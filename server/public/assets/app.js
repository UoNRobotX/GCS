/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _keenUi = __webpack_require__(3);
	
	var _keenUi2 = _interopRequireDefault(_keenUi);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _store = __webpack_require__(136);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_keenUi2.default);
	
	var app = new _vue2.default({
	    el: 'body',
	    components: {
	        App: _App2.default
	    },
	    store: _store2.default
	});
	
	window.app = app;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Keen UI v0.8.9 (https://github.com/JosephusPaye/keen-ui)
	 * (c) 2016 Josephus Paye II
	 * Released under the MIT License.
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Keen"] = factory();
		else
			root["Keen"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		__webpack_require__(1);
		
		var _UiAlert = __webpack_require__(2);
		
		var _UiAlert2 = _interopRequireDefault(_UiAlert);
		
		var _UiAutocomplete = __webpack_require__(81);
		
		var _UiAutocomplete2 = _interopRequireDefault(_UiAutocomplete);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		var _UiCheckbox = __webpack_require__(113);
		
		var _UiCheckbox2 = _interopRequireDefault(_UiCheckbox);
		
		var _UiCollapsible = __webpack_require__(117);
		
		var _UiCollapsible2 = _interopRequireDefault(_UiCollapsible);
		
		var _UiConfirm = __webpack_require__(121);
		
		var _UiConfirm2 = _interopRequireDefault(_UiConfirm);
		
		var _UiFab = __webpack_require__(129);
		
		var _UiFab2 = _interopRequireDefault(_UiFab);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiMenuOption = __webpack_require__(16);
		
		var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);
		
		var _UiModal = __webpack_require__(124);
		
		var _UiModal2 = _interopRequireDefault(_UiModal);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiPreloader = __webpack_require__(133);
		
		var _UiPreloader2 = _interopRequireDefault(_UiPreloader);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _UiProgressLinear = __webpack_require__(137);
		
		var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);
		
		var _UiRadio = __webpack_require__(141);
		
		var _UiRadio2 = _interopRequireDefault(_UiRadio);
		
		var _UiRadioGroup = __webpack_require__(145);
		
		var _UiRadioGroup2 = _interopRequireDefault(_UiRadioGroup);
		
		var _UiRating = __webpack_require__(149);
		
		var _UiRating2 = _interopRequireDefault(_UiRating);
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		var _UiRatingPreview = __webpack_require__(157);
		
		var _UiRatingPreview2 = _interopRequireDefault(_UiRatingPreview);
		
		var _UiRippleInk = __webpack_require__(20);
		
		var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);
		
		var _UiSelect = __webpack_require__(161);
		
		var _UiSelect2 = _interopRequireDefault(_UiSelect);
		
		var _UiSlider = __webpack_require__(172);
		
		var _UiSlider2 = _interopRequireDefault(_UiSlider);
		
		var _UiSnackbar = __webpack_require__(184);
		
		var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);
		
		var _UiSnackbarContainer = __webpack_require__(188);
		
		var _UiSnackbarContainer2 = _interopRequireDefault(_UiSnackbarContainer);
		
		var _UiSwitch = __webpack_require__(192);
		
		var _UiSwitch2 = _interopRequireDefault(_UiSwitch);
		
		var _UiTab = __webpack_require__(196);
		
		var _UiTab2 = _interopRequireDefault(_UiTab);
		
		var _UiTabs = __webpack_require__(200);
		
		var _UiTabs2 = _interopRequireDefault(_UiTabs);
		
		var _UiTextbox = __webpack_require__(208);
		
		var _UiTextbox2 = _interopRequireDefault(_UiTextbox);
		
		var _UiToolbar = __webpack_require__(212);
		
		var _UiToolbar2 = _interopRequireDefault(_UiToolbar);
		
		var _UiTooltip = __webpack_require__(74);
		
		var _UiTooltip2 = _interopRequireDefault(_UiTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var Keen = {
		    UiAlert: _UiAlert2.default,
		    UiAutocomplete: _UiAutocomplete2.default,
		    UiButton: _UiButton2.default,
		    UiCheckbox: _UiCheckbox2.default,
		    UiCollapsible: _UiCollapsible2.default,
		    UiConfirm: _UiConfirm2.default,
		    UiFab: _UiFab2.default,
		    UiIcon: _UiIcon2.default,
		    UiIconButton: _UiIconButton2.default,
		    UiMenu: _UiMenu2.default,
		    UiMenuOption: _UiMenuOption2.default,
		    UiModal: _UiModal2.default,
		    UiPopover: _UiPopover2.default,
		    UiPreloader: _UiPreloader2.default,
		    UiProgressCircular: _UiProgressCircular2.default,
		    UiProgressLinear: _UiProgressLinear2.default,
		    UiRadio: _UiRadio2.default,
		    UiRadioGroup: _UiRadioGroup2.default,
		    UiRating: _UiRating2.default,
		    UiRatingIcon: _UiRatingIcon2.default,
		    UiRatingPreview: _UiRatingPreview2.default,
		    UiRippleInk: _UiRippleInk2.default,
		    UiSelect: _UiSelect2.default,
		    UiSlider: _UiSlider2.default,
		    UiSnackbar: _UiSnackbar2.default,
		    UiSnackbarContainer: _UiSnackbarContainer2.default,
		    UiSwitch: _UiSwitch2.default,
		    UiTab: _UiTab2.default,
		    UiTabs: _UiTabs2.default,
		    UiTextbox: _UiTextbox2.default,
		    UiToolbar: _UiToolbar2.default,
		    UiTooltip: _UiTooltip2.default,
		
		    install: function install(Vue) {
		        Vue.component('ui-alert', _UiAlert2.default);
		        Vue.component('ui-autocomplete', _UiAutocomplete2.default);
		        Vue.component('ui-button', _UiButton2.default);
		        Vue.component('ui-checkbox', _UiCheckbox2.default);
		        Vue.component('ui-collapsible', _UiCollapsible2.default);
		        Vue.component('ui-confirm', _UiConfirm2.default);
		        Vue.component('ui-fab', _UiFab2.default);
		        Vue.component('ui-icon', _UiIcon2.default);
		        Vue.component('ui-icon-button', _UiIconButton2.default);
		        Vue.component('ui-menu', _UiMenu2.default);
		        Vue.component('ui-menu-option', _UiMenuOption2.default);
		        Vue.component('ui-modal', _UiModal2.default);
		        Vue.component('ui-popover', _UiPopover2.default);
		        Vue.component('ui-preloader', _UiPreloader2.default);
		        Vue.component('ui-progress-circular', _UiProgressCircular2.default);
		        Vue.component('ui-progress-linear', _UiProgressLinear2.default);
		        Vue.component('ui-radio', _UiRadio2.default);
		        Vue.component('ui-radio-group', _UiRadioGroup2.default);
		        Vue.component('ui-rating', _UiRating2.default);
		        Vue.component('ui-rating-icon', _UiRatingIcon2.default);
		        Vue.component('ui-rating-preview', _UiRatingPreview2.default);
		        Vue.component('ui-ripple-ink', _UiRippleInk2.default);
		        Vue.component('ui-select', _UiSelect2.default);
		        Vue.component('ui-slider', _UiSlider2.default);
		        Vue.component('ui-snackbar', _UiSnackbar2.default);
		        Vue.component('ui-snackbar-container', _UiSnackbarContainer2.default);
		        Vue.component('ui-switch', _UiSwitch2.default);
		        Vue.component('ui-tab', _UiTab2.default);
		        Vue.component('ui-tabs', _UiTabs2.default);
		        Vue.component('ui-textbox', _UiTextbox2.default);
		        Vue.component('ui-toolbar', _UiToolbar2.default);
		        Vue.component('ui-tooltip', _UiTooltip2.default);
		    }
		};
		
		module.exports = Keen;
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		'use strict';
		
		document.addEventListener('DOMContentLoaded', function () {
		    var hadKeyboardEvent = false;
		    var keyboardModalityWhitelist = ['input:not([type])', 'input[type=text]', 'input[type=number]', 'input[type=date]', 'input[type=time]', 'input[type=datetime]', 'textarea', '[role=textbox]', '[supports-modality=keyboard]'].join(',');
		
		    var isHandlingKeyboardThrottle;
		
		    var matcher = function () {
		        var el = document.body;
		
		        if (el.matchesSelector) {
		            return el.matchesSelector;
		        }
		
		        if (el.webkitMatchesSelector) {
		            return el.webkitMatchesSelector;
		        }
		
		        if (el.mozMatchesSelector) {
		            return el.mozMatchesSelector;
		        }
		
		        if (el.msMatchesSelector) {
		            return el.msMatchesSelector;
		        }
		
		        console.error('Couldn\'t find any matchesSelector method on document.body.');
		    }();
		
		    var disableFocusRingByDefault = function disableFocusRingByDefault() {
		        var css = 'body:not([modality=keyboard]) :focus { outline: none; }';
		        var head = document.head || document.getElementsByTagName('head')[0];
		        var style = document.createElement('style');
		
		        style.type = 'text/css';
		        style.id = 'disable-focus-ring';
		
		        if (style.styleSheet) {
		            style.styleSheet.cssText = css;
		        } else {
		            style.appendChild(document.createTextNode(css));
		        }
		
		        head.insertBefore(style, head.firstChild);
		    };
		
		    var focusTriggersKeyboardModality = function focusTriggersKeyboardModality(el) {
		        var triggers = false;
		
		        if (matcher) {
		            triggers = matcher.call(el, keyboardModalityWhitelist) && matcher.call(el, ':not([readonly])');
		        }
		
		        return triggers;
		    };
		
		    disableFocusRingByDefault();
		
		    document.body.addEventListener('keydown', function () {
		        hadKeyboardEvent = true;
		
		        if (isHandlingKeyboardThrottle) {
		            clearTimeout(isHandlingKeyboardThrottle);
		        }
		
		        isHandlingKeyboardThrottle = setTimeout(function () {
		            hadKeyboardEvent = false;
		        }, 100);
		    }, true);
		
		    document.body.addEventListener('focus', function (e) {
		        if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
		            document.body.setAttribute('modality', 'keyboard');
		        }
		    }, true);
		
		    document.body.addEventListener('blur', function () {
		        document.body.removeAttribute('modality');
		    }, true);
		});
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(3)
		__vue_script__ = __webpack_require__(5)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAlert.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(80)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAlert.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 4 */,
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-alert',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: true
		        },
		        type: {
		            type: String,
		            default: 'info' },
		        text: String,
		        icon: String,
		        hideIcon: {
		            type: Boolean,
		            default: false
		        },
		        dismissible: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    computed: {
		        iconName: function iconName() {
		            if (this.icon) {
		                return this.icon;
		            }
		
		            var icon = this.type;
		
		            if (icon === 'success') {
		                icon = 'check_circle';
		            }
		
		            return icon;
		        }
		    },
		
		    methods: {
		        close: function close() {
		            this.show = false;
		            this.$dispatch('dismissed');
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiIconButton: _UiIconButton2.default
		    }
		};
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(7)
		__vue_script__ = __webpack_require__(8)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiIcon.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(9)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiIcon.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-icon',
		
		    props: {
		        icon: {
		            type: String,
		            required: true
		        },
		        removeText: {
		            type: Boolean,
		            default: false
		        }
		    }
		};
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
		module.exports = "\n<i\n    class=\"ui-icon material-icons\" :class=\"[icon]\" v-text=\"removeText ? null : icon\"\n    aria-hidden=\"true\"\n></i>\n";
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(11)
		__vue_script__ = __webpack_require__(12)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiIconButton.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(79)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiIconButton.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 11 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _HasDropdown = __webpack_require__(72);
		
		var _HasDropdown2 = _interopRequireDefault(_HasDropdown);
		
		var _ShowsTooltip = __webpack_require__(73);
		
		var _ShowsTooltip2 = _interopRequireDefault(_ShowsTooltip);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-icon-button',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-icon-button-' + type;
		            }
		        },
		        buttonType: {
		            type: String,
		            default: 'button'
		        },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        icon: {
		            type: String,
		            required: true
		        },
		        ariaLabel: String,
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.color];
		
		            if (this.hasDropdown) {
		                classes.push('ui-dropdown');
		            }
		
		            return classes;
		        },
		        spinnerColor: function spinnerColor() {
		            if (this.color === 'color-default' || this.color === 'color-black') {
		                return 'black';
		            }
		
		            return 'white';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiMenu: _UiMenu2.default,
		        UiPopover: _UiPopover2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasDropdown2.default, _ShowsTooltip2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(14)
		__vue_script__ = __webpack_require__(15)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiMenu.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(62)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiMenu.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 14 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiMenuOption = __webpack_require__(16);
		
		var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);
		
		var _ShowsDropdown = __webpack_require__(58);
		
		var _ShowsDropdown2 = _interopRequireDefault(_ShowsDropdown);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-menu',
		
		    props: {
		        options: {
		            type: Array,
		            required: true,
		            default: function _default() {
		                return [];
		            }
		        },
		        showIcons: {
		            type: Boolean,
		            default: false
		        },
		        showSecondaryText: {
		            type: Boolean,
		            default: false
		        },
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        },
		        closeOnSelect: {
		            type: Boolean,
		            default: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-menu-default'
		        }
		    },
		
		    events: {
		        'dropdown-opened': function dropdownOpened() {
		            if (this.containFocus) {
		                document.addEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('opened');
		
		            return true;
		        },
		
		        'dropdown-closed': function dropdownClosed() {
		            if (this.containFocus) {
		                document.removeEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('closed');
		
		            return true;
		        }
		    },
		
		    methods: {
		        optionSelect: function optionSelect(option) {
		            if (!(option.disabled || option.type === 'divider')) {
		                this.$dispatch('option-selected', option);
		
		                if (this.closeOnSelect) {
		                    this.closeDropdown();
		                }
		            }
		        },
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.dropdown.contains(e.target)) {
		                e.stopPropagation();
		
		                this.$els.dropdown.querySelector('.ui-menu-option').focus();
		            }
		        },
		        redirectFocus: function redirectFocus(e) {
		            e.stopPropagation();
		
		            this.$els.dropdown.querySelector('.ui-menu-option').focus();
		        }
		    },
		
		    components: {
		        UiMenuOption: _UiMenuOption2.default
		    },
		
		    mixins: [_ShowsDropdown2.default]
		};
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(17)
		__vue_script__ = __webpack_require__(18)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiMenuOption.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(57)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiMenuOption.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 17 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-menu-option',
		
		    props: {
		        type: String,
		        text: String,
		        icon: String,
		        showIcon: {
		            type: Boolean,
		            default: false
		        },
		        secondaryText: String,
		        showSecondaryText: {
		            type: Boolean,
		            default: false
		        },
		        partial: {
		            type: String,
		            default: 'ui-menu-default'
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        },
		        option: Object
		    },
		
		    computed: {
		        isDivider: function isDivider() {
		            return this.type === 'divider';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    partials: {
		        'ui-menu-default': '\n            <ui-icon\n                class="ui-menu-option-icon" :icon="icon" v-if="showIcon && !isDivider && icon"\n            ></ui-icon>\n\n            <div class="ui-menu-option-text" v-text="text" v-if="!isDivider"></div>\n\n            <div\n                class="ui-menu-option-secondary-text" v-text="secondaryText"\n                v-if="showSecondaryText && !isDivider && secondaryText"\n            ></div>\n        '
		    },
		
		    mixins: [_ShowsRippleInk2.default]
		};
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRippleInk = __webpack_require__(20);
		
		var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiRippleInk: _UiRippleInk2.default
		    }
		};
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(21)
		__vue_script__ = __webpack_require__(22)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRippleInk.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(56)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRippleInk.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 21 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var startRipple = function startRipple(eventType, event) {
		    var holder = event.currentTarget;
		
		    if (!_classlist2.default.has(holder, 'ui-ripple-ink')) {
		        holder = holder.querySelector('.ui-ripple-ink');
		
		        if (!holder) {
		            return;
		        }
		    }
		
		    var prev = holder.getAttribute('data-ui-event');
		
		    if (prev && prev !== eventType) {
		        return;
		    }
		
		    holder.setAttribute('data-ui-event', eventType);
		
		    var rect = holder.getBoundingClientRect();
		    var x = event.offsetX;
		    var y;
		
		    if (x !== undefined) {
		        y = event.offsetY;
		    } else {
		        x = event.clientX - rect.left;
		        y = event.clientY - rect.top;
		    }
		
		    var ripple = document.createElement('div');
		    var max;
		
		    if (rect.width === rect.height) {
		        max = rect.width * 1.412;
		    } else {
		        max = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
		    }
		
		    var dim = max * 2 + 'px';
		
		    ripple.style.width = dim;
		    ripple.style.height = dim;
		    ripple.style.marginLeft = -max + x + 'px';
		    ripple.style.marginTop = -max + y + 'px';
		
		    ripple.className = 'ripple';
		    holder.appendChild(ripple);
		
		    setTimeout(function () {
		        _classlist2.default.add(ripple, 'held');
		    }, 0);
		
		    var releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';
		
		    var release = function release() {
		        document.removeEventListener(releaseEvent, release);
		
		        _classlist2.default.add(ripple, 'done');
		
		        setTimeout(function () {
		            holder.removeChild(ripple);
		
		            if (!holder.children.length) {
		                _classlist2.default.remove(holder, 'active');
		                holder.removeAttribute('data-ui-event');
		            }
		        }, 450);
		    };
		
		    document.addEventListener(releaseEvent, release);
		};
		
		var handleMouseDown = function handleMouseDown(e) {
		    if (e.button === 0) {
		        startRipple(e.type, e);
		    }
		};
		
		var handleTouchStart = function handleTouchStart(e) {
		    if (e.changedTouches) {
		        for (var i = 0; i < e.changedTouches.length; ++i) {
		            startRipple(e.type, e.changedTouches[i]);
		        }
		    }
		};
		
		exports.default = {
		    name: 'ui-ripple-ink',
		
		    props: {
		        trigger: {
		            type: Element,
		            required: true
		        }
		    },
		
		    watch: {
		        trigger: function trigger() {
		            this.initialize();
		        }
		    },
		
		    ready: function ready() {
		        this.initialize();
		    },
		    beforeDestory: function beforeDestory() {
		        if (this.trigger) {
		            this.trigger.removeEventListener('mousedown', handleMouseDown);
		            this.trigger.removeEventListener('touchstart', handleTouchStart);
		        }
		    },
		
		
		    methods: {
		        initialize: function initialize() {
		            if (this.trigger) {
		                this.trigger.addEventListener('touchstart', handleTouchStart);
		                this.trigger.addEventListener('mousedown', handleMouseDown);
		            }
		        }
		    }
		};
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _typeof2 = __webpack_require__(24);
		
		var _typeof3 = _interopRequireDefault(_typeof2);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var trim = /^\s+|\s+$/g;
		var whitespace = /\s+/g;
		
		function interpret(input) {
		    return typeof input === 'string' ? input.replace(trim, '').split(whitespace) : input;
		}
		
		function classes(el) {
		    if (isElement(el)) {
		        return el.className.replace(trim, '').split(whitespace);
		    }
		
		    return [];
		}
		
		function set(el, input) {
		    if (isElement(el)) {
		        el.className = interpret(input).join(' ');
		    }
		}
		
		function add(el, input) {
		    var current = remove(el, input);
		    var values = interpret(input);
		
		    current.push.apply(current, values);
		    set(el, current);
		
		    return current;
		}
		
		function remove(el, input) {
		    var current = classes(el);
		    var values = interpret(input);
		
		    values.forEach(function (value) {
		        var i = current.indexOf(value);
		        if (i !== -1) {
		            current.splice(i, 1);
		        }
		    });
		
		    set(el, current);
		
		    return current;
		}
		
		function contains(el, input) {
		    var current = classes(el);
		    var values = interpret(input);
		
		    return values.every(function (value) {
		        return current.indexOf(value) !== -1;
		    });
		}
		
		function isElement(o) {
		    var elementObjects = (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object';
		
		    return elementObjects ? o instanceof HTMLElement : isElementObject(o);
		}
		
		function isElementObject(o) {
		    return o && (typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) === 'object' && typeof o.nodeName === 'string' && o.nodeType === 1;
		}
		
		exports.default = {
		    add: add,
		    remove: remove,
		    contains: contains,
		    has: contains,
		    set: set,
		    get: classes
		};
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		var _Symbol = __webpack_require__(25)["default"];
		
		exports["default"] = function (obj) {
		  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
		};
		
		exports.__esModule = true;
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = { "default": __webpack_require__(26), __esModule: true };
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(27);
		__webpack_require__(55);
		module.exports = __webpack_require__(34).Symbol;
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// ECMAScript 6 symbols shim
		var $              = __webpack_require__(28)
		  , global         = __webpack_require__(29)
		  , has            = __webpack_require__(30)
		  , DESCRIPTORS    = __webpack_require__(31)
		  , $export        = __webpack_require__(33)
		  , redefine       = __webpack_require__(37)
		  , $fails         = __webpack_require__(32)
		  , shared         = __webpack_require__(40)
		  , setToStringTag = __webpack_require__(41)
		  , uid            = __webpack_require__(43)
		  , wks            = __webpack_require__(42)
		  , keyOf          = __webpack_require__(44)
		  , $names         = __webpack_require__(49)
		  , enumKeys       = __webpack_require__(50)
		  , isArray        = __webpack_require__(51)
		  , anObject       = __webpack_require__(52)
		  , toIObject      = __webpack_require__(45)
		  , createDesc     = __webpack_require__(39)
		  , getDesc        = $.getDesc
		  , setDesc        = $.setDesc
		  , _create        = $.create
		  , getNames       = $names.get
		  , $Symbol        = global.Symbol
		  , $JSON          = global.JSON
		  , _stringify     = $JSON && $JSON.stringify
		  , setter         = false
		  , HIDDEN         = wks('_hidden')
		  , isEnum         = $.isEnum
		  , SymbolRegistry = shared('symbol-registry')
		  , AllSymbols     = shared('symbols')
		  , useNative      = typeof $Symbol == 'function'
		  , ObjectProto    = Object.prototype;
		
		// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
		var setSymbolDesc = DESCRIPTORS && $fails(function(){
		  return _create(setDesc({}, 'a', {
		    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
		  })).a != 7;
		}) ? function(it, key, D){
		  var protoDesc = getDesc(ObjectProto, key);
		  if(protoDesc)delete ObjectProto[key];
		  setDesc(it, key, D);
		  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
		} : setDesc;
		
		var wrap = function(tag){
		  var sym = AllSymbols[tag] = _create($Symbol.prototype);
		  sym._k = tag;
		  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
		    configurable: true,
		    set: function(value){
		      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
		      setSymbolDesc(this, tag, createDesc(1, value));
		    }
		  });
		  return sym;
		};
		
		var isSymbol = function(it){
		  return typeof it == 'symbol';
		};
		
		var $defineProperty = function defineProperty(it, key, D){
		  if(D && has(AllSymbols, key)){
		    if(!D.enumerable){
		      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
		      it[HIDDEN][key] = true;
		    } else {
		      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
		      D = _create(D, {enumerable: createDesc(0, false)});
		    } return setSymbolDesc(it, key, D);
		  } return setDesc(it, key, D);
		};
		var $defineProperties = function defineProperties(it, P){
		  anObject(it);
		  var keys = enumKeys(P = toIObject(P))
		    , i    = 0
		    , l = keys.length
		    , key;
		  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
		  return it;
		};
		var $create = function create(it, P){
		  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
		};
		var $propertyIsEnumerable = function propertyIsEnumerable(key){
		  var E = isEnum.call(this, key);
		  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
		    ? E : true;
		};
		var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
		  var D = getDesc(it = toIObject(it), key);
		  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
		  return D;
		};
		var $getOwnPropertyNames = function getOwnPropertyNames(it){
		  var names  = getNames(toIObject(it))
		    , result = []
		    , i      = 0
		    , key;
		  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
		  return result;
		};
		var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
		  var names  = getNames(toIObject(it))
		    , result = []
		    , i      = 0
		    , key;
		  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
		  return result;
		};
		var $stringify = function stringify(it){
		  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
		  var args = [it]
		    , i    = 1
		    , $$   = arguments
		    , replacer, $replacer;
		  while($$.length > i)args.push($$[i++]);
		  replacer = args[1];
		  if(typeof replacer == 'function')$replacer = replacer;
		  if($replacer || !isArray(replacer))replacer = function(key, value){
		    if($replacer)value = $replacer.call(this, key, value);
		    if(!isSymbol(value))return value;
		  };
		  args[1] = replacer;
		  return _stringify.apply($JSON, args);
		};
		var buggyJSON = $fails(function(){
		  var S = $Symbol();
		  // MS Edge converts symbol values to JSON as {}
		  // WebKit converts symbol values to JSON as null
		  // V8 throws on boxed symbols
		  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
		});
		
		// 19.4.1.1 Symbol([description])
		if(!useNative){
		  $Symbol = function Symbol(){
		    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
		    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
		  };
		  redefine($Symbol.prototype, 'toString', function toString(){
		    return this._k;
		  });
		
		  isSymbol = function(it){
		    return it instanceof $Symbol;
		  };
		
		  $.create     = $create;
		  $.isEnum     = $propertyIsEnumerable;
		  $.getDesc    = $getOwnPropertyDescriptor;
		  $.setDesc    = $defineProperty;
		  $.setDescs   = $defineProperties;
		  $.getNames   = $names.get = $getOwnPropertyNames;
		  $.getSymbols = $getOwnPropertySymbols;
		
		  if(DESCRIPTORS && !__webpack_require__(54)){
		    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
		  }
		}
		
		var symbolStatics = {
		  // 19.4.2.1 Symbol.for(key)
		  'for': function(key){
		    return has(SymbolRegistry, key += '')
		      ? SymbolRegistry[key]
		      : SymbolRegistry[key] = $Symbol(key);
		  },
		  // 19.4.2.5 Symbol.keyFor(sym)
		  keyFor: function keyFor(key){
		    return keyOf(SymbolRegistry, key);
		  },
		  useSetter: function(){ setter = true; },
		  useSimple: function(){ setter = false; }
		};
		// 19.4.2.2 Symbol.hasInstance
		// 19.4.2.3 Symbol.isConcatSpreadable
		// 19.4.2.4 Symbol.iterator
		// 19.4.2.6 Symbol.match
		// 19.4.2.8 Symbol.replace
		// 19.4.2.9 Symbol.search
		// 19.4.2.10 Symbol.species
		// 19.4.2.11 Symbol.split
		// 19.4.2.12 Symbol.toPrimitive
		// 19.4.2.13 Symbol.toStringTag
		// 19.4.2.14 Symbol.unscopables
		$.each.call((
		  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
		  'species,split,toPrimitive,toStringTag,unscopables'
		).split(','), function(it){
		  var sym = wks(it);
		  symbolStatics[it] = useNative ? sym : wrap(sym);
		});
		
		setter = true;
		
		$export($export.G + $export.W, {Symbol: $Symbol});
		
		$export($export.S, 'Symbol', symbolStatics);
		
		$export($export.S + $export.F * !useNative, 'Object', {
		  // 19.1.2.2 Object.create(O [, Properties])
		  create: $create,
		  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
		  defineProperty: $defineProperty,
		  // 19.1.2.3 Object.defineProperties(O, Properties)
		  defineProperties: $defineProperties,
		  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
		  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
		  // 19.1.2.7 Object.getOwnPropertyNames(O)
		  getOwnPropertyNames: $getOwnPropertyNames,
		  // 19.1.2.8 Object.getOwnPropertySymbols(O)
		  getOwnPropertySymbols: $getOwnPropertySymbols
		});
		
		// 24.3.2 JSON.stringify(value [, replacer [, space]])
		$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
		
		// 19.4.3.5 Symbol.prototype[@@toStringTag]
		setToStringTag($Symbol, 'Symbol');
		// 20.2.1.9 Math[@@toStringTag]
		setToStringTag(Math, 'Math', true);
		// 24.3.3 JSON[@@toStringTag]
		setToStringTag(global.JSON, 'JSON', true);
	
	/***/ },
	/* 28 */
	/***/ function(module, exports) {
	
		var $Object = Object;
		module.exports = {
		  create:     $Object.create,
		  getProto:   $Object.getPrototypeOf,
		  isEnum:     {}.propertyIsEnumerable,
		  getDesc:    $Object.getOwnPropertyDescriptor,
		  setDesc:    $Object.defineProperty,
		  setDescs:   $Object.defineProperties,
		  getKeys:    $Object.keys,
		  getNames:   $Object.getOwnPropertyNames,
		  getSymbols: $Object.getOwnPropertySymbols,
		  each:       [].forEach
		};
	
	/***/ },
	/* 29 */
	/***/ function(module, exports) {
	
		// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		var global = module.exports = typeof window != 'undefined' && window.Math == Math
		  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
		if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
	
	/***/ },
	/* 30 */
	/***/ function(module, exports) {
	
		var hasOwnProperty = {}.hasOwnProperty;
		module.exports = function(it, key){
		  return hasOwnProperty.call(it, key);
		};
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Thank's IE8 for his funny defineProperty
		module.exports = !__webpack_require__(32)(function(){
		  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
		});
	
	/***/ },
	/* 32 */
	/***/ function(module, exports) {
	
		module.exports = function(exec){
		  try {
		    return !!exec();
		  } catch(e){
		    return true;
		  }
		};
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global    = __webpack_require__(29)
		  , core      = __webpack_require__(34)
		  , ctx       = __webpack_require__(35)
		  , PROTOTYPE = 'prototype';
		
		var $export = function(type, name, source){
		  var IS_FORCED = type & $export.F
		    , IS_GLOBAL = type & $export.G
		    , IS_STATIC = type & $export.S
		    , IS_PROTO  = type & $export.P
		    , IS_BIND   = type & $export.B
		    , IS_WRAP   = type & $export.W
		    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
		    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
		    , key, own, out;
		  if(IS_GLOBAL)source = name;
		  for(key in source){
		    // contains in native
		    own = !IS_FORCED && target && key in target;
		    if(own && key in exports)continue;
		    // export native or passed
		    out = own ? target[key] : source[key];
		    // prevent global pollution for namespaces
		    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
		    // bind timers to global for call from export context
		    : IS_BIND && own ? ctx(out, global)
		    // wrap global constructors for prevent change them in library
		    : IS_WRAP && target[key] == out ? (function(C){
		      var F = function(param){
		        return this instanceof C ? new C(param) : C(param);
		      };
		      F[PROTOTYPE] = C[PROTOTYPE];
		      return F;
		    // make static versions for prototype methods
		    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
		    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
		  }
		};
		// type bitmap
		$export.F = 1;  // forced
		$export.G = 2;  // global
		$export.S = 4;  // static
		$export.P = 8;  // proto
		$export.B = 16; // bind
		$export.W = 32; // wrap
		module.exports = $export;
	
	/***/ },
	/* 34 */
	/***/ function(module, exports) {
	
		var core = module.exports = {version: '1.2.6'};
		if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		// optional / simple context binding
		var aFunction = __webpack_require__(36);
		module.exports = function(fn, that, length){
		  aFunction(fn);
		  if(that === undefined)return fn;
		  switch(length){
		    case 1: return function(a){
		      return fn.call(that, a);
		    };
		    case 2: return function(a, b){
		      return fn.call(that, a, b);
		    };
		    case 3: return function(a, b, c){
		      return fn.call(that, a, b, c);
		    };
		  }
		  return function(/* ...args */){
		    return fn.apply(that, arguments);
		  };
		};
	
	/***/ },
	/* 36 */
	/***/ function(module, exports) {
	
		module.exports = function(it){
		  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
		  return it;
		};
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(38);
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $          = __webpack_require__(28)
		  , createDesc = __webpack_require__(39);
		module.exports = __webpack_require__(31) ? function(object, key, value){
		  return $.setDesc(object, key, createDesc(1, value));
		} : function(object, key, value){
		  object[key] = value;
		  return object;
		};
	
	/***/ },
	/* 39 */
	/***/ function(module, exports) {
	
		module.exports = function(bitmap, value){
		  return {
		    enumerable  : !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable    : !(bitmap & 4),
		    value       : value
		  };
		};
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global = __webpack_require__(29)
		  , SHARED = '__core-js_shared__'
		  , store  = global[SHARED] || (global[SHARED] = {});
		module.exports = function(key){
		  return store[key] || (store[key] = {});
		};
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		var def = __webpack_require__(28).setDesc
		  , has = __webpack_require__(30)
		  , TAG = __webpack_require__(42)('toStringTag');
		
		module.exports = function(it, tag, stat){
		  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
		};
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		var store  = __webpack_require__(40)('wks')
		  , uid    = __webpack_require__(43)
		  , Symbol = __webpack_require__(29).Symbol;
		module.exports = function(name){
		  return store[name] || (store[name] =
		    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
		};
	
	/***/ },
	/* 43 */
	/***/ function(module, exports) {
	
		var id = 0
		  , px = Math.random();
		module.exports = function(key){
		  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
		};
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $         = __webpack_require__(28)
		  , toIObject = __webpack_require__(45);
		module.exports = function(object, el){
		  var O      = toIObject(object)
		    , keys   = $.getKeys(O)
		    , length = keys.length
		    , index  = 0
		    , key;
		  while(length > index)if(O[key = keys[index++]] === el)return key;
		};
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		// to indexed object, toObject with fallback for non-array-like ES3 strings
		var IObject = __webpack_require__(46)
		  , defined = __webpack_require__(48);
		module.exports = function(it){
		  return IObject(defined(it));
		};
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		// fallback for non-array-like ES3 and non-enumerable old V8 strings
		var cof = __webpack_require__(47);
		module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
		  return cof(it) == 'String' ? it.split('') : Object(it);
		};
	
	/***/ },
	/* 47 */
	/***/ function(module, exports) {
	
		var toString = {}.toString;
		
		module.exports = function(it){
		  return toString.call(it).slice(8, -1);
		};
	
	/***/ },
	/* 48 */
	/***/ function(module, exports) {
	
		// 7.2.1 RequireObjectCoercible(argument)
		module.exports = function(it){
		  if(it == undefined)throw TypeError("Can't call method on  " + it);
		  return it;
		};
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
		// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
		var toIObject = __webpack_require__(45)
		  , getNames  = __webpack_require__(28).getNames
		  , toString  = {}.toString;
		
		var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
		  ? Object.getOwnPropertyNames(window) : [];
		
		var getWindowNames = function(it){
		  try {
		    return getNames(it);
		  } catch(e){
		    return windowNames.slice();
		  }
		};
		
		module.exports.get = function getOwnPropertyNames(it){
		  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
		  return getNames(toIObject(it));
		};
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		// all enumerable object keys, includes symbols
		var $ = __webpack_require__(28);
		module.exports = function(it){
		  var keys       = $.getKeys(it)
		    , getSymbols = $.getSymbols;
		  if(getSymbols){
		    var symbols = getSymbols(it)
		      , isEnum  = $.isEnum
		      , i       = 0
		      , key;
		    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
		  }
		  return keys;
		};
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 7.2.2 IsArray(argument)
		var cof = __webpack_require__(47);
		module.exports = Array.isArray || function(arg){
		  return cof(arg) == 'Array';
		};
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObject = __webpack_require__(53);
		module.exports = function(it){
		  if(!isObject(it))throw TypeError(it + ' is not an object!');
		  return it;
		};
	
	/***/ },
	/* 53 */
	/***/ function(module, exports) {
	
		module.exports = function(it){
		  return typeof it === 'object' ? it !== null : typeof it === 'function';
		};
	
	/***/ },
	/* 54 */
	/***/ function(module, exports) {
	
		module.exports = true;
	
	/***/ },
	/* 55 */
	/***/ function(module, exports) {
	
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-ripple-ink\"></div>\n";
	
	/***/ },
	/* 57 */
	/***/ function(module, exports) {
	
		module.exports = "\n<a\n    class=\"ui-menu-option\" role=\"menu-item\" :tabindex=\"(isDivider || disabled) ? null : '0'\"\n    :class=\"{ 'divider': isDivider, 'disabled' : disabled }\"\n>\n    <div class=\"ui-menu-option-content\" :class=\"[partial]\">\n        <partial :name=\"partial\"></partial>\n    </div>\n\n    <ui-ripple-ink\n        :trigger=\"$el\" v-if=\"!hideRippleInk && !disabled && !isDivider\"\n    ></ui-ripple-ink>\n</a>\n";
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _tetherDrop = __webpack_require__(59);
		
		var _tetherDrop2 = _interopRequireDefault(_tetherDrop);
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        id: String,
		        trigger: Element,
		        containFocus: {
		            type: Boolean,
		            default: true
		        },
		        dropdownPosition: {
		            type: String,
		            default: 'bottom left'
		        },
		        openOn: {
		            type: String,
		            default: 'click' }
		    },
		
		    data: function data() {
		        return {
		            drop: null,
		            lastFocussedElement: null
		        };
		    },
		    ready: function ready() {
		        if (this.trigger) {
		            this.initializeDropdown();
		        }
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.drop) {
		            this.drop.remove();
		            this.drop.destroy();
		        }
		    },
		
		
		    events: {
		        'ui-dropdown::open': function uiDropdownOpen(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.openDropdown();
		        },
		
		        'ui-dropdown::close': function uiDropdownClose(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.closeDropdown();
		        },
		
		        'ui-dropdown::toggle': function uiDropdownToggle(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.toggleDropdown();
		        }
		    },
		
		    methods: {
		        initializeDropdown: function initializeDropdown() {
		            this.drop = new _tetherDrop2.default({
		                target: this.trigger,
		                content: this.$els.dropdown,
		                position: this.dropdownPosition,
		                constrainToWindow: true,
		                openOn: this.openOn
		            });
		
		            if (this.dropdownPosition !== 'bottom left') {
		                this.drop.open();
		                this.drop.close();
		                this.drop.open();
		                this.drop.close();
		            }
		
		            this.drop.on('open', this.positionDrop);
		            this.drop.on('open', this.dropdownOpened);
		            this.drop.on('close', this.dropdownClosed);
		        },
		        openDropdown: function openDropdown() {
		            if (this.drop) {
		                this.drop.open();
		            }
		        },
		        positionDrop: function positionDrop() {
		            var drop = this.drop;
		            var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		
		            var dropWidth = drop.drop.getBoundingClientRect().width;
		            var left = drop.target.getBoundingClientRect().left;
		            var availableSpace = windowWidth - left;
		
		            if (dropWidth > availableSpace) {
		                var direction = dropWidth > availableSpace ? 'right' : 'left';
		
		                drop.tether.attachment.left = direction;
		                drop.tether.targetAttachment.left = direction;
		
		                drop.position();
		            }
		        },
		        closeDropdown: function closeDropdown() {
		            if (this.drop) {
		                this.drop.close();
		            }
		        },
		        toggleDropdown: function toggleDropdown(e) {
		            if (this.drop) {
		                this.drop.toggle(e);
		            }
		        },
		        dropdownOpened: function dropdownOpened() {
		            _classlist2.default.add(this.trigger, 'dropdown-open');
		
		            this.lastFocussedElement = document.activeElement;
		            this.$els.dropdown.focus();
		
		            this.$dispatch('dropdown-opened');
		        },
		        dropdownClosed: function dropdownClosed() {
		            _classlist2.default.remove(this.trigger, 'dropdown-open');
		
		            if (this.lastFocussedElement) {
		                this.lastFocussedElement.focus();
		            }
		
		            this.$dispatch('dropdown-closed');
		        }
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether-drop 1.4.1 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require('tether'));
		  } else {
		    root.Drop = factory(root.Tether);
		  }
		}(this, function(Tether) {
		
		/* global Tether */
		'use strict';
		
		var _bind = Function.prototype.bind;
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var _Tether$Utils = Tether.Utils;
		var extend = _Tether$Utils.extend;
		var addClass = _Tether$Utils.addClass;
		var removeClass = _Tether$Utils.removeClass;
		var hasClass = _Tether$Utils.hasClass;
		var Evented = _Tether$Utils.Evented;
		
		function sortAttach(str) {
		  var _str$split = str.split(' ');
		
		  var _str$split2 = _slicedToArray(_str$split, 2);
		
		  var first = _str$split2[0];
		  var second = _str$split2[1];
		
		  if (['left', 'right'].indexOf(first) >= 0) {
		    var _ref = [second, first];
		    first = _ref[0];
		    second = _ref[1];
		  }
		  return [first, second].join(' ');
		}
		
		function removeFromArray(arr, item) {
		  var index = undefined;
		  var results = [];
		  while ((index = arr.indexOf(item)) !== -1) {
		    results.push(arr.splice(index, 1));
		  }
		  return results;
		}
		
		var clickEvents = ['click'];
		if ('ontouchstart' in document.documentElement) {
		  clickEvents.push('touchstart');
		}
		
		var transitionEndEvents = {
		  'WebkitTransition': 'webkitTransitionEnd',
		  'MozTransition': 'transitionend',
		  'OTransition': 'otransitionend',
		  'transition': 'transitionend'
		};
		
		var transitionEndEvent = '';
		for (var _name in transitionEndEvents) {
		  if (({}).hasOwnProperty.call(transitionEndEvents, _name)) {
		    var tempEl = document.createElement('p');
		    if (typeof tempEl.style[_name] !== 'undefined') {
		      transitionEndEvent = transitionEndEvents[_name];
		    }
		  }
		}
		
		var MIRROR_ATTACH = {
		  left: 'right',
		  right: 'left',
		  top: 'bottom',
		  bottom: 'top',
		  middle: 'middle',
		  center: 'center'
		};
		
		var allDrops = {};
		
		// Drop can be included in external libraries.  Calling createContext gives you a fresh
		// copy of drop which won't interact with other copies on the page (beyond calling the document events).
		
		function createContext() {
		  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		  var drop = function drop() {
		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }
		
		    return new (_bind.apply(DropInstance, [null].concat(args)))();
		  };
		
		  extend(drop, {
		    createContext: createContext,
		    drops: [],
		    defaults: {}
		  });
		
		  var defaultOptions = {
		    classPrefix: 'drop',
		    defaults: {
		      position: 'bottom left',
		      openOn: 'click',
		      beforeClose: null,
		      constrainToScrollParent: true,
		      constrainToWindow: true,
		      classes: '',
		      remove: false,
		      openDelay: 0,
		      closeDelay: 50,
		      // inherited from openDelay and closeDelay if not explicitly defined
		      focusDelay: null,
		      blurDelay: null,
		      hoverOpenDelay: null,
		      hoverCloseDelay: null,
		      tetherOptions: {}
		    }
		  };
		
		  extend(drop, defaultOptions, options);
		  extend(drop.defaults, defaultOptions.defaults, options.defaults);
		
		  if (typeof allDrops[drop.classPrefix] === 'undefined') {
		    allDrops[drop.classPrefix] = [];
		  }
		
		  drop.updateBodyClasses = function () {
		    // There is only one body, so despite the context concept, we still iterate through all
		    // drops which share our classPrefix.
		
		    var anyOpen = false;
		    var drops = allDrops[drop.classPrefix];
		    var len = drops.length;
		    for (var i = 0; i < len; ++i) {
		      if (drops[i].isOpened()) {
		        anyOpen = true;
		        break;
		      }
		    }
		
		    if (anyOpen) {
		      addClass(document.body, drop.classPrefix + '-open');
		    } else {
		      removeClass(document.body, drop.classPrefix + '-open');
		    }
		  };
		
		  var DropInstance = (function (_Evented) {
		    _inherits(DropInstance, _Evented);
		
		    function DropInstance(opts) {
		      _classCallCheck(this, DropInstance);
		
		      _get(Object.getPrototypeOf(DropInstance.prototype), 'constructor', this).call(this);
		      this.options = extend({}, drop.defaults, opts);
		      this.target = this.options.target;
		
		      if (typeof this.target === 'undefined') {
		        throw new Error('Drop Error: You must provide a target.');
		      }
		
		      var dataPrefix = 'data-' + drop.classPrefix;
		
		      var contentAttr = this.target.getAttribute(dataPrefix);
		      if (contentAttr && this.options.content == null) {
		        this.options.content = contentAttr;
		      }
		
		      var attrsOverride = ['position', 'openOn'];
		      for (var i = 0; i < attrsOverride.length; ++i) {
		
		        var override = this.target.getAttribute(dataPrefix + '-' + attrsOverride[i]);
		        if (override && this.options[attrsOverride[i]] == null) {
		          this.options[attrsOverride[i]] = override;
		        }
		      }
		
		      if (this.options.classes && this.options.addTargetClasses !== false) {
		        addClass(this.target, this.options.classes);
		      }
		
		      drop.drops.push(this);
		      allDrops[drop.classPrefix].push(this);
		
		      this._boundEvents = [];
		      this.bindMethods();
		      this.setupElements();
		      this.setupEvents();
		      this.setupTether();
		    }
		
		    _createClass(DropInstance, [{
		      key: '_on',
		      value: function _on(element, event, handler) {
		        this._boundEvents.push({ element: element, event: event, handler: handler });
		        element.addEventListener(event, handler);
		      }
		    }, {
		      key: 'bindMethods',
		      value: function bindMethods() {
		        this.transitionEndHandler = this._transitionEndHandler.bind(this);
		      }
		    }, {
		      key: 'setupElements',
		      value: function setupElements() {
		        var _this = this;
		
		        this.drop = document.createElement('div');
		        addClass(this.drop, drop.classPrefix);
		
		        if (this.options.classes) {
		          addClass(this.drop, this.options.classes);
		        }
		
		        this.content = document.createElement('div');
		        addClass(this.content, drop.classPrefix + '-content');
		
		        if (typeof this.options.content === 'function') {
		          var generateAndSetContent = function generateAndSetContent() {
		            // content function might return a string or an element
		            var contentElementOrHTML = _this.options.content.call(_this, _this);
		
		            if (typeof contentElementOrHTML === 'string') {
		              _this.content.innerHTML = contentElementOrHTML;
		            } else if (typeof contentElementOrHTML === 'object') {
		              _this.content.innerHTML = '';
		              _this.content.appendChild(contentElementOrHTML);
		            } else {
		              throw new Error('Drop Error: Content function should return a string or HTMLElement.');
		            }
		          };
		
		          generateAndSetContent();
		          this.on('open', generateAndSetContent.bind(this));
		        } else if (typeof this.options.content === 'object') {
		          this.content.appendChild(this.options.content);
		        } else {
		          this.content.innerHTML = this.options.content;
		        }
		
		        this.drop.appendChild(this.content);
		      }
		    }, {
		      key: 'setupTether',
		      value: function setupTether() {
		        // Tether expects two attachment points, one in the target element, one in the
		        // drop.  We use a single one, and use the order as well, to allow us to put
		        // the drop on either side of any of the four corners.  This magic converts between
		        // the two:
		        var dropAttach = this.options.position.split(' ');
		        dropAttach[0] = MIRROR_ATTACH[dropAttach[0]];
		        dropAttach = dropAttach.join(' ');
		
		        var constraints = [];
		        if (this.options.constrainToScrollParent) {
		          constraints.push({
		            to: 'scrollParent',
		            pin: 'top, bottom',
		            attachment: 'together none'
		          });
		        } else {
		          // To get 'out of bounds' classes
		          constraints.push({
		            to: 'scrollParent'
		          });
		        }
		
		        if (this.options.constrainToWindow !== false) {
		          constraints.push({
		            to: 'window',
		            attachment: 'together'
		          });
		        } else {
		          // To get 'out of bounds' classes
		          constraints.push({
		            to: 'window'
		          });
		        }
		
		        var opts = {
		          element: this.drop,
		          target: this.target,
		          attachment: sortAttach(dropAttach),
		          targetAttachment: sortAttach(this.options.position),
		          classPrefix: drop.classPrefix,
		          offset: '0 0',
		          targetOffset: '0 0',
		          enabled: false,
		          constraints: constraints,
		          addTargetClasses: this.options.addTargetClasses
		        };
		
		        if (this.options.tetherOptions !== false) {
		          this.tether = new Tether(extend({}, opts, this.options.tetherOptions));
		        }
		      }
		    }, {
		      key: 'setupEvents',
		      value: function setupEvents() {
		        var _this2 = this;
		
		        if (!this.options.openOn) {
		          return;
		        }
		
		        if (this.options.openOn === 'always') {
		          setTimeout(this.open.bind(this));
		          return;
		        }
		
		        var events = this.options.openOn.split(' ');
		
		        if (events.indexOf('click') >= 0) {
		          var openHandler = function openHandler(event) {
		            _this2.toggle(event);
		            event.preventDefault();
		          };
		
		          var closeHandler = function closeHandler(event) {
		            if (!_this2.isOpened()) {
		              return;
		            }
		
		            // Clicking inside dropdown
		            if (event.target === _this2.drop || _this2.drop.contains(event.target)) {
		              return;
		            }
		
		            // Clicking target
		            if (event.target === _this2.target || _this2.target.contains(event.target)) {
		              return;
		            }
		
		            _this2.close(event);
		          };
		
		          for (var i = 0; i < clickEvents.length; ++i) {
		            var clickEvent = clickEvents[i];
		            this._on(this.target, clickEvent, openHandler);
		            this._on(document, clickEvent, closeHandler);
		          }
		        }
		
		        var inTimeout = null;
		        var outTimeout = null;
		
		        var inHandler = function inHandler(event) {
		          if (outTimeout !== null) {
		            clearTimeout(outTimeout);
		          } else {
		            inTimeout = setTimeout(function () {
		              _this2.open(event);
		              inTimeout = null;
		            }, (event.type === 'focus' ? _this2.options.focusDelay : _this2.options.hoverOpenDelay) || _this2.options.openDelay);
		          }
		        };
		
		        var outHandler = function outHandler(event) {
		          if (inTimeout !== null) {
		            clearTimeout(inTimeout);
		          } else {
		            outTimeout = setTimeout(function () {
		              _this2.close(event);
		              outTimeout = null;
		            }, (event.type === 'blur' ? _this2.options.blurDelay : _this2.options.hoverCloseDelay) || _this2.options.closeDelay);
		          }
		        };
		
		        if (events.indexOf('hover') >= 0) {
		          this._on(this.target, 'mouseover', inHandler);
		          this._on(this.drop, 'mouseover', inHandler);
		          this._on(this.target, 'mouseout', outHandler);
		          this._on(this.drop, 'mouseout', outHandler);
		        }
		
		        if (events.indexOf('focus') >= 0) {
		          this._on(this.target, 'focus', inHandler);
		          this._on(this.drop, 'focus', inHandler);
		          this._on(this.target, 'blur', outHandler);
		          this._on(this.drop, 'blur', outHandler);
		        }
		      }
		    }, {
		      key: 'isOpened',
		      value: function isOpened() {
		        if (this.drop) {
		          return hasClass(this.drop, drop.classPrefix + '-open');
		        }
		      }
		    }, {
		      key: 'toggle',
		      value: function toggle(event) {
		        if (this.isOpened()) {
		          this.close(event);
		        } else {
		          this.open(event);
		        }
		      }
		    }, {
		      key: 'open',
		      value: function open(event) {
		        var _this3 = this;
		
		        /* eslint no-unused-vars: 0 */
		        if (this.isOpened()) {
		          return;
		        }
		
		        if (!this.drop.parentNode) {
		          document.body.appendChild(this.drop);
		        }
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.enable();
		        }
		
		        addClass(this.drop, drop.classPrefix + '-open');
		        addClass(this.drop, drop.classPrefix + '-open-transitionend');
		
		        setTimeout(function () {
		          if (_this3.drop) {
		            addClass(_this3.drop, drop.classPrefix + '-after-open');
		          }
		        });
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.position();
		        }
		
		        this.trigger('open');
		
		        drop.updateBodyClasses();
		      }
		    }, {
		      key: '_transitionEndHandler',
		      value: function _transitionEndHandler(e) {
		        if (e.target !== e.currentTarget) {
		          return;
		        }
		
		        if (!hasClass(this.drop, drop.classPrefix + '-open')) {
		          removeClass(this.drop, drop.classPrefix + '-open-transitionend');
		        }
		        this.drop.removeEventListener(transitionEndEvent, this.transitionEndHandler);
		      }
		    }, {
		      key: 'beforeCloseHandler',
		      value: function beforeCloseHandler(event) {
		        var shouldClose = true;
		
		        if (!this.isClosing && typeof this.options.beforeClose === 'function') {
		          this.isClosing = true;
		          shouldClose = this.options.beforeClose(event, this) !== false;
		        }
		
		        this.isClosing = false;
		
		        return shouldClose;
		      }
		    }, {
		      key: 'close',
		      value: function close(event) {
		        if (!this.isOpened()) {
		          return;
		        }
		
		        if (!this.beforeCloseHandler(event)) {
		          return;
		        }
		
		        removeClass(this.drop, drop.classPrefix + '-open');
		        removeClass(this.drop, drop.classPrefix + '-after-open');
		
		        this.drop.addEventListener(transitionEndEvent, this.transitionEndHandler);
		
		        this.trigger('close');
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.disable();
		        }
		
		        drop.updateBodyClasses();
		
		        if (this.options.remove) {
		          this.remove(event);
		        }
		      }
		    }, {
		      key: 'remove',
		      value: function remove(event) {
		        this.close(event);
		        if (this.drop.parentNode) {
		          this.drop.parentNode.removeChild(this.drop);
		        }
		      }
		    }, {
		      key: 'position',
		      value: function position() {
		        if (this.isOpened() && typeof this.tether !== 'undefined') {
		          this.tether.position();
		        }
		      }
		    }, {
		      key: 'destroy',
		      value: function destroy() {
		        this.remove();
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.destroy();
		        }
		
		        for (var i = 0; i < this._boundEvents.length; ++i) {
		          var _boundEvents$i = this._boundEvents[i];
		          var element = _boundEvents$i.element;
		          var _event = _boundEvents$i.event;
		          var handler = _boundEvents$i.handler;
		
		          element.removeEventListener(_event, handler);
		        }
		
		        this._boundEvents = [];
		
		        this.tether = null;
		        this.drop = null;
		        this.content = null;
		        this.target = null;
		
		        removeFromArray(allDrops[drop.classPrefix], this);
		        removeFromArray(drop.drops, this);
		      }
		    }]);
		
		    return DropInstance;
		  })(Evented);
		
		  return drop;
		}
		
		var Drop = createContext();
		
		document.addEventListener('DOMContentLoaded', function () {
		  Drop.updateBodyClasses();
		});
		return Drop;
		
		}));
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether 1.2.0 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require, exports, module);
		  } else {
		    root.Tether = factory();
		  }
		}(this, function(require, exports, module) {
		
		'use strict';
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		var TetherBase = undefined;
		if (typeof TetherBase === 'undefined') {
		  TetherBase = { modules: [] };
		}
		
		function getScrollParent(el) {
		  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;
		  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397
		  var computedStyle = getComputedStyle(el) || {};
		  var position = computedStyle.position;
		
		  if (position === 'fixed') {
		    return el;
		  }
		
		  var parent = el;
		  while (parent = parent.parentNode) {
		    var style = undefined;
		    try {
		      style = getComputedStyle(parent);
		    } catch (err) {}
		
		    if (typeof style === 'undefined' || style === null) {
		      return parent;
		    }
		
		    var _style = style;
		    var overflow = _style.overflow;
		    var overflowX = _style.overflowX;
		    var overflowY = _style.overflowY;
		
		    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
		      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {
		        return parent;
		      }
		    }
		  }
		
		  return document.body;
		}
		
		var uniqueId = (function () {
		  var id = 0;
		  return function () {
		    return ++id;
		  };
		})();
		
		var zeroPosCache = {};
		var getOrigin = function getOrigin(doc) {
		  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of
		  // jitter as the user scrolls that messes with our ability to detect if two positions
		  // are equivilant or not.  We place an element at the top left of the page that will
		  // get the same jitter, so we can cancel the two out.
		  var node = doc._tetherZeroElement;
		  if (typeof node === 'undefined') {
		    node = doc.createElement('div');
		    node.setAttribute('data-tether-id', uniqueId());
		    extend(node.style, {
		      top: 0,
		      left: 0,
		      position: 'absolute'
		    });
		
		    doc.body.appendChild(node);
		
		    doc._tetherZeroElement = node;
		  }
		
		  var id = node.getAttribute('data-tether-id');
		  if (typeof zeroPosCache[id] === 'undefined') {
		    zeroPosCache[id] = {};
		
		    var rect = node.getBoundingClientRect();
		    for (var k in rect) {
		      // Can't use extend, as on IE9, elements don't resolve to be hasOwnProperty
		      zeroPosCache[id][k] = rect[k];
		    }
		
		    // Clear the cache when this position call is done
		    defer(function () {
		      delete zeroPosCache[id];
		    });
		  }
		
		  return zeroPosCache[id];
		};
		
		function getBounds(el) {
		  var doc = undefined;
		  if (el === document) {
		    doc = document;
		    el = document.documentElement;
		  } else {
		    doc = el.ownerDocument;
		  }
		
		  var docEl = doc.documentElement;
		
		  var box = {};
		  // The original object returned by getBoundingClientRect is immutable, so we clone it
		  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9
		  var rect = el.getBoundingClientRect();
		  for (var k in rect) {
		    box[k] = rect[k];
		  }
		
		  var origin = getOrigin(doc);
		
		  box.top -= origin.top;
		  box.left -= origin.left;
		
		  if (typeof box.width === 'undefined') {
		    box.width = document.body.scrollWidth - box.left - box.right;
		  }
		  if (typeof box.height === 'undefined') {
		    box.height = document.body.scrollHeight - box.top - box.bottom;
		  }
		
		  box.top = box.top - docEl.clientTop;
		  box.left = box.left - docEl.clientLeft;
		  box.right = doc.body.clientWidth - box.width - box.left;
		  box.bottom = doc.body.clientHeight - box.height - box.top;
		
		  return box;
		}
		
		function getOffsetParent(el) {
		  return el.offsetParent || document.documentElement;
		}
		
		function getScrollBarSize() {
		  var inner = document.createElement('div');
		  inner.style.width = '100%';
		  inner.style.height = '200px';
		
		  var outer = document.createElement('div');
		  extend(outer.style, {
		    position: 'absolute',
		    top: 0,
		    left: 0,
		    pointerEvents: 'none',
		    visibility: 'hidden',
		    width: '200px',
		    height: '150px',
		    overflow: 'hidden'
		  });
		
		  outer.appendChild(inner);
		
		  document.body.appendChild(outer);
		
		  var widthContained = inner.offsetWidth;
		  outer.style.overflow = 'scroll';
		  var widthScroll = inner.offsetWidth;
		
		  if (widthContained === widthScroll) {
		    widthScroll = outer.clientWidth;
		  }
		
		  document.body.removeChild(outer);
		
		  var width = widthContained - widthScroll;
		
		  return { width: width, height: width };
		}
		
		function extend() {
		  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		  var args = [];
		
		  Array.prototype.push.apply(args, arguments);
		
		  args.slice(1).forEach(function (obj) {
		    if (obj) {
		      for (var key in obj) {
		        if (({}).hasOwnProperty.call(obj, key)) {
		          out[key] = obj[key];
		        }
		      }
		    }
		  });
		
		  return out;
		}
		
		function removeClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    name.split(' ').forEach(function (cls) {
		      if (cls.trim()) {
		        el.classList.remove(cls);
		      }
		    });
		  } else {
		    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');
		    var className = getClassName(el).replace(regex, ' ');
		    setClassName(el, className);
		  }
		}
		
		function addClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    name.split(' ').forEach(function (cls) {
		      if (cls.trim()) {
		        el.classList.add(cls);
		      }
		    });
		  } else {
		    removeClass(el, name);
		    var cls = getClassName(el) + (' ' + name);
		    setClassName(el, cls);
		  }
		}
		
		function hasClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    return el.classList.contains(name);
		  }
		  var className = getClassName(el);
		  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);
		}
		
		function getClassName(el) {
		  if (el.className instanceof SVGAnimatedString) {
		    return el.className.baseVal;
		  }
		  return el.className;
		}
		
		function setClassName(el, className) {
		  el.setAttribute('class', className);
		}
		
		function updateClasses(el, add, all) {
		  // Of the set of 'all' classes, we need the 'add' classes, and only the
		  // 'add' classes to be set.
		  all.forEach(function (cls) {
		    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
		      removeClass(el, cls);
		    }
		  });
		
		  add.forEach(function (cls) {
		    if (!hasClass(el, cls)) {
		      addClass(el, cls);
		    }
		  });
		}
		
		var deferred = [];
		
		var defer = function defer(fn) {
		  deferred.push(fn);
		};
		
		var flush = function flush() {
		  var fn = undefined;
		  while (fn = deferred.pop()) {
		    fn();
		  }
		};
		
		var Evented = (function () {
		  function Evented() {
		    _classCallCheck(this, Evented);
		  }
		
		  _createClass(Evented, [{
		    key: 'on',
		    value: function on(event, handler, ctx) {
		      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
		
		      if (typeof this.bindings === 'undefined') {
		        this.bindings = {};
		      }
		      if (typeof this.bindings[event] === 'undefined') {
		        this.bindings[event] = [];
		      }
		      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });
		    }
		  }, {
		    key: 'once',
		    value: function once(event, handler, ctx) {
		      this.on(event, handler, ctx, true);
		    }
		  }, {
		    key: 'off',
		    value: function off(event, handler) {
		      if (typeof this.bindings !== 'undefined' && typeof this.bindings[event] !== 'undefined') {
		        return;
		      }
		
		      if (typeof handler === 'undefined') {
		        delete this.bindings[event];
		      } else {
		        var i = 0;
		        while (i < this.bindings[event].length) {
		          if (this.bindings[event][i].handler === handler) {
		            this.bindings[event].splice(i, 1);
		          } else {
		            ++i;
		          }
		        }
		      }
		    }
		  }, {
		    key: 'trigger',
		    value: function trigger(event) {
		      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {
		        var i = 0;
		
		        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		          args[_key - 1] = arguments[_key];
		        }
		
		        while (i < this.bindings[event].length) {
		          var _bindings$event$i = this.bindings[event][i];
		          var handler = _bindings$event$i.handler;
		          var ctx = _bindings$event$i.ctx;
		          var once = _bindings$event$i.once;
		
		          var context = ctx;
		          if (typeof context === 'undefined') {
		            context = this;
		          }
		
		          handler.apply(context, args);
		
		          if (once) {
		            this.bindings[event].splice(i, 1);
		          } else {
		            ++i;
		          }
		        }
		      }
		    }
		  }]);
		
		  return Evented;
		})();
		
		TetherBase.Utils = {
		  getScrollParent: getScrollParent,
		  getBounds: getBounds,
		  getOffsetParent: getOffsetParent,
		  extend: extend,
		  addClass: addClass,
		  removeClass: removeClass,
		  hasClass: hasClass,
		  updateClasses: updateClasses,
		  defer: defer,
		  flush: flush,
		  uniqueId: uniqueId,
		  Evented: Evented,
		  getScrollBarSize: getScrollBarSize
		};
		/* globals TetherBase, performance */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		if (typeof TetherBase === 'undefined') {
		  throw new Error('You must include the utils.js file before tether.js');
		}
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getScrollParent = _TetherBase$Utils.getScrollParent;
		var getBounds = _TetherBase$Utils.getBounds;
		var getOffsetParent = _TetherBase$Utils.getOffsetParent;
		var extend = _TetherBase$Utils.extend;
		var addClass = _TetherBase$Utils.addClass;
		var removeClass = _TetherBase$Utils.removeClass;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		var flush = _TetherBase$Utils.flush;
		var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
		
		function within(a, b) {
		  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
		
		  return a + diff >= b && b >= a - diff;
		}
		
		var transformKey = (function () {
		  if (typeof document === 'undefined') {
		    return '';
		  }
		  var el = document.createElement('div');
		
		  var transforms = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
		  for (var i = 0; i < transforms.length; ++i) {
		    var key = transforms[i];
		    if (el.style[key] !== undefined) {
		      return key;
		    }
		  }
		})();
		
		var tethers = [];
		
		var position = function position() {
		  tethers.forEach(function (tether) {
		    tether.position(false);
		  });
		  flush();
		};
		
		function now() {
		  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {
		    return performance.now();
		  }
		  return +new Date();
		}
		
		(function () {
		  var lastCall = null;
		  var lastDuration = null;
		  var pendingTimeout = null;
		
		  var tick = function tick() {
		    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {
		      // We voluntarily throttle ourselves if we can't manage 60fps
		      lastDuration = Math.min(lastDuration - 16, 250);
		
		      // Just in case this is the last event, remember to position just once more
		      pendingTimeout = setTimeout(tick, 250);
		      return;
		    }
		
		    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {
		      // Some browsers call events a little too frequently, refuse to run more than is reasonable
		      return;
		    }
		
		    if (typeof pendingTimeout !== 'undefined') {
		      clearTimeout(pendingTimeout);
		      pendingTimeout = null;
		    }
		
		    lastCall = now();
		    position();
		    lastDuration = now() - lastCall;
		  };
		
		  if (typeof window !== 'undefined') {
		    ['resize', 'scroll', 'touchmove'].forEach(function (event) {
		      window.addEventListener(event, tick);
		    });
		  }
		})();
		
		var MIRROR_LR = {
		  center: 'center',
		  left: 'right',
		  right: 'left'
		};
		
		var MIRROR_TB = {
		  middle: 'middle',
		  top: 'bottom',
		  bottom: 'top'
		};
		
		var OFFSET_MAP = {
		  top: 0,
		  left: 0,
		  middle: '50%',
		  center: '50%',
		  bottom: '100%',
		  right: '100%'
		};
		
		var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
		  var left = attachment.left;
		  var top = attachment.top;
		
		  if (left === 'auto') {
		    left = MIRROR_LR[relativeToAttachment.left];
		  }
		
		  if (top === 'auto') {
		    top = MIRROR_TB[relativeToAttachment.top];
		  }
		
		  return { left: left, top: top };
		};
		
		var attachmentToOffset = function attachmentToOffset(attachment) {
		  var left = attachment.left;
		  var top = attachment.top;
		
		  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {
		    left = OFFSET_MAP[attachment.left];
		  }
		
		  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {
		    top = OFFSET_MAP[attachment.top];
		  }
		
		  return { left: left, top: top };
		};
		
		function addOffset() {
		  var out = { top: 0, left: 0 };
		
		  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
		    offsets[_key] = arguments[_key];
		  }
		
		  offsets.forEach(function (_ref) {
		    var top = _ref.top;
		    var left = _ref.left;
		
		    if (typeof top === 'string') {
		      top = parseFloat(top, 10);
		    }
		    if (typeof left === 'string') {
		      left = parseFloat(left, 10);
		    }
		
		    out.top += top;
		    out.left += left;
		  });
		
		  return out;
		}
		
		function offsetToPx(offset, size) {
		  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
		    offset.left = parseFloat(offset.left, 10) / 100 * size.width;
		  }
		  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
		    offset.top = parseFloat(offset.top, 10) / 100 * size.height;
		  }
		
		  return offset;
		}
		
		var parseOffset = function parseOffset(value) {
		  var _value$split = value.split(' ');
		
		  var _value$split2 = _slicedToArray(_value$split, 2);
		
		  var top = _value$split2[0];
		  var left = _value$split2[1];
		
		  return { top: top, left: left };
		};
		var parseAttachment = parseOffset;
		
		var TetherClass = (function () {
		  function TetherClass(options) {
		    var _this = this;
		
		    _classCallCheck(this, TetherClass);
		
		    this.position = this.position.bind(this);
		
		    tethers.push(this);
		
		    this.history = [];
		
		    this.setOptions(options, false);
		
		    TetherBase.modules.forEach(function (module) {
		      if (typeof module.initialize !== 'undefined') {
		        module.initialize.call(_this);
		      }
		    });
		
		    this.position();
		  }
		
		  _createClass(TetherClass, [{
		    key: 'getClass',
		    value: function getClass() {
		      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
		      var classes = this.options.classes;
		
		      if (typeof classes !== 'undefined' && classes[key]) {
		        return this.options.classes[key];
		      } else if (this.options.classPrefix) {
		        return this.options.classPrefix + '-' + key;
		      } else {
		        return key;
		      }
		    }
		  }, {
		    key: 'setOptions',
		    value: function setOptions(options) {
		      var _this2 = this;
		
		      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
		
		      var defaults = {
		        offset: '0 0',
		        targetOffset: '0 0',
		        targetAttachment: 'auto auto',
		        classPrefix: 'tether'
		      };
		
		      this.options = extend(defaults, options);
		
		      var _options = this.options;
		      var element = _options.element;
		      var target = _options.target;
		      var targetModifier = _options.targetModifier;
		
		      this.element = element;
		      this.target = target;
		      this.targetModifier = targetModifier;
		
		      if (this.target === 'viewport') {
		        this.target = document.body;
		        this.targetModifier = 'visible';
		      } else if (this.target === 'scroll-handle') {
		        this.target = document.body;
		        this.targetModifier = 'scroll-handle';
		      }
		
		      ['element', 'target'].forEach(function (key) {
		        if (typeof _this2[key] === 'undefined') {
		          throw new Error('Tether Error: Both element and target must be defined');
		        }
		
		        if (typeof _this2[key].jquery !== 'undefined') {
		          _this2[key] = _this2[key][0];
		        } else if (typeof _this2[key] === 'string') {
		          _this2[key] = document.querySelector(_this2[key]);
		        }
		      });
		
		      addClass(this.element, this.getClass('element'));
		      if (!(this.options.addTargetClasses === false)) {
		        addClass(this.target, this.getClass('target'));
		      }
		
		      if (!this.options.attachment) {
		        throw new Error('Tether Error: You must provide an attachment');
		      }
		
		      this.targetAttachment = parseAttachment(this.options.targetAttachment);
		      this.attachment = parseAttachment(this.options.attachment);
		      this.offset = parseOffset(this.options.offset);
		      this.targetOffset = parseOffset(this.options.targetOffset);
		
		      if (typeof this.scrollParent !== 'undefined') {
		        this.disable();
		      }
		
		      if (this.targetModifier === 'scroll-handle') {
		        this.scrollParent = this.target;
		      } else {
		        this.scrollParent = getScrollParent(this.target);
		      }
		
		      if (!(this.options.enabled === false)) {
		        this.enable(pos);
		      }
		    }
		  }, {
		    key: 'getTargetBounds',
		    value: function getTargetBounds() {
		      if (typeof this.targetModifier !== 'undefined') {
		        if (this.targetModifier === 'visible') {
		          if (this.target === document.body) {
		            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };
		          } else {
		            var bounds = getBounds(this.target);
		
		            var out = {
		              height: bounds.height,
		              width: bounds.width,
		              top: bounds.top,
		              left: bounds.left
		            };
		
		            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
		            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
		            out.height = Math.min(innerHeight, out.height);
		            out.height -= 2;
		
		            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
		            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
		            out.width = Math.min(innerWidth, out.width);
		            out.width -= 2;
		
		            if (out.top < pageYOffset) {
		              out.top = pageYOffset;
		            }
		            if (out.left < pageXOffset) {
		              out.left = pageXOffset;
		            }
		
		            return out;
		          }
		        } else if (this.targetModifier === 'scroll-handle') {
		          var bounds = undefined;
		          var target = this.target;
		          if (target === document.body) {
		            target = document.documentElement;
		
		            bounds = {
		              left: pageXOffset,
		              top: pageYOffset,
		              height: innerHeight,
		              width: innerWidth
		            };
		          } else {
		            bounds = getBounds(target);
		          }
		
		          var style = getComputedStyle(target);
		
		          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;
		
		          var scrollBottom = 0;
		          if (hasBottomScroll) {
		            scrollBottom = 15;
		          }
		
		          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;
		
		          var out = {
		            width: 15,
		            height: height * 0.975 * (height / target.scrollHeight),
		            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
		          };
		
		          var fitAdj = 0;
		          if (height < 408 && this.target === document.body) {
		            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
		          }
		
		          if (this.target !== document.body) {
		            out.height = Math.max(out.height, 24);
		          }
		
		          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
		          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);
		
		          if (this.target === document.body) {
		            out.height = Math.max(out.height, 24);
		          }
		
		          return out;
		        }
		      } else {
		        return getBounds(this.target);
		      }
		    }
		  }, {
		    key: 'clearCache',
		    value: function clearCache() {
		      this._cache = {};
		    }
		  }, {
		    key: 'cache',
		    value: function cache(k, getter) {
		      // More than one module will often need the same DOM info, so
		      // we keep a cache which is cleared on each position call
		      if (typeof this._cache === 'undefined') {
		        this._cache = {};
		      }
		
		      if (typeof this._cache[k] === 'undefined') {
		        this._cache[k] = getter.call(this);
		      }
		
		      return this._cache[k];
		    }
		  }, {
		    key: 'enable',
		    value: function enable() {
		      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
		
		      if (!(this.options.addTargetClasses === false)) {
		        addClass(this.target, this.getClass('enabled'));
		      }
		      addClass(this.element, this.getClass('enabled'));
		      this.enabled = true;
		
		      if (this.scrollParent !== document) {
		        this.scrollParent.addEventListener('scroll', this.position);
		      }
		
		      if (pos) {
		        this.position();
		      }
		    }
		  }, {
		    key: 'disable',
		    value: function disable() {
		      removeClass(this.target, this.getClass('enabled'));
		      removeClass(this.element, this.getClass('enabled'));
		      this.enabled = false;
		
		      if (typeof this.scrollParent !== 'undefined') {
		        this.scrollParent.removeEventListener('scroll', this.position);
		      }
		    }
		  }, {
		    key: 'destroy',
		    value: function destroy() {
		      var _this3 = this;
		
		      this.disable();
		
		      tethers.forEach(function (tether, i) {
		        if (tether === _this3) {
		          tethers.splice(i, 1);
		          return;
		        }
		      });
		    }
		  }, {
		    key: 'updateAttachClasses',
		    value: function updateAttachClasses(elementAttach, targetAttach) {
		      var _this4 = this;
		
		      elementAttach = elementAttach || this.attachment;
		      targetAttach = targetAttach || this.targetAttachment;
		      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];
		
		      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {
		        // updateAttachClasses can be called more than once in a position call, so
		        // we need to clean up after ourselves such that when the last defer gets
		        // ran it doesn't add any extra classes from previous calls.
		        this._addAttachClasses.splice(0, this._addAttachClasses.length);
		      }
		
		      if (typeof this._addAttachClasses === 'undefined') {
		        this._addAttachClasses = [];
		      }
		      var add = this._addAttachClasses;
		
		      if (elementAttach.top) {
		        add.push(this.getClass('element-attached') + '-' + elementAttach.top);
		      }
		      if (elementAttach.left) {
		        add.push(this.getClass('element-attached') + '-' + elementAttach.left);
		      }
		      if (targetAttach.top) {
		        add.push(this.getClass('target-attached') + '-' + targetAttach.top);
		      }
		      if (targetAttach.left) {
		        add.push(this.getClass('target-attached') + '-' + targetAttach.left);
		      }
		
		      var all = [];
		      sides.forEach(function (side) {
		        all.push(_this4.getClass('element-attached') + '-' + side);
		        all.push(_this4.getClass('target-attached') + '-' + side);
		      });
		
		      defer(function () {
		        if (!(typeof _this4._addAttachClasses !== 'undefined')) {
		          return;
		        }
		
		        updateClasses(_this4.element, _this4._addAttachClasses, all);
		        if (!(_this4.options.addTargetClasses === false)) {
		          updateClasses(_this4.target, _this4._addAttachClasses, all);
		        }
		
		        delete _this4._addAttachClasses;
		      });
		    }
		  }, {
		    key: 'position',
		    value: function position() {
		      var _this5 = this;
		
		      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
		
		      // flushChanges commits the changes immediately, leave true unless you are positioning multiple
		      // tethers (in which case call Tether.Utils.flush yourself when you're done)
		
		      if (!this.enabled) {
		        return;
		      }
		
		      this.clearCache();
		
		      // Turn 'auto' attachments into the appropriate corner or edge
		      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
		
		      this.updateAttachClasses(this.attachment, targetAttachment);
		
		      var elementPos = this.cache('element-bounds', function () {
		        return getBounds(_this5.element);
		      });
		
		      var width = elementPos.width;
		      var height = elementPos.height;
		
		      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
		        var _lastSize = this.lastSize;
		
		        // We cache the height and width to make it possible to position elements that are
		        // getting hidden.
		        width = _lastSize.width;
		        height = _lastSize.height;
		      } else {
		        this.lastSize = { width: width, height: height };
		      }
		
		      var targetPos = this.cache('target-bounds', function () {
		        return _this5.getTargetBounds();
		      });
		      var targetSize = targetPos;
		
		      // Get an actual px offset from the attachment
		      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });
		      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
		
		      var manualOffset = offsetToPx(this.offset, { width: width, height: height });
		      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
		
		      // Add the manually provided offset
		      offset = addOffset(offset, manualOffset);
		      targetOffset = addOffset(targetOffset, manualTargetOffset);
		
		      // It's now our goal to make (element position + offset) == (target position + target offset)
		      var left = targetPos.left + targetOffset.left - offset.left;
		      var top = targetPos.top + targetOffset.top - offset.top;
		
		      for (var i = 0; i < TetherBase.modules.length; ++i) {
		        var _module2 = TetherBase.modules[i];
		        var ret = _module2.position.call(this, {
		          left: left,
		          top: top,
		          targetAttachment: targetAttachment,
		          targetPos: targetPos,
		          elementPos: elementPos,
		          offset: offset,
		          targetOffset: targetOffset,
		          manualOffset: manualOffset,
		          manualTargetOffset: manualTargetOffset,
		          scrollbarSize: scrollbarSize,
		          attachment: this.attachment
		        });
		
		        if (ret === false) {
		          return false;
		        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {
		          continue;
		        } else {
		          top = ret.top;
		          left = ret.left;
		        }
		      }
		
		      // We describe the position three different ways to give the optimizer
		      // a chance to decide the best possible way to position the element
		      // with the fewest repaints.
		      var next = {
		        // It's position relative to the page (absolute positioning when
		        // the element is a child of the body)
		        page: {
		          top: top,
		          left: left
		        },
		
		        // It's position relative to the viewport (fixed positioning)
		        viewport: {
		          top: top - pageYOffset,
		          bottom: pageYOffset - top - height + innerHeight,
		          left: left - pageXOffset,
		          right: pageXOffset - left - width + innerWidth
		        }
		      };
		
		      var scrollbarSize = undefined;
		      if (document.body.scrollWidth > window.innerWidth) {
		        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
		        next.viewport.bottom -= scrollbarSize.height;
		      }
		
		      if (document.body.scrollHeight > window.innerHeight) {
		        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
		        next.viewport.right -= scrollbarSize.width;
		      }
		
		      if (['', 'static'].indexOf(document.body.style.position) === -1 || ['', 'static'].indexOf(document.body.parentElement.style.position) === -1) {
		        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'
		        next.page.bottom = document.body.scrollHeight - top - height;
		        next.page.right = document.body.scrollWidth - left - width;
		      }
		
		      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {
		        (function () {
		          var offsetParent = _this5.cache('target-offsetparent', function () {
		            return getOffsetParent(_this5.target);
		          });
		          var offsetPosition = _this5.cache('target-offsetparent-bounds', function () {
		            return getBounds(offsetParent);
		          });
		          var offsetParentStyle = getComputedStyle(offsetParent);
		          var offsetParentSize = offsetPosition;
		
		          var offsetBorder = {};
		          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {
		            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
		          });
		
		          offsetPosition.right = document.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
		          offsetPosition.bottom = document.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;
		
		          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
		            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
		              // We're within the visible part of the target's scroll parent
		              var scrollTop = offsetParent.scrollTop;
		              var scrollLeft = offsetParent.scrollLeft;
		
		              // It's position relative to the target's offset parent (absolute positioning when
		              // the element is moved to be a child of the target's offset parent).
		              next.offset = {
		                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
		                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
		              };
		            }
		          }
		        })();
		      }
		
		      // We could also travel up the DOM and try each containing context, rather than only
		      // looking at the body, but we're gonna get diminishing returns.
		
		      this.move(next);
		
		      this.history.unshift(next);
		
		      if (this.history.length > 3) {
		        this.history.pop();
		      }
		
		      if (flushChanges) {
		        flush();
		      }
		
		      return true;
		    }
		
		    // THE ISSUE
		  }, {
		    key: 'move',
		    value: function move(pos) {
		      var _this6 = this;
		
		      if (!(typeof this.element.parentNode !== 'undefined')) {
		        return;
		      }
		
		      var same = {};
		
		      for (var type in pos) {
		        same[type] = {};
		
		        for (var key in pos[type]) {
		          var found = false;
		
		          for (var i = 0; i < this.history.length; ++i) {
		            var point = this.history[i];
		            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {
		              found = true;
		              break;
		            }
		          }
		
		          if (!found) {
		            same[type][key] = true;
		          }
		        }
		      }
		
		      var css = { top: '', left: '', right: '', bottom: '' };
		
		      var transcribe = function transcribe(_same, _pos) {
		        var hasOptimizations = typeof _this6.options.optimizations !== 'undefined';
		        var gpu = hasOptimizations ? _this6.options.optimizations.gpu : null;
		        if (gpu !== false) {
		          var yPos = undefined,
		              xPos = undefined;
		          if (_same.top) {
		            css.top = 0;
		            yPos = _pos.top;
		          } else {
		            css.bottom = 0;
		            yPos = -_pos.bottom;
		          }
		
		          if (_same.left) {
		            css.left = 0;
		            xPos = _pos.left;
		          } else {
		            css.right = 0;
		            xPos = -_pos.right;
		          }
		
		          css[transformKey] = 'translateX(' + Math.round(xPos) + 'px) translateY(' + Math.round(yPos) + 'px)';
		
		          if (transformKey !== 'msTransform') {
		            // The Z transform will keep this in the GPU (faster, and prevents artifacts),
		            // but IE9 doesn't support 3d transforms and will choke.
		            css[transformKey] += " translateZ(0)";
		          }
		        } else {
		          if (_same.top) {
		            css.top = _pos.top + 'px';
		          } else {
		            css.bottom = _pos.bottom + 'px';
		          }
		
		          if (_same.left) {
		            css.left = _pos.left + 'px';
		          } else {
		            css.right = _pos.right + 'px';
		          }
		        }
		      };
		
		      var moved = false;
		      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
		        css.position = 'absolute';
		        transcribe(same.page, pos.page);
		      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
		        css.position = 'fixed';
		        transcribe(same.viewport, pos.viewport);
		      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {
		        (function () {
		          css.position = 'absolute';
		          var offsetParent = _this6.cache('target-offsetparent', function () {
		            return getOffsetParent(_this6.target);
		          });
		
		          if (getOffsetParent(_this6.element) !== offsetParent) {
		            defer(function () {
		              _this6.element.parentNode.removeChild(_this6.element);
		              offsetParent.appendChild(_this6.element);
		            });
		          }
		
		          transcribe(same.offset, pos.offset);
		          moved = true;
		        })();
		      } else {
		        css.position = 'absolute';
		        transcribe({ top: true, left: true }, pos.page);
		      }
		
		      if (!moved) {
		        var offsetParentIsBody = true;
		        var currentNode = this.element.parentNode;
		        while (currentNode && currentNode.tagName !== 'BODY') {
		          if (getComputedStyle(currentNode).position !== 'static') {
		            offsetParentIsBody = false;
		            break;
		          }
		
		          currentNode = currentNode.parentNode;
		        }
		
		        if (!offsetParentIsBody) {
		          this.element.parentNode.removeChild(this.element);
		          document.body.appendChild(this.element);
		        }
		      }
		
		      // Any css change will trigger a repaint, so let's avoid one if nothing changed
		      var writeCSS = {};
		      var write = false;
		      for (var key in css) {
		        var val = css[key];
		        var elVal = this.element.style[key];
		
		        if (elVal !== '' && val !== '' && ['top', 'left', 'bottom', 'right'].indexOf(key) >= 0) {
		          elVal = parseFloat(elVal);
		          val = parseFloat(val);
		        }
		
		        if (elVal !== val) {
		          write = true;
		          writeCSS[key] = val;
		        }
		      }
		
		      if (write) {
		        defer(function () {
		          extend(_this6.element.style, writeCSS);
		        });
		      }
		    }
		  }]);
		
		  return TetherClass;
		})();
		
		TetherClass.modules = [];
		
		TetherBase.position = position;
		
		var Tether = extend(TetherClass, TetherBase);
		/* globals TetherBase */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getBounds = _TetherBase$Utils.getBounds;
		var extend = _TetherBase$Utils.extend;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		
		var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];
		
		function getBoundingRect(tether, to) {
		  if (to === 'scrollParent') {
		    to = tether.scrollParent;
		  } else if (to === 'window') {
		    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
		  }
		
		  if (to === document) {
		    to = to.documentElement;
		  }
		
		  if (typeof to.nodeType !== 'undefined') {
		    (function () {
		      var size = getBounds(to);
		      var pos = size;
		      var style = getComputedStyle(to);
		
		      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];
		
		      BOUNDS_FORMAT.forEach(function (side, i) {
		        side = side[0].toUpperCase() + side.substr(1);
		        if (side === 'Top' || side === 'Left') {
		          to[i] += parseFloat(style['border' + side + 'Width']);
		        } else {
		          to[i] -= parseFloat(style['border' + side + 'Width']);
		        }
		      });
		    })();
		  }
		
		  return to;
		}
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var _this = this;
		
		    var top = _ref.top;
		    var left = _ref.left;
		    var targetAttachment = _ref.targetAttachment;
		
		    if (!this.options.constraints) {
		      return true;
		    }
		
		    var _cache = this.cache('element-bounds', function () {
		      return getBounds(_this.element);
		    });
		
		    var height = _cache.height;
		    var width = _cache.width;
		
		    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
		      var _lastSize = this.lastSize;
		
		      // Handle the item getting hidden as a result of our positioning without glitching
		      // the classes in and out
		      width = _lastSize.width;
		      height = _lastSize.height;
		    }
		
		    var targetSize = this.cache('target-bounds', function () {
		      return _this.getTargetBounds();
		    });
		
		    var targetHeight = targetSize.height;
		    var targetWidth = targetSize.width;
		
		    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];
		
		    this.options.constraints.forEach(function (constraint) {
		      var outOfBoundsClass = constraint.outOfBoundsClass;
		      var pinnedClass = constraint.pinnedClass;
		
		      if (outOfBoundsClass) {
		        allClasses.push(outOfBoundsClass);
		      }
		      if (pinnedClass) {
		        allClasses.push(pinnedClass);
		      }
		    });
		
		    allClasses.forEach(function (cls) {
		      ['left', 'top', 'right', 'bottom'].forEach(function (side) {
		        allClasses.push(cls + '-' + side);
		      });
		    });
		
		    var addClasses = [];
		
		    var tAttachment = extend({}, targetAttachment);
		    var eAttachment = extend({}, this.attachment);
		
		    this.options.constraints.forEach(function (constraint) {
		      var to = constraint.to;
		      var attachment = constraint.attachment;
		      var pin = constraint.pin;
		
		      if (typeof attachment === 'undefined') {
		        attachment = '';
		      }
		
		      var changeAttachX = undefined,
		          changeAttachY = undefined;
		      if (attachment.indexOf(' ') >= 0) {
		        var _attachment$split = attachment.split(' ');
		
		        var _attachment$split2 = _slicedToArray(_attachment$split, 2);
		
		        changeAttachY = _attachment$split2[0];
		        changeAttachX = _attachment$split2[1];
		      } else {
		        changeAttachX = changeAttachY = attachment;
		      }
		
		      var bounds = getBoundingRect(_this, to);
		
		      if (changeAttachY === 'target' || changeAttachY === 'both') {
		        if (top < bounds[1] && tAttachment.top === 'top') {
		          top += targetHeight;
		          tAttachment.top = 'bottom';
		        }
		
		        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
		          top -= targetHeight;
		          tAttachment.top = 'top';
		        }
		      }
		
		      if (changeAttachY === 'together') {
		        if (top < bounds[1] && tAttachment.top === 'top') {
		          if (eAttachment.top === 'bottom') {
		            top += targetHeight;
		            tAttachment.top = 'bottom';
		
		            top += height;
		            eAttachment.top = 'top';
		          } else if (eAttachment.top === 'top') {
		            top += targetHeight;
		            tAttachment.top = 'bottom';
		
		            top -= height;
		            eAttachment.top = 'bottom';
		          }
		        }
		
		        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
		          if (eAttachment.top === 'top') {
		            top -= targetHeight;
		            tAttachment.top = 'top';
		
		            top -= height;
		            eAttachment.top = 'bottom';
		          } else if (eAttachment.top === 'bottom') {
		            top -= targetHeight;
		            tAttachment.top = 'top';
		
		            top += height;
		            eAttachment.top = 'top';
		          }
		        }
		
		        if (tAttachment.top === 'middle') {
		          if (top + height > bounds[3] && eAttachment.top === 'top') {
		            top -= height;
		            eAttachment.top = 'bottom';
		          } else if (top < bounds[1] && eAttachment.top === 'bottom') {
		            top += height;
		            eAttachment.top = 'top';
		          }
		        }
		      }
		
		      if (changeAttachX === 'target' || changeAttachX === 'both') {
		        if (left < bounds[0] && tAttachment.left === 'left') {
		          left += targetWidth;
		          tAttachment.left = 'right';
		        }
		
		        if (left + width > bounds[2] && tAttachment.left === 'right') {
		          left -= targetWidth;
		          tAttachment.left = 'left';
		        }
		      }
		
		      if (changeAttachX === 'together') {
		        if (left < bounds[0] && tAttachment.left === 'left') {
		          if (eAttachment.left === 'right') {
		            left += targetWidth;
		            tAttachment.left = 'right';
		
		            left += width;
		            eAttachment.left = 'left';
		          } else if (eAttachment.left === 'left') {
		            left += targetWidth;
		            tAttachment.left = 'right';
		
		            left -= width;
		            eAttachment.left = 'right';
		          }
		        } else if (left + width > bounds[2] && tAttachment.left === 'right') {
		          if (eAttachment.left === 'left') {
		            left -= targetWidth;
		            tAttachment.left = 'left';
		
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (eAttachment.left === 'right') {
		            left -= targetWidth;
		            tAttachment.left = 'left';
		
		            left += width;
		            eAttachment.left = 'left';
		          }
		        } else if (tAttachment.left === 'center') {
		          if (left + width > bounds[2] && eAttachment.left === 'left') {
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (left < bounds[0] && eAttachment.left === 'right') {
		            left += width;
		            eAttachment.left = 'left';
		          }
		        }
		      }
		
		      if (changeAttachY === 'element' || changeAttachY === 'both') {
		        if (top < bounds[1] && eAttachment.top === 'bottom') {
		          top += height;
		          eAttachment.top = 'top';
		        }
		
		        if (top + height > bounds[3] && eAttachment.top === 'top') {
		          top -= height;
		          eAttachment.top = 'bottom';
		        }
		      }
		
		      if (changeAttachX === 'element' || changeAttachX === 'both') {
		        if (left < bounds[0]) {
		          if (eAttachment.left === 'right') {
		            left += width;
		            eAttachment.left = 'left';
		          } else if (eAttachment.left === 'center') {
		            left += width / 2;
		            eAttachment.left = 'left';
		          }
		        }
		
		        if (left + width > bounds[2]) {
		          if (eAttachment.left === 'left') {
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (eAttachment.left === 'center') {
		            left -= width / 2;
		            eAttachment.left = 'right';
		          }
		        }
		      }
		
		      if (typeof pin === 'string') {
		        pin = pin.split(',').map(function (p) {
		          return p.trim();
		        });
		      } else if (pin === true) {
		        pin = ['top', 'left', 'right', 'bottom'];
		      }
		
		      pin = pin || [];
		
		      var pinned = [];
		      var oob = [];
		
		      if (top < bounds[1]) {
		        if (pin.indexOf('top') >= 0) {
		          top = bounds[1];
		          pinned.push('top');
		        } else {
		          oob.push('top');
		        }
		      }
		
		      if (top + height > bounds[3]) {
		        if (pin.indexOf('bottom') >= 0) {
		          top = bounds[3] - height;
		          pinned.push('bottom');
		        } else {
		          oob.push('bottom');
		        }
		      }
		
		      if (left < bounds[0]) {
		        if (pin.indexOf('left') >= 0) {
		          left = bounds[0];
		          pinned.push('left');
		        } else {
		          oob.push('left');
		        }
		      }
		
		      if (left + width > bounds[2]) {
		        if (pin.indexOf('right') >= 0) {
		          left = bounds[2] - width;
		          pinned.push('right');
		        } else {
		          oob.push('right');
		        }
		      }
		
		      if (pinned.length) {
		        (function () {
		          var pinnedClass = undefined;
		          if (typeof _this.options.pinnedClass !== 'undefined') {
		            pinnedClass = _this.options.pinnedClass;
		          } else {
		            pinnedClass = _this.getClass('pinned');
		          }
		
		          addClasses.push(pinnedClass);
		          pinned.forEach(function (side) {
		            addClasses.push(pinnedClass + '-' + side);
		          });
		        })();
		      }
		
		      if (oob.length) {
		        (function () {
		          var oobClass = undefined;
		          if (typeof _this.options.outOfBoundsClass !== 'undefined') {
		            oobClass = _this.options.outOfBoundsClass;
		          } else {
		            oobClass = _this.getClass('out-of-bounds');
		          }
		
		          addClasses.push(oobClass);
		          oob.forEach(function (side) {
		            addClasses.push(oobClass + '-' + side);
		          });
		        })();
		      }
		
		      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {
		        eAttachment.left = tAttachment.left = false;
		      }
		      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {
		        eAttachment.top = tAttachment.top = false;
		      }
		
		      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
		        _this.updateAttachClasses(eAttachment, tAttachment);
		      }
		    });
		
		    defer(function () {
		      if (!(_this.options.addTargetClasses === false)) {
		        updateClasses(_this.target, addClasses, allClasses);
		      }
		      updateClasses(_this.element, addClasses, allClasses);
		    });
		
		    return { top: top, left: left };
		  }
		});
		/* globals TetherBase */
		
		'use strict';
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getBounds = _TetherBase$Utils.getBounds;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var _this = this;
		
		    var top = _ref.top;
		    var left = _ref.left;
		
		    var _cache = this.cache('element-bounds', function () {
		      return getBounds(_this.element);
		    });
		
		    var height = _cache.height;
		    var width = _cache.width;
		
		    var targetPos = this.getTargetBounds();
		
		    var bottom = top + height;
		    var right = left + width;
		
		    var abutted = [];
		    if (top <= targetPos.bottom && bottom >= targetPos.top) {
		      ['left', 'right'].forEach(function (side) {
		        var targetPosSide = targetPos[side];
		        if (targetPosSide === left || targetPosSide === right) {
		          abutted.push(side);
		        }
		      });
		    }
		
		    if (left <= targetPos.right && right >= targetPos.left) {
		      ['top', 'bottom'].forEach(function (side) {
		        var targetPosSide = targetPos[side];
		        if (targetPosSide === top || targetPosSide === bottom) {
		          abutted.push(side);
		        }
		      });
		    }
		
		    var allClasses = [];
		    var addClasses = [];
		
		    var sides = ['left', 'top', 'right', 'bottom'];
		    allClasses.push(this.getClass('abutted'));
		    sides.forEach(function (side) {
		      allClasses.push(_this.getClass('abutted') + '-' + side);
		    });
		
		    if (abutted.length) {
		      addClasses.push(this.getClass('abutted'));
		    }
		
		    abutted.forEach(function (side) {
		      addClasses.push(_this.getClass('abutted') + '-' + side);
		    });
		
		    defer(function () {
		      if (!(_this.options.addTargetClasses === false)) {
		        updateClasses(_this.target, addClasses, allClasses);
		      }
		      updateClasses(_this.element, addClasses, allClasses);
		    });
		
		    return true;
		  }
		});
		/* globals TetherBase */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var top = _ref.top;
		    var left = _ref.left;
		
		    if (!this.options.shift) {
		      return;
		    }
		
		    var shift = this.options.shift;
		    if (typeof this.options.shift === 'function') {
		      shift = this.options.shift.call(this, { top: top, left: left });
		    }
		
		    var shiftTop = undefined,
		        shiftLeft = undefined;
		    if (typeof shift === 'string') {
		      shift = shift.split(' ');
		      shift[1] = shift[1] || shift[0];
		
		      var _shift = shift;
		
		      var _shift2 = _slicedToArray(_shift, 2);
		
		      shiftTop = _shift2[0];
		      shiftLeft = _shift2[1];
		
		      shiftTop = parseFloat(shiftTop, 10);
		      shiftLeft = parseFloat(shiftLeft, 10);
		    } else {
		      shiftTop = shift.top;
		      shiftLeft = shift.left;
		    }
		
		    top += shiftTop;
		    left += shiftLeft;
		
		    return { top: top, left: left };
		  }
		});
		return Tether;
		
		}));
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    props: {
		        id: String
		    },
		
		    methods: {
		        eventTargetsComponent: function eventTargetsComponent(eventTarget) {
		            if (eventTarget === undefined || this.id === eventTarget) {
		                return true;
		            }
		
		            return false;
		        }
		    }
		};
	
	/***/ },
	/* 62 */
	/***/ function(module, exports) {
	
		module.exports = "\n<ul\n    class=\"ui-menu\" role=\"menu\" tabindex=\"-1\" @keydown.esc=\"closeDropdown\" v-el:dropdown\n    :class=\"{ 'has-icons': showIcons, 'has-secondary-text': showSecondaryText }\"\n>\n    <ui-menu-option\n        :type=\"option.type\" :icon=\"option.icon\" :text=\"option.text\" :disabled=\"option.disabled\"\n        :secondary-text=\"option.secondaryText\" :option=\"option\" :show-icon=\"showIcons\"\n        :show-secondary-text=\"showSecondaryText\" :hide-ripple-ink=\"hideRippleInk\"\n        :partial=\"option.partial || partial\"\n\n        @keydown.enter.prevent=\"optionSelect(option)\" @click=\"optionSelect(option)\"\n\n        v-for=\"option in options\"\n    ></ui-menu-option>\n\n    <div\n        class=\"ui-menu-focus-redirector\" @focus=\"redirectFocus\" tabindex=\"0\"\n    ></div>\n</ul>\n";
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(64)
		__vue_script__ = __webpack_require__(65)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiPopover.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(66)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiPopover.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 64 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _ShowsDropdown = __webpack_require__(58);
		
		var _ShowsDropdown2 = _interopRequireDefault(_ShowsDropdown);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-popover',
		
		    events: {
		        'dropdown-opened': function dropdownOpened() {
		            if (this.containFocus) {
		                document.addEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('opened');
		
		            return true;
		        },
		
		        'dropdown-closed': function dropdownClosed() {
		            if (this.containFocus) {
		                document.removeEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('closed');
		
		            return true;
		        }
		    },
		
		    methods: {
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.dropdown.contains(e.target)) {
		                e.stopPropagation();
		
		                this.$els.dropdown.focus();
		            }
		        }
		    },
		
		    mixins: [_ShowsDropdown2.default]
		};
	
	/***/ },
	/* 66 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-popover\" role=\"dialog\" tabindex=\"-1\" @keydown.esc=\"closeDropdown\" v-el:dropdown\n>\n    <slot></slot>\n</div>\n";
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(68)
		__vue_script__ = __webpack_require__(69)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiProgressCircular.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(70)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiProgressCircular.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 68 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 69 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-progress-circular',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: false
		        },
		        type: {
		            type: String,
		            default: 'indeterminate' },
		        color: {
		            type: String,
		            default: 'primary' },
		        value: {
		            type: Number,
		            default: 0
		        },
		        size: {
		            type: Number,
		            default: 32
		        },
		        stroke: Number,
		        autoStroke: {
		            type: Boolean,
		            default: true
		        },
		        disableTransition: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        strokeDashArray: function strokeDashArray() {
		            var circumference = 2 * Math.PI * this.radius;
		
		            return Math.round(circumference * 1000) / 1000;
		        },
		        strokeDashOffset: function strokeDashOffset() {
		            var value = this.moderateValue(this.value);
		            var circumference = 2 * Math.PI * this.radius;
		
		            return (100 - value) / 100 * circumference;
		        },
		        radius: function radius() {
		            return (this.size - this.stroke) / 2;
		        }
		    },
		
		    created: function created() {
		        if (!this.stroke) {
		            if (this.autoStroke) {
		                this.stroke = parseInt(this.size / 8, 10);
		            } else {
		                this.stroke = 4;
		            }
		        }
		    },
		
		
		    methods: {
		        moderateValue: function moderateValue(value) {
		            if (isNaN(value) || value < 0) {
		                return 0;
		            }
		
		            if (value > 100) {
		                return 100;
		            }
		
		            return value;
		        }
		    }
		};
	
	/***/ },
	/* 70 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-progress-circular\" :style=\"{ 'width': size + 'px', 'height': size + 'px' }\"\n    v-show=\"show\" :transition=\"disableTransition ? null : 'ui-progress-circular-toggle'\"\n>\n    <svg\n        class=\"ui-progress-circular-determinate\" :width=\"size\" :height=\"size\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" :aria-valuenow=\"value\"\n        v-if=\"type === 'determinate'\"\n    >\n        <circle\n            class=\"ui-progress-circular-determinate-path\" :class=\"[color]\" :r=\"radius\"\n            :cx=\"size / 2\" :cy=\"size / 2\" fill=\"transparent\" :stroke-dasharray=\"strokeDashArray\"\n            stroke-dashoffset=\"0\"\n\n            :style=\"{ 'stroke-dashoffset': strokeDashOffset, 'stroke-width': stroke }\"\n        ></circle>\n    </svg>\n\n    <svg\n        class=\"ui-progress-circular-indeterminate\" viewBox=\"25 25 50 50\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" v-else\n    >\n        <circle\n            class=\"ui-progress-circular-indeterminate-path\" :class=\"[color]\" cx=\"50\" cy=\"50\"\n            r=\"20\" fill=\"none\" stroke-miterlimit=\"10\" :stroke-width=\"stroke\"\n        >\n    </svg>\n</div>\n";
	
	/***/ },
	/* 71 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		exports.default = function (value) {
		    this.el.disabled = Boolean(value);
		};
	
	/***/ },
	/* 72 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    props: {
		        openDropdownOn: String,
		        dropdownPosition: String,
		        hasPopover: {
		            type: Boolean,
		            default: false
		        },
		        hasDropdownMenu: {
		            type: Boolean,
		            default: false
		        },
		        menuOptions: {
		            type: Array,
		            default: function _default() {
		                return [];
		            }
		        },
		        showMenuIcons: {
		            type: Boolean,
		            default: false
		        },
		        showMenuSecondaryText: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    methods: {
		        menuOptionSelect: function menuOptionSelect(option) {
		            this.$dispatch('menu-option-selected', option);
		        }
		    }
		};
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiTooltip = __webpack_require__(74);
		
		var _UiTooltip2 = _interopRequireDefault(_UiTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        tooltip: String,
		        openTooltipOn: String,
		        tooltipPosition: String
		    },
		
		    components: {
		        UiTooltip: _UiTooltip2.default
		    }
		};
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(75)
		__vue_script__ = __webpack_require__(76)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTooltip.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(78)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTooltip.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 75 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _tetherTooltip = __webpack_require__(77);
		
		var _tetherTooltip2 = _interopRequireDefault(_tetherTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tooltip',
		
		    props: {
		        content: String,
		        trigger: {
		            type: Element,
		            required: true
		        },
		        position: {
		            type: String,
		            default: 'bottom center'
		        },
		        openOn: {
		            type: String,
		            default: 'hover focus'
		        }
		    },
		
		    data: function data() {
		        return {
		            tooltip: null
		        };
		    },
		
		
		    watch: {
		        trigger: function trigger() {
		            if (!this.tooltip) {
		                this.initialize();
		            }
		        }
		    },
		
		    ready: function ready() {
		        this.initialize();
		    },
		    beforeDestory: function beforeDestory() {
		        if (this.tooltip) {
		            this.tooltip.remove();
		            this.tooltip.destroy();
		        }
		    },
		
		
		    methods: {
		        initialize: function initialize() {
		            if (this.trigger) {
		                this.tooltip = new _tetherTooltip2.default({
		                    target: this.trigger,
		                    content: this.$els.tooltip,
		                    classes: 'ui-tooltip-theme',
		                    position: this.position,
		                    openOn: 'hover focus'
		                });
		            }
		        }
		    }
		};
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether-tooltip 1.1.0 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(59),__webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require('tether-drop'), require('tether'));
		  } else {
		    root.Tooltip = factory(root.Drop, root.Tether);
		  }
		}(this, function(Drop, Tether) {
		
		/* global Tether Drop */
		
		'use strict';
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		var extend = Tether.Utils.extend;
		
		var _Drop = Drop.createContext({
		  classPrefix: 'tooltip'
		});
		
		var defaults = {
		  position: 'top center',
		  openOn: 'hover',
		  classes: 'tooltip-theme-arrows',
		  constrainToWindow: true,
		  constrainToScrollParent: false
		};
		
		var tooltipCount = 0;
		
		var Tooltip = (function () {
		  function Tooltip(options) {
		    _classCallCheck(this, Tooltip);
		
		    this.options = options;
		
		    if (!this.options.target) {
		      throw new Error('Tooltip Error: You must provide a target for Tooltip to attach to');
		    }
		
		    var position = this.options.target.getAttribute('data-tooltip-position');
		    if (position) {
		      if (typeof this.options.position === 'undefined') {
		        this.options.position = position;
		      }
		    }
		
		    var content = this.options.target.getAttribute('data-tooltip');
		
		    if (content) {
		      if (typeof this.options.content === 'undefined') {
		        var contentEl = document.createElement('div');
		        contentEl.innerHTML = content;
		
		        // Add ARIA attributes (see #50)
		        contentEl.setAttribute('role', 'tooltip');
		        contentEl.id = 'drop-tooltip-' + tooltipCount;
		        this.options.target.setAttribute('aria-describedby', contentEl.id);
		        tooltipCount += 1;
		
		        this.options.content = contentEl;
		      }
		    }
		
		    if (!this.options.content) {
		      throw new Error('Tooltip Error: You must provide content for Tooltip to display');
		    }
		
		    this.options = extend({}, defaults, this.options);
		
		    this.drop = new _Drop(this.options);
		  }
		
		  _createClass(Tooltip, [{
		    key: 'close',
		    value: function close() {
		      this.drop.close();
		    }
		  }, {
		    key: 'open',
		    value: function open() {
		      this.drop.open();
		    }
		  }, {
		    key: 'toggle',
		    value: function toggle() {
		      this.drop.toggle();
		    }
		  }, {
		    key: 'remove',
		    value: function remove() {
		      this.drop.remove();
		    }
		  }, {
		    key: 'destroy',
		    value: function destroy() {
		      this.drop.destroy();
		    }
		  }, {
		    key: 'position',
		    value: function position() {
		      this.drop.position();
		    }
		  }]);
		
		  return Tooltip;
		})();
		
		var initialized = [];
		
		Tooltip.init = function () {
		  var tooltipElements = document.querySelectorAll('[data-tooltip]');
		  var len = tooltipElements.length;
		  for (var i = 0; i < len; ++i) {
		    var el = tooltipElements[i];
		    if (initialized.indexOf(el) === -1) {
		      new Tooltip({
		        target: el
		      });
		      initialized.push(el);
		    }
		  }
		};
		
		document.addEventListener('DOMContentLoaded', function () {
		  if (Tooltip.autoinit !== false) {
		    Tooltip.init();
		  }
		});
		return Tooltip;
		
		}));
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-tooltip\" v-text=\"content\" v-el:tooltip></div>\n";
	
	/***/ },
	/* 79 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-icon-button\" :class=\"styleClasses\" :aria-label=\"ariaLabel || tooltip\"\n    :type=\"buttonType\" v-disabled=\"disabled || loading\" v-el:button\n>\n    <ui-icon\n        class=\"ui-icon-button-icon\" :icon=\"icon\" v-show=\"!loading\"\n    ></ui-icon>\n\n    <ui-progress-circular\n        class=\"ui-icon-button-spinner\" :color=\"spinnerColor\" :size=\"24\" :stroke=\"4.5\"\n        disable-transition v-show=\"loading\"\n    ></ui-progress-circular>\n\n    <ui-ripple-ink v-if=\"!hideRippleInk && !disabled\" :trigger=\"$els.button\"></ui-ripple-ink>\n\n    <ui-tooltip\n        :trigger=\"$els.button\" :content=\"tooltip\" :position=\"tooltipPosition\" v-if=\"tooltip\"\n        :open-on=\"openTooltipOn\"\n    ></ui-tooltip>\n\n    <ui-menu\n        class=\"ui-button-dropdown-menu\" :trigger=\"$els.button\" :options=\"menuOptions\"\n        :show-icons=\"showMenuIcons\" :show-secondary-text=\"showMenuSecondaryText\"\n        :open-on=\"openDropdownOn\" @option-selected=\"menuOptionSelect\"\n        :dropdown-position=\"dropdownPosition\" v-if=\"hasDropdownMenu\"\n    ></ui-menu>\n\n    <ui-popover\n        :trigger=\"$els.button\" :open-on=\"openDropdownOn\" :dropdown-position=\"dropdownPosition\"\n        v-if=\"hasPopover\"\n    >\n        <slot name=\"popover\"></slot>\n    </ui-popover>\n</button>\n";
	
	/***/ },
	/* 80 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-alert\">\n    <div\n        class=\"ui-alert-body\" :class=\"[type]\" role=\"alert\" v-show=\"show\"\n        transition=\"ui-alert-toggle\"\n    >\n        <ui-icon class=\"ui-alert-icon\" :icon=\"iconName\" v-if=\"!hideIcon\"></ui-icon>\n\n        <div class=\"ui-alert-text\">\n            <slot>\n                <span v-text=\"text\"></span>\n            </slot>\n        </div>\n\n        <ui-icon-button\n            class=\"ui-alert-close-button\" type=\"clear\" icon=\"&#xE5CD\" aria-label=\"Close\"\n            @click=\"close\" v-if=\"dismissible\"\n        ></ui-icon-button>\n    </div>\n</div>\n";
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(82)
		__vue_script__ = __webpack_require__(83)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAutocomplete.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(108)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAutocomplete.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 82 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _fuzzysearch = __webpack_require__(84);
		
		var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiAutocompleteSuggestion = __webpack_require__(85);
		
		var _UiAutocompleteSuggestion2 = _interopRequireDefault(_UiAutocompleteSuggestion);
		
		var _autofocus = __webpack_require__(90);
		
		var _autofocus2 = _interopRequireDefault(_autofocus);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-autocomplete',
		
		    props: {
		        suggestions: {
		            type: Array,
		            default: []
		        },
		        limit: {
		            type: Number,
		            default: 8
		        },
		        partial: String,
		        append: {
		            type: Boolean,
		            default: false
		        },
		        appendDelimiter: {
		            type: String,
		            default: ', '
		        },
		        minChars: {
		            type: Number,
		            default: 2
		        },
		        showOnUpDown: {
		            type: Boolean,
		            default: true
		        },
		        autofocus: {
		            type: Boolean,
		            default: false
		        },
		        filter: Function,
		        autoHighlightFirstMatch: {
		            type: Boolean,
		            default: true
		        },
		        cycleHighlight: {
		            type: Boolean,
		            default: true
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            showDropdown: false,
		            highlightedItem: -1,
		            ignoreValueChange: false
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            if (document.activeElement === this.$els.input) {
		                document.activeElement.blur();
		            }
		
		            this.value = this.initialValue;
		            this.dirty = false;
		            this.valid = true;
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (!this.ignoreValueChange && this.value.length >= this.minChars) {
		                this.open();
		            }
		
		            this.highlightedItem = this.autoHighlightFirstMatch ? 0 : -1;
		        }
		    },
		
		    ready: function ready() {
		        document.addEventListener('click', this.closeOnExternalClick);
		    },
		    beforeDestroy: function beforeDestroy() {
		        document.removeEventListener('click', this.closeOnExternalClick);
		    },
		
		
		    methods: {
		        search: function search(item) {
		            if (this.filter) {
		                return this.filter(item, this.value);
		            }
		
		            var text = item[this.keys.text] || item;
		            var query = this.value;
		
		            if (typeof query === 'string') {
		                query = query.toLowerCase();
		            }
		
		            return (0, _fuzzysearch2.default)(query, text.toLowerCase());
		        },
		        select: function select(item) {
		            var _this = this;
		
		            if (this.append) {
		                this.value += this.appendDelimiter + (item[this.keys.value] || item);
		            } else {
		                this.value = item[this.keys.value] || item;
		            }
		
		            this.$dispatch('selected', item);
		
		            this.validate();
		
		            this.$nextTick(function () {
		                _this.close();
		                _this.$els.input.focus();
		            });
		        },
		        highlight: function highlight(index) {
		            var firstIndex = 0;
		            var lastIndex = this.$refs.items.length - 1;
		
		            if (index === -2) {
		                index = lastIndex;
		            } else if (index < firstIndex) {
		                index = this.cycleHighlight ? lastIndex : index;
		            } else if (index > lastIndex) {
		                index = this.cycleHighlight ? firstIndex : -1;
		            }
		
		            this.highlightedItem = index;
		
		            if (this.showOnUpDown) {
		                this.open();
		            }
		
		            if (index < firstIndex || index > lastIndex) {
		                this.$dispatch('highlight-overflow', index);
		            } else {
		                this.$dispatch('highlighted', this.$refs.items[index].item, index);
		            }
		        },
		        selectHighlighted: function selectHighlighted(index, e) {
		            if (this.showDropdown && this.$refs.items.length) {
		                e.preventDefault();
		                this.select(this.$refs.items[index].item);
		            }
		        },
		        clearSearch: function clearSearch() {
		            this.value = '';
		        },
		        open: function open() {
		            if (!this.showDropdown) {
		                this.showDropdown = true;
		                this.$dispatch('opened');
		            }
		        },
		        close: function close() {
		            if (this.showDropdown) {
		                this.showDropdown = false;
		                this.highlightedItem = -1;
		
		                this.$dispatch('closed');
		                this.validate();
		            }
		        },
		        closeOnExternalClick: function closeOnExternalClick(e) {
		            if (!this.$els.autocomplete.contains(e.target) && this.showDropdown) {
		                this.close();
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiAutocompleteSuggestion: _UiAutocompleteSuggestion2.default
		    },
		
		    directives: {
		        autofocus: _autofocus2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 84 */
	/***/ function(module, exports) {
	
		'use strict';
		
		function fuzzysearch (needle, haystack) {
		  var tlen = haystack.length;
		  var qlen = needle.length;
		  if (qlen > tlen) {
		    return false;
		  }
		  if (qlen === tlen) {
		    return needle === haystack;
		  }
		  outer: for (var i = 0, j = 0; i < qlen; i++) {
		    var nch = needle.charCodeAt(i);
		    while (j < tlen) {
		      if (haystack.charCodeAt(j++) === nch) {
		        continue outer;
		      }
		    }
		    return false;
		  }
		  return true;
		}
		
		module.exports = fuzzysearch;
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(86)
		__vue_script__ = __webpack_require__(87)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAutocompleteSuggestion.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(89)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAutocompleteSuggestion.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 86 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-autocomplete-suggestion',
		
		    props: {
		        id: {
		            type: String,
		            default: function _default() {
		                return _uuid2.default.short();
		            }
		        },
		        item: {
		            type: [String, Object],
		            required: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-autocomplete-simple' },
		        highlighted: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    partials: {
		        'ui-autocomplete-simple': '\n            <li class="ui-autocomplete-suggestion-item" v-text="item[keys.text] || item"></li>\n        ',
		
		        'ui-autocomplete-image': '\n            <div\n                class="image" :style="{ \'background-image\': \'url(\' + item[keys.image] + \')\' }"\n            ></div>\n            <div class="text" v-text="item[keys.text]"></div>\n        '
		    }
		};
	
	/***/ },
	/* 88 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		/**
		 * Fast UUID generator, RFC4122 version 4 compliant.
		 * @author Jeff Ward (jcward.com).
		 * @license MIT license
		 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
		 **/
		
		var lut = [];
		
		for (var i = 0; i < 256; i++) {
		    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
		}
		
		var generate = function generate() {
		    var d0 = Math.random() * 0xffffffff | 0;
		    var d1 = Math.random() * 0xffffffff | 0;
		    var d2 = Math.random() * 0xffffffff | 0;
		    var d3 = Math.random() * 0xffffffff | 0;
		
		    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
		};
		
		var short = function short(prefix) {
		    prefix = prefix || '';
		
		    var uuid = generate();
		
		    return prefix + uuid.split('-')[0];
		};
		
		exports.default = {
		    generate: generate,
		    short: short
		};
	
	/***/ },
	/* 89 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-autocomplete-suggestion\" :class=\"[partial, { 'highlighted': highlighted }]\"\n    :id=\"id\"\n>\n    <partial :name=\"partial\"></partial>\n</li>\n";
	
	/***/ },
	/* 90 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		exports.default = function (value) {
		    this.el.autofocus = Boolean(value);
		};
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        id: String,
		        name: {
		            type: String,
		            required: true
		        },
		        placeholder: String,
		        value: {
		            type: [String, Number],
		            default: '',
		            twoWay: true
		        },
		        icon: String,
		        iconRight: {
		            type: Boolean,
		            default: false
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        },
		        debounce: {
		            type: Number,
		            default: null
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: ''
		        };
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            var canBeValidated = Boolean(this.validationRules);
		            var hasHelpText = Boolean(this.helpText);
		
		            return canBeValidated || hasHelpText;
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _validatorjs = __webpack_require__(93);
		
		var _validatorjs2 = _interopRequireDefault(_validatorjs);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        valid: {
		            type: Boolean,
		            default: true,
		            twoWay: true
		        },
		        dirty: {
		            type: Boolean,
		            default: false,
		            twoWay: true
		        },
		        hideValidationErrors: {
		            type: Boolean,
		            default: false
		        },
		        validationRules: [String, Array],
		        validationMessages: Object
		    },
		
		    data: function data() {
		        return {
		            validationError: ''
		        };
		    },
		
		
		    events: {
		        'ui-input::set-validity': function uiInputSetValidity(valid, error, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.setValidity(valid, error);
		        }
		    },
		
		    methods: {
		        validate: function validate() {
		            if (!this.validationRules || !this.dirty) {
		                return;
		            }
		
		            var data = {
		                value: this.value
		            };
		
		            var rules = {
		                value: this.validationRules
		            };
		
		            var validation = new _validatorjs2.default(data, rules, this.validationMessages);
		
		            validation.setAttributeNames({ value: this.name.replace(/_/g, ' ') });
		
		            this.setValidity(validation.passes(), validation.errors.first('value'));
		        },
		        setValidity: function setValidity(valid, error) {
		            this.valid = valid;
		
		            if (!valid && error && error.length) {
		                this.validationError = error;
		            }
		        }
		    }
		};
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Rules = __webpack_require__(94);
		var Lang = __webpack_require__(95);
		var Errors = __webpack_require__(106);
		var Attributes = __webpack_require__(97);
		var AsyncResolvers = __webpack_require__(107);
		
		var Validator = function(input, rules, customMessages) {
		  var lang = Validator.getDefaultLang();
		  this.input = input;
		  this.messages = Lang._make(lang);
		  this.messages._setCustom(customMessages);
		  this.setAttributeFormatter(Validator.prototype.attributeFormatter);
		
		  this.errors = new Errors();
		  this.errorCount = 0;
		
		  this.hasAsync = false;
		  this.rules = this._parseRules(rules);
		};
		
		Validator.prototype = {
		
		  constructor: Validator,
		
		  /**
		   * Default language
		   *
		   * @type {string}
		   */
		  lang: 'en',
		
		  /**
		   * Numeric based rules
		   *
		   * @type {array}
		   */
		  numericRules: ['integer', 'numeric'],
		
		  /**
		   * Attribute formatter.
		   *
		   * @type {function}
		   */
		  attributeFormatter: Attributes.formatter,
		
		  /**
		   * Run validator
		   *
		   * @return {boolean} Whether it passes; true = passes, false = fails
		   */
		  check: function() {
		    var self = this;
		
		    for (var attribute in this.rules) {
		      var attributeRules = this.rules[attribute];
		      var inputValue = this.input[attribute]; // if it doesnt exist in input, it will be undefined
		
		      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {
		        ruleOptions = attributeRules[i];
		        rule = this.getRule(ruleOptions.name);
		
		        if (!this._isValidatable(rule, inputValue)) {
		          continue;
		        }
		
		        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);
		        if (!rulePassed) {
		          this._addFailure(rule);
		        }
		
		        if (this._shouldStopValidating(attribute, rulePassed)) {
		          break;
		        }
		      }
		    }
		
		    return this.errorCount === 0;
		  },
		
		  /**
		   * Run async validator
		   *
		   * @param {function} passes
		   * @param {function} fails
		   * @return {void}
		   */
		  checkAsync: function(passes, fails) {
		    var _this = this;
		    passes = passes || function() {};
		    fails = fails || function() {};
		
		    var failsOne = function(rule, message) {
		      _this._addFailure(rule, message);
		    };
		
		    var resolvedAll = function(allPassed) {
		      if (allPassed) {
		        passes();
		      } else {
		        fails();
		      }
		    };
		
		    var validateRule = function(inputValue, ruleOptions, attribute, rule) {
		      return function() {
		        var resolverIndex = asyncResolvers.add(rule);
		        rule.validate(inputValue, ruleOptions.value, attribute, function() {
		          asyncResolvers.resolve(resolverIndex);
		        });
		      };
		    };
		
		    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);
		
		    for (var attribute in this.rules) {
		      var attributeRules = this.rules[attribute];
		      var inputValue = this.input[attribute]; // if it doesnt exist in input, it will be undefined
		
		      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {
		        ruleOptions = attributeRules[i];
		
		        rule = this.getRule(ruleOptions.name);
		
		        if (!this._isValidatable(rule, inputValue)) {
		          continue;
		        }
		
		        validateRule(inputValue, ruleOptions, attribute, rule)();
		      }
		    }
		
		    asyncResolvers.enableFiring();
		    asyncResolvers.fire();
		  },
		
		  /**
		   * Add failure and error message for given rule
		   *
		   * @param {Rule} rule
		   */
		  _addFailure: function(rule) {
		    var msg = this.messages.render(rule);
		    this.errors.add(rule.attribute, msg);
		    this.errorCount++;
		  },
		
		  /**
		   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }
		   *
		   * @param  {object} rules
		   * @return {object}
		   */
		  _parseRules: function(rules) {
		    var parsedRules = {};
		    for (var attribute in rules) {
		      var rulesArray = rules[attribute];
		      var attributeRules = [];
		
		      if (typeof rulesArray === 'string') {
		        rulesArray = rulesArray.split('|');
		      }
		
		      for (var i = 0, len = rulesArray.length, rule; i < len; i++) {
		        rule = this._extractRuleAndRuleValue(rulesArray[i]);
		        if (Rules.isAsync(rule.name)) {
		          this.hasAsync = true;
		        }
		        attributeRules.push(rule);
		      }
		
		      parsedRules[attribute] = attributeRules;
		    }
		    return parsedRules;
		  },
		
		  /**
		   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3
		   *
		   * @param  {string} ruleString min:3
		   * @return {object} object containing the name of the rule and value
		   */
		  _extractRuleAndRuleValue: function(ruleString) {
		    var rule = {},
		      ruleArray;
		
		    rule.name = ruleString;
		
		    if (ruleString.indexOf(':') >= 0) {
		      ruleArray = ruleString.split(':');
		      rule.name = ruleArray[0];
		      rule.value = ruleArray.slice(1).join(":");
		    }
		
		    return rule;
		  },
		
		  /**
		   * Determine if attribute has any of the given rules
		   *
		   * @param  {string}  attribute
		   * @param  {array}   findRules
		   * @return {boolean}
		   */
		  _hasRule: function(attribute, findRules) {
		    var rules = this.rules[attribute] || [];
		    for (var i = 0, len = rules.length; i < len; i++) {
		      if (findRules.indexOf(rules[i].name) > -1) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Determine if attribute has any numeric-based rules.
		   *
		   * @param  {string}  attribute
		   * @return {Boolean}
		   */
		  _hasNumericRule: function(attribute) {
		    return this._hasRule(attribute, this.numericRules);
		  },
		
		  /**
		   * Determine if rule is validatable
		   *
		   * @param  {Rule}   rule
		   * @param  {mixed}  value
		   * @return {boolean}
		   */
		  _isValidatable: function(rule, value) {
		    if (Rules.isImplicit(rule.name)) {
		      return true;
		    }
		
		    return this.getRule('required').validate(value);
		  },
		
		
		  /**
		   * Determine if we should stop validating.
		   *
		   * @param  {string} attribute
		   * @param  {boolean} rulePassed
		   * @return {boolean}
		   */
		  _shouldStopValidating: function(attribute, rulePassed) {
		
		    var stopOnAttributes = this.stopOnAttributes;
		    if (stopOnAttributes === false || rulePassed === true) {
		      return false;
		    }
		
		    if (stopOnAttributes instanceof Array) {
		      return stopOnAttributes.indexOf(attribute) > -1;
		    }
		
		    return true;
		  },
		
		  /**
		   * Set custom attribute names.
		   *
		   * @param {object} attributes
		   * @return {void}
		   */
		  setAttributeNames: function(attributes) {
		    this.messages._setAttributeNames(attributes);
		  },
		
		  /**
		   * Set the attribute formatter.
		   *
		   * @param {fuction} func
		   * @return {void}
		   */
		  setAttributeFormatter: function(func) {
		    this.messages._setAttributeFormatter(func);
		  },
		
		  /**
		   * Get validation rule
		   *
		   * @param  {string} name
		   * @return {Rule}
		   */
		  getRule: function(name) {
		    return Rules.make(name, this);
		  },
		
		  /**
		   * Stop on first error.
		   *
		   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		   * @return {void}
		   */
		  stopOnError: function(attributes) {
		    this.stopOnAttributes = attributes;
		  },
		
		  /**
		   * Determine if validation passes
		   *
		   * @param {function} passes
		   * @return {boolean|undefined}
		   */
		  passes: function(passes) {
		    var async = this._checkAsync('passes', passes);
		    if (async) {
		      return this.checkAsync(passes);
		    }
		    return this.check();
		  },
		
		  /**
		   * Determine if validation fails
		   *
		   * @param {function} fails
		   * @return {boolean|undefined}
		   */
		  fails: function(fails) {
		    var async = this._checkAsync('fails', fails);
		    if (async) {
		      return this.checkAsync(function() {}, fails);
		    }
		    return !this.check();
		  },
		
		  /**
		   * Check if validation should be called asynchronously
		   *
		   * @param  {string}   funcName Name of the caller
		   * @param  {function} callback
		   * @return {boolean}
		   */
		  _checkAsync: function(funcName, callback) {
		    var hasCallback = typeof callback === 'function';
		    if (this.hasAsync && !hasCallback) {
		      throw funcName + ' expects a callback when async rules are being tested.';
		    }
		
		    return this.hasAsync || hasCallback;
		  }
		
		};
		
		/**
		 * Set messages for language
		 *
		 * @param {string} lang
		 * @param {object} messages
		 * @return {this}
		 */
		Validator.setMessages = function(lang, messages) {
		  Lang._set(lang, messages);
		  return this;
		};
		
		/**
		 * Get messages for given language
		 *
		 * @param  {string} lang
		 * @return {Messages}
		 */
		Validator.getMessages = function(lang) {
		  return Lang._get(lang);
		};
		
		/**
		 * Set default language to use
		 *
		 * @param {string} lang
		 * @return {void}
		 */
		Validator.useLang = function(lang) {
		  this.prototype.lang = lang;
		};
		
		/**
		 * Get default language
		 *
		 * @return {string}
		 */
		Validator.getDefaultLang = function() {
		  return this.prototype.lang;
		};
		
		/**
		 * Set the attribute formatter.
		 *
		 * @param {fuction} func
		 * @return {void}
		 */
		Validator.setAttributeFormatter = function(func) {
		  this.prototype.attributeFormatter = func;
		};
		
		/**
		 * Stop on first error.
		 *
		 * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		 * @return {void}
		 */
		Validator.stopOnError = function(attributes) {
		  this.prototype.stopOnAttributes = attributes;
		};
		
		/**
		 * Register custom validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator.register = function(name, fn, message) {
		  var lang = Validator.getDefaultLang();
		  Rules.register(name, fn);
		  Lang._setRuleMessage(lang, name, message);
		};
		
		/**
		 * Register asynchronous validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator.registerAsync = function(name, fn, message) {
		  var lang = Validator.getDefaultLang();
		  Rules.registerAsync(name, fn);
		  Lang._setRuleMessage(lang, name, message);
		};
		
		module.exports = Validator;
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports) {
	
		var rules = {
		
		  required: function(val) {
		    var str;
		
		    if (val === undefined || val === null) {
		      return false;
		    }
		
		    str = String(val).replace(/\s/g, "");
		    return str.length > 0 ? true : false;
		  },
		
		  required_if: function(val, req, attribute) {
		    req = this.getParameters();
		    if (this.validator.input[req[0]] === req[1]) {
		      return this.validator.getRule('required').validate(val);
		    }
		
		    return true;
		  },
		
		  // compares the size of strings
		  // with numbers, compares the value
		  size: function(val, req, attribute) {
		    if (val) {
		      req = parseFloat(req);
		
		      var size = this.getSize();
		
		      return size === req;
		    }
		
		    return true;
		  },
		
		  string: function(val, req, attribute) {
		    return typeof val === 'string';
		  },
		
		  /**
		   * Compares the size of strings or the value of numbers if there is a truthy value
		   */
		  min: function(val, req, attribute) {
		    var size = this.getSize();
		    return size >= req;
		  },
		
		  /**
		   * Compares the size of strings or the value of numbers if there is a truthy value
		   */
		  max: function(val, req, attribute) {
		    var size = this.getSize();
		    return size <= req;
		  },
		
		  between: function(val, req, attribute) {
		    req = this.getParameters();
		    var size = this.getSize();
		    var min = parseFloat(req[0], 10);
		    var max = parseFloat(req[1], 10);
		    return size >= min && size <= max;
		  },
		
		  email: function(val) {
		    var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
		    return re.test(val);
		  },
		
		  numeric: function(val) {
		    var num;
		
		    num = Number(val); // tries to convert value to a number. useful if value is coming from form element
		
		    if (typeof num === 'number' && !isNaN(num) && typeof val !== 'boolean') {
		      return true;
		    } else {
		      return false;
		    }
		  },
		
		  array: function(val) {
		    return val instanceof Array;
		  },
		
		  url: function(url) {
		    return (/^https?:\/\/\S+/).test(url);
		  },
		
		  alpha: function(val) {
		    return (/^[a-zA-Z]+$/).test(val);
		  },
		
		  alpha_dash: function(val) {
		    return (/^[a-zA-Z0-9_\-]+$/).test(val);
		  },
		
		  alpha_num: function(val) {
		    return (/^[a-zA-Z0-9]+$/).test(val);
		  },
		
		  same: function(val, req) {
		    var val1 = this.validator.input[req];
		    var val2 = val;
		
		    if (val1 === val2) {
		      return true;
		    }
		
		    return false;
		  },
		
		  different: function(val, req) {
		    var val1 = this.validator.input[req];
		    var val2 = val;
		
		    if (val1 !== val2) {
		      return true;
		    }
		
		    return false;
		  },
		
		  "in": function(val, req) {
		    var list, i;
		
		    if (val) {
		      list = req.split(',');
		    }
		
		    if (val && !(val instanceof Array)) {
		      val = String(val); // if it is a number
		
		      for (i = 0; i < list.length; i++) {
		        if (val === list[i]) {
		          return true;
		        }
		      }
		
		      return false;
		    }
		
		    if (val && val instanceof Array) {
		      for (i = 0; i < val.length; i++) {
		        if (list.indexOf(val[i]) < 0) {
		          return false;
		        }
		      }
		    }
		
		    return true;
		  },
		
		  not_in: function(val, req) {
		    var list = req.split(',');
		    var len = list.length;
		    var returnVal = true;
		
		    val = String(val); // convert val to a string if it is a number
		
		    for (var i = 0; i < len; i++) {
		      if (val === list[i]) {
		        returnVal = false;
		        break;
		      }
		    }
		
		    return returnVal;
		  },
		
		  accepted: function(val) {
		    if (val === 'on' || val === 'yes' || val === 1 || val === '1' || val === true) {
		      return true;
		    }
		
		    return false;
		  },
		
		  confirmed: function(val, req, key) {
		    var confirmedKey = key + '_confirmation';
		
		    if (this.validator.input[confirmedKey] === val) {
		      return true;
		    }
		
		    return false;
		  },
		
		  integer: function(val) {
		    return String(parseInt(val, 10)) === String(val);
		  },
		
		  digits: function(val, req) {
		    var numericRule = this.validator.getRule('numeric');
		    if (numericRule.validate(val) && String(val).length === parseInt(req)) {
		      return true;
		    }
		
		    return false;
		  },
		
		  regex: function(val, req) {
		    var mod = /[g|i|m]{1,3}$/;
		    var flag = req.match(mod);
		    flag = flag ? flag[0] : "i";
		    req = req.replace(mod, "").slice(1, -1);
		    req = new RegExp(req, flag);
		    return !!val.match(req);
		  }
		
		};
		
		function Rule(name, fn, async) {
		  this.name = name;
		  this.fn = fn;
		  this.passes = null;
		  this.customMessage = undefined;
		  this.async = async;
		}
		
		Rule.prototype = {
		
		  /**
		   * Validate rule
		   *
		   * @param  {mixed} inputValue
		   * @param  {mixed} ruleValue
		   * @param  {string} attribute
		   * @param  {function} callback
		   * @return {boolean|undefined}
		   */
		  validate: function(inputValue, ruleValue, attribute, callback) {
		    var _this = this;
		    this._setValidatingData(attribute, inputValue, ruleValue);
		    if (typeof callback === 'function') {
		      this.callback = callback;
		      var handleResponse = function(passes, message) {
		        _this.response(passes, message);
		      };
		
		      if (this.async) {
		        return this.fn.apply(this, [inputValue, ruleValue, attribute, handleResponse]);
		      } else {
		        return handleResponse(this.fn.apply(this, [inputValue, ruleValue, attribute]));
		      }
		    }
		    return this.fn.apply(this, [inputValue, ruleValue, attribute]);
		  },
		
		  /**
		   * Set validating data
		   *
		   * @param {string} attribute
		   * @param {mixed} inputValue
		   * @param {mixed} ruleValue
		   * @return {void}
		   */
		  _setValidatingData: function(attribute, inputValue, ruleValue) {
		    this.attribute = attribute;
		    this.inputValue = inputValue;
		    this.ruleValue = ruleValue;
		  },
		
		  /**
		   * Get parameters
		   *
		   * @return {array}
		   */
		  getParameters: function() {
		    return this.ruleValue ? this.ruleValue.split(',') : [];
		  },
		
		  /**
		   * Get true size of value
		   *
		   * @return {integer|float}
		   */
		  getSize: function() {
		    var value = this.inputValue;
		
		    if (value instanceof Array) {
		      return value.length;
		    }
		
		    if (typeof value === 'number') {
		      return value;
		    }
		
		    if (this.validator._hasNumericRule(this.attribute)) {
		      return parseFloat(value, 10);
		    }
		
		    return value.length;
		  },
		
		  /**
		   * Get the type of value being checked; numeric or string.
		   *
		   * @return {string}
		   */
		  _getValueType: function() {
		
		    if (typeof this.inputValue === 'number' || this.validator._hasNumericRule(this.attribute)) {
		      return 'numeric';
		    }
		
		    return 'string';
		  },
		
		  /**
		   * Set the async callback response
		   *
		   * @param  {boolean|undefined} passes  Whether validation passed
		   * @param  {string|undefined} message Custom error message
		   * @return {void}
		   */
		  response: function(passes, message) {
		    this.passes = (passes === undefined || passes === true);
		    this.customMessage = message;
		    this.callback(this.passes, message);
		  },
		
		  /**
		   * Set validator instance
		   *
		   * @param {Validator} validator
		   * @return {void}
		   */
		  setValidator: function(validator) {
		    this.validator = validator;
		  }
		
		};
		
		var manager = {
		
		  /**
		   * List of async rule names
		   *
		   * @type {Array}
		   */
		  asyncRules: [],
		
		  /**
		   * Implicit rules (rules to always validate)
		   *
		   * @type {Array}
		   */
		  implicitRules: ['required', 'required_if', 'accepted'],
		
		  /**
		   * Get rule by name
		   *
		   * @param  {string} name
		   * @param {Validator}
		   * @return {Rule}
		   */
		  make: function(name, validator) {
		    var async = this.isAsync(name);
		    var rule = new Rule(name, rules[name], async);
		    rule.setValidator(validator);
		    return rule;
		  },
		
		  /**
		   * Determine if given rule is async
		   *
		   * @param  {string}  name
		   * @return {boolean}
		   */
		  isAsync: function(name) {
		    for (var i = 0, len = this.asyncRules.length; i < len; i++) {
		      if (this.asyncRules[i] === name) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Determine if rule is implicit (should always validate)
		   *
		   * @param {string} name
		   * @return {boolean}
		   */
		  isImplicit: function(name) {
		    return this.implicitRules.indexOf(name) > -1;
		  },
		
		  /**
		   * Register new rule
		   *
		   * @param  {string}   name
		   * @param  {function} fn
		   * @return {void}
		   */
		  register: function(name, fn) {
		    rules[name] = fn;
		  },
		
		  /**
		   * Register async rule
		   *
		   * @param  {string}   name
		   * @param  {function} fn
		   * @return {void}
		   */
		  registerAsync: function(name, fn) {
		    this.register(name, fn);
		    this.asyncRules.push(name);
		  }
		
		};
		
		
		module.exports = manager;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Messages = __webpack_require__(96);
		
		__webpack_require__(98);
		
		var container = {
		
		  messages: {},
		
		  /**
		   * Set messages for language
		   *
		   * @param {string} lang
		   * @param {object} rawMessages
		   * @return {void}
		   */
		  _set: function(lang, rawMessages) {
		    this.messages[lang] = rawMessages;
		  },
		
		  /**
		   * Set message for given language's rule.
		   *
		   * @param {string} lang
		   * @param {string} attribute
		   * @param {string|object} message
		   * @return {void}
		   */
		  _setRuleMessage: function(lang, attribute, message) {
		    this._load(lang);
		    if (message === undefined) {
		      message = this.messages[lang].def;
		    }
		
		    this.messages[lang][attribute] = message;
		  },
		
		  /**
		   * Load messages (if not already loaded)
		   *
		   * @param  {string} lang
		   * @return {void}
		   */
		  _load: function(lang) {
		    if (!this.messages[lang]) {
		      var rawMessages = __webpack_require__(99)("./" + lang);
		      this._set(lang, rawMessages);
		    }
		  },
		
		  /**
		   * Get raw messages for language
		   *
		   * @param  {string} lang
		   * @return {object}
		   */
		  _get: function(lang) {
		    this._load(lang);
		    return this.messages[lang];
		  },
		
		  /**
		   * Make messages for given language
		   *
		   * @param  {string} lang
		   * @return {Messages}
		   */
		  _make: function(lang) {
		    this._load(lang);
		    return new Messages(lang, this.messages[lang]);
		  }
		
		};
		
		module.exports = container;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Attributes = __webpack_require__(97);
		
		var Messages = function(lang, messages) {
		  this.lang = lang;
		  this.messages = messages;
		  this.customMessages = {};
		  this.attributeNames = {};
		};
		
		Messages.prototype = {
		  constructor: Messages,
		
		  /**
		   * Set custom messages
		   *
		   * @param {object} customMessages
		   * @return {void}
		   */
		  _setCustom: function(customMessages) {
		    this.customMessages = customMessages || {};
		  },
		
		  /**
		   * Set custom attribute names.
		   *
		   * @param {object} attributes
		   */
		  _setAttributeNames: function(attributes) {
		    this.attributeNames = attributes;
		  },
		
		  /**
		   * Set the attribute formatter.
		   *
		   * @param {fuction} func
		   * @return {void}
		   */
		  _setAttributeFormatter: function(func) {
		    this.attributeFormatter = func;
		  },
		
		  /**
		   * Get attribute name to display.
		   *
		   * @param  {string} attribute
		   * @return {string}
		   */
		  _getAttributeName: function(attribute) {
		    var name = attribute;
		    if (this.attributeNames.hasOwnProperty(attribute)) {
		      return this.attributeNames[attribute];
		    } else if (this.messages.attributes.hasOwnProperty(attribute)) {
		      name = this.messages.attributes[attribute];
		    }
		
		    if (this.attributeFormatter) {
		      name = this.attributeFormatter(name);
		    }
		
		    return name;
		  },
		
		  /**
		   * Get all messages
		   *
		   * @return {object}
		   */
		  all: function() {
		    return this.messages;
		  },
		
		  /**
		   * Render message
		   *
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  render: function(rule) {
		    if (rule.customMessage) {
		      return rule.customMessage;
		    }
		    var template = this._getTemplate(rule);
		
		    var message;
		    if (Attributes.replacements[rule.name]) {
		      message = Attributes.replacements[rule.name].apply(this, [template, rule]);
		    } else {
		      message = this._replacePlaceholders(rule, template, {});
		    }
		
		    return message;
		  },
		
		  /**
		   * Get the template to use for given rule
		   *
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  _getTemplate: function(rule) {
		
		    var messages = this.messages;
		    var template = messages.def;
		    var customMessages = this.customMessages;
		    var formats = [rule.name + '.' + rule.attribute, rule.name];
		
		    for (var i = 0, format; i < formats.length; i++) {
		      format = formats[i];
		      if (customMessages.hasOwnProperty(format)) {
		        template = customMessages[format];
		        break;
		      } else if (messages.hasOwnProperty(format)) {
		        template = messages[format];
		        break;
		      }
		    }
		
		    if (typeof template === 'object') {
		      template = template[rule._getValueType()];
		    }
		
		    return template;
		  },
		
		  /**
		   * Replace placeholders in the template using the data object
		   *
		   * @param  {Rule} rule
		   * @param  {string} template
		   * @param  {object} data
		   * @return {string}
		   */
		  _replacePlaceholders: function(rule, template, data) {
		    var message, attribute;
		
		    data.attribute = this._getAttributeName(rule.attribute);
		    data[rule.name] = rule.getParameters().join(',');
		
		    if (typeof template === 'string' && typeof data === 'object') {
		      message = template;
		
		      for (attribute in data) {
		        message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);
		      }
		    }
		
		    return message;
		  }
		
		};
		
		module.exports = Messages;
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports) {
	
		var replacements = {
		
		  /**
		   * Between replacement (replaces :min and :max)
		   *
		   * @param  {string} template
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  between: function(template, rule) {
		    var parameters = rule.getParameters();
		    return this._replacePlaceholders(rule, template, {
		      min: parameters[0],
		      max: parameters[1]
		    });
		  },
		
		  /**
		   * Required_if replacement.
		   *
		   * @param  {string} template
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  required_if: function(template, rule) {
		    var parameters = rule.getParameters();
		    return this._replacePlaceholders(rule, template, {
		      other: parameters[0],
		      value: parameters[1]
		    });
		  }
		};
		
		function formatter(attribute) {
		  return attribute.replace(/[_\[]/g, ' ').replace(/]/g, '');
		}
		
		module.exports = {
		  replacements: replacements,
		  formatter: formatter
		};
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'The :attribute must be accepted.',
		  alpha: 'The :attribute field must contain only alphabetic characters.',
		  alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',
		  alpha_num: 'The :attribute field must be alphanumeric.',
		  between: 'The :attribute field must be between :min and :max.',
		  confirmed: 'The :attribute confirmation does not match.',
		  email: 'The :attribute format is invalid.',
		  def: 'The :attribute attribute has errors.',
		  digits: 'The :attribute must be :digits digits.',
		  different: 'The :attribute and :different must be different.',
		  'in': 'The selected :attribute is invalid.',
		  integer: 'The :attribute must be an integer.',
		  min: {
		    numeric: 'The :attribute must be at least :min.',
		    string: 'The :attribute must be at least :min characters.'
		  },
		  max: {
		    numeric: 'The :attribute may not be greater than :max.',
		    string: 'The :attribute may not be greater than :max characters.'
		  },
		  not_in: 'The selected :attribute is invalid.',
		  numeric: 'The :attribute must be a number.',
		  required: 'The :attribute field is required.',
		  required_if: 'The :attribute field is required when :other is :value.',
		  same: 'The :attribute and :same fields must match.',
		  size: {
		    numeric: 'The :attribute must be :size.',
		    string: 'The :attribute must be :size characters.'
		  },
		  string: 'The :attribute must be a string.',
		  url: 'The :attribute format is invalid.',
		  regex: 'The :attribute format is invalid',
		  attributes: {}
		};
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
		var map = {
			"./en": 98,
			"./en.js": 98,
			"./es": 100,
			"./es.js": 100,
			"./fr": 101,
			"./fr.js": 101,
			"./it": 102,
			"./it.js": 102,
			"./ja": 103,
			"./ja.js": 103,
			"./pl": 104,
			"./pl.js": 104,
			"./ru": 105,
			"./ru.js": 105
		};
		function webpackContext(req) {
			return __webpack_require__(webpackContextResolve(req));
		};
		function webpackContextResolve(req) {
			return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
		};
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = 99;
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'El campo :attribute debe ser aceptado.',
		  alpha: 'El campo :attribute solo debe contener letras.',
		  alpha_dash: 'El campo :attribute solo debe contener letras, números y guiones.',
		  alpha_num: 'El campo :attribute solo debe contener letras y números.',
		  attributes: {},
		  between: 'El campo :attribute tiene que estar entre :min - :max.',
		  confirmed: 'La confirmación de :attribute no coincide.',
		  different: 'El campo :attribute y :other deben ser diferentes.',
		  digits: 'El campo :attribute debe tener :digits dígitos.',
		  email: 'El campo :attribute no es un correo válido',
		  'in': 'El campo :attribute es inválido.',
		  integer: 'El campo :attribute debe ser un número entero.',
		  max: {
		    numeric: 'El campo :attribute no debe ser mayor a :max.',
		    string: 'El campo :attribute no debe ser mayor que :max caracteres.'
		  },
		  min: {
		    numeric: 'El tamaño del campo :attribute debe ser de al menos :min.',
		    string: 'El campo :attribute debe contener al menos :min caracteres.'
		  },
		  not_in: 'El campo :attribute es inválido.',
		  numeric: 'El campo :attribute debe ser numérico.',
		  regex: 'El formato del campo :attribute es inválido.',
		  required: 'El campo :attribute es obligatorio.',
		  required_if: 'El campo :attribute es obligatorio cuando :other es :value.',
		  same: 'El campo :attribute y :other deben coincidir.',
		  size: {
		    numeric: 'El tamaño del campo :attribute debe ser :size.',
		    string: 'El campo :attribute debe contener :size caracteres.'
		  },
		  url: 'El formato de :attribute es inválido.'
		};
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Le champs :attribute doit être accepté.',
		  alpha: 'Le champs :attribute ne peut contenir que des caractères alphabétiques.',
		  alpha_dash: 'Le champs :attribute ne peut contenir que des caractères alphanumériques, des tirets et underscores.',
		  alpha_num: 'Le champs :attribute doit être alphanumérique.',
		  between: 'Le champs :attribute doit être compris entre :min and :max.',
		  confirmed: 'Le champs :attribute ne correspond pas.',
		  email: 'Le champs :attribute contient un format invalide.',
		  def: 'Le champs :attribute contient un attribut erroné.',
		  digits: 'Le champs :attribute doit être de :digits chiffres.',
		  different: 'Le champs :attribute et :different doivent être differents.',
		  'in': 'Le champs :attribute est invalide.',
		  integer: 'Le champs :attribute doit être un entier.',
		  min: {
		    numeric: 'Le champs :attribute doit être contenir au moins :min.',
		    string: 'Le champs :attribute doit être contenir au moins :min caractères.'
		  },
		  max: {
		    numeric: 'Le champs :attribute ne doit être supérieur à :max.',
		    string: 'Le champs :attribute ne doit être plus de :max characters.'
		  },
		  not_in: 'Le champs :attribute est invalide.',
		  numeric: 'Le champs :attribute doit être un numéro.',
		  required: 'Le champs :attribute est obligatoire.',
		  required_if: 'Le champs :attribute est obligatoire quand :other est :value.',
		  same: 'Le champs :attribute et :same doivent correspondre.',
		  size: {
		    numeric: 'La taille du champs :attribute doit être :size.',
		    string: 'La taille du champs :attribute doit être de :size caractères.'
		  },
		  url: 'Le format du champs :attribute est invalide.',
		  regex: 'Le format du champs :attribute est invalide.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 102 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Il campo :attribute deve essere accettato.',
		  alpha: 'Il campo :attribute deve contenere sono caratteri alfabetici.',
		  alpha_dash: 'Il campo :attribute può contenere solo caratteri alfanumerici oltre a trattini e trattini bassi.',
		  alpha_num: 'Il campo :attribute deve essere alfanumerico.',
		  between: 'Il campo :attribute deve essere compreso tra :min e :max.',
		  confirmed: 'Il campo conferma :attribute non è uguale.',
		  email: 'Il formato dell\'attributo :attribute non è valido.',
		  def: 'Gli attributi del campo :attribute contengono degli errori.',
		  digits: 'Il campo :attribute deve essere di :digits cifre.',
		  different: 'Il campo :attribute e :different devo essere diversi.',
		  'in': 'Il valore del campo :attribute non è valido.',
		  integer: 'Il campo :attribute deve essere un valore intero.',
		  min: {
		    numeric: 'Il campo :attribute deve essere maggiore o uguale di :min.',
		    string: 'Il campo :attribute deve essere composto da almeno :min caratteri.'
		  },
		  max: {
		    numeric: 'Il campo :attribute deve essere minore o uguale di :max.',
		    string: 'Il campo :attribute deve essere composto da massimo :max caratteri.'
		  },
		  not_in: 'Il campo :attribute non è valido.',
		  numeric: 'Il campo :attribute deve essere un numero.',
		  required: 'Il campo :attribute è richiesto.',
		  required_if: 'Il campo :attribute è richiesto quando il campo :other è uguale a :value.',
		  same: 'I campi :attribute e :same devono essere uguali.',
		  size: {
		    numeric: 'La dimensione del campo :attribute deve essere uguale a :size.',
		    string: 'Il campo :attribute deve essere di :size caratteri.'
		  },
		  string: 'Il campo :attribute deve essere una stringa.',
		  url: 'Il formato del campo :attribute non è valido.',
		  regex: 'Il formato del campo :attribute non è valido.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 103 */
	/***/ function(module, exports) {
	
		module.exports = {
		    accepted: ':attributeを確認してください。',
		    alpha: ':attributeは英字のみで入力してください。',
		    alpha_dash: ':attributeは英字とダッシュと下線のみで入力してください。',
		    alpha_num: ':attributeは英数字のみで入力してください。',
		    between: ':attributeは:min〜:max文字で入力してください。',
		    confirmed: ':attributeは確認が一致しません。',
		    email: ':attributeは正しいメールアドレスを入力してください。',
		    def: ':attributeは検証エラーが含まれています。',
		    digits: ':attributeは:digitsの数字のみで入力してください。',
		    different: ':attributeと:differentは同じであってはなりません。',
		    'in': '選択された:attributeは無効です。',
		    integer: ':attributeは整数で入力してください。',
		    min        : {
		        numeric : ":attributeは:min以上を入力してください。",
		        string  : ":attributeは:min文字以上で入力してください。"
		    },
		    max : {
		        numeric : ":attributeは:max以下を入力してください。",
		        string  : ":attributeは:max文字以上で入力してください。"
		    },
		    not_in      : "選択された:attributeは無効です。",
		    numeric     : ":attributeは数値で入力してください。",
		    required    : ":attributeは必須です。",
		    required_if : ":otherは:valueになったら:attributeは必須です。",
		    same        : ":attributeと:sameは同じでなければなりません。",
		    size        : {
		        numeric : ":attributeは:sizeを入力してください。",
		        string  : ":attributeは:size文字で入力してください。"
		    },
		    url        : ":attributeはURIを入力してください。",
		    regex      : ":attributeの値 \":value\" はパターンにマッチする必要があります。",
		    attributes : {}
		};
	
	
	/***/ },
	/* 104 */
	/***/ function(module, exports) {
	
		module.exports = {
		    accepted: 'Pole :attribute musi być zaakceptowane.',
		    alpha: 'Pole :attribute może zawierać tylko litery.',
		    alpha_dash: 'Pole :attribute moze zawierać tylko litery, myślnik i podrkeślenie.',
		    alpha_num: 'Pole :attribute moze zawierac tylko znaki alfanumeryczne.',
		    between: 'Pole :attribute musi mieć długość od :min do :max.',
		    confirmed: 'Pole :attribute nie spełnia warunku potwierdzenia.',
		    email: 'Pole :attribute ma niepoprawny format adresu email.',
		    def: 'Pole :attribute zawiera błędy.',
		    digits: 'Pole :attribute może zawierać tylko cyfry ze zbioru :digits.',
		    different: 'Pola :attribute i :different muszą się różnić.',
		    'in': 'Pole :attribute musi należeć do zbioru :in.',
		    integer: 'Pole :attribute musi być liczbą całkowitą.',
		    min: {
		        numeric: 'Pole :attribute musi być równe conajmniej :min.',
		        string: 'Pole :attribute musi zawierać conajmniej :min znaków.'
		    },
		    max: {
		        numeric: 'Pole :attribute nie moze być większe :max.',
		        string: 'Pole :attribute nie moze być dłuższe niż :max znaków.'
		    },
		    not_in: 'Pole :attribute nie może należeć do zbioru :not_in.',
		    numeric: 'Pole :attribute musi być liczbą.',
		    required: 'Pole :attribute jest wymagane.',
		    required_if: 'Pole :attribute jest wymagane jeśli pole :other jest równe :value.',
		    same: 'Pola :attribute i :same muszą być takie same.',
		    size: {
		        numeric: 'Pole :attribute musi być równe :size.',
		        string: 'Pole :attribute musi zawierać :size znaków.'
		    },
		    string: 'Pole :attribute musi być ciągiem znaków.',
		    url: 'Pole :attribute musi być poprawnym adresem URL.',
		    regex: 'Pole :attribute nie spełnia warunku.',
		    attributes: {}
		};
	
	
	/***/ },
	/* 105 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Вы должны принять :attribute.',
		  alpha: 'Поле :attribute может содержать только буквы.',
		  alpha_dash: 'Поле :attribute может содержать только буквы, цифры, дефисы и символы подчёркивания.',
		  alpha_num: 'Поле :attribute может содержать только буквы и цифры.',
		  between: 'Поле :attribute должно быть между :min и :max.',
		  confirmed: 'Поле :attribute не совпадает с подтверждением.',
		  email: 'Поле :attribute должно быть действительным электронным адресом.',
		  def: 'Поле :attribute содержит ошибки.',
		  digits: 'Длина цифрового поля :attribute должна быть :digits.',
		  different: 'Поля :attribute и :different должны различаться.',
		  'in': 'Выбранное значение для :attribute ошибочно.',
		  integer: 'Поле :attribute должно быть целым числом.',
		  min: {
		    numeric: 'Значение поля :attribute должно быть больше или равно :min.',
		    string: 'Количество символов в поле :attribute должно быть не менее :min.'
		  },
		  max: {
		    numeric: 'Значение поля :attribute должно быть меньше или равно :max.',
		    string: 'Количество символов в поле :attribute не может превышать :max.'
		  },
		  not_in: 'Выбранное значение для :attribute ошибочно.',
		  numeric: 'Поле :attribute должно быть числом.',
		  required: 'Поле :attribute обязательно для заполнения.',
		  required_if: 'Поле :attribute требуется когда значения поля :other равно :value.',
		  same: 'Значение :attribute должно совпадать с :same.',
		  size: {
		    numeric: 'Значение поля :attribute должно быть равным :size.',
		    string: 'Количество символов в поле :attribute должно быть равно :size.'
		  },
		  url: 'Поле :attribute должно содержать валидный URL.',
		  regex: 'Неверный формат поля :attribute.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 106 */
	/***/ function(module, exports) {
	
		var Errors = function() {
		  this.errors = {};
		};
		
		Errors.prototype = {
		  constructor: Errors,
		
		  /**
		   * Add new error message for given attribute
		   *
		   * @param  {string} attribute
		   * @param  {string} message
		   * @return {void}
		   */
		  add: function(attribute, message) {
		    if (!this.has(attribute)) {
		      this.errors[attribute] = [];
		    }
		
		    if (this.errors[attribute].indexOf(message) === -1) {
		      this.errors[attribute].push(message);
		    }
		  },
		
		  /**
		   * Returns an array of error messages for an attribute, or an empty array
		   *
		   * @param  {string} attribute A key in the data object being validated
		   * @return {array} An array of error messages
		   */
		  get: function(attribute) {
		    if (this.has(attribute)) {
		      return this.errors[attribute];
		    }
		
		    return [];
		  },
		
		  /**
		   * Returns the first error message for an attribute, false otherwise
		   *
		   * @param  {string} attribute A key in the data object being validated
		   * @return {string|false} First error message or false
		   */
		  first: function(attribute) {
		    if (this.has(attribute)) {
		      return this.errors[attribute][0];
		    }
		
		    return false;
		  },
		
		  /**
		   * Get all error messages from all failing attributes
		   *
		   * @return {Object} Failed attribute names for keys and an array of messages for values
		   */
		  all: function() {
		    return this.errors;
		  },
		
		  /**
		   * Determine if there are any error messages for an attribute
		   *
		   * @param  {string}  attribute A key in the data object being validated
		   * @return {boolean}
		   */
		  has: function(attribute) {
		    if (this.errors.hasOwnProperty(attribute)) {
		      return true;
		    }
		
		    return false;
		  }
		};
		
		module.exports = Errors;
	
	
	/***/ },
	/* 107 */
	/***/ function(module, exports) {
	
		function AsyncResolvers(onFailedOne, onResolvedAll) {
		  this.onResolvedAll = onResolvedAll;
		  this.onFailedOne = onFailedOne;
		  this.resolvers = {};
		  this.resolversCount = 0;
		  this.passed = [];
		  this.failed = [];
		  this.firing = false;
		}
		
		AsyncResolvers.prototype = {
		
		  /**
		   * Add resolver
		   *
		   * @param {Rule} rule
		   * @return {integer}
		   */
		  add: function(rule) {
		    var index = this.resolversCount;
		    this.resolvers[index] = rule;
		    this.resolversCount++;
		    return index;
		  },
		
		  /**
		   * Resolve given index
		   *
		   * @param  {integer} index
		   * @return {void}
		   */
		  resolve: function(index) {
		    var rule = this.resolvers[index];
		    if (rule.passes === true) {
		      this.passed.push(rule);
		    } else if (rule.passes === false) {
		      this.failed.push(rule);
		      this.onFailedOne(rule);
		    }
		
		    this.fire();
		  },
		
		  /**
		   * Determine if all have been resolved
		   *
		   * @return {boolean}
		   */
		  isAllResolved: function() {
		    return (this.passed.length + this.failed.length) === this.resolversCount;
		  },
		
		  /**
		   * Attempt to fire final all resolved callback if completed
		   *
		   * @return {void}
		   */
		  fire: function() {
		
		    if (!this.firing) {
		      return;
		    }
		
		    if (this.isAllResolved()) {
		      this.onResolvedAll(this.failed.length === 0);
		    }
		
		  },
		
		  /**
		   * Enable firing
		   *
		   * @return {void}
		   */
		  enableFiring: function() {
		    this.firing = true;
		  }
		
		};
		
		module.exports = AsyncResolvers;
	
	
	/***/ },
	/* 108 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-autocomplete\" v-el:autocomplete\n    :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'icon-right': iconRight\n    }\"\n>\n    <div class=\"ui-autocomplete-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-autocomplete-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-autocomplete-content\">\n        <label class=\"ui-autocomplete-label\">\n            <div class=\"ui-autocomplete-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <ui-icon\n                class=\"ui-autocomplete-clear-button\" icon=\"&#xE5CD\" title=\"Clear\"\n                @click=\"clearSearch\" v-show=\"!disabled && value.length\"\n            ></ui-icon>\n\n            <input\n                class=\"ui-autocomplete-input\" :placeholder=\"placeholder\" :name=\"name\"\n                :id=\"id\" autocomplete=\"off\" v-autofocus=\"autofocus\" :debounce=\"debounce\"\n\n                @focus=\"focus\" @blur=\"blur\" @keydown.up.prevent=\"highlight(highlightedItem - 1)\"\n                @keydown.down.prevent=\"highlight(highlightedItem + 1)\" @keydown.tab=\"close\"\n                @keydown.enter=\"selectHighlighted(highlightedItem, $event)\"\n\n                v-model=\"value\" v-disabled=\"disabled\" v-el:input\n            >\n\n            <ul class=\"ui-autocomplete-suggestions\" v-show=\"showDropdown\">\n                <ui-autocomplete-suggestion\n                    :highlighted=\"highlightedItem === index\" :item=\"item\" :partial=\"partial\"\n                    :keys=\"keys\"\n\n                    v-for=\"(index, item) in suggestions | filterBy search | limitBy limit\"\n                    v-ref:items @click=\"select(item)\"\n                ></ui-autocomplete-suggestion>\n            </ul>\n        </label>\n\n        <div class=\"ui-autocomplete-feedback\" v-if=\"showFeedback\">\n            <div\n                class=\"ui-autocomplete-error-text\" v-text=\"validationError\"\n                transition=\"ui-autocomplete-feedback-toggle\"\n                v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-autocomplete-help-text\" transition=\"ui-autocomplete-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(110)
		__vue_script__ = __webpack_require__(111)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiButton.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(112)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiButton.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 110 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 111 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _HasDropdown = __webpack_require__(72);
		
		var _HasDropdown2 = _interopRequireDefault(_HasDropdown);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-button',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-button-' + type;
		            }
		        },
		        buttonType: {
		            type: String,
		            default: 'submit' },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        raised: {
		            type: Boolean,
		            default: false
		        },
		        text: String,
		        icon: String,
		        iconRight: {
		            type: Boolean,
		            default: false
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        showDropdownIcon: {
		            type: Boolean,
		            default: true
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.color];
		
		            if (this.raised) {
		                classes.push('ui-button-raised');
		            }
		
		            if (this.hasDropdownMenu || this.hasPopover) {
		                classes.push('has-dropdown');
		            }
		
		            return classes;
		        },
		        spinnerColor: function spinnerColor() {
		            if (this.color === 'color-default' || this.type === 'ui-button-flat') {
		                return 'black';
		            }
		
		            return 'white';
		        },
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiMenu: _UiMenu2.default,
		        UiPopover: _UiPopover2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasDropdown2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 112 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-button\" :class=\"styleClasses\" :type=\"buttonType\" v-disabled=\"disabled || loading\"\n    v-el:button\n>\n    <div class=\"ui-button-content\" :class=\"{ 'invisible': loading }\">\n        <ui-icon\n            class=\"ui-button-icon\" :class=\"{ 'position-right': iconRight }\" :icon=\"icon\"\n            v-if=\"showIcon\"\n        ></ui-icon>\n\n        <div class=\"ui-button-text\">\n            <slot>\n                <span v-text=\"text\"></span>\n            </slot>\n        </div>\n\n        <ui-icon\n            class=\"ui-button-dropdown-icon\" icon=\"&#xE5C5;\"\n            v-if=\"!iconRight && showDropdownIcon && (hasDropdownMenu || hasPopover)\"\n        ></ui-icon>\n    </div>\n\n    <ui-progress-circular\n        class=\"ui-button-spinner\" :color=\"spinnerColor\" :size=\"18\" :stroke=\"4.5\"\n        disable-transition v-show=\"loading\"\n    ></ui-progress-circular>\n\n    <ui-ripple-ink v-if=\"!hideRippleInk && !disabled\" :trigger=\"$els.button\"></ui-ripple-ink>\n\n    <ui-menu\n        class=\"ui-button-dropdown-menu\" :trigger=\"$els.button\" :options=\"menuOptions\"\n        :show-icons=\"showMenuIcons\" :show-secondary-text=\"showMenuSecondaryText\"\n        :open-on=\"openDropdownOn\" @option-selected=\"menuOptionSelect\"\n        :dropdown-position=\"dropdownPosition\" v-if=\"hasDropdownMenu\"\n    ></ui-menu>\n\n    <ui-popover\n        :trigger=\"$els.button\" :open-on=\"openDropdownOn\" :dropdown-position=\"dropdownPosition\"\n        v-if=\"hasPopover\"\n    >\n        <slot name=\"popover\"></slot>\n    </ui-popover>\n</button>\n";
	
	/***/ },
	/* 113 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(114)
		__vue_script__ = __webpack_require__(115)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiCheckbox.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(116)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiCheckbox.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 114 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-checkbox',
		
		    props: {
		        name: String,
		        model: {
		            type: [Array, String, Boolean],
		            required: true,
		            twoWay: true
		        },
		        value: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: false
		        };
		    },
		
		
		    computed: {
		        isChecked: function isChecked() {
		            if (this.value) {
		                return this.model.indexOf(this.value) > -1;
		            }
		
		            return this.model;
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.model;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.model = this.initialValue;
		        }
		    },
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 116 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-checkbox\"\n    :class=\"{\n        'disabled': disabled, 'checked': isChecked, 'active': active, 'label-left': labelLeft\n    }\"\n>\n    <input\n        class=\"ui-checkbox-input\" type=\"checkbox\" :name=\"name\" @focus=\"focus\" @blur=\"blur\"\n        :value=\"value ? value : null\" v-model=\"model\" v-disabled=\"disabled\"\n    >\n\n    <div class=\"ui-checkbox-checkmark\">\n        <div class=\"ui-checkbox-focus-ring\"></div>\n    </div>\n\n    <div class=\"ui-checkbox-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 117 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(118)
		__vue_script__ = __webpack_require__(119)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiCollapsible.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(120)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiCollapsible.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 118 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-collapsible',
		
		    props: {
		        id: String,
		        open: {
		            type: Boolean,
		            default: false
		        },
		        header: String,
		        transition: {
		            type: String,
		            default: 'ui-collapsible-toggle'
		        },
		        hideIcon: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            height: 0,
		            isReady: false
		        };
		    },
		
		
		    computed: {
		        icon: function icon() {
		            return this.open ? 'keyboard_arrow_up' : 'keyboard_arrow_down';
		        },
		        calculatedHeight: function calculatedHeight() {
		            if (this.height === 0) {
		                return 'initial';
		            }
		
		            return this.height + 'px';
		        }
		    },
		
		    created: function created() {
		        this.id = this.id || _uuid2.default.short('ui-collapsible-');
		    },
		    ready: function ready() {
		        this.isReady = true;
		        this.setHeight();
		    },
		
		
		    events: {
		        'ui-collapsible::refresh-height': function uiCollapsibleRefreshHeight(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.$nextTick(this.setHeight);
		        }
		    },
		
		    methods: {
		        toggleMenu: function toggleMenu() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.open = !this.open;
		        },
		        setHeight: function setHeight() {
		            var body = this.$els.body;
		
		            body.style.display = 'block';
		            this.height = body.scrollHeight;
		
		            if (!this.open) {
		                body.style.display = 'none';
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ShowsRippleInk2.default, _ReceivesTargetedEvent2.default],
		
		    transitions: {
		        'ui-collapsible-toggle': {
		            afterEnter: function afterEnter() {
		                this.$dispatch('opened');
		                this.setHeight();
		            },
		            afterLeave: function afterLeave() {
		                this.$dispatch('closed');
		            }
		        }
		    }
		};
	
	/***/ },
	/* 120 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-collapsible\">\n    <button\n        class=\"ui-collapsible-header\" :class=\"{ 'disabled': disabled }\" :aria-controls=\"id\"\n        :aria-expanded=\"open ? 'true' : 'false'\" @click=\"toggleMenu\" v-disabled=\"disabled\"\n        v-el:button\n    >\n        <div class=\"ui-collapsible-header-content\">\n            <slot name=\"header\">\n                <div v-text=\"header\"></div>\n            </slot>\n        </div>\n\n        <ui-icon class=\"ui-collapsible-header-icon\" :icon=\"icon\" v-if=\"!hideIcon\"></ui-icon>\n\n        <ui-ripple-ink\n            v-if=\"!hideRippleInk && !disabled && isReady\" :trigger=\"$els.button\"\n        ></ui-ripple-ink>\n    </button>\n\n    <div\n        class=\"ui-collapsible-body-wrapper\" :transition=\"transition\"\n        :style=\"{ 'height': calculatedHeight }\" v-show=\"open\"v-el:body\n    >\n        <div class=\"ui-collapsible-body\" :id=\"id\" :aria-hidden=\"open ? null : 'true'\">\n            <slot></slot>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 121 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(122)
		__vue_script__ = __webpack_require__(123)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiConfirm.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(128)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiConfirm.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 122 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _UiModal = __webpack_require__(124);
		
		var _UiModal2 = _interopRequireDefault(_UiModal);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-confirm',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        type: {
		            type: String,
		            default: 'primary' },
		        header: {
		            type: String,
		            default: 'UiConfirm'
		        },
		        confirmButtonText: {
		            type: String,
		            default: 'OK'
		        },
		        confirmButtonIcon: String,
		        denyButtonText: {
		            type: String,
		            default: 'Cancel'
		        },
		        denyButtonIcon: String,
		        autofocus: {
		            type: String,
		            default: 'deny-button' },
		        closeOnConfirm: {
		            type: Boolean,
		            default: false
		        },
		        backdropDismissible: {
		            type: Boolean,
		            default: true
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    methods: {
		        confirm: function confirm() {
		            this.$dispatch('confirmed');
		
		            if (this.closeOnConfirm) {
		                this.show = false;
		            }
		        },
		        deny: function deny() {
		            this.show = false;
		            this.$dispatch('denied');
		        },
		        opened: function opened() {
		            var button = void 0;
		
		            if (this.autofocus === 'confirm-button') {
		                button = this.$els.confirmButton;
		            } else if (this.autofocus === 'deny-button') {
		                button = this.$els.denyButton;
		            }
		
		            if (button) {
		                _classlist2.default.add(button, 'autofocus');
		                button.addEventListener('blur', this.removeAutoFocus);
		
		                button.focus();
		            }
		
		            return true;
		        },
		        removeAutoFocus: function removeAutoFocus() {
		            var button = void 0;
		
		            if (this.autofocus === 'confirm-button') {
		                button = this.$els.confirmButton;
		            } else if (this.autofocus === 'deny-button') {
		                button = this.$els.denyButton;
		            }
		
		            if (button) {
		                button.removeEventListener('blur', this.removeAutoFocus);
		
		                _classlist2.default.remove(button, 'autofocus');
		            }
		        }
		    },
		
		    components: {
		        UiModal: _UiModal2.default,
		        UiButton: _UiButton2.default
		    }
		};
	
	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(125)
		__vue_script__ = __webpack_require__(126)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiModal.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(127)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiModal.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 125 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 126 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-modal',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-modal-' + type;
		            }
		        },
		        header: {
		            type: String,
		            default: 'UiModal Header'
		        },
		        body: {
		            type: String,
		            default: 'UiModal body'
		        },
		        role: {
		            type: String,
		            default: 'dialog' },
		        transition: {
		            type: String,
		            default: 'ui-modal-scale' },
		        showCloseButton: {
		            type: Boolean,
		            default: true
		        },
		        hideFooter: {
		            type: Boolean,
		            default: false
		        },
		        dismissible: {
		            type: Boolean,
		            default: true
		        },
		        backdropDismissible: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    data: function data() {
		        return {
		            lastFocussedElement: null
		        };
		    },
		
		
		    watch: {
		        show: function show() {
		            var _this = this;
		
		            this.$nextTick(function () {
		                if (_this.show) {
		                    _this.opened();
		                } else {
		                    _this.closed();
		                }
		            });
		        }
		    },
		
		    beforeDestroy: function beforeDestroy() {
		        if (this.show) {
		            this.tearDown();
		        }
		    },
		
		
		    methods: {
		        close: function close(e) {
		            if (!this.dismissible) {
		                return;
		            }
		
		            if (e.currentTarget === this.$els.modalMask && e.target !== e.currentTarget) {
		                return;
		            }
		
		            if (e.currentTarget === this.$els.modalMask && !this.backdropDismissible) {
		                return;
		            }
		
		            this.show = false;
		        },
		        opened: function opened() {
		            this.lastFocussedElement = document.activeElement;
		            this.$els.modalContainer.focus();
		
		            _classlist2.default.add(document.body, 'ui-modal-open');
		
		            document.addEventListener('focus', this.restrictFocus, true);
		
		            this.$dispatch('opened');
		        },
		        closed: function closed() {
		            this.tearDown();
		            this.$dispatch('closed');
		        },
		        redirectFocus: function redirectFocus(e) {
		            e.stopPropagation();
		
		            this.$els.modalContainer.focus();
		        },
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.modalContainer.contains(e.target)) {
		                e.stopPropagation();
		                this.$els.modalContainer.focus();
		            }
		        },
		        tearDown: function tearDown() {
		            _classlist2.default.remove(document.body, 'ui-modal-open');
		
		            document.removeEventListener('focus', this.restrictFocus, true);
		
		            if (this.lastFocussedElement) {
		                this.lastFocussedElement.focus();
		            }
		        },
		        transitionEnd: function transitionEnd() {
		            if (this.show) {
		                this.$dispatch('revealed');
		            } else {
		                this.$dispatch('hidden');
		            }
		        }
		    },
		
		    components: {
		        UiIconButton: _UiIconButton2.default,
		        UiButton: _UiButton2.default
		    }
		};
	
	/***/ },
	/* 127 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-modal ui-modal-mask\" v-show=\"show\" :transition=\"transition\" :class=\"[type]\"\n    :role=\"role\" @transitionend=\"transitionEnd | debounce 100\"\n>\n    <div class=\"ui-modal-wrapper\" @click=\"close\" v-el:modal-mask>\n        <div\n            class=\"ui-modal-container\" tabindex=\"-1\" @keydown.esc=\"close\"\n            v-el:modal-container\n        >\n            <div class=\"ui-modal-header\">\n                <slot name=\"header\">\n                    <h1 v-text=\"header\" class=\"ui-modal-header-text\"></h1>\n                </slot>\n\n                <ui-icon-button\n                    type=\"clear\" icon=\"&#xE5CD\" class=\"ui-modal-close-button\" @click=\"close\"\n                    :disabled=\"!dismissible\" v-if=\"showCloseButton\" v-el:close-button\n                ></ui-icon-button>\n            </div>\n\n            <div class=\"ui-modal-body\">\n                <slot>\n                    <div v-text=\"body\"></div>\n                </slot>\n            </div>\n\n            <div class=\"ui-modal-footer\" v-if=\"!hideFooter\">\n                <slot name=\"footer\">\n                    <ui-button @click=\"close\" v-if=\"dismissible\">Close</ui-button>\n                </slot>\n            </div>\n\n            <div class=\"focus-redirector\" @focus=\"redirectFocus\" tabindex=\"0\"></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 128 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-confirm\">\n    <ui-modal\n        :show.sync=\"show\" role=\"alertdialog\" :header=\"header\" @opened=\"opened\" show-close-button\n        :dismissible=\"!loading\" :backdrop-dismissible=\"backdropDismissible\"\n    >\n        <div class=\"ui-confirm-message\">\n            <slot></slot>\n        </div>\n\n        <div slot=\"footer\">\n            <ui-button\n                :color=\"type\" :text=\"confirmButtonText\" :icon=\"confirmButtonIcon\"\n                @click=\"confirm\" :loading=\"loading\" v-el:confirm-button\n            ></ui-button>\n\n            <ui-button\n                :text=\"denyButtonText\" :icon=\"denyButtonIcon\" @click=\"deny\"\n                :disabled=\"loading\" v-el:deny-button\n            ></ui-button>\n        </div>\n    </ui-modal>\n</div>\n";
	
	/***/ },
	/* 129 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(130)
		__vue_script__ = __webpack_require__(131)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiFab.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(132)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiFab.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 130 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 131 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsTooltip = __webpack_require__(73);
		
		var _ShowsTooltip2 = _interopRequireDefault(_ShowsTooltip);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-fab',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal',
		            coerce: function coerce(type) {
		                return 'ui-fab-' + type;
		            }
		        },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        icon: {
		            type: String,
		            required: true
		        },
		        ariaLabel: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ShowsTooltip2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 132 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-fab\" :class=\"[this.type, this.color]\" :aria-label=\"ariaLabel || tooltip\"\n    v-disabled=\"disabled\" v-el:button\n>\n    <ui-icon class=\"ui-fab-icon\" :icon=\"icon\"></ui-icon>\n\n    <ui-ripple-ink :trigger=\"$els.button\" v-if=\"!hideRippleInk && !disabled\"></ui-ripple-ink>\n\n    <ui-tooltip\n        :trigger=\"$els.button\" :content=\"tooltip\" :position=\"tooltipPosition\" v-if=\"tooltip\"\n        :open-on=\"openTooltipOn\"\n    ></ui-tooltip>\n</button>\n";
	
	/***/ },
	/* 133 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(134)
		__vue_script__ = __webpack_require__(135)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiPreloader.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(136)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiPreloader.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 134 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 135 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-preloader',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true
		        }
		    }
		};
	
	/***/ },
	/* 136 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-preloader\">\n    <div\n        class=\"ui-preloader-progressbar\" :class=\"{ 'loading' : show }\"\n        :aria-busy=\"show ? 'true' : false\" role=\"progressbar\"\n    ></div>\n</div>\n";
	
	/***/ },
	/* 137 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(138)
		__vue_script__ = __webpack_require__(139)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiProgressLinear.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(140)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiProgressLinear.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 138 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 139 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-progress-linear',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: false
		        },
		        type: {
		            type: String,
		            default: 'indeterminate' },
		        color: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        value: {
		            type: Number,
		            coerce: Number,
		            default: 0
		        }
		    },
		
		    computed: {
		        progress: function progress() {
		            if (this.value < 0) {
		                return 0;
		            }
		
		            if (this.value > 100) {
		                return 100;
		            }
		
		            return this.value;
		        }
		    }
		};
	
	/***/ },
	/* 140 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-progress-linear\" :class=\"[color]\" v-show=\"show\"\n    transition=\"ui-progress-linear-toggle\"\n>\n    <div\n        class=\"ui-progress-linear-determinate\" :style=\"{ 'width': progress + '%' }\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" :aria-valuenow=\"value\"\n        v-if=\"type === 'determinate'\"\n    ></div>\n\n    <div\n        class=\"ui-progress-linear-indeterminate\" role=\"progressbar\" :aria-valuemin=\"0\"\n        :aria-valuemax=\"100\" v-else\n    ></div>\n</div>\n";
	
	/***/ },
	/* 141 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(142)
		__vue_script__ = __webpack_require__(143)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRadio.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(144)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRadio.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 142 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 143 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-radio',
		
		    props: {
		        id: String,
		        name: String,
		        model: {
		            type: String,
		            default: '',
		            twoWay: true
		        },
		        checked: {
		            type: Boolean,
		            default: false
		        },
		        value: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false
		        };
		    },
		
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		
		            this.$dispatch('focussed');
		        },
		        blur: function blur() {
		            this.active = false;
		
		            this.$dispatch('blurred');
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 144 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-radio\"\n    :class=\"{ 'disabled': disabled, 'checked': active, 'label-left': labelLeft }\"\n>\n    <div class=\"ui-radio-input-wrapper\">\n        <input\n            class=\"ui-radio-input\" type=\"radio\" :id=\"id\" :name=\"name\" :value=\"value\"\n            :checked=\"checked\" @focus=\"focus\" @blur=\"blur\" v-model=\"model\" v-disabled=\"disabled\"\n        >\n\n        <span class=\"ui-radio-border\"></span>\n        <span class=\"ui-radio-inner-dot\"></span>\n    </div>\n\n    <div class=\"ui-radio-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 145 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(146)
		__vue_script__ = __webpack_require__(147)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRadioGroup.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(148)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRadioGroup.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 146 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 147 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _UiRadio = __webpack_require__(141);
		
		var _UiRadio2 = _interopRequireDefault(_UiRadio);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-radio-group',
		
		    props: {
		        name: {
		            type: String,
		            required: true
		        },
		        value: {
		            type: String,
		            default: '',
		            twoWay: true
		        },
		        options: {
		            type: Array,
		            required: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        vertical: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: ''
		        };
		    },
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            return Boolean(this.helpText);
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        }
		    },
		
		    components: {
		        UiRadio: _UiRadio2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 148 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-radio-group\" :id=\"id\"\n    :class=\"{ 'disabled': disabled, 'active': active, 'vertical': vertical }\"\n>\n    <div class=\"ui-radio-group-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n    <div class=\"ui-radio-group-options-wrapper\">\n        <ui-radio\n            class=\"ui-radio-group-radio\" v-for=\"option in options\" :model.sync=\"value\"\n            :name=\"name\" :label=\"option.text || option\" :value=\"option.value || option\"\n            :disabled=\"disabled || option.disabled\" @focussed=\"focus\" @blurred=\"blur\"\n        ></ui-radio>\n    </div>\n\n    <div\n        class=\"ui-radio-group-feedback\" v-if=\"showFeedback\"\n        transition=\"ui-radio-group-feedback-toggle\"\n    >\n        <div class=\"ui-radio-group-help-text\" v-text=\"helpText\"></div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 149 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(150)
		__vue_script__ = __webpack_require__(151)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRating.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(156)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRating.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 150 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 151 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        value: {
		            type: Number,
		            coerce: Number,
		            required: true,
		            twoWay: true
		        },
		        total: {
		            type: Number,
		            coerce: Number,
		            required: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: 0,
		            previewValue: 0,
		            previewing: false
		        };
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            return Boolean(this.helpText);
		        }
		    },
		
		    watch: {
		        value: function value() {
		            this.previewValue = this.value;
		        },
		        previewValue: function previewValue() {
		            this.$dispatch('preview-value-changed', this.previewValue);
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.value;
		
		        this.previewValue = this.value;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    methods: {
		        startPreview: function startPreview() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewing = true;
		        },
		        endPreview: function endPreview() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewing = false;
		            this.previewValue = this.value;
		        },
		        preview: function preview(n) {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewValue = n + 1;
		        },
		        commitValue: function commitValue(value) {
		            if (this.disabled) {
		                return;
		            }
		
		            if (value > 0 && value <= this.total) {
		                this.value = value;
		            }
		        },
		        incrementPreviewValue: function incrementPreviewValue() {
		            if (this.disabled) {
		                return;
		            }
		
		            var proposedValue = this.previewValue + 1;
		
		            if (proposedValue <= this.total) {
		                this.previewValue = proposedValue;
		            }
		        },
		        decrementPreviewValue: function decrementPreviewValue() {
		            if (this.disabled) {
		                return;
		            }
		
		            var proposedValue = this.previewValue - 1;
		
		            if (proposedValue > 0) {
		                this.previewValue = proposedValue;
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		            this.startPreview();
		        },
		        blur: function blur() {
		            this.active = false;
		
		            this.commitValue(this.previewValue);
		            this.endPreview();
		        }
		    },
		
		    components: {
		        UiRatingIcon: _UiRatingIcon2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 152 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(153)
		__vue_script__ = __webpack_require__(154)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRatingIcon.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(155)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRatingIcon.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 153 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 154 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating-icon',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        selected: {
		            type: Boolean,
		            required: true
		        },
		        filled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        icon: function icon() {
		            if (this.filled || this.selected) {
		                return this.type === 'star' ? 'star' : 'favorite';
		            }
		
		            return this.type === 'star' ? 'star_border' : 'favorite_border';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    }
		};
	
	/***/ },
	/* 155 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-rating-icon\">\n    <ui-icon\n        class=\"ui-rating-icon-icon\" :icon=\"icon\"\n        :class=\"{ 'selected': selected, 'filled' : filled }\"\n    ></ui-icon>\n</div>\n";
	
	/***/ },
	/* 156 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-rating\" :class=\"{ 'disabled': disabled, 'preview': previewing, 'active': active }\"\n\n    :tabindex=\"disabled ? null : 0\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"total\"\n    :aria-valuenow=\"previewValue\"\n\n    @keydown.up.prevent=\"incrementPreviewValue\" @keydown.down.prevent=\"decrementPreviewValue\"\n    @keydown.right.prevent=\"incrementPreviewValue\" @keydown.left.prevent=\"decrementPreviewValue\"\n    @keydown.enter.prevent=\"commitValue(previewValue)\" @focus=\"focus\" @blur=\"blur\"\n>\n    <div class=\"ui-rating-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n    <div\n        class=\"ui-rating-icons-wrapper\" @mouseenter=\"startPreview\" @mouseleave=\"endPreview\"\n    >\n        <ui-rating-icon\n            :type=\"type\" v-for=\"n in total\" :selected=\"(n + 1) <= value\" @mouseover=\"preview(n)\"\n            :filled=\"(n + 1) <= previewValue\" @click=\"commitValue(n + 1)\"\n        ></ui-rating-icon>\n    </div>\n\n    <div\n        class=\"ui-rating-feedback\" v-if=\"showFeedback\" transition=\"ui-rating-feedback-toggle\"\n    >\n        <div class=\"ui-rating-help-text\" v-text=\"helpText\"></div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 157 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(158)
		__vue_script__ = __webpack_require__(159)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRatingPreview.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(160)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRatingPreview.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 158 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 159 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating-preview',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        value: {
		            type: Number,
		            coerce: Number,
		            required: true
		        },
		        total: {
		            type: Number,
		            coerce: Number,
		            required: true
		        }
		    },
		
		    components: {
		        UiRatingIcon: _UiRatingIcon2.default
		    }
		};
	
	/***/ },
	/* 160 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-rating-preview\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"total\"\n    :aria-valuenow=\"value\"\n>\n    <ui-rating-icon\n        :type=\"type\" v-for=\"n in total\" :selected=\"(n + 1) <= value\"\n    ></ui-rating-icon>\n</div>\n";
	
	/***/ },
	/* 161 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(162)
		__vue_script__ = __webpack_require__(163)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSelect.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(171)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSelect.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 162 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 163 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _mergeOptions = __webpack_require__(164);
		
		var _mergeOptions2 = _interopRequireDefault(_mergeOptions);
		
		var _fuzzysearch = __webpack_require__(84);
		
		var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);
		
		var _elementScroll = __webpack_require__(166);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiSelectOption = __webpack_require__(167);
		
		var _UiSelectOption2 = _interopRequireDefault(_UiSelectOption);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-select',
		
		    props: {
		        value: {
		            type: [Object, Array, String, Number],
		            default: null,
		            twoWay: true
		        },
		        default: {
		            type: [Object, Array, String, Number],
		            default: null
		        },
		        options: {
		            type: Array,
		            default: []
		        },
		        partial: String,
		        showSearch: {
		            type: Boolean,
		            default: false
		        },
		        searchPlaceholder: {
		            type: String,
		            default: 'Search'
		        },
		        multiple: {
		            type: Boolean,
		            default: false
		        },
		        multipleDelimiter: {
		            type: String,
		            default: ', '
		        },
		        optionsDynamic: {
		            type: Boolean,
		            default: false
		        },
		        optionsLoaded: {
		            type: Boolean,
		            default: true
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        },
		        filter: Function
		    },
		
		    data: function data() {
		        return {
		            query: '',
		            selectedIndex: -1,
		            highlightedIndex: -1,
		            showDropdown: false,
		            ignoreQueryChange: false
		        };
		    },
		
		
		    computed: {
		        filteredOptions: function filteredOptions() {
		            if (this.optionsDynamic) {
		                return this.options;
		            }
		
		            return this.options.filter(this.search);
		        },
		        displayText: function displayText() {
		            var _this = this;
		
		            if (this.multiple && this.value.length) {
		                var labels = this.value.map(function (value) {
		                    return value[_this.keys.text] || value;
		                });
		
		                return labels.join(this.multipleDelimiter);
		            }
		
		            return this.value ? this.value[this.keys.text] || this.value : '';
		        },
		        hasDisplayText: function hasDisplayText() {
		            return this.displayText && Boolean(this.displayText.length);
		        },
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        nothingFound: function nothingFound() {
		            if (this.optionsDynamic && !this.optionsLoaded) {
		                return false;
		            }
		
		            if (this.query.length && !this.loading) {
		                return !Boolean(this.filteredOptions.length);
		            }
		
		            return false;
		        }
		    },
		
		    watch: {
		        filteredOptions: function filteredOptions() {
		            this.highlightedIndex = 0;
		            (0, _elementScroll.resetScroll)(this.$els.optionsList);
		        },
		        showDropdown: function showDropdown() {
		            if (this.showDropdown) {
		                this.opened();
		                this.$dispatch('opened');
		            } else {
		                this.closed();
		                this.$dispatch('closed');
		            }
		        },
		        query: function query() {
		            if (!this.ignoreQueryChange) {
		                this.$dispatch('query-changed', this.query);
		            }
		        }
		    },
		
		    created: function created() {
		        this.initValue();
		
		        var errorMessages = {
		            min: 'You must select at least :min options.',
		            max: 'You must select no more than :max options.',
		            between: 'You must select at least :min but no more than :max options.'
		        };
		
		        if (this.validationRules) {
		            this.validationMessages = (0, _mergeOptions2.default)(errorMessages, this.validationMessages);
		        }
		    },
		    ready: function ready() {
		        document.addEventListener('click', this.closeOnExternalClick);
		    },
		    beforeDestroy: function beforeDestroy() {
		        document.removeEventListener('click', this.closeOnExternalClick);
		    },
		
		
		    events: {
		        'ui-select::set-selected': function uiSelectSetSelected(value, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.default = value;
		            this.initValue();
		        },
		
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.initValue();
		            this.dirty = false;
		            this.valid = true;
		
		            this.clearQuery();
		            this.selectedIndex = -1;
		            this.highlightedIndex = -1;
		        }
		    },
		
		    methods: {
		        initValue: function initValue() {
		            this.value = this.multiple ? [] : null;
		
		            if (this.default) {
		                var defaults = Array.isArray(this.default) ? this.default : [this.default];
		
		                if (defaults.length) {
		                    this.setDefaultValue(defaults);
		                }
		            }
		        },
		        search: function search(option) {
		            if (this.filter) {
		                return this.filter(option, this.query);
		            }
		
		            var query = this.query.toLowerCase();
		            var text = option[this.keys.text] || option;
		
		            if (typeof text === 'string') {
		                text = text.toLowerCase();
		            }
		
		            return (0, _fuzzysearch2.default)(query, text);
		        },
		        clearQuery: function clearQuery() {
		            var _this2 = this;
		
		            this.ignoreQueryChange = true;
		
		            this.$nextTick(function () {
		                _this2.query = '';
		
		                _this2.$nextTick(function () {
		                    _this2.ignoreQueryChange = false;
		                });
		            });
		        },
		        select: function select(option, index) {
		            var close = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
		
		            if (this.multiple) {
		                if (this.isSelected(option)) {
		                    this.deselect(option);
		                } else {
		                    this.value.push(option);
		                }
		            } else {
		                this.value = option;
		                this.selectedIndex = index;
		            }
		
		            this.$dispatch('selected', option);
		
		            this.highlightedIndex = index;
		            this.clearQuery();
		            this.validate();
		
		            if (!this.multiple && close) {
		                this.close();
		            }
		        },
		        deselect: function deselect(option) {
		            this.value.$remove(option);
		        },
		        isSelected: function isSelected(option) {
		            if (this.multiple) {
		                return this.value.indexOf(option) > -1;
		            }
		
		            return this.value === option;
		        },
		        selectHighlighted: function selectHighlighted(index, e) {
		            if (this.$refs.options.length) {
		                e.preventDefault();
		                this.select(this.$refs.options[index].option, index);
		            }
		        },
		        highlight: function highlight(index, preventScroll) {
		            if (this.highlightedIndex === index || this.$refs.options.length === 0) {
		                return;
		            }
		
		            var firstIndex = 0;
		            var lastIndex = this.$refs.options.length - 1;
		
		            if (index < firstIndex) {
		                index = lastIndex;
		            } else if (index > lastIndex) {
		                index = firstIndex;
		            }
		
		            this.highlightedIndex = index;
		
		            if (!preventScroll) {
		                this.scrollOptionIntoView(this.$refs.options[index].$el);
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		
		            if (this.showDropdown) {
		                this.close();
		            }
		        },
		        toggle: function toggle() {
		            if (this.showDropdown) {
		                this.close();
		            } else {
		                this.open();
		            }
		        },
		        open: function open() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.showDropdown = true;
		        },
		        opened: function opened() {
		            var _this3 = this;
		
		            this.$nextTick(function () {
		                if (_this3.showSearch) {
		                    _this3.$els.searchInput.focus();
		                } else {
		                    _this3.$els.dropdown.focus();
		                }
		
		                _this3.scrollOptionIntoView(_this3.$els.optionsList.querySelector('.selected'));
		            });
		        },
		        close: function close(deactivate) {
		            this.showDropdown = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            if (deactivate) {
		                this.active = false;
		            } else {
		                this.$els.label.focus();
		            }
		        },
		        closeOnExternalClick: function closeOnExternalClick(e) {
		            if (!this.$el.contains(e.target) && (this.showDropdown || this.active)) {
		                this.close(true);
		            }
		        },
		        closed: function closed() {
		            this.validate();
		
		            if (this.multiple) {
		                this.highlightedIndex = -1;
		            } else {
		                this.highlightedIndex = this.selectedIndex;
		            }
		        },
		        setDefaultValue: function setDefaultValue(defaults) {
		            var optionValue = void 0;
		            var defaultOptionValue = void 0;
		
		            for (var i = 0; i < defaults.length; i++) {
		                defaultOptionValue = defaults[i][this.keys.value] || defaults[i];
		
		                for (var j = 0; j < this.options.length; j++) {
		                    optionValue = this.options[j][this.keys.value] || this.options[j];
		
		                    if (optionValue === defaultOptionValue) {
		                        this.select(this.options[j], j, false);
		                        break;
		                    }
		                }
		            }
		        },
		        scrollOptionIntoView: function scrollOptionIntoView(optionEl) {
		            (0, _elementScroll.scrollIntoView)(optionEl, this.$els.optionsList, 80);
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiSelectOption: _UiSelectOption2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 164 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var isOptionObject = __webpack_require__(165);
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.propertyIsEnumerable;
		var globalThis = this;
		var defaultMergeOpts = {
			concatArrays: false
		};
		
		function getEnumerableOwnPropertyKeys(value) {
			var keys = [];
		
			for (var key in value) {
				if (hasOwnProperty.call(value, key)) {
					keys.push(key);
				}
			}
		
			if (Object.getOwnPropertySymbols) {
				var symbols = Object.getOwnPropertySymbols(value);
		
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(value, symbols[i])) {
						keys.push(symbols[i]);
					}
				}
			}
		
			return keys;
		}
		
		function clone(value) {
			if (Array.isArray(value)) {
				return cloneArray(value);
			}
		
			if (isOptionObject(value)) {
				return cloneOptionObject(value);
			}
		
			return value;
		}
		
		function cloneArray(array) {
			var result = array.slice(0, 0);
		
			getEnumerableOwnPropertyKeys(array).forEach(function (key) {
				result[key] = clone(array[key]);
			});
		
			return result;
		}
		
		function cloneOptionObject(obj) {
			var result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};
		
			getEnumerableOwnPropertyKeys(obj).forEach(function (key) {
				result[key] = clone(obj[key]);
			});
		
			return result;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 */
		function mergeKeys(merged, source, keys, mergeOpts) {
			keys.forEach(function (key) {
				if (key in merged) {
					merged[key] = merge(merged[key], source[key], mergeOpts);
				} else {
					merged[key] = clone(source[key]);
				}
			});
		
			return merged;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 *
		 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
		 */
		function concatArrays(merged, source, mergeOpts) {
			var result = merged.slice(0, 0);
			var resultIndex = 0;
		
			[merged, source].forEach(function (array) {
				var indices = [];
		
				// result.concat(array) with cloning
				for (var k = 0; k < array.length; k++) {
					if (!hasOwnProperty.call(array, k)) {
						continue;
					}
		
					indices.push(String(k));
		
					if (array === merged) {
						// already cloned
						result[resultIndex++] = array[k];
					} else {
						result[resultIndex++] = clone(array[k]);
					}
				}
		
				// merge non-index keys
				result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(function (key) {
					return indices.indexOf(key) === -1;
				}), mergeOpts);
			});
		
			return result;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 */
		function merge(merged, source, mergeOpts) {
			if (mergeOpts.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
				return concatArrays(merged, source, mergeOpts);
			}
		
			if (!isOptionObject(source) || !isOptionObject(merged)) {
				return clone(source);
			}
		
			return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), mergeOpts);
		}
		
		module.exports = function () {
			var mergeOpts = merge(clone(defaultMergeOpts), (this !== globalThis && this) || {}, defaultMergeOpts);
			var merged = {};
		
			for (var i = 0; i < arguments.length; i++) {
				var option = arguments[i];
		
				if (option === undefined) {
					continue;
				}
		
				if (!isOptionObject(option)) {
					throw new TypeError('`' + option + '` is not an Option Object');
				}
		
				merged = merge(merged, option, mergeOpts);
			}
		
			return merged;
		};
	
	
	/***/ },
	/* 165 */
	/***/ function(module, exports) {
	
		'use strict';
		var toString = Object.prototype.toString;
		
		module.exports = function (x) {
			var prototype;
			return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
		};
	
	
	/***/ },
	/* 166 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.inView = inView;
		exports.scrollIntoView = scrollIntoView;
		exports.resetScroll = resetScroll;
		function inView(element, container) {
		    if (!element) {
		        return;
		    }
		
		    container = container || element.parentElement;
		
		    var top = element.offsetTop;
		    var parentTop = container.scrollTop;
		    var bottom = top + element.offsetHeight;
		    var parentBottom = container.offsetHeight;
		
		    return top >= parentTop && bottom <= parentBottom;
		}
		
		function scrollIntoView(element, container) {
		    var marginTop = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
		
		    if (!element || inView(element, container)) {
		        return;
		    }
		
		    container = container || element.parentElement;
		
		    container.scrollTop = element.offsetTop - marginTop;
		}
		
		function resetScroll(element) {
		    if (!element) {
		        return;
		    }
		
		    element.scrollTop = 0;
		}
		
		exports.default = {
		    inView: inView,
		    scrollIntoView: scrollIntoView,
		    resetScroll: resetScroll
		};
	
	/***/ },
	/* 167 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(168)
		__vue_script__ = __webpack_require__(169)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSelectOption.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(170)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSelectOption.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 168 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 169 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-select-option',
		
		    props: {
		        option: {
		            type: [String, Object],
		            required: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-select-simple' },
		        showCheckbox: {
		            type: Boolean,
		            default: false
		        },
		        highlighted: {
		            type: Boolean,
		            default: false
		        },
		        selected: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    computed: {
		        icon: function icon() {
		            return this.selected ? 'check_box' : 'check_box_outline_blank';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    partials: {
		        'ui-select-simple': '\n            <li class="ui-select-item-text" v-text="option[keys.text] || option"></li>\n        ',
		
		        'ui-select-image': '\n            <div\n                class="ui-select-item-image"\n                :style="{ \'background-image\': \'url(\' + option[keys.image] + \')\' }"\n            ></div>\n\n            <div class="ui-select-item-text" v-text="option[keys.text]"></div>\n        '
		    }
		};
	
	/***/ },
	/* 170 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-select-option\" :class=\"{ highlighted: highlighted, selected: selected }\"\n>\n    <div class=\"ui-select-option-content\" :class=\"[partial]\">\n        <partial :name=\"partial\"></partial>\n    </div>\n\n    <ui-icon\n        class=\"ui-select-option-checkbox\" :icon=\"icon\" v-if=\"showCheckbox\"\n    ></ui-icon>\n</li>\n";
	
	/***/ },
	/* 171 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-select\" :id=\"id\" :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'icon-right': iconRight\n    }\"\n>\n    <div class=\"ui-select-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-select-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-select-content\">\n        <div\n            class=\"ui-select-label\" :tabindex=\"disabled ? null : '0'\" v-el:label\n            @focus=\"focus\" @keydown.tab=\"blur\" @click=\"toggle\" @keydown.space.prevent=\"open\"\n            @keydown.enter.prevent=\"open\"\n        >\n            <div class=\"ui-select-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <div class=\"ui-select-display\">\n                <div\n                    class=\"ui-select-value\" :class=\"{ placeholder: !hasDisplayText }\"\n                    v-text=\"hasDisplayText ? displayText : placeholder\"\n                ></div>\n\n                <ui-icon icon=\"arrow_drop_down\" class=\"ui-select-dropdown-icon\"></ui-icon>\n            </div>\n\n            <div\n                class=\"ui-select-dropdown\" tabindex=\"-1\" v-show=\"showDropdown\" v-el:dropdown\n                @keydown.esc.prevent=\"close()\" @keydown.tab=\"close()\"\n                @keydown.up.prevent=\"highlight(highlightedIndex - 1)\"\n                @keydown.down.prevent=\"highlight(highlightedIndex + 1)\"\n                @keydown.enter.prevent.stop=\"selectHighlighted(highlightedIndex, $event)\"\n            >\n                <div class=\"ui-select-search\" v-if=\"showSearch\" @click.stop @keydown.space.stop>\n                    <input\n                        class=\"ui-select-search-input\" type=\"text\" v-el:search-input\n                        :placeholder=\"searchPlaceholder\" v-model=\"query\" autocomplete=\"off\"\n                    >\n\n                    <ui-progress-circular\n                        class=\"ui-select-search-spinner\" :size=\"24\" :stroke=\"4\" :show=\"loading\"\n                    ></ui-progress-circular>\n                </div>\n\n                <ul class=\"ui-select-options\" v-el:options-list>\n                    <ui-select-option\n                        :option=\"option\" :partial=\"partial\" :show-checkbox=\"multiple\" :\n                        :keys=\"keys\" @click.stop.prevent=\"select(option, index)\"\n                        @mouseover.stop=\"highlight(index, true)\"\n\n                        :highlighted=\"highlightedIndex === index\"\n                        :selected=\"isSelected(option)\"\n\n                        v-for=\"(index, option) in filteredOptions\" v-ref:options\n                    ></ui-select-option>\n\n                    <li class=\"ui-select-no-results\" v-if=\"nothingFound\">No results found</li>\n                </ul>\n            </div>\n        </div>\n\n        <div class=\"ui-select-feedback\" v-if=\"showFeedback\">\n            <div\n                class=\"ui-select-error-text\" transition=\"ui-select-feedback-toggle\"\n                v-text=\"validationError\" v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-select-help-text\" transition=\"ui-select-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 172 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(173)
		__vue_script__ = __webpack_require__(174)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSlider.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(183)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSlider.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 173 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 174 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _draggabilly = __webpack_require__(175);
		
		var _draggabilly2 = _interopRequireDefault(_draggabilly);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-slider',
		
		    props: {
		        name: String,
		        value: {
		            type: Number,
		            required: true,
		            twoWay: true
		        },
		        step: {
		            type: Number,
		            default: 5
		        },
		        icon: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: 0,
		            dragging: false,
		            draggable: null
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        hasLabel: function hasLabel() {
		            if (this.hideLabel) {
		                return true;
		            }
		
		            return Boolean(this.label);
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (!this.dragging) {
		                this.$els.thumb.style.left = this.value + '%';
		            }
		        },
		        disabled: function disabled() {
		            if (this.disabled) {
		                this.draggable.disable();
		            } else {
		                this.draggable.enable();
		            }
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    ready: function ready() {
		        this.initialValue = this.value;
		
		        this.$els.thumb.style.left = this.value + '%';
		
		        this.draggable = new _draggabilly2.default(this.$els.thumb, {
		            containment: this.$els.containment,
		            axis: 'x'
		        });
		
		        this.draggable.on('dragStart', this.dragStart);
		        this.draggable.on('dragMove', this.dragMove);
		        this.draggable.on('dragEnd', this.dragEnd);
		
		        if (this.disabled) {
		            this.draggable.disable();
		        }
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.draggable) {
		            this.draggable.destroy();
		        }
		    },
		
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        },
		        sliderClick: function sliderClick(e) {
		            if (this.disabled) {
		                return;
		            }
		
		            var sliderPosition = this.$els.slider.getBoundingClientRect();
		
		            var newValue = (e.clientX - sliderPosition.left) / sliderPosition.width * 100;
		
		            this.setValue(newValue);
		
		            if (e.target !== this.$els.thumb) {
		                this.draggable._pointerDown(e, e);
		            }
		
		            this.$el.focus();
		        },
		        dragStart: function dragStart() {
		            this.dragging = true;
		            this.$el.focus();
		        },
		        dragMove: function dragMove() {
		            var x = this.draggable.position.x;
		            var newValue = x / this.$els.slider.getBoundingClientRect().width * 100;
		
		            this.setValue(newValue);
		        },
		        dragEnd: function dragEnd() {
		            this.dragging = false;
		        },
		        increment: function increment() {
		            if (this.value === 100) {
		                return;
		            }
		
		            this.setValue(this.value + this.step);
		        },
		        decrement: function decrement() {
		            if (this.value === 0) {
		                return;
		            }
		
		            this.setValue(this.value - this.step);
		        },
		        setValue: function setValue(value) {
		            if (value === this.value) {
		                return;
		            }
		
		            var moderatedValue = Math.round(value);
		
		            if (moderatedValue >= 100) {
		                moderatedValue = 100;
		            }
		
		            if (moderatedValue <= 0) {
		                moderatedValue = 0;
		            }
		
		            this.value = moderatedValue;
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 175 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Draggabilly v1.2.4
		 * Make that shiz draggable
		 * http://draggabilly.desandro.com
		 * MIT license
		 */
		
		( function( window, factory ) {
		  'use strict';
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		        'classie/classie',
		        'get-style-property/get-style-property',
		        'get-size/get-size',
		        'unidragger/unidragger'
		      ],
		      function( classie, getStyleProperty, getSize, Unidragger ) {
		        return factory( window, classie, getStyleProperty, getSize, Unidragger );
		      });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(176),
		      __webpack_require__(177),
		      __webpack_require__(178),
		      __webpack_require__(179)
		    );
		  } else {
		    // browser global
		    window.Draggabilly = factory(
		      window,
		      window.classie,
		      window.getStyleProperty,
		      window.getSize,
		      window.Unidragger
		    );
		  }
		
		}( window, function factory( window, classie, getStyleProperty, getSize, Unidragger ) {
		
		'use strict';
		
		// vars
		var document = window.document;
		
		function noop() {}
		
		// -------------------------- helpers -------------------------- //
		
		// extend objects
		function extend( a, b ) {
		  for ( var prop in b ) {
		    a[ prop ] = b[ prop ];
		  }
		  return a;
		}
		
		// ----- get style ----- //
		
		var defView = document.defaultView;
		
		var getStyle = defView && defView.getComputedStyle ?
		  function( elem ) {
		    return defView.getComputedStyle( elem, null );
		  } :
		  function( elem ) {
		    return elem.currentStyle;
		  };
		
		
		// http://stackoverflow.com/a/384380/182183
		var isElement = ( typeof HTMLElement == 'object' ) ?
		  function isElementDOM2( obj ) {
		    return obj instanceof HTMLElement;
		  } :
		  function isElementQuirky( obj ) {
		    return obj && typeof obj == 'object' &&
		      obj.nodeType == 1 && typeof obj.nodeName == 'string';
		  };
		
		// -------------------------- requestAnimationFrame -------------------------- //
		
		// https://gist.github.com/1866474
		
		var lastTime = 0;
		var prefixes = 'webkit moz ms o'.split(' ');
		// get unprefixed rAF and cAF, if present
		var requestAnimationFrame = window.requestAnimationFrame;
		var cancelAnimationFrame = window.cancelAnimationFrame;
		// loop through vendor prefixes and get prefixed rAF and cAF
		var prefix;
		for( var i = 0; i < prefixes.length; i++ ) {
		  if ( requestAnimationFrame && cancelAnimationFrame ) {
		    break;
		  }
		  prefix = prefixes[i];
		  requestAnimationFrame = requestAnimationFrame || window[ prefix + 'RequestAnimationFrame' ];
		  cancelAnimationFrame  = cancelAnimationFrame  || window[ prefix + 'CancelAnimationFrame' ] ||
		                            window[ prefix + 'CancelRequestAnimationFrame' ];
		}
		
		// fallback to setTimeout and clearTimeout if either request/cancel is not supported
		if ( !requestAnimationFrame || !cancelAnimationFrame )  {
		  requestAnimationFrame = function( callback ) {
		    var currTime = new Date().getTime();
		    var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
		    var id = window.setTimeout( function() {
		      callback( currTime + timeToCall );
		    }, timeToCall );
		    lastTime = currTime + timeToCall;
		    return id;
		  };
		
		  cancelAnimationFrame = function( id ) {
		    window.clearTimeout( id );
		  };
		}
		
		// -------------------------- support -------------------------- //
		
		var transformProperty = getStyleProperty('transform');
		// TODO fix quick & dirty check for 3D support
		var is3d = !!getStyleProperty('perspective');
		
		var jQuery = window.jQuery;
		
		// --------------------------  -------------------------- //
		
		function Draggabilly( element, options ) {
		  // querySelector if string
		  this.element = typeof element == 'string' ?
		    document.querySelector( element ) : element;
		
		  if ( jQuery ) {
		    this.$element = jQuery( this.element );
		  }
		
		  // options
		  this.options = extend( {}, this.constructor.defaults );
		  this.option( options );
		
		  this._create();
		}
		
		// inherit Unidragger methods
		extend( Draggabilly.prototype, Unidragger.prototype );
		
		Draggabilly.defaults = {
		};
		
		/**
		 * set options
		 * @param {Object} opts
		 */
		Draggabilly.prototype.option = function( opts ) {
		  extend( this.options, opts );
		};
		
		Draggabilly.prototype._create = function() {
		
		  // properties
		  this.position = {};
		  this._getPosition();
		
		  this.startPoint = { x: 0, y: 0 };
		  this.dragPoint = { x: 0, y: 0 };
		
		  this.startPosition = extend( {}, this.position );
		
		  // set relative positioning
		  var style = getStyle( this.element );
		  if ( style.position != 'relative' && style.position != 'absolute' ) {
		    this.element.style.position = 'relative';
		  }
		
		  this.enable();
		  this.setHandles();
		
		};
		
		/**
		 * set this.handles and bind start events to 'em
		 */
		Draggabilly.prototype.setHandles = function() {
		  this.handles = this.options.handle ?
		    this.element.querySelectorAll( this.options.handle ) : [ this.element ];
		
		  this.bindHandles();
		};
		
		/**
		 * emits events via eventEmitter and jQuery events
		 * @param {String} type - name of event
		 * @param {Event} event - original event
		 * @param {Array} args - extra arguments
		 */
		Draggabilly.prototype.dispatchEvent = function( type, event, args ) {
		  var emitArgs = [ event ].concat( args );
		  this.emitEvent( type, emitArgs );
		  var jQuery = window.jQuery;
		  // trigger jQuery event
		  if ( jQuery && this.$element ) {
		    if ( event ) {
		      // create jQuery event
		      var $event = jQuery.Event( event );
		      $event.type = type;
		      this.$element.trigger( $event, args );
		    } else {
		      // just trigger with type if no event available
		      this.$element.trigger( type, args );
		    }
		  }
		};
		
		// -------------------------- position -------------------------- //
		
		// get left/top position from style
		Draggabilly.prototype._getPosition = function() {
		  // properties
		  var style = getStyle( this.element );
		
		  var x = parseInt( style.left, 10 );
		  var y = parseInt( style.top, 10 );
		
		  // clean up 'auto' or other non-integer values
		  this.position.x = isNaN( x ) ? 0 : x;
		  this.position.y = isNaN( y ) ? 0 : y;
		
		  this._addTransformPosition( style );
		};
		
		// add transform: translate( x, y ) to position
		Draggabilly.prototype._addTransformPosition = function( style ) {
		  if ( !transformProperty ) {
		    return;
		  }
		  var transform = style[ transformProperty ];
		  // bail out if value is 'none'
		  if ( transform.indexOf('matrix') !== 0 ) {
		    return;
		  }
		  // split matrix(1, 0, 0, 1, x, y)
		  var matrixValues = transform.split(',');
		  // translate X value is in 12th or 4th position
		  var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;
		  var translateX = parseInt( matrixValues[ xIndex ], 10 );
		  // translate Y value is in 13th or 5th position
		  var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );
		  this.position.x += translateX;
		  this.position.y += translateY;
		};
		
		// -------------------------- events -------------------------- //
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerDown = function( event, pointer ) {
		  this._dragPointerDown( event, pointer );
		  // kludge to blur focused inputs in dragger
		  var focused = document.activeElement;
		  if ( focused && focused.blur ) {
		    focused.blur();
		  }
		  // bind move and end events
		  this._bindPostStartEvents( event );
		  classie.add( this.element, 'is-pointer-down' );
		  this.dispatchEvent( 'pointerDown', event, [ pointer ] );
		};
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerMove = function( event, pointer ) {
		  var moveVector = this._dragPointerMove( event, pointer );
		  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );
		  this._dragMove( event, pointer, moveVector );
		};
		
		/**
		 * drag start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragStart = function( event, pointer ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  this._getPosition();
		  this.measureContainment();
		  // position _when_ drag began
		  this.startPosition.x = this.position.x;
		  this.startPosition.y = this.position.y;
		  // reset left/top style
		  this.setLeftTop();
		
		  this.dragPoint.x = 0;
		  this.dragPoint.y = 0;
		
		  // reset isDragging flag
		  this.isDragging = true;
		  classie.add( this.element, 'is-dragging' );
		  this.dispatchEvent( 'dragStart', event, [ pointer ] );
		  // start animation
		  this.animate();
		};
		
		Draggabilly.prototype.measureContainment = function() {
		  var containment = this.options.containment;
		  if ( !containment ) {
		    return;
		  }
		
		  this.size = getSize( this.element );
		  var elemRect = this.element.getBoundingClientRect();
		
		  // use element if element
		  var container = isElement( containment ) ? containment :
		    // fallback to querySelector if string
		    typeof containment == 'string' ? document.querySelector( containment ) :
		    // otherwise just `true`, use the parent
		    this.element.parentNode;
		
		  this.containerSize = getSize( container );
		  var containerRect = container.getBoundingClientRect();
		
		  this.relativeStartPosition = {
		    x: elemRect.left - containerRect.left,
		    y: elemRect.top  - containerRect.top
		  };
		};
		
		// ----- move event ----- //
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragMove = function( event, pointer, moveVector ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  var dragX = moveVector.x;
		  var dragY = moveVector.y;
		
		  var grid = this.options.grid;
		  var gridX = grid && grid[0];
		  var gridY = grid && grid[1];
		
		  dragX = applyGrid( dragX, gridX );
		  dragY = applyGrid( dragY, gridY );
		
		  dragX = this.containDrag( 'x', dragX, gridX );
		  dragY = this.containDrag( 'y', dragY, gridY );
		
		  // constrain to axis
		  dragX = this.options.axis == 'y' ? 0 : dragX;
		  dragY = this.options.axis == 'x' ? 0 : dragY;
		
		  this.position.x = this.startPosition.x + dragX;
		  this.position.y = this.startPosition.y + dragY;
		  // set dragPoint properties
		  this.dragPoint.x = dragX;
		  this.dragPoint.y = dragY;
		
		  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );
		};
		
		function applyGrid( value, grid, method ) {
		  method = method || 'round';
		  return grid ? Math[ method ]( value / grid ) * grid : value;
		}
		
		Draggabilly.prototype.containDrag = function( axis, drag, grid ) {
		  if ( !this.options.containment ) {
		    return drag;
		  }
		  var measure = axis == 'x' ? 'width' : 'height';
		
		  var rel = this.relativeStartPosition[ axis ];
		  var min = applyGrid( -rel, grid, 'ceil' );
		  var max = this.containerSize[ measure ] - rel - this.size[ measure ];
		  max = applyGrid( max, grid, 'floor' );
		  return  Math.min( max, Math.max( min, drag ) );
		};
		
		// ----- end event ----- //
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerUp = function( event, pointer ) {
		  classie.remove( this.element, 'is-pointer-down' );
		  this.dispatchEvent( 'pointerUp', event, [ pointer ] );
		  this._dragPointerUp( event, pointer );
		};
		
		/**
		 * drag end
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragEnd = function( event, pointer ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  this.isDragging = false;
		  // use top left position when complete
		  if ( transformProperty ) {
		    this.element.style[ transformProperty ] = '';
		    this.setLeftTop();
		  }
		  classie.remove( this.element, 'is-dragging' );
		  this.dispatchEvent( 'dragEnd', event, [ pointer ] );
		};
		
		// -------------------------- animation -------------------------- //
		
		Draggabilly.prototype.animate = function() {
		  // only render and animate if dragging
		  if ( !this.isDragging ) {
		    return;
		  }
		
		  this.positionDrag();
		
		  var _this = this;
		  requestAnimationFrame( function animateFrame() {
		    _this.animate();
		  });
		
		};
		
		// transform translate function
		var translate = is3d ?
		  function( x, y ) {
		    return 'translate3d( ' + x + 'px, ' + y + 'px, 0)';
		  } :
		  function( x, y ) {
		    return 'translate( ' + x + 'px, ' + y + 'px)';
		  };
		
		// left/top positioning
		Draggabilly.prototype.setLeftTop = function() {
		  this.element.style.left = this.position.x + 'px';
		  this.element.style.top  = this.position.y + 'px';
		};
		
		Draggabilly.prototype.positionDrag = transformProperty ?
		  function() {
		    // position with transform
		    this.element.style[ transformProperty ] = translate( this.dragPoint.x, this.dragPoint.y );
		  } : Draggabilly.prototype.setLeftTop;
		
		// ----- staticClick ----- //
		
		Draggabilly.prototype.staticClick = function( event, pointer ) {
		  this.dispatchEvent( 'staticClick', event, [ pointer ] );
		};
		
		// ----- methods ----- //
		
		Draggabilly.prototype.enable = function() {
		  this.isEnabled = true;
		};
		
		Draggabilly.prototype.disable = function() {
		  this.isEnabled = false;
		  if ( this.isDragging ) {
		    this.dragEnd();
		  }
		};
		
		Draggabilly.prototype.destroy = function() {
		  this.disable();
		  // reset styles
		  if ( transformProperty ) {
		    this.element.style[ transformProperty ] = '';
		  }
		  this.element.style.left = '';
		  this.element.style.top = '';
		  this.element.style.position = '';
		  // unbind handles
		  this.unbindHandles();
		  // remove jQuery data
		  if ( this.$element ) {
		    this.$element.removeData('draggabilly');
		  }
		};
		
		// ----- jQuery bridget ----- //
		
		// required for jQuery bridget
		Draggabilly.prototype._init = noop;
		
		if ( jQuery && jQuery.bridget ) {
		  jQuery.bridget( 'draggabilly', Draggabilly );
		}
		
		// -----  ----- //
		
		return Draggabilly;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 176 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * classie v1.0.1
		 * class helper functions
		 * from bonzo https://github.com/ded/bonzo
		 * MIT license
		 * 
		 * classie.has( elem, 'my-class' ) -> true/false
		 * classie.add( elem, 'my-new-class' )
		 * classie.remove( elem, 'my-unwanted-class' )
		 * classie.toggle( elem, 'my-class' )
		 */
		
		/*jshint browser: true, strict: true, undef: true, unused: true */
		/*global define: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		// class helper functions from bonzo https://github.com/ded/bonzo
		
		function classReg( className ) {
		  return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
		}
		
		// classList support for class management
		// altho to be fair, the api sucks because it won't accept multiple classes at once
		var hasClass, addClass, removeClass;
		
		if ( 'classList' in document.documentElement ) {
		  hasClass = function( elem, c ) {
		    return elem.classList.contains( c );
		  };
		  addClass = function( elem, c ) {
		    elem.classList.add( c );
		  };
		  removeClass = function( elem, c ) {
		    elem.classList.remove( c );
		  };
		}
		else {
		  hasClass = function( elem, c ) {
		    return classReg( c ).test( elem.className );
		  };
		  addClass = function( elem, c ) {
		    if ( !hasClass( elem, c ) ) {
		      elem.className = elem.className + ' ' + c;
		    }
		  };
		  removeClass = function( elem, c ) {
		    elem.className = elem.className.replace( classReg( c ), ' ' );
		  };
		}
		
		function toggleClass( elem, c ) {
		  var fn = hasClass( elem, c ) ? removeClass : addClass;
		  fn( elem, c );
		}
		
		var classie = {
		  // full names
		  hasClass: hasClass,
		  addClass: addClass,
		  removeClass: removeClass,
		  toggleClass: toggleClass,
		  // short names
		  has: hasClass,
		  add: addClass,
		  remove: removeClass,
		  toggle: toggleClass
		};
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD
		  define( classie );
		} else if ( true ) {
		  // CommonJS
		  module.exports = classie;
		} else {
		  // browser global
		  window.classie = classie;
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 177 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * getStyleProperty v1.0.4
		 * original by kangax
		 * http://perfectionkills.com/feature-testing-css-properties/
		 * MIT license
		 */
		
		/*jshint browser: true, strict: true, undef: true */
		/*global define: false, exports: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		var prefixes = 'Webkit Moz ms Ms O'.split(' ');
		var docElemStyle = document.documentElement.style;
		
		function getStyleProperty( propName ) {
		  if ( !propName ) {
		    return;
		  }
		
		  // test standard property first
		  if ( typeof docElemStyle[ propName ] === 'string' ) {
		    return propName;
		  }
		
		  // capitalize
		  propName = propName.charAt(0).toUpperCase() + propName.slice(1);
		
		  // test vendor specific properties
		  var prefixed;
		  for ( var i=0, len = prefixes.length; i < len; i++ ) {
		    prefixed = prefixes[i] + propName;
		    if ( typeof docElemStyle[ prefixed ] === 'string' ) {
		      return prefixed;
		    }
		  }
		}
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD
		  define( function() {
		    return getStyleProperty;
		  });
		} else if ( true ) {
		  // CommonJS for Component
		  module.exports = getStyleProperty;
		} else {
		  // browser global
		  window.getStyleProperty = getStyleProperty;
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 178 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * getSize v1.2.2
		 * measure size of elements
		 * MIT license
		 */
		
		/*jshint browser: true, strict: true, undef: true, unused: true */
		/*global define: false, exports: false, require: false, module: false, console: false */
		
		( function( window, undefined ) {
		
		'use strict';
		
		// -------------------------- helpers -------------------------- //
		
		// get a number from a string, not a percentage
		function getStyleSize( value ) {
		  var num = parseFloat( value );
		  // not a percent like '100%', and a number
		  var isValid = value.indexOf('%') === -1 && !isNaN( num );
		  return isValid && num;
		}
		
		function noop() {}
		
		var logError = typeof console === 'undefined' ? noop :
		  function( message ) {
		    console.error( message );
		  };
		
		// -------------------------- measurements -------------------------- //
		
		var measurements = [
		  'paddingLeft',
		  'paddingRight',
		  'paddingTop',
		  'paddingBottom',
		  'marginLeft',
		  'marginRight',
		  'marginTop',
		  'marginBottom',
		  'borderLeftWidth',
		  'borderRightWidth',
		  'borderTopWidth',
		  'borderBottomWidth'
		];
		
		function getZeroSize() {
		  var size = {
		    width: 0,
		    height: 0,
		    innerWidth: 0,
		    innerHeight: 0,
		    outerWidth: 0,
		    outerHeight: 0
		  };
		  for ( var i=0, len = measurements.length; i < len; i++ ) {
		    var measurement = measurements[i];
		    size[ measurement ] = 0;
		  }
		  return size;
		}
		
		
		
		function defineGetSize( getStyleProperty ) {
		
		// -------------------------- setup -------------------------- //
		
		var isSetup = false;
		
		var getStyle, boxSizingProp, isBoxSizeOuter;
		
		/**
		 * setup vars and functions
		 * do it on initial getSize(), rather than on script load
		 * For Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=548397
		 */
		function setup() {
		  // setup once
		  if ( isSetup ) {
		    return;
		  }
		  isSetup = true;
		
		  var getComputedStyle = window.getComputedStyle;
		  getStyle = ( function() {
		    var getStyleFn = getComputedStyle ?
		      function( elem ) {
		        return getComputedStyle( elem, null );
		      } :
		      function( elem ) {
		        return elem.currentStyle;
		      };
		
		      return function getStyle( elem ) {
		        var style = getStyleFn( elem );
		        if ( !style ) {
		          logError( 'Style returned ' + style +
		            '. Are you running this code in a hidden iframe on Firefox? ' +
		            'See http://bit.ly/getsizebug1' );
		        }
		        return style;
		      };
		  })();
		
		  // -------------------------- box sizing -------------------------- //
		
		  boxSizingProp = getStyleProperty('boxSizing');
		
		  /**
		   * WebKit measures the outer-width on style.width on border-box elems
		   * IE & Firefox measures the inner-width
		   */
		  if ( boxSizingProp ) {
		    var div = document.createElement('div');
		    div.style.width = '200px';
		    div.style.padding = '1px 2px 3px 4px';
		    div.style.borderStyle = 'solid';
		    div.style.borderWidth = '1px 2px 3px 4px';
		    div.style[ boxSizingProp ] = 'border-box';
		
		    var body = document.body || document.documentElement;
		    body.appendChild( div );
		    var style = getStyle( div );
		
		    isBoxSizeOuter = getStyleSize( style.width ) === 200;
		    body.removeChild( div );
		  }
		
		}
		
		// -------------------------- getSize -------------------------- //
		
		function getSize( elem ) {
		  setup();
		
		  // use querySeletor if elem is string
		  if ( typeof elem === 'string' ) {
		    elem = document.querySelector( elem );
		  }
		
		  // do not proceed on non-objects
		  if ( !elem || typeof elem !== 'object' || !elem.nodeType ) {
		    return;
		  }
		
		  var style = getStyle( elem );
		
		  // if hidden, everything is 0
		  if ( style.display === 'none' ) {
		    return getZeroSize();
		  }
		
		  var size = {};
		  size.width = elem.offsetWidth;
		  size.height = elem.offsetHeight;
		
		  var isBorderBox = size.isBorderBox = !!( boxSizingProp &&
		    style[ boxSizingProp ] && style[ boxSizingProp ] === 'border-box' );
		
		  // get all measurements
		  for ( var i=0, len = measurements.length; i < len; i++ ) {
		    var measurement = measurements[i];
		    var value = style[ measurement ];
		    value = mungeNonPixel( elem, value );
		    var num = parseFloat( value );
		    // any 'auto', 'medium' value will be 0
		    size[ measurement ] = !isNaN( num ) ? num : 0;
		  }
		
		  var paddingWidth = size.paddingLeft + size.paddingRight;
		  var paddingHeight = size.paddingTop + size.paddingBottom;
		  var marginWidth = size.marginLeft + size.marginRight;
		  var marginHeight = size.marginTop + size.marginBottom;
		  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
		  var borderHeight = size.borderTopWidth + size.borderBottomWidth;
		
		  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
		
		  // overwrite width and height if we can get it from style
		  var styleWidth = getStyleSize( style.width );
		  if ( styleWidth !== false ) {
		    size.width = styleWidth +
		      // add padding and border unless it's already including it
		      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
		  }
		
		  var styleHeight = getStyleSize( style.height );
		  if ( styleHeight !== false ) {
		    size.height = styleHeight +
		      // add padding and border unless it's already including it
		      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
		  }
		
		  size.innerWidth = size.width - ( paddingWidth + borderWidth );
		  size.innerHeight = size.height - ( paddingHeight + borderHeight );
		
		  size.outerWidth = size.width + marginWidth;
		  size.outerHeight = size.height + marginHeight;
		
		  return size;
		}
		
		// IE8 returns percent values, not pixels
		// taken from jQuery's curCSS
		function mungeNonPixel( elem, value ) {
		  // IE8 and has percent value
		  if ( window.getComputedStyle || value.indexOf('%') === -1 ) {
		    return value;
		  }
		  var style = elem.style;
		  // Remember the original values
		  var left = style.left;
		  var rs = elem.runtimeStyle;
		  var rsLeft = rs && rs.left;
		
		  // Put in the new values to get a computed value out
		  if ( rsLeft ) {
		    rs.left = elem.currentStyle.left;
		  }
		  style.left = value;
		  value = style.pixelLeft;
		
		  // Revert the changed values
		  style.left = left;
		  if ( rsLeft ) {
		    rs.left = rsLeft;
		  }
		
		  return value;
		}
		
		return getSize;
		
		}
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD for RequireJS
		  define( [ 'get-style-property/get-style-property' ], defineGetSize );
		} else if ( true ) {
		  // CommonJS for Component
		  module.exports = defineGetSize( __webpack_require__(177) );
		} else {
		  // browser global
		  window.getSize = defineGetSize( window.getStyleProperty );
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 179 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Unidragger v1.1.5
		 * Draggable base class
		 * MIT license
		 */
		
		/*jshint browser: true, unused: true, undef: true, strict: true */
		
		( function( window, factory ) {
		  /*global define: false, module: false, require: false */
		  'use strict';
		  // universal module definition
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		      'eventie/eventie',
		      'unipointer/unipointer'
		    ], function( eventie, Unipointer ) {
		      return factory( window, eventie, Unipointer );
		    });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(180),
		      __webpack_require__(181)
		    );
		  } else {
		    // browser global
		    window.Unidragger = factory(
		      window,
		      window.eventie,
		      window.Unipointer
		    );
		  }
		
		}( window, function factory( window, eventie, Unipointer ) {
		
		'use strict';
		
		// -----  ----- //
		
		function noop() {}
		
		// handle IE8 prevent default
		function preventDefaultEvent( event ) {
		  if ( event.preventDefault ) {
		    event.preventDefault();
		  } else {
		    event.returnValue = false;
		  }
		}
		
		// -------------------------- Unidragger -------------------------- //
		
		function Unidragger() {}
		
		// inherit Unipointer & EventEmitter
		Unidragger.prototype = new Unipointer();
		
		// ----- bind start ----- //
		
		Unidragger.prototype.bindHandles = function() {
		  this._bindHandles( true );
		};
		
		Unidragger.prototype.unbindHandles = function() {
		  this._bindHandles( false );
		};
		
		var navigator = window.navigator;
		/**
		 * works as unbinder, as you can .bindHandles( false ) to unbind
		 * @param {Boolean} isBind - will unbind if falsey
		 */
		Unidragger.prototype._bindHandles = function( isBind ) {
		  // munge isBind, default to true
		  isBind = isBind === undefined ? true : !!isBind;
		  // extra bind logic
		  var binderExtra;
		  if ( navigator.pointerEnabled ) {
		    binderExtra = function( handle ) {
		      // disable scrolling on the element
		      handle.style.touchAction = isBind ? 'none' : '';
		    };
		  } else if ( navigator.msPointerEnabled ) {
		    binderExtra = function( handle ) {
		      // disable scrolling on the element
		      handle.style.msTouchAction = isBind ? 'none' : '';
		    };
		  } else {
		    binderExtra = function() {
		      // TODO re-enable img.ondragstart when unbinding
		      if ( isBind ) {
		        disableImgOndragstart( handle );
		      }
		    };
		  }
		  // bind each handle
		  var bindMethod = isBind ? 'bind' : 'unbind';
		  for ( var i=0, len = this.handles.length; i < len; i++ ) {
		    var handle = this.handles[i];
		    this._bindStartEvent( handle, isBind );
		    binderExtra( handle );
		    eventie[ bindMethod ]( handle, 'click', this );
		  }
		};
		
		// remove default dragging interaction on all images in IE8
		// IE8 does its own drag thing on images, which messes stuff up
		
		function noDragStart() {
		  return false;
		}
		
		// TODO replace this with a IE8 test
		var isIE8 = 'attachEvent' in document.documentElement;
		
		// IE8 only
		var disableImgOndragstart = !isIE8 ? noop : function( handle ) {
		
		  if ( handle.nodeName == 'IMG' ) {
		    handle.ondragstart = noDragStart;
		  }
		
		  var images = handle.querySelectorAll('img');
		  for ( var i=0, len = images.length; i < len; i++ ) {
		    var img = images[i];
		    img.ondragstart = noDragStart;
		  }
		};
		
		// ----- start event ----- //
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerDown = function( event, pointer ) {
		  // dismiss range sliders
		  if ( event.target.nodeName == 'INPUT' && event.target.type == 'range' ) {
		    // reset pointerDown logic
		    this.isPointerDown = false;
		    delete this.pointerIdentifier;
		    return;
		  }
		
		  this._dragPointerDown( event, pointer );
		  // kludge to blur focused inputs in dragger
		  var focused = document.activeElement;
		  if ( focused && focused.blur ) {
		    focused.blur();
		  }
		  // bind move and end events
		  this._bindPostStartEvents( event );
		  // track scrolling
		  this.pointerDownScroll = Unidragger.getScrollPosition();
		  eventie.bind( window, 'scroll', this );
		
		  this.emitEvent( 'pointerDown', [ event, pointer ] );
		};
		
		// base pointer down logic
		Unidragger.prototype._dragPointerDown = function( event, pointer ) {
		  // track to see when dragging starts
		  this.pointerDownPoint = Unipointer.getPointerPoint( pointer );
		
		  // prevent default, unless touchstart or <select>
		  var isTouchstart = event.type == 'touchstart';
		  var targetNodeName = event.target.nodeName;
		  if ( !isTouchstart && targetNodeName != 'SELECT' ) {
		    preventDefaultEvent( event );
		  }
		};
		
		// ----- move event ----- //
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerMove = function( event, pointer ) {
		  var moveVector = this._dragPointerMove( event, pointer );
		  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
		  this._dragMove( event, pointer, moveVector );
		};
		
		// base pointer move logic
		Unidragger.prototype._dragPointerMove = function( event, pointer ) {
		  var movePoint = Unipointer.getPointerPoint( pointer );
		  var moveVector = {
		    x: movePoint.x - this.pointerDownPoint.x,
		    y: movePoint.y - this.pointerDownPoint.y
		  };
		  // start drag if pointer has moved far enough to start drag
		  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {
		    this._dragStart( event, pointer );
		  }
		  return moveVector;
		};
		
		// condition if pointer has moved far enough to start drag
		Unidragger.prototype.hasDragStarted = function( moveVector ) {
		  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;
		};
		
		
		// ----- end event ----- //
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerUp = function( event, pointer ) {
		  this.emitEvent( 'pointerUp', [ event, pointer ] );
		  this._dragPointerUp( event, pointer );
		};
		
		Unidragger.prototype._dragPointerUp = function( event, pointer ) {
		  if ( this.isDragging ) {
		    this._dragEnd( event, pointer );
		  } else {
		    // pointer didn't move enough for drag to start
		    this._staticClick( event, pointer );
		  }
		};
		
		Unipointer.prototype.pointerDone = function() {
		  eventie.unbind( window, 'scroll', this );
		};
		
		// -------------------------- drag -------------------------- //
		
		// dragStart
		Unidragger.prototype._dragStart = function( event, pointer ) {
		  this.isDragging = true;
		  this.dragStartPoint = Unidragger.getPointerPoint( pointer );
		  // prevent clicks
		  this.isPreventingClicks = true;
		
		  this.dragStart( event, pointer );
		};
		
		Unidragger.prototype.dragStart = function( event, pointer ) {
		  this.emitEvent( 'dragStart', [ event, pointer ] );
		};
		
		// dragMove
		Unidragger.prototype._dragMove = function( event, pointer, moveVector ) {
		  // do not drag if not dragging yet
		  if ( !this.isDragging ) {
		    return;
		  }
		
		  this.dragMove( event, pointer, moveVector );
		};
		
		Unidragger.prototype.dragMove = function( event, pointer, moveVector ) {
		  preventDefaultEvent( event );
		  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
		};
		
		// dragEnd
		Unidragger.prototype._dragEnd = function( event, pointer ) {
		  // set flags
		  this.isDragging = false;
		  // re-enable clicking async
		  var _this = this;
		  setTimeout( function() {
		    delete _this.isPreventingClicks;
		  });
		
		  this.dragEnd( event, pointer );
		};
		
		Unidragger.prototype.dragEnd = function( event, pointer ) {
		  this.emitEvent( 'dragEnd', [ event, pointer ] );
		};
		
		Unidragger.prototype.pointerDone = function() {
		  eventie.unbind( window, 'scroll', this );
		  delete this.pointerDownScroll;
		};
		
		// ----- onclick ----- //
		
		// handle all clicks and prevent clicks when dragging
		Unidragger.prototype.onclick = function( event ) {
		  if ( this.isPreventingClicks ) {
		    preventDefaultEvent( event );
		  }
		};
		
		// ----- staticClick ----- //
		
		// triggered after pointer down & up with no/tiny movement
		Unidragger.prototype._staticClick = function( event, pointer ) {
		  // ignore emulated mouse up clicks
		  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {
		    return;
		  }
		
		  // allow click in <input>s and <textarea>s
		  var nodeName = event.target.nodeName;
		  if ( nodeName == 'INPUT' || nodeName == 'TEXTAREA' ) {
		    event.target.focus();
		  }
		  this.staticClick( event, pointer );
		
		  // set flag for emulated clicks 300ms after touchend
		  if ( event.type != 'mouseup' ) {
		    this.isIgnoringMouseUp = true;
		    var _this = this;
		    // reset flag after 300ms
		    setTimeout( function() {
		      delete _this.isIgnoringMouseUp;
		    }, 400 );
		  }
		};
		
		Unidragger.prototype.staticClick = function( event, pointer ) {
		  this.emitEvent( 'staticClick', [ event, pointer ] );
		};
		
		// ----- scroll ----- //
		
		Unidragger.prototype.onscroll = function() {
		  var scroll = Unidragger.getScrollPosition();
		  var scrollMoveX = this.pointerDownScroll.x - scroll.x;
		  var scrollMoveY = this.pointerDownScroll.y - scroll.y;
		  // cancel click/tap if scroll is too much
		  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {
		    this._pointerDone();
		  }
		};
		
		// ----- utils ----- //
		
		Unidragger.getPointerPoint = function( pointer ) {
		  return {
		    x: pointer.pageX !== undefined ? pointer.pageX : pointer.clientX,
		    y: pointer.pageY !== undefined ? pointer.pageY : pointer.clientY
		  };
		};
		
		var isPageOffset = window.pageYOffset !== undefined;
		
		// get scroll in { x, y }
		Unidragger.getScrollPosition = function() {
		  return {
		    x: isPageOffset ? window.pageXOffset : document.body.scrollLeft,
		    y: isPageOffset ? window.pageYOffset : document.body.scrollTop
		  };
		};
		
		// -----  ----- //
		
		Unidragger.getPointerPoint = Unipointer.getPointerPoint;
		
		return Unidragger;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 180 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		 * eventie v1.0.6
		 * event binding helper
		 *   eventie.bind( elem, 'click', myFn )
		 *   eventie.unbind( elem, 'click', myFn )
		 * MIT license
		 */
		
		/*jshint browser: true, undef: true, unused: true */
		/*global define: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		var docElem = document.documentElement;
		
		var bind = function() {};
		
		function getIEEvent( obj ) {
		  var event = window.event;
		  // add event.target
		  event.target = event.target || event.srcElement || obj;
		  return event;
		}
		
		if ( docElem.addEventListener ) {
		  bind = function( obj, type, fn ) {
		    obj.addEventListener( type, fn, false );
		  };
		} else if ( docElem.attachEvent ) {
		  bind = function( obj, type, fn ) {
		    obj[ type + fn ] = fn.handleEvent ?
		      function() {
		        var event = getIEEvent( obj );
		        fn.handleEvent.call( fn, event );
		      } :
		      function() {
		        var event = getIEEvent( obj );
		        fn.call( obj, event );
		      };
		    obj.attachEvent( "on" + type, obj[ type + fn ] );
		  };
		}
		
		var unbind = function() {};
		
		if ( docElem.removeEventListener ) {
		  unbind = function( obj, type, fn ) {
		    obj.removeEventListener( type, fn, false );
		  };
		} else if ( docElem.detachEvent ) {
		  unbind = function( obj, type, fn ) {
		    obj.detachEvent( "on" + type, obj[ type + fn ] );
		    try {
		      delete obj[ type + fn ];
		    } catch ( err ) {
		      // can't delete window object properties
		      obj[ type + fn ] = undefined;
		    }
		  };
		}
		
		var eventie = {
		  bind: bind,
		  unbind: unbind
		};
		
		// ----- module definition ----- //
		
		if ( true ) {
		  // AMD
		  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (eventie), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if ( typeof exports === 'object' ) {
		  // CommonJS
		  module.exports = eventie;
		} else {
		  // browser global
		  window.eventie = eventie;
		}
		
		})( window );
	
	
	/***/ },
	/* 181 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Unipointer v1.1.0
		 * base class for doing one thing with pointer event
		 * MIT license
		 */
		
		/*jshint browser: true, undef: true, unused: true, strict: true */
		/*global define: false, module: false, require: false */
		
		( function( window, factory ) {
		  'use strict';
		  // universal module definition
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		      'eventEmitter/EventEmitter',
		      'eventie/eventie'
		    ], function( EventEmitter, eventie ) {
		      return factory( window, EventEmitter, eventie );
		    });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(182),
		      __webpack_require__(180)
		    );
		  } else {
		    // browser global
		    window.Unipointer = factory(
		      window,
		      window.EventEmitter,
		      window.eventie
		    );
		  }
		
		}( window, function factory( window, EventEmitter, eventie ) {
		
		'use strict';
		
		function noop() {}
		
		function Unipointer() {}
		
		// inherit EventEmitter
		Unipointer.prototype = new EventEmitter();
		
		Unipointer.prototype.bindStartEvent = function( elem ) {
		  this._bindStartEvent( elem, true );
		};
		
		Unipointer.prototype.unbindStartEvent = function( elem ) {
		  this._bindStartEvent( elem, false );
		};
		
		/**
		 * works as unbinder, as you can ._bindStart( false ) to unbind
		 * @param {Boolean} isBind - will unbind if falsey
		 */
		Unipointer.prototype._bindStartEvent = function( elem, isBind ) {
		  // munge isBind, default to true
		  isBind = isBind === undefined ? true : !!isBind;
		  var bindMethod = isBind ? 'bind' : 'unbind';
		
		  if ( window.navigator.pointerEnabled ) {
		    // W3C Pointer Events, IE11. See https://coderwall.com/p/mfreca
		    eventie[ bindMethod ]( elem, 'pointerdown', this );
		  } else if ( window.navigator.msPointerEnabled ) {
		    // IE10 Pointer Events
		    eventie[ bindMethod ]( elem, 'MSPointerDown', this );
		  } else {
		    // listen for both, for devices like Chrome Pixel
		    eventie[ bindMethod ]( elem, 'mousedown', this );
		    eventie[ bindMethod ]( elem, 'touchstart', this );
		  }
		};
		
		// trigger handler methods for events
		Unipointer.prototype.handleEvent = function( event ) {
		  var method = 'on' + event.type;
		  if ( this[ method ] ) {
		    this[ method ]( event );
		  }
		};
		
		// returns the touch that we're keeping track of
		Unipointer.prototype.getTouch = function( touches ) {
		  for ( var i=0, len = touches.length; i < len; i++ ) {
		    var touch = touches[i];
		    if ( touch.identifier == this.pointerIdentifier ) {
		      return touch;
		    }
		  }
		};
		
		// ----- start event ----- //
		
		Unipointer.prototype.onmousedown = function( event ) {
		  // dismiss clicks from right or middle buttons
		  var button = event.button;
		  if ( button && ( button !== 0 && button !== 1 ) ) {
		    return;
		  }
		  this._pointerDown( event, event );
		};
		
		Unipointer.prototype.ontouchstart = function( event ) {
		  this._pointerDown( event, event.changedTouches[0] );
		};
		
		Unipointer.prototype.onMSPointerDown =
		Unipointer.prototype.onpointerdown = function( event ) {
		  this._pointerDown( event, event );
		};
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unipointer.prototype._pointerDown = function( event, pointer ) {
		  // dismiss other pointers
		  if ( this.isPointerDown ) {
		    return;
		  }
		
		  this.isPointerDown = true;
		  // save pointer identifier to match up touch events
		  this.pointerIdentifier = pointer.pointerId !== undefined ?
		    // pointerId for pointer events, touch.indentifier for touch events
		    pointer.pointerId : pointer.identifier;
		
		  this.pointerDown( event, pointer );
		};
		
		Unipointer.prototype.pointerDown = function( event, pointer ) {
		  this._bindPostStartEvents( event );
		  this.emitEvent( 'pointerDown', [ event, pointer ] );
		};
		
		// hash of events to be bound after start event
		var postStartEvents = {
		  mousedown: [ 'mousemove', 'mouseup' ],
		  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],
		  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],
		  MSPointerDown: [ 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel' ]
		};
		
		Unipointer.prototype._bindPostStartEvents = function( event ) {
		  if ( !event ) {
		    return;
		  }
		  // get proper events to match start event
		  var events = postStartEvents[ event.type ];
		  // IE8 needs to be bound to document
		  var node = event.preventDefault ? window : document;
		  // bind events to node
		  for ( var i=0, len = events.length; i < len; i++ ) {
		    var evnt = events[i];
		    eventie.bind( node, evnt, this );
		  }
		  // save these arguments
		  this._boundPointerEvents = {
		    events: events,
		    node: node
		  };
		};
		
		Unipointer.prototype._unbindPostStartEvents = function() {
		  var args = this._boundPointerEvents;
		  // IE8 can trigger dragEnd twice, check for _boundEvents
		  if ( !args || !args.events ) {
		    return;
		  }
		
		  for ( var i=0, len = args.events.length; i < len; i++ ) {
		    var event = args.events[i];
		    eventie.unbind( args.node, event, this );
		  }
		  delete this._boundPointerEvents;
		};
		
		// ----- move event ----- //
		
		Unipointer.prototype.onmousemove = function( event ) {
		  this._pointerMove( event, event );
		};
		
		Unipointer.prototype.onMSPointerMove =
		Unipointer.prototype.onpointermove = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerMove( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchmove = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerMove( event, touch );
		  }
		};
		
		/**
		 * pointer move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerMove = function( event, pointer ) {
		  this.pointerMove( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerMove = function( event, pointer ) {
		  this.emitEvent( 'pointerMove', [ event, pointer ] );
		};
		
		// ----- end event ----- //
		
		
		Unipointer.prototype.onmouseup = function( event ) {
		  this._pointerUp( event, event );
		};
		
		Unipointer.prototype.onMSPointerUp =
		Unipointer.prototype.onpointerup = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerUp( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchend = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerUp( event, touch );
		  }
		};
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerUp = function( event, pointer ) {
		  this._pointerDone();
		  this.pointerUp( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerUp = function( event, pointer ) {
		  this.emitEvent( 'pointerUp', [ event, pointer ] );
		};
		
		// ----- pointer done ----- //
		
		// triggered on pointer up & pointer cancel
		Unipointer.prototype._pointerDone = function() {
		  // reset properties
		  this.isPointerDown = false;
		  delete this.pointerIdentifier;
		  // remove events
		  this._unbindPostStartEvents();
		  this.pointerDone();
		};
		
		Unipointer.prototype.pointerDone = noop;
		
		// ----- pointer cancel ----- //
		
		Unipointer.prototype.onMSPointerCancel =
		Unipointer.prototype.onpointercancel = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerCancel( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchcancel = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerCancel( event, touch );
		  }
		};
		
		/**
		 * pointer cancel
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerCancel = function( event, pointer ) {
		  this._pointerDone();
		  this.pointerCancel( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerCancel = function( event, pointer ) {
		  this.emitEvent( 'pointerCancel', [ event, pointer ] );
		};
		
		// -----  ----- //
		
		// utility function for getting x/y cooridinates from event, because IE8
		Unipointer.getPointerPoint = function( pointer ) {
		  return {
		    x: pointer.pageX !== undefined ? pointer.pageX : pointer.clientX,
		    y: pointer.pageY !== undefined ? pointer.pageY : pointer.clientY
		  };
		};
		
		// -----  ----- //
		
		return Unipointer;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 182 */
	/***/ function(module, exports) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * EventEmitter v4.2.11 - git.io/ee
		 * Unlicense - http://unlicense.org/
		 * Oliver Caldwell - http://oli.me.uk/
		 * @preserve
		 */
		
		;(function () {
		    'use strict';
		
		    /**
		     * Class for managing events.
		     * Can be extended to provide event functionality in other classes.
		     *
		     * @class EventEmitter Manages event registering and emitting.
		     */
		    function EventEmitter() {}
		
		    // Shortcuts to improve speed and size
		    var proto = EventEmitter.prototype;
		    var exports = this;
		    var originalGlobalValue = exports.EventEmitter;
		
		    /**
		     * Finds the index of the listener for the event in its storage array.
		     *
		     * @param {Function[]} listeners Array of listeners to search through.
		     * @param {Function} listener Method to look for.
		     * @return {Number} Index of the specified listener, -1 if not found
		     * @api private
		     */
		    function indexOfListener(listeners, listener) {
		        var i = listeners.length;
		        while (i--) {
		            if (listeners[i].listener === listener) {
		                return i;
		            }
		        }
		
		        return -1;
		    }
		
		    /**
		     * Alias a method while keeping the context correct, to allow for overwriting of target method.
		     *
		     * @param {String} name The name of the target method.
		     * @return {Function} The aliased method
		     * @api private
		     */
		    function alias(name) {
		        return function aliasClosure() {
		            return this[name].apply(this, arguments);
		        };
		    }
		
		    /**
		     * Returns the listener array for the specified event.
		     * Will initialise the event object and listener arrays if required.
		     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
		     * Each property in the object response is an array of listener functions.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Function[]|Object} All listener functions for the event.
		     */
		    proto.getListeners = function getListeners(evt) {
		        var events = this._getEvents();
		        var response;
		        var key;
		
		        // Return a concatenated array of all matching events if
		        // the selector is a regular expression.
		        if (evt instanceof RegExp) {
		            response = {};
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    response[key] = events[key];
		                }
		            }
		        }
		        else {
		            response = events[evt] || (events[evt] = []);
		        }
		
		        return response;
		    };
		
		    /**
		     * Takes a list of listener objects and flattens it into a list of listener functions.
		     *
		     * @param {Object[]} listeners Raw listener objects.
		     * @return {Function[]} Just the listener functions.
		     */
		    proto.flattenListeners = function flattenListeners(listeners) {
		        var flatListeners = [];
		        var i;
		
		        for (i = 0; i < listeners.length; i += 1) {
		            flatListeners.push(listeners[i].listener);
		        }
		
		        return flatListeners;
		    };
		
		    /**
		     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Object} All listener functions for an event in an object.
		     */
		    proto.getListenersAsObject = function getListenersAsObject(evt) {
		        var listeners = this.getListeners(evt);
		        var response;
		
		        if (listeners instanceof Array) {
		            response = {};
		            response[evt] = listeners;
		        }
		
		        return response || listeners;
		    };
		
		    /**
		     * Adds a listener function to the specified event.
		     * The listener will not be added if it is a duplicate.
		     * If the listener returns true then it will be removed after it is called.
		     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListener = function addListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var listenerIsWrapped = typeof listener === 'object';
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
		                listeners[key].push(listenerIsWrapped ? listener : {
		                    listener: listener,
		                    once: false
		                });
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of addListener
		     */
		    proto.on = alias('addListener');
		
		    /**
		     * Semi-alias of addListener. It will add a listener that will be
		     * automatically removed after its first execution.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addOnceListener = function addOnceListener(evt, listener) {
		        return this.addListener(evt, {
		            listener: listener,
		            once: true
		        });
		    };
		
		    /**
		     * Alias of addOnceListener.
		     */
		    proto.once = alias('addOnceListener');
		
		    /**
		     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
		     * You need to tell it what event names should be matched by a regex.
		     *
		     * @param {String} evt Name of the event to create.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvent = function defineEvent(evt) {
		        this.getListeners(evt);
		        return this;
		    };
		
		    /**
		     * Uses defineEvent to define multiple events.
		     *
		     * @param {String[]} evts An array of event names to define.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvents = function defineEvents(evts) {
		        for (var i = 0; i < evts.length; i += 1) {
		            this.defineEvent(evts[i]);
		        }
		        return this;
		    };
		
		    /**
		     * Removes a listener function from the specified event.
		     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to remove the listener from.
		     * @param {Function} listener Method to remove from the event.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListener = function removeListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var index;
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                index = indexOfListener(listeners[key], listener);
		
		                if (index !== -1) {
		                    listeners[key].splice(index, 1);
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeListener
		     */
		    proto.off = alias('removeListener');
		
		    /**
		     * Adds listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
		     * You can also pass it a regular expression to add the array of listeners to all events that match it.
		     * Yeah, this function does quite a bit. That's probably a bad thing.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListeners = function addListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(false, evt, listeners);
		    };
		
		    /**
		     * Removes listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be removed.
		     * You can also pass it a regular expression to remove the listeners from all events that match it.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListeners = function removeListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(true, evt, listeners);
		    };
		
		    /**
		     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
		     * The first argument will determine if the listeners are removed (true) or added (false).
		     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be added/removed.
		     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
		     *
		     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		        var i;
		        var value;
		        var single = remove ? this.removeListener : this.addListener;
		        var multiple = remove ? this.removeListeners : this.addListeners;
		
		        // If evt is an object then pass each of its properties to this method
		        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
		            for (i in evt) {
		                if (evt.hasOwnProperty(i) && (value = evt[i])) {
		                    // Pass the single listener straight through to the singular method
		                    if (typeof value === 'function') {
		                        single.call(this, i, value);
		                    }
		                    else {
		                        // Otherwise pass back to the multiple function
		                        multiple.call(this, i, value);
		                    }
		                }
		            }
		        }
		        else {
		            // So evt must be a string
		            // And listeners must be an array of listeners
		            // Loop over it and pass each one to the multiple method
		            i = listeners.length;
		            while (i--) {
		                single.call(this, evt, listeners[i]);
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Removes all listeners from a specified event.
		     * If you do not specify an event then all listeners will be removed.
		     * That means every event will be emptied.
		     * You can also pass a regex to remove all events that match it.
		     *
		     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeEvent = function removeEvent(evt) {
		        var type = typeof evt;
		        var events = this._getEvents();
		        var key;
		
		        // Remove different things depending on the state of evt
		        if (type === 'string') {
		            // Remove all listeners for the specified event
		            delete events[evt];
		        }
		        else if (evt instanceof RegExp) {
		            // Remove all events matching the regex.
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    delete events[key];
		                }
		            }
		        }
		        else {
		            // Remove all listeners in all events
		            delete this._events;
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeEvent.
		     *
		     * Added to mirror the node API.
		     */
		    proto.removeAllListeners = alias('removeEvent');
		
		    /**
		     * Emits an event of your choice.
		     * When emitted, every listener attached to that event will be executed.
		     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
		     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
		     * So they will not arrive within the array on the other side, they will be separate.
		     * You can also pass a regular expression to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {Array} [args] Optional array of arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emitEvent = function emitEvent(evt, args) {
		        var listeners = this.getListenersAsObject(evt);
		        var listener;
		        var i;
		        var key;
		        var response;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                i = listeners[key].length;
		
		                while (i--) {
		                    // If the listener returns true then it shall be removed from the event
		                    // The function is executed either with a basic call or an apply if there is an args array
		                    listener = listeners[key][i];
		
		                    if (listener.once === true) {
		                        this.removeListener(evt, listener.listener);
		                    }
		
		                    response = listener.listener.apply(this, args || []);
		
		                    if (response === this._getOnceReturnValue()) {
		                        this.removeListener(evt, listener.listener);
		                    }
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of emitEvent
		     */
		    proto.trigger = alias('emitEvent');
		
		    /**
		     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
		     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {...*} Optional additional arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emit = function emit(evt) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return this.emitEvent(evt, args);
		    };
		
		    /**
		     * Sets the current value to check against when executing listeners. If a
		     * listeners return value matches the one set here then it will be removed
		     * after execution. This value defaults to true.
		     *
		     * @param {*} value The new value to check for when executing listeners.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.setOnceReturnValue = function setOnceReturnValue(value) {
		        this._onceReturnValue = value;
		        return this;
		    };
		
		    /**
		     * Fetches the current value to check against when executing listeners. If
		     * the listeners return value matches this one then it should be removed
		     * automatically. It will return true by default.
		     *
		     * @return {*|Boolean} The current value to check for or the default, true.
		     * @api private
		     */
		    proto._getOnceReturnValue = function _getOnceReturnValue() {
		        if (this.hasOwnProperty('_onceReturnValue')) {
		            return this._onceReturnValue;
		        }
		        else {
		            return true;
		        }
		    };
		
		    /**
		     * Fetches the events object and creates one if required.
		     *
		     * @return {Object} The events storage object.
		     * @api private
		     */
		    proto._getEvents = function _getEvents() {
		        return this._events || (this._events = {});
		    };
		
		    /**
		     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
		     *
		     * @return {Function} Non conflicting EventEmitter class.
		     */
		    EventEmitter.noConflict = function noConflict() {
		        exports.EventEmitter = originalGlobalValue;
		        return EventEmitter;
		    };
		
		    // Expose the class either via AMD, CommonJS or the global object
		    if (typeof define === 'function' && define.amd) {
		        define(function () {
		            return EventEmitter;
		        });
		    }
		    else if (typeof module === 'object' && module.exports){
		        module.exports = EventEmitter;
		    }
		    else {
		        exports.EventEmitter = EventEmitter;
		    }
		}.call(this));
		
		}.call(window));
	
	/***/ },
	/* 183 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-slider\" :id=\"id\"\n    :class=\"{\n        min: value === 0, max: value === 100, dragging: dragging, disabled: disabled,\n        active: active, 'has-label': hasLabel\n    }\"\n\n    :tabindex=\"disabled ? null : 0\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"100\"\n    :aria-valuenow=\"value\"\n\n    @keydown.left.prevent=\"decrement\" @keydown.right.prevent=\"increment\"\n    @keydown.down.prevent=\"decrement\" @keydown.up.prevent=\"increment\"\n    @focus=\"focus\" @blur=\"blur\"\n>\n    <input type=\"hidden\" :value=\"value\" :name=\"name\">\n\n    <div class=\"ui-slider-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-slider-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-slider-content\">\n        <div class=\"ui-slider-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n        <div class=\"ui-slider-wrapper\" v-el:slider @mousedown=\"sliderClick\">\n            <div class=\"ui-slider-containment\" v-el:containment></div>\n\n            <div class=\"ui-slider-track\">\n                <div class=\"ui-slider-track-fill\" :style=\"{ width: value + '%'}\"></div>\n            </div>\n\n            <div class=\"ui-slider-thumb-container\" v-el:thumb>\n                <div class=\"ui-slider-focus-ring\"></div>\n                <div class=\"ui-slider-thumb\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 184 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(185)
		__vue_script__ = __webpack_require__(186)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSnackbar.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(187)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSnackbar.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 185 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 186 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-snackbar',
		
		    props: {
		        id: String,
		        show: {
		            type: Boolean,
		            default: false,
		            twoWay: true
		        },
		        message: String,
		        action: String,
		        actionColor: {
		            type: String,
		            default: 'accent' },
		        persistent: {
		            type: Boolean,
		            default: false
		        },
		        duration: {
		            type: Number,
		            default: 5000
		        },
		        autoHide: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    data: function data() {
		        return {
		            height: 0,
		            timeout: null
		        };
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.timeout) {
		            clearTimeout(this.timeout);
		        }
		    },
		
		
		    methods: {
		        click: function click() {
		            this.$dispatch('clicked');
		            this.hide();
		        },
		        actionClick: function actionClick() {
		            this.$dispatch('action-clicked');
		            this.hide();
		        },
		        hide: function hide() {
		            if (!this.persistent) {
		                this.show = false;
		            }
		        }
		    },
		
		    components: {
		        UiButton: _UiButton2.default
		    },
		
		    transitions: {
		        'ui-snackbar-toggle': {
		            afterEnter: function afterEnter() {
		                this.$dispatch('shown');
		
		                if (this.autoHide) {
		                    this.timeout = setTimeout(this.hide, this.duration);
		                }
		            },
		            afterLeave: function afterLeave() {
		                this.$dispatch('hidden');
		
		                if (this.timeout) {
		                    clearTimeout(this.timeout);
		                    this.timeout = null;
		                }
		            }
		        }
		    }
		};
	
	/***/ },
	/* 187 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-snackbar\" :id=\"id\" transition=\"ui-snackbar-toggle\" @click=\"click\" v-show=\"show\"\n>\n    <div class=\"ui-snackbar-text\">\n        <slot>\n            <span v-text=\"message\"></span>\n        </slot>\n    </div>\n\n    <div class=\"ui-snackbar-action\">\n        <ui-button\n            class=\"ui-snackbar-action-button\" type=\"flat\" :color=\"actionColor\"\n            :text=\"action\" @click.stop=\"actionClick\" v-if=\"action\"\n        ></ui-button>\n    </div>\n</div>\n";
	
	/***/ },
	/* 188 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(189)
		__vue_script__ = __webpack_require__(190)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSnackbarContainer.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(191)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSnackbarContainer.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 189 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 190 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _UiSnackbar = __webpack_require__(184);
		
		var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-snackbar-container',
		
		    props: {
		        queueSnackbars: {
		            type: Boolean,
		            default: false
		        },
		        defaultDuration: {
		            type: Number,
		            default: 5000
		        },
		        position: {
		            type: String,
		            default: 'left', coerce: function coerce(position) {
		                return 'position-' + position;
		            }
		        }
		    },
		
		    events: {
		        'ui-snackbar::create': function uiSnackbarCreate(snackbar) {
		            snackbar.show = false;
		            snackbar.id = snackbar.id || _uuid2.default.short('ui-snackbar-');
		            snackbar.duration = snackbar.duration || this.defaultDuration;
		
		            this.queue.push(snackbar);
		
		            if (this.queue.length === 1) {
		                this.showNext();
		            } else {
		                if (!this.queueSnackbars) {
		                    this.queue[0].show = false;
		                }
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            queue: [] };
		    },
		
		
		    methods: {
		        showNext: function showNext() {
		            if (!this.queue.length) {
		                return;
		            }
		
		            this.queue[0].show = true;
		        },
		        shown: function shown(snackbar) {
		            this.$dispatch('snackbar-shown', snackbar);
		            this.callHook('onShow', snackbar);
		        },
		        hidden: function hidden(snackbar) {
		            this.$dispatch('snackbar-hidden', snackbar);
		            this.callHook('onHide', snackbar);
		
		            this.queue.$remove(snackbar);
		            this.showNext();
		        },
		        clicked: function clicked(snackbar) {
		            this.callHook('onClick', snackbar);
		        },
		        actionClicked: function actionClicked(snackbar) {
		            this.callHook('onActionClick', snackbar);
		        },
		        callHook: function callHook(hook, snackbar) {
		            if (typeof snackbar[hook] === 'function') {
		                snackbar[hook].call(undefined, snackbar);
		            }
		        }
		    },
		
		    components: {
		        UiSnackbar: _UiSnackbar2.default
		    }
		};
	
	/***/ },
	/* 191 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-snackbar-container\" :class=\"[position]\">\n    <ui-snackbar\n        :duration=\"s.duration\" :show.sync=\"s.show\" :action=\"s.action\"\n        :action-color=\"s.actionColor\" :persistent=\"s.persistent\" :id=\"s.id\" auto-hide\n\n        @shown=\"shown(s)\" @hidden=\"hidden(s)\" @clicked=\"clicked(s)\"\n        @action-clicked=\"actionClicked(s)\"\n\n        v-for=\"s in queue\"\n    >\n        <div v-html=\"s.message\" v-if=\"s.allowHtml\"></div>\n        <span v-text=\"s.message\" v-else></span>\n    </ui-snackbar>\n</div>\n";
	
	/***/ },
	/* 192 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(193)
		__vue_script__ = __webpack_require__(194)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSwitch.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(195)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSwitch.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 193 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 194 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-switch',
		
		    props: {
		        name: String,
		        value: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            initialValue: false
		        };
		    },
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 195 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-switch\"\n    :class=\"{ 'checked': value, 'disabled': disabled, 'label-left': labelLeft }\"\n>\n    <div class=\"ui-switch-container\">\n        <input\n            class=\"ui-switch-input\" type=\"checkbox\" :name=\"name\" :id=\"id\" v-model=\"value\"\n            v-disabled=\"disabled\"\n        >\n\n        <div class=\"ui-switch-track\"></div>\n        <div class=\"ui-switch-thumb\"></div>\n\n        <div class=\"ui-switch-focus-ring\"></div>\n    </div>\n\n    <div class=\"ui-switch-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 196 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(197)
		__vue_script__ = __webpack_require__(198)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTab.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(199)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTab.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 197 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 198 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-tab',
		
		    props: {
		        id: String,
		        header: String,
		        icon: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        active: function active() {
		            return this.$parent.activeTab === this.id;
		        }
		    },
		
		    watch: {
		        active: function active() {
		            if (this.active) {
		                this.$dispatch('selected', this.id);
		            } else {
		                this.$dispatch('deselected', this.id);
		            }
		        }
		    }
		};
	
	/***/ },
	/* 199 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-tab\" :id=\"id\" role=\"tabpanel\" :tabindex=\"active ? '0' : null\"\n    :aria-hidden=\"!active ? 'true' : null\" v-show=\"active\"\n>\n    <slot></slot>\n</div>\n";
	
	/***/ },
	/* 200 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(201)
		__vue_script__ = __webpack_require__(202)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTabs.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(207)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTabs.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 201 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 202 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _UiTabHeaderItem = __webpack_require__(203);
		
		var _UiTabHeaderItem2 = _interopRequireDefault(_UiTabHeaderItem);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tabs',
		
		    props: {
		        type: {
		            type: String,
		            default: 'text' },
		        activeTab: String,
		        backgroundColor: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'background-color-' + color;
		            }
		        },
		        textColor: {
		            type: String,
		            default: 'black', coerce: function coerce(color) {
		                return 'text-color-' + color;
		            }
		        },
		        textColorActive: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'text-color-active-' + color;
		            }
		        },
		        indicatorColor: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        fullwidth: {
		            type: Boolean,
		            default: false
		        },
		        raised: {
		            type: Boolean,
		            default: false
		        },
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            activeTabElement: null
		        };
		    },
		
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = ['ui-tabs-type-' + this.type];
		
		            if (this.raised) {
		                classes.push('raised');
		            }
		
		            if (this.fullwidth) {
		                classes.push('fullwidth');
		            }
		
		            return classes;
		        },
		        indicatorLeft: function indicatorLeft() {
		            if (this.activeTabElement) {
		                return this.activeTabElement.offsetLeft + 'px';
		            }
		
		            return 0;
		        },
		        indicatorRight: function indicatorRight() {
		            if (this.activeTabElement) {
		                var left = this.activeTabElement.offsetLeft;
		                var width = this.activeTabElement.offsetWidth;
		                var tabContainerWidth = this.$els.tabsContainer.offsetWidth;
		
		                return tabContainerWidth - (left + width) + 'px';
		            }
		        }
		    },
		
		    ready: function ready() {
		        var _this = this;
		
		        for (var i = 0; i < this.$children.length; i++) {
		            this.$children[i].id = this.$children[i].id || _uuid2.default.short('ui-tab-');
		        }
		
		        this.activeTab = this.activeTab || this.$children[0].id;
		
		        this.$nextTick(function () {
		            if (_this.$els.tabsContainer) {
		                _this.activeTabElement = _this.$els.tabsContainer.querySelector('.active');
		            }
		        });
		    },
		
		
		    events: {
		        'ui-tabs::select': function uiTabsSelect(tabId, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            var tab = this.findTabById(tabId);
		
		            if (tab) {
		                this.select(tab.$el, tab);
		            }
		        }
		    },
		
		    methods: {
		        select: function select(e, tab) {
		            var newTabElement = e.currentTarget ? e.currentTarget : e;
		
		            if (tab.disabled || this.activeTabElement === newTabElement) {
		                return;
		            }
		
		            this.activeTabElement = newTabElement;
		            this.activeTab = tab.id;
		
		            this.$dispatch('active-tab-changed', tab.id);
		        },
		        selectPrev: function selectPrev(currentTabIndex) {
		            if (currentTabIndex === 0) {
		                return;
		            }
		
		            var prevTab = this.findTab(currentTabIndex);
		            this.select(prevTab.$el, prevTab);
		
		            this.activeTabElement.focus();
		        },
		        selectNext: function selectNext(currentTabIndex) {
		            if (currentTabIndex === this.$refs.tabElements.length - 1) {
		                return;
		            }
		
		            var nextTab = this.findTab(currentTabIndex, true);
		            this.select(nextTab.$el, nextTab);
		
		            this.activeTabElement.focus();
		        },
		        findTab: function findTab(currentTabIndex, next) {
		            var tab = void 0;
		
		            if (next) {
		                for (var i = currentTabIndex + 1; i < this.$refs.tabElements.length; i++) {
		                    if (!this.$refs.tabElements[i].disabled) {
		                        tab = this.$refs.tabElements[i];
		                        break;
		                    }
		                }
		            } else {
		                for (var _i = currentTabIndex - 1; _i >= 0; _i--) {
		                    if (!this.$refs.tabElements[_i].disabled) {
		                        tab = this.$refs.tabElements[_i];
		                        break;
		                    }
		                }
		            }
		
		            tab = tab || this.$refs.tabElements[currentTabIndex];
		
		            return tab;
		        },
		        findTabById: function findTabById(id) {
		            var tab = null;
		
		            var numOfTabs = this.$refs.tabElements.length;
		
		            for (var i = 0; i <= numOfTabs; i++) {
		                if (id === this.$refs.tabElements[i].id) {
		                    tab = this.$refs.tabElements[i];
		                    break;
		                }
		            }
		
		            return tab;
		        }
		    },
		
		    components: {
		        UiTabHeaderItem: _UiTabHeaderItem2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 203 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(204)
		__vue_script__ = __webpack_require__(205)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTabHeaderItem.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(206)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTabHeaderItem.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 204 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 205 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tab-header-item',
		
		    props: {
		        id: String,
		        type: {
		            type: String,
		            default: 'text' },
		        text: String,
		        icon: String,
		        active: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 206 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-tab-header-item\" role=\"tab\"\n    :class=\"['type-' + type, { 'active': active, 'disabled': disabled }]\"\n\n    :tabindex=\"active ? 0 : -1\" :aria-controls=\"id\" :aria-selected=\"active ? 'true' : null\"\n    v-disabled=\"disabled\" v-el:item\n>\n    <div\n        class=\"ui-tab-header-item-icon\" v-if=\"type === 'icon' || type === 'icon-and-text'\"\n    >\n        <ui-icon :icon=\"icon\"></ui-icon>\n    </div>\n\n    <div\n        class=\"ui-tab-header-item-text\" v-text=\"text\"\n        v-if=\"type === 'text' || type === 'icon-and-text'\"\n    ></div>\n\n    <ui-ripple-ink :trigger=\"$els.item\" v-if=\"!hideRippleInk && !disabled\"></ui-ripple-ink>\n</li>\n";
	
	/***/ },
	/* 207 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-tabs\" :class=\"styleClasses\">\n    <div class=\"ui-tabs-header\" :class=\"[backgroundColor]\">\n        <ul\n            class=\"ui-tabs-header-items\" :class=\"[textColor, textColorActive]\" role=\"tablist\"\n            v-el:tabs-container\n        >\n            <ui-tab-header-item\n                :type=\"type\" :id=\"tab.id\" :icon=\"tab.icon\" :text=\"tab.header\"\n                :active=\"activeTab === tab.id\" :disabled=\"tab.disabled\"\n                :hide-ripple-ink=\"hideRippleInk\"\n\n                @click=\"select($event, tab)\" @keydown.left=\"selectPrev(index)\"\n                @keydown.right=\"selectNext($index)\"\n\n                v-for=\"(index, tab) in $children\" v-ref:tab-elements\n            ></ui-tab-header-item>\n        </ul>\n\n        <div\n            class=\"ui-tabs-active-tab-indicator\" :class=\"[indicatorColor]\"\n            :style=\"{ 'left': indicatorLeft, 'right': indicatorRight }\"\n        ></div>\n    </div>\n\n    <div class=\"ui-tabs-body\">\n        <slot></slot>\n    </div>\n</div>\n";
	
	/***/ },
	/* 208 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(209)
		__vue_script__ = __webpack_require__(210)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTextbox.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(211)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTextbox.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 209 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 210 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _autofocus = __webpack_require__(90);
		
		var _autofocus2 = _interopRequireDefault(_autofocus);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-textbox',
		
		    props: {
		        type: {
		            type: String,
		            default: 'text'
		        },
		        multiLine: {
		            type: Boolean,
		            default: false
		        },
		        rows: {
		            type: Number,
		            default: 2
		        },
		        maxLength: Number,
		        trimValue: {
		            type: Boolean,
		            default: true
		        },
		        validateOnBlur: {
		            type: Boolean,
		            default: false
		        },
		        autocomplete: String,
		        autofocus: {
		            type: Boolean,
		            default: false
		        },
		        min: Number,
		        max: Number,
		        step: {
		            type: String,
		            default: 'any',
		            coerce: String
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (this.ignoreValueChange) {
		                return;
		            }
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            if (!this.validateOnBlur) {
		                this.validate();
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            ignoreValueChange: false
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        minValue: function minValue() {
		            if (this.type !== 'number') {
		                return null;
		            }
		
		            if (this.min || this.min === 0) {
		                return this.min;
		            }
		
		            return null;
		        },
		        maxValue: function maxValue() {
		            if (this.type !== 'number') {
		                return null;
		            }
		
		            if (this.max || this.max === 0) {
		                return this.max;
		            }
		
		            return null;
		        },
		        stepValue: function stepValue() {
		            if (this.type === 'number') {
		                return this.step;
		            }
		
		            return null;
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            var _this = this;
		
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.ignoreValueChange = true;
		
		            if (document.activeElement === this.$el.querySelector('input') || document.activeElement === this.$el.querySelector('textarea')) {
		                document.activeElement.blur();
		            }
		
		            this.validationError = '';
		            this.value = this.initialValue;
		            this.valid = true;
		            this.dirty = false;
		
		            this.$nextTick(function () {
		                _this.ignoreValueChange = false;
		            });
		        }
		    },
		
		    methods: {
		        focussed: function focussed() {
		            this.active = true;
		            this.$dispatch('focussed');
		        },
		        blurred: function blurred() {
		            this.active = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            this.$dispatch('blurred');
		            this.validate();
		        },
		        changed: function changed() {
		            this.$dispatch('changed');
		        },
		        keydown: function keydown(e) {
		            this.$dispatch('keydown', e);
		        },
		        keydownEnter: function keydownEnter(e) {
		            this.$dispatch('keydown-enter', e);
		        }
		    },
		
		    filters: {
		        trim: {
		            write: function write(value) {
		                if (this.type !== 'number' && this.trimValue) {
		                    return value.trim();
		                }
		
		                return value;
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    directives: {
		        autofocus: _autofocus2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 211 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-textbox\"\n    :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'is-multi-line': multiLine, 'icon-right': iconRight,\n        'has-counter': maxLength\n    }\"\n>\n    <div class=\"ui-textbox-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-textbox-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-textbox-content\">\n        <label class=\"ui-textbox-label\">\n            <div class=\"ui-textbox-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <input\n                class=\"ui-textbox-input\" :type=\"type\" :placeholder=\"placeholder\" :name=\"name\"\n                :id=\"id\" :number=\"type === 'number' ? true : null\" :min=\"minValue\"\n                :max=\"maxValue\" :step=\"stepValue\"\n                :autocomplete=\"autocomplete ? autocomplete : null\"\n\n                @focus=\"focussed\" @blur=\"blurred\" @change=\"changed\" @keydown=\"keydown\"\n                @keydown.enter=\"keydownEnter\" :debounce=\"debounce\"\n\n                v-model=\"value | trim\" v-disabled=\"disabled\" v-if=\"!multiLine\"\n                v-autofocus=\"autofocus\"\n            >\n\n            <textarea\n                class=\"ui-textbox-textarea\" :placeholder=\"placeholder\" :name=\"name\" :id=\"id\"\n                :rows=\"rows\"\n\n                @focus=\"focussed\" @blur=\"blurred\" @change=\"changed\" @keydown=\"keydown\"\n                @keydown.enter=\"keydownEnter\" :debounce=\"debounce\"\n\n                v-model=\"value | trim\" v-disabled=\"disabled\" v-else\n            ></textarea>\n        </label>\n\n        <div class=\"ui-textbox-feedback\" v-if=\"showFeedback || maxLength\">\n            <div\n                class=\"ui-textbox-error-text\" transition=\"ui-textbox-feedback-toggle\"\n                v-text=\"validationError\" v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-textbox-help-text\" transition=\"ui-textbox-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n\n            <div\n                class=\"ui-textbox-counter\" v-text=\"value.length + '/' + maxLength\"\n                v-if=\"maxLength\"\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 212 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(213)
		__vue_script__ = __webpack_require__(214)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiToolbar.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(215)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiToolbar.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 213 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 214 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiProgressLinear = __webpack_require__(137);
		
		var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-toolbar',
		
		    props: {
		        type: {
		            type: String,
		            default: 'default', coerce: function coerce(type) {
		                return 'ui-toolbar-' + type;
		            }
		        },
		        textColor: {
		            type: String,
		            default: 'black', coerce: function coerce(color) {
		                return 'text-color-' + color;
		            }
		        },
		        title: String,
		        brand: String,
		        showBrand: {
		            type: Boolean,
		            default: false
		        },
		        showBrandDivider: {
		            type: Boolean,
		            default: null
		        },
		        navIcon: {
		            type: String,
		            default: 'menu'
		        },
		        hideNavIcon: {
		            type: Boolean,
		            default: false
		        },
		        flat: {
		            type: Boolean,
		            default: false
		        },
		        preloaderTop: {
		            type: Boolean,
		            default: false
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.textColor];
		
		            if (!this.flat) {
		                classes.push('ui-toolbar-raised');
		            }
		
		            return classes;
		        },
		        iconColor: function iconColor() {
		            if (this.textColor === 'text-color-black') {
		                return 'black';
		            }
		
		            return 'white';
		        },
		        preloaderColor: function preloaderColor() {
		            if (this.textColor === 'text-color-black') {
		                return 'primary';
		            }
		
		            return 'white';
		        },
		        brandDividerVisible: function brandDividerVisible() {
		            if (this.showBrandDivider !== null) {
		                return this.showBrandDivider;
		            }
		
		            if (!this.showBrand) {
		                return false;
		            }
		
		            return true;
		        }
		    },
		
		    methods: {
		        navIconClick: function navIconClick() {
		            this.$dispatch('nav-icon-clicked');
		        }
		    },
		
		    components: {
		        UiProgressLinear: _UiProgressLinear2.default,
		        UiIconButton: _UiIconButton2.default
		    }
		};
	
	/***/ },
	/* 215 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-toolbar\" :class=\"styleClasses\">\n    <div class=\"ui-toolbar-left\">\n        <ui-icon-button\n            class=\"ui-toolbar-nav-icon\" type=\"clear\" :color=\"iconColor\" :icon=\"navIcon\"\n            @click=\"navIconClick\" v-if=\"!hideNavIcon\"\n        ></ui-icon-button>\n\n        <div class=\"ui-toolbar-brand\" v-if=\"showBrand\">\n            <slot name=\"brand\">\n                <div class=\"ui-toolbar-brand-text\" v-text=\"brand\"></div>\n            </slot>\n        </div>\n    </div>\n\n    <div class=\"ui-toolbar-center\">\n        <div class=\"ui-toolbar-divider\" v-if=\"brandDividerVisible\"></div>\n\n        <slot>\n            <div class=\"ui-toolbar-title\" v-text=\"title\"></div>\n        </slot>\n    </div>\n\n    <div class=\"ui-toolbar-right\">\n        <slot name=\"actions\"></slot>\n    </div>\n\n    <ui-progress-linear\n        :show=\"loading\" class=\"ui-toolbar-preloader\" :class=\"{ 'position-top' : preloaderTop }\"\n        :color=\"preloaderColor\"\n    ></ui-progress-linear>\n</div>\n";
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=keen-ui.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(8)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(135)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 6 */,
/* 7 */,
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _MapView = __webpack_require__(9);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _ParamsView = __webpack_require__(69);
	
	var _ParamsView2 = _interopRequireDefault(_ParamsView);
	
	var _SettingsView = __webpack_require__(73);
	
	var _SettingsView2 = _interopRequireDefault(_SettingsView);
	
	var _GcsIndicators = __webpack_require__(77);
	
	var _GcsIndicators2 = _interopRequireDefault(_GcsIndicators);
	
	var _SocketIoManager = __webpack_require__(81);
	
	var _SocketIoManager2 = _interopRequireDefault(_SocketIoManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    data: function data() {
	        return {};
	    },
	
	
	    events: {
	        'app::create-snackbar': function appCreateSnackbar(message, snackbar) {
	            this.createSnackbar(message, snackbar);
	        },
	        'map::pan-up': function mapPanUp() {
	            this.$broadcast('map::pan-up');
	        },
	        'map::pan-down': function mapPanDown() {
	            this.$broadcast('map::pan-down');
	        },
	        'map::pan-left': function mapPanLeft() {
	            this.$broadcast('map::pan-left');
	        },
	        'map::pan-right': function mapPanRight() {
	            this.$broadcast('map::pan-right');
	        },
	        'map::pan-center': function mapPanCenter() {
	            this.$broadcast('map::pan-center');
	        },
	        'map::zoom-in': function mapZoomIn() {
	            this.$broadcast('map::zoom-in');
	        },
	        'map::zoom-out': function mapZoomOut() {
	            this.$broadcast('map::zoom-out');
	        },
	        'map::change-type': function mapChangeType(newType) {
	            this.$broadcast('map::change-type', newType);
	        },
	        'map:click': function mapClick(e) {
	            this.$broadcast('map:click', e);
	        },
	        'map:dblclick': function mapDblclick(e) {
	            this.$broadcast('map:dblclick', e);
	        },
	        'map:rightclick': function mapRightclick(e) {
	            this.$broadcast('map:rightclick', e);
	        }
	    },
	
	    methods: {
	        createSnackbar: function createSnackbar(message, snackbar) {
	            snackbar = snackbar || {
	                message: message
	            };
	
	            this.$broadcast('ui-snackbar::create', snackbar);
	        }
	    },
	
	    components: {
	        MapView: _MapView2.default,
	        ParamsView: _ParamsView2.default,
	        SettingsView: _SettingsView2.default,
	        GcsIndicators: _GcsIndicators2.default,
	        SocketIoManager: _SocketIoManager2.default
	    }
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(10)
	__vue_script__ = __webpack_require__(11)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/views/MapView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(68)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./MapView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 10 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsMap = __webpack_require__(12);
	
	var _GcsMap2 = _interopRequireDefault(_GcsMap);
	
	var _GcsMapControls = __webpack_require__(25);
	
	var _GcsMapControls2 = _interopRequireDefault(_GcsMapControls);
	
	var _GcsMapSidebar = __webpack_require__(29);
	
	var _GcsMapSidebar2 = _interopRequireDefault(_GcsMapSidebar);
	
	var _GcsSidebarControls = __webpack_require__(56);
	
	var _GcsSidebarControls2 = _interopRequireDefault(_GcsSidebarControls);
	
	var _GcsWamv = __webpack_require__(64);
	
	var _GcsWamv2 = _interopRequireDefault(_GcsWamv);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    data: function data() {
	        return {
	            showSidebar: true
	        };
	    },
	
	
	    methods: {
	        toggleSidebar: function toggleSidebar() {
	            this.showSidebar = !this.showSidebar;
	        }
	    },
	
	    components: {
	        GcsMap: _GcsMap2.default,
	        GcsWamv: _GcsWamv2.default,
	        GcsMapControls: _GcsMapControls2.default,
	        GcsMapSidebar: _GcsMapSidebar2.default,
	        GcsSidebarControls: _GcsSidebarControls2.default
	    }
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(13)
	__vue_script__ = __webpack_require__(14)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/map/GcsMap.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(24)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsMap.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 13 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _copyObject = __webpack_require__(15);
	
	var _copyObject2 = _interopRequireDefault(_copyObject);
	
	var _loadGoogleMapsApi = __webpack_require__(19);
	
	var _loadGoogleMapsApi2 = _interopRequireDefault(_loadGoogleMapsApi);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapEl: _getters.getMapEl,
	            mapLoaded: _getters.getMapLoaded,
	            mapEditing: _getters.getMapEditing,
	            wamv: _getters.getWamv,
	            config: _getters.getConfig,
	            settings: _getters.getSettings
	        },
	
	        actions: {
	            setMap: _actions.setMap,
	            setMapEl: _actions.setMapEl,
	            setMapLoaded: _actions.setMapLoaded
	        }
	    },
	
	    watch: {
	        mapEditing: function mapEditing() {
	            if (this.mapEditing) {
	                this.map.setOptions({ draggableCursor: 'crosshair' });
	            } else {
	                this.map.setOptions({ draggableCursor: 'move' });
	            }
	        }
	    },
	
	    ready: function ready() {
	        this.setMapEl(document.getElementById('map'));
	
	        (0, _loadGoogleMapsApi2.default)(this.config.googleMaps).then(this.initializeMap).catch(function (error) {
	            console.log('Unable to load Google Maps API', error);
	        });
	    },
	
	
	    events: {
	        'map::pan-up': function mapPanUp() {
	            this.map.panBy(0, -1 * (this.mapEl.clientHeight / 4));
	        },
	        'map::pan-down': function mapPanDown() {
	            this.map.panBy(0, this.mapEl.clientHeight / 4);
	        },
	        'map::pan-left': function mapPanLeft() {
	            this.map.panBy(-1 * (this.mapEl.clientWidth / 4), 0);
	        },
	        'map::pan-right': function mapPanRight() {
	            this.map.panBy(this.mapEl.clientWidth / 4, 0);
	        },
	        'map::pan-center': function mapPanCenter() {
	            if (this.wamv.loaded) {
	                this.map.panTo(this.wamv.position);
	            }
	        },
	        'map::zoom-in': function mapZoomIn() {
	            this.map.setZoom(this.map.getZoom() + 1);
	        },
	        'map::zoom-out': function mapZoomOut() {
	            this.map.setZoom(this.map.getZoom() - 1);
	        },
	        'map::change-type': function mapChangeType(newType) {
	            this.map.setMapTypeId(google.maps.MapTypeId[newType]);
	        }
	    },
	
	    methods: {
	        initializeMap: function initializeMap() {
	            var mapConfig = (0, _copyObject2.default)(this.config.map);
	
	            mapConfig.mapTypeId = google.maps.MapTypeId[this.settings.defaultMapType];
	
	            var map = new google.maps.Map(this.mapEl, mapConfig);
	
	            this.setupEvents(map);
	
	            this.setMap(map);
	            this.setMapLoaded(true);
	        },
	        setupEvents: function setupEvents(map) {
	            var _this = this;
	
	            map.addListener('click', function (e) {
	                _this.$dispatch('map:click', e);
	            });
	
	            map.addListener('dblclick', function (e) {
	                _this.$dispatch('map:dblclick', e);
	            });
	
	            map.addListener('rightclick', function (e) {
	                _this.$dispatch('map:rightclick', e);
	            });
	        }
	    }
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(16);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	exports.default = function (object) {
	    return JSON.parse((0, _stringify2.default)(object));
	};
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(17), __esModule: true };

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(18)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 18 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var client = _ref.client;
	  var key = _ref.key;
	  var language = _ref.language;
	  var _ref$libraries = _ref.libraries;
	  var libraries = _ref$libraries === undefined ? [] : _ref$libraries;
	  var _ref$timeout = _ref.timeout;
	  var timeout = _ref$timeout === undefined ? 10000 : _ref$timeout;
	  var v = _ref.v;
	
	  var callbackName = '__googleMapsApiOnLoadCallback';
	
	  return new Promise(function (resolve, reject) {
	
	    // Exit if not running inside a browser.
	    if (typeof window === 'undefined') {
	      return reject(new Error('Can only load the Google Maps API in the browser'));
	    }
	
	    // Prepare the `script` tag to be inserted into the page.
	    var scriptElement = document.createElement('script');
	    var params = ['callback=' + callbackName];
	    if (client) params.push('client=' + client);
	    if (key) params.push('key=' + key);
	    if (language) params.push('language=' + language);
	    libraries = [].concat(libraries); // Ensure that `libraries` is an array
	    if (libraries.length) params.push('libraries=' + libraries.join(','));
	    if (v) params.push('v=' + v);
	    scriptElement.src = 'https://maps.googleapis.com/maps/api/js?' + params.join('&');
	
	    // Timeout if necessary.
	    var timeoutId = null;
	    if (timeout) {
	      timeoutId = setTimeout(function () {
	        window[callbackName] = function () {}; // Set the on load callback to a no-op.
	        reject(new Error('Could not load the Google Maps API'));
	      }, timeout);
	    }
	
	    // Hook up the on load callback.
	    window[callbackName] = function () {
	      if (timeoutId !== null) {
	        clearTimeout(timeoutId);
	      }
	      resolve(window.google.maps);
	      delete window[callbackName];
	    };
	
	    // Insert the `script` tag.
	    document.body.appendChild(scriptElement);
	  });
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setMap = setMap;
	exports.setMapEl = setMapEl;
	exports.setMapLoaded = setMapLoaded;
	exports.setMapEditing = setMapEditing;
	exports.setWamv = setWamv;
	exports.setWamvArmed = setWamvArmed;
	exports.setWamvMode = setWamvMode;
	exports.initSettings = initSettings;
	exports.updateSetting = updateSetting;
	exports.setMissions = setMissions;
	exports.setCurrentMissionIndex = setCurrentMissionIndex;
	exports.setCurrentMission = setCurrentMission;
	exports.setParameters = setParameters;
	exports.sendGetParameters = sendGetParameters;
	exports.succeedGetParameters = succeedGetParameters;
	exports.failGetParameters = failGetParameters;
	exports.sendSaveMissions = sendSaveMissions;
	exports.succeedSaveMissions = succeedSaveMissions;
	exports.failSaveMissions = failSaveMissions;
	exports.sendLoadMissions = sendLoadMissions;
	exports.succeedLoadMissions = succeedLoadMissions;
	exports.failLoadMissions = failLoadMissions;
	exports.sendUploadMission = sendUploadMission;
	exports.succeedUploadMission = succeedUploadMission;
	exports.failUploadMission = failUploadMission;
	exports.sendDownloadMission = sendDownloadMission;
	exports.succeedDownloadMission = succeedDownloadMission;
	exports.failDownloadMission = failDownloadMission;
	exports.sendStartMission = sendStartMission;
	exports.succeedStartMission = succeedStartMission;
	exports.failStartMission = failStartMission;
	exports.sendStopMission = sendStopMission;
	exports.succeedStopMission = succeedStopMission;
	exports.failStopMission = failStopMission;
	exports.sendResumeMission = sendResumeMission;
	exports.succeedResumeMission = succeedResumeMission;
	exports.failResumeMission = failResumeMission;
	exports.sendArm = sendArm;
	exports.succeedArm = succeedArm;
	exports.failArm = failArm;
	exports.sendDisarm = sendDisarm;
	exports.succeedDisarm = succeedDisarm;
	exports.failDisarm = failDisarm;
	exports.sendKill = sendKill;
	exports.succeedKill = succeedKill;
	exports.failKill = failKill;
	exports.sendUnkill = sendUnkill;
	exports.succeedUnkill = succeedUnkill;
	exports.failUnkill = failUnkill;
	
	var _deepAssign = __webpack_require__(21);
	
	var _deepAssign2 = _interopRequireDefault(_deepAssign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function setMap(_ref, map) {
	  var dispatch = _ref.dispatch;
	  var state = _ref.state;
	
	  dispatch('SET_MAP', map);
	}
	
	function setMapEl(_ref2, mapEl) {
	  var dispatch = _ref2.dispatch;
	  var state = _ref2.state;
	
	  dispatch('SET_MAP_EL', mapEl);
	}
	
	function setMapLoaded(_ref3, loaded) {
	  var dispatch = _ref3.dispatch;
	  var state = _ref3.state;
	
	  dispatch('SET_MAP_LOADED', loaded);
	}
	
	function setMapEditing(_ref4, editing) {
	  var dispatch = _ref4.dispatch;
	  var state = _ref4.state;
	
	  dispatch('SET_MAP_EDITING', editing);
	}
	
	function setWamv(_ref5, wamv) {
	  var dispatch = _ref5.dispatch;
	  var state = _ref5.state;
	
	  dispatch('SET_WAMV', wamv);
	}
	
	function setWamvArmed(_ref6, armed) {
	  var dispatch = _ref6.dispatch;
	  var state = _ref6.state;
	
	  dispatch('SET_WAMV_ARMED', armed);
	}
	
	function setWamvMode(_ref7, mode) {
	  var dispatch = _ref7.dispatch;
	  var state = _ref7.state;
	
	  dispatch('SET_WAMV_MODE', mode);
	}
	
	function initSettings(_ref8) {
	  var dispatch = _ref8.dispatch;
	}
	
	function updateSetting(_ref9, key, value) {
	  var dispatch = _ref9.dispatch;
	  var state = _ref9.state;
	
	  var settings = (0, _deepAssign2.default)({}, state.settings);
	  settings[key] = value;
	
	  dispatch('UPDATE_SETTINGS', settings);
	}
	
	function setMissions(_ref10, missions) {
	  var dispatch = _ref10.dispatch;
	  var state = _ref10.state;
	
	  dispatch('SET_MISSIONS', missions);
	}
	
	function setCurrentMissionIndex(_ref11, index) {
	  var dispatch = _ref11.dispatch;
	  var state = _ref11.state;
	
	  dispatch('SET_CURRENT_MISSION_INDEX', index);
	}
	
	function setCurrentMission(_ref12, mission) {
	  var dispatch = _ref12.dispatch;
	  var state = _ref12.state;
	
	  dispatch('SET_CURRENT_MISSION', mission);
	}
	
	function setParameters(_ref13, parameters) {
	  var dispatch = _ref13.dispatch;
	  var state = _ref13.state;
	
	  dispatch('SET_PARAMETERS', parameters);
	}
	
	function sendGetParameters(_ref14) {
	  var dispatch = _ref14.dispatch;
	  var state = _ref14.state;
	
	  dispatch('SEND_GET_PARAMETERS');
	}
	
	function succeedGetParameters(_ref15, parameters) {
	  var dispatch = _ref15.dispatch;
	  var state = _ref15.state;
	
	  dispatch('SUCCEED_GET_PARAMETERS', parameters);
	}
	
	function failGetParameters(_ref16, msg) {
	  var dispatch = _ref16.dispatch;
	  var state = _ref16.state;
	
	  dispatch('FAIL_GET_PARAMETERS', msg);
	}
	
	function sendSaveMissions(_ref17, missions) {
	  var dispatch = _ref17.dispatch;
	  var state = _ref17.state;
	
	  dispatch('SEND_SAVE_MISSIONS', missions);
	}
	
	function succeedSaveMissions(_ref18) {
	  var dispatch = _ref18.dispatch;
	  var state = _ref18.state;
	
	  dispatch('SUCCEED_SAVE_MISSIONS');
	}
	
	function failSaveMissions(_ref19, msg) {
	  var dispatch = _ref19.dispatch;
	  var state = _ref19.state;
	
	  dispatch('FAIL_SAVE_MISSIONS', msg);
	}
	
	function sendLoadMissions(_ref20) {
	  var dispatch = _ref20.dispatch;
	  var state = _ref20.state;
	
	  dispatch('SEND_LOAD_MISSIONS');
	}
	
	function succeedLoadMissions(_ref21, missions) {
	  var dispatch = _ref21.dispatch;
	  var state = _ref21.state;
	
	  dispatch('SUCCEED_LOAD_MISSIONS', missions);
	}
	
	function failLoadMissions(_ref22, msg) {
	  var dispatch = _ref22.dispatch;
	  var state = _ref22.state;
	
	  dispatch('FAIL_LOAD_MISSIONS', msg);
	}
	
	function sendUploadMission(_ref23, mission) {
	  var dispatch = _ref23.dispatch;
	  var state = _ref23.state;
	
	  dispatch('SEND_UPLOAD_MISSION', mission);
	}
	
	function succeedUploadMission(_ref24) {
	  var dispatch = _ref24.dispatch;
	  var state = _ref24.state;
	
	  dispatch('SUCCEED_UPLOAD_MISSION');
	}
	
	function failUploadMission(_ref25, msg) {
	  var dispatch = _ref25.dispatch;
	  var state = _ref25.state;
	
	  dispatch('FAIL_UPLOAD_MISSION', msg);
	}
	
	function sendDownloadMission(_ref26) {
	  var dispatch = _ref26.dispatch;
	  var state = _ref26.state;
	
	  dispatch('SEND_DOWNLOAD_MISSION');
	}
	
	function succeedDownloadMission(_ref27, mission) {
	  var dispatch = _ref27.dispatch;
	  var state = _ref27.state;
	
	  dispatch('SUCCEED_DOWNLOAD_MISSION', mission);
	}
	
	function failDownloadMission(_ref28, msg) {
	  var dispatch = _ref28.dispatch;
	  var state = _ref28.state;
	
	  dispatch('FAIL_DOWNLOAD_MISSION', msg);
	}
	
	function sendStartMission(_ref29) {
	  var dispatch = _ref29.dispatch;
	  var state = _ref29.state;
	
	  dispatch('SEND_START_MISSION');
	}
	
	function succeedStartMission(_ref30) {
	  var dispatch = _ref30.dispatch;
	  var state = _ref30.state;
	
	  dispatch('SUCCEED_START_MISSION');
	}
	
	function failStartMission(_ref31, msg) {
	  var dispatch = _ref31.dispatch;
	  var state = _ref31.state;
	
	  dispatch('FAIL_START_MISSION', msg);
	}
	
	function sendStopMission(_ref32) {
	  var dispatch = _ref32.dispatch;
	  var state = _ref32.state;
	
	  dispatch('SEND_STOP_MISSION');
	}
	
	function succeedStopMission(_ref33) {
	  var dispatch = _ref33.dispatch;
	  var state = _ref33.state;
	
	  dispatch('SUCCEED_STOP_MISSION');
	}
	
	function failStopMission(_ref34, msg) {
	  var dispatch = _ref34.dispatch;
	  var state = _ref34.state;
	
	  dispatch('FAIL_STOP_MISSION', msg);
	}
	
	function sendResumeMission(_ref35) {
	  var dispatch = _ref35.dispatch;
	  var state = _ref35.state;
	
	  dispatch('SEND_RESUME_MISSION');
	}
	
	function succeedResumeMission(_ref36) {
	  var dispatch = _ref36.dispatch;
	  var state = _ref36.state;
	
	  dispatch('SUCCEED_RESUME_MISSION');
	}
	
	function failResumeMission(_ref37, msg) {
	  var dispatch = _ref37.dispatch;
	  var state = _ref37.state;
	
	  dispatch('FAIL_RESUME_MISSION', msg);
	}
	
	function sendArm(_ref38) {
	  var dispatch = _ref38.dispatch;
	  var state = _ref38.state;
	
	  dispatch('SEND_ARM');
	}
	
	function succeedArm(_ref39) {
	  var dispatch = _ref39.dispatch;
	  var state = _ref39.state;
	
	  dispatch('SUCCEED_ARM');
	}
	
	function failArm(_ref40, msg) {
	  var dispatch = _ref40.dispatch;
	  var state = _ref40.state;
	
	  dispatch('FAIL_ARM', msg);
	}
	
	function sendDisarm(_ref41) {
	  var dispatch = _ref41.dispatch;
	  var state = _ref41.state;
	
	  dispatch('SEND_DISARM');
	}
	
	function succeedDisarm(_ref42) {
	  var dispatch = _ref42.dispatch;
	  var state = _ref42.state;
	
	  dispatch('SUCCEED_DISARM');
	}
	
	function failDisarm(_ref43, msg) {
	  var dispatch = _ref43.dispatch;
	  var state = _ref43.state;
	
	  dispatch('FAIL_DISARM', msg);
	}
	
	function sendKill(_ref44) {
	  var dispatch = _ref44.dispatch;
	  var state = _ref44.state;
	
	  dispatch('SEND_KILL');
	}
	
	function succeedKill(_ref45) {
	  var dispatch = _ref45.dispatch;
	  var state = _ref45.state;
	
	  dispatch('SUCCEED_KILL');
	}
	
	function failKill(_ref46, msg) {
	  var dispatch = _ref46.dispatch;
	  var state = _ref46.state;
	
	  dispatch('FAIL_KILL', msg);
	}
	
	function sendUnkill(_ref47) {
	  var dispatch = _ref47.dispatch;
	  var state = _ref47.state;
	
	  dispatch('SEND_UNKILL');
	}
	
	function succeedUnkill(_ref48) {
	  var dispatch = _ref48.dispatch;
	  var state = _ref48.state;
	
	  dispatch('SUCCEED_UNKILL');
	}
	
	function failUnkill(_ref49, msg) {
	  var dispatch = _ref49.dispatch;
	  var state = _ref49.state;
	
	  dispatch('FAIL_UNKILL', msg);
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObj = __webpack_require__(22);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Sources cannot be null or undefined');
		}
	
		return Object(val);
	}
	
	function assignKey(to, from, key) {
		var val = from[key];
	
		if (val === undefined || val === null) {
			return;
		}
	
		if (hasOwnProperty.call(to, key)) {
			if (to[key] === undefined || to[key] === null) {
				throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
			}
		}
	
		if (!hasOwnProperty.call(to, key) || !isObj(val)) {
			to[key] = val;
		} else {
			to[key] = assign(Object(to[key]), from[key]);
		}
	}
	
	function assign(to, from) {
		if (to === from) {
			return to;
		}
	
		from = Object(from);
	
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				assignKey(to, from, key);
			}
		}
	
		if (Object.getOwnPropertySymbols) {
			var symbols = Object.getOwnPropertySymbols(from);
	
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					assignKey(to, from, symbols[i]);
				}
			}
		}
	
		return to;
	}
	
	module.exports = function deepAssign(target) {
		target = toObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			assign(target, arguments[s]);
		}
	
		return target;
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (x) {
		var type = typeof x;
		return x !== null && (type === 'object' || type === 'function');
	};


/***/ },
/* 23 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getMap = getMap;
	exports.getMapEl = getMapEl;
	exports.getMapLoaded = getMapLoaded;
	exports.getMapEditing = getMapEditing;
	exports.getWamv = getWamv;
	exports.getConfig = getConfig;
	exports.getSettings = getSettings;
	exports.getMissions = getMissions;
	exports.getCurrentMissionIndex = getCurrentMissionIndex;
	exports.getCurrentMission = getCurrentMission;
	exports.getParameters = getParameters;
	exports.getMessageStateWaiting = getMessageStateWaiting;
	exports.getMessageStateSuccess = getMessageStateSuccess;
	exports.getMessageStateFailure = getMessageStateFailure;
	exports.getGetParameterState = getGetParameterState;
	exports.getGetParameterData = getGetParameterData;
	exports.getSaveMissionsState = getSaveMissionsState;
	exports.getSaveMissionsData = getSaveMissionsData;
	exports.getLoadMissionsState = getLoadMissionsState;
	exports.getLoadMissionsData = getLoadMissionsData;
	exports.getUploadMissionState = getUploadMissionState;
	exports.getUploadMissionData = getUploadMissionData;
	exports.getDownloadMissionState = getDownloadMissionState;
	exports.getDownloadMissionData = getDownloadMissionData;
	exports.getStartMissionState = getStartMissionState;
	exports.getStartMissionData = getStartMissionData;
	exports.getStopMissionState = getStopMissionState;
	exports.getStopMissionData = getStopMissionData;
	exports.getResumeMissionState = getResumeMissionState;
	exports.getResumeMissionData = getResumeMissionData;
	exports.getArmState = getArmState;
	exports.getArmData = getArmData;
	exports.getDisarmState = getDisarmState;
	exports.getDisarmData = getDisarmData;
	exports.getKillState = getKillState;
	exports.getKillData = getKillData;
	exports.getUnkillState = getUnkillState;
	exports.getUnkillData = getUnkillData;
	function getMap(state) {
	    return state.map;
	}
	
	function getMapEl(state) {
	    return state.mapEl;
	}
	
	function getMapLoaded(state) {
	    return state.mapLoaded;
	}
	
	function getMapEditing(state) {
	    return state.mapEditing;
	}
	
	function getWamv(state) {
	    return state.wamv;
	}
	
	function getConfig(state) {
	    return state.config;
	}
	
	function getSettings(state) {
	    return state.settings;
	}
	
	function getMissions(state) {
	    return state.missions;
	}
	
	function getCurrentMissionIndex(state) {
	    return state.currentMissionIndex;
	}
	
	function getCurrentMission(state) {
	    return state.missions[state.currentMissionIndex];
	}
	
	function getParameters(state) {
	    return state.parameters;
	}
	
	function getMessageStateWaiting(state) {
	    return state.messageState.WAITING;
	}
	
	function getMessageStateSuccess(state) {
	    return state.messageState.SUCCESS;
	}
	
	function getMessageStateFailure(state) {
	    return state.messageState.FAILURE;
	}
	
	function getGetParameterState(state) {
	    return state.messageState.get_parameters[0];
	}
	
	function getGetParameterData(state) {
	    return state.messageState.get_parameters[1];
	}
	
	function getSaveMissionsState(state) {
	    return state.messageState.save_missions[0];
	}
	
	function getSaveMissionsData(state) {
	    return state.messageState.save_missions[1];
	}
	
	function getLoadMissionsState(state) {
	    return state.messageState.load_missions[0];
	}
	
	function getLoadMissionsData(state) {
	    return state.messageState.load_missions[1];
	}
	
	function getUploadMissionState(state) {
	    return state.messageState.upload_mission[0];
	}
	
	function getUploadMissionData(state) {
	    return state.messageState.upload_mission[1];
	}
	
	function getDownloadMissionState(state) {
	    return state.messageState.download_mission[0];
	}
	
	function getDownloadMissionData(state) {
	    return state.messageState.download_mission[1];
	}
	
	function getStartMissionState(state) {
	    return state.messageState.start_mission[0];
	}
	
	function getStartMissionData(state) {
	    return state.messageState.start_mission[1];
	}
	
	function getStopMissionState(state) {
	    return state.messageState.stop_mission[0];
	}
	
	function getStopMissionData(state) {
	    return state.messageState.stop_mission[1];
	}
	
	function getResumeMissionState(state) {
	    return state.messageState.resume_mission[0];
	}
	
	function getResumeMissionData(state) {
	    return state.messageState.resume_mission[1];
	}
	
	function getArmState(state) {
	    return state.messageState.arm[0];
	}
	
	function getArmData(state) {
	    return state.messageState.arm[1];
	}
	
	function getDisarmState(state) {
	    return state.messageState.disarm[0];
	}
	
	function getDisarmData(state) {
	    return state.messageState.disarm[1];
	}
	
	function getKillState(state) {
	    return state.messageState.kill[0];
	}
	
	function getKillData(state) {
	    return state.messageState.kill[1];
	}
	
	function getUnkillState(state) {
	    return state.messageState.unkill[0];
	}
	
	function getUnkillData(state) {
	    return state.messageState.unkill[1];
	}

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map\" id=\"map\" :class=\"{ 'gcs-map-edit-mode': mapEditing }\"></div>\n";

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(26)
	__vue_script__ = __webpack_require__(27)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/map/GcsMapControls.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(28)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsMapControls.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 26 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {
	            mapType: 'Satellite',
	            mapTypesMenu: [{ 'value': 'ROADMAP', text: 'Road' }, { 'value': 'TERRAIN', text: 'Terrain' }, { 'value': 'SATELLITE', text: 'Satellite' }, { 'value': 'HYBRID', text: 'Hybrid' }]
	        };
	    },
	
	
	    methods: {
	        pan: function pan(direction) {
	            this.$dispatch('map::pan-' + direction);
	        },
	        zoom: function zoom(type) {
	            this.$dispatch('map::zoom-' + type);
	        },
	        changeMapType: function changeMapType(selected) {
	            this.mapType = selected.text;
	            this.$dispatch('map::change-type', selected.value);
	        }
	    }
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map-controls\">\n    <div class=\"pan-controls\">\n        <ui-icon-button\n            class=\"pan-control up\" icon=\"keyboard_arrow_up\" @click=\"pan('up')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control right\" icon=\"keyboard_arrow_right\" @click=\"pan('right')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control down\" icon=\"keyboard_arrow_down\" @click=\"pan('down')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control left\" icon=\"keyboard_arrow_left\" @click=\"pan('left')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control center\" icon=\"my_location\" @click=\"pan('center')\"\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"zoom-controls\">\n        <ui-icon-button\n            class=\"zoom-control in\" icon=\"add\" @click=\"zoom('in')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"zoom-control out\" icon=\"remove\" @click=\"zoom('out')\"\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"type-control\">\n        <ui-button\n            :menu-options=\"mapTypesMenu\" name=\"map_types\" :text=\"mapType\"\n            @menu-option-selected=\"changeMapType\" has-dropdown-menu raised\n            dropdown-position=\"top right\" :show-dropdown-icon=\"false\"\n        ></ui-button>\n    </div>\n</div>\n";

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(30)
	__vue_script__ = __webpack_require__(31)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/map/GcsMapSidebar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(55)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsMapSidebar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 30 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsMissions = __webpack_require__(32);
	
	var _GcsMissions2 = _interopRequireDefault(_GcsMissions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        showSidebar: {
	            type: Boolean,
	            required: true
	        }
	    },
	
	    components: {
	        GcsMissions: _GcsMissions2.default
	    }
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(33)
	__vue_script__ = __webpack_require__(34)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/mission/GcsMissions.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(54)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsMissions.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 33 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(16);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _GcsMission = __webpack_require__(35);
	
	var _GcsMission2 = _interopRequireDefault(_GcsMission);
	
	var _GcsMissionRow = __webpack_require__(50);
	
	var _GcsMissionRow2 = _interopRequireDefault(_GcsMissionRow);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            missions: _getters.getMissions,
	            currentMissionIndex: _getters.getCurrentMissionIndex,
	            currentMission: _getters.getCurrentMission,
	            WAITING: _getters.getMessageStateWaiting,
	            SUCCESS: _getters.getMessageStateSuccess,
	            FAILURE: _getters.getMessageStateFailure,
	            saveMissionsState: _getters.getSaveMissionsState,
	            saveMissionsData: _getters.getSaveMissionsData,
	            loadMissionsState: _getters.getLoadMissionsState,
	            loadMissionsData: _getters.getLoadMissionsData
	        },
	
	        actions: {
	            setMissions: _actions.setMissions,
	            setCurrentMissionIndex: _actions.setCurrentMissionIndex,
	            sendSaveMissions: _actions.sendSaveMissions,
	            failSaveMissions: _actions.failSaveMissions,
	            sendLoadMissions: _actions.sendLoadMissions,
	            failLoadMissions: _actions.failLoadMissions
	        }
	    },
	
	    data: function data() {
	        return {
	            currentView: 'listing',
	            overflowMenu: [{ id: 'save', text: 'Save to server' }, { id: 'load', text: 'Load from server' }, { id: 'sep1', text: '', type: 'divider' }, { id: 'export', text: 'Export to file' }, { id: 'import', text: 'Import from file' }, { id: 'sep2', text: '', type: 'divider' }, { id: 'clear', text: 'Clear all' }]
	        };
	    },
	
	
	    methods: {
	        selectMission: function selectMission(index) {
	            this.setCurrentMissionIndex(index);
	            this.currentView = 'gcs-mission';
	        },
	        showListingView: function showListingView() {
	            this.currentView = 'listing';
	            this.setCurrentMissionIndex(-1);
	        },
	        addMission: function addMission() {
	            this.missions.push({
	                title: 'Mission ' + (this.missions.length + 1),
	                description: null,
	                waypoints: []
	            });
	        },
	        menuOptionSelected: function menuOptionSelected(option) {
	            var _this = this;
	
	            switch (option.id) {
	                case 'save':
	                    {
	                        this.sendSaveMissions(this.missions);
	                        setTimeout(function () {
	                            if (_this.saveMissionsState == _this.WAITING) {
	                                _this.failSaveMissions('Timeout reached.');
	                            }
	                        }, 1000);
	                        break;
	                    }
	                case 'load':
	                    {
	                        this.sendLoadMissions(this.missions);
	                        setTimeout(function () {
	                            if (_this.loadMissionsState == _this.WAITING) {
	                                _this.failLoadMissions('Timeout reached.');
	                            }
	                        }, 1000);
	                        break;
	                    }
	                case 'import':
	                    {
	                        document.getElementById('import_missions_input').click();
	                        break;
	                    }
	                case 'export':
	                    {
	                        var uri = 'data:application/json,';
	                        uri += (0, _stringify2.default)(this.missions);
	                        uri = encodeURI(uri);
	
	                        var link = document.getElementById('export_missions_link');
	                        link.href = uri;
	                        link.download = 'missions.json';
	
	                        link.click();
	                        break;
	                    }
	                case 'clear':
	                    {
	                        this.setMissions([]);
	                    }
	            }
	        },
	        importMission: function importMission() {
	            var _this2 = this;
	
	            var files = document.getElementById('import_missions_input').files;
	
	            if (files.length > 0) {
	                var file = files[0];
	                var reader = new FileReader();
	
	                reader.onload = function (e) {
	                    var contents = e.target.result;
	                    try {
	                        var newMissions = JSON.parse(contents);
	
	                        _this2.setMissions(newMissions);
	                    } catch (e) {
	                        console.log('file contents are invalid: ' + e.message);
	                    }
	                };
	
	                reader.readAsText(file);
	            }
	        }
	    },
	
	    watch: {
	        saveMissionsState: function saveMissionsState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Missions saved.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to save missions: ' + this.saveMissionsData);
	                }
	            }
	        },
	        loadMissionsState: function loadMissionsState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    this.setMissions(this.loadMissionsData);
	                    console.log('Missions loaded.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to load missions: ' + this.loadMissionsData);
	                }
	            }
	        }
	    },
	
	    events: {
	        'delete-mission': function deleteMission(index) {
	            this.missions.splice(index, 1);
	        }
	    },
	
	    components: {
	        GcsMission: _GcsMission2.default,
	        GcsMissionRow: _GcsMissionRow2.default
	    }
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(36)
	__vue_script__ = __webpack_require__(37)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/mission/GcsMission.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(49)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsMission.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 36 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsWaypoint = __webpack_require__(38);
	
	var _GcsWaypoint2 = _interopRequireDefault(_GcsWaypoint);
	
	var _GcsWaypointLink = __webpack_require__(44);
	
	var _GcsWaypointLink2 = _interopRequireDefault(_GcsWaypointLink);
	
	var _elementScroll = __webpack_require__(42);
	
	var _elementScroll2 = _interopRequireDefault(_elementScroll);
	
	var _numberToLetter = __webpack_require__(48);
	
	var _numberToLetter2 = _interopRequireDefault(_numberToLetter);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            mapEditing: _getters.getMapEditing
	        },
	
	        actions: {
	            setMapEditing: _actions.setMapEditing
	        }
	    },
	
	    props: {
	        mission: {
	            type: Object,
	            required: true
	        }
	    },
	
	    data: function data() {
	        return {
	            waypointsVisible: true,
	            overflowMenu: [{ id: 'edit', text: 'Edit mission' }, { id: 'delete', text: 'Delete mission' }]
	        };
	    },
	    ready: function ready() {
	        this.setMapEditing(true);
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.setMapEditing(false);
	    },
	
	
	    events: {
	        'map:click': function mapClick(e) {
	            var _this = this;
	
	            if (!this.mapEditing) {
	                return;
	            }
	
	            var lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            var lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	
	            var newWaypoint = {
	                title: null,
	                type: 'normal',
	                visible: true,
	                position: {
	                    lat: lat,
	                    lng: lng
	                }
	            };
	
	            this.mission.waypoints.push(newWaypoint);
	
	            this.$nextTick(function () {
	                _elementScroll2.default.scrollToEnd(_this.$els.pageContent);
	            });
	        },
	        'map:dblclick': function mapDblclick(e) {
	            console.log('Map double clicked', e);
	        },
	        'map:rightclick': function mapRightclick(e) {
	            console.log('Map right-clicked', e);
	        },
	        'waypoint:drag': function waypointDrag(index, lat, lng) {
	            this.mission.waypoints[index].position.lat = lat;
	            this.mission.waypoints[index].position.lng = lng;
	
	            this.$broadcast('waypointLink:drag_start', index, lat, lng);
	            var nextIndex = index > 0 ? index - 1 : this.mission.waypoints.length - 1;
	            this.$broadcast('waypointLink:drag_end', nextIndex, lat, lng);
	        },
	        'waypointLink:click': function waypointLinkClick(index, lat, lng) {
	            if (!this.mapEditing) {
	                return;
	            }
	
	            var newWaypoint = {
	                title: null,
	                type: 'normal',
	                visible: true,
	                position: {
	                    lat: lat,
	                    lng: lng
	                }
	            };
	            this.mission.waypoints.splice(index + 1, 0, newWaypoint);
	        }
	    },
	
	    methods: {
	        goBack: function goBack() {
	            this.$dispatch('go-back');
	        },
	        toLetter: function toLetter(number) {
	            return (0, _numberToLetter2.default)(number);
	        },
	        toggleWaypointVisibility: function toggleWaypointVisibility() {
	            var _this2 = this;
	
	            this.waypointsVisible = !this.waypointsVisible;
	
	            this.mission.waypoints = this.mission.waypoints.map(function (waypoint) {
	                waypoint.visible = _this2.waypointsVisible;
	
	                return waypoint;
	            });
	
	            this.setMapEditing(this.waypointsVisible);
	        },
	        deleteWaypoint: function deleteWaypoint(index) {
	            this.mission.waypoints.splice(index, 1);
	        },
	        clearWaypoints: function clearWaypoints() {
	            this.mission.waypoints = [];
	
	            this.waypointsVisible = true;
	            this.setMapEditing(true);
	        }
	    },
	
	    components: {
	        GcsWaypoint: _GcsWaypoint2.default,
	        GcsWaypointLink: _GcsWaypointLink2.default
	    }
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(39)
	__vue_script__ = __webpack_require__(40)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/markers/GcsWaypoint.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(43)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsWaypoint.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 39 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(41);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	var _elementScroll = __webpack_require__(42);
	
	var _elementScroll2 = _interopRequireDefault(_elementScroll);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        index: Number,
	        label: {
	            type: String,
	            coerce: String
	        },
	        title: {
	            type: String,
	            coerce: function coerce(value) {
	                return value ? String(value) : '';
	            }
	        },
	        type: {
	            type: String,
	            default: 'normal'
	        }
	    },
	
	    data: function data() {
	        return {
	            dragging: false,
	            highlighted: false,
	            fillColor: { normal: 'yellow', hover: 'lime' }
	        };
	    },
	
	
	    events: {
	        click: function click() {
	            _elementScroll2.default.scrollIntoView(this.$el, null, 56);
	        },
	        rightclick: function rightclick() {
	            this.$dispatch('delete');
	        },
	        drag: function drag(e) {
	            this.lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            this.lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	            this.$dispatch('waypoint:drag', this.index, this.lat, this.lng);
	        },
	        mouseover: function mouseover() {
	            this.highlighted = true;
	            if (this.marker) {
	                this.marker.setIcon(this.getIcon(this.fillColor.hover));
	            }
	        },
	        mouseout: function mouseout() {
	            this.highlighted = false;
	            if (this.marker && !this.dragging) {
	                this.marker.setIcon(this.getIcon(this.fillColor.normal));
	            }
	        },
	        dragstart: function dragstart() {
	            this.dragging = true;
	        },
	        dragend: function dragend() {
	            this.dragging = false;
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var fillColor = arguments.length <= 0 || arguments[0] === undefined ? this.fillColor.normal : arguments[0];
	            var scale = arguments.length <= 1 || arguments[1] === undefined ? this.scale : arguments[1];
	            var rotation = arguments.length <= 2 || arguments[2] === undefined ? this.rotation : arguments[2];
	
	            return {
	                path: google.maps.SymbolPath.CIRCLE,
	                rotation: rotation,
	                scale: scale,
	                fillColor: fillColor,
	                fillOpacity: 1,
	                strokeColor: 'white',
	                strokeWeight: 2
	            };
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapEl: _getters.getMapEl,
	            mapLoaded: _getters.getMapLoaded
	        }
	    },
	
	    props: {
	        title: String,
	        lat: {
	            type: Number,
	            required: true
	        },
	        lng: {
	            type: Number,
	            required: true
	        },
	        rotation: {
	            type: Number,
	            default: 0
	        },
	        scale: {
	            type: Number,
	            default: 6
	        },
	        visible: {
	            type: Boolean,
	            default: true
	        },
	        draggable: {
	            type: Boolean,
	            default: false
	        }
	    },
	
	    data: function data() {
	        return {
	            marker: null
	        };
	    },
	
	
	    computed: {
	        position: function position() {
	            return {
	                lat: this.lat,
	                lng: this.lng
	            };
	        }
	    },
	
	    ready: function ready() {
	        if (this.mapLoaded) {
	            this.initializeMarker();
	        }
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.marker.setMap(null);
	        this.marker = null;
	    },
	
	
	    watch: {
	        mapLoaded: function mapLoaded(newVal, oldVal) {
	            if (!oldVal && newVal && !this.marker) {
	                this.initializeMarker();
	            }
	        },
	        map: function map() {
	            if (this.marker) {
	                this.marker.setMap(this.map);
	            }
	        },
	        title: function title() {
	            if (this.marker) {
	                this.marker.setTitle(this.title);
	            }
	        },
	        label: function label() {
	            if (this.marker) {
	                this.marker.setLabel(this.label);
	            }
	        },
	        position: function position() {
	            if (this.marker) {
	                this.marker.setPosition(this.position);
	            }
	        },
	        visible: function visible() {
	            if (this.marker) {
	                this.marker.setVisible(this.visible);
	            }
	        },
	        draggable: function draggable() {
	            if (this.marker) {
	                this.marker.setDraggable(this.draggable);
	            }
	        },
	        rotation: function rotation() {
	            this.updateIcon();
	        },
	        scale: function scale() {
	            this.updateIcon();
	        }
	    },
	
	    methods: {
	        initializeMarker: function initializeMarker() {
	            this.marker = new google.maps.Marker({
	                position: this.position,
	                icon: this.getIcon(),
	                draggable: this.draggable,
	                visible: this.visible,
	                map: this.map
	            });
	
	            if (this.title) {
	                this.marker.setTitle(this.title);
	            }
	
	            if (this.label) {
	                this.marker.setLabel(this.label);
	            }
	
	            this.$dispatch('initialized', this.marker);
	
	            this.setupEvents();
	        },
	        updateIcon: function updateIcon() {
	            if (this.marker) {
	                this.marker.setIcon(this.getIcon());
	            }
	        },
	        setupEvents: function setupEvents() {
	            var _this = this;
	
	            this.marker.addListener('click', function (e) {
	                _this.$dispatch('click', e);
	            });
	
	            this.marker.addListener('dblclick', function (e) {
	                _this.$dispatch('dblclick', e);
	            });
	
	            this.marker.addListener('rightclick', function (e) {
	                _this.$dispatch('rightclick', e);
	            });
	
	            this.marker.addListener('mouseover', function (e) {
	                _this.$dispatch('mouseover', e);
	            });
	
	            this.marker.addListener('mouseout', function (e) {
	                _this.$dispatch('mouseout', e);
	            });
	
	            this.marker.addListener('dragstart', function (e) {
	                _this.$dispatch('dragstart', e);
	            });
	
	            this.marker.addListener('drag', function (e) {
	                _this.$dispatch('drag', e);
	            });
	
	            this.marker.addListener('dragend', function (e) {
	                _this.$dispatch('dragend', e);
	            });
	
	            this.marker.addListener('position_changed', function (e) {
	                _this.$dispatch('position_changed', e);
	            });
	        }
	    }
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.inView = inView;
	exports.scrollIntoView = scrollIntoView;
	exports.scrollToStart = scrollToStart;
	exports.scrollToEnd = scrollToEnd;
	function inView(element, container) {
	    if (!element) {
	        return;
	    }
	
	    container = container || element.parentElement;
	
	    var top = element.offsetTop;
	    var parentTop = container.scrollTop;
	    var bottom = top + element.offsetHeight;
	    var parentBottom = container.offsetHeight;
	
	    return top >= parentTop && bottom <= parentBottom;
	}
	
	function scrollIntoView(element, container) {
	    var marginTop = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    if (!element || inView(element, container)) {
	        return;
	    }
	
	    container = container || element.parentElement;
	
	    container.scrollTop = element.offsetTop - marginTop;
	}
	
	function scrollToStart(element) {
	    if (!element) {
	        return;
	    }
	
	    element.scrollTop = 0;
	}
	
	function scrollToEnd(element) {
	    if (!element) {
	        return;
	    }
	
	    element.scrollTop = element.scrollHeight;
	}
	
	exports.default = {
	    inView: inView,
	    scrollIntoView: scrollIntoView,
	    scrollToStart: scrollToStart,
	    scrollToEnd: scrollToEnd
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-waypoint\" :class=\"{ 'highlighted': (dragging || highlighted) }\">\n    <div class=\"number\" v-text=\"index + 1\"></div>\n\n    <div class=\"content\">\n        <div class=\"row\">\n            <ui-textbox\n                class=\"column\" label=\"Title\" name=\"title\" :value.sync=\"title\"\n            ></ui-textbox>\n        </div>\n\n        <div class=\"row\">\n            <ui-textbox\n                class=\"column one-half\" label=\"Latitude\" name=\"latitude\" :value.sync=\"lat\"\n                type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n\n            <ui-textbox\n                class=\"column one-half\" label=\"Longitude\" name=\"longitude\" :value.sync=\"lng\"\n                type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n        </div>\n\n        <div class=\"row\">\n            <ui-select\n                class=\"column one-half\" label=\"Type\" name=\"type\" :value.sync=\"type\"\n                :options=\"[{ text: 'Normal', value: 'normal' }]\" :default=\"type\"\n            ></ui-select>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(45)
	__vue_script__ = __webpack_require__(46)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/markers/GcsWaypointLink.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(47)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsWaypointLink.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 45 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapLoaded: _getters.getMapLoaded
	        }
	    },
	
	    props: {
	        index: {
	            type: Number,
	            required: true
	        },
	        start: {
	            type: Object,
	            required: true
	        },
	        end: {
	            type: Object,
	            required: true
	        },
	        visible: {
	            type: Boolean,
	            default: true
	        }
	    },
	
	    data: function data() {
	        return {
	            link: null,
	            strokeColor: { normal: 'black', hover: 'green' }
	        };
	    },
	    ready: function ready() {
	        if (this.mapLoaded) {
	            this.initializeLink();
	        }
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.link.setMap(null);
	        this.link = null;
	    },
	
	
	    watch: {
	        mapLoaded: function mapLoaded(newVal, oldVal) {
	            if (!oldVal && newVal && !this.link) {
	                this.initializeLink();
	            }
	        },
	        map: function map() {
	            if (this.link) {
	                this.link.setMap(this.map);
	            }
	        },
	        start: function start() {
	            if (this.link) {
	                this.link.getPath().setAt(0, new google.maps.LatLng(this.start.lat, this.start.lng));
	            }
	        },
	        end: function end() {
	            if (this.link) {
	                this.link.getPath().setAt(1, new google.maps.LatLng(this.end.lat, this.end.lng));
	            }
	        }
	    },
	
	    methods: {
	        initializeLink: function initializeLink() {
	            var _this = this;
	
	            this.link = new google.maps.Polyline({
	                path: [this.start, this.end],
	                strokeColor: this.strokeColor.normal,
	                strokeOpacity: 1,
	                strokeWeight: 3,
	                visible: this.visible,
	                map: this.map
	            });
	            this.link.addListener('click', function (e) {
	                var lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	                var lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	                _this.$dispatch('waypointLink:click', _this.index, lat, lng);
	            });
	            this.link.addListener('mouseover', function () {
	                if (_this.link) {
	                    _this.link.setOptions({ strokeColor: _this.strokeColor.hover });
	                }
	            });
	            this.link.addListener('mouseout', function () {
	                if (_this.link) {
	                    _this.link.setOptions({ strokeColor: _this.strokeColor.normal });
	                }
	            });
	        }
	    },
	
	    events: {
	        'waypointLink:drag_start': function waypointLinkDrag_start(index, lat, lng) {
	            if (this.index == index) {
	                this.start = { lat: lat, lng: lng };
	            } else {
	                return true;
	            }
	        },
	        'waypointLink:drag_end': function waypointLinkDrag_end(index, lat, lng) {
	            if (this.index == index) {
	                this.end = { lat: lat, lng: lng };
	            } else {
	                return true;
	            }
	        }
	    }
	};

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-waypoint-link\"></div>\n";

/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (number) {
	    if (number > 52) {
	        return '0';
	    }
	
	    var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
	
	    return alphabet[number - 1];
	};

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-mission\">\n    <ui-toolbar :title=\"mission.title\" hide-nav-icon show-brand :show-brand-divider=\"false\">\n        <div slot=\"brand\">\n            <ui-icon-button\n                @click=\"goBack\" type=\"clear\" icon=\"arrow_back\" tooltip=\"Back to Missions\"\n                tooltip-position=\"bottom left\"\n            ></ui-icon-button>\n        </div>\n\n        <div slot=\"actions\">\n            <ui-icon-button\n                type=\"clear\" icon=\"clear_all\" tooltip=\"Clear all\" @click=\"clearWaypoints\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" :icon=\"waypointsVisible ? 'visibility' : 'visibility_off'\"\n                @click=\"toggleWaypointVisibility\"\n                :tooltip=\"waypointsVisible ? 'Hide waypoints' : 'Show waypoints'\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" icon=\"more_vert\" has-dropdown-menu dropdown-position=\"bottom right\"\n                :menu-options=\"overflowMenu\"\n            ></ui-icon-button>\n        </div>\n    </ui-toolbar>\n\n    <div class=\"sidebar-page-content\" v-el:page-content>\n        <p\n            class=\"no-waypoints\" v-if=\"!mission.waypoints.length\"\n        >No waypoints for this mission. Click the map to add a waypoint.</p>\n\n        <component v-else>\n            <gcs-waypoint\n                v-for=\"(index, waypoint) in mission.waypoints\" :index=\"index\"\n                :label=\"toLetter(index + 1)\" :title=\"waypoint.title\" :type=\"waypoint.type\"\n                :lat=\"waypoint.position.lat\" :lng=\"waypoint.position.lng\" :visible=\"waypoint.visible\"\n                :rotation=\"waypoint.rotation\" :scale=\"10\" draggable\n                @delete=\"deleteWaypoint(index)\"\n            ></gcs-waypoint>\n            <gcs-waypoint-link\n                v-for=\"(index, waypoint) in mission.waypoints\"\n                :index=\"index\"\n                :start=\"waypoint.position\"\n                :end=\"mission.waypoints[(index+1) % mission.waypoints.length].position;\"\n            ></gcs-waypoint-link>\n        </component>\n    </div>\n</div>\n";

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(51)
	__vue_script__ = __webpack_require__(52)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/mission/GcsMissionRow.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(53)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsMissionRow.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 51 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: {
	        mission: {
	            type: Object,
	            required: true
	        },
	        index: {
	            type: Number,
	            required: true
	        }
	    },
	
	    computed: {
	        hasWaypoints: function hasWaypoints() {
	            return this.mission.waypoints && this.mission.waypoints.length;
	        },
	        firstWaypoint: function firstWaypoint() {
	            return this.mission.waypoints[0];
	        },
	        lastWaypoint: function lastWaypoint() {
	            return this.mission.waypoints[this.mission.waypoints.length - 1];
	        }
	    },
	
	    methods: {
	        deleteMission: function deleteMission() {
	            this.$dispatch('delete-mission', this.index);
	        }
	    }
	};

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-mission-row\">\n    <ui-icon-button\n        type=\"clear\" icon=\"delete\" class=\"delete-button\" tooltip=\"Delete\" @click=\"deleteMission\"\n    ></ui-icon-button>\n\n    <h3 class=\"mission-header\" v-text=\"mission.title\"></h3>\n\n    <div class=\"mission-summary\">\n        <p class=\"description\" v-if=\"mission.description\" v-text=\"mission.description\"></p>\n\n        <p class=\"waypoints\" v-if=\"!mission.description && hasWaypoints\">\n            <span>From: ({{ firstWaypoint.position.lat }}, {{ firstWaypoint.position.lng }})</span>\n            <span>To: ({{ lastWaypoint.position.lat }}, {{ lastWaypoint.position.lng }})</span>\n        </p>\n\n        <p class=\"no-waypoints\" v-if=\"!mission.description && !hasWaypoints\">No waypoints</p>\n    </div>\n</div>\n";

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-missions\">\n    <div class=\"sidebar-page\">\n        <div class=\"missions-list\" v-if=\"currentView === 'listing'\">\n            <ui-toolbar title=\"Missions\" hide-nav-icon>\n                <div slot=\"actions\">\n                    <ui-icon-button\n                        type=\"clear\" icon=\"add\" tooltip=\"Add mission\" @click=\"addMission\"\n                    ></ui-icon-button>\n\n                    <ui-icon-button\n                        type=\"clear\" icon=\"more_vert\" has-dropdown-menu\n                        dropdown-position=\"bottom right\" :menu-options=\"overflowMenu\"\n                        @menu-option-selected=\"menuOptionSelected\"\n                    ></ui-icon-button>\n                </div>\n            </ui-toolbar>\n\n            <div class=\"sidebar-page-content\">\n                <div class=\"blank-state\" v-if=\"!missions.length\">No missions</div>\n\n                <gcs-mission-row\n                    v-for=\"(index, mission) in missions\" :index=\"index\" :mission=\"mission\"\n                    @click=\"selectMission(index)\"\n                ></gcs-mission-row>\n            </div>\n        </div>\n\n        <component\n            v-else :is=\"currentView\" :mission=\"currentMission\" @go-back=\"showListingView\"\n        ></component>\n    </div>\n</div>\n<!-- hidden input element used for selecting a file to import from -->\n<input type=\"file\" id=\"import_missions_input\" @change=\"importMission\">\n<!-- hidden link used for prompting a download -->\n<a id=\"export_missions_link\"></a>\n";

/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map-sidebar\" v-show=\"showSidebar\" transition=\"sidebar-collapse\">\n    <gcs-missions></gcs-missions>\n</div>\n";

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(57)
	__vue_script__ = __webpack_require__(58)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/map/GcsSidebarControls.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(63)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsSidebarControls.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 57 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsCommands = __webpack_require__(59);
	
	var _GcsCommands2 = _interopRequireDefault(_GcsCommands);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            currentMissionIndex: _getters.getCurrentMissionIndex
	        }
	    },
	
	    props: {
	        showSidebar: {
	            type: Boolean,
	            required: true
	        }
	    },
	
	    methods: {
	        toggleSidebar: function toggleSidebar() {
	            this.$dispatch('toggle-sidebar');
	        }
	    },
	
	    components: {
	        GcsCommands: _GcsCommands2.default
	    }
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(60)
	__vue_script__ = __webpack_require__(61)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/map/GcsCommands.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(62)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsCommands.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 60 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	var _actions = __webpack_require__(20);
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv,
	            missions: _getters.getMissions,
	            WAITING: _getters.getMessageStateWaiting,
	            SUCCESS: _getters.getMessageStateSuccess,
	            FAILURE: _getters.getMessageStateFailure,
	            currentMissionIndex: _getters.getCurrentMissionIndex,
	            uploadMissionState: _getters.getUploadMissionState,
	            uploadMissionData: _getters.getUploadMissionData,
	            downloadMissionState: _getters.getDownloadMissionState,
	            downloadMissionData: _getters.getDownloadMissionData,
	            startMissionState: _getters.getStartMissionState,
	            startMissionData: _getters.getStartMissionData,
	            stopMissionState: _getters.getStopMissionState,
	            stopMissionData: _getters.getStopMissionData,
	            resumeMissionState: _getters.getResumeMissionState,
	            resumeMissionData: _getters.getResumeMissionData,
	            armState: _getters.getArmState,
	            armData: _getters.getArmData,
	            disarmState: _getters.getDisarmState,
	            disarmData: _getters.getDisarmData,
	            killState: _getters.getKillState,
	            killData: _getters.getKillData,
	            unkillState: _getters.getUnkillState,
	            unkillData: _getters.getUnkillData
	        },
	
	        actions: {
	            setArmed: _actions.setWamvArmed,
	            setCurrentMission: _actions.setCurrentMission,
	            sendUploadMission: _actions.sendUploadMission,
	            failUploadMission: _actions.failUploadMission,
	            sendDownloadMission: _actions.sendDownloadMission,
	            failDownloadMission: _actions.failDownloadMission,
	            sendStartMission: _actions.sendStartMission,
	            failStartMission: _actions.failStartMission,
	            sendStopMission: _actions.sendStopMission,
	            failStopMission: _actions.failStopMission,
	            sendResumeMission: _actions.sendResumeMission,
	            failResumeMission: _actions.failResumeMission,
	            sendArm: _actions.sendArm,
	            failArm: _actions.failArm,
	            sendDisarm: _actions.sendDisarm,
	            failDisarm: _actions.failDisarm,
	            sendKill: _actions.sendKill,
	            failKill: _actions.failKill,
	            sendUnkill: _actions.sendUnkill,
	            failUnkill: _actions.failUnkill
	        }
	    },
	
	    computed: {
	        isArmed: {
	            get: function get() {
	                return this.wamv.armed;
	            },
	            set: function set(arm) {
	                var _this = this;
	
	                if (arm) {
	                    this.sendArm();
	                    setTimeout(function () {
	                        if (_this.armState == _this.WAITING) {
	                            _this.failArm('Timeout reached.');
	                        }
	                    }, 1000);
	                } else {
	                    this.sendDisarm();
	                    setTimeout(function () {
	                        if (_this.disarmState == _this.WAITING) {
	                            _this.failDisarm('Timeout reached.');
	                        }
	                    }, 1000);
	                }
	            }
	        }
	    },
	
	    methods: {
	        uploadMission: function uploadMission() {
	            var _this2 = this;
	
	            var mission = this.missions[this.currentMissionIndex];
	            this.sendUploadMission(mission);
	            setTimeout(function () {
	                if (_this2.uploadMissionState == _this2.WAITING) {
	                    _this2.failUploadMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        downloadMission: function downloadMission() {
	            var _this3 = this;
	
	            this.sendDownloadMission();
	            setTimeout(function () {
	                if (_this3.downloadMissionState == _this3.WAITING) {
	                    _this3.failDownloadMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        startMission: function startMission() {
	            var _this4 = this;
	
	            this.sendStartMission();
	            setTimeout(function () {
	                if (_this4.startMissionState == _this4.WAITING) {
	                    _this4.failStartMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        stopMission: function stopMission() {
	            var _this5 = this;
	
	            this.sendStopMission();
	            setTimeout(function () {
	                if (_this5.stopMissionState == _this5.WAITING) {
	                    _this5.failStopMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        resumeMission: function resumeMission() {
	            var _this6 = this;
	
	            this.sendResumeMission();
	            setTimeout(function () {
	                if (_this6.resumeMissionState == _this6.WAITING) {
	                    _this6.failResumeMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        kill: function kill() {
	            var _this7 = this;
	
	            this.sendKill();
	            setTimeout(function () {
	                if (_this7.killState == _this7.WAITING) {
	                    _this7.failKill('Timeout reached.');
	                }
	            }, 1000);
	        },
	        unkill: function unkill() {
	            var _this8 = this;
	
	            this.sendUnkill();
	            setTimeout(function () {
	                if (_this8.unkillState == _this8.WAITING) {
	                    _this8.failUnkill('Timeout reached.');
	                }
	            }, 1000);
	        }
	    },
	
	    watch: {
	        uploadMissionState: function uploadMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission uploaded.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to upload mission: ' + this.uploadMissionData);
	                }
	            }
	        },
	        downloadMissionState: function downloadMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission downloaded.');
	                    this.setCurrentMission(this.downloadMissionData);
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to download mission: ' + this.downloadMissionData);
	                }
	            }
	        },
	        startMissionState: function startMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission started.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to start mission: ' + this.startMissionData);
	                }
	            }
	        },
	        stopMissionState: function stopMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission stopped.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to stop mission: ' + this.stopMissionData);
	                }
	            }
	        },
	        resumeMissionState: function resumeMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission resumed.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to resume mission: ' + this.resumeMissionData);
	                }
	            }
	        },
	        armState: function armState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Vehicle armed.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to arm vehicle: ' + this.armData);
	                }
	            }
	        },
	        disarmState: function disarmState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Vehicle disarmed.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to disarm vehicle: ' + this.disarmData);
	                }
	            }
	        },
	        killState: function killState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Kill switch activated.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to activate kill switch: ' + this.killData);
	                }
	            }
	        },
	        unkillState: function unkillState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Kill switch deactivated.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to deactivate kill switch: ' + this.unkillData);
	                }
	            }
	        }
	    }
	};

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-commands\">\n    <div class=\"row\">\n        <ui-button @click=\"uploadMission\">Upload Mission</ui-button>\n    </div>\n\n    <div class=\"row\">\n        <ui-button @click=\"downloadMission\">Download Mission</ui-button>\n    </div>\n\n    <div class=\"row\">\n        <ui-button\n            v-if=\"wamv.mode == 'idle' || wamv.mode == 'paused'\"\n            @click=\"startMission\"\n        >Start</ui-button>\n        <ui-button\n            v-if=\"wamv.mode == 'paused'\"\n            @click=\"resumeMission\"\n        >Resume</ui-button>\n        <ui-button\n            v-if=\"wamv.mode == 'auto'\"\n            @click=\"stopMission\"\n        >Stop</ui-button>\n    </div>\n\n    <div class=\"row\" v-if=\"wamv.loaded\">\n        <div class=\"column one-half\"> {{ isArmed ? 'Armed' : 'Disarmed' }}</div>\n        <div class=\"column one-half\">\n            <ui-switch :value.sync=\"isArmed\"></ui-switch>\n        </div>\n    </div>\n\n    <div class=\"row\">\n        <ui-button color=\"danger\"\n            v-if=\"wamv.mode != 'killed'\" @click=\"kill\"\n        >Kill</ui-button>\n        <ui-button\n            v-if=\"wamv.mode == 'killed'\" @click=\"unkill\"\n        >Unkill</ui-button>\n    </div>\n</div>\n";

/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = "\n<div\n    class=\"gcs-sidebar-controls\"\n    :style=\"{ transform: 'translateX(' + (showSidebar ? '376px' : '16px' + ')') }\"\n>\n    <ui-button\n        :color=\"showSidebar ? 'primary' : 'default'\" @click=\"toggleSidebar\"\n    >Missions</ui-button>\n\n    <ui-button v-if=\"currentMissionIndex != -1\" has-popover text=\"Commands\">\n        <div slot=\"popover\" class=\"gcs-sidebar-controls-popover\">\n            <gcs-commands></gcs-commands>\n        </div>\n    </ui-button>\n</div>\n";

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(65)
	__vue_script__ = __webpack_require__(66)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/markers/GcsWamv.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(67)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsWamv.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 65 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(41);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    events: {
	        click: function click(e) {
	            console.log('Wamv clicked', e);
	        },
	        initialized: function initialized() {
	            window.wamv = this;
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var scale = arguments.length <= 0 || arguments[0] === undefined ? this.scale : arguments[0];
	            var rotation = arguments.length <= 1 || arguments[1] === undefined ? this.rotation : arguments[1];
	
	            return {
	                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
	                rotation: rotation,
	                scale: scale,
	                fillColor: 'red',
	                fillOpacity: 0.8,
	                strokeColor: 'white',
	                strokeWeight: 2
	            };
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-wamv\"></div>\n";

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view map-view\">\n    <gcs-map></gcs-map>\n    <gcs-map-controls></gcs-map-controls>\n    <gcs-map-sidebar :show-sidebar=\"showSidebar\"></gcs-map-sidebar>\n\n    <gcs-sidebar-controls\n        :show-sidebar=\"showSidebar\" @toggle-sidebar=\"toggleSidebar\"\n    ></gcs-sidebar-controls>\n\n    <gcs-wamv v-if=\"wamv.loaded\"\n        :lat=\"wamv.position.lat\" :lng=\"wamv.position.lng\"\n        :rotation=\"wamv.heading\"\n    ></gcs-wamv>\n</div>\n";

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(70)
	__vue_script__ = __webpack_require__(71)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/views/ParamsView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(72)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./ParamsView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 70 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            parameters: _getters.getParameters
	        }
	    },
	
	    data: function data() {
	        return {};
	    },
	
	
	    methods: {
	        isArray: function isArray(x) {
	            return Array.isArray(x);
	        }
	    }
	};

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view params-view\">\n    <div class=\"page\">\n        <h1 class=\"page-header\">Params</h1>\n        <div class=\"page-content\">\n            <!-- display parameters (up to hierarchy depth 3) -->\n            <div v-for=\"(name, val) in parameters\">\n                <span v-if=\"isArray(val)\"\n                    v-text=\"name + ' (' + val[0] + '): ' + val[1]\"\n                ></span>\n                <div v-else>\n                    <span v-text=\"name\"></span>\n                    <div v-for=\"(name2, val2) in val\">\n                        <span v-if=\"isArray(val2)\"\n                            v-text=\"'> ' + name2 + ' (' + val2[0] + '): ' + val2[1]\"\n                        ></span>\n                        <div v-else>\n                            <span v-text=\"'> ' + name2\"></span>\n                            <div v-for=\"(name3, val3) in val2\">\n                                <span v-if=\"isArray(val3)\"\n                                    v-text=\"'> > ' + name3 + ' (' + val3[0] + '): ' + val3[1]\"\n                                ></span>\n                                <span v-else\n                                    v-text=\"'> > ' + name3 + ': ...'\">\n                                </span>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(74)
	__vue_script__ = __webpack_require__(75)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/views/SettingsView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(76)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./SettingsView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 74 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 75 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {};
	    }
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view settings-view\">\n    <div class=\"page\">\n        <h1 class=\"page-header\">Settings</h1>\n        <div class=\"page-content\">\n            Settings here\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(78)
	__vue_script__ = __webpack_require__(79)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/GcsIndicators.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(80)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./GcsIndicators.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 78 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    computed: {
	        heading: function heading() {
	            var deg = Math.round(this.wamv.heading);
	            return deg + '&deg; ' + this.degreeToToCardinal(this.wamv.heading);
	        },
	        speed: function speed() {
	            var spd = Math.round(this.wamv.speed * 100) / 100;
	            return this.wamv.speed + ' KMPH';
	        },
	        battery: function battery() {
	            var perc = Math.round(this.wamv.battery * 100) / 100;
	            return perc + '%';
	        },
	        signal: function signal() {
	            var perc = Math.round(this.wamv.signal * 100) / 100;
	            return perc + '%';
	        }
	    },
	
	    methods: {
	        degreeToToCardinal: function degreeToToCardinal(degree) {
	            if (degree < 22.5 || degree >= 337.5) {
	                return 'N';
	            }
	
	            if (degree < 67.5 || degree >= 22.5) {
	                return 'NE';
	            }
	
	            if (degree < 112.5 || degree >= 67.5) {
	                return 'E';
	            }
	
	            if (degree < 157.5 || degree >= 112.5) {
	                return 'SE';
	            }
	
	            if (degree < 202.5 || degree >= 157.5) {
	                return 'S';
	            }
	
	            if (degree < 247.5 || degree >= 202.5) {
	                return 'SW';
	            }
	
	            if (degree < 292.5 || degree >= 247.5) {
	                return 'W';
	            }
	
	            if (degree < 337.5 || degree >= 292.5) {
	                return 'NW';
	            }
	
	            return '';
	        }
	    }
	};

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "\n<ul class=\"gcs-indicators\" v-if=\"wamv.loaded\">\n    <li class=\"indicator heading\">\n        <ui-icon\n            icon=\"navigation\" :style=\"{ transform: 'rotateZ(' + wamv.heading + 'deg)' }\"\n        ></ui-icon>\n        <span class=\"value\" v-html=\"heading\"></span>\n    </li>\n\n    <li class=\"indicator speed\">\n        <ui-icon icon=\"network_check\"></ui-icon>\n        <span class=\"value\" v-text=\"speed\"></span>\n    </li>\n\n    <li class=\"indicator battery\">\n        <ui-icon icon=\"battery_full\"></ui-icon>\n        <span class=\"value\" v-text=\"battery\"></span>\n    </li>\n\n    <li class=\"indicator signal\">\n        <ui-icon icon=\"wifi\"></ui-icon>\n        <span class=\"value\" v-text=\"signal\"></span>\n    </li>\n</ul>\n";

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(82)
	__vue_script__ = __webpack_require__(83)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src/components/SocketIoManager.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(134)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "./SocketIoManager.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 82 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _socket = __webpack_require__(84);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            WAITING: _getters.getMessageStateWaiting,
	            SUCCESS: _getters.getMessageStateSuccess,
	            FAILURE: _getters.getMessageStateFailure,
	            getParameterState: _getters.getGetParameterState,
	            getParameterData: _getters.getGetParameterData,
	            saveMissionsState: _getters.getSaveMissionsState,
	            saveMissionsData: _getters.getSaveMissionsData,
	            loadMissionsState: _getters.getLoadMissionsState,
	            loadMissionsData: _getters.getLoadMissionsData,
	            uploadMissionState: _getters.getUploadMissionState,
	            uploadMissionData: _getters.getUploadMissionData,
	            downloadMissionState: _getters.getDownloadMissionState,
	            downloadMissionData: _getters.getDownloadMissionData,
	            startMissionState: _getters.getStartMissionState,
	            startMissionData: _getters.getStartMissionData,
	            stopMissionState: _getters.getStopMissionState,
	            stopMissionData: _getters.getStopMissionData,
	            resumeMissionState: _getters.getResumeMissionState,
	            resumeMissionData: _getters.getResumeMissionData,
	            armState: _getters.getArmState,
	            armData: _getters.getArmData,
	            disarmState: _getters.getDisarmState,
	            disarmData: _getters.getDisarmData,
	            killState: _getters.getKillState,
	            killData: _getters.getKillData,
	            unkillState: _getters.getUnkillState,
	            unkillData: _getters.getUnkillData
	        },
	        actions: {
	            setWamv: _actions.setWamv,
	            setParameters: _actions.setParameters,
	            sendGetParameters: _actions.sendGetParameters,
	            succeedGetParameters: _actions.succeedGetParameters,
	            failGetParameters: _actions.failGetParameters,
	            succeedLoadMissions: _actions.succeedLoadMissions,
	            sendLoadMissions: _actions.sendLoadMissions,
	            failLoadMissions: _actions.failLoadMissions,
	            succeedSaveMissions: _actions.succeedSaveMissions,
	            failSaveMissions: _actions.failSaveMissions,
	            succeedUploadMission: _actions.succeedUploadMission,
	            failUploadMission: _actions.failUploadMission,
	            succeedDownloadMission: _actions.succeedDownloadMission,
	            failDownloadMission: _actions.failDownloadMission,
	            succeedStartMission: _actions.succeedStartMission,
	            failStartMission: _actions.failStartMission,
	            succeedStopMission: _actions.succeedStopMission,
	            failStopMission: _actions.failStopMission,
	            succeedResumeMission: _actions.succeedResumeMission,
	            failResumeMission: _actions.failResumeMission,
	            succeedArm: _actions.succeedArm,
	            failArm: _actions.failArm,
	            succeedDisarm: _actions.succeedDisarm,
	            failDisarm: _actions.failDisarm,
	            succeedKill: _actions.succeedKill,
	            failKill: _actions.failKill,
	            succeedUnkill: _actions.succeedUnkill,
	            failUnkill: _actions.failUnkill
	        }
	    },
	
	    data: function data() {
	        return {
	            socket: null };
	    },
	    ready: function ready() {
	        var _this = this;
	
	        this.socket = (0, _socket2.default)('localhost:3000');
	        this.socket.on('connect', function () {
	            console.log('connected to server');
	
	            _this.sendGetParameters();
	            setTimeout(function () {
	                if (_this.getParameterState == _this.WAITING) {
	                    _this.failGetParameters('Timeout reached.');
	                }
	            }, 1000);
	
	            _this.sendLoadMissions();
	            setTimeout(function () {
	                if (_this.loadMissionsState == _this.WAITING) {
	                    _this.failLoadMissions('Timeout reached.');
	                }
	            }, 1000);
	        });
	        this.socket.on('disconnect', function () {
	            console.log('disconnected from server');
	        });
	        this.socket.on('status', function (data) {
	            data.loaded = true;
	            _this.setWamv(data);
	        });
	        this.socket.on('get_parameters', function (data) {
	            console.log('received "get_parameters" message');
	            if (_this.getParameterState == _this.WAITING) {
	                _this.succeedGetParameters(data);
	            }
	        });
	        this.socket.on('load_missions', function (data) {
	            console.log('received "load_missions" message');
	            if (_this.loadMissionsState == _this.WAITING) {
	                _this.succeedLoadMissions(data);
	            }
	        });
	        this.socket.on('download_mission', function (data) {
	            console.log('received "download_mission" message:');
	            if (_this.downloadMissionState == _this.WAITING) {
	                _this.succeedDownloadMission(data);
	            }
	        });
	        this.socket.on('success', function (data) {
	            console.log('received "success" message');
	            if (data == 'save_missions' && _this.saveMissionsState == _this.WAITING) {
	                _this.succeedSaveMissions();
	            } else if (data == 'upload_mission' && _this.uploadMissionState == _this.WAITING) {
	                _this.succeedUploadMission();
	            } else if (data == 'start_mission' && _this.startMissionState == _this.WAITING) {
	                _this.succeedStartMission();
	            } else if (data == 'stop_mission' && _this.stopMissionState == _this.WAITING) {
	                _this.succeedStopMission();
	            } else if (data == 'resume_mission' && _this.resumeMissionState == _this.WAITING) {
	                _this.succeedResumeMission();
	            } else if (data == 'arm' && _this.armState == _this.WAITING) {
	                _this.succeedArm();
	            } else if (data == 'disarm' && _this.disarmState == _this.WAITING) {
	                _this.succeedDisarm();
	            } else if (data == 'kill' && _this.killState == _this.WAITING) {
	                _this.succeedKill();
	            } else if (data == 'unkill' && _this.unkillState == _this.WAITING) {
	                _this.succeedUnkill();
	            }
	        });
	        this.socket.on('failure', function (data) {
	            console.log('received "failure" message');
	            switch (data[0]) {
	                case 'get_parameters':
	                    {
	                        _this.failGetParameters(data[1]);
	                        break;
	                    }
	                case 'save_missions':
	                    {
	                        _this.failSaveMissions(data[1]);
	                        break;
	                    }
	                case 'load_missions':
	                    {
	                        _this.failLoadMissions(data[1]);
	                        break;
	                    }
	                case 'upload_mission':
	                    {
	                        _this.failUploadMission(data[1]);
	                        break;
	                    }
	                case 'download_mission':
	                    {
	                        _this.failDownloadMission(data[1]);
	                        break;
	                    }
	                case 'start_mission':
	                    {
	                        _this.failStartMission(data[1]);
	                        break;
	                    }
	                case 'stop_mission':
	                    {
	                        _this.failStopMission(data[1]);
	                        break;
	                    }
	                case 'resume_mission':
	                    {
	                        _this.failResumeMission(data[1]);
	                        break;
	                    }
	                case 'arm':
	                    {
	                        _this.failArm(data[1]);
	                        break;
	                    }
	                case 'disarm':
	                    {
	                        _this.failDisarm(data[1]);
	                        break;
	                    }
	                case 'kill':
	                    {
	                        _this.failKill(data[1]);
	                        break;
	                    }
	                case 'unkill':
	                    {
	                        _this.failUnkill(data[1]);
	                        break;
	                    }
	            }
	        });
	        this.socket.on('attention', function (data) {
	            console.log('Attention: ' + data);
	        });
	    },
	
	
	    watch: {
	        getParameterState: function getParameterState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('get_parameters');
	                } else if (state == this.SUCCESS) {
	                    this.setParameters(this.getParameterData);
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to get parameters: ' + this.getParameterData);
	                }
	            }
	        },
	        saveMissionsState: function saveMissionsState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('save_missions', this.saveMissionsData);
	                }
	            }
	        },
	        loadMissionsState: function loadMissionsState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('load_missions');
	                }
	            }
	        },
	        uploadMissionState: function uploadMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('upload_mission', this.uploadMissionData);
	                }
	            }
	        },
	        downloadMissionState: function downloadMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('download_mission');
	                }
	            }
	        },
	        startMissionState: function startMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('start_mission');
	                }
	            }
	        },
	        stopMissionState: function stopMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('stop_mission');
	                }
	            }
	        },
	        resumeMissionState: function resumeMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('resume_mission');
	                }
	            }
	        },
	        armState: function armState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('arm');
	                }
	            }
	        },
	        disarmState: function disarmState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('disarm');
	                }
	            }
	        },
	        killState: function killState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('kill');
	                }
	            }
	        },
	        unkillState: function unkillState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.WAITING) {
	                    this.socket.emit('unkill');
	                }
	            }
	        }
	    }
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(85);
	var parser = __webpack_require__(90);
	var Manager = __webpack_require__(98);
	var debug = __webpack_require__(87)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] ||
	                      false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(98);
	exports.Socket = __webpack_require__(126);


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(86);
	var debug = __webpack_require__(87)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc){
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
	
	  return obj;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(88);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(89);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(87)('socket.io-parser');
	var json = __webpack_require__(91);
	var isArray = __webpack_require__(94);
	var Emitter = __webpack_require__(95);
	var binary = __webpack_require__(96);
	var isBuf = __webpack_require__(97);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(93);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)(module), (function() { return this; }())))

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 93 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 95 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(94);
	var isBuf = __webpack_require__(97);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 97 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(99);
	var Socket = __webpack_require__(126);
	var Emitter = __webpack_require__(127);
	var parser = __webpack_require__(90);
	var on = __webpack_require__(129);
	var bind = __webpack_require__(130);
	var debug = __webpack_require__(87)('socket.io-client:manager');
	var indexOf = __webpack_require__(124);
	var Backoff = __webpack_require__(133);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function(){
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function(){
	  this.lastPing = new Date;
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function(){
	  this.emitAll('pong', new Date - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function(){
	  debug('cleanup');
	
	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();
	
	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' == this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function(reason){
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(100);


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(101);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(108);


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(102);
	var Emitter = __webpack_require__(117);
	var debug = __webpack_require__(87)('engine.io-client:socket');
	var index = __webpack_require__(124);
	var parser = __webpack_require__(108);
	var parseuri = __webpack_require__(86);
	var parsejson = __webpack_require__(125);
	var parseqs = __webpack_require__(118);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop(){}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(107);
	Socket.transports = __webpack_require__(102);
	Socket.parser = __webpack_require__(108);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose(){
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function(){
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function() {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(103);
	var XHR = __webpack_require__(105);
	var JSONP = __webpack_require__(121);
	var websocket = __webpack_require__(122);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(104);
	
	module.exports = function(opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }
	
	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 104 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(103);
	var Polling = __webpack_require__(106);
	var Emitter = __webpack_require__(117);
	var inherit = __webpack_require__(119);
	var debug = __webpack_require__(87)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty(){}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts){
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }
	
	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function(){
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(107);
	var parseqs = __webpack_require__(118);
	var parser = __webpack_require__(108);
	var inherit = __webpack_require__(119);
	var yeast = __webpack_require__(120);
	var debug = __webpack_require__(87)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(103);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function(){
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function(){
	  var self = this;
	
	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(108);
	var Emitter = __webpack_require__(117);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(109);
	var hasBinary = __webpack_require__(110);
	var sliceBuffer = __webpack_require__(112);
	var base64encoder = __webpack_require__(113);
	var after = __webpack_require__(114);
	var utf8 = __webpack_require__(115);
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = navigator.userAgent.match(/Android/i);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(116);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if(numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 109 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(111);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 112 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
	
	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 113 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = after
	
	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count
	
	    return (count === 0) ? callback() : proxy
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}
	
	function noop() {}


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)(module), (function() { return this; }())))

/***/ },
/* 116 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      ary[i] = buf;
	    }
	  }
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);
	
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};
	
	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 117 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 119 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 120 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;
	
	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(106);
	var inherit = __webpack_require__(119);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  }
	  else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch(e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(107);
	var parser = __webpack_require__(108);
	var parseqs = __webpack_require__(118);
	var inherit = __webpack_require__(119);
	var yeast = __webpack_require__(120);
	var debug = __webpack_require__(87)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(123);
	  } catch (e) { }
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	
	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function(){
	  var self = this;
	
	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function(packet) {
	      parser.encodePacket(packet, self.supportsBinary, function(data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e){
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done(){
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function(){
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 124 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 125 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(90);
	var Emitter = __webpack_require__(127);
	var toArray = __webpack_require__(128);
	var on = __webpack_require__(129);
	var bind = __webpack_require__(130);
	var debug = __webpack_require__(87)('socket.io-client:socket');
	var hasBin = __webpack_require__(131);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function() {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  delete this.flags;
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function(packet){
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function(compress){
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};


/***/ },
/* 127 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = toArray
	
	function toArray(list, index) {
	    var array = []
	
	    index = index || 0
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }
	
	    return array
	}


/***/ },
/* 129 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(132);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 133 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "\n<div></div>\n";

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-app\">\n    <ui-tabs\n        class=\"main-tab-container\" background-color=\"dark\" text-color=\"light\"\n        indicator-color=\"transparent\"\n    >\n        <ui-tab header=\"Map\">\n            <map-view></map-view>\n        </ui-tab>\n\n        <ui-tab header=\"Params\">\n            <params-view></params-view>\n        </ui-tab>\n\n        <ui-tab header=\"Settings\">\n            <settings-view></settings-view>\n        </ui-tab>\n    </ui-tabs>\n\n    <gcs-indicators></gcs-indicators>\n\n    <ui-snackbar-container position=\"center\"></ui-snackbar-container>\n</div>\n<socket-io-manager></socket-io-manager>\n";

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vuex = __webpack_require__(137);
	
	var _vuex2 = _interopRequireDefault(_vuex);
	
	var _config = __webpack_require__(138);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vuex2.default);
	
	var initialState = {
	    map: null,
	    mapEl: null,
	    mapLoaded: false,
	    mapEditing: false,
	    wamv: {
	        loaded: false,
	        position: { lat: -32.8883338, lng: 151.7075279 },
	        heading: 0,
	        speed: 0,
	        battery: 100,
	        armed: false,
	        mode: 'idle',
	        signal: 100
	    },
	    config: _config2.default,
	    settings: _config2.default.settings,
	    settingsLoaded: false,
	    missions: [],
	    currentMissionIndex: -1,
	    parameters: {},
	    messageState: {
	        INITIAL: 0,
	        WAITING: 1,
	        SUCCESS: 2,
	        FAILURE: 3,
	
	        get_parameters: [0, null],
	        set_parameter: [0, null],
	        save_missions: [0, null],
	        load_missions: [0, null],
	        upload_mission: [0, null],
	        download_mission: [0, null],
	        arm: [0, null],
	        disarm: [0, null],
	        start_mission: [0, null],
	        stop_mission: [0, null],
	        resume_mission: [0, null],
	        kill: [0, null],
	        unkill: [0, null]
	    }
	};
	
	var mutations = {
	    SET_MAP: function SET_MAP(state, map) {
	        state.map = map;
	    },
	    SET_MAP_EL: function SET_MAP_EL(state, mapEl) {
	        state.mapEl = mapEl;
	    },
	    SET_MAP_LOADED: function SET_MAP_LOADED(state, loaded) {
	        state.mapLoaded = loaded;
	    },
	    SET_MAP_EDITING: function SET_MAP_EDITING(state, editing) {
	        state.mapEditing = editing;
	    },
	    UPDATE_WAMV_POSITION: function UPDATE_WAMV_POSITION(state, position) {
	        state.wamv.position = position;
	    },
	    SET_WAMV: function SET_WAMV(state, wamv) {
	        state.wamv = wamv;
	    },
	    SET_WAMV_ARMED: function SET_WAMV_ARMED(state, armed) {
	        state.wamv.armed = armed;
	    },
	    SET_WAMV_MODE: function SET_WAMV_MODE(state, mode) {
	        state.wamv.mode = mode;
	    },
	    INIT_SETTINGS: function INIT_SETTINGS(state, settings) {
	        state.settings = settings;
	        state.settingsLoaded = true;
	    },
	    UPDATE_SETTINGS: function UPDATE_SETTINGS(state, settings) {
	        state.settings = settings;
	    },
	    SET_MISSIONS: function SET_MISSIONS(state, missions) {
	        state.missions = missions;
	    },
	    SET_CURRENT_MISSION_INDEX: function SET_CURRENT_MISSION_INDEX(state, index) {
	        state.currentMissionIndex = index;
	    },
	    SET_CURRENT_MISSION: function SET_CURRENT_MISSION(state, mission) {
	        state.missions.$set(state.currentMissionIndex, mission);
	    },
	    SET_PARAMETERS: function SET_PARAMETERS(state, parameters) {
	        state.parameters = parameters;
	    },
	    SEND_GET_PARAMETERS: function SEND_GET_PARAMETERS(state) {
	        state.messageState.get_parameters.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_GET_PARAMETERS: function SUCCEED_GET_PARAMETERS(state, parameters) {
	        state.messageState.get_parameters.$set(0, state.messageState.SUCCESS);
	        state.messageState.get_parameters.$set(1, parameters);
	    },
	    FAIL_GET_PARAMETERS: function FAIL_GET_PARAMETERS(state, msg) {
	        state.messageState.get_parameters.$set(0, state.messageState.FAILURE);
	        state.messageState.get_parameters.$set(1, msg);
	    },
	    SEND_SAVE_MISSIONS: function SEND_SAVE_MISSIONS(state, missions) {
	        state.messageState.save_missions.$set(0, state.messageState.WAITING);
	        state.messageState.save_missions.$set(1, missions);
	    },
	    SUCCEED_SAVE_MISSIONS: function SUCCEED_SAVE_MISSIONS(state) {
	        state.messageState.save_missions.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_SAVE_MISSIONS: function FAIL_SAVE_MISSIONS(state, msg) {
	        state.messageState.save_missions.$set(0, state.messageState.FAILURE);
	        state.messageState.save_missions.$set(1, msg);
	    },
	    SEND_LOAD_MISSIONS: function SEND_LOAD_MISSIONS(state) {
	        state.messageState.load_missions.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_LOAD_MISSIONS: function SUCCEED_LOAD_MISSIONS(state, missions) {
	        state.messageState.load_missions.$set(0, state.messageState.SUCCESS);
	        state.messageState.load_missions.$set(1, missions);
	    },
	    FAIL_LOAD_MISSIONS: function FAIL_LOAD_MISSIONS(state, msg) {
	        state.messageState.load_missions.$set(0, state.messageState.FAILURE);
	        state.messageState.load_missions.$set(1, msg);
	    },
	    SEND_UPLOAD_MISSION: function SEND_UPLOAD_MISSION(state, mission) {
	        state.messageState.upload_mission.$set(0, state.messageState.WAITING);
	        state.messageState.upload_mission.$set(1, mission);
	    },
	    SUCCEED_UPLOAD_MISSION: function SUCCEED_UPLOAD_MISSION(state) {
	        state.messageState.upload_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_UPLOAD_MISSION: function FAIL_UPLOAD_MISSION(state, msg) {
	        state.messageState.upload_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.upload_mission.$set(1, msg);
	    },
	    SEND_DOWNLOAD_MISSION: function SEND_DOWNLOAD_MISSION(state) {
	        state.messageState.download_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_DOWNLOAD_MISSION: function SUCCEED_DOWNLOAD_MISSION(state, mission) {
	        state.messageState.download_mission.$set(0, state.messageState.SUCCESS);
	        state.messageState.download_mission.$set(1, mission);
	    },
	    FAIL_DOWNLOAD_MISSION: function FAIL_DOWNLOAD_MISSION(state, msg) {
	        state.messageState.download_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.download_mission.$set(1, msg);
	    },
	    SEND_START_MISSION: function SEND_START_MISSION(state) {
	        state.messageState.start_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_START_MISSION: function SUCCEED_START_MISSION(state) {
	        state.messageState.start_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_START_MISSION: function FAIL_START_MISSION(state, msg) {
	        state.messageState.start_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.start_mission.$set(1, msg);
	    },
	    SEND_STOP_MISSION: function SEND_STOP_MISSION(state) {
	        state.messageState.stop_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_STOP_MISSION: function SUCCEED_STOP_MISSION(state) {
	        state.messageState.stop_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_STOP_MISSION: function FAIL_STOP_MISSION(state, msg) {
	        state.messageState.stop_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.stop_mission.$set(1, msg);
	    },
	    SEND_RESUME_MISSION: function SEND_RESUME_MISSION(state) {
	        state.messageState.resume_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_RESUME_MISSION: function SUCCEED_RESUME_MISSION(state) {
	        state.messageState.resume_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_RESUME_MISSION: function FAIL_RESUME_MISSION(state, msg) {
	        state.messageState.resume_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.resume_mission.$set(1, msg);
	    },
	    SEND_ARM: function SEND_ARM(state) {
	        state.messageState.arm.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_ARM: function SUCCEED_ARM(state) {
	        state.messageState.arm.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_ARM: function FAIL_ARM(state, msg) {
	        state.messageState.arm.$set(0, state.messageState.FAILURE);
	        state.messageState.arm.$set(1, msg);
	    },
	    SEND_DISARM: function SEND_DISARM(state) {
	        state.messageState.disarm.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_DISARM: function SUCCEED_DISARM(state) {
	        state.messageState.disarm.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_DISARM: function FAIL_DISARM(state, msg) {
	        state.messageState.disarm.$set(0, state.messageState.FAILURE);
	        state.messageState.disarm.$set(1, msg);
	    },
	    SEND_KILL: function SEND_KILL(state) {
	        state.messageState.kill.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_KILL: function SUCCEED_KILL(state) {
	        state.messageState.kill.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_KILL: function FAIL_KILL(state, msg) {
	        state.messageState.kill.$set(0, state.messageState.FAILURE);
	        state.messageState.kill.$set(1, msg);
	    },
	    SEND_UNKILL: function SEND_UNKILL(state) {
	        state.messageState.unkill.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_UNKILL: function SUCCEED_UNKILL(state) {
	        state.messageState.unkill.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_UNKILL: function FAIL_UNKILL(state, msg) {
	        state.messageState.unkill.$set(0, state.messageState.FAILURE);
	        state.messageState.unkill.$set(1, msg);
	    }
	};
	
	exports.default = new _vuex2.default.Store({
	    state: initialState,
	    mutations: mutations
	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Vuex v1.0.0-rc.2
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Vuex = factory());
	}(this, function () { 'use strict';
	
	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
	  };
	
	  var classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  };
	
	  var createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }
	
	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();
	
	  var toConsumableArray = function (arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
	
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  };
	
	  /**
	   * Merge an array of objects into one.
	   *
	   * @param {Array<Object>} arr
	   * @return {Object}
	   */
	
	  function mergeObjects(arr) {
	    return arr.reduce(function (prev, obj) {
	      Object.keys(obj).forEach(function (key) {
	        var existing = prev[key];
	        if (existing) {
	          // allow multiple mutation objects to contain duplicate
	          // handlers for the same mutation type
	          if (Array.isArray(existing)) {
	            prev[key] = existing.concat(obj[key]);
	          } else {
	            prev[key] = [existing].concat(obj[key]);
	          }
	        } else {
	          prev[key] = obj[key];
	        }
	      });
	      return prev;
	    }, {});
	  }
	
	  /**
	   * Check whether the given value is Object or not
	   *
	   * @param {*} obj
	   * @return {Boolean}
	   */
	
	  function isObject(obj) {
	    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	  }
	
	  /**
	   * Get state sub tree by given keys.
	   *
	   * @param {Object} state
	   * @param {Array<String>} nestedKeys
	   * @return {Object}
	   */
	  function getNestedState(state, nestedKeys) {
	    return nestedKeys.reduce(function (state, key) {
	      return state[key];
	    }, state);
	  }
	
	  /**
	   * Hacks to get access to Vue internals.
	   * Maybe we should expose these...
	   */
	
	  var Watcher = void 0;
	  function getWatcher(vm) {
	    if (!Watcher) {
	      var noop = function noop() {};
	      var unwatch = vm.$watch(noop, noop);
	      Watcher = vm._watchers[0].constructor;
	      unwatch();
	    }
	    return Watcher;
	  }
	
	  var Dep = void 0;
	  function getDep(vm) {
	    if (!Dep) {
	      Dep = vm._data.__ob__.dep.constructor;
	    }
	    return Dep;
	  }
	
	  var hook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	  function devtoolPlugin(store) {
	    if (!hook) return;
	
	    hook.emit('vuex:init', store);
	
	    hook.on('vuex:travel-to-state', function (targetState) {
	      store.replaceState(targetState);
	    });
	
	    store.subscribe(function (mutation, state) {
	      hook.emit('vuex:mutation', mutation, state);
	    });
	  }
	
	  function override (Vue) {
	    var version = Number(Vue.version.split('.')[0]);
	
	    if (version >= 2) {
	      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
	      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
	    } else {
	      (function () {
	        // override init and inject vuex init procedure
	        // for 1.x backwards compatibility.
	        var _init = Vue.prototype._init;
	        Vue.prototype._init = function () {
	          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	          options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
	          _init.call(this, options);
	        };
	      })();
	    }
	
	    /**
	     * Vuex init hook, injected into each instances init hooks list.
	     */
	
	    function vuexInit() {
	      var options = this.$options;
	      var store = options.store;
	      var vuex = options.vuex;
	      // store injection
	
	      if (store) {
	        this.$store = store;
	      } else if (options.parent && options.parent.$store) {
	        this.$store = options.parent.$store;
	      }
	      // vuex option handling
	      if (vuex) {
	        if (!this.$store) {
	          console.warn('[vuex] store not injected. make sure to ' + 'provide the store option in your root component.');
	        }
	        var state = vuex.state;
	        var actions = vuex.actions;
	        var getters = vuex.getters;
	        // handle deprecated state option
	
	        if (state && !getters) {
	          console.warn('[vuex] vuex.state option will been deprecated in 1.0. ' + 'Use vuex.getters instead.');
	          getters = state;
	        }
	        // getters
	        if (getters) {
	          options.computed = options.computed || {};
	          for (var key in getters) {
	            defineVuexGetter(this, key, getters[key]);
	          }
	        }
	        // actions
	        if (actions) {
	          options.methods = options.methods || {};
	          for (var _key in actions) {
	            options.methods[_key] = makeBoundAction(this.$store, actions[_key], _key);
	          }
	        }
	      }
	    }
	
	    /**
	     * Setter for all getter properties.
	     */
	
	    function setter() {
	      throw new Error('vuex getter properties are read-only.');
	    }
	
	    /**
	     * Define a Vuex getter on an instance.
	     *
	     * @param {Vue} vm
	     * @param {String} key
	     * @param {Function} getter
	     */
	
	    function defineVuexGetter(vm, key, getter) {
	      if (typeof getter !== 'function') {
	        console.warn('[vuex] Getter bound to key \'vuex.getters.' + key + '\' is not a function.');
	      } else {
	        Object.defineProperty(vm, key, {
	          enumerable: true,
	          configurable: true,
	          get: makeComputedGetter(vm.$store, getter),
	          set: setter
	        });
	      }
	    }
	
	    /**
	     * Make a computed getter, using the same caching mechanism of computed
	     * properties. In addition, it is cached on the raw getter function using
	     * the store's unique cache id. This makes the same getter shared
	     * across all components use the same underlying watcher, and makes
	     * the getter evaluated only once during every flush.
	     *
	     * @param {Store} store
	     * @param {Function} getter
	     */
	
	    function makeComputedGetter(store, getter) {
	      var id = store._getterCacheId;
	
	      // cached
	      if (getter[id]) {
	        return getter[id];
	      }
	      var vm = store._vm;
	      var Watcher = getWatcher(vm);
	      var Dep = getDep(vm);
	      var watcher = new Watcher(vm, function (vm) {
	        return getter(vm.state);
	      }, null, { lazy: true });
	      var computedGetter = function computedGetter() {
	        if (watcher.dirty) {
	          watcher.evaluate();
	        }
	        if (Dep.target) {
	          watcher.depend();
	        }
	        return watcher.value;
	      };
	      getter[id] = computedGetter;
	      return computedGetter;
	    }
	
	    /**
	     * Make a bound-to-store version of a raw action function.
	     *
	     * @param {Store} store
	     * @param {Function} action
	     * @param {String} key
	     */
	
	    function makeBoundAction(store, action, key) {
	      if (typeof action !== 'function') {
	        console.warn('[vuex] Action bound to key \'vuex.actions.' + key + '\' is not a function.');
	      }
	      return function vuexBoundAction() {
	        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
	          args[_key2] = arguments[_key2];
	        }
	
	        return action.call.apply(action, [this, store].concat(args));
	      };
	    }
	
	    // option merging
	    var merge = Vue.config.optionMergeStrategies.computed;
	    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
	      if (!toVal) return fromVal;
	      if (!fromVal) return toVal;
	      return {
	        getters: merge(toVal.getters, fromVal.getters),
	        state: merge(toVal.state, fromVal.state),
	        actions: merge(toVal.actions, fromVal.actions)
	      };
	    };
	  }
	
	  var Vue = void 0;
	  var uid = 0;
	
	  var Store = function () {
	
	    /**
	     * @param {Object} options
	     *        - {Object} state
	     *        - {Object} actions
	     *        - {Object} mutations
	     *        - {Array} plugins
	     *        - {Boolean} strict
	     */
	
	    function Store() {
	      var _this = this;
	
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$state = _ref.state;
	      var state = _ref$state === undefined ? {} : _ref$state;
	      var _ref$mutations = _ref.mutations;
	      var mutations = _ref$mutations === undefined ? {} : _ref$mutations;
	      var _ref$modules = _ref.modules;
	      var modules = _ref$modules === undefined ? {} : _ref$modules;
	      var _ref$plugins = _ref.plugins;
	      var plugins = _ref$plugins === undefined ? [] : _ref$plugins;
	      var _ref$strict = _ref.strict;
	      var strict = _ref$strict === undefined ? false : _ref$strict;
	      classCallCheck(this, Store);
	
	      this._getterCacheId = 'vuex_store_' + uid++;
	      this._dispatching = false;
	      this._rootMutations = this._mutations = mutations;
	      this._modules = modules;
	      this._subscribers = [];
	      // bind dispatch to self
	      var dispatch = this.dispatch;
	      this.dispatch = function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	
	        dispatch.apply(_this, args);
	      };
	      // use a Vue instance to store the state tree
	      // suppress warnings just in case the user has added
	      // some funky global mixins
	      if (!Vue) {
	        throw new Error('[vuex] must call Vue.use(Vuex) before creating a store instance.');
	      }
	      var silent = Vue.config.silent;
	      Vue.config.silent = true;
	      this._vm = new Vue({
	        data: {
	          state: state
	        }
	      });
	      Vue.config.silent = silent;
	      this._setupModuleState(state, modules);
	      this._setupModuleMutations(modules);
	      // add extra warnings in strict mode
	      if (strict) {
	        this._setupMutationCheck();
	      }
	      // apply plugins
	      devtoolPlugin(this);
	      plugins.forEach(function (plugin) {
	        return plugin(_this);
	      });
	    }
	
	    /**
	     * Getter for the entire state tree.
	     * Read only.
	     *
	     * @return {Object}
	     */
	
	    createClass(Store, [{
	      key: 'replaceState',
	
	
	      /**
	       * Replace root state.
	       *
	       * @param {Object} state
	       */
	
	      value: function replaceState(state) {
	        this._dispatching = true;
	        this._vm.state = state;
	        this._dispatching = false;
	      }
	
	      /**
	       * Dispatch an action.
	       *
	       * @param {String} type
	       */
	
	    }, {
	      key: 'dispatch',
	      value: function dispatch(type) {
	        var _this2 = this;
	
	        for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          payload[_key2 - 1] = arguments[_key2];
	        }
	
	        var silent = false;
	        var isObjectStyleDispatch = false;
	        // compatibility for object actions, e.g. FSA
	        if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type.type && arguments.length === 1) {
	          isObjectStyleDispatch = true;
	          payload = type;
	          if (type.silent) silent = true;
	          type = type.type;
	        }
	        var handler = this._mutations[type];
	        var state = this.state;
	        if (handler) {
	          this._dispatching = true;
	          // apply the mutation
	          if (Array.isArray(handler)) {
	            handler.forEach(function (h) {
	              isObjectStyleDispatch ? h(state, payload) : h.apply(undefined, [state].concat(toConsumableArray(payload)));
	            });
	          } else {
	            isObjectStyleDispatch ? handler(state, payload) : handler.apply(undefined, [state].concat(toConsumableArray(payload)));
	          }
	          this._dispatching = false;
	          if (!silent) {
	            (function () {
	              var mutation = isObjectStyleDispatch ? payload : { type: type, payload: payload };
	              _this2._subscribers.forEach(function (sub) {
	                return sub(mutation, state);
	              });
	            })();
	          }
	        } else {
	          console.warn('[vuex] Unknown mutation: ' + type);
	        }
	      }
	
	      /**
	       * Watch state changes on the store.
	       * Same API as Vue's $watch, except when watching a function,
	       * the function gets the state as the first argument.
	       *
	       * @param {Function} fn
	       * @param {Function} cb
	       * @param {Object} [options]
	       */
	
	    }, {
	      key: 'watch',
	      value: function watch(fn, cb, options) {
	        var _this3 = this;
	
	        if (typeof fn !== 'function') {
	          console.error('Vuex store.watch only accepts function.');
	          return;
	        }
	        return this._vm.$watch(function () {
	          return fn(_this3.state);
	        }, cb, options);
	      }
	
	      /**
	       * Subscribe to state changes. Fires after every mutation.
	       */
	
	    }, {
	      key: 'subscribe',
	      value: function subscribe(fn) {
	        var subs = this._subscribers;
	        if (subs.indexOf(fn) < 0) {
	          subs.push(fn);
	        }
	        return function () {
	          var i = subs.indexOf(fn);
	          if (i > -1) {
	            subs.splice(i, 1);
	          }
	        };
	      }
	
	      /**
	       * Hot update mutations & modules.
	       *
	       * @param {Object} options
	       *        - {Object} [mutations]
	       *        - {Object} [modules]
	       */
	
	    }, {
	      key: 'hotUpdate',
	      value: function hotUpdate() {
	        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	        var mutations = _ref2.mutations;
	        var modules = _ref2.modules;
	
	        this._rootMutations = this._mutations = mutations || this._rootMutations;
	        this._setupModuleMutations(modules || this._modules);
	      }
	
	      /**
	       * Attach sub state tree of each module to the root tree.
	       *
	       * @param {Object} state
	       * @param {Object} modules
	       */
	
	    }, {
	      key: '_setupModuleState',
	      value: function _setupModuleState(state, modules) {
	        var _this4 = this;
	
	        if (!isObject(modules)) return;
	
	        Object.keys(modules).forEach(function (key) {
	          var module = modules[key];
	
	          // set this module's state
	          Vue.set(state, key, module.state || {});
	
	          // retrieve nested modules
	          _this4._setupModuleState(state[key], module.modules);
	        });
	      }
	
	      /**
	       * Bind mutations for each module to its sub tree and
	       * merge them all into one final mutations map.
	       *
	       * @param {Object} updatedModules
	       */
	
	    }, {
	      key: '_setupModuleMutations',
	      value: function _setupModuleMutations(updatedModules) {
	        var modules = this._modules;
	        Object.keys(updatedModules).forEach(function (key) {
	          modules[key] = updatedModules[key];
	        });
	        var updatedMutations = this._createModuleMutations(modules, []);
	        this._mutations = mergeObjects([this._rootMutations].concat(toConsumableArray(updatedMutations)));
	      }
	
	      /**
	       * Helper method for _setupModuleMutations.
	       * The method retrieve nested sub modules and
	       * bind each mutations to its sub tree recursively.
	       *
	       * @param {Object} modules
	       * @param {Array<String>} nestedKeys
	       * @return {Array<Object>}
	       */
	
	    }, {
	      key: '_createModuleMutations',
	      value: function _createModuleMutations(modules, nestedKeys) {
	        var _this5 = this;
	
	        if (!isObject(modules)) return [];
	
	        return Object.keys(modules).map(function (key) {
	          var module = modules[key];
	          var newNestedKeys = nestedKeys.concat(key);
	
	          // retrieve nested modules
	          var nestedMutations = _this5._createModuleMutations(module.modules, newNestedKeys);
	
	          if (!module || !module.mutations) {
	            return mergeObjects(nestedMutations);
	          }
	
	          // bind mutations to sub state tree
	          var mutations = {};
	          Object.keys(module.mutations).forEach(function (name) {
	            var original = module.mutations[name];
	            mutations[name] = function (state) {
	              for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	                args[_key3 - 1] = arguments[_key3];
	              }
	
	              original.apply(undefined, [getNestedState(state, newNestedKeys)].concat(args));
	            };
	          });
	
	          // merge mutations of this module and nested modules
	          return mergeObjects([mutations].concat(toConsumableArray(nestedMutations)));
	        });
	      }
	
	      /**
	       * Setup mutation check: if the vuex instance's state is mutated
	       * outside of a mutation handler, we throw en error. This effectively
	       * enforces all mutations to the state to be trackable and hot-reloadble.
	       * However, this comes at a run time cost since we are doing a deep
	       * watch on the entire state tree, so it is only enalbed with the
	       * strict option is set to true.
	       */
	
	    }, {
	      key: '_setupMutationCheck',
	      value: function _setupMutationCheck() {
	        var _this6 = this;
	
	        var Watcher = getWatcher(this._vm);
	        /* eslint-disable no-new */
	        new Watcher(this._vm, 'state', function () {
	          if (!_this6._dispatching) {
	            throw new Error('[vuex] Do not mutate vuex store state outside mutation handlers.');
	          }
	        }, { deep: true, sync: true });
	        /* eslint-enable no-new */
	      }
	    }, {
	      key: 'state',
	      get: function get() {
	        return this._vm.state;
	      },
	      set: function set(v) {
	        throw new Error('[vuex] Use store.replaceState() to explicit replace store state.');
	      }
	    }]);
	    return Store;
	  }();
	
	  function install(_Vue) {
	    if (Vue) {
	      console.warn('[vuex] already installed. Vue.use(Vuex) should be called only once.');
	      return;
	    }
	    Vue = _Vue;
	    override(Vue);
	  }
	
	  // auto install in dist mode
	  if (typeof window !== 'undefined' && window.Vue) {
	    install(window.Vue);
	  }
	
	  var index = {
	    Store: Store,
	    install: install
	  };
	
	  return index;
	
	}));

/***/ },
/* 138 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    googleMaps: {
	        key: 'AIzaSyABnCcekyPecGnsA1Rj_NdWjmUafJ1yVqA',
	        v: 3
	    },
	    map: {
	        center: {
	            lat: 21.308731,
	            lng: -157.888815
	        },
	        zoom: 19,
	        disableDefaultUI: true,
	        disableDoubleClickZoom: true,
	        tilt: 0
	    },
	    settings: {
	        defaultMapType: 'SATELLITE'
	    }
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDkxY2Y1NDU2NjA3YTRkNzEzODciLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUvZGlzdC92dWUuY29tbW9uLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2tlZW4tdWkvZGlzdC9rZWVuLXVpLmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlPzk2MDUiLCJ3ZWJwYWNrOi8vL0FwcC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWU/NzlkNSIsIndlYnBhY2s6Ly8vTWFwVmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcC52dWU/MzVjNCIsIndlYnBhY2s6Ly8vR2NzTWFwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9jb3B5LW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2FkLWdvb2dsZS1tYXBzLWFwaS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL2FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWVwLWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlZXAtYXNzaWduL34vaXMtb2JqL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zdG9yZS9nZXR0ZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXAudnVlPzJjMmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcENvbnRyb2xzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlPzBjZGQiLCJ3ZWJwYWNrOi8vL0djc01hcENvbnRyb2xzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlPzIyMDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBTaWRlYmFyLnZ1ZT81OTM3Iiwid2VicGFjazovLy9HY3NNYXBTaWRlYmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25zLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25zLnZ1ZT8yZDI4Iiwid2VicGFjazovLy9HY3NNaXNzaW9ucy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb24udnVlP2VkMzQiLCJ3ZWJwYWNrOi8vL0djc01pc3Npb24udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnQudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnQudnVlP2IwYjIiLCJ3ZWJwYWNrOi8vL0djc1dheXBvaW50LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvbWl4aW5zL2lzLW1hcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9lbGVtZW50LXNjcm9sbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50LnZ1ZT8zMmYxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50TGluay52dWU/OGUwZCIsIndlYnBhY2s6Ly8vR2NzV2F5cG9pbnRMaW5rLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50TGluay52dWU/NDJhOSIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9udW1iZXItdG8tbGV0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWU/OWZkOCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25Sb3cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWU/OTE1YyIsIndlYnBhY2s6Ly8vR2NzTWlzc2lvblJvdy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZT81YTBjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbnMudnVlPzRhZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlPzY5ZjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc1NpZGViYXJDb250cm9scy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc1NpZGViYXJDb250cm9scy52dWU/N2ZjZiIsIndlYnBhY2s6Ly8vR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWU/ZmMxMyIsIndlYnBhY2s6Ly8vR2NzQ29tbWFuZHMudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWU/MjZmOSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZT83M2RjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2Ftdi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZT9kMGIwIiwid2VicGFjazovLy9HY3NXYW12LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dhbXYudnVlPzY2NTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWU/MDQxMCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZT9mNTY2Iiwid2VicGFjazovLy9QYXJhbXNWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZT9iYWM5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZT9lODE5Iiwid2VicGFjazovLy9TZXR0aW5nc1ZpZXcudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWU/NjY2MCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZT85ZGE1Iiwid2VicGFjazovLy9HY3NJbmRpY2F0b3JzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZT84YmYyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU29ja2V0SW9NYW5hZ2VyLnZ1ZT83NTcyIiwid2VicGFjazovLy9Tb2NrZXRJb01hbmFnZXIudnVlIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZGVidWcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9kZWJ1Zy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9kZWJ1Zy9+L21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9+L2pzb24zL2xpYi9qc29uMy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2hhcy1jb3JzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2hhcy1iaW5hcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL34vYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L3V0ZjgvdXRmOC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2Jsb2IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9wYXJzZXFzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34veWVhc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy93cyAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vcGFyc2Vqc29uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L3RvLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vaGFzLWJpbmFyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9iYWNrbzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU29ja2V0SW9NYW5hZ2VyLnZ1ZT9lOGQzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlP2Q4MTgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL3N0b3JlLmpzIiwid2VicGFjazovLy8uL34vdnVleC9kaXN0L3Z1ZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy5qcyJdLCJuYW1lcyI6WyJ1c2UiLCJhcHAiLCJlbCIsImNvbXBvbmVudHMiLCJBcHAiLCJzdG9yZSIsIndpbmRvdyIsIm9iamVjdCIsIkpTT04iLCJwYXJzZSIsInNldE1hcCIsInNldE1hcEVsIiwic2V0TWFwTG9hZGVkIiwic2V0TWFwRWRpdGluZyIsInNldFdhbXYiLCJzZXRXYW12QXJtZWQiLCJzZXRXYW12TW9kZSIsImluaXRTZXR0aW5ncyIsInVwZGF0ZVNldHRpbmciLCJzZXRNaXNzaW9ucyIsInNldEN1cnJlbnRNaXNzaW9uSW5kZXgiLCJzZXRDdXJyZW50TWlzc2lvbiIsInNldFBhcmFtZXRlcnMiLCJzZW5kR2V0UGFyYW1ldGVycyIsInN1Y2NlZWRHZXRQYXJhbWV0ZXJzIiwiZmFpbEdldFBhcmFtZXRlcnMiLCJzZW5kU2F2ZU1pc3Npb25zIiwic3VjY2VlZFNhdmVNaXNzaW9ucyIsImZhaWxTYXZlTWlzc2lvbnMiLCJzZW5kTG9hZE1pc3Npb25zIiwic3VjY2VlZExvYWRNaXNzaW9ucyIsImZhaWxMb2FkTWlzc2lvbnMiLCJzZW5kVXBsb2FkTWlzc2lvbiIsInN1Y2NlZWRVcGxvYWRNaXNzaW9uIiwiZmFpbFVwbG9hZE1pc3Npb24iLCJzZW5kRG93bmxvYWRNaXNzaW9uIiwic3VjY2VlZERvd25sb2FkTWlzc2lvbiIsImZhaWxEb3dubG9hZE1pc3Npb24iLCJzZW5kU3RhcnRNaXNzaW9uIiwic3VjY2VlZFN0YXJ0TWlzc2lvbiIsImZhaWxTdGFydE1pc3Npb24iLCJzZW5kU3RvcE1pc3Npb24iLCJzdWNjZWVkU3RvcE1pc3Npb24iLCJmYWlsU3RvcE1pc3Npb24iLCJzZW5kUmVzdW1lTWlzc2lvbiIsInN1Y2NlZWRSZXN1bWVNaXNzaW9uIiwiZmFpbFJlc3VtZU1pc3Npb24iLCJzZW5kQXJtIiwic3VjY2VlZEFybSIsImZhaWxBcm0iLCJzZW5kRGlzYXJtIiwic3VjY2VlZERpc2FybSIsImZhaWxEaXNhcm0iLCJzZW5kS2lsbCIsInN1Y2NlZWRLaWxsIiwiZmFpbEtpbGwiLCJzZW5kVW5raWxsIiwic3VjY2VlZFVua2lsbCIsImZhaWxVbmtpbGwiLCJtYXAiLCJkaXNwYXRjaCIsInN0YXRlIiwibWFwRWwiLCJsb2FkZWQiLCJlZGl0aW5nIiwid2FtdiIsImFybWVkIiwibW9kZSIsImtleSIsInZhbHVlIiwic2V0dGluZ3MiLCJtaXNzaW9ucyIsImluZGV4IiwibWlzc2lvbiIsInBhcmFtZXRlcnMiLCJtc2ciLCJnZXRNYXAiLCJnZXRNYXBFbCIsImdldE1hcExvYWRlZCIsImdldE1hcEVkaXRpbmciLCJnZXRXYW12IiwiZ2V0Q29uZmlnIiwiZ2V0U2V0dGluZ3MiLCJnZXRNaXNzaW9ucyIsImdldEN1cnJlbnRNaXNzaW9uSW5kZXgiLCJnZXRDdXJyZW50TWlzc2lvbiIsImdldFBhcmFtZXRlcnMiLCJnZXRNZXNzYWdlU3RhdGVXYWl0aW5nIiwiZ2V0TWVzc2FnZVN0YXRlU3VjY2VzcyIsImdldE1lc3NhZ2VTdGF0ZUZhaWx1cmUiLCJnZXRHZXRQYXJhbWV0ZXJTdGF0ZSIsImdldEdldFBhcmFtZXRlckRhdGEiLCJnZXRTYXZlTWlzc2lvbnNTdGF0ZSIsImdldFNhdmVNaXNzaW9uc0RhdGEiLCJnZXRMb2FkTWlzc2lvbnNTdGF0ZSIsImdldExvYWRNaXNzaW9uc0RhdGEiLCJnZXRVcGxvYWRNaXNzaW9uU3RhdGUiLCJnZXRVcGxvYWRNaXNzaW9uRGF0YSIsImdldERvd25sb2FkTWlzc2lvblN0YXRlIiwiZ2V0RG93bmxvYWRNaXNzaW9uRGF0YSIsImdldFN0YXJ0TWlzc2lvblN0YXRlIiwiZ2V0U3RhcnRNaXNzaW9uRGF0YSIsImdldFN0b3BNaXNzaW9uU3RhdGUiLCJnZXRTdG9wTWlzc2lvbkRhdGEiLCJnZXRSZXN1bWVNaXNzaW9uU3RhdGUiLCJnZXRSZXN1bWVNaXNzaW9uRGF0YSIsImdldEFybVN0YXRlIiwiZ2V0QXJtRGF0YSIsImdldERpc2FybVN0YXRlIiwiZ2V0RGlzYXJtRGF0YSIsImdldEtpbGxTdGF0ZSIsImdldEtpbGxEYXRhIiwiZ2V0VW5raWxsU3RhdGUiLCJnZXRVbmtpbGxEYXRhIiwibWFwTG9hZGVkIiwibWFwRWRpdGluZyIsImNvbmZpZyIsImN1cnJlbnRNaXNzaW9uSW5kZXgiLCJtZXNzYWdlU3RhdGUiLCJXQUlUSU5HIiwiU1VDQ0VTUyIsIkZBSUxVUkUiLCJnZXRfcGFyYW1ldGVycyIsInNhdmVfbWlzc2lvbnMiLCJsb2FkX21pc3Npb25zIiwidXBsb2FkX21pc3Npb24iLCJkb3dubG9hZF9taXNzaW9uIiwic3RhcnRfbWlzc2lvbiIsInN0b3BfbWlzc2lvbiIsInJlc3VtZV9taXNzaW9uIiwiYXJtIiwiZGlzYXJtIiwia2lsbCIsInVua2lsbCIsInZ1ZXgiLCJnZXR0ZXJzIiwicHJvcHMiLCJ0aXRsZSIsIlN0cmluZyIsImxhdCIsInR5cGUiLCJOdW1iZXIiLCJyZXF1aXJlZCIsImxuZyIsInJvdGF0aW9uIiwiZGVmYXVsdCIsInNjYWxlIiwidmlzaWJsZSIsIkJvb2xlYW4iLCJkcmFnZ2FibGUiLCJkYXRhIiwibWFya2VyIiwiY29tcHV0ZWQiLCJwb3NpdGlvbiIsInJlYWR5IiwiaW5pdGlhbGl6ZU1hcmtlciIsImJlZm9yZURlc3Ryb3kiLCJ3YXRjaCIsIm5ld1ZhbCIsIm9sZFZhbCIsInNldFRpdGxlIiwibGFiZWwiLCJzZXRMYWJlbCIsInNldFBvc2l0aW9uIiwic2V0VmlzaWJsZSIsInNldERyYWdnYWJsZSIsInVwZGF0ZUljb24iLCJtZXRob2RzIiwiZ29vZ2xlIiwibWFwcyIsIk1hcmtlciIsImljb24iLCJnZXRJY29uIiwiJGRpc3BhdGNoIiwic2V0dXBFdmVudHMiLCJzZXRJY29uIiwiYWRkTGlzdGVuZXIiLCJlIiwiaW5WaWV3Iiwic2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxUb1N0YXJ0Iiwic2Nyb2xsVG9FbmQiLCJlbGVtZW50IiwiY29udGFpbmVyIiwicGFyZW50RWxlbWVudCIsInRvcCIsIm9mZnNldFRvcCIsInBhcmVudFRvcCIsInNjcm9sbFRvcCIsImJvdHRvbSIsIm9mZnNldEhlaWdodCIsInBhcmVudEJvdHRvbSIsIm1hcmdpblRvcCIsInNjcm9sbEhlaWdodCIsIm51bWJlciIsImFscGhhYmV0Iiwic3BsaXQiLCJpbml0aWFsU3RhdGUiLCJoZWFkaW5nIiwic3BlZWQiLCJiYXR0ZXJ5Iiwic2lnbmFsIiwic2V0dGluZ3NMb2FkZWQiLCJJTklUSUFMIiwic2V0X3BhcmFtZXRlciIsIm11dGF0aW9ucyIsIlNFVF9NQVAiLCJTRVRfTUFQX0VMIiwiU0VUX01BUF9MT0FERUQiLCJTRVRfTUFQX0VESVRJTkciLCJVUERBVEVfV0FNVl9QT1NJVElPTiIsIlNFVF9XQU1WIiwiU0VUX1dBTVZfQVJNRUQiLCJTRVRfV0FNVl9NT0RFIiwiSU5JVF9TRVRUSU5HUyIsIlVQREFURV9TRVRUSU5HUyIsIlNFVF9NSVNTSU9OUyIsIlNFVF9DVVJSRU5UX01JU1NJT05fSU5ERVgiLCJTRVRfQ1VSUkVOVF9NSVNTSU9OIiwiJHNldCIsIlNFVF9QQVJBTUVURVJTIiwiU0VORF9HRVRfUEFSQU1FVEVSUyIsIlNVQ0NFRURfR0VUX1BBUkFNRVRFUlMiLCJGQUlMX0dFVF9QQVJBTUVURVJTIiwiU0VORF9TQVZFX01JU1NJT05TIiwiU1VDQ0VFRF9TQVZFX01JU1NJT05TIiwiRkFJTF9TQVZFX01JU1NJT05TIiwiU0VORF9MT0FEX01JU1NJT05TIiwiU1VDQ0VFRF9MT0FEX01JU1NJT05TIiwiRkFJTF9MT0FEX01JU1NJT05TIiwiU0VORF9VUExPQURfTUlTU0lPTiIsIlNVQ0NFRURfVVBMT0FEX01JU1NJT04iLCJGQUlMX1VQTE9BRF9NSVNTSU9OIiwiU0VORF9ET1dOTE9BRF9NSVNTSU9OIiwiU1VDQ0VFRF9ET1dOTE9BRF9NSVNTSU9OIiwiRkFJTF9ET1dOTE9BRF9NSVNTSU9OIiwiU0VORF9TVEFSVF9NSVNTSU9OIiwiU1VDQ0VFRF9TVEFSVF9NSVNTSU9OIiwiRkFJTF9TVEFSVF9NSVNTSU9OIiwiU0VORF9TVE9QX01JU1NJT04iLCJTVUNDRUVEX1NUT1BfTUlTU0lPTiIsIkZBSUxfU1RPUF9NSVNTSU9OIiwiU0VORF9SRVNVTUVfTUlTU0lPTiIsIlNVQ0NFRURfUkVTVU1FX01JU1NJT04iLCJGQUlMX1JFU1VNRV9NSVNTSU9OIiwiU0VORF9BUk0iLCJTVUNDRUVEX0FSTSIsIkZBSUxfQVJNIiwiU0VORF9ESVNBUk0iLCJTVUNDRUVEX0RJU0FSTSIsIkZBSUxfRElTQVJNIiwiU0VORF9LSUxMIiwiU1VDQ0VFRF9LSUxMIiwiRkFJTF9LSUxMIiwiU0VORF9VTktJTEwiLCJTVUNDRUVEX1VOS0lMTCIsIkZBSUxfVU5LSUxMIiwiU3RvcmUiLCJnb29nbGVNYXBzIiwidiIsImNlbnRlciIsInpvb20iLCJkaXNhYmxlRGVmYXVsdFVJIiwiZGlzYWJsZURvdWJsZUNsaWNrWm9vbSIsInRpbHQiLCJkZWZhdWx0TWFwVHlwZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTs7OztBQUNBOzs7O0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixhQUFZO0FBQ1o7O0FBRUE7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxJQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcseUJBQXlCO0FBQ3BDLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxLQUFLO0FBQ2hELFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsSUFBSTtBQUNmLFlBQVcsaUJBQWlCO0FBQzVCLFlBQVcsSUFBSTtBQUNmLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsMENBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEtBQUs7QUFDaEIsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxJQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLElBQUk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxJQUFJO0FBQ2YsWUFBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxJQUFJO0FBQ2YsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsTUFBTTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxFQUFFO0FBQ2YsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLE9BQU87QUFDcEIsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLEVBQUU7QUFDZixjQUFhLFNBQVM7QUFDdEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLEVBQUU7QUFDZixjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsYUFBYTtBQUN4QixZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCLFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUE4QjtBQUM5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsZ0RBQStDO0FBQy9DLE1BQUs7QUFDTCxvQ0FBbUM7QUFDbkM7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsb0NBQW1DO0FBQ25DO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLGFBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEscUJBQXFCO0FBQ2xDLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxJQUFJO0FBQ2YsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7QUFDSDtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsSUFBSTtBQUNqQixjQUFhLE9BQU87QUFDcEIsY0FBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsUUFBUTtBQUNyQixjQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEVBQUU7QUFDZixjQUFhLEVBQUU7QUFDZixjQUFhLE1BQU07QUFDbkIsY0FBYSxRQUFRO0FBQ3JCLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGdCQUFnQjtBQUM3QixjQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLFFBQVE7QUFDckIsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLEVBQUU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsZ0JBQWdCO0FBQzdCLGNBQWEsU0FBUztBQUN0QixjQUFhLE9BQU87QUFDcEIseUJBQXdCLFFBQVE7QUFDaEMseUJBQXdCLFFBQVE7QUFDaEMsZUFBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxRQUFRO0FBQ3JCLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEtBQUs7QUFDbEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxJQUFJO0FBQ2pCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsU0FBUztBQUN0QixjQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsRUFBRTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsc0I7Ozs7Ozs7QUN6MVRBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVOzs7Ozs7O0FDL0p0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBLDJEQUEwRCxlQUFlLEVBQUU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTtBQUNOLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBLHNFQUFxRTs7QUFFckU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MseUNBQXlDO0FBQzNFO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRGQUEyRixhQUFhO0FBQ3hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBb0MsaUNBQWlDLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLHlDQUF5QyxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhLEVBQUUsMkJBQTJCLDBCQUEwQixZQUFZLEVBQUUsMkNBQTJDLDhCQUE4QixFQUFFLE9BQU8sNkVBQTZFLEVBQUUsR0FBRyxFQUFFOztBQUV2cEIsbUNBQWtDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFbmpCLG1EQUFrRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXhKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVztBQUNYOztBQUVBO0FBQ0EsZUFBYzs7QUFFZCxzRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRO0FBQ1I7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSOztBQUVBO0FBQ0Esc0VBQXFFLCtCQUErQjtBQUNwRzs7QUFFQSxvREFBbUQsK0JBQStCO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjs7QUFFQSxpQ0FBZ0M7QUFDaEMsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1osV0FBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1osV0FBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOLGNBQWE7QUFDYjtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUEsR0FBRTs7O0FBR0YsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQSwrRkFBOEYsNERBQTREO0FBQzFKO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBLHdGQUF1Riw2QkFBNkI7O0FBRXBILFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7O0FBR047QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUEyQyxzQ0FBc0M7O0FBRWpGO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FB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O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsZUFBYztBQUNkLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLDZCQUE0QixxQkFBcUI7QUFDakQ7O0FBRUEsaUNBQWdDLHlCQUF5QjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUI7QUFDbkIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQjtBQUNuQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUI7QUFDbkIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxRkFBb0Y7QUFDcEY7O0FBRUEsa0JBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUpBQXNKO0FBQ3RKOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUEseUhBQXdILDhEQUE4RDtBQUN0TDtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBLG9FQUFtRSwrQ0FBK0M7O0FBRWxILFFBQU87QUFDUDtBQUNBOztBQUVBLHlFQUF3RSxxSkFBcUosNnBCQUE2cEIsK0JBQStCOztBQUV6NUIsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBc0I7QUFDdEIsc0JBQXFCOztBQUVyQixtQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksTUFBTTtBQUNsQixhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRixHQUFFOztBQUVGLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUYsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUEsb0VBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLEdBQUU7OztBQUdGLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7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a0RBRUE7MkJBQ0E7MkJBQ0E7QUFDQTswREFDQTt5QkFDQTsyREFDQTs0Q0FDQTtBQUNBO0FBQ0E7eURBQ0E7eUJBQ0E7MkRBQ0E7MkNBQ0E7QUFDQTtBQUNBOzREQUNBO3lCQUNBOzhEQUNBOzhDQUNBO0FBQ0E7QUFDQTttREFDQTt5QkFDQTtzRkFDQTt1QkFDQTsrRkFDQTt1QkFDQTs2RkFDQTt1QkFDQTsyRkFDQTt1QkFDQTsrRkFDQTt1QkFDQTswRUFDQTt1QkFDQTtnRkFDQTt1QkFDQTs0RUFDQTt1QkFDQTtnRkFDQTt1QkFDQTtBQUNBO0FBQ0E7bURBQ0E7eUJBQ0E7MEJBQ0E7O0FBQ0E7c0RBQ0E7QUFDQTtBQUNBOztBQUNBO3FEQUNBO0FBQ0E7QUFDQTs7QUFDQTtxREFDQTtBQUNBO0FBQ0E7O0FBQ0E7c0RBQ0E7QUFDQTtBQUNBOztBQUNBO3dEQUNBO0FBQ0E7QUFDQTs7QUFDQTtxREFDQTtBQUNBO0FBQ0E7O0FBQ0E7b0RBQ0E7QUFDQTtBQUNBOztBQUNBO3NEQUNBO0FBQ0E7QUFDQTs7QUFDQTs0Q0FDQTtBQUNBO0FBQ0E7O0FBQ0E7K0NBQ0E7QUFDQTtBQUNBOztBQUNBOzZDQUNBO0FBQ0E7QUFDQTs7QUFDQTsrQ0FDQTtBQUNBO0FBRUE7O0FBQ0E7cURBQ0E7eUNBQ0E7QUFDQTtBQUVBOzs7O3dFQUVBO29DQUVBOzRDQUNBO3NDQUNBO21EQUNBOzZDQUNBO21EQUNBO3FFQUNBO0FBQ0E7QUFDQTtBQUVBO3dFQUNBO29DQUNBOzRDQUNBOzREQUNBO0FBQ0E7QUFDQTtBQUVBO3dFQUNBO29DQUNBOzRDQUNBO3NDQUNBO0FBQ0E7QUFDQTtBQUVBOzBFQUNBO29DQUNBOzRDQUNBOzZEQUNBO0FBQ0E7QUFDQTtBQUVBOzhFQUNBO29DQUNBOzRDQUNBO3NDQUNBO0FBQ0E7QUFDQTtBQUVBO3dFQUNBO29DQUNBOzRDQUNBO3NDQUNBO0FBQ0E7QUFDQTtBQUVBO3NFQUNBO29DQUNBOzRDQUNBO3NDQUNBO0FBQ0E7QUFDQTtBQUVBOzBFQUNBO29DQUNBOzRDQUNBO3NDQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBOzs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQix1QkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFtRjtBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxvQkFBb0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcscUJBQXFCO0FBQ2hDLGFBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7bUNDL1lBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLG1DQUFrQyxpREFBaUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzaUJBOzs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTJGOztBQUUzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2dEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BEQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBLE1BQUssV0FBVztBQUNoQjtBQUNBOzs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCLGlEQUFpRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsNERBQTJEO0FBQzNEO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXVFO0FBQ3ZFLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0RBQW1ELGNBQWM7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzWkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxVQUFVO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUMxREQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7bUNDM0JBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0EsTUFBSztBQUNMLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Ysb0JBQW1CO0FBQ25CO0FBQ0EsSUFBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRSxPQUFPO0FBQ1Q7QUFDQTs7QUFFQSxFQUFDOzs7Ozs7OztBQ25QRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7Ozs7Ozs7O0FDOUZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsTUFBTTtBQUNqQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTSxZQUFZOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3T0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLFlBQVk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUyxPQUFPO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTs7QUFF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Q0Esa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLGNBQWM7QUFDL0IsbUJBQWtCO0FBQ2xCOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBb0csZUFBZTtBQUNuSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsR0FBRyx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRzs7Ozs7Ozs7Ozs7bUJDcnBCYztBQUNYcUQsaUJBQVk7QUFDUjlMLGNBQUsseUNBREc7QUFFUitMLFlBQUc7QUFGSyxNQUREO0FBS1h4TSxVQUFLO0FBQ0R5TSxpQkFBUTtBQUNKekgsa0JBQUssU0FERDtBQUVKSSxrQkFBSyxDQUFDO0FBRkYsVUFEUDtBQUtEc0gsZUFBTSxFQUxMO0FBTURDLDJCQUFrQixJQU5qQjtBQU9EQyxpQ0FBd0IsSUFQdkI7QUFRREMsZUFBTTtBQVJMLE1BTE07QUFlWGxNLGVBQVU7QUFDTm1NLHlCQUFnQjtBQURWO0FBZkMsRSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDA5MWNmNTQ1NjYwN2E0ZDcxMzg3XG4gKiovIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IEtlZW5VSSBmcm9tICdrZWVuLXVpJztcbmltcG9ydCBBcHAgZnJvbSAnYXBwL0FwcC52dWUnO1xuaW1wb3J0IHN0b3JlIGZyb20gJ3N0b3JlL3N0b3JlJztcblxuVnVlLnVzZShLZWVuVUkpO1xuXG52YXIgYXBwID0gbmV3IFZ1ZSh7XG4gICAgZWw6ICdib2R5JyxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFwcFxuICAgIH0sXG4gICAgc3RvcmVcbn0pO1xuXG53aW5kb3cuYXBwID0gYXBwO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbWFpbi5qc1xuICoqLyIsIi8qIVxuICogVnVlLmpzIHYxLjAuMjZcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKGhhc093bihvYmosIGtleSkpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9iai5faXNWdWUpIHtcbiAgICBzZXQob2JqLl9kYXRhLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm47XG4gIH1cbiAgb2IuY29udmVydChrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgaWYgKG9iLnZtcykge1xuICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV07XG4gICAgICB2bS5fcHJveHkoa2V5KTtcbiAgICAgIHZtLl9kaWdlc3QoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBkZWwob2JqLCBrZXkpIHtcbiAgaWYgKCFoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlbGV0ZSBvYmpba2V5XTtcbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKCFvYikge1xuICAgIGlmIChvYmouX2lzVnVlKSB7XG4gICAgICBkZWxldGUgb2JqLl9kYXRhW2tleV07XG4gICAgICBvYmouX2RpZ2VzdCgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl91bnByb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfC0/W1xcZFxcLl0rfCdbXiddKid8XCJbXlwiXSpcIilcXHM/JC87XG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbChleHApIHtcbiAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGO1xufVxuXG4vKipcbiAqIEd1YXJkIHRleHQgb3V0cHV0LCBtYWtlIHN1cmUgdW5kZWZpbmVkIG91dHB1dHNcbiAqIGVtcHR5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBfdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIGNvbnZlcnQgcG9zc2libGUgbnVtZXJpYyBzdHJpbmdzIHRvIG51bWJlcnNcbiAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8TnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZWQgPSBOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiBpc05hTihwYXJzZWQpID8gdmFsdWUgOiBwYXJzZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyBib29sZWFuIGxpdGVyYWxzIGludG8gcmVhbCBib29sZWFucy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfEJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBTdHJpcCBxdW90ZXMgZnJvbSBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZyB8IGZhbHNlfVxuICovXG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHN0cikge1xuICB2YXIgYSA9IHN0ci5jaGFyQ29kZUF0KDApO1xuICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGEgPT09IGIgJiYgKGEgPT09IDB4MjIgfHwgYSA9PT0gMHgyNykgPyBzdHIuc2xpY2UoMSwgLTEpIDogc3RyO1xufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbG1pdGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgdG9VcHBlcik7XG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBoeXBoZW5hdGVSRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBoeXBoZW4vdW5kZXJzY29yZS9zbGFzaCBkZWxpbWl0ZXJlZCBuYW1lcyBpbnRvXG4gKiBjYW1lbGl6ZWQgY2xhc3NOYW1lcy5cbiAqXG4gKiBlLmcuIG15LWNvbXBvbmVudCA9PiBNeUNvbXBvbmVudFxuICogICAgICBzb21lX2Vsc2UgICAgPT4gU29tZUVsc2VcbiAqICAgICAgc29tZS9jb21wICAgID0+IFNvbWVDb21wXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXFwvXSkoXFx3KS9nO1xuXG5mdW5jdGlvbiBjbGFzc2lmeShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbCA/IGwgPiAxID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpIDogZm4uY2FsbChjdHgsIGEpIDogZm4uY2FsbChjdHgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBmcm9tKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG59XG5cbi8qKlxuICogQXJyYXkgdHlwZSBjaGVjay5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudW1lcmFibGVdXG4gKi9cblxuZnVuY3Rpb24gZGVmKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gc28gaXQgb25seSBnZXRzIGNhbGxlZCBhZnRlciB0aGVcbiAqIGlucHV0IHN0b3BzIGFycml2aW5nIGFmdGVyIHRoZSBnaXZlbiB3YWl0IHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge051bWJlcn0gd2FpdFxuICogQHJldHVybiB7RnVuY3Rpb259IC0gdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIF9kZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogTWFudWFsIGluZGV4T2YgYmVjYXVzZSBpdCdzIHNsaWdodGx5IGZhc3RlciB0aGFuXG4gKiBuYXRpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyLCBvYmopIHtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogTWFrZSBhIGNhbmNlbGxhYmxlIHZlcnNpb24gb2YgYW4gYXN5bmMgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNhbmNlbGxhYmxlKGZuKSB7XG4gIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xuICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYi5jYW5jZWxsZWQgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gY2I7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICByZXR1cm4gYSA9PSBiIHx8IChpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKSA6IGZhbHNlKTtcbiAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbn1cblxudmFyIGhhc1Byb3RvID0gKCdfX3Byb3RvX18nIGluIHt9KTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpICE9PSAnW29iamVjdCBPYmplY3RdJztcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8vIFVBIHNuaWZmaW5nIGZvciB3b3JraW5nIGFyb3VuZCBicm93c2VyLXNwZWNpZmljIHF1aXJrc1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIFVBLmluZGV4T2YoJ3RyaWRlbnQnKSA+IDA7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSW9zID0gVUEgJiYgLyhpcGhvbmV8aXBhZHxpcG9kfGlvcykvaS50ZXN0KFVBKTtcbnZhciBpb3NWZXJzaW9uTWF0Y2ggPSBpc0lvcyAmJiBVQS5tYXRjaCgvb3MgKFtcXGRfXSspLyk7XG52YXIgaW9zVmVyc2lvbiA9IGlvc1ZlcnNpb25NYXRjaCAmJiBpb3NWZXJzaW9uTWF0Y2hbMV0uc3BsaXQoJ18nKTtcblxuLy8gZGV0ZWN0aW5nIGlPUyBVSVdlYlZpZXcgYnkgaW5kZXhlZERCXG52YXIgaGFzTXV0YXRpb25PYnNlcnZlckJ1ZyA9IGlvc1ZlcnNpb24gJiYgTnVtYmVyKGlvc1ZlcnNpb25bMF0pID49IDkgJiYgTnVtYmVyKGlvc1ZlcnNpb25bMV0pID49IDMgJiYgIXdpbmRvdy5pbmRleGVkREI7XG5cbnZhciB0cmFuc2l0aW9uUHJvcCA9IHVuZGVmaW5lZDtcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uUHJvcCA9IHVuZGVmaW5lZDtcbnZhciBhbmltYXRpb25FbmRFdmVudCA9IHVuZGVmaW5lZDtcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xuaWYgKGluQnJvd3NlciAmJiAhaXNJRTkpIHtcbiAgdmFyIGlzV2Via2l0VHJhbnMgPSB3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXNXZWJraXRBbmltID0gd2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQ7XG4gIHRyYW5zaXRpb25Qcm9wID0gaXNXZWJraXRUcmFucyA/ICdXZWJraXRUcmFuc2l0aW9uJyA6ICd0cmFuc2l0aW9uJztcbiAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gaXNXZWJraXRUcmFucyA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcbiAgYW5pbWF0aW9uUHJvcCA9IGlzV2Via2l0QW5pbSA/ICdXZWJraXRBbmltYXRpb24nIDogJ2FuaW1hdGlvbic7XG4gIGFuaW1hdGlvbkVuZEV2ZW50ID0gaXNXZWJraXRBbmltID8gJ3dlYmtpdEFuaW1hdGlvbkVuZCcgOiAnYW5pbWF0aW9uZW5kJztcbn1cblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS4gSWRlYWxseSB0aGlzXG4gKiBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSBtaWNyb3Rhc2ssIHNvIHdlIGxldmVyYWdlXG4gKiBNdXRhdGlvbk9ic2VydmVyIGlmIGl0J3MgYXZhaWxhYmxlLCBhbmQgZmFsbGJhY2sgdG9cbiAqIHNldFRpbWVvdXQoMCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqL1xuXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlcigpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIWhhc011dGF0aW9uT2JzZXJ2ZXJCdWcpIHtcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb3VudGVyKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IGNvdW50ZXI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZWJwYWNrIGF0dGVtcHRzIHRvIGluamVjdCBhIHNoaW0gZm9yIHNldEltbWVkaWF0ZVxuICAgIC8vIGlmIGl0IGlzIHVzZWQgYXMgYSBnbG9iYWwsIHNvIHdlIGhhdmUgdG8gd29yayBhcm91bmQgdGhhdCB0b1xuICAgIC8vIGF2b2lkIGJ1bmRsaW5nIHVubmVjZXNzYXJ5IGNvZGUuXG4gICAgdmFyIGNvbnRleHQgPSBpbkJyb3dzZXIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9O1xuICAgIHRpbWVyRnVuYyA9IGNvbnRleHQuc2V0SW1tZWRpYXRlIHx8IHNldFRpbWVvdXQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgdmFyIGZ1bmMgPSBjdHggPyBmdW5jdGlvbiAoKSB7XG4gICAgICBjYi5jYWxsKGN0eCk7XG4gICAgfSA6IGNiO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICAgIGlmIChwZW5kaW5nKSByZXR1cm47XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKG5leHRUaWNrSGFuZGxlciwgMCk7XG4gIH07XG59KSgpO1xuXG52YXIgX1NldCA9IHVuZGVmaW5lZDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIFNldC50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnNldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzLnNldFtrZXldID0gMTtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBDYWNoZShsaW1pdCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fa2V5bWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxudmFyIHAgPSBDYWNoZS5wcm90b3R5cGU7XG5cbi8qKlxuICogUHV0IDx2YWx1ZT4gaW50byB0aGUgY2FjaGUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+LlxuICogUmV0dXJucyB0aGUgZW50cnkgd2hpY2ggd2FzIHJlbW92ZWQgdG8gbWFrZSByb29tIGZvclxuICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqIChpLmUuIGlmIHRoZXJlIHdhcyBlbm91Z2ggcm9vbSBhbHJlYWR5KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gKi9cblxucC5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgcmVtb3ZlZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgICAgcmVtb3ZlZCA9IHRoaXMuc2hpZnQoKTtcbiAgICB9XG4gICAgZW50cnkgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gICAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeTtcbiAgICBpZiAodGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTtcbiAgICAgIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB9XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5zaXplKys7XG4gIH1cbiAgZW50cnkudmFsdWUgPSB2YWx1ZTtcblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG5cbi8qKlxuICogUHVyZ2UgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgZnJvbSB0aGVcbiAqIGNhY2hlLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVudHJ5IG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAqIGNhY2hlIHdhcyBlbXB0eS5cbiAqL1xuXG5wLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gIGlmIChlbnRyeSkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXdlcjtcbiAgICB0aGlzLmhlYWQub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9rZXltYXBbZW50cnkua2V5XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNpemUtLTtcbiAgfVxuICByZXR1cm4gZW50cnk7XG59O1xuXG4vKipcbiAqIEdldCBhbmQgcmVnaXN0ZXIgcmVjZW50IHVzZSBvZiA8a2V5Pi4gUmV0dXJucyB0aGUgdmFsdWVcbiAqIGFzc29jaWF0ZWQgd2l0aCA8a2V5PiBvciB1bmRlZmluZWQgaWYgbm90IGluIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRW50cnlcbiAqIEByZXR1cm4ge0VudHJ5fCp9XG4gKi9cblxucC5nZXQgPSBmdW5jdGlvbiAoa2V5LCByZXR1cm5FbnRyeSkge1xuICB2YXIgZW50cnkgPSB0aGlzLl9rZXltYXBba2V5XTtcbiAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xuICB9XG4gIC8vIEhFQUQtLS0tLS0tLS0tLS0tLVRBSUxcbiAgLy8gICA8Lm9sZGVyICAgLm5ld2VyPlxuICAvLyAgPC0tLSBhZGQgZGlyZWN0aW9uIC0tXG4gIC8vICAgQSAgQiAgQyAgPEQ+ICBFXG4gIGlmIChlbnRyeS5uZXdlcikge1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjsgLy8gQyA8LS0gRS5cbiAgfVxuICBpZiAoZW50cnkub2xkZXIpIHtcbiAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyOyAvLyBDLiAtLT4gRVxuICB9XG4gIGVudHJ5Lm5ld2VyID0gdW5kZWZpbmVkOyAvLyBEIC0teFxuICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDsgLy8gRC4gLS0+IEVcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5OyAvLyBFLiA8LS0gRFxuICB9XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xufTtcblxudmFyIGNhY2hlJDEgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgZmlsdGVyVG9rZW5SRSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nO1xudmFyIHJlc2VydmVkQXJnUkUgPSAvXmluJHxeLT9cXGQrLztcblxuLyoqXG4gKiBQYXJzZXIgc3RhdGVcbiAqL1xuXG52YXIgc3RyO1xudmFyIGRpcjtcbnZhciBjO1xudmFyIHByZXY7XG52YXIgaTtcbnZhciBsO1xudmFyIGxhc3RGaWx0ZXJJbmRleDtcbnZhciBpblNpbmdsZTtcbnZhciBpbkRvdWJsZTtcbnZhciBjdXJseTtcbnZhciBzcXVhcmU7XG52YXIgcGFyZW47XG4vKipcbiAqIFB1c2ggYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgZGlyZWN0aXZlIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gIHZhciBleHAgPSBzdHIuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCk7XG4gIHZhciBmaWx0ZXI7XG4gIGlmIChleHApIHtcbiAgICBmaWx0ZXIgPSB7fTtcbiAgICB2YXIgdG9rZW5zID0gZXhwLm1hdGNoKGZpbHRlclRva2VuUkUpO1xuICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgZmlsdGVyLmFyZ3MgPSB0b2tlbnMuc2xpY2UoMSkubWFwKHByb2Nlc3NGaWx0ZXJBcmcpO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyKSB7XG4gICAgKGRpci5maWx0ZXJzID0gZGlyLmZpbHRlcnMgfHwgW10pLnB1c2goZmlsdGVyKTtcbiAgfVxuICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhcmd1bWVudCBpcyBkeW5hbWljIGFuZCBzdHJpcCBxdW90ZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NGaWx0ZXJBcmcoYXJnKSB7XG4gIGlmIChyZXNlcnZlZEFyZ1JFLnRlc3QoYXJnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdG9OdW1iZXIoYXJnKSxcbiAgICAgIGR5bmFtaWM6IGZhbHNlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhhcmcpO1xuICAgIHZhciBkeW5hbWljID0gc3RyaXBwZWQgPT09IGFyZztcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGR5bmFtaWMgPyBhcmcgOiBzdHJpcHBlZCxcbiAgICAgIGR5bmFtaWM6IGR5bmFtaWNcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBkaXJlY3RpdmUgdmFsdWUgYW5kIGV4dHJhY3QgdGhlIGV4cHJlc3Npb25cbiAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIFwiYSArIDEgfCB1cHBlcmNhc2VcIiB3aWxsIHlpZWxkOlxuICoge1xuICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICogICBmaWx0ZXJzOiBbXG4gKiAgICAgeyBuYW1lOiAndXBwZXJjYXNlJywgYXJnczogbnVsbCB9XG4gKiAgIF1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlKHMpIHtcbiAgdmFyIGhpdCA9IGNhY2hlJDEuZ2V0KHMpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIC8vIHJlc2V0IHBhcnNlciBzdGF0ZVxuICBzdHIgPSBzO1xuICBpblNpbmdsZSA9IGluRG91YmxlID0gZmFsc2U7XG4gIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwO1xuICBsYXN0RmlsdGVySW5kZXggPSAwO1xuICBkaXIgPSB7fTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIC8vIGNoZWNrIHNpbmdsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgaW5TaW5nbGUgPSAhaW5TaW5nbGU7XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgLy8gY2hlY2sgZG91YmxlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSBpbkRvdWJsZSA9ICFpbkRvdWJsZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJiBzdHIuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MpIHtcbiAgICAgIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFscmVhZHkgaGFzIGZpbHRlclxuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6XG4gICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO2JyZWFrOyAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6XG4gICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO2JyZWFrOyAvLyAnXG4gICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICBwYXJlbisrO2JyZWFrOyAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICBwYXJlbi0tO2JyZWFrOyAvLyApXG4gICAgICAgIGNhc2UgMHg1QjpcbiAgICAgICAgICBzcXVhcmUrKzticmVhazsgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6XG4gICAgICAgICAgc3F1YXJlLS07YnJlYWs7IC8vIF1cbiAgICAgICAgY2FzZSAweDdCOlxuICAgICAgICAgIGN1cmx5Kys7YnJlYWs7IC8vIHtcbiAgICAgICAgY2FzZSAweDdEOlxuICAgICAgICAgIGN1cmx5LS07YnJlYWs7IC8vIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBjYWNoZSQxLnB1dChzLCBkaXIpO1xuICByZXR1cm4gZGlyO1xufVxuXG52YXIgZGlyZWN0aXZlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRGlyZWN0aXZlOiBwYXJzZURpcmVjdGl2ZVxufSk7XG5cbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcbnZhciBjYWNoZSA9IHVuZGVmaW5lZDtcbnZhciB0YWdSRSA9IHVuZGVmaW5lZDtcbnZhciBodG1sUkUgPSB1bmRlZmluZWQ7XG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBzbyBpdCBjYW4gYmUgdXNlZCBpbiBhIFJlZ0V4cFxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlUmVnZXgoKSB7XG4gIHZhciBvcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMF0pO1xuICB2YXIgY2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1sxXSk7XG4gIHZhciB1bnNhZmVPcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMF0pO1xuICB2YXIgdW5zYWZlQ2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1sxXSk7XG4gIHRhZ1JFID0gbmV3IFJlZ0V4cCh1bnNhZmVPcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyB1bnNhZmVDbG9zZSArICd8JyArIG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpO1xuICBodG1sUkUgPSBuZXcgUmVnRXhwKCdeJyArIHVuc2FmZU9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIHVuc2FmZUNsb3NlICsgJyQnKTtcbiAgLy8gcmVzZXQgY2FjaGVcbiAgY2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG59XG5cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSB0ZXh0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0PiB8IG51bGx9XG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtodG1sXVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRleHQodGV4dCkge1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY29tcGlsZVJlZ2V4KCk7XG4gIH1cbiAgdmFyIGhpdCA9IGNhY2hlLmdldCh0ZXh0KTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgaHRtbCwgdmFsdWUsIGZpcnN0LCBvbmVUaW1lO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgaHRtbCA9IGh0bWxSRS50ZXN0KG1hdGNoWzBdKTtcbiAgICB2YWx1ZSA9IGh0bWwgPyBtYXRjaFsxXSA6IG1hdGNoWzJdO1xuICAgIGZpcnN0ID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICBvbmVUaW1lID0gZmlyc3QgPT09IDQyOyAvLyAqXG4gICAgdmFsdWUgPSBvbmVUaW1lID8gdmFsdWUuc2xpY2UoMSkgOiB2YWx1ZTtcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0YWc6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgaHRtbDogaHRtbCxcbiAgICAgIG9uZVRpbWU6IG9uZVRpbWVcbiAgICB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgpXG4gICAgfSk7XG4gIH1cbiAgY2FjaGUucHV0KHRleHQsIHRva2Vucyk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgbGlzdCBvZiB0b2tlbnMgaW50byBhbiBleHByZXNzaW9uLlxuICogZS5nLiB0b2tlbnMgcGFyc2VkIGZyb20gJ2Ege3tifX0gYycgY2FuIGJlIHNlcmlhbGl6ZWRcbiAqIGludG8gb25lIHNpbmdsZSBleHByZXNzaW9uIGFzICdcImEgXCIgKyBiICsgXCIgY1wiJy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gdG9rZW5zVG9FeHAodG9rZW5zLCB2bSkge1xuICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbiwgdm0pO1xuICAgIH0pLmpvaW4oJysnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW5zWzBdLCB2bSwgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzaW5nbGUgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHBhcmFtIHtCb29sZWFufSBbc2luZ2xlXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFRva2VuKHRva2VuLCB2bSwgc2luZ2xlKSB7XG4gIHJldHVybiB0b2tlbi50YWcgPyB0b2tlbi5vbmVUaW1lICYmIHZtID8gJ1wiJyArIHZtLiRldmFsKHRva2VuLnZhbHVlKSArICdcIicgOiBpbmxpbmVGaWx0ZXJzKHRva2VuLnZhbHVlLCBzaW5nbGUpIDogJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJztcbn1cblxuLyoqXG4gKiBGb3IgYW4gYXR0cmlidXRlIHdpdGggbXVsdGlwbGUgaW50ZXJwb2xhdGlvbiB0YWdzLFxuICogZS5nLiBhdHRyPVwic29tZS17e3RoaW5nIHwgZmlsdGVyfX1cIiwgaW4gb3JkZXIgdG8gY29tYmluZVxuICogdGhlIHdob2xlIHRoaW5nIGludG8gYSBzaW5nbGUgd2F0Y2hhYmxlIGV4cHJlc3Npb24sIHdlXG4gKiBoYXZlIHRvIGlubGluZSB0aG9zZSBmaWx0ZXJzLiBUaGlzIGZ1bmN0aW9uIGRvZXMgZXhhY3RseVxuICogdGhhdC4gVGhpcyBpcyBhIGJpdCBoYWNreSBidXQgaXQgYXZvaWRzIGhlYXZ5IGNoYW5nZXNcbiAqIHRvIGRpcmVjdGl2ZSBwYXJzZXIgYW5kIHdhdGNoZXIgbWVjaGFuaXNtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGZpbHRlclJFID0gL1tefF1cXHxbXnxdLztcbmZ1bmN0aW9uIGlubGluZUZpbHRlcnMoZXhwLCBzaW5nbGUpIHtcbiAgaWYgKCFmaWx0ZXJSRS50ZXN0KGV4cCkpIHtcbiAgICByZXR1cm4gc2luZ2xlID8gZXhwIDogJygnICsgZXhwICsgJyknO1xuICB9IGVsc2Uge1xuICAgIHZhciBkaXIgPSBwYXJzZURpcmVjdGl2ZShleHApO1xuICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndGhpcy5fYXBwbHlGaWx0ZXJzKCcgKyBkaXIuZXhwcmVzc2lvbiArIC8vIHZhbHVlXG4gICAgICAnLG51bGwsJyArIC8vIG9sZFZhbHVlIChudWxsIGZvciByZWFkKVxuICAgICAgSlNPTi5zdHJpbmdpZnkoZGlyLmZpbHRlcnMpICsgLy8gZmlsdGVyIGRlc2NyaXB0b3JzXG4gICAgICAnLGZhbHNlKSc7IC8vIHdyaXRlP1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICBjb21waWxlUmVnZXg6IGNvbXBpbGVSZWdleCxcbiAgcGFyc2VUZXh0OiBwYXJzZVRleHQsXG4gIHRva2Vuc1RvRXhwOiB0b2tlbnNUb0V4cFxufSk7XG5cbnZhciBkZWxpbWl0ZXJzID0gWyd7eycsICd9fSddO1xudmFyIHVuc2FmZURlbGltaXRlcnMgPSBbJ3t7eycsICd9fX0nXTtcblxudmFyIGNvbmZpZyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICogQWxzbyBlbmFibGVzIHN0YWNrIHRyYWNlIGZvciB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIGRlYnVnOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIGFzeW5jIHJlbmRlcmluZy5cbiAgICovXG5cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd2FybiBhZ2FpbnN0IGVycm9ycyBjYXVnaHQgd2hlbiBldmFsdWF0aW5nXG4gICAqIGV4cHJlc3Npb25zLlxuICAgKi9cblxuICB3YXJuRXhwcmVzc2lvbkVycm9yczogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBkZXZ0b29scyBpbnNwZWN0aW9uLlxuICAgKiBEaXNhYmxlZCBieSBkZWZhdWx0IGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuICAgKi9cblxuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogSW50ZXJuYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGUgZGVsaW1pdGVycyBoYXZlIGJlZW5cbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgX2Fzc2V0VHlwZXM6IFsnY29tcG9uZW50JywgJ2RpcmVjdGl2ZScsICdlbGVtZW50RGlyZWN0aXZlJywgJ2ZpbHRlcicsICd0cmFuc2l0aW9uJywgJ3BhcnRpYWwnXSxcblxuICAvKipcbiAgICogcHJvcCBiaW5kaW5nIG1vZGVzXG4gICAqL1xuXG4gIF9wcm9wQmluZGluZ01vZGVzOiB7XG4gICAgT05FX1dBWTogMCxcbiAgICBUV09fV0FZOiAxLFxuICAgIE9ORV9USU1FOiAyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBiYXRjaGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cblxuICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxuXG59LCB7XG4gIGRlbGltaXRlcnM6IHsgLyoqXG4gICAgICAgICAgICAgICAgICogSW50ZXJwb2xhdGlvbiBkZWxpbWl0ZXJzLiBDaGFuZ2luZyB0aGVzZSB3b3VsZCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICogdGhlIHRleHQgcGFyc2VyIHRvIHJlLWNvbXBpbGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAgICAgICAgICAgICAgICAgKi9cblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIGRlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIHVuc2FmZURlbGltaXRlcnM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB1bnNhZmVEZWxpbWl0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICB1bnNhZmVEZWxpbWl0ZXJzID0gdmFsO1xuICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XG59KTtcblxudmFyIHdhcm4gPSB1bmRlZmluZWQ7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IHVuZGVmaW5lZDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcblxuICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1Z1ZSB3YXJuXTogJyArIG1zZyArICh2bSA/IGZvcm1hdENvbXBvbmVudE5hbWUodm0pIDogJycpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5faXNWdWUgPyB2bS4kb3B0aW9ucy5uYW1lIDogdm0ubmFtZTtcbiAgICAgIHJldHVybiBuYW1lID8gJyAoZm91bmQgaW4gY29tcG9uZW50OiA8JyArIGh5cGhlbmF0ZShuYW1lKSArICc+KScgOiAnJztcbiAgICB9O1xuICB9KSgpO1xufVxuXG4vKipcbiAqIEFwcGVuZCB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZFdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZVdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVXaXRoVHJhbnNpdGlvbihlbCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgLTEsIGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmUoZWwpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIEFwcGx5IHRyYW5zaXRpb25zIHdpdGggYW4gb3BlcmF0aW9uIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgMTogZW50ZXJcbiAqICAgICAgICAgICAgICAgICAtMTogbGVhdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gdGhlIGFjdHVhbCBET00gb3BlcmF0aW9uXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRyYW5zaXRpb24oZWwsIGRpcmVjdGlvbiwgb3AsIHZtLCBjYikge1xuICB2YXIgdHJhbnNpdGlvbiA9IGVsLl9fdl90cmFucztcbiAgaWYgKCF0cmFuc2l0aW9uIHx8XG4gIC8vIHNraXAgaWYgdGhlcmUgYXJlIG5vIGpzIGhvb2tzIGFuZCBDU1MgdHJhbnNpdGlvbiBpc1xuICAvLyBub3Qgc3VwcG9ydGVkXG4gICF0cmFuc2l0aW9uLmhvb2tzICYmICF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgLy8gc2tpcCB0cmFuc2l0aW9ucyBmb3IgaW5pdGlhbCBjb21waWxlXG4gICF2bS5faXNDb21waWxlZCB8fFxuICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgbWFuaXB1bGF0ZWQgYnkgYSBwYXJlbnQgZGlyZWN0aXZlXG4gIC8vIGR1cmluZyB0aGUgcGFyZW50J3MgY29tcGlsYXRpb24gcGhhc2UsIHNraXAgdGhlXG4gIC8vIGFuaW1hdGlvbi5cbiAgdm0uJHBhcmVudCAmJiAhdm0uJHBhcmVudC5faXNDb21waWxlZCkge1xuICAgIG9wKCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYWN0aW9uID0gZGlyZWN0aW9uID4gMCA/ICdlbnRlcicgOiAnbGVhdmUnO1xuICB0cmFuc2l0aW9uW2FjdGlvbl0ob3AsIGNiKTtcbn1cblxudmFyIHRyYW5zaXRpb24gPSBPYmplY3QuZnJlZXplKHtcbiAgYXBwZW5kV2l0aFRyYW5zaXRpb246IGFwcGVuZFdpdGhUcmFuc2l0aW9uLFxuICBiZWZvcmVXaXRoVHJhbnNpdGlvbjogYmVmb3JlV2l0aFRyYW5zaXRpb24sXG4gIHJlbW92ZVdpdGhUcmFuc2l0aW9uOiByZW1vdmVXaXRoVHJhbnNpdGlvbixcbiAgYXBwbHlUcmFuc2l0aW9uOiBhcHBseVRyYW5zaXRpb25cbn0pO1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWw7XG4gICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBzZWxlY3Rvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICogTm90ZTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zIHNob3VsZCB3b3JrIGhlcmVcbiAqIGJ1dCBhbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgY29tbWVudCBub2RlcyBpbiBwaGFudG9tanMsXG4gKiBtYWtpbmcgdW5pdCB0ZXN0cyBkaWZmaWN1bHQuIFRoaXMgaXMgZml4ZWQgYnkgZG9pbmcgdGhlXG4gKiBjb250YWlucygpIGNoZWNrIG9uIHRoZSBub2RlJ3MgcGFyZW50Tm9kZSBpbnN0ZWFkIG9mXG4gKiB0aGUgbm9kZSBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGluRG9jKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gZG9jID09PSBub2RlIHx8IGRvYyA9PT0gcGFyZW50IHx8ICEhKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEgJiYgZG9jLmNvbnRhaW5zKHBhcmVudCkpO1xufVxuXG4vKipcbiAqIEdldCBhbmQgcmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBfYXR0clxuICovXG5cbmZ1bmN0aW9uIGdldEF0dHIobm9kZSwgX2F0dHIpIHtcbiAgdmFyIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKF9hdHRyKTtcbiAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEdldCBhbiBhdHRyaWJ1dGUgd2l0aCBjb2xvbiBvciB2LWJpbmQ6IHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRCaW5kQXR0cihub2RlLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBnZXRBdHRyKG5vZGUsICc6JyArIG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgdmFsID0gZ2V0QXR0cihub2RlLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIENoZWNrIHRoZSBwcmVzZW5jZSBvZiBhIGJpbmQgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzQmluZEF0dHIobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJzonICsgbmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtYmluZDonICsgbmFtZSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGJlZm9yZSB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZShlbCwgdGFyZ2V0KSB7XG4gIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYWZ0ZXIgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBhZnRlcihlbCwgdGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5uZXh0U2libGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGVsIGZyb20gRE9NXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZShlbCkge1xuICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuLyoqXG4gKiBQcmVwZW5kIGVsIHRvIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gcHJlcGVuZChlbCwgdGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQuZmlyc3RDaGlsZCkge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlIHRhcmdldCB3aXRoIGVsXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZXBsYWNlKHRhcmdldCwgZWwpIHtcbiAgdmFyIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV1cbiAqL1xuXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGNiLCB1c2VDYXB0dXJlKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiLCB1c2VDYXB0dXJlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBjYikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYik7XG59XG5cbi8qKlxuICogRm9yIElFOSBjb21wYXQ6IHdoZW4gYm90aCBjbGFzcyBhbmQgOmNsYXNzIGFyZSBwcmVzZW50XG4gKiBnZXRBdHRyaWJ1dGUoJ2NsYXNzJykgcmV0dXJucyB3cm9uZyB2YWx1ZS4uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xuICB2YXIgY2xhc3NuYW1lID0gZWwuY2xhc3NOYW1lO1xuICBpZiAodHlwZW9mIGNsYXNzbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjbGFzc25hbWUgPSBjbGFzc25hbWUuYmFzZVZhbCB8fCAnJztcbiAgfVxuICByZXR1cm4gY2xhc3NuYW1lO1xufVxuXG4vKipcbiAqIEluIElFOSwgc2V0QXR0cmlidXRlKCdjbGFzcycpIHdpbGwgcmVzdWx0IGluIGVtcHR5IGNsYXNzXG4gKiBpZiB0aGUgZWxlbWVudCBhbHNvIGhhcyB0aGUgOmNsYXNzIGF0dHJpYnV0ZTsgSG93ZXZlciBpblxuICogUGhhbnRvbUpTLCBzZXR0aW5nIGBjbGFzc05hbWVgIGRvZXMgbm90IHdvcmsgb24gU1ZHIGVsZW1lbnRzLi4uXG4gKiBTbyB3ZSBoYXZlIHRvIGRvIGEgY29uZGl0aW9uYWwgY2hlY2sgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmICEvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xzO1xuICB9IGVsc2Uge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBnZXRDbGFzcyhlbCkgKyAnICc7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBzZXRDbGFzcyhlbCwgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBJRSAmIFNWR1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIGdldENsYXNzKGVsKSArICcgJztcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgc2V0Q2xhc3MoZWwsIGN1ci50cmltKCkpO1xuICB9XG4gIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCByYXcgY29udGVudCBpbnNpZGUgYW4gZWxlbWVudCBpbnRvIGEgdGVtcG9yYXJ5XG4gKiBjb250YWluZXIgZGl2XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBhc0ZyYWdtZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnQoZWwsIGFzRnJhZ21lbnQpIHtcbiAgdmFyIGNoaWxkO1xuICB2YXIgcmF3Q29udGVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1RlbXBsYXRlKGVsKSAmJiBpc0ZyYWdtZW50KGVsLmNvbnRlbnQpKSB7XG4gICAgZWwgPSBlbC5jb250ZW50O1xuICB9XG4gIGlmIChlbC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB0cmltTm9kZShlbCk7XG4gICAgcmF3Q29udGVudCA9IGFzRnJhZ21lbnQgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgIHJhd0NvbnRlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3Q29udGVudDtcbn1cblxuLyoqXG4gKiBUcmltIHBvc3NpYmxlIGVtcHR5IGhlYWQvdGFpbCB0ZXh0IGFuZCBjb21tZW50XG4gKiBub2RlcyBpbnNpZGUgYSBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cblxuZnVuY3Rpb24gdHJpbU5vZGUobm9kZSkge1xuICB2YXIgY2hpbGQ7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlcXVlbmNlcyAqL1xuICB3aGlsZSAoKGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBpc1RyaW1tYWJsZShjaGlsZCkpKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbiAgd2hpbGUgKChjaGlsZCA9IG5vZGUubGFzdENoaWxkLCBpc1RyaW1tYWJsZShjaGlsZCkpKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZXF1ZW5jZXMgKi9cbn1cblxuZnVuY3Rpb24gaXNUcmltbWFibGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAhbm9kZS5kYXRhLnRyaW0oKSB8fCBub2RlLm5vZGVUeXBlID09PSA4KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgdGVtcGxhdGUgdGFnLlxuICogTm90ZSBpZiB0aGUgdGVtcGxhdGUgYXBwZWFycyBpbnNpZGUgYW4gU1ZHIGl0cyB0YWdOYW1lXG4gKiB3aWxsIGJlIGluIGxvd2VyY2FzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZW1wbGF0ZSc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIFwiYW5jaG9yXCIgZm9yIHBlcmZvcm1pbmcgZG9tIGluc2VydGlvbi9yZW1vdmFscy5cbiAqIFRoaXMgaXMgdXNlZCBpbiBhIG51bWJlciBvZiBzY2VuYXJpb3M6XG4gKiAtIGZyYWdtZW50IGluc3RhbmNlXG4gKiAtIHYtaHRtbFxuICogLSB2LWlmXG4gKiAtIHYtZm9yXG4gKiAtIGNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBlcnNpc3QgLSBJRSB0cmFzaGVzIGVtcHR5IHRleHROb2RlcyBvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVOb2RlKHRydWUpLCBzbyBpbiBjZXJ0YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlcyB0aGUgYW5jaG9yIG5lZWRzIHRvIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub24tZW1wdHkgdG8gYmUgcGVyc2lzdGVkIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuXG4gKiBAcmV0dXJuIHtDb21tZW50fFRleHR9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQW5jaG9yKGNvbnRlbnQsIHBlcnNpc3QpIHtcbiAgdmFyIGFuY2hvciA9IGNvbmZpZy5kZWJ1ZyA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCkgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwZXJzaXN0ID8gJyAnIDogJycpO1xuICBhbmNob3IuX192X2FuY2hvciA9IHRydWU7XG4gIHJldHVybiBhbmNob3I7XG59XG5cbi8qKlxuICogRmluZCBhIGNvbXBvbmVudCByZWYgYXR0cmlidXRlIHRoYXQgc3RhcnRzIHdpdGggJC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ3x1bmRlZmluZWR9XG4gKi9cblxudmFyIHJlZlJFID0gL152LXJlZjovO1xuXG5mdW5jdGlvbiBmaW5kUmVmKG5vZGUpIHtcbiAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgdmFyIGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAocmVmUkUudGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gY2FtZWxpemUobmFtZS5yZXBsYWNlKHJlZlJFLCAnJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcCBhIGZ1bmN0aW9uIHRvIGEgcmFuZ2Ugb2Ygbm9kZXMgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gKi9cblxuZnVuY3Rpb24gbWFwTm9kZVJhbmdlKG5vZGUsIGVuZCwgb3ApIHtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlIChub2RlICE9PSBlbmQpIHtcbiAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBvcChub2RlKTtcbiAgICBub2RlID0gbmV4dDtcbiAgfVxuICBvcChlbmQpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAqIHRoZSBub2RlcyBpbiBhIGZyYWdtZW50IHdpdGggY29ycmVjdCBvcmRlcmluZyxcbiAqIGFuZCBjYWxsIGNhbGxiYWNrIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIHZtLCBmcmFnLCBjYikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVtb3ZlZCA9IDA7XG4gIHZhciBub2RlcyA9IFtdO1xuICBtYXBOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZW5kKSBkb25lID0gdHJ1ZTtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgIHJlbW92ZVdpdGhUcmFuc2l0aW9uKG5vZGUsIHZtLCBvblJlbW92ZWQpO1xuICB9KTtcbiAgZnVuY3Rpb24gb25SZW1vdmVkKCkge1xuICAgIHJlbW92ZWQrKztcbiAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNGcmFnbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbiAgfVxufVxuXG52YXIgY29tbW9uVGFnUkUgPSAvXihkaXZ8cHxzcGFufGltZ3xhfGJ8aXxicnx1bHxvbHxsaXxoMXxoMnxoM3xoNHxoNXxoNnxjb2RlfHByZXx0YWJsZXx0aHx0ZHx0cnxmb3JtfGxhYmVsfGlucHV0fHNlbGVjdHxvcHRpb258bmF2fGFydGljbGV8c2VjdGlvbnxoZWFkZXJ8Zm9vdGVyKSQvaTtcbnZhciByZXNlcnZlZFRhZ1JFID0gL14oc2xvdHxwYXJ0aWFsfGNvbXBvbmVudCkkL2k7XG5cbnZhciBpc1Vua25vd25FbGVtZW50ID0gdW5kZWZpbmVkO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaXNVbmtub3duRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgdGFnKSB7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgcmV0dXJuIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8IGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSAmJlxuICAgICAgICAvLyBDaHJvbWUgcmV0dXJucyB1bmtub3duIGZvciBzZXZlcmFsIEhUTUw1IGVsZW1lbnRzLlxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTQwNTI2XG4gICAgICAgIC8vIEZpcmVmb3ggcmV0dXJucyB1bmtub3duIGZvciBzb21lIFwiSW50ZXJhY3RpdmUgZWxlbWVudHMuXCJcbiAgICAgICAgIS9eKGRhdGF8dGltZXxydGN8cmJ8ZGV0YWlsc3xkaWFsb2d8c3VtbWFyeSkkLy50ZXN0KHRhZylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQsIGlmIHllcyByZXR1cm4gaXRzXG4gKiBjb21wb25lbnQgaWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgaWYgKCFjb21tb25UYWdSRS50ZXN0KHRhZykgJiYgIXJlc2VydmVkVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgaWYgKHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpIHtcbiAgICAgIHJldHVybiB7IGlkOiB0YWcgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzID0gaGFzQXR0cnMgJiYgZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChpcykge1xuICAgICAgICByZXR1cm4gaXM7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkVGFnID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCAmJiBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwW3RhZ107XG4gICAgICAgIGlmIChleHBlY3RlZFRhZykge1xuICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSAnICsgJ2RpZCB5b3UgbWVhbiA8JyArIGV4cGVjdGVkVGFnICsgJz4/ICcgKyAnSFRNTCBpcyBjYXNlLWluc2Vuc2l0aXZlLCByZW1lbWJlciB0byB1c2Uga2ViYWItY2FzZSBpbiB0ZW1wbGF0ZXMuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmtub3duRWxlbWVudChlbCwgdGFnKSkge1xuICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgKyAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc0F0dHJzKSB7XG4gICAgcmV0dXJuIGdldElzQmluZGluZyhlbCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgXCJpc1wiIGJpbmRpbmcgZnJvbSBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldElzQmluZGluZyhlbCwgb3B0aW9ucykge1xuICAvLyBkeW5hbWljIHN5bnRheFxuICB2YXIgZXhwID0gZWwuZ2V0QXR0cmlidXRlKCdpcycpO1xuICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgZXhwKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgcmV0dXJuIHsgaWQ6IGV4cCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHAgPSBnZXRCaW5kQXR0cihlbCwgJ2lzJyk7XG4gICAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4geyBpZDogZXhwLCBkeW5hbWljOiB0cnVlIH07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICpcbiAqIEFsbCBzdHJhdGVneSBmdW5jdGlvbnMgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0geyp9IHBhcmVudFZhbFxuICogQHBhcmFtIHsqfSBjaGlsZFZhbFxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqL1xuXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VEYXRhKHRvLCBmcm9tKSB7XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICBmb3IgKGtleSBpbiBmcm9tKSB7XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRvVmFsKSAmJiBpc09iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJywgdm0pO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKGNoaWxkVmFsLmNhbGwodGhpcyksIHBhcmVudFZhbC5jYWxsKHRoaXMpKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh2bSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbFxuICovXG5cbnN0cmF0cy5lbCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtICYmIGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZWxcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJywgdm0pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmV0ID0gY2hpbGRWYWwgfHwgcGFyZW50VmFsO1xuICAvLyBpbnZva2UgdGhlIGVsZW1lbnQgZmFjdG9yeSBpZiB0aGlzIGlzIGluc3RhbmNlIG1lcmdlXG4gIHJldHVybiB2bSAmJiB0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nID8gcmV0LmNhbGwodm0pIDogcmV0O1xufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcGFyYW0gYXR0cmlidXRlcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuXG5zdHJhdHMuaW5pdCA9IHN0cmF0cy5jcmVhdGVkID0gc3RyYXRzLnJlYWR5ID0gc3RyYXRzLmF0dGFjaGVkID0gc3RyYXRzLmRldGFjaGVkID0gc3RyYXRzLmJlZm9yZUNvbXBpbGUgPSBzdHJhdHMuY29tcGlsZWQgPSBzdHJhdHMuYmVmb3JlRGVzdHJveSA9IHN0cmF0cy5kZXN0cm95ZWQgPSBzdHJhdHMuYWN0aXZhdGUgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKSA6IGlzQXJyYXkoY2hpbGRWYWwpID8gY2hpbGRWYWwgOiBbY2hpbGRWYWxdIDogcGFyZW50VmFsO1xufTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyhwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsID8gZXh0ZW5kKHJlcywgZ3VhcmRBcnJheUFzc2V0cyhjaGlsZFZhbCkpIDogcmVzO1xufVxuXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIEV2ZW50cyAmIFdhdGNoZXJzLlxuICpcbiAqIEV2ZW50cyAmIHdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy53YXRjaCA9IHN0cmF0cy5ldmVudHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsO1xuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIWlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50ID8gcGFyZW50LmNvbmNhdChjaGlsZCkgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cblxuc3RyYXRzLnByb3BzID0gc3RyYXRzLm1ldGhvZHMgPSBzdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsO1xuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiBkZWZhdWx0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgY29tcG9uZW50IG9wdGlvbnMgZ2V0IGNvbnZlcnRlZCB0byBhY3R1YWxcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50cyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuY29tcG9uZW50cyA9IGd1YXJkQXJyYXlBc3NldHMob3B0aW9ucy5jb21wb25lbnRzKTtcbiAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoY29tcG9uZW50cyk7XG4gICAgdmFyIGRlZjtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hcCA9IG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXAgPSB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gaWRzW2ldO1xuICAgICAgaWYgKGNvbW1vblRhZ1JFLnRlc3Qoa2V5KSB8fCByZXNlcnZlZFRhZ1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gcmVjb3JkIGEgYWxsIGxvd2VyY2FzZSA8LT4ga2ViYWItY2FzZSBtYXBwaW5nIGZvclxuICAgICAgLy8gcG9zc2libGUgY3VzdG9tIGVsZW1lbnQgY2FzZSBlcnJvciB3YXJuaW5nXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtYXBba2V5LnJlcGxhY2UoLy0vZywgJycpLnRvTG93ZXJDYXNlKCldID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICB9XG4gICAgICBkZWYgPSBjb21wb25lbnRzW2tleV07XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChkZWYpKSB7XG4gICAgICAgIGNvbXBvbmVudHNba2V5XSA9IFZ1ZS5leHRlbmQoZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBndWFyZFByb3BzKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgdmFyIGksIHZhbDtcbiAgaWYgKGlzQXJyYXkocHJvcHMpKSB7XG4gICAgb3B0aW9ucy5wcm9wcyA9IHt9O1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9wc1t2YWxdID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodmFsLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9wc1t2YWwubmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleXNbaV1dO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcHNba2V5c1tpXV0gPSB7IHR5cGU6IHZhbCB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEd1YXJkIGFuIEFycmF5LWZvcm1hdCBhc3NldHMgb3B0aW9uIGFuZCBjb252ZXJ0ZWQgaXRcbiAqIGludG8gdGhlIGtleS12YWx1ZSBPYmplY3QgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhc3NldHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBndWFyZEFycmF5QXNzZXRzKGFzc2V0cykge1xuICBpZiAoaXNBcnJheShhc3NldHMpKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpID0gYXNzZXRzLmxlbmd0aDtcbiAgICB2YXIgYXNzZXQ7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXNzZXQgPSBhc3NldHNbaV07XG4gICAgICB2YXIgaWQgPSB0eXBlb2YgYXNzZXQgPT09ICdmdW5jdGlvbicgPyBhc3NldC5vcHRpb25zICYmIGFzc2V0Lm9wdGlvbnMubmFtZSB8fCBhc3NldC5pZCA6IGFzc2V0Lm5hbWUgfHwgYXNzZXQuaWQ7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXJyYXktc3ludGF4IGFzc2V0cyBtdXN0IHByb3ZpZGUgYSBcIm5hbWVcIiBvciBcImlkXCIgZmllbGQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNbaWRdID0gYXNzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIGFzc2V0cztcbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGlsZFxuICogQHBhcmFtIHtWdWV9IFt2bV0gLSBpZiB2bSBpcyBwcmVzZW50LCBpbmRpY2F0ZXMgdGhpcyBpc1xuICogICAgICAgICAgICAgICAgICAgICBhbiBpbnN0YW50aWF0aW9uIG1lcmdlLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICBndWFyZENvbXBvbmVudHMoY2hpbGQpO1xuICBndWFyZFByb3BzKGNoaWxkKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY2hpbGQucHJvcHNEYXRhICYmICF2bSkge1xuICAgICAgd2FybigncHJvcHNEYXRhIGNhbiBvbmx5IGJlIHVzZWQgYXMgYW4gaW5zdGFudGlhdGlvbiBvcHRpb24uJyk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGlmIChjaGlsZFsnZXh0ZW5kcyddKSB7XG4gICAgcGFyZW50ID0gdHlwZW9mIGNoaWxkWydleHRlbmRzJ10gPT09ICdmdW5jdGlvbicgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZFsnZXh0ZW5kcyddLm9wdGlvbnMsIHZtKSA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkWydleHRlbmRzJ10sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICB2YXIgbWl4aW5PcHRpb25zID0gbWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlID8gbWl4aW4ub3B0aW9ucyA6IG1peGluO1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW5PcHRpb25zLCB2bSk7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdhcm5NaXNzaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R8RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsIHR5cGUsIGlkLCB3YXJuTWlzc2luZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIHZhciBjYW1lbGl6ZWRJZDtcbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHxcbiAgLy8gY2FtZWxDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKV0gfHxcbiAgLy8gUGFzY2FsIENhc2UgSURcbiAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGVwKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG5cbi8qKlxuICogQWRkIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy4kcmVtb3ZlKHN1Yik7XG59O1xuXG4vKipcbiAqIEFkZCBzZWxmIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgdGFyZ2V0IHdhdGNoZXIuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xufTtcblxuLyoqXG4gKiBOb3RpZnkgYWxsIHN1YnNjcmliZXJzIG9mIGEgbmV3IHZhbHVlLlxuICovXG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFibGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdG9BcnJheSh0aGlzLnN1YnMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5cbjtbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJywgJ3NvcnQnLCAncmV2ZXJzZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IoKSB7XG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCB3aXRoIGEgbmV3IHZhbHVlXG4gKiBhbmQgZW1pdHMgY29ycmVzcG9uZGluZyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHsqfSAtIHJlcGxhY2VkIGVsZW1lbnRcbiAqL1xuXG5kZWYoYXJyYXlQcm90bywgJyRzZXQnLCBmdW5jdGlvbiAkc2V0KGluZGV4LCB2YWwpIHtcbiAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhpcy5sZW5ndGggPSBOdW1iZXIoaW5kZXgpICsgMTtcbiAgfVxuICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEsIHZhbClbMF07XG59KTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGF0IGdpdmVuIGluZGV4IG9yIHRhcmdldCBlbGVtZW50IHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0geyp9IGl0ZW1cbiAqL1xuXG5kZWYoYXJyYXlQcm90bywgJyRyZW1vdmUnLCBmdW5jdGlvbiAkcmVtb3ZlKGl0ZW0pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghdGhpcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLCBpdGVtKTtcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59KTtcblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIGluIGNlcnRhaW4gY2FzZXMsIGUuZy5cbiAqIHYtZm9yIHNjb3BlIGFsaWFzIGFuZCBwcm9wcywgd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uXG4gKiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWUgdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogU28gd2hlbmV2ZXIgd2Ugd2FudCB0byBzZXQgYSByZWFjdGl2ZSBwcm9wZXJ0eSB3aXRob3V0IGZvcmNpbmdcbiAqIGNvbnZlcnNpb24gb24gdGhlIG5ldyB2YWx1ZSwgd2Ugd3JhcCB0aGF0IGNhbGwgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gKi9cblxudmFyIHNob3VsZENvbnZlcnQgPSB0cnVlO1xuXG5mdW5jdGlvbiB3aXRob3V0Q29udmVyc2lvbihmbikge1xuICBzaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gIGZuKCk7XG4gIHNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90byA/IHByb3RvQXVnbWVudCA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jb252ZXJ0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHByb3BlcnR5IGludG8gZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZW1pdFxuICogdGhlIGV2ZW50cyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC9jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgZGVmaW5lUmVhY3RpdmUodGhpcy52YWx1ZSwga2V5LCB2YWwpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gb3duZXIgdm0sIHNvIHRoYXQgd2hlbiAkc2V0LyRkZWxldGUgbXV0YXRpb25zXG4gKiBoYXBwZW4gd2UgY2FuIG5vdGlmeSBvd25lciB2bXMgdG8gcHJveHkgdGhlIGtleXMgYW5kXG4gKiBkaWdlc3QgdGhlIHdhdGNoZXJzLiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIG9iamVjdFxuICogaXMgb2JzZXJ2ZWQgYXMgYW4gaW5zdGFuY2UncyByb290ICRkYXRhLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5hZGRWbSA9IGZ1bmN0aW9uICh2bSkge1xuICAodGhpcy52bXMgfHwgKHRoaXMudm1zID0gW10pKS5wdXNoKHZtKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKTtcbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqL1xuXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvXG4gKi9cblxuZnVuY3Rpb24gY29weUF1Z21lbnQodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge09ic2VydmVyfHVuZGVmaW5lZH1cbiAqIEBzdGF0aWNcbiAqL1xuXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCB2bSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChzaG91bGRDb252ZXJ0ICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiYgIXZhbHVlLl9pc1Z1ZSkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAob2IgJiYgdm0pIHtcbiAgICBvYi5hZGRWbSh2bSk7XG4gIH1cbiAgcmV0dXJuIG9iO1xufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5cbnZhciB1dGlsID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSxcblx0c2V0OiBzZXQsXG5cdGRlbDogZGVsLFxuXHRoYXNPd246IGhhc093bixcblx0aXNMaXRlcmFsOiBpc0xpdGVyYWwsXG5cdGlzUmVzZXJ2ZWQ6IGlzUmVzZXJ2ZWQsXG5cdF90b1N0cmluZzogX3RvU3RyaW5nLFxuXHR0b051bWJlcjogdG9OdW1iZXIsXG5cdHRvQm9vbGVhbjogdG9Cb29sZWFuLFxuXHRzdHJpcFF1b3Rlczogc3RyaXBRdW90ZXMsXG5cdGNhbWVsaXplOiBjYW1lbGl6ZSxcblx0aHlwaGVuYXRlOiBoeXBoZW5hdGUsXG5cdGNsYXNzaWZ5OiBjbGFzc2lmeSxcblx0YmluZDogYmluZCxcblx0dG9BcnJheTogdG9BcnJheSxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0aXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcblx0ZGVmOiBkZWYsXG5cdGRlYm91bmNlOiBfZGVib3VuY2UsXG5cdGluZGV4T2Y6IGluZGV4T2YsXG5cdGNhbmNlbGxhYmxlOiBjYW5jZWxsYWJsZSxcblx0bG9vc2VFcXVhbDogbG9vc2VFcXVhbCxcblx0aXNBcnJheTogaXNBcnJheSxcblx0aGFzUHJvdG86IGhhc1Byb3RvLFxuXHRpbkJyb3dzZXI6IGluQnJvd3Nlcixcblx0ZGV2dG9vbHM6IGRldnRvb2xzLFxuXHRpc0lFOiBpc0lFLFxuXHRpc0lFOTogaXNJRTksXG5cdGlzQW5kcm9pZDogaXNBbmRyb2lkLFxuXHRpc0lvczogaXNJb3MsXG5cdGlvc1ZlcnNpb25NYXRjaDogaW9zVmVyc2lvbk1hdGNoLFxuXHRpb3NWZXJzaW9uOiBpb3NWZXJzaW9uLFxuXHRoYXNNdXRhdGlvbk9ic2VydmVyQnVnOiBoYXNNdXRhdGlvbk9ic2VydmVyQnVnLFxuXHRnZXQgdHJhbnNpdGlvblByb3AgKCkgeyByZXR1cm4gdHJhbnNpdGlvblByb3A7IH0sXG5cdGdldCB0cmFuc2l0aW9uRW5kRXZlbnQgKCkgeyByZXR1cm4gdHJhbnNpdGlvbkVuZEV2ZW50OyB9LFxuXHRnZXQgYW5pbWF0aW9uUHJvcCAoKSB7IHJldHVybiBhbmltYXRpb25Qcm9wOyB9LFxuXHRnZXQgYW5pbWF0aW9uRW5kRXZlbnQgKCkgeyByZXR1cm4gYW5pbWF0aW9uRW5kRXZlbnQ7IH0sXG5cdG5leHRUaWNrOiBuZXh0VGljayxcblx0Z2V0IF9TZXQgKCkgeyByZXR1cm4gX1NldDsgfSxcblx0cXVlcnk6IHF1ZXJ5LFxuXHRpbkRvYzogaW5Eb2MsXG5cdGdldEF0dHI6IGdldEF0dHIsXG5cdGdldEJpbmRBdHRyOiBnZXRCaW5kQXR0cixcblx0aGFzQmluZEF0dHI6IGhhc0JpbmRBdHRyLFxuXHRiZWZvcmU6IGJlZm9yZSxcblx0YWZ0ZXI6IGFmdGVyLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0cHJlcGVuZDogcHJlcGVuZCxcblx0cmVwbGFjZTogcmVwbGFjZSxcblx0b246IG9uLFxuXHRvZmY6IG9mZixcblx0c2V0Q2xhc3M6IHNldENsYXNzLFxuXHRhZGRDbGFzczogYWRkQ2xhc3MsXG5cdHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcblx0ZXh0cmFjdENvbnRlbnQ6IGV4dHJhY3RDb250ZW50LFxuXHR0cmltTm9kZTogdHJpbU5vZGUsXG5cdGlzVGVtcGxhdGU6IGlzVGVtcGxhdGUsXG5cdGNyZWF0ZUFuY2hvcjogY3JlYXRlQW5jaG9yLFxuXHRmaW5kUmVmOiBmaW5kUmVmLFxuXHRtYXBOb2RlUmFuZ2U6IG1hcE5vZGVSYW5nZSxcblx0cmVtb3ZlTm9kZVJhbmdlOiByZW1vdmVOb2RlUmFuZ2UsXG5cdGlzRnJhZ21lbnQ6IGlzRnJhZ21lbnQsXG5cdGdldE91dGVySFRNTDogZ2V0T3V0ZXJIVE1MLFxuXHRtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcblx0cmVzb2x2ZUFzc2V0OiByZXNvbHZlQXNzZXQsXG5cdGNoZWNrQ29tcG9uZW50QXR0cjogY2hlY2tDb21wb25lbnRBdHRyLFxuXHRjb21tb25UYWdSRTogY29tbW9uVGFnUkUsXG5cdHJlc2VydmVkVGFnUkU6IHJlc2VydmVkVGFnUkUsXG5cdGdldCB3YXJuICgpIHsgcmV0dXJuIHdhcm47IH1cbn0pO1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFRoZSBtYWluIGluaXQgc2VxdWVuY2UuIFRoaXMgaXMgY2FsbGVkIGZvciBldmVyeVxuICAgKiBpbnN0YW5jZSwgaW5jbHVkaW5nIG9uZXMgdGhhdCBhcmUgY3JlYXRlZCBmcm9tIGV4dGVuZGVkXG4gICAqIGNvbnN0cnVjdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGlzIG9wdGlvbnMgb2JqZWN0IHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgb2YgbWVyZ2luZyBjbGFzc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYW5kIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgdGhpcy4kcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgdGhpcy4kcm9vdCA9IHRoaXMuJHBhcmVudCA/IHRoaXMuJHBhcmVudC4kcm9vdCA6IHRoaXM7XG4gICAgdGhpcy4kY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLiRyZWZzID0ge307IC8vIGNoaWxkIHZtIHJlZmVyZW5jZXNcbiAgICB0aGlzLiRlbHMgPSB7fTsgLy8gZWxlbWVudCByZWZlcmVuY2VzXG4gICAgdGhpcy5fd2F0Y2hlcnMgPSBbXTsgLy8gYWxsIHdhdGNoZXJzIGFzIGFuIGFycmF5XG4gICAgdGhpcy5fZGlyZWN0aXZlcyA9IFtdOyAvLyBhbGwgZGlyZWN0aXZlc1xuXG4gICAgLy8gYSB1aWRcbiAgICB0aGlzLl91aWQgPSB1aWQrKztcblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdGhpcy5faXNWdWUgPSB0cnVlO1xuXG4gICAgLy8gZXZlbnRzIGJvb2trZWVwaW5nXG4gICAgdGhpcy5fZXZlbnRzID0ge307IC8vIHJlZ2lzdGVyZWQgY2FsbGJhY2tzXG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSB7fTsgLy8gZm9yICRicm9hZGNhc3Qgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBmcmFnbWVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5faXNGcmFnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZyYWdtZW50ID0gLy8gQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgdGhpcy5fZnJhZ21lbnRTdGFydCA9IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG4gICAgdGhpcy5fZnJhZ21lbnRFbmQgPSBudWxsOyAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuXG4gICAgLy8gbGlmZWN5Y2xlIHN0YXRlXG4gICAgdGhpcy5faXNDb21waWxlZCA9IHRoaXMuX2lzRGVzdHJveWVkID0gdGhpcy5faXNSZWFkeSA9IHRoaXMuX2lzQXR0YWNoZWQgPSB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdGhpcy5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fdW5saW5rRm4gPSBudWxsO1xuXG4gICAgLy8gY29udGV4dDpcbiAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgLy8gYW5kIGl0cyBob3N0LlxuICAgIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLl9jb250ZXh0IHx8IHRoaXMuJHBhcmVudDtcblxuICAgIC8vIHNjb3BlOlxuICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICB0aGlzLl9zY29wZSA9IG9wdGlvbnMuX3Njb3BlO1xuXG4gICAgLy8gZnJhZ21lbnQ6XG4gICAgLy8gaWYgdGhpcyBpbnN0YW5jZSBpcyBjb21waWxlZCBpbnNpZGUgYSBGcmFnbWVudCwgaXRcbiAgICAvLyBuZWVkcyB0byByZWlnc3RlciBpdHNlbGYgYXMgYSBjaGlsZCBvZiB0aGF0IGZyYWdtZW50XG4gICAgLy8gZm9yIGF0dGFjaC9kZXRhY2ggdG8gd29yayBwcm9wZXJseS5cbiAgICB0aGlzLl9mcmFnID0gb3B0aW9ucy5fZnJhZztcbiAgICBpZiAodGhpcy5fZnJhZykge1xuICAgICAgdGhpcy5fZnJhZy5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIHB1c2ggc2VsZiBpbnRvIHBhcmVudCAvIHRyYW5zY2x1c2lvbiBob3N0XG4gICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50LiRjaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIG1lcmdlIG9wdGlvbnMuXG4gICAgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zLCBvcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIHNldCByZWZcbiAgICB0aGlzLl91cGRhdGVSZWYoKTtcblxuICAgIC8vIGluaXRpYWxpemUgZGF0YSBhcyBlbXB0eSBvYmplY3QuXG4gICAgLy8gaXQgd2lsbCBiZSBmaWxsZWQgdXAgaW4gX2luaXREYXRhKCkuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgLy8gY2FsbCBpbml0IGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnaW5pdCcpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9ic2VydmF0aW9uIGFuZCBzY29wZSBpbmhlcml0YW5jZS5cbiAgICB0aGlzLl9pbml0U3RhdGUoKTtcblxuICAgIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAvLyBjYWxsIGNyZWF0ZWQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdjcmVhdGVkJyk7XG5cbiAgICAvLyBpZiBgZWxgIG9wdGlvbiBpcyBwYXNzZWQsIHN0YXJ0IGNvbXBpbGF0aW9uLlxuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLiRtb3VudChvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwYXRoQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbi8vIGFjdGlvbnNcbnZhciBBUFBFTkQgPSAwO1xudmFyIFBVU0ggPSAxO1xudmFyIElOQ19TVUJfUEFUSF9ERVBUSCA9IDI7XG52YXIgUFVTSF9TVUJfUEFUSCA9IDM7XG5cbi8vIHN0YXRlc1xudmFyIEJFRk9SRV9QQVRIID0gMDtcbnZhciBJTl9QQVRIID0gMTtcbnZhciBCRUZPUkVfSURFTlQgPSAyO1xudmFyIElOX0lERU5UID0gMztcbnZhciBJTl9TVUJfUEFUSCA9IDQ7XG52YXIgSU5fU0lOR0xFX1FVT1RFID0gNTtcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA2O1xudmFyIEFGVEVSX1BBVEggPSA3O1xudmFyIEVSUk9SID0gODtcblxudmFyIHBhdGhTdGF0ZU1hY2hpbmUgPSBbXTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfUEFUSF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfUEFUSF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfSURFTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0lERU5UXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0lERU5UXSA9IHtcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnMCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ3dzJzogW0lOX1BBVEgsIFBVU0hdLFxuICAnLic6IFtCRUZPUkVfSURFTlQsIFBVU0hdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgUFVTSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSCwgUFVTSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU1VCX1BBVEhdID0ge1xuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1wiJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIElOQ19TVUJfUEFUSF9ERVBUSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hfU1VCX1BBVEhdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0RPVUJMRV9RVU9URV0gPSB7XG4gICdcIic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUoY2gpIHtcbiAgaWYgKGNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ2VvZic7XG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDVCOiAvLyBbXG4gICAgY2FzZSAweDVEOiAvLyBdXG4gICAgY2FzZSAweDJFOiAvLyAuXG4gICAgY2FzZSAweDIyOiAvLyBcIlxuICAgIGNhc2UgMHgyNzogLy8gJ1xuICAgIGNhc2UgMHgzMDpcbiAgICAgIC8vIDBcbiAgICAgIHJldHVybiBjaDtcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDpcbiAgICAgIC8vICRcbiAgICAgIHJldHVybiAnaWRlbnQnO1xuXG4gICAgY2FzZSAweDIwOiAvLyBTcGFjZVxuICAgIGNhc2UgMHgwOTogLy8gVGFiXG4gICAgY2FzZSAweDBBOiAvLyBOZXdsaW5lXG4gICAgY2FzZSAweDBEOiAvLyBSZXR1cm5cbiAgICBjYXNlIDB4QTA6IC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgY2FzZSAweEZFRkY6IC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAvLyBMaW5lIFNlcGFyYXRvclxuICAgIGNhc2UgMHgyMDI5OlxuICAgICAgLy8gUGFyYWdyYXBoIFNlcGFyYXRvclxuICAgICAgcmV0dXJuICd3cyc7XG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoY29kZSA+PSAweDYxICYmIGNvZGUgPD0gMHg3QSB8fCBjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVBKSB7XG4gICAgcmV0dXJuICdpZGVudCc7XG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICByZXR1cm4gJ2Vsc2UnO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIHN1YlBhdGgsIHJldHVybiBpdHMgcGxhaW4gZm9ybSBpZiBpdCBpc1xuICogYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuIE90aGVyd2lzZSBwcmVwZW5kIHRoZVxuICogZHluYW1pYyBpbmRpY2F0b3IgKCopLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0U3ViUGF0aChwYXRoKSB7XG4gIHZhciB0cmltbWVkID0gcGF0aC50cmltKCk7XG4gIC8vIGludmFsaWQgbGVhZGluZyAwXG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJzAnICYmIGlzTmFOKHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0xpdGVyYWwodHJpbW1lZCkgPyBzdHJpcFF1b3Rlcyh0cmltbWVkKSA6ICcqJyArIHRyaW1tZWQ7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbW9kZSA9IEJFRk9SRV9QQVRIO1xuICB2YXIgc3ViUGF0aERlcHRoID0gMDtcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwO1xuXG4gIHZhciBhY3Rpb25zID0gW107XG5cbiAgYWN0aW9uc1tQVVNIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0FQUEVORF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSBuZXdDaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhcjtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tJTkNfU1VCX1BBVEhfREVQVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIHN1YlBhdGhEZXB0aCsrO1xuICB9O1xuXG4gIGFjdGlvbnNbUFVTSF9TVUJfUEFUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN1YlBhdGhEZXB0aCA+IDApIHtcbiAgICAgIHN1YlBhdGhEZXB0aC0tO1xuICAgICAgbW9kZSA9IElOX1NVQl9QQVRIO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YlBhdGhEZXB0aCA9IDA7XG4gICAgICBrZXkgPSBmb3JtYXRTdWJQYXRoKGtleSk7XG4gICAgICBpZiAoa2V5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25zW1BVU0hdKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSgpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBwYXRoW2luZGV4ICsgMV07XG4gICAgaWYgKG1vZGUgPT09IElOX1NJTkdMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gXCInXCIgfHwgbW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgbmV3Q2hhciA9ICdcXFxcJyArIG5leHRDaGFyO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gcGF0aFtpbmRleF07XG5cbiAgICBpZiAoYyA9PT0gJ1xcXFwnICYmIG1heWJlVW5lc2NhcGVRdW90ZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpO1xuICAgIHR5cGVNYXAgPSBwYXRoU3RhdGVNYWNoaW5lW21vZGVdO1xuICAgIHRyYW5zaXRpb24gPSB0eXBlTWFwW3R5cGVdIHx8IHR5cGVNYXBbJ2Vsc2UnXSB8fCBFUlJPUjtcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuOyAvLyBwYXJzZSBlcnJvclxuICAgIH1cblxuICAgIG1vZGUgPSB0cmFuc2l0aW9uWzBdO1xuICAgIGFjdGlvbiA9IGFjdGlvbnNbdHJhbnNpdGlvblsxXV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl07XG4gICAgICBuZXdDaGFyID0gbmV3Q2hhciA9PT0gdW5kZWZpbmVkID8gYyA6IG5ld0NoYXI7XG4gICAgICBpZiAoYWN0aW9uKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBoaXQgPSBwYXRoQ2FjaGUuZ2V0KHBhdGgpO1xuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlKHBhdGgpO1xuICAgIGlmIChoaXQpIHtcbiAgICAgIHBhdGhDYWNoZS5wdXQocGF0aCwgaGl0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhpdDtcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoKG9iaiwgcGF0aCkge1xuICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKHBhdGgpLmdldChvYmopO1xufVxuXG4vKipcbiAqIFdhcm4gYWdhaW5zdCBzZXR0aW5nIG5vbi1leGlzdGVudCByb290IHBhdGggb24gYSB2bS5cbiAqL1xuXG52YXIgd2Fybk5vbkV4aXN0ZW50O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2Fybk5vbkV4aXN0ZW50ID0gZnVuY3Rpb24gKHBhdGgsIHZtKSB7XG4gICAgd2FybignWW91IGFyZSBzZXR0aW5nIGEgbm9uLWV4aXN0ZW50IHBhdGggXCInICsgcGF0aC5yYXcgKyAnXCIgJyArICdvbiBhIHZtIGluc3RhbmNlLiBDb25zaWRlciBwcmUtaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSAnICsgJ3dpdGggdGhlIFwiZGF0YVwiIG9wdGlvbiBmb3IgbW9yZSByZWxpYWJsZSByZWFjdGl2aXR5ICcgKyAnYW5kIGJldHRlciBwZXJmb3JtYW5jZS4nLCB2bSk7XG4gIH07XG59XG5cbi8qKlxuICogU2V0IG9uIGFuIG9iamVjdCBmcm9tIGEgcGF0aFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gc2V0UGF0aChvYmosIHBhdGgsIHZhbCkge1xuICB2YXIgb3JpZ2luYWwgPSBvYmo7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gcGFyc2UocGF0aCk7XG4gIH1cbiAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0LCBrZXk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsYXN0ID0gb2JqO1xuICAgIGtleSA9IHBhdGhbaV07XG4gICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgICAga2V5ID0gcGFyc2VFeHByZXNzaW9uKGtleS5zbGljZSgxKSkuZ2V0LmNhbGwob3JpZ2luYWwsIG9yaWdpbmFsKTtcbiAgICB9XG4gICAgaWYgKGkgPCBsIC0gMSkge1xuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGxhc3QuX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgsIGxhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHNldChsYXN0LCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqLiRzZXQoa2V5LCB2YWwpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb2JqLl9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIHNldChvYmosIGtleSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBwYXRoID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlUGF0aDogcGFyc2VQYXRoLFxuICBnZXRQYXRoOiBnZXRQYXRoLFxuICBzZXRQYXRoOiBzZXRQYXRoXG59KTtcblxudmFyIGV4cHJlc3Npb25DYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxudmFyIGFsbG93ZWRLZXl3b3JkcyA9ICdNYXRoLERhdGUsdGhpcyx0cnVlLGZhbHNlLG51bGwsdW5kZWZpbmVkLEluZmluaXR5LE5hTiwnICsgJ2lzTmFOLGlzRmluaXRlLGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLCcgKyAnZW5jb2RlVVJJQ29tcG9uZW50LHBhcnNlSW50LHBhcnNlRmxvYXQnO1xudmFyIGFsbG93ZWRLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgYWxsb3dlZEtleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpO1xuXG4vLyBrZXl3b3JkcyB0aGF0IGRvbid0IG1ha2Ugc2Vuc2UgaW5zaWRlIGV4cHJlc3Npb25zXG52YXIgaW1wcm9wZXJLZXl3b3JkcyA9ICdicmVhayxjYXNlLGNsYXNzLGNhdGNoLGNvbnN0LGNvbnRpbnVlLGRlYnVnZ2VyLGRlZmF1bHQsJyArICdkZWxldGUsZG8sZWxzZSxleHBvcnQsZXh0ZW5kcyxmaW5hbGx5LGZvcixmdW5jdGlvbixpZiwnICsgJ2ltcG9ydCxpbixpbnN0YW5jZW9mLGxldCxyZXR1cm4sc3VwZXIsc3dpdGNoLHRocm93LHRyeSwnICsgJ3Zhcix3aGlsZSx3aXRoLHlpZWxkLGVudW0sYXdhaXQsaW1wbGVtZW50cyxwYWNrYWdlLCcgKyAncHJvdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWMnO1xudmFyIGltcHJvcGVyS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGltcHJvcGVyS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbnZhciB3c1JFID0gL1xccy9nO1xudmFyIG5ld2xpbmVSRSA9IC9cXG4vZztcbnZhciBzYXZlUkUgPSAvW1xceyxdXFxzKltcXHdcXCRfXStcXHMqOnwoJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmApfG5ldyB8dHlwZW9mIHx2b2lkIC9nO1xudmFyIHJlc3RvcmVSRSA9IC9cIihcXGQrKVwiL2c7XG52YXIgcGF0aFRlc3RSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J1xcXXxcXFtcIi4qP1wiXFxdfFxcW1xcZCtcXF18XFxbW0EtWmEtel8kXVtcXHckXSpcXF0pKiQvO1xudmFyIGlkZW50UkUgPSAvW15cXHckXFwuXSg/OltBLVphLXpfJF1bXFx3JF0qKS9nO1xudmFyIGxpdGVyYWxWYWx1ZVJFJDEgPSAvXig/OnRydWV8ZmFsc2V8bnVsbHx1bmRlZmluZWR8SW5maW5pdHl8TmFOKSQvO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXTtcblxuLyoqXG4gKiBTYXZlIHJlcGxhY2VyXG4gKlxuICogVGhlIHNhdmUgcmVnZXggY2FuIG1hdGNoIHR3byBwb3NzaWJsZSBjYXNlczpcbiAqIDEuIEFuIG9wZW5pbmcgb2JqZWN0IGxpdGVyYWxcbiAqIDIuIEEgc3RyaW5nXG4gKiBJZiBtYXRjaGVkIGFzIGEgcGxhaW4gc3RyaW5nLCB3ZSBuZWVkIHRvIGVzY2FwZSBpdHNcbiAqIG5ld2xpbmVzLCBzaW5jZSB0aGUgc3RyaW5nIG5lZWRzIHRvIGJlIHByZXNlcnZlZCB3aGVuXG4gKiBnZW5lcmF0aW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpc1N0cmluZyAtIHN0ciBpZiBtYXRjaGVkIGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gcGxhY2Vob2xkZXIgd2l0aCBpbmRleFxuICovXG5cbmZ1bmN0aW9uIHNhdmUoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aDtcbiAgc2F2ZWRbaV0gPSBpc1N0cmluZyA/IHN0ci5yZXBsYWNlKG5ld2xpbmVSRSwgJ1xcXFxuJykgOiBzdHI7XG4gIHJldHVybiAnXCInICsgaSArICdcIic7XG59XG5cbi8qKlxuICogUGF0aCByZXdyaXRlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJld3JpdGUocmF3KSB7XG4gIHZhciBjID0gcmF3LmNoYXJBdCgwKTtcbiAgdmFyIHBhdGggPSByYXcuc2xpY2UoMSk7XG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gcGF0aC5pbmRleE9mKCdcIicpID4gLTEgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKSA6IHBhdGg7XG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXN0b3JlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGkgLSBtYXRjaGVkIHNhdmUgaW5kZXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV07XG59XG5cbi8qKlxuICogUmV3cml0ZSBhbiBleHByZXNzaW9uLCBwcmVmaXhpbmcgYWxsIHBhdGggYWNjZXNzb3JzIHdpdGhcbiAqIGBzY29wZS5gIGFuZCBnZW5lcmF0ZSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlR2V0dGVyKGV4cCkge1xuICBpZiAoaW1wcm9wZXJLZXl3b3Jkc1JFLnRlc3QoZXhwKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbiAgLy8gcmVzZXQgc3RhdGVcbiAgc2F2ZWQubGVuZ3RoID0gMDtcbiAgLy8gc2F2ZSBzdHJpbmdzIGFuZCBvYmplY3QgbGl0ZXJhbCBrZXlzXG4gIHZhciBib2R5ID0gZXhwLnJlcGxhY2Uoc2F2ZVJFLCBzYXZlKS5yZXBsYWNlKHdzUkUsICcnKTtcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdXNlIHRoZSByZWdleCBtYXRjaGVzIDEgZXh0cmEgY2hhclxuICBib2R5ID0gKCcgJyArIGJvZHkpLnJlcGxhY2UoaWRlbnRSRSwgcmV3cml0ZSkucmVwbGFjZShyZXN0b3JlUkUsIHJlc3RvcmUpO1xuICByZXR1cm4gbWFrZUdldHRlckZuKGJvZHkpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZ2V0dGVyIGZ1bmN0aW9uLiBSZXF1aXJlcyBldmFsLlxuICpcbiAqIFdlIGlzb2xhdGUgdGhlIHRyeS9jYXRjaCBzbyBpdCBkb2Vzbid0IGFmZmVjdCB0aGVcbiAqIG9wdGltaXphdGlvbiBvZiB0aGUgcGFyc2UgZnVuY3Rpb24gd2hlbiBpdCBpcyBub3QgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gbWFrZUdldHRlckZuKGJvZHkpIHtcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyAqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7Jyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgZGVmYXVsdCBidWlsZCBvZiBWdWUuanMgaW4gYW4gZW52aXJvbm1lbnQgJyArICd3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICsgJ1VzZSB0aGUgQ1NQLWNvbXBsaWFudCBidWlsZCBpbnN0ZWFkOiAnICsgJ2h0dHA6Ly92dWVqcy5vcmcvZ3VpZGUvaW5zdGFsbGF0aW9uLmh0bWwjQ1NQLWNvbXBsaWFudC1idWlsZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybignSW52YWxpZCBleHByZXNzaW9uLiAnICsgJ0dlbmVyYXRlZCBmdW5jdGlvbiBib2R5OiAnICsgYm9keSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub29wO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVTZXR0ZXIoZXhwKSB7XG4gIHZhciBwYXRoID0gcGFyc2VQYXRoKGV4cCk7XG4gIGlmIChwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgdmFsKSB7XG4gICAgICBzZXRQYXRoKHNjb3BlLCBwYXRoLCB2YWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHNldHRlciBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gaW50byByZS13cml0dGVuIGdldHRlci9zZXR0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpO1xuICAvLyB0cnkgY2FjaGVcbiAgdmFyIGhpdCA9IGV4cHJlc3Npb25DYWNoZS5nZXQoZXhwKTtcbiAgaWYgKGhpdCkge1xuICAgIGlmIChuZWVkU2V0ICYmICFoaXQuc2V0KSB7XG4gICAgICBoaXQuc2V0ID0gY29tcGlsZVNldHRlcihoaXQuZXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICB2YXIgcmVzID0geyBleHA6IGV4cCB9O1xuICByZXMuZ2V0ID0gaXNTaW1wbGVQYXRoKGV4cCkgJiYgZXhwLmluZGV4T2YoJ1snKSA8IDBcbiAgLy8gb3B0aW1pemVkIHN1cGVyIHNpbXBsZSBnZXR0ZXJcbiAgPyBtYWtlR2V0dGVyRm4oJ3Njb3BlLicgKyBleHApXG4gIC8vIGR5bmFtaWMgZ2V0dGVyXG4gIDogY29tcGlsZUdldHRlcihleHApO1xuICBpZiAobmVlZFNldCkge1xuICAgIHJlcy5zZXQgPSBjb21waWxlU2V0dGVyKGV4cCk7XG4gIH1cbiAgZXhwcmVzc2lvbkNhY2hlLnB1dChleHAsIHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIHNpbXBsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKGV4cCkge1xuICByZXR1cm4gcGF0aFRlc3RSRS50ZXN0KGV4cCkgJiZcbiAgLy8gZG9uJ3QgdHJlYXQgbGl0ZXJhbCB2YWx1ZXMgYXMgcGF0aHNcbiAgIWxpdGVyYWxWYWx1ZVJFJDEudGVzdChleHApICYmXG4gIC8vIE1hdGggY29uc3RhbnRzIGUuZy4gTWF0aC5QSSwgTWF0aC5FIGV0Yy5cbiAgZXhwLnNsaWNlKDAsIDUpICE9PSAnTWF0aC4nO1xufVxuXG52YXIgZXhwcmVzc2lvbiA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZUV4cHJlc3Npb246IHBhcnNlRXhwcmVzc2lvbixcbiAgaXNTaW1wbGVQYXRoOiBpc1NpbXBsZVBhdGhcbn0pO1xuXG4vLyB3ZSBoYXZlIHR3byBzZXBhcmF0ZSBxdWV1ZXM6IG9uZSBmb3IgZGlyZWN0aXZlIHVwZGF0ZXNcbi8vIGFuZCBvbmUgZm9yIHVzZXIgd2F0Y2hlciByZWdpc3RlcmVkIHZpYSAkd2F0Y2goKS5cbi8vIHdlIHdhbnQgdG8gZ3VhcmFudGVlIGRpcmVjdGl2ZSB1cGRhdGVzIHRvIGJlIGNhbGxlZFxuLy8gYmVmb3JlIHVzZXIgd2F0Y2hlcnMgc28gdGhhdCB3aGVuIHVzZXIgd2F0Y2hlcnMgYXJlXG4vLyB0cmlnZ2VyZWQsIHRoZSBET00gd291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gaW4gdXBkYXRlZFxuLy8gc3RhdGUuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIHVzZXJRdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBiYXRjaGVyJ3Mgc3RhdGUuXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRCYXRjaGVyU3RhdGUoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIHVzZXJRdWV1ZS5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgY2lyY3VsYXIgPSB7fTtcbiAgd2FpdGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlKCkge1xuICB2YXIgX2FnYWluID0gdHJ1ZTtcblxuICBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHtcbiAgICBfYWdhaW4gPSBmYWxzZTtcblxuICAgIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSk7XG4gICAgcnVuQmF0Y2hlclF1ZXVlKHVzZXJRdWV1ZSk7XG4gICAgLy8gdXNlciB3YXRjaGVycyB0cmlnZ2VyZWQgbW9yZSB3YXRjaGVycyxcbiAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRlcGxldGVzXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICB9XG4gICAgLy8gZGV2IHRvb2wgaG9va1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gICAgfVxuICAgIHJlc2V0QmF0Y2hlclN0YXRlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW4gdGhlIHdhdGNoZXJzIGluIGEgc2luZ2xlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cblxuZnVuY3Rpb24gcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKSB7XG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybignWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wIGZvciB3YXRjaGVyICcgKyAnd2l0aCBleHByZXNzaW9uIFwiJyArIHdhdGNoZXIuZXhwcmVzc2lvbiArICdcIicsIHdhdGNoZXIudm0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqXG4gKiBAcGFyYW0ge1dhdGNoZXJ9IHdhdGNoZXJcbiAqICAgcHJvcGVydGllczpcbiAqICAgLSB7TnVtYmVyfSBpZFxuICogICAtIHtGdW5jdGlvbn0gcnVuXG4gKi9cblxuZnVuY3Rpb24gcHVzaFdhdGNoZXIod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgLy8gcHVzaCB3YXRjaGVyIGludG8gYXBwcm9wcmlhdGUgcXVldWVcbiAgICB2YXIgcSA9IHdhdGNoZXIudXNlciA/IHVzZXJRdWV1ZSA6IHF1ZXVlO1xuICAgIGhhc1tpZF0gPSBxLmxlbmd0aDtcbiAgICBxLnB1c2god2F0Y2hlcik7XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoQmF0Y2hlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheX0gZmlsdGVyc1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHR3b1dheVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gc3luY1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxhenlcbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3ByZVByb2Nlc3NdXG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwb3N0UHJvY2Vzc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAvLyBtaXggaW4gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICB2YXIgaXNGbiA9IHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nO1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuO1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5wcmV2RXJyb3IgPSBudWxsOyAvLyBmb3IgYXN5bmMgZXJyb3Igc3RhY2tzXG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlci9zZXR0ZXJcbiAgaWYgKGlzRm4pIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgdGhpcy5zZXR0ZXIgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHBPckZuLCB0aGlzLnR3b1dheSk7XG4gICAgdGhpcy5nZXR0ZXIgPSByZXMuZ2V0O1xuICAgIHRoaXMuc2V0dGVyID0gcmVzLnNldDtcbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5ID8gdW5kZWZpbmVkIDogdGhpcy5nZXQoKTtcbiAgLy8gc3RhdGUgZm9yIGF2b2lkaW5nIGZhbHNlIHRyaWdnZXJzIGZvciBkZWVwIGFuZCBBcnJheVxuICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2U7XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iZWZvcmVHZXQoKTtcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZSB8fCB0aGlzLnZtO1xuICB2YXIgdmFsdWU7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHNjb3BlLCBzY29wZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBleHByZXNzaW9uICcgKyAnXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiOiAnICsgZS50b1N0cmluZygpLCB0aGlzLnZtKTtcbiAgICB9XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLnByZVByb2Nlc3MpIHtcbiAgICB2YWx1ZSA9IHRoaXMucHJlUHJvY2Vzcyh2YWx1ZSk7XG4gIH1cbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgbnVsbCwgdGhpcy5maWx0ZXJzLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHRoaXMucG9zdFByb2Nlc3MpIHtcbiAgICB2YWx1ZSA9IHRoaXMucG9zdFByb2Nlc3ModmFsdWUpO1xuICB9XG4gIHRoaXMuYWZ0ZXJHZXQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZSB8fCB0aGlzLnZtO1xuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKHZhbHVlLCB0aGlzLnZhbHVlLCB0aGlzLmZpbHRlcnMsIHRydWUpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhpcy5zZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUsIHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgd2FybignRXJyb3Igd2hlbiBldmFsdWF0aW5nIHNldHRlciAnICsgJ1wiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIjogJyArIGUudG9TdHJpbmcoKSwgdGhpcy52bSk7XG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dDtcbiAgaWYgKGZvckNvbnRleHQgJiYgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uKSB7XG4gICAgaWYgKGZvckNvbnRleHQuZmlsdGVycykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHR3by13YXkgYmluZGluZyBvbiAnICsgJ2Egdi1mb3IgYWxpYXMgKCcgKyB0aGlzLmV4cHJlc3Npb24gKyAnKSwgYW5kIHRoZSAnICsgJ3YtZm9yIGhhcyBmaWx0ZXJzLiBUaGlzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkuICcgKyAnRWl0aGVyIHJlbW92ZSB0aGUgZmlsdGVycyBvciB1c2UgYW4gYXJyYXkgb2YgJyArICdvYmplY3RzIGFuZCBiaW5kIHRvIG9iamVjdCBwcm9wZXJ0aWVzIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvckNvbnRleHQuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAgIC8vIG9yaWdpbmFsIGlzIGFuIG9iamVjdFxuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlW3Njb3BlLiRrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJlcGFyZSBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtEZXB9IGRlcFxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmFmdGVyR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvd1xuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgcXVldWVkLCBvbmx5IG92ZXJ3cml0ZSBzaGFsbG93IHdpdGggbm9uLXNoYWxsb3csXG4gICAgLy8gYnV0IG5vdCB0aGUgb3RoZXIgd2F5IGFyb3VuZC5cbiAgICB0aGlzLnNoYWxsb3cgPSB0aGlzLnF1ZXVlZCA/IHNoYWxsb3cgPyB0aGlzLnNoYWxsb3cgOiBmYWxzZSA6ICEhc2hhbGxvdztcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWU7XG4gICAgLy8gcmVjb3JkIGJlZm9yZS1wdXNoIGVycm9yIHN0YWNrIGluIGRlYnVnIG1vZGVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcpIHtcbiAgICAgIHRoaXMucHJldkVycm9yID0gbmV3IEVycm9yKCdbdnVlXSBhc3luYyBzdGFjayB0cmFjZScpO1xuICAgIH1cbiAgICBwdXNoV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgIC8vIGhhdmUgbXV0YXRlZDsgYnV0IG9ubHkgZG8gc28gaWYgdGhpcyBpcyBhXG4gICAgLy8gbm9uLXNoYWxsb3cgdXBkYXRlIChjYXVzZWQgYnkgYSB2bSBkaWdlc3QpLlxuICAgIChpc09iamVjdCh2YWx1ZSkgfHwgdGhpcy5kZWVwKSAmJiAhdGhpcy5zaGFsbG93KSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gaW4gZGVidWcgKyBhc3luYyBtb2RlLCB3aGVuIGEgd2F0Y2hlciBjYWxsYmFja3NcbiAgICAgIC8vIHRocm93cywgd2UgYWxzbyB0aHJvdyB0aGUgc2F2ZWQgYmVmb3JlLXB1c2ggZXJyb3JcbiAgICAgIC8vIHNvIHRoZSBmdWxsIGNyb3NzLXRpY2sgc3RhY2sgdHJhY2UgaXMgYXZhaWxhYmxlLlxuICAgICAgdmFyIHByZXZFcnJvciA9IHRoaXMucHJldkVycm9yO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcgJiYgcHJldkVycm9yKSB7XG4gICAgICAgIHRoaXMucHJldkVycm9yID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHByZXZFcnJvcjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGF2b2lkIG92ZXJ3cml0aW5nIGFub3RoZXIgd2F0Y2hlciB0aGF0IGlzIGJlaW5nXG4gIC8vIGNvbGxlY3RlZC5cbiAgdmFyIGN1cnJlbnQgPSBEZXAudGFyZ2V0O1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBEZXAudGFyZ2V0ID0gY3VycmVudDtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJjcmliZXIgbGlzdC5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkIG9yIGlzIHBlcmZvcm1pbmcgYSB2LWZvclxuICAgIC8vIHJlLXJlbmRlciAodGhlIHdhdGNoZXIgbGlzdCBpcyB0aGVuIGZpbHRlcmVkIGJ5IHYtZm9yKS5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXRoaXMudm0uX3ZGb3JSZW1vdmluZykge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy52bSA9IHRoaXMuY2IgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWNydXNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UodmFsLCBzZWVuKSB7XG4gIHZhciBpID0gdW5kZWZpbmVkLFxuICAgICAga2V5cyA9IHVuZGVmaW5lZDtcbiAgaWYgKCFzZWVuKSB7XG4gICAgc2VlbiA9IHNlZW5PYmplY3RzO1xuICAgIHNlZW4uY2xlYXIoKTtcbiAgfVxuICB2YXIgaXNBID0gaXNBcnJheSh2YWwpO1xuICB2YXIgaXNPID0gaXNPYmplY3QodmFsKTtcbiAgaWYgKChpc0EgfHwgaXNPKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQSkge1xuICAgICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xuICAgIH0gZWxzZSBpZiAoaXNPKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0JDEgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmF0dHIgPSB0aGlzLmVsLm5vZGVUeXBlID09PSAzID8gJ2RhdGEnIDogJ3RleHRDb250ZW50JztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZWxbdGhpcy5hdHRyXSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gIH1cbn07XG5cbnZhciB0ZW1wbGF0ZUNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xudmFyIGlkU2VsZWN0b3JDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxudmFyIG1hcCA9IHtcbiAgZWZhdWx0OiBbMCwgJycsICcnXSxcbiAgbGVnZW5kOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgdHI6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuICBjb2w6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddXG59O1xuXG5tYXAudGQgPSBtYXAudGggPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxubWFwLm9wdGlvbiA9IG1hcC5vcHRncm91cCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cIm11bHRpcGxlXCI+JywgJzwvc2VsZWN0PiddO1xuXG5tYXAudGhlYWQgPSBtYXAudGJvZHkgPSBtYXAuY29sZ3JvdXAgPSBtYXAuY2FwdGlvbiA9IG1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAuZyA9IG1hcC5kZWZzID0gbWFwLnN5bWJvbCA9IG1hcC51c2UgPSBtYXAuaW1hZ2UgPSBtYXAudGV4dCA9IG1hcC5jaXJjbGUgPSBtYXAuZWxsaXBzZSA9IG1hcC5saW5lID0gbWFwLnBhdGggPSBtYXAucG9seWdvbiA9IG1hcC5wb2x5bGluZSA9IG1hcC5yZWN0ID0gWzEsICc8c3ZnICcgKyAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcgKyAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyArICd4bWxuczpldj1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50c1wiJyArICd2ZXJzaW9uPVwiMS4xXCI+JywgJzwvc3ZnPiddO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIHN1cHBvcnRlZCB0ZW1wbGF0ZSBub2RlIHdpdGggYVxuICogRG9jdW1lbnRGcmFnbWVudCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1JlYWxUZW1wbGF0ZShub2RlKSB7XG4gIHJldHVybiBpc1RlbXBsYXRlKG5vZGUpICYmIGlzRnJhZ21lbnQobm9kZS5jb250ZW50KTtcbn1cblxudmFyIHRhZ1JFJDEgPSAvPChbXFx3Oi1dKykvO1xudmFyIGVudGl0eVJFID0gLyYjP1xcdys/Oy87XG52YXIgY29tbWVudFJFID0gLzwhLS0vO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGVtcGxhdGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICogRGV0ZXJtaW5lcyBjb3JyZWN0IHdyYXBwaW5nIGJ5IHRhZyB0eXBlcy4gV3JhcHBpbmdcbiAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlU3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlU3RyaW5nLCByYXcpIHtcbiAgLy8gdHJ5IGEgY2FjaGUgaGl0IGZpcnN0XG4gIHZhciBjYWNoZUtleSA9IHJhdyA/IHRlbXBsYXRlU3RyaW5nIDogdGVtcGxhdGVTdHJpbmcudHJpbSgpO1xuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSQxKTtcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG4gIHZhciBjb21tZW50TWF0Y2ggPSBjb21tZW50UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG5cbiAgaWYgKCF0YWdNYXRjaCAmJiAhZW50aXR5TWF0Y2ggJiYgIWNvbW1lbnRNYXRjaCkge1xuICAgIC8vIHRleHQgb25seSwgcmV0dXJuIGEgc2luZ2xlIHRleHQgbm9kZS5cbiAgICBmcmFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRlbXBsYXRlU3RyaW5nKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IHRhZ01hdGNoICYmIHRhZ01hdGNoWzFdO1xuICAgIHZhciB3cmFwID0gbWFwW3RhZ10gfHwgbWFwLmVmYXVsdDtcbiAgICB2YXIgZGVwdGggPSB3cmFwWzBdO1xuICAgIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICAgIHZhciBzdWZmaXggPSB3cmFwWzJdO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBub2RlLmlubmVySFRNTCA9IHByZWZpeCArIHRlbXBsYXRlU3RyaW5nICsgc3VmZml4O1xuICAgIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcpIHtcbiAgICB0cmltTm9kZShmcmFnKTtcbiAgfVxuICB0ZW1wbGF0ZUNhY2hlLnB1dChjYWNoZUtleSwgZnJhZyk7XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSB0ZW1wbGF0ZSBub2RlIHRvIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gbm9kZVRvRnJhZ21lbnQobm9kZSkge1xuICAvLyBpZiBpdHMgYSB0ZW1wbGF0ZSB0YWcgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0LFxuICAvLyBpdHMgY29udGVudCBpcyBhbHJlYWR5IGEgZG9jdW1lbnQgZnJhZ21lbnQuIEhvd2V2ZXIsIGlPUyBTYWZhcmkgaGFzXG4gIC8vIGJ1ZyB3aGVuIHVzaW5nIGRpcmVjdGx5IGNsb25lZCB0ZW1wbGF0ZSBjb250ZW50IHdpdGggdG91Y2hcbiAgLy8gZXZlbnRzIGFuZCBjYW4gY2F1c2UgY3Jhc2hlcyB3aGVuIHRoZSBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIERPTSwgc28gd2VcbiAgLy8gaGF2ZSB0byB0cmVhdCB0ZW1wbGF0ZSBlbGVtZW50cyBhcyBzdHJpbmcgdGVtcGxhdGVzLiAoIzI4MDUpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9GcmFnbWVudChub2RlLmlubmVySFRNTCk7XG4gIH1cbiAgLy8gc2NyaXB0IHRlbXBsYXRlXG4gIGlmIChub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS50ZXh0Q29udGVudCk7XG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmVkTm9kZSA9IGNsb25lTm9kZShub2RlKTtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKGNoaWxkID0gY2xvbmVkTm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRyaW1Ob2RlKGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3d1Zy5jZ2k/aWQ9MTM3NzU1XG52YXIgaGFzQnJva2VuVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+JztcbiAgICByZXR1cm4gIWEuY2xvbmVOb2RlKHRydWUpLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gVGVzdCBmb3IgSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBjbG9uZSBidWdcbnZhciBoYXNUZXh0YXJlYUNsb25lQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnO1xuICAgIHJldHVybiB0LmNsb25lTm9kZSh0cnVlKS52YWx1ZSA9PT0gJ3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiAxLiBEZWFsIHdpdGggU2FmYXJpIGNsb25pbmcgbmVzdGVkIDx0ZW1wbGF0ZT4gYnVnIGJ5XG4gKiAgICBtYW51YWxseSBjbG9uaW5nIGFsbCB0ZW1wbGF0ZSBpbnN0YW5jZXMuXG4gKiAyLiBEZWFsIHdpdGggSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWcgYnkgc2V0dGluZ1xuICogICAgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgY2xvbmluZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIW5vZGUucXVlcnlTZWxlY3RvckFsbCkge1xuICAgIHJldHVybiBub2RlLmNsb25lTm9kZSgpO1xuICB9XG4gIHZhciByZXMgPSBub2RlLmNsb25lTm9kZSh0cnVlKTtcbiAgdmFyIGksIG9yaWdpbmFsLCBjbG9uZWQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaGFzQnJva2VuVGVtcGxhdGUpIHtcbiAgICB2YXIgdGVtcENsb25lID0gcmVzO1xuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuY29udGVudDtcbiAgICAgIHRlbXBDbG9uZSA9IHJlcy5jb250ZW50O1xuICAgIH1cbiAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICBjbG9uZWQgPSB0ZW1wQ2xvbmUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjbG9uZWRbaV0ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVOb2RlKG9yaWdpbmFsW2ldKSwgY2xvbmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNUZXh0YXJlYUNsb25lQnVnKSB7XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgcmVzLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIGNsb25lZCA9IHJlcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpO1xuICAgICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNsb25lZFtpXS52YWx1ZSA9IG9yaWdpbmFsW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgb3B0aW9uIGFuZCBub3JtYWxpemVzIGl0IGludG8gYVxuICogYSBEb2N1bWVudEZyYWdtZW50IHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwYXJ0aWFsIG9yIGFcbiAqIGluc3RhbmNlIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGVtcGxhdGVcbiAqICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZTpcbiAqICAgICAgICAtIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0XG4gKiAgICAgICAgLSBOb2RlIG9iamVjdCBvZiB0eXBlIFRlbXBsYXRlXG4gKiAgICAgICAgLSBpZCBzZWxlY3RvcjogJyNzb21lLXRlbXBsYXRlLWlkJ1xuICogICAgICAgIC0gdGVtcGxhdGUgc3RyaW5nOiAnPGRpdj48c3Bhbj57e21zZ319PC9zcGFuPjwvZGl2PidcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkQ2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gKiAgICAgICAgaW5saW5lIEhUTUwgaW50ZXJwb2xhdGlvbi4gRG8gbm90IGNoZWNrIGZvciBpZFxuICogICAgICAgIHNlbGVjdG9yIGFuZCBrZWVwIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHNob3VsZENsb25lLCByYXcpIHtcbiAgdmFyIG5vZGUsIGZyYWc7XG5cbiAgLy8gaWYgdGhlIHRlbXBsYXRlIGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudCxcbiAgLy8gZG8gbm90aGluZ1xuICBpZiAoaXNGcmFnbWVudCh0ZW1wbGF0ZSkpIHtcbiAgICB0cmltTm9kZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHNob3VsZENsb25lID8gY2xvbmVOb2RlKHRlbXBsYXRlKSA6IHRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghcmF3ICYmIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAvLyBpZCBzZWxlY3RvciBjYW4gYmUgY2FjaGVkIHRvb1xuICAgICAgZnJhZyA9IGlkU2VsZWN0b3JDYWNoZS5nZXQodGVtcGxhdGUpO1xuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KG5vZGUpO1xuICAgICAgICAgIC8vIHNhdmUgc2VsZWN0b3IgdG8gY2FjaGVcbiAgICAgICAgICBpZFNlbGVjdG9yQ2FjaGUucHV0KHRlbXBsYXRlLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSwgcmF3KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnICYmIHNob3VsZENsb25lID8gY2xvbmVOb2RlKGZyYWcpIDogZnJhZztcbn1cblxudmFyIHRlbXBsYXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNsb25lTm9kZTogY2xvbmVOb2RlLFxuICBwYXJzZVRlbXBsYXRlOiBwYXJzZVRlbXBsYXRlXG59KTtcblxudmFyIGh0bWwgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBhIGNvbW1lbnQgbm9kZSBtZWFucyB0aGlzIGlzIGEgYmluZGluZyBmb3JcbiAgICAvLyB7e3sgaW5saW5lIHVuZXNjYXBlZCBodG1sIH19fVxuICAgIGlmICh0aGlzLmVsLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAvLyBob2xkIG5vZGVzXG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWh0bWwnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgdGhpcy5zd2FwKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gc3dhcCh2YWx1ZSkge1xuICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICB2YXIgaSA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlbW92ZSh0aGlzLm5vZGVzW2ldKTtcbiAgICB9XG4gICAgLy8gY29udmVydCBuZXcgdmFsdWUgdG8gYSBmcmFnbWVudFxuICAgIC8vIGRvIG5vdCBhdHRlbXB0IHRvIHJldHJpZXZlIGZyb20gaWQgc2VsZWN0b3JcbiAgICB2YXIgZnJhZyA9IHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgIC8vIHNhdmUgYSByZWZlcmVuY2UgdG8gdGhlc2Ugbm9kZXMgc28gd2UgY2FuIHJlbW92ZSBsYXRlclxuICAgIHRoaXMubm9kZXMgPSB0b0FycmF5KGZyYWcuY2hpbGROb2Rlcyk7XG4gICAgYmVmb3JlKGZyYWcsIHRoaXMuYW5jaG9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBbcGFyZW50RnJhZ11cbiAqL1xuZnVuY3Rpb24gRnJhZ21lbnQobGlua2VyLCB2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLmNoaWxkRnJhZ3MgPSBbXTtcbiAgdGhpcy52bSA9IHZtO1xuICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXJlbnRGcmFnID0gcGFyZW50RnJhZztcbiAgaWYgKHBhcmVudEZyYWcpIHtcbiAgICBwYXJlbnRGcmFnLmNoaWxkRnJhZ3MucHVzaCh0aGlzKTtcbiAgfVxuICB0aGlzLnVubGluayA9IGxpbmtlcih2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHRoaXMpO1xuICB2YXIgc2luZ2xlID0gdGhpcy5zaW5nbGUgPSBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmXG4gIC8vIGRvIG5vdCBnbyBzaW5nbGUgbW9kZSBpZiB0aGUgb25seSBub2RlIGlzIGFuIGFuY2hvclxuICAhZnJhZy5jaGlsZE5vZGVzWzBdLl9fdl9hbmNob3I7XG4gIGlmIChzaW5nbGUpIHtcbiAgICB0aGlzLm5vZGUgPSBmcmFnLmNoaWxkTm9kZXNbMF07XG4gICAgdGhpcy5iZWZvcmUgPSBzaW5nbGVCZWZvcmU7XG4gICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2RlID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1zdGFydCcpO1xuICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1lbmQnKTtcbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHByZXBlbmQodGhpcy5ub2RlLCBmcmFnKTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuZW5kKTtcbiAgICB0aGlzLmJlZm9yZSA9IG11bHRpQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gbXVsdGlSZW1vdmU7XG4gIH1cbiAgdGhpcy5ub2RlLl9fdl9mcmFnID0gdGhpcztcbn1cblxuLyoqXG4gKiBDYWxsIGF0dGFjaC9kZXRhY2ggZm9yIGFsbCBjb21wb25lbnRzIGNvbnRhaW5lZCB3aXRoaW5cbiAqIHRoaXMgZnJhZ21lbnQuIEFsc28gZG8gc28gcmVjdXJzaXZlbHkgZm9yIGFsbCBjaGlsZFxuICogZnJhZ21lbnRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tcbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uY2FsbEhvb2soaG9vayk7XG4gIH1cbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaG9vayh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnNlcnQgZnJhZ21lbnQgYmVmb3JlIHRhcmdldCwgc2luZ2xlIG5vZGUgdmVyc2lvblxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWV0aG9kKHRoaXMubm9kZSwgdGFyZ2V0LCB0aGlzLnZtKTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBzaW5nbGVSZW1vdmUoKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBpbkRvYyh0aGlzLm5vZGUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gIHJlbW92ZVdpdGhUcmFuc2l0aW9uKHRoaXMubm9kZSwgdGhpcy52bSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZnJhZ21lbnQgYmVmb3JlIHRhcmdldCwgbXVsdGktbm9kZXMgdmVyc2lvblxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gbXVsdGlCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdmFyIG1ldGhvZCA9IHdpdGhUcmFuc2l0aW9uICE9PSBmYWxzZSA/IGJlZm9yZVdpdGhUcmFuc2l0aW9uIDogYmVmb3JlO1xuICBtYXBOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBtZXRob2Qobm9kZSwgdGFyZ2V0LCB2bSk7XG4gIH0pO1xuICBpZiAoaW5Eb2ModGhpcy5ub2RlKSkge1xuICAgIHRoaXMuY2FsbEhvb2soYXR0YWNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBmcmFnbWVudCwgbXVsdGktbm9kZXMgdmVyc2lvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBpbkRvYyh0aGlzLm5vZGUpO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgdGhpcy52bSwgdGhpcy5mcmFnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICB9XG4gICAgc2VsZi5kZXN0cm95KCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFByZXBhcmUgdGhlIGZyYWdtZW50IGZvciByZW1vdmFsLlxuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5iZWZvcmVSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpLCBsO1xuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHJlY3Vyc2l2ZWx5IG9uIGNoaWxkXG4gICAgLy8gZnJhZ21lbnRzLCBkZXB0aC1maXJzdFxuICAgIHRoaXMuY2hpbGRGcmFnc1tpXS5iZWZvcmVSZW1vdmUoZmFsc2UpO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIENhbGwgZGVzdHJveSBmb3IgYWxsIGNvbnRhaW5lZCBpbnN0YW5jZXMsXG4gICAgLy8gd2l0aCByZW1vdmU6ZmFsc2UgYW5kIGRlZmVyOnRydWUuXG4gICAgLy8gRGVmZXIgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAgIC8vIGtlZXAgdGhlIGNoaWxkcmVuIHRvIGNhbGwgZGV0YWNoIGhvb2tzXG4gICAgLy8gb24gdGhlbS5cbiAgICB0aGlzLmNoaWxkcmVuW2ldLiRkZXN0cm95KGZhbHNlLCB0cnVlKTtcbiAgfVxuICB2YXIgZGlycyA9IHRoaXMudW5saW5rLmRpcnM7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIGRpc2FibGUgdGhlIHdhdGNoZXJzIG9uIGFsbCB0aGUgZGlyZWN0aXZlc1xuICAgIC8vIHNvIHRoYXQgdGhlIHJlbmRlcmVkIGNvbnRlbnQgc3RheXMgdGhlIHNhbWVcbiAgICAvLyBkdXJpbmcgcmVtb3ZhbC5cbiAgICBkaXJzW2ldLl93YXRjaGVyICYmIGRpcnNbaV0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBmcmFnbWVudC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFyZW50RnJhZykge1xuICAgIHRoaXMucGFyZW50RnJhZy5jaGlsZEZyYWdzLiRyZW1vdmUodGhpcyk7XG4gIH1cbiAgdGhpcy5ub2RlLl9fdl9mcmFnID0gbnVsbDtcbiAgdGhpcy51bmxpbmsoKTtcbn07XG5cbi8qKlxuICogQ2FsbCBhdHRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoKGNoaWxkKSB7XG4gIGlmICghY2hpbGQuX2lzQXR0YWNoZWQgJiYgaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGwgZGV0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGRldGFjaChjaGlsZCkge1xuICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gIH1cbn1cblxudmFyIGxpbmtlckNhY2hlID0gbmV3IENhY2hlKDUwMDApO1xuXG4vKipcbiAqIEEgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYVxuICogZnJhZ21lbnQuIENhY2hlcyB0aGUgY29tcGlsZWQgbGlua2VyIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxcbiAqL1xuZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5KHZtLCBlbCkge1xuICB0aGlzLnZtID0gdm07XG4gIHZhciB0ZW1wbGF0ZTtcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGVsID09PSAnc3RyaW5nJztcbiAgaWYgKGlzU3RyaW5nIHx8IGlzVGVtcGxhdGUoZWwpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgIHRlbXBsYXRlID0gcGFyc2VUZW1wbGF0ZShlbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQsIGJ1dCBvbmx5IGZvciBjb21wb25lbnRzXG4gIHZhciBsaW5rZXI7XG4gIHZhciBjaWQgPSB2bS5jb25zdHJ1Y3Rvci5jaWQ7XG4gIGlmIChjaWQgPiAwKSB7XG4gICAgdmFyIGNhY2hlSWQgPSBjaWQgKyAoaXNTdHJpbmcgPyBlbCA6IGdldE91dGVySFRNTChlbCkpO1xuICAgIGxpbmtlciA9IGxpbmtlckNhY2hlLmdldChjYWNoZUlkKTtcbiAgICBpZiAoIWxpbmtlcikge1xuICAgICAgbGlua2VyID0gY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpO1xuICAgICAgbGlua2VyQ2FjaGUucHV0KGNhY2hlSWQsIGxpbmtlcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgfVxuICB0aGlzLmxpbmtlciA9IGxpbmtlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBmcmFnbWVudCBpbnN0YW5jZSB3aXRoIGdpdmVuIGhvc3QgYW5kIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBob3N0XG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IHBhcmVudEZyYWdcbiAqL1xuXG5GcmFnbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICB2YXIgZnJhZyA9IGNsb25lTm9kZSh0aGlzLnRlbXBsYXRlKTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpO1xufTtcblxudmFyIE9OID0gNzAwO1xudmFyIE1PREVMID0gODAwO1xudmFyIEJJTkQgPSA4NTA7XG52YXIgVFJBTlNJVElPTiA9IDExMDA7XG52YXIgRUwgPSAxNTAwO1xudmFyIENPTVBPTkVOVCA9IDE1MDA7XG52YXIgUEFSVElBTCA9IDE3NTA7XG52YXIgSUYgPSAyMTAwO1xudmFyIEZPUiA9IDIyMDA7XG52YXIgU0xPVCA9IDIzMDA7XG5cbnZhciB1aWQkMyA9IDA7XG5cbnZhciB2Rm9yID0ge1xuXG4gIHByaW9yaXR5OiBGT1IsXG4gIHRlcm1pbmFsOiB0cnVlLFxuXG4gIHBhcmFtczogWyd0cmFjay1ieScsICdzdGFnZ2VyJywgJ2VudGVyLXN0YWdnZXInLCAnbGVhdmUtc3RhZ2dlciddLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gc3VwcG9ydCBcIml0ZW0gaW4vb2YgaXRlbXNcIiBzeW50YXhcbiAgICB2YXIgaW5NYXRjaCA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaCgvKC4qKSAoPzppbnxvZikgKC4qKS8pO1xuICAgIGlmIChpbk1hdGNoKSB7XG4gICAgICB2YXIgaXRNYXRjaCA9IGluTWF0Y2hbMV0ubWF0Y2goL1xcKCguKiksKC4qKVxcKS8pO1xuICAgICAgaWYgKGl0TWF0Y2gpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0TWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB0aGlzLmFsaWFzID0gaXRNYXRjaFsyXS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBpbk1hdGNoWzJdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hbGlhcykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb24gXCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArICdhbGlhcyBpcyByZXF1aXJlZC4nLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1aWQgYXMgYSBjYWNoZSBpZGVudGlmaWVyXG4gICAgdGhpcy5pZCA9ICdfX3YtZm9yX18nICsgKyt1aWQkMztcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYW4gb3B0aW9uIGxpc3QsXG4gICAgLy8gc28gdGhhdCB3ZSBrbm93IGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSA8c2VsZWN0PidzXG4gICAgLy8gdi1tb2RlbCB3aGVuIHRoZSBvcHRpb24gbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBiZWNhdXNlIHYtbW9kZWwgaGFzIGEgbG93ZXIgcHJpb3JpdHkgdGhhbiB2LWZvcixcbiAgICAvLyB0aGUgdi1tb2RlbCBpcyBub3QgYm91bmQgaGVyZSB5ZXQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyByZXRyaXZlIGl0IGluIHRoZSBhY3R1YWwgdXBkYXRlTW9kZWwoKSBmdW5jdGlvbi5cbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lO1xuICAgIHRoaXMuaXNPcHRpb24gPSAodGFnID09PSAnT1BUSU9OJyB8fCB0YWcgPT09ICdPUFRHUk9VUCcpICYmIHRoaXMuZWwucGFyZW50Tm9kZS50YWdOYW1lID09PSAnU0VMRUNUJztcblxuICAgIC8vIHNldHVwIGFuY2hvciBub2Rlc1xuICAgIHRoaXMuc3RhcnQgPSBjcmVhdGVBbmNob3IoJ3YtZm9yLXN0YXJ0Jyk7XG4gICAgdGhpcy5lbmQgPSBjcmVhdGVBbmNob3IoJ3YtZm9yLWVuZCcpO1xuICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5lbmQpO1xuICAgIGJlZm9yZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG5cbiAgICAvLyBjYWNoZVxuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gZnJhZ21lbnQgZmFjdG9yeVxuICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgdGhpcy5lbCk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuICAgIHRoaXMuZGlmZihkYXRhKTtcbiAgICB0aGlzLnVwZGF0ZVJlZigpO1xuICAgIHRoaXMudXBkYXRlTW9kZWwoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlmZiwgYmFzZWQgb24gbmV3IGRhdGEgYW5kIG9sZCBkYXRhLCBkZXRlcm1pbmUgdGhlXG4gICAqIG1pbmltdW0gYW1vdW50IG9mIERPTSBtYW5pcHVsYXRpb25zIG5lZWRlZCB0byBtYWtlIHRoZVxuICAgKiBET00gcmVmbGVjdCB0aGUgbmV3IGRhdGEgQXJyYXkuXG4gICAqXG4gICAqIFRoZSBhbGdvcml0aG0gZGlmZnMgdGhlIG5ldyBkYXRhIEFycmF5IGJ5IHN0b3JpbmcgYVxuICAgKiBoaWRkZW4gcmVmZXJlbmNlIHRvIGFuIG93bmVyIHZtIGluc3RhbmNlIG9uIHByZXZpb3VzbHlcbiAgICogc2VlbiBkYXRhLiBUaGlzIGFsbG93cyB1cyB0byBhY2hpZXZlIE8obikgd2hpY2ggaXNcbiAgICogYmV0dGVyIHRoYW4gYSBsZXZlbnNodGVpbiBkaXN0YW5jZSBiYXNlZCBhbGdvcml0aG0sXG4gICAqIHdoaWNoIGlzIE8obSAqIG4pLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqL1xuXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYoZGF0YSkge1xuICAgIC8vIGNoZWNrIGlmIHRoZSBBcnJheSB3YXMgY29udmVydGVkIGZyb20gYW4gT2JqZWN0XG4gICAgdmFyIGl0ZW0gPSBkYXRhWzBdO1xuICAgIHZhciBjb252ZXJ0ZWRGcm9tT2JqZWN0ID0gdGhpcy5mcm9tT2JqZWN0ID0gaXNPYmplY3QoaXRlbSkgJiYgaGFzT3duKGl0ZW0sICcka2V5JykgJiYgaGFzT3duKGl0ZW0sICckdmFsdWUnKTtcblxuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgb2xkRnJhZ3MgPSB0aGlzLmZyYWdzO1xuICAgIHZhciBmcmFncyA9IHRoaXMuZnJhZ3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIHZhciBhbGlhcyA9IHRoaXMuYWxpYXM7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICB2YXIgaW5Eb2N1bWVudCA9IGluRG9jKHN0YXJ0KTtcbiAgICB2YXIgaW5pdCA9ICFvbGRGcmFncztcbiAgICB2YXIgaSwgbCwgZnJhZywga2V5LCB2YWx1ZSwgcHJpbWl0aXZlO1xuXG4gICAgLy8gRmlyc3QgcGFzcywgZ28gdGhyb3VnaCB0aGUgbmV3IEFycmF5IGFuZCBmaWxsIHVwXG4gICAgLy8gdGhlIG5ldyBmcmFncyBhcnJheS4gSWYgYSBwaWVjZSBvZiBkYXRhIGhhcyBhIGNhY2hlZFxuICAgIC8vIGluc3RhbmNlIGZvciBpdCwgd2UgcmV1c2UgaXQuIE90aGVyd2lzZSBidWlsZCBhIG5ld1xuICAgIC8vIGluc3RhbmNlLlxuICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaXRlbSA9IGRhdGFbaV07XG4gICAgICBrZXkgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4ka2V5IDogbnVsbDtcbiAgICAgIHZhbHVlID0gY29udmVydGVkRnJvbU9iamVjdCA/IGl0ZW0uJHZhbHVlIDogaXRlbTtcbiAgICAgIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgICBmcmFnID0gIWluaXQgJiYgdGhpcy5nZXRDYWNoZWRGcmFnKHZhbHVlLCBpLCBrZXkpO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgLy8gcmV1c2FibGUgZnJhZ21lbnRcbiAgICAgICAgZnJhZy5yZXVzZWQgPSB0cnVlO1xuICAgICAgICAvLyB1cGRhdGUgJGluZGV4XG4gICAgICAgIGZyYWcuc2NvcGUuJGluZGV4ID0gaTtcbiAgICAgICAgLy8gdXBkYXRlICRrZXlcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGZyYWcuc2NvcGUuJGtleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgaXRlcmF0b3JcbiAgICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgZnJhZy5zY29wZVtpdGVyYXRvcl0gPSBrZXkgIT09IG51bGwgPyBrZXkgOiBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBkYXRhIGZvciB0cmFjay1ieSwgb2JqZWN0IHJlcGVhdCAmXG4gICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgIGlmICh0cmFja0J5S2V5IHx8IGNvbnZlcnRlZEZyb21PYmplY3QgfHwgcHJpbWl0aXZlKSB7XG4gICAgICAgICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnJhZy5zY29wZVthbGlhc10gPSB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IGlzbnRhbmNlXG4gICAgICAgIGZyYWcgPSB0aGlzLmNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGksIGtleSk7XG4gICAgICAgIGZyYWcuZnJlc2ggPSAhaW5pdDtcbiAgICAgIH1cbiAgICAgIGZyYWdzW2ldID0gZnJhZztcbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIGZyYWcuYmVmb3JlKGVuZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UncmUgZG9uZSBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgIGlmIChpbml0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2Vjb25kIHBhc3MsIGdvIHRocm91Z2ggdGhlIG9sZCBmcmFnbWVudHMgYW5kXG4gICAgLy8gZGVzdHJveSB0aG9zZSB3aG8gYXJlIG5vdCByZXVzZWQgKGFuZCByZW1vdmUgdGhlbVxuICAgIC8vIGZyb20gY2FjaGUpXG4gICAgdmFyIHJlbW92YWxJbmRleCA9IDA7XG4gICAgdmFyIHRvdGFsUmVtb3ZlZCA9IG9sZEZyYWdzLmxlbmd0aCAtIGZyYWdzLmxlbmd0aDtcbiAgICAvLyB3aGVuIHJlbW92aW5nIGEgbGFyZ2UgbnVtYmVyIG9mIGZyYWdtZW50cywgd2F0Y2hlciByZW1vdmFsXG4gICAgLy8gdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBib3R0bGVuZWNrLCBzbyB3ZSBiYXRjaCB0aGUgd2F0Y2hlclxuICAgIC8vIHJlbW92YWxzIGludG8gYSBzaW5nbGUgZmlsdGVyIGNhbGwhXG4gICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gb2xkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmcmFnID0gb2xkRnJhZ3NbaV07XG4gICAgICBpZiAoIWZyYWcucmV1c2VkKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoZnJhZywgcmVtb3ZhbEluZGV4KyssIHRvdGFsUmVtb3ZlZCwgaW5Eb2N1bWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudm0uX3ZGb3JSZW1vdmluZyA9IGZhbHNlO1xuICAgIGlmIChyZW1vdmFsSW5kZXgpIHtcbiAgICAgIHRoaXMudm0uX3dhdGNoZXJzID0gdGhpcy52bS5fd2F0Y2hlcnMuZmlsdGVyKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHJldHVybiB3LmFjdGl2ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIHBhc3MsIG1vdmUvaW5zZXJ0IG5ldyBmcmFnbWVudHMgaW50byB0aGVcbiAgICAvLyByaWdodCBwbGFjZS5cbiAgICB2YXIgdGFyZ2V0UHJldiwgcHJldkVsLCBjdXJyZW50UHJldjtcbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBmcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBmcmFnc1tpXTtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGZyYWcgdGhhdCB3ZSBzaG91bGQgYmUgYWZ0ZXJcbiAgICAgIHRhcmdldFByZXYgPSBmcmFnc1tpIC0gMV07XG4gICAgICBwcmV2RWwgPSB0YXJnZXRQcmV2ID8gdGFyZ2V0UHJldi5zdGFnZ2VyQ2IgPyB0YXJnZXRQcmV2LnN0YWdnZXJBbmNob3IgOiB0YXJnZXRQcmV2LmVuZCB8fCB0YXJnZXRQcmV2Lm5vZGUgOiBzdGFydDtcbiAgICAgIGlmIChmcmFnLnJldXNlZCAmJiAhZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgICAgY3VycmVudFByZXYgPSBmaW5kUHJldkZyYWcoZnJhZywgc3RhcnQsIHRoaXMuaWQpO1xuICAgICAgICBpZiAoY3VycmVudFByZXYgIT09IHRhcmdldFByZXYgJiYgKCFjdXJyZW50UHJldiB8fFxuICAgICAgICAvLyBvcHRpbWl6YXRpb24gZm9yIG1vdmluZyBhIHNpbmdsZSBpdGVtLlxuICAgICAgICAvLyB0aGFua3MgdG8gc3VnZ2VzdGlvbnMgYnkgQGxpdm9yYXMgaW4gIzE4MDdcbiAgICAgICAgZmluZFByZXZGcmFnKGN1cnJlbnRQcmV2LCBzdGFydCwgdGhpcy5pZCkgIT09IHRhcmdldFByZXYpKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlKGZyYWcsIHByZXZFbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5ldyBpbnN0YW5jZSwgb3Igc3RpbGwgaW4gc3RhZ2dlci5cbiAgICAgICAgLy8gaW5zZXJ0IHdpdGggdXBkYXRlZCBzdGFnZ2VyIGluZGV4LlxuICAgICAgICB0aGlzLmluc2VydChmcmFnLCBpbnNlcnRpb25JbmRleCsrLCBwcmV2RWwsIGluRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgZnJhZy5yZXVzZWQgPSBmcmFnLmZyZXNoID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBhbGlhcywgaW5kZXgsIGtleSkge1xuICAgIHZhciBob3N0ID0gdGhpcy5faG9zdDtcbiAgICAvLyBjcmVhdGUgaXRlcmF0aW9uIHNjb3BlXG4gICAgdmFyIHBhcmVudFNjb3BlID0gdGhpcy5fc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgc2NvcGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlKTtcbiAgICAvLyByZWYgaG9sZGVyIGZvciB0aGUgc2NvcGVcbiAgICBzY29wZS4kcmVmcyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJHJlZnMpO1xuICAgIHNjb3BlLiRlbHMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRlbHMpO1xuICAgIC8vIG1ha2Ugc3VyZSBwb2ludCAkcGFyZW50IHRvIHBhcmVudCBzY29wZVxuICAgIHNjb3BlLiRwYXJlbnQgPSBwYXJlbnRTY29wZTtcbiAgICAvLyBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGFsaWFzXG4gICAgc2NvcGUuJGZvckNvbnRleHQgPSB0aGlzO1xuICAgIC8vIGRlZmluZSBzY29wZSBwcm9wZXJ0aWVzXG4gICAgLy8gaW1wb3J0YW50OiBkZWZpbmUgdGhlIHNjb3BlIGFsaWFzIHdpdGhvdXQgZm9yY2VkIGNvbnZlcnNpb25cbiAgICAvLyBzbyB0aGF0IGZyb3plbiBkYXRhIHN0cnVjdHVyZXMgcmVtYWluIG5vbi1yZWFjdGl2ZS5cbiAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgYWxpYXMsIHZhbHVlKTtcbiAgICB9KTtcbiAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRrZXknLCBrZXkpO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgLy8gYXZvaWQgYWNjaWRlbnRhbCBmYWxsYmFja1xuICAgICAgZGVmKHNjb3BlLCAnJGtleScsIG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pdGVyYXRvcikge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIHRoaXMuaXRlcmF0b3IsIGtleSAhPT0gbnVsbCA/IGtleSA6IGluZGV4KTtcbiAgICB9XG4gICAgdmFyIGZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnKTtcbiAgICBmcmFnLmZvcklkID0gdGhpcy5pZDtcbiAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSk7XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdi1yZWYgb24gb3duZXIgdm0uXG4gICAqL1xuXG4gIHVwZGF0ZVJlZjogZnVuY3Rpb24gdXBkYXRlUmVmKCkge1xuICAgIHZhciByZWYgPSB0aGlzLmRlc2NyaXB0b3IucmVmO1xuICAgIGlmICghcmVmKSByZXR1cm47XG4gICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnM7XG4gICAgdmFyIHJlZnM7XG4gICAgaWYgKCF0aGlzLmZyb21PYmplY3QpIHtcbiAgICAgIHJlZnMgPSB0aGlzLmZyYWdzLm1hcChmaW5kVm1Gcm9tRnJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnMgPSB7fTtcbiAgICAgIHRoaXMuZnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICByZWZzW2ZyYWcuc2NvcGUuJGtleV0gPSBmaW5kVm1Gcm9tRnJhZyhmcmFnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNoW3JlZl0gPSByZWZzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3Igb3B0aW9uIGxpc3RzLCB1cGRhdGUgdGhlIGNvbnRhaW5pbmcgdi1tb2RlbCBvblxuICAgKiBwYXJlbnQgPHNlbGVjdD4uXG4gICAqL1xuXG4gIHVwZGF0ZU1vZGVsOiBmdW5jdGlvbiB1cGRhdGVNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgIHZhciBtb2RlbCA9IHBhcmVudCAmJiBwYXJlbnQuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jdW1lbnRcbiAgICovXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoZnJhZywgaW5kZXgsIHByZXZFbCwgaW5Eb2N1bWVudCkge1xuICAgIGlmIChmcmFnLnN0YWdnZXJDYikge1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IuY2FuY2VsKCk7XG4gICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCBudWxsLCAnZW50ZXInKTtcbiAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYW5jaG9yIGFuZCBpbnNlcnQgaXQgc3luY2hyb25vdXNseSxcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGNvcnJlY3Qgb3JkZXIgd2l0aG91dFxuICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICB2YXIgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yO1xuICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yID0gY3JlYXRlQW5jaG9yKCdzdGFnZ2VyLWFuY2hvcicpO1xuICAgICAgICBhbmNob3IuX192X2ZyYWcgPSBmcmFnO1xuICAgICAgfVxuICAgICAgYWZ0ZXIoYW5jaG9yLCBwcmV2RWwpO1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5iZWZvcmUoYW5jaG9yKTtcbiAgICAgICAgcmVtb3ZlKGFuY2hvcik7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcHJldkVsLm5leHRTaWJsaW5nO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAvLyByZXNldCBlbmQgYW5jaG9yIHBvc2l0aW9uIGluIGNhc2UgdGhlIHBvc2l0aW9uIHdhcyBtZXNzZWQgdXBcbiAgICAgICAgLy8gYnkgYW4gZXh0ZXJuYWwgZHJhZy1uLWRyb3AgbGlicmFyeS5cbiAgICAgICAgYWZ0ZXIodGhpcy5lbmQsIHByZXZFbCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZW5kO1xuICAgICAgfVxuICAgICAgZnJhZy5iZWZvcmUodGFyZ2V0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZyYWdtZW50LiBIYW5kbGVzIHN0YWdnZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jdW1lbnRcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZnJhZywgaW5kZXgsIHRvdGFsLCBpbkRvY3VtZW50KSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKTtcbiAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgIC8vIGl0J3Mgbm90IHBvc3NpYmxlIGZvciB0aGUgc2FtZSBmcmFnIHRvIGJlIHJlbW92ZWRcbiAgICAgIC8vIHR3aWNlLCBzbyBpZiB3ZSBoYXZlIGEgcGVuZGluZyBzdGFnZ2VyIGNhbGxiYWNrLFxuICAgICAgLy8gaXQgbWVhbnMgdGhpcyBmcmFnIGlzIHF1ZXVlZCBmb3IgZW50ZXIgYnV0IHJlbW92ZWRcbiAgICAgIC8vIGJlZm9yZSBpdHMgdHJhbnNpdGlvbiBzdGFydGVkLiBTaW5jZSBpdCBpcyBhbHJlYWR5XG4gICAgICAvLyBkZXN0cm95ZWQsIHdlIGNhbiBqdXN0IGxlYXZlIGl0IGluIGRldGFjaGVkIHN0YXRlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsICdsZWF2ZScpO1xuICAgIGlmIChpbkRvY3VtZW50ICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLnJlbW92ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZSBhIGZyYWdtZW50IHRvIGEgbmV3IHBvc2l0aW9uLlxuICAgKiBGb3JjZSBubyB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7Tm9kZX0gcHJldkVsXG4gICAqL1xuXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUoZnJhZywgcHJldkVsKSB7XG4gICAgLy8gZml4IGEgY29tbW9uIGlzc3VlIHdpdGggU29ydGFibGU6XG4gICAgLy8gaWYgcHJldkVsIGRvZXNuJ3QgaGF2ZSBuZXh0U2libGluZywgdGhpcyBtZWFucyBpdCdzXG4gICAgLy8gYmVlbiBkcmFnZ2VkIGFmdGVyIHRoZSBlbmQgYW5jaG9yLiBKdXN0IHJlLXBvc2l0aW9uXG4gICAgLy8gdGhlIGVuZCBhbmNob3IgdG8gdGhlIGVuZCBvZiB0aGUgY29udGFpbmVyLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghcHJldkVsLm5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLmVuZC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuZW5kKTtcbiAgICB9XG4gICAgZnJhZy5iZWZvcmUocHJldkVsLm5leHRTaWJsaW5nLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGEgZnJhZ21lbnQgdXNpbmcgdHJhY2stYnkgb3IgdGhlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqL1xuXG4gIGNhY2hlRnJhZzogZnVuY3Rpb24gY2FjaGVGcmFnKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgdmFyIGlkO1xuICAgIGlmIChrZXkgfHwgdHJhY2tCeUtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgICBjYWNoZVtpZF0gPSBmcmFnO1xuICAgICAgfSBlbHNlIGlmICh0cmFja0J5S2V5ICE9PSAnJGluZGV4Jykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgIGlmIChoYXNPd24odmFsdWUsIGlkKSkge1xuICAgICAgICBpZiAodmFsdWVbaWRdID09PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWVbaWRdID0gZnJhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgZGVmKHZhbHVlLCBpZCwgZnJhZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybignRnJvemVuIHYtZm9yIG9iamVjdHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgdHJhY2tlZCwgbWFrZSBzdXJlIHRvICcgKyAncHJvdmlkZSBhIHRyYWNrLWJ5IGtleS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZy5yYXcgPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiBnZXRDYWNoZWRGcmFnKHZhbHVlLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBmcmFnO1xuICAgIGlmIChrZXkgfHwgdHJhY2tCeUtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgZnJhZyA9IHRoaXMuY2FjaGVbaWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnID0gdmFsdWVbdGhpcy5pZF07XG4gICAgfVxuICAgIGlmIChmcmFnICYmIChmcmFnLnJldXNlZCB8fCBmcmFnLmZyZXNoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgZnJhZ21lbnQgZnJvbSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKi9cblxuICBkZWxldGVDYWNoZWRGcmFnOiBmdW5jdGlvbiBkZWxldGVDYWNoZWRGcmFnKGZyYWcpIHtcbiAgICB2YXIgdmFsdWUgPSBmcmFnLnJhdztcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIHNjb3BlID0gZnJhZy5zY29wZTtcbiAgICB2YXIgaW5kZXggPSBzY29wZS4kaW5kZXg7XG4gICAgLy8gZml4ICM5NDg6IGF2b2lkIGFjY2lkZW50YWxseSBmYWxsIHRocm91Z2ggdG9cbiAgICAvLyBhIHBhcmVudCByZXBlYXRlciB3aGljaCBoYXBwZW5zIHRvIGhhdmUgJGtleS5cbiAgICB2YXIga2V5ID0gaGFzT3duKHNjb3BlLCAnJGtleScpICYmIHNjb3BlLiRrZXk7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgaWYgKHRyYWNrQnlLZXkgfHwga2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlW3RoaXMuaWRdID0gbnVsbDtcbiAgICAgIGZyYWcucmF3ID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhZ2dlciBhbW91bnQgZm9yIGFuIGluc2VydGlvbi9yZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICovXG5cbiAgZ2V0U3RhZ2dlcjogZnVuY3Rpb24gZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSArICdTdGFnZ2VyJztcbiAgICB2YXIgdHJhbnMgPSBmcmFnLm5vZGUuX192X3RyYW5zO1xuICAgIHZhciBob29rcyA9IHRyYW5zICYmIHRyYW5zLmhvb2tzO1xuICAgIHZhciBob29rID0gaG9va3MgJiYgKGhvb2tzW3R5cGVdIHx8IGhvb2tzLnN0YWdnZXIpO1xuICAgIHJldHVybiBob29rID8gaG9vay5jYWxsKGZyYWcsIGluZGV4LCB0b3RhbCkgOiBpbmRleCAqIHBhcnNlSW50KHRoaXMucGFyYW1zW3R5cGVdIHx8IHRoaXMucGFyYW1zLnN0YWdnZXIsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgdGhlIHZhbHVlIGJlZm9yZSBwaXBpbmcgaXQgdGhyb3VnaCB0aGVcbiAgICogZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICovXG5cbiAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uIF9wcmVQcm9jZXNzKHZhbHVlKSB7XG4gICAgLy8gcmVnYXJkbGVzcyBvZiB0eXBlLCBzdG9yZSB0aGUgdW4tZmlsdGVyZWQgcmF3IHZhbHVlLlxuICAgIHRoaXMucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvc3QtcHJvY2VzcyB0aGUgdmFsdWUgYWZ0ZXIgaXQgaGFzIGJlZW4gcGlwZWQgdGhyb3VnaFxuICAgKiB0aGUgZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICpcbiAgICogSXQgaXMgbmVjZXNzYXJ5IGZvciB0aGlzIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlXG4gICAqIHdhdGNoZXIncyBkZXBlbmRlbmN5IGNvbGxlY3Rpb24gcGhhc2UgYmVjYXVzZSB3ZSB3YW50XG4gICAqIHRoZSB2LWZvciB0byB1cGRhdGUgd2hlbiB0aGUgc291cmNlIE9iamVjdCBpcyBtdXRhdGVkLlxuICAgKi9cblxuICBfcG9zdFByb2Nlc3M6IGZ1bmN0aW9uIF9wb3N0UHJvY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGNvbnZlcnQgcGxhaW4gb2JqZWN0IHRvIGFycmF5LlxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJlc1tpXSA9IHtcbiAgICAgICAgICAka2V5OiBrZXksXG4gICAgICAgICAgJHZhbHVlOiB2YWx1ZVtrZXldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gcmFuZ2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlIHx8IFtdO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJlZikge1xuICAgICAgKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzW3RoaXMuZGVzY3JpcHRvci5yZWZdID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ3MpIHtcbiAgICAgIHZhciBpID0gdGhpcy5mcmFncy5sZW5ndGg7XG4gICAgICB2YXIgZnJhZztcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZnJhZ3NbaV07XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKTtcbiAgICAgICAgZnJhZy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciB0byBmaW5kIHRoZSBwcmV2aW91cyBlbGVtZW50IHRoYXQgaXMgYSBmcmFnbWVudFxuICogYW5jaG9yLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgZGVzdHJveWVkIGZyYWcnc1xuICogZWxlbWVudCBjb3VsZCBzdGlsbCBiZSBsaW5nZXJpbmcgaW4gdGhlIERPTSBiZWZvcmUgaXRzXG4gKiBsZWF2aW5nIHRyYW5zaXRpb24gZmluaXNoZXMsIGJ1dCBpdHMgaW5zZXJ0ZWQgZmxhZ1xuICogc2hvdWxkIGhhdmUgYmVlbiBzZXQgdG8gZmFsc2Ugc28gd2UgY2FuIHNraXAgdGhlbS5cbiAqXG4gKiBJZiB0aGlzIGlzIGEgYmxvY2sgcmVwZWF0LCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBvbmx5XG4gKiByZXR1cm4gZnJhZyB0aGF0IGlzIGJvdW5kIHRvIHRoaXMgdi1mb3IuIChzZWUgIzkyOSlcbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge0NvbW1lbnR8VGV4dH0gYW5jaG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGZpbmRQcmV2RnJhZyhmcmFnLCBhbmNob3IsIGlkKSB7XG4gIHZhciBlbCA9IGZyYWcubm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGZyYWcgPSBlbC5fX3ZfZnJhZztcbiAgd2hpbGUgKCghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiYgZWwgIT09IGFuY2hvcikge1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBmcmFnID0gZWwuX192X2ZyYWc7XG4gIH1cbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogRmluZCBhIHZtIGZyb20gYSBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGZpbmRWbUZyb21GcmFnKGZyYWcpIHtcbiAgdmFyIG5vZGUgPSBmcmFnLm5vZGU7XG4gIC8vIGhhbmRsZSBtdWx0aS1ub2RlIGZyYWdcbiAgaWYgKGZyYWcuZW5kKSB7XG4gICAgd2hpbGUgKCFub2RlLl9fdnVlX18gJiYgbm9kZSAhPT0gZnJhZy5lbmQgJiYgbm9kZS5uZXh0U2libGluZykge1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlLl9fdnVlX187XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmFuZ2UgYXJyYXkgZnJvbSBnaXZlbiBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHJhbmdlKG4pIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShNYXRoLmZsb29yKG4pKTtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByZXRbaV0gPSBpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0cmFjayBieSBrZXkgZm9yIGFuIGl0ZW0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3RyYWNrQnlLZXldXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSkge1xuICByZXR1cm4gdHJhY2tCeUtleSA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnID8gaW5kZXggOiB0cmFja0J5S2V5LmNoYXJBdCgwKS5tYXRjaCgvXFx3LykgPyBnZXRQYXRoKHZhbHVlLCB0cmFja0J5S2V5KSA6IHZhbHVlW3RyYWNrQnlLZXldIDoga2V5IHx8IHZhbHVlO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2Rm9yLndhcm5EdXBsaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB3YXJuKCdEdXBsaWNhdGUgdmFsdWUgZm91bmQgaW4gdi1mb3I9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgKyAneW91IGFyZSBleHBlY3RpbmcgZHVwbGljYXRlIHZhbHVlcy4nLCB0aGlzLnZtKTtcbiAgfTtcbn1cblxudmFyIHZJZiA9IHtcblxuICBwcmlvcml0eTogSUYsXG4gIHRlcm1pbmFsOiB0cnVlLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoIWVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICAgIHZhciBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICB0aGlzLmVsc2VFbCA9IG5leHQ7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBtYWluIGJsb2NrXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1pZicpO1xuICAgICAgcmVwbGFjZShlbCwgdGhpcy5hbmNob3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtaWY9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGNhbm5vdCBiZSAnICsgJ3VzZWQgb24gYW4gaW5zdGFuY2Ugcm9vdCBlbGVtZW50LicsIHRoaXMudm0pO1xuICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSByZXR1cm47XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZykge1xuICAgICAgICB0aGlzLmluc2VydCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCgpIHtcbiAgICBpZiAodGhpcy5lbHNlRnJhZykge1xuICAgICAgdGhpcy5lbHNlRnJhZy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZWxzZUZyYWcgPSBudWxsO1xuICAgIH1cbiAgICAvLyBsYXp5IGluaXQgZmFjdG9yeVxuICAgIGlmICghdGhpcy5mYWN0b3J5KSB7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKTtcbiAgICB0aGlzLmZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcucmVtb3ZlKCk7XG4gICAgICB0aGlzLmZyYWcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRWwgJiYgIXRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIGlmICghdGhpcy5lbHNlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmVsc2VGYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLmVsc2VFbC5fY29udGV4dCB8fCB0aGlzLnZtLCB0aGlzLmVsc2VFbCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsc2VGcmFnID0gdGhpcy5lbHNlRmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgICAgdGhpcy5lbHNlRnJhZy5iZWZvcmUodGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRnJhZykge1xuICAgICAgdGhpcy5lbHNlRnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvdyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICB2YXIgbmV4dCA9IHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmVsc2VFbCA9IG5leHQ7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5hcHBseSh0aGlzLmVsLCB2YWx1ZSk7XG4gICAgaWYgKHRoaXMuZWxzZUVsKSB7XG4gICAgICB0aGlzLmFwcGx5KHRoaXMuZWxzZUVsLCAhdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkoZWwsIHZhbHVlKSB7XG4gICAgaWYgKGluRG9jKGVsKSkge1xuICAgICAgYXBwbHlUcmFuc2l0aW9uKGVsLCB2YWx1ZSA/IDEgOiAtMSwgdG9nZ2xlLCB0aGlzLnZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9nZ2xlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRleHQkMiA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpc1JhbmdlID0gZWwudHlwZSA9PT0gJ3JhbmdlJztcbiAgICB2YXIgbGF6eSA9IHRoaXMucGFyYW1zLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHRoaXMucGFyYW1zLm51bWJlcjtcbiAgICB2YXIgZGVib3VuY2UgPSB0aGlzLnBhcmFtcy5kZWJvdW5jZTtcblxuICAgIC8vIGhhbmRsZSBjb21wb3NpdGlvbiBldmVudHMuXG4gICAgLy8gICBodHRwOi8vYmxvZy5ldmFueW91Lm1lLzIwMTQvMDEvMDMvY29tcG9zaXRpb24tZXZlbnQvXG4gICAgLy8gc2tpcCB0aGlzIGZvciBBbmRyb2lkIGJlY2F1c2UgaXQgaGFuZGxlcyBjb21wb3NpdGlvblxuICAgIC8vIGV2ZW50cyBxdWl0ZSBkaWZmZXJlbnRseS4gQW5kcm9pZCBkb2Vzbid0IHRyaWdnZXJcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgZm9yIGxhbmd1YWdlIGlucHV0IG1ldGhvZHMgZS5nLlxuICAgIC8vIENoaW5lc2UsIGJ1dCBpbnN0ZWFkIHRyaWdnZXJzIHRoZW0gZm9yIHNwZWxsaW5nXG4gICAgLy8gc3VnZ2VzdGlvbnMuLi4gKHNlZSBEaXNjdXNzaW9uLyMxNjIpXG4gICAgdmFyIGNvbXBvc2luZyA9IGZhbHNlO1xuICAgIGlmICghaXNBbmRyb2lkICYmICFpc1JhbmdlKSB7XG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbnN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGluIElFMTEgdGhlIFwiY29tcG9zaXRpb25lbmRcIiBldmVudCBmaXJlcyBBRlRFUlxuICAgICAgICAvLyB0aGUgXCJpbnB1dFwiIGV2ZW50LCBzbyB0aGUgaW5wdXQgaGFuZGxlciBpcyBibG9ja2VkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuLi4gaGF2ZSB0byBjYWxsIGl0IGhlcmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICMxMzI3OiBpbiBsYXp5IG1vZGUgdGhpcyBpcyB1bmVjZXNzYXJ5LlxuICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgbWVzc2luZyB3aXRoIHRoZSBpbnB1dCB3aGVuIHVzZXIgaXMgdHlwaW5nLFxuICAgIC8vIGFuZCBmb3JjZSB1cGRhdGUgb24gYmx1ci5cbiAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICBpZiAoIWlzUmFuZ2UgJiYgIWxhenkpIHtcbiAgICAgIHRoaXMub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gZG8gbm90IHN5bmMgdmFsdWUgYWZ0ZXIgZnJhZ21lbnQgcmVtb3ZhbCAoIzIwMTcpXG4gICAgICAgIGlmICghc2VsZi5fZnJhZyB8fCBzZWxmLl9mcmFnLmluc2VydGVkKSB7XG4gICAgICAgICAgc2VsZi5yYXdMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBOb3cgYXR0YWNoIHRoZSBtYWluIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IHRoaXMucmF3TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29tcG9zaW5nIHx8ICFzZWxmLl9ib3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gbnVtYmVyIHx8IGlzUmFuZ2UgPyB0b051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICAgIHNlbGYuc2V0KHZhbCk7XG4gICAgICAvLyBmb3JjZSB1cGRhdGUgb24gbmV4dCB0aWNrIHRvIGF2b2lkIGxvY2sgJiBzYW1lIHZhbHVlXG4gICAgICAvLyBhbHNvIG9ubHkgdXBkYXRlIHdoZW4gdXNlciBpcyBub3QgdHlwaW5nXG4gICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLl9ib3VuZCAmJiAhc2VsZi5mb2N1c2VkKSB7XG4gICAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBhcHBseSBkZWJvdW5jZVxuICAgIGlmIChkZWJvdW5jZSkge1xuICAgICAgdGhpcy5saXN0ZW5lciA9IF9kZWJvdW5jZSh0aGlzLmxpc3RlbmVyLCBkZWJvdW5jZSk7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBqUXVlcnkgZXZlbnRzLCBzaW5jZSBqUXVlcnkudHJpZ2dlcigpIGRvZXNuJ3RcbiAgICAvLyB0cmlnZ2VyIG5hdGl2ZSBldmVudHMgaW4gc29tZSBjYXNlcyBhbmQgc29tZSBwbHVnaW5zXG4gICAgLy8gcmVseSBvbiAkLnRyaWdnZXIoKVxuICAgIC8vXG4gICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgaWYgYSBsaXN0ZW5lciBpcyBhdHRhY2hlZCB1c2luZ1xuICAgIC8vIGpRdWVyeSwgaXQgaXMgYWxzbyByZW1vdmVkIHdpdGggalF1ZXJ5LCB0aGF0J3Mgd2h5XG4gICAgLy8gd2UgZG8gdGhlIGNoZWNrIGZvciBlYWNoIGRpcmVjdGl2ZSBpbnN0YW5jZSBhbmRcbiAgICAvLyBzdG9yZSB0aGF0IGNoZWNrIHJlc3VsdCBvbiBpdHNlbGYuIFRoaXMgYWxzbyBhbGxvd3NcbiAgICAvLyBlYXNpZXIgdGVzdCBjb3ZlcmFnZSBjb250cm9sIGJ5IHVuc2V0dGluZyB0aGUgZ2xvYmFsXG4gICAgLy8galF1ZXJ5IHZhcmlhYmxlIGluIHRlc3RzLlxuICAgIHRoaXMuaGFzalF1ZXJ5ID0gdHlwZW9mIGpRdWVyeSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub24gPyAnb24nIDogJ2JpbmQnO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdjaGFuZ2UnLCB0aGlzLnJhd0xpc3RlbmVyKTtcbiAgICAgIGlmICghbGF6eSkge1xuICAgICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIHRoaXMub24oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU5IGRvZXNuJ3QgZmlyZSBpbnB1dCBldmVudCBvbiBiYWNrc3BhY2UvZGVsL2N1dFxuICAgIGlmICghbGF6eSAmJiBpc0lFOSkge1xuICAgICAgdGhpcy5vbignY3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljayhzZWxmLmxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA0NiB8fCBlLmtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCBpbml0aWFsIHZhbHVlIGlmIHByZXNlbnRcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpIHx8IGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgZWwudmFsdWUudHJpbSgpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgLy8gIzMwMjkgb25seSB1cGRhdGUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gVGhpcyBwcmV2ZW50XG4gICAgLy8gYnJvd3NlcnMgZnJvbSBvdmVyd3JpdGluZyB2YWx1ZXMgbGlrZSBzZWxlY3Rpb25TdGFydFxuICAgIHZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuZWwudmFsdWUpIHRoaXMuZWwudmFsdWUgPSB2YWx1ZTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByYWRpbyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHZhbHVlIG92ZXJ3cml0ZSB2aWEgdi1iaW5kOnZhbHVlXG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZWwudmFsdWU7XG4gICAgICBpZiAoc2VsZi5wYXJhbXMubnVtYmVyKSB7XG4gICAgICAgIHZhbCA9IHRvTnVtYmVyKHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICB9O1xuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5lbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgfVxufTtcblxudmFyIHNlbGVjdCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIC8vIG1ldGhvZCB0byBmb3JjZSB1cGRhdGUgRE9NIHVzaW5nIGxhdGVzdCB2YWx1ZS5cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX3dhdGNoZXIpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci5nZXQoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYSBtdWx0aXBsZSBzZWxlY3RcbiAgICB2YXIgbXVsdGlwbGUgPSB0aGlzLm11bHRpcGxlID0gZWwuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpO1xuXG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSk7XG4gICAgICB2YWx1ZSA9IHNlbGYucGFyYW1zLm51bWJlciA/IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHRvTnVtYmVyKSA6IHRvTnVtYmVyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsdWUpO1xuICAgIH07XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICAvLyBpZiBoYXMgaW5pdGlhbCB2YWx1ZSwgc2V0IGFmdGVyQmluZFxuICAgIHZhciBpbml0VmFsdWUgPSBnZXRWYWx1ZShlbCwgbXVsdGlwbGUsIHRydWUpO1xuICAgIGlmIChtdWx0aXBsZSAmJiBpbml0VmFsdWUubGVuZ3RoIHx8ICFtdWx0aXBsZSAmJiBpbml0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG5cbiAgICAvLyBBbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IEZpcmVmb3ggcmVzZXRzXG4gICAgLy8gc2VsZWN0ZWRJbmRleCB3aXRoIHZhbHVlIC0xIHRvIDAgd2hlbiB0aGUgZWxlbWVudFxuICAgIC8vIGlzIGFwcGVuZGVkIHRvIGEgbmV3IHBhcmVudCwgdGhlcmVmb3JlIHdlIGhhdmUgdG9cbiAgICAvLyBmb3JjZSBhIERPTSB1cGRhdGUgd2hlbmV2ZXIgdGhhdCBoYXBwZW5zLi4uXG4gICAgdGhpcy52bS4kb24oJ2hvb2s6YXR0YWNoZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBuZXh0VGljayhfdGhpcy5mb3JjZVVwZGF0ZSk7XG4gICAgfSk7XG4gICAgaWYgKCFpbkRvYyhlbCkpIHtcbiAgICAgIG5leHRUaWNrKHRoaXMuZm9yY2VVcGRhdGUpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIHZhciBtdWx0aSA9IHRoaXMubXVsdGlwbGUgJiYgaXNBcnJheSh2YWx1ZSk7XG4gICAgdmFyIG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICAgIHZhciBpID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgdmFyIG9wLCB2YWw7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgb3AgPSBvcHRpb25zW2ldO1xuICAgICAgdmFsID0gb3AuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gb3AuX3ZhbHVlIDogb3AudmFsdWU7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgIG9wLnNlbGVjdGVkID0gbXVsdGkgPyBpbmRleE9mJDEodmFsdWUsIHZhbCkgPiAtMSA6IGxvb3NlRXF1YWwodmFsdWUsIHZhbCk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRoaXMudm0uJG9mZignaG9vazphdHRhY2hlZCcsIHRoaXMuZm9yY2VVcGRhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBzZWxlY3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1NlbGVjdEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FycmF5fCp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwsIG11bHRpLCBpbml0KSB7XG4gIHZhciByZXMgPSBtdWx0aSA/IFtdIDogbnVsbDtcbiAgdmFyIG9wLCB2YWwsIHNlbGVjdGVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3AgPSBlbC5vcHRpb25zW2ldO1xuICAgIHNlbGVjdGVkID0gaW5pdCA/IG9wLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA6IG9wLnNlbGVjdGVkO1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgdmFsID0gb3AuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gb3AuX3ZhbHVlIDogb3AudmFsdWU7XG4gICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogTmF0aXZlIEFycmF5LmluZGV4T2YgdXNlcyBzdHJpY3QgZXF1YWwsIGJ1dCBpbiB0aGlzXG4gKiBjYXNlIHdlIG5lZWQgdG8gbWF0Y2ggc3RyaW5nL251bWJlcnMgd2l0aCBjdXN0b20gZXF1YWwuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIGluZGV4T2YkMShhcnIsIHZhbCkge1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBjaGVja2JveCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBlbC5fdmFsdWUgOiBzZWxmLnBhcmFtcy5udW1iZXIgPyB0b051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm9vbGVhblZhbHVlKCkge1xuICAgICAgdmFyIHZhbCA9IGVsLmNoZWNrZWQ7XG4gICAgICBpZiAodmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfdHJ1ZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl90cnVlVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbCAmJiBlbC5oYXNPd25Qcm9wZXJ0eSgnX2ZhbHNlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX2ZhbHNlVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbW9kZWwgPSBzZWxmLl93YXRjaGVyLnZhbHVlO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobW9kZWwsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICBtb2RlbC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLiRyZW1vdmUodmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZXQoZ2V0Qm9vbGVhblZhbHVlKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZWwuY2hlY2tlZCA9IGluZGV4T2YodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSkgPiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdHJ1ZVZhbHVlJykpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGVsLl90cnVlVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gIHRleHQ6IHRleHQkMixcbiAgcmFkaW86IHJhZGlvLFxuICBzZWxlY3Q6IHNlbGVjdCxcbiAgY2hlY2tib3g6IGNoZWNrYm94XG59O1xuXG52YXIgbW9kZWwgPSB7XG5cbiAgcHJpb3JpdHk6IE1PREVMLFxuICB0d29XYXk6IHRydWUsXG4gIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgcGFyYW1zOiBbJ2xhenknLCAnbnVtYmVyJywgJ2RlYm91bmNlJ10sXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgKiAgIDxzZWxlY3Q+XG4gICAqICAgPHRleHRhcmVhPlxuICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgKiAgICAgLSB0ZXh0XG4gICAqICAgICAtIGNoZWNrYm94XG4gICAqICAgICAtIHJhZGlvXG4gICAqICAgICAtIG51bWJlclxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGZyaWVuZGx5IHdhcm5pbmcuLi5cbiAgICB0aGlzLmNoZWNrRmlsdGVycygpO1xuICAgIGlmICh0aGlzLmhhc1JlYWQgJiYgIXRoaXMuaGFzV3JpdGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyBhIHJlYWQtb25seSBmaWx0ZXIgd2l0aCAnICsgJ3YtbW9kZWw9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIi4gJyArICdZb3UgbWlnaHQgd2FudCB0byB1c2UgYSB0d28td2F5IGZpbHRlciB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci4nLCB0aGlzLnZtKTtcbiAgICB9XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgdGFnID0gZWwudGFnTmFtZTtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnNbZWwudHlwZV0gfHwgaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy5zZWxlY3Q7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBlbGVtZW50IHR5cGU6ICcgKyB0YWcsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbC5fX3ZfbW9kZWwgPSB0aGlzO1xuICAgIGhhbmRsZXIuYmluZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlID0gaGFuZGxlci51cGRhdGU7XG4gICAgdGhpcy5fdW5iaW5kID0gaGFuZGxlci51bmJpbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHJlYWQvd3JpdGUgZmlsdGVyIHN0YXRzLlxuICAgKi9cblxuICBjaGVja0ZpbHRlcnM6IGZ1bmN0aW9uIGNoZWNrRmlsdGVycygpIHtcbiAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAoIWZpbHRlcnMpIHJldHVybjtcbiAgICB2YXIgaSA9IGZpbHRlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBmaWx0ZXIgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXJzW2ldLm5hbWUpO1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLnJlYWQpIHtcbiAgICAgICAgdGhpcy5oYXNSZWFkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIud3JpdGUpIHtcbiAgICAgICAgdGhpcy5oYXNXcml0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuZWwuX192X21vZGVsID0gbnVsbDtcbiAgICB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKCk7XG4gIH1cbn07XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICAnZGVsZXRlJzogWzgsIDQ2XSxcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufTtcblxuZnVuY3Rpb24ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGtleS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyQ29kZSA+IDQ3ICYmIGNoYXJDb2RlIDwgNTgpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNoYXJDb2RlID0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDY0ICYmIGNoYXJDb2RlIDwgOTEpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5Q29kZXNba2V5XTtcbiAgfSk7XG4gIGNvZGVzID0gW10uY29uY2F0LmFwcGx5KFtdLCBjb2Rlcyk7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICBpZiAoY29kZXMuaW5kZXhPZihlLmtleUNvZGUpID4gLTEpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdG9wRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEhhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxmRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGZIYW5kbGVyKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBvbiQxID0ge1xuXG4gIHByaW9yaXR5OiBPTixcbiAgYWNjZXB0U3RhdGVtZW50OiB0cnVlLFxuICBrZXlDb2Rlczoga2V5Q29kZXMsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBkZWFsIHdpdGggaWZyYW1lc1xuICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdJRlJBTUUnICYmIHRoaXMuYXJnICE9PSAnbG9hZCcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuaWZyYW1lQmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyLCBzZWxmLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdsb2FkJywgdGhpcy5pZnJhbWVCaW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaGFuZGxlcikge1xuICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgLy8gZS5nLiBAbW91c2Vkb3duLnByZXZlbnRcbiAgICBpZiAoIXRoaXMuZGVzY3JpcHRvci5yYXcpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1vbjonICsgdGhpcy5hcmcgKyAnPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBleHBlY3RzIGEgZnVuY3Rpb24gdmFsdWUsICcgKyAnZ290ICcgKyBoYW5kbGVyLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBtb2RpZmllcnNcbiAgICBpZiAodGhpcy5tb2RpZmllcnMuc3RvcCkge1xuICAgICAgaGFuZGxlciA9IHN0b3BGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGlmaWVycy5wcmV2ZW50KSB7XG4gICAgICBoYW5kbGVyID0gcHJldmVudEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnNlbGYpIHtcbiAgICAgIGhhbmRsZXIgPSBzZWxmRmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBrZXkgZmlsdGVyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGlmaWVycykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT09ICdzdG9wJyAmJiBrZXkgIT09ICdwcmV2ZW50JyAmJiBrZXkgIT09ICdzZWxmJyAmJiBrZXkgIT09ICdjYXB0dXJlJztcbiAgICB9KTtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5pZnJhbWVCaW5kKSB7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb24odGhpcy5lbCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlciwgdGhpcy5tb2RpZmllcnMuY2FwdHVyZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmlmcmFtZUJpbmQgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3cgOiB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgIG9mZihlbCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ107XG52YXIgY2FtZWxQcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xudmFyIGltcG9ydGFudFJFID0gLyFpbXBvcnRhbnQ7PyQvO1xudmFyIHByb3BDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciB0ZXN0RWwgPSBudWxsO1xuXG52YXIgc3R5bGUgPSB7XG5cbiAgZGVlcDogdHJ1ZSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZS5yZWR1Y2UoZXh0ZW5kLCB7fSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gaGFuZGxlT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gY2FjaGUgb2JqZWN0IHN0eWxlcyBzbyB0aGF0IG9ubHkgY2hhbmdlZCBwcm9wc1xuICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgfHwgKHRoaXMuY2FjaGUgPSB7fSk7XG4gICAgdmFyIG5hbWUsIHZhbDtcbiAgICBmb3IgKG5hbWUgaW4gY2FjaGUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIG51bGwpO1xuICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgdmFsID0gdmFsdWVbbmFtZV07XG4gICAgICBpZiAodmFsICE9PSBjYWNoZVtuYW1lXSkge1xuICAgICAgICBjYWNoZVtuYW1lXSA9IHZhbDtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUocHJvcCwgdmFsdWUpIHtcbiAgICBwcm9wID0gbm9ybWFsaXplKHByb3ApO1xuICAgIGlmICghcHJvcCkgcmV0dXJuOyAvLyB1bnN1cHBvcnRlZCBwcm9wXG4gICAgLy8gY2FzdCBwb3NzaWJsZSBudW1iZXJzL2Jvb2xlYW5zIGludG8gc3RyaW5nc1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhciBpc0ltcG9ydGFudCA9IGltcG9ydGFudFJFLnRlc3QodmFsdWUpID8gJ2ltcG9ydGFudCcgOiAnJztcbiAgICAgIGlmIChpc0ltcG9ydGFudCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdJdFxcJ3MgcHJvYmFibHkgYSBiYWQgaWRlYSB0byB1c2UgIWltcG9ydGFudCB3aXRoIGlubGluZSBydWxlcy4gJyArICdUaGlzIGZlYXR1cmUgd2lsbCBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgVnVlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLmtlYmFiLCB2YWx1ZSwgaXNJbXBvcnRhbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZVtwcm9wLmNhbWVsXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLnN0eWxlW3Byb3AuY2FtZWxdID0gJyc7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKiAtIGNhY2hlIHJlc3VsdFxuICogLSBhdXRvIHByZWZpeFxuICogLSBjYW1lbENhc2UgLT4gZGFzaC1jYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUocHJvcCkge1xuICBpZiAocHJvcENhY2hlW3Byb3BdKSB7XG4gICAgcmV0dXJuIHByb3BDYWNoZVtwcm9wXTtcbiAgfVxuICB2YXIgcmVzID0gcHJlZml4KHByb3ApO1xuICBwcm9wQ2FjaGVbcHJvcF0gPSBwcm9wQ2FjaGVbcmVzXSA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81MjM2OTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeChwcm9wKSB7XG4gIHByb3AgPSBoeXBoZW5hdGUocHJvcCk7XG4gIHZhciBjYW1lbCA9IGNhbWVsaXplKHByb3ApO1xuICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpO1xuICBpZiAoIXRlc3RFbCkge1xuICAgIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG4gIHZhciBpID0gcHJlZml4ZXMubGVuZ3RoO1xuICB2YXIgcHJlZml4ZWQ7XG4gIGlmIChjYW1lbCAhPT0gJ2ZpbHRlcicgJiYgY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlYmFiOiBwcm9wLFxuICAgICAgY2FtZWw6IGNhbWVsXG4gICAgfTtcbiAgfVxuICB3aGlsZSAoaS0tKSB7XG4gICAgcHJlZml4ZWQgPSBjYW1lbFByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2ViYWI6IHByZWZpeGVzW2ldICsgcHJvcCxcbiAgICAgICAgY2FtZWw6IHByZWZpeGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyB4bGlua1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG52YXIgeGxpbmtSRSA9IC9eeGxpbms6LztcblxuLy8gY2hlY2sgZm9yIGF0dHJpYnV0ZXMgdGhhdCBwcm9oaWJpdCBpbnRlcnBvbGF0aW9uc1xudmFyIGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUgPSAvXnYtfF46fF5AfF4oPzppc3x0cmFuc2l0aW9ufHRyYW5zaXRpb24tbW9kZXxkZWJvdW5jZXx0cmFjay1ieXxzdGFnZ2VyfGVudGVyLXN0YWdnZXJ8bGVhdmUtc3RhZ2dlcikkLztcbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIGFsc28gc2V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xuLy8gYmVjYXVzZSB0aGV5IG9ubHkgYWZmZWN0IHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBlbGVtZW50XG52YXIgYXR0cldpdGhQcm9wc1JFID0gL14oPzp2YWx1ZXxjaGVja2VkfHNlbGVjdGVkfG11dGVkKSQvO1xuLy8gdGhlc2UgYXR0cmlidXRlcyBleHBlY3QgZW51bXJhdGVkIHZhbHVlcyBvZiBcInRydWVcIiBvciBcImZhbHNlXCJcbi8vIGJ1dCBhcmUgbm90IGJvb2xlYW4gYXR0cmlidXRlc1xudmFyIGVudW1lcmF0ZWRBdHRyUkUgPSAvXig/OmRyYWdnYWJsZXxjb250ZW50ZWRpdGFibGV8c3BlbGxjaGVjaykkLztcblxuLy8gdGhlc2UgYXR0cmlidXRlcyBzaG91bGQgc2V0IGEgaGlkZGVuIHByb3BlcnR5IGZvclxuLy8gYmluZGluZyB2LW1vZGVsIHRvIG9iamVjdCB2YWx1ZXNcbnZhciBtb2RlbFByb3BzID0ge1xuICB2YWx1ZTogJ192YWx1ZScsXG4gICd0cnVlLXZhbHVlJzogJ190cnVlVmFsdWUnLFxuICAnZmFsc2UtdmFsdWUnOiAnX2ZhbHNlVmFsdWUnXG59O1xuXG52YXIgYmluZCQxID0ge1xuXG4gIHByaW9yaXR5OiBCSU5ELFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZztcbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lO1xuICAgIC8vIHNob3VsZCBiZSBkZWVwIHdhdGNoIG9uIG9iamVjdCBtb2RlXG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICB0aGlzLmRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbiBiaW5kaW5nc1xuICAgIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuICAgIHZhciB0b2tlbnMgPSBkZXNjcmlwdG9yLmludGVycDtcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbnMgd2l0aCBvbmUtdGltZSB0b2tlbnNcbiAgICAgIGlmIChkZXNjcmlwdG9yLmhhc09uZVRpbWUpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gdG9rZW5zVG9FeHAodG9rZW5zLCB0aGlzLl9zY29wZSB8fCB0aGlzLnZtKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBhbGxvdyBiaW5kaW5nIG9uIG5hdGl2ZSBhdHRyaWJ1dGVzXG4gICAgICBpZiAoZGlzYWxsb3dlZEludGVycEF0dHJSRS50ZXN0KGF0dHIpIHx8IGF0dHIgPT09ICduYW1lJyAmJiAodGFnID09PSAnUEFSVElBTCcgfHwgdGFnID09PSAnU0xPVCcpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihhdHRyICsgJz1cIicgKyBkZXNjcmlwdG9yLnJhdyArICdcIjogJyArICdhdHRyaWJ1dGUgaW50ZXJwb2xhdGlvbiBpcyBub3QgYWxsb3dlZCBpbiBWdWUuanMgJyArICdkaXJlY3RpdmVzIGFuZCBzcGVjaWFsIGF0dHJpYnV0ZXMuJywgdGhpcy52bSk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByYXcgPSBhdHRyICsgJz1cIicgKyBkZXNjcmlwdG9yLnJhdyArICdcIjogJztcbiAgICAgICAgLy8gd2FybiBzcmNcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzcmMnKSB7XG4gICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInNyY1wiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAnYSA0MDQgcmVxdWVzdC4gVXNlIHYtYmluZDpzcmMgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhcm4gc3R5bGVcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICB3YXJuKHJhdyArICdpbnRlcnBvbGF0aW9uIGluIFwic3R5bGVcIiBhdHRyaWJ1dGUgd2lsbCBjYXVzZSAnICsgJ3RoZSBhdHRyaWJ1dGUgdG8gYmUgZGlzY2FyZGVkIGluIEludGVybmV0IEV4cGxvcmVyLiAnICsgJ1VzZSB2LWJpbmQ6c3R5bGUgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZztcbiAgICBpZiAodGhpcy5hcmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pO1xuICAgIH1cbiAgfSxcblxuICAvLyBzaGFyZSBvYmplY3QgaGFuZGxlciB3aXRoIHYtYmluZDpjbGFzc1xuICBoYW5kbGVPYmplY3Q6IHN0eWxlLmhhbmRsZU9iamVjdCxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIGhhbmRsZVNpbmdsZShhdHRyLCB2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGludGVycCA9IHRoaXMuZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICBhdHRyID0gY2FtZWxpemUoYXR0cik7XG4gICAgfVxuICAgIGlmICghaW50ZXJwICYmIGF0dHJXaXRoUHJvcHNSRS50ZXN0KGF0dHIpICYmIGF0dHIgaW4gZWwpIHtcbiAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyID09PSAndmFsdWUnID8gdmFsdWUgPT0gbnVsbCAvLyBJRTkgd2lsbCBzZXQgaW5wdXQudmFsdWUgdG8gXCJudWxsXCIgZm9yIG51bGwuLi5cbiAgICAgID8gJycgOiB2YWx1ZSA6IHZhbHVlO1xuXG4gICAgICBpZiAoZWxbYXR0cl0gIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICBlbFthdHRyXSA9IGF0dHJWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IG1vZGVsIHByb3BzXG4gICAgdmFyIG1vZGVsUHJvcCA9IG1vZGVsUHJvcHNbYXR0cl07XG4gICAgaWYgKCFpbnRlcnAgJiYgbW9kZWxQcm9wKSB7XG4gICAgICBlbFttb2RlbFByb3BdID0gdmFsdWU7XG4gICAgICAvLyB1cGRhdGUgdi1tb2RlbCBpZiBwcmVzZW50XG4gICAgICB2YXIgbW9kZWwgPSBlbC5fX3ZfbW9kZWw7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwubGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZG8gbm90IHNldCB2YWx1ZSBhdHRyaWJ1dGUgZm9yIHRleHRhcmVhXG4gICAgaWYgKGF0dHIgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgYXR0cmlidXRlXG4gICAgaWYgKGVudW1lcmF0ZWRBdHRyUkUudGVzdChhdHRyKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgLy8gaGFuZGxlIGVkZ2UgY2FzZSAjMTk2MDpcbiAgICAgICAgLy8gY2xhc3MgaW50ZXJwb2xhdGlvbiBzaG91bGQgbm90IG92ZXJ3cml0ZSBWdWUgdHJhbnNpdGlvbiBjbGFzc1xuICAgICAgICBpZiAoZWwuX192X3RyYW5zKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJyAnICsgZWwuX192X3RyYW5zLmlkICsgJy10cmFuc2l0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBzZXRDbGFzcyhlbCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh4bGlua1JFLnRlc3QoYXR0cikpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywgYXR0ciwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZWwgPSB7XG5cbiAgcHJpb3JpdHk6IEVMLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gY2FtZWxpemUodGhpcy5hcmcpO1xuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgaWYgKGhhc093bihyZWZzLCBpZCkpIHtcbiAgICAgIHJlZnNbaWRdID0gdGhpcy5lbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocmVmcywgaWQsIHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChyZWZzW3RoaXMuaWRdID09PSB0aGlzLmVsKSB7XG4gICAgICByZWZzW3RoaXMuaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZWYgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgKyAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJywgdGhpcy52bSk7XG4gIH1cbn07XG5cbnZhciBjbG9hayA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHRoaXMudm0uJG9uY2UoJ3ByZS1ob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJyk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIG11c3QgZXhwb3J0IHBsYWluIG9iamVjdFxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIHRleHQ6IHRleHQkMSxcbiAgaHRtbDogaHRtbCxcbiAgJ2Zvcic6IHZGb3IsXG4gICdpZic6IHZJZixcbiAgc2hvdzogc2hvdyxcbiAgbW9kZWw6IG1vZGVsLFxuICBvbjogb24kMSxcbiAgYmluZDogYmluZCQxLFxuICBlbDogZWwsXG4gIHJlZjogcmVmLFxuICBjbG9hazogY2xvYWtcbn07XG5cbnZhciB2Q2xhc3MgPSB7XG5cbiAgZGVlcDogdHJ1ZSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zZXRDbGFzcyh2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3Mobm9ybWFsaXplJDEodmFsdWUpKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q2xhc3M6IGZ1bmN0aW9uIHNldENsYXNzKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhbnVwKHZhbHVlKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IHZhbHVlW2ldO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICBhcHBseSh0aGlzLmVsLCB2YWwsIGFkZENsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmV2S2V5cyA9IHZhbHVlO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAodmFsdWUpIHtcbiAgICB2YXIgcHJldktleXMgPSB0aGlzLnByZXZLZXlzO1xuICAgIGlmICghcHJldktleXMpIHJldHVybjtcbiAgICB2YXIgaSA9IHByZXZLZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJldktleXNbaV07XG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgYXBwbHkodGhpcy5lbCwga2V5LCByZW1vdmVDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMgKHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgb2JqZWN0cylcbiAqIGludG8gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheTxTdHJpbmd8T2JqZWN0Pn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplJDEodmFsdWUpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIF9rZXkgPSB2YWx1ZVtpXTtcbiAgICAgIGlmIChfa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgX2tleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXMucHVzaChfa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIF9rZXkpIHtcbiAgICAgICAgICAgIGlmIChfa2V5W2tdKSByZXMucHVzaChrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgcmVzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIGEgY2xhc3MvY2xhc3NlcyBvbiBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgY2xhc3MgbmFtZS4gVGhpcyBtYXkgb3IgbWF5IG5vdFxuICogICAgICAgICAgICAgICAgICAgICBjb250YWluIGEgc3BhY2UgY2hhcmFjdGVyLCBpbiBzdWNoIGFcbiAqICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZSdsbCBkZWFsIHdpdGggbXVsdGlwbGUgY2xhc3NcbiAqICAgICAgICAgICAgICAgICAgICAgbmFtZXMgYXQgb25jZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHkoZWwsIGtleSwgZm4pIHtcbiAga2V5ID0ga2V5LnRyaW0oKTtcbiAgaWYgKGtleS5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgZm4oZWwsIGtleSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSBrZXkgY29udGFpbnMgb25lIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVycy5cbiAgLy8gU2luY2UgYSBjbGFzcyBuYW1lIGRvZXNuJ3QgYWNjZXB0IHN1Y2ggY2hhcmFjdGVycywgd2VcbiAgLy8gdHJlYXQgaXQgYXMgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgdmFyIGtleXMgPSBrZXkuc3BsaXQoL1xccysvKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZuKGVsLCBrZXlzW2ldKTtcbiAgfVxufVxuXG52YXIgY29tcG9uZW50ID0ge1xuXG4gIHByaW9yaXR5OiBDT01QT05FTlQsXG5cbiAgcGFyYW1zOiBbJ2tlZXAtYWxpdmUnLCAndHJhbnNpdGlvbi1tb2RlJywgJ2lubGluZS10ZW1wbGF0ZSddLFxuXG4gIC8qKlxuICAgKiBTZXR1cC4gVHdvIHBvc3NpYmxlIHVzYWdlczpcbiAgICpcbiAgICogLSBzdGF0aWM6XG4gICAqICAgPGNvbXA+IG9yIDxkaXYgdi1jb21wb25lbnQ9XCJjb21wXCI+XG4gICAqXG4gICAqIC0gZHluYW1pYzpcbiAgICogICA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICBpZiAoIXRoaXMuZWwuX192dWVfXykge1xuICAgICAgLy8ga2VlcC1hbGl2ZSBjYWNoZVxuICAgICAgdGhpcy5rZWVwQWxpdmUgPSB0aGlzLnBhcmFtcy5rZWVwQWxpdmU7XG4gICAgICBpZiAodGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgIHRoaXMuaW5saW5lVGVtcGxhdGUgPSBleHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXBvbmVudCByZXNvbHV0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gdGhpcy5Db21wb25lbnQgPSBudWxsO1xuICAgICAgLy8gdHJhbnNpdGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscyA9IDA7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgLy8gY3JlYXRlIGEgcmVmIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtY29tcG9uZW50Jyk7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICAgIC8vIHJlbW92ZSBpcyBhdHRyaWJ1dGUuXG4gICAgICAvLyB0aGlzIGlzIHJlbW92ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLCBidXQgYmVjYXVzZSBjb21waWxhdGlvbiBpc1xuICAgICAgLy8gY2FjaGVkLCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdXNlZCBlbHNld2hlcmUgdGhpcyBhdHRyaWJ1dGVcbiAgICAgIC8vIHdpbGwgcmVtYWluIGF0IGxpbmsgdGltZS5cbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJzppcycpO1xuICAgICAgLy8gcmVtb3ZlIHJlZiwgc2FtZSBhcyBhYm92ZVxuICAgICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtcmVmOicgKyBoeXBoZW5hdGUodGhpcy5kZXNjcmlwdG9yLnJlZikpO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhdGljLCBidWlsZCByaWdodCBub3cuXG4gICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignY2Fubm90IG1vdW50IGNvbXBvbmVudCBcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgJyArICdvbiBhbHJlYWR5IG1vdW50ZWQgZWxlbWVudDogJyArIHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAqIGxpdGVyYWwgc2NlbmFyaW8sIGUuZy4gPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmxpdGVyYWwpIHtcbiAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN3aXRjaCBkeW5hbWljIGNvbXBvbmVudHMuIE1heSByZXNvbHZlIHRoZSBjb21wb25lbnRcbiAgICogYXN5bmNocm9ub3VzbHksIGFuZCBwZXJmb3JtIHRyYW5zaXRpb24gYmFzZWQgb25cbiAgICogc3BlY2lmaWVkIHRyYW5zaXRpb24gbW9kZS4gQWNjZXB0cyBhIGZldyBhZGRpdGlvbmFsXG4gICAqIGFyZ3VtZW50cyBzcGVjaWZpY2FsbHkgZm9yIHZ1ZS1yb3V0ZXIuXG4gICAqXG4gICAqIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgZnVsbCB0cmFuc2l0aW9uIGlzXG4gICAqIGZpbmlzaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uIHNldENvbXBvbmVudCh2YWx1ZSwgY2IpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgLy8ganVzdCByZW1vdmUgY3VycmVudFxuICAgICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZFZNLCBjYik7XG4gICAgICB0aGlzLmNoaWxkVk0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciB0byB1c2Ugd2hlbiBjcmVhdGluZ1xuICAgKiB0aGUgY2hpbGQgdm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KHZhbHVlLCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAgIHNlbGYuQ29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5vcHRpb25zLm5hbWUgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IG51bGwpO1xuICAgICAgc2VsZi5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICBjYigpO1xuICAgIH0pO1xuICAgIHRoaXMudm0uX3Jlc29sdmVDb21wb25lbnQodmFsdWUsIHRoaXMucGVuZGluZ0NvbXBvbmVudENiKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yIGFuZFxuICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAqIHdoZXRoZXIgdGhlIG5ldyBjb21wb25lbnQgYW5kIHRoZSBvbGQgb25lIGFyZSBhY3R1YWxseVxuICAgKiB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRDb21wb25lbnQoY2IpIHtcbiAgICAvLyBhY3R1YWwgbW91bnRcbiAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhY3RpdmF0ZUhvb2tzID0gdGhpcy5Db21wb25lbnQub3B0aW9ucy5hY3RpdmF0ZTtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKTtcbiAgICB2YXIgbmV3Q29tcG9uZW50ID0gdGhpcy5idWlsZCgpO1xuICAgIGlmIChhY3RpdmF0ZUhvb2tzICYmICFjYWNoZWQpIHtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG5ld0NvbXBvbmVudDtcbiAgICAgIGNhbGxBY3RpdmF0ZUhvb2tzKGFjdGl2YXRlSG9va3MsIG5ld0NvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi53YWl0aW5nRm9yICE9PSBuZXdDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi53YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgc2VsZi50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSByZWYgZm9yIGtlcHQtYWxpdmUgY29tcG9uZW50XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIG5ld0NvbXBvbmVudC5fdXBkYXRlUmVmKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb21wb25lbnQgY2hhbmdlcyBvciB1bmJpbmRzIGJlZm9yZSBhbiBhc3luY1xuICAgKiBjb25zdHJ1Y3RvciBpcyByZXNvbHZlZCwgd2UgbmVlZCB0byBpbnZhbGlkYXRlIGl0c1xuICAgKiBwZW5kaW5nIGNhbGxiYWNrLlxuICAgKi9cblxuICBpbnZhbGlkYXRlUGVuZGluZzogZnVuY3Rpb24gaW52YWxpZGF0ZVBlbmRpbmcoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbXBvbmVudENiKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYi5jYW5jZWwoKTtcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlL2luc2VydCBhIG5ldyBjaGlsZCB2bS5cbiAgICogSWYga2VlcCBhbGl2ZSBhbmQgaGFzIGNhY2hlZCBpbnN0YW5jZSwgaW5zZXJ0IHRoYXRcbiAgICogaW5zdGFuY2U7IG90aGVyd2lzZSBidWlsZCBhIG5ldyBvbmUgYW5kIGNhY2hlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dHJhT3B0aW9uc11cbiAgICogQHJldHVybiB7VnVlfSAtIHRoZSBjcmVhdGVkIGluc3RhbmNlXG4gICAqL1xuXG4gIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChleHRyYU9wdGlvbnMpIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5Db21wb25lbnQpIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuQ29tcG9uZW50TmFtZSxcbiAgICAgICAgZWw6IGNsb25lTm9kZSh0aGlzLmVsKSxcbiAgICAgICAgdGVtcGxhdGU6IHRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBhZGQgdGhlIGNoaWxkIHdpdGggY29ycmVjdCBwYXJlbnRcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgaXRzIHBhcmVudFxuICAgICAgICAvLyBzaG91bGQgYmUgdGhlIHRyYW5zY2x1c2lvbiBob3N0LlxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2hvc3QgfHwgdGhpcy52bSxcbiAgICAgICAgLy8gaWYgbm8gaW5saW5lLXRlbXBsYXRlLCB0aGVuIHRoZSBjb21waWxlZFxuICAgICAgICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICBfbGlua2VyQ2FjaGFibGU6ICF0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICBfcmVmOiB0aGlzLmRlc2NyaXB0b3IucmVmLFxuICAgICAgICBfYXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgICBfY29udGV4dDogdGhpcy52bSxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAgICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgICAgICBfc2NvcGU6IHRoaXMuX3Njb3BlLFxuICAgICAgICAvLyBwYXNzIGluIHRoZSBvd25lciBmcmFnbWVudCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCB0aGUgZnJhZ21lbnQgY2FuIGtlZXBcbiAgICAgICAgLy8gdHJhY2sgb2YgaXRzIGNvbnRhaW5lZCBjb21wb25lbnRzIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGNhbGwgYXR0YWNoL2RldGFjaCBob29rcyBmb3IgdGhlbS5cbiAgICAgICAgX2ZyYWc6IHRoaXMuX2ZyYWdcbiAgICAgIH07XG4gICAgICAvLyBleHRyYSBvcHRpb25zXG4gICAgICAvLyBpbiAxLjAuMCB0aGlzIGlzIHVzZWQgYnkgdnVlLXJvdXRlciBvbmx5XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKG9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5Db21wb25lbnQob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwuaGFzQXR0cmlidXRlKCd0cmFuc2l0aW9uJykgJiYgY2hpbGQuX2lzRnJhZ21lbnQpIHtcbiAgICAgICAgd2FybignVHJhbnNpdGlvbnMgd2lsbCBub3Qgd29yayBvbiBhIGZyYWdtZW50IGluc3RhbmNlLiAnICsgJ1RlbXBsYXRlOiAnICsgY2hpbGQuJG9wdGlvbnMudGVtcGxhdGUsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyeSB0byBnZXQgYSBjYWNoZWQgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICAgKi9cblxuICBnZXRDYWNoZWQ6IGZ1bmN0aW9uIGdldENhY2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZWVwQWxpdmUgJiYgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIHVuYnVpbGQoZGVmZXIpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRm9yKSB7XG4gICAgICBpZiAoIXRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMud2FpdGluZ0Zvci4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy53YWl0aW5nRm9yID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZFZNO1xuICAgIGlmICghY2hpbGQgfHwgdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAvLyByZW1vdmUgcmVmXG4gICAgICAgIGNoaWxkLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGNoaWxkLl91cGRhdGVSZWYodHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSBzb2xlIHB1cnBvc2Ugb2YgYGRlZmVyQ2xlYW51cGAgaXMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBcImRlYWN0aXZhdGVcIiB0aGUgdm0gcmlnaHQgbm93IGFuZCBwZXJmb3JtIERPTSByZW1vdmFsXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuJGRlc3Ryb3koZmFsc2UsIGRlZmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGN1cnJlbnQgZGVzdHJveWVkIGNoaWxkIGFuZCBtYW51YWxseSBkb1xuICAgKiB0aGUgY2xlYW51cCBhZnRlciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCwgY2IpIHtcbiAgICB2YXIga2VlcEFsaXZlID0gdGhpcy5rZWVwQWxpdmU7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICAvLyB3ZSBtYXkgaGF2ZSBhIGNvbXBvbmVudCBzd2l0Y2ggd2hlbiBhIHByZXZpb3VzXG4gICAgICAvLyBjb21wb25lbnQgaXMgc3RpbGwgYmVpbmcgdHJhbnNpdGlvbmVkIG91dC5cbiAgICAgIC8vIHdlIHdhbnQgdG8gdHJpZ2dlciBvbmx5IG9uZSBsYXN0ZXN0IGluc2VydGlvbiBjYlxuICAgICAgLy8gd2hlbiB0aGUgZXhpc3RpbmcgdHJhbnNpdGlvbiBmaW5pc2hlcy4gKCMxMTE5KVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMrKztcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IGNiO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2hpbGQuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxzLS07XG4gICAgICAgIGlmICgha2VlcEFsaXZlKSBjaGlsZC5fY2xlYW51cCgpO1xuICAgICAgICBpZiAoIXNlbGYucGVuZGluZ1JlbW92YWxzICYmIHNlbGYucGVuZGluZ1JlbW92YWxDYikge1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYigpO1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBY3R1YWxseSBzd2FwIHRoZSBjb21wb25lbnRzLCBkZXBlbmRpbmcgb24gdGhlXG4gICAqIHRyYW5zaXRpb24gbW9kZS4gRGVmYXVsdHMgdG8gc2ltdWx0YW5lb3VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhbnNpdGlvbih0YXJnZXQsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGlsZFZNO1xuICAgIC8vIGZvciBkZXZ0b29sIGluc3BlY3Rpb25cbiAgICBpZiAoY3VycmVudCkgY3VycmVudC5faW5hY3RpdmUgPSB0cnVlO1xuICAgIHRhcmdldC5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNoaWxkVk0gPSB0YXJnZXQ7XG4gICAgc3dpdGNoIChzZWxmLnBhcmFtcy50cmFuc2l0aW9uTW9kZSkge1xuICAgICAgY2FzZSAnaW4tb3V0JzpcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ291dC1pbic6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50KTtcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGNiKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZC5cbiAgICovXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlUGVuZGluZygpO1xuICAgIC8vIERvIG5vdCBkZWZlciBjbGVhbnVwIHdoZW4gdW5iaW5kaW5nXG4gICAgdGhpcy51bmJ1aWxkKCk7XG4gICAgLy8gZGVzdHJveSBhbGwga2VlcC1hbGl2ZSBjYWNoZWQgaW5zdGFuY2VzXG4gICAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XS4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYWN0aXZhdGUgaG9va3MgaW4gb3JkZXIgKGFzeW5jaHJvbm91cylcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBob29rc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZUhvb2tzKGhvb2tzLCB2bSwgY2IpIHtcbiAgdmFyIHRvdGFsID0gaG9va3MubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gMDtcbiAgaG9va3NbMF0uY2FsbCh2bSwgbmV4dCk7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKCsrY2FsbGVkID49IHRvdGFsKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rc1tjYWxsZWRdLmNhbGwodm0sIG5leHQpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcEJpbmRpbmdNb2RlcyA9IGNvbmZpZy5fcHJvcEJpbmRpbmdNb2RlcztcbnZhciBlbXB0eSA9IHt9O1xuXG4vLyByZWdleGVzXG52YXIgaWRlbnRSRSQxID0gL15bJF9hLXpBLVpdK1tcXHckXSokLztcbnZhciBzZXR0YWJsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooXFwuW0EtWmEtel8kXVtcXHckXSp8XFxbW15cXFtcXF1dK1xcXSkqJC87XG5cbi8qKlxuICogQ29tcGlsZSBwcm9wcyBvbiBhIHJvb3QgZWxlbWVudCBhbmQgcmV0dXJuXG4gKiBhIHByb3BzIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wT3B0aW9uc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUHJvcHMoZWwsIHByb3BPcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcE9wdGlvbnMpO1xuICB2YXIgaSA9IG5hbWVzLmxlbmd0aDtcbiAgdmFyIG9wdGlvbnMsIG5hbWUsIGF0dHIsIHZhbHVlLCBwYXRoLCBwYXJzZWQsIHByb3A7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgb3B0aW9ucyA9IHByb3BPcHRpb25zW25hbWVdIHx8IGVtcHR5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJyRkYXRhJykge1xuICAgICAgd2FybignRG8gbm90IHVzZSAkZGF0YSBhcyBwcm9wLicsIHZtKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHByb3BzIGNvdWxkIGNvbnRhaW4gZGFzaGVzLCB3aGljaCB3aWxsIGJlXG4gICAgLy8gaW50ZXJwcmV0ZWQgYXMgbWludXMgY2FsY3VsYXRpb25zIGJ5IHRoZSBwYXJzZXJcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNhbWVsaXplIHRoZSBwYXRoIGhlcmVcbiAgICBwYXRoID0gY2FtZWxpemUobmFtZSk7XG4gICAgaWYgKCFpZGVudFJFJDEudGVzdChwYXRoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3Aga2V5OiBcIicgKyBuYW1lICsgJ1wiLiBQcm9wIGtleXMgJyArICdtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzLicsIHZtKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb3AgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtb2RlOiBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVksXG4gICAgICByYXc6IG51bGxcbiAgICB9O1xuXG4gICAgYXR0ciA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgICAvLyBmaXJzdCBjaGVjayBkeW5hbWljIHZlcnNpb25cbiAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIpKSA9PT0gbnVsbCkge1xuICAgICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWTtcbiAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLm9uY2UnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgZHluYW1pYyBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVycztcbiAgICAgIC8vIGNoZWNrIGJpbmRpbmcgdHlwZVxuICAgICAgaWYgKGlzTGl0ZXJhbCh2YWx1ZSkgJiYgIXBhcnNlZC5maWx0ZXJzKSB7XG4gICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgLy8gYm9vbGVhbnMsIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZXR1cCBhIHByb3AgYmluZGluZyxcbiAgICAgICAgLy8gc28gd2UgY2FuIG9wdGltaXplIHRoZW0gYXMgYSBvbmUtdGltZSBzZXQuXG4gICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAvLyBjaGVjayBub24tc2V0dGFibGUgcGF0aCBmb3IgdHdvLXdheSBiaW5kaW5nc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJiAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVk7XG4gICAgICAgICAgd2FybignQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgKyAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLnBhcmVudFBhdGggPSB2YWx1ZTtcblxuICAgICAgLy8gd2FybiByZXF1aXJlZCB0d28td2F5XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLnR3b1dheSAmJiBwcm9wLm1vZGUgIT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSkge1xuICAgICAgICB3YXJuKCdQcm9wIFwiJyArIG5hbWUgKyAnXCIgZXhwZWN0cyBhIHR3by13YXkgYmluZGluZyB0eXBlLicsIHZtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9IGdldEF0dHIoZWwsIGF0dHIpKSAhPT0gbnVsbCkge1xuICAgICAgLy8gaGFzIGxpdGVyYWwgYmluZGluZyFcbiAgICAgIHByb3AucmF3ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBjaGVjayBwb3NzaWJsZSBjYW1lbENhc2UgcHJvcCB1c2FnZVxuICAgICAgdmFyIGxvd2VyQ2FzZU5hbWUgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IC9bQS1aXFwtXS8udGVzdChuYW1lKSAmJiAoZWwuZ2V0QXR0cmlidXRlKGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLm9uY2UnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSArICcub25jZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lICsgJy5zeW5jJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLnN5bmMnKSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybignUG9zc2libGUgdXNhZ2UgZXJyb3IgZm9yIHByb3AgYCcgKyBsb3dlckNhc2VOYW1lICsgJ2AgLSAnICsgJ2RpZCB5b3UgbWVhbiBgJyArIGF0dHIgKyAnYD8gSFRNTCBpcyBjYXNlLWluc2Vuc2l0aXZlLCByZW1lbWJlciB0byB1c2UgJyArICdrZWJhYi1jYXNlIGZvciBwcm9wcyBpbiB0ZW1wbGF0ZXMuJywgdm0pO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVkKSB7XG4gICAgICAgIC8vIHdhcm4gbWlzc2luZyByZXF1aXJlZFxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6ICcgKyBuYW1lLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHB1c2ggcHJvcFxuICAgIHByb3BzLnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VQcm9wc0xpbmtGbihwcm9wcyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgcHJvcHMgdG8gYSB2bS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wc1xuICogQHJldHVybiB7RnVuY3Rpb259IHByb3BzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZVByb3BzTGlua0ZuKHByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm9wc0xpbmtGbih2bSwgc2NvcGUpIHtcbiAgICAvLyBzdG9yZSByZXNvbHZlZCBwcm9wcyBpbmZvXG4gICAgdm0uX3Byb3BzID0ge307XG4gICAgdmFyIGlubGluZVByb3BzID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhO1xuICAgIHZhciBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHZhciBwcm9wLCBwYXRoLCBvcHRpb25zLCB2YWx1ZSwgcmF3O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHJhdyA9IHByb3AucmF3O1xuICAgICAgcGF0aCA9IHByb3AucGF0aDtcbiAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gICAgICB2bS5fcHJvcHNbcGF0aF0gPSBwcm9wO1xuICAgICAgaWYgKGlubGluZVByb3BzICYmIGhhc093bihpbmxpbmVQcm9wcywgcGF0aCkpIHtcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIGlubGluZVByb3BzW3BhdGhdKTtcbiAgICAgIH1pZiAocmF3ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgYWJzZW50IHByb3BcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgICAvLyBkeW5hbWljIHByb3BcbiAgICAgICAgaWYgKHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRSkge1xuICAgICAgICAgIC8vIG9uZSB0aW1lIGJpbmRpbmdcbiAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bS5fY29udGV4dCB8fCB2bSkuJGdldChwcm9wLnBhcmVudFBhdGgpO1xuICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZtLl9jb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBkeW5hbWljIGJpbmRpbmdcbiAgICAgICAgICAgIHZtLl9iaW5kRGlyKHtcbiAgICAgICAgICAgICAgbmFtZTogJ3Byb3AnLFxuICAgICAgICAgICAgICBkZWY6IHByb3BEZWYsXG4gICAgICAgICAgICAgIHByb3A6IHByb3BcbiAgICAgICAgICAgIH0sIG51bGwsIG51bGwsIHNjb3BlKTsgLy8gZWwsIGhvc3QsIHNjb3BlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZVxuICAgICAgICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdm0uJGdldChwcm9wLnBhcmVudFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wLm9wdGltaXplZExpdGVyYWwpIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxpdGVyYWwsIGNhc3QgaXQgYW5kIGp1c3Qgc2V0IG9uY2VcbiAgICAgICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMocmF3KTtcbiAgICAgICAgdmFsdWUgPSBzdHJpcHBlZCA9PT0gcmF3ID8gdG9Cb29sZWFuKHRvTnVtYmVyKHJhdykpIDogc3RyaXBwZWQ7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbCwgYnV0IHdlIG5lZWQgdG8gY2F0ZXIgZm9yXG4gICAgICAgIC8vIEJvb2xlYW4gcHJvcHMgd2l0aCBubyB2YWx1ZSwgb3Igd2l0aCBzYW1lXG4gICAgICAgIC8vIGxpdGVyYWwgdmFsdWUgKGUuZy4gZGlzYWJsZWQ9XCJkaXNhYmxlZFwiKVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1sb2FkZXIvaXNzdWVzLzE4MlxuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMudHlwZSA9PT0gQm9vbGVhbiAmJiAocmF3ID09PSAnJyB8fCByYXcgPT09IGh5cGhlbmF0ZShwcm9wLm5hbWUpKSA/IHRydWUgOiByYXc7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBwcm9wIHdpdGggYSByYXdWYWx1ZSwgYXBwbHlpbmcgbmVjZXNzYXJ5IGNvZXJzaW9ucyxcbiAqIGRlZmF1bHQgdmFsdWVzICYgYXNzZXJ0aW9ucyBhbmQgY2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgd2l0aFxuICogcHJvY2Vzc2VkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gcmF3VmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgcmF3VmFsdWUsIGZuKSB7XG4gIHZhciBpc1NpbXBsZSA9IHByb3AuZHluYW1pYyAmJiBpc1NpbXBsZVBhdGgocHJvcC5wYXJlbnRQYXRoKTtcbiAgdmFyIHZhbHVlID0gcmF3VmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wKTtcbiAgfVxuICB2YWx1ZSA9IGNvZXJjZVByb3AocHJvcCwgdmFsdWUsIHZtKTtcbiAgdmFyIGNvZXJjZWQgPSB2YWx1ZSAhPT0gcmF3VmFsdWU7XG4gIGlmICghYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSwgdm0pKSB7XG4gICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzU2ltcGxlICYmICFjb2VyY2VkKSB7XG4gICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZm4odmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZuKHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHByb3AncyBpbml0aWFsIHZhbHVlIG9uIGEgdm0gYW5kIGl0cyBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKSB7XG4gIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgcHJvcC5wYXRoLCB2YWx1ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhIHByb3AncyB2YWx1ZSBvbiBhIHZtLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCB2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdm1bcHJvcC5wYXRoXSA9IHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIHZhciBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICBpZiAoIWhhc093bihvcHRpb25zLCAnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRlZiA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIjogJyArICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICsgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLCB2bSk7XG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy50eXBlICE9PSBGdW5jdGlvbiA/IGRlZi5jYWxsKHZtKSA6IGRlZjtcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFByb3AocHJvcCwgdmFsdWUsIHZtKSB7XG4gIGlmICghcHJvcC5vcHRpb25zLnJlcXVpcmVkICYmICggLy8gbm9uLXJlcXVpcmVkXG4gIHByb3AucmF3ID09PSBudWxsIHx8IC8vIGFic2NlbnRcbiAgdmFsdWUgPT0gbnVsbCkgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIHZhciBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIi4nICsgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoZm9ybWF0VHlwZSkuam9pbignLCAnKSArICcsIGdvdCAnICsgZm9ybWF0VmFsdWUodmFsdWUpICsgJy4nLCB2bSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gb3B0aW9ucy52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCIuJywgdm0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGb3JjZSBwYXJzaW5nIHZhbHVlIHdpdGggY29lcmNlIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2VQcm9wKHByb3AsIHZhbHVlLCB2bSkge1xuICB2YXIgY29lcmNlID0gcHJvcC5vcHRpb25zLmNvZXJjZTtcbiAgaWYgKCFjb2VyY2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgY29lcmNlIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIjogZXhwZWN0ZWQgZnVuY3Rpb24sIGdvdCAnICsgdHlwZW9mIGNvZXJjZSArICcuJywgdm0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlO1xuICBpZiAodHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ3N0cmluZyc7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBOdW1iZXIpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnbnVtYmVyJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnYm9vbGVhbic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBGdW5jdGlvbikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBPYmplY3QpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnb2JqZWN0JztcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEFycmF5KSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2FycmF5JztcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5cbi8qKlxuICogRm9ybWF0IHR5cGUgZm9yIG91dHB1dFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkgOiAnY3VzdG9tIHR5cGUnO1xufVxuXG4vKipcbiAqIEZvcm1hdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbn1cblxudmFyIGJpbmRpbmdNb2RlcyA9IGNvbmZpZy5fcHJvcEJpbmRpbmdNb2RlcztcblxudmFyIHByb3BEZWYgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtO1xuICAgIHZhciBwYXJlbnQgPSBjaGlsZC5fY29udGV4dDtcbiAgICAvLyBwYXNzZWQgaW4gZnJvbSBjb21waWxlciBkaXJlY3RseVxuICAgIHZhciBwcm9wID0gdGhpcy5kZXNjcmlwdG9yLnByb3A7XG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoO1xuICAgIHZhciBwYXJlbnRLZXkgPSBwcm9wLnBhcmVudFBhdGg7XG4gICAgdmFyIHR3b1dheSA9IHByb3AubW9kZSA9PT0gYmluZGluZ01vZGVzLlRXT19XQVk7XG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKHBhcmVudCwgcGFyZW50S2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB1cGRhdGVQcm9wKGNoaWxkLCBwcm9wLCB2YWwpO1xuICAgIH0sIHtcbiAgICAgIHR3b1dheTogdHdvV2F5LFxuICAgICAgZmlsdGVyczogcHJvcC5maWx0ZXJzLFxuICAgICAgLy8gaW1wb3J0YW50OiBwcm9wcyBuZWVkIHRvIGJlIG9ic2VydmVkIG9uIHRoZVxuICAgICAgLy8gdi1mb3Igc2NvcGUgaWYgcHJlc2VudFxuICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdGhlIGNoaWxkIGluaXRpYWwgdmFsdWUuXG4gICAgaW5pdFByb3AoY2hpbGQsIHByb3AsIHBhcmVudFdhdGNoZXIudmFsdWUpO1xuXG4gICAgLy8gc2V0dXAgdHdvLXdheSBiaW5kaW5nXG4gICAgaWYgKHR3b1dheSkge1xuICAgICAgLy8gaW1wb3J0YW50OiBkZWZlciB0aGUgY2hpbGQgd2F0Y2hlciBjcmVhdGlvbiB1bnRpbFxuICAgICAgLy8gdGhlIGNyZWF0ZWQgaG9vayAoYWZ0ZXIgZGF0YSBvYnNlcnZhdGlvbilcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRvbmNlKCdwcmUtaG9vazpjcmVhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNoaWxkV2F0Y2hlciA9IG5ldyBXYXRjaGVyKGNoaWxkLCBjaGlsZEtleSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHBhcmVudFdhdGNoZXIuc2V0KHZhbCk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAvLyBlbnN1cmUgc3luYyB1cHdhcmQgYmVmb3JlIHBhcmVudCBzeW5jIGRvd24uXG4gICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgaW4gY2FzZXMgZS5nLiB0aGUgY2hpbGRcbiAgICAgICAgICAvLyBtdXRhdGVzIGEgcHJvcCBhcnJheSwgdGhlbiByZXBsYWNlcyBpdC4gKCMxNjgzKVxuICAgICAgICAgIHN5bmM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5wYXJlbnRXYXRjaGVyLnRlYXJkb3duKCk7XG4gICAgaWYgKHRoaXMuY2hpbGRXYXRjaGVyKSB7XG4gICAgICB0aGlzLmNoaWxkV2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlJDEgPSBbXTtcbnZhciBxdWV1ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBQdXNoIGEgam9iIGludG8gdGhlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYlxuICovXG5cbmZ1bmN0aW9uIHB1c2hKb2Ioam9iKSB7XG4gIHF1ZXVlJDEucHVzaChqb2IpO1xuICBpZiAoIXF1ZXVlZCkge1xuICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgbmV4dFRpY2soZmx1c2gpO1xuICB9XG59XG5cbi8qKlxuICogRmx1c2ggdGhlIHF1ZXVlLCBhbmQgZG8gb25lIGZvcmNlZCByZWZsb3cgYmVmb3JlXG4gKiB0cmlnZ2VyaW5nIHRyYW5zaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAvLyBGb3JjZSBsYXlvdXRcbiAgdmFyIGYgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlJDEubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZSQxW2ldKCk7XG4gIH1cbiAgcXVldWUkMSA9IFtdO1xuICBxdWV1ZWQgPSBmYWxzZTtcbiAgLy8gZHVtbXkgcmV0dXJuLCBzbyBqcyBsaW50ZXJzIGRvbid0IGNvbXBsYWluIGFib3V0XG4gIC8vIHVudXNlZCB2YXJpYWJsZSBmXG4gIHJldHVybiBmO1xufVxuXG52YXIgVFlQRV9UUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIFRZUEVfQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG52YXIgdHJhbnNEdXJhdGlvblByb3AgPSB0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbic7XG52YXIgYW5pbUR1cmF0aW9uUHJvcCA9IGFuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nO1xuXG4vKipcbiAqIElmIGEganVzdC1lbnRlcmVkIGVsZW1lbnQgaXMgYXBwbGllZCB0aGVcbiAqIGxlYXZlIGNsYXNzIHdoaWxlIGl0cyBlbnRlciB0cmFuc2l0aW9uIGhhc24ndCBzdGFydGVkIHlldCxcbiAqIGFuZCB0aGUgdHJhbnNpdGlvbmVkIHByb3BlcnR5IGhhcyB0aGUgc2FtZSB2YWx1ZSBmb3IgYm90aFxuICogZW50ZXIvbGVhdmUsIHRoZW4gdGhlIGxlYXZlIHRyYW5zaXRpb24gd2lsbCBiZSBza2lwcGVkIGFuZFxuICogdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgbmV2ZXIgZmlyZXMuIFRoaXMgZnVuY3Rpb24gZW5zdXJlc1xuICogaXRzIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhZnRlciBhIHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWRcbiAqIGJ5IHdhaXRpbmcgZm9yIGRvdWJsZSByYWYuXG4gKlxuICogSXQgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0IG9uIGRldmljZXMgdGhhdCBzdXBwb3J0IENTU1xuICogdHJhbnNpdGlvbnMgYnV0IG5vdCByYWYgKGUuZy4gQW5kcm9pZCA0LjIgYnJvd3NlcikgLSBzaW5jZVxuICogdGhlc2UgZW52aXJvbm1lbnRzIGFyZSB1c3VhbGx5IHNsb3csIHdlIGFyZSBnaXZpbmcgaXQgYVxuICogcmVsYXRpdmVseSBsYXJnZSB0aW1lb3V0LlxuICovXG5cbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbnZhciB3YWl0Rm9yVHJhbnNpdGlvblN0YXJ0ID0gcmFmXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgc2V0VGltZW91dChmbiwgNTApO1xufTtcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5lbnRlckNsYXNzID0gaG9va3MgJiYgaG9va3MuZW50ZXJDbGFzcyB8fCBpZCArICctZW50ZXInO1xuICB0aGlzLmxlYXZlQ2xhc3MgPSBob29rcyAmJiBob29rcy5sZWF2ZUNsYXNzIHx8IGlkICsgJy1sZWF2ZSc7XG4gIHRoaXMuaG9va3MgPSBob29rcztcbiAgdGhpcy52bSA9IHZtO1xuICAvLyBhc3luYyBzdGF0ZVxuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB0aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLnR5cGVDYWNoZSA9IHt9O1xuICAvLyBjaGVjayBjc3MgdHJhbnNpdGlvbiB0eXBlXG4gIHRoaXMudHlwZSA9IGhvb2tzICYmIGhvb2tzLnR5cGU7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSBUWVBFX1RSQU5TSVRJT04gJiYgdGhpcy50eXBlICE9PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgd2FybignaW52YWxpZCBDU1MgdHJhbnNpdGlvbiB0eXBlIGZvciB0cmFuc2l0aW9uPVwiJyArIHRoaXMuaWQgKyAnXCI6ICcgKyB0aGlzLnR5cGUsIHZtKTtcbiAgICB9XG4gIH1cbiAgLy8gYmluZFxuICB2YXIgc2VsZiA9IHRoaXM7WydlbnRlck5leHRUaWNrJywgJ2VudGVyRG9uZScsICdsZWF2ZU5leHRUaWNrJywgJ2xlYXZlRG9uZSddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICBzZWxmW21dID0gYmluZChzZWxmW21dLCBzZWxmKTtcbiAgfSk7XG59XG5cbnZhciBwJDEgPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuLyoqXG4gKiBTdGFydCBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGVudGVyIHRyYW5zaXRpb24gdHJpZ2dlcmVkXG4gKiAyLiBjYWxsIGJlZm9yZUVudGVyIGhvb2tcbiAqIDMuIGFkZCBlbnRlciBjbGFzc1xuICogNC4gaW5zZXJ0L3Nob3cgZWxlbWVudFxuICogNS4gY2FsbCBlbnRlciBob29rICh3aXRoIHBvc3NpYmxlIGV4cGxpY2l0IGpzIGNhbGxiYWNrKVxuICogNi4gcmVmbG93XG4gKiA3LiBiYXNlZCBvbiB0cmFuc2l0aW9uIHR5cGU6XG4gKiAgICAtIHRyYW5zaXRpb246XG4gKiAgICAgICAgcmVtb3ZlIGNsYXNzIG5vdywgd2FpdCBmb3IgdHJhbnNpdGlvbmVuZCxcbiAqICAgICAgICB0aGVuIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gYW5pbWF0aW9uOlxuICogICAgICAgIHdhaXQgZm9yIGFuaW1hdGlvbmVuZCwgcmVtb3ZlIGNsYXNzLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBubyBjc3MgdHJhbnNpdGlvbjpcbiAqICAgICAgICBkb25lIG5vdyBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogOC4gd2FpdCBmb3IgZWl0aGVyIGRvbmUgb3IganMgY2FsbGJhY2ssIHRoZW4gY2FsbFxuICogICAgYWZ0ZXJFbnRlciBob29rLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gaW5zZXJ0L3Nob3cgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5wJDEuZW50ZXIgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpO1xuICB0aGlzLmNhbGxIb29rKCdiZWZvcmVFbnRlcicpO1xuICB0aGlzLmNiID0gY2I7XG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIG9wKCk7XG4gIHRoaXMuZW50ZXJlZCA9IGZhbHNlO1xuICB0aGlzLmNhbGxIb29rV2l0aENiKCdlbnRlcicpO1xuICBpZiAodGhpcy5lbnRlcmVkKSB7XG4gICAgcmV0dXJuOyAvLyB1c2VyIGNhbGxlZCBkb25lIHN5bmNocm9ub3VzbHkuXG4gIH1cbiAgdGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuZW50ZXJDYW5jZWxsZWQ7XG4gIHB1c2hKb2IodGhpcy5lbnRlck5leHRUaWNrKTtcbn07XG5cbi8qKlxuICogVGhlIFwibmV4dFRpY2tcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLCB3aGljaCBpc1xuICogdG8gYmUgcHVzaGVkIGludG8gYSBxdWV1ZSBhbmQgZXhlY3V0ZWQgYWZ0ZXIgYSByZWZsb3cgc29cbiAqIHRoYXQgcmVtb3ZpbmcgdGhlIGNsYXNzIGNhbiB0cmlnZ2VyIGEgQ1NTIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmVudGVyTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgLy8gcHJldmVudCB0cmFuc2l0aW9uIHNraXBwaW5nXG4gIHRoaXMuanVzdEVudGVyZWQgPSB0cnVlO1xuICB3YWl0Rm9yVHJhbnNpdGlvblN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICB9KTtcbiAgdmFyIGVudGVyRG9uZSA9IHRoaXMuZW50ZXJEb25lO1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgICAgLy8gdHJpZ2dlciB0cmFuc2l0aW9uIGJ5IHJlbW92aW5nIGVudGVyIGNsYXNzIG5vd1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYih0cmFuc2l0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGFuaW1hdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlckRvbmUoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudGVyZWQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICB0aGlzLmNhbGxIb29rKCdhZnRlckVudGVyJyk7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGxlYXZlIHRyYW5zaXRpb24gdHJpZ2dlcmVkLlxuICogMi4gY2FsbCBiZWZvcmVMZWF2ZSBob29rXG4gKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gKiA0LiBjYWxsIGxlYXZlIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA1LiByZWZsb3cgaWYgbm8gZXhwbGljaXQganMgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbiBvciBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgZW5kIGV2ZW50LCByZW1vdmUgY2xhc3MsIHRoZW4gZG9uZSBpZlxuICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyTGVhdmUgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmxlYXZlID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlTGVhdmUnKTtcbiAgdGhpcy5vcCA9IG9wO1xuICB0aGlzLmNiID0gY2I7XG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLmNhbGxIb29rV2l0aENiKCdsZWF2ZScpO1xuICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgcmV0dXJuOyAvLyB1c2VyIGNhbGxlZCBkb25lIHN5bmNocm9ub3VzbHkuXG4gIH1cbiAgdGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MubGVhdmVDYW5jZWxsZWQ7XG4gIC8vIG9ubHkgbmVlZCB0byBoYW5kbGUgbGVhdmVEb25lIGlmXG4gIC8vIDEuIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgZG9uZSAoc3luY2hyb25vdXNseSBjYWxsZWRcbiAgLy8gICAgYnkgdGhlIHVzZXIsIHdoaWNoIGNhdXNlcyB0aGlzLm9wIHNldCB0byBudWxsKVxuICAvLyAyLiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrXG4gIGlmICh0aGlzLm9wICYmICF0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgLy8gaWYgYSBDU1MgdHJhbnNpdGlvbiBsZWF2ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgZW50ZXIsXG4gICAgLy8gdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgbmV2ZXIgZmlyZXMuIHRoZXJlZm9yZSB3ZVxuICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBlbmQgdGhlIGxlYXZlIGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLmp1c3RFbnRlcmVkKSB7XG4gICAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoSm9iKHRoaXMubGVhdmVOZXh0VGljayk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmxlYXZlTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmxlYXZlQ2xhc3MpO1xuICBpZiAodHlwZSkge1xuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHRoaXMuc2V0dXBDc3NDYihldmVudCwgdGhpcy5sZWF2ZURvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGVhdmVEb25lKCk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVmdCA9IHRydWU7XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIHRoaXMub3AoKTtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJMZWF2ZScpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xuICB0aGlzLm9wID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FuY2VsIGFueSBwZW5kaW5nIGNhbGxiYWNrcyBmcm9tIGEgcHJldmlvdXNseSBydW5uaW5nXG4gKiBidXQgbm90IGZpbmlzaGVkIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmNhbmNlbFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgdmFyIGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ0Nzc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgb2ZmKHRoaXMuZWwsIHRoaXMucGVuZGluZ0Nzc0V2ZW50LCB0aGlzLnBlbmRpbmdDc3NDYik7XG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBoYXNQZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiLmNhbmNlbCgpO1xuICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB9XG4gIGlmIChoYXNQZW5kaW5nKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB9XG4gIGlmICh0aGlzLmNhbmNlbCkge1xuICAgIHRoaXMuY2FuY2VsLmNhbGwodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAodGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdKSB7XG4gICAgdGhpcy5ob29rc1t0eXBlXS5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkLCBwb3RlbnRpYWxseS1hc3luYyBob29rIGZ1bmN0aW9uLlxuICogV2UgY2hlY2sgZm9yIHRoZSBsZW5ndGggb2YgYXJndW1lbnRzIHRvIHNlZSBpZiB0aGUgaG9va1xuICogZXhwZWN0cyBhIGBkb25lYCBjYWxsYmFjay4gSWYgdHJ1ZSwgdGhlIHRyYW5zaXRpb24ncyBlbmRcbiAqIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB3aGVuIHRoZSB1c2VyIGNhbGxzIHRoYXQgY2FsbGJhY2s7XG4gKiBvdGhlcndpc2UsIHRoZSBlbmQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgQ1NTIHRyYW5zaXRpb24gb3JcbiAqIGFuaW1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5cbnAkMS5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBob29rID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdO1xuICBpZiAoaG9vaykge1xuICAgIGlmIChob29rLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBjYW5jZWxsYWJsZSh0aGlzW3R5cGUgKyAnRG9uZSddKTtcbiAgICB9XG4gICAgaG9vay5jYWxsKHRoaXMudm0sIHRoaXMuZWwsIHRoaXMucGVuZGluZ0pzQ2IpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgdHJhbnNpdGlvbiB0eXBlIGJhc2VkIG9uIHRoZVxuICogY2FsY3VsYXRlZCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5cbnAkMS5nZXRDc3NUcmFuc2l0aW9uVHlwZSA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgQ1NTIHRyYW5zaXRpb25zIGlmIHBhZ2UgaXMgbm90IHZpc2libGUgLVxuICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gIC8vIGZpcmluZyB1bnRpbCB0aGUgcGFnZSBpcyB2aXNpYmxlIGFnYWluLlxuICAvLyBwYWdlVmlzaWJpbGl0eSBBUEkgaXMgc3VwcG9ydGVkIGluIElFMTArLCBzYW1lIGFzXG4gIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgZG9jdW1lbnQuaGlkZGVuIHx8XG4gIC8vIGV4cGxpY2l0IGpzLW9ubHkgdHJhbnNpdGlvblxuICB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuY3NzID09PSBmYWxzZSB8fFxuICAvLyBlbGVtZW50IGlzIGhpZGRlblxuICBpc0hpZGRlbih0aGlzLmVsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdHlwZSA9IHRoaXMudHlwZSB8fCB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdO1xuICBpZiAodHlwZSkgcmV0dXJuIHR5cGU7XG4gIHZhciBpbmxpbmVTdHlsZXMgPSB0aGlzLmVsLnN0eWxlO1xuICB2YXIgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKTtcbiAgdmFyIHRyYW5zRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXTtcbiAgaWYgKHRyYW5zRHVyYXRpb24gJiYgdHJhbnNEdXJhdGlvbiAhPT0gJzBzJykge1xuICAgIHR5cGUgPSBUWVBFX1RSQU5TSVRJT047XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9IGlubGluZVN0eWxlc1thbmltRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1thbmltRHVyYXRpb25Qcm9wXTtcbiAgICBpZiAoYW5pbUR1cmF0aW9uICYmIGFuaW1EdXJhdGlvbiAhPT0gJzBzJykge1xuICAgICAgdHlwZSA9IFRZUEVfQU5JTUFUSU9OO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV0gPSB0eXBlO1xuICB9XG4gIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxucCQxLnNldHVwQ3NzQ2IgPSBmdW5jdGlvbiAoZXZlbnQsIGNiKSB7XG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gZXZlbnQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsID0gdGhpcy5lbDtcbiAgdmFyIG9uRW5kID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIG9mZihlbCwgZXZlbnQsIG9uRW5kKTtcbiAgICAgIHNlbGYucGVuZGluZ0Nzc0V2ZW50ID0gc2VsZi5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLnBlbmRpbmdKc0NiICYmIGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBvbihlbCwgZXZlbnQsIG9uRW5kKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBoaWRkZW4gLSBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3RcbiAqIHNraXAgdGhlIHRyYW5zaXRpb24gYWxsdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0hpZGRlbihlbCkge1xuICBpZiAoL3N2ZyQvLnRlc3QoZWwubmFtZXNwYWNlVVJJKSkge1xuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaGF2ZSBvZmZzZXQoV2lkdGh8SGVpZ2h0KVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNsaWVudCByZWN0XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gIShyZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uJDEgPSB7XG5cbiAgcHJpb3JpdHk6IFRSQU5TSVRJT04sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaWQsIG9sZElkKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAvLyByZXNvbHZlIG9uIG93bmVyIHZtXG4gICAgdmFyIGhvb2tzID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICd0cmFuc2l0aW9ucycsIGlkKTtcbiAgICBpZCA9IGlkIHx8ICd2JztcbiAgICBvbGRJZCA9IG9sZElkIHx8ICd2JztcbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLnZtKTtcbiAgICByZW1vdmVDbGFzcyhlbCwgb2xkSWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgICBhZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgfVxufTtcblxudmFyIGludGVybmFsRGlyZWN0aXZlcyA9IHtcbiAgc3R5bGU6IHN0eWxlLFxuICAnY2xhc3MnOiB2Q2xhc3MsXG4gIGNvbXBvbmVudDogY29tcG9uZW50LFxuICBwcm9wOiBwcm9wRGVmLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uJDFcbn07XG5cbi8vIHNwZWNpYWwgYmluZGluZyBwcmVmaXhlc1xudmFyIGJpbmRSRSA9IC9edi1iaW5kOnxeOi87XG52YXIgb25SRSA9IC9edi1vbjp8XkAvO1xudmFyIGRpckF0dHJSRSA9IC9edi0oW146XSspKD86JHw6KC4qKSQpLztcbnZhciBtb2RpZmllclJFID0gL1xcLlteXFwuXSsvZztcbnZhciB0cmFuc2l0aW9uUkUgPSAvXih2LWJpbmQ6fDopP3RyYW5zaXRpb24kLztcblxuLy8gZGVmYXVsdCBkaXJlY3RpdmUgcHJpb3JpdHlcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcbnZhciBERUZBVUxUX1RFUk1JTkFMX1BSSU9SSVRZID0gMjAwMDtcblxuLyoqXG4gKiBDb21waWxlIGEgdGVtcGxhdGUgYW5kIHJldHVybiBhIHJldXNhYmxlIGNvbXBvc2l0ZSBsaW5rXG4gKiBmdW5jdGlvbiwgd2hpY2ggcmVjdXJzaXZlbHkgY29udGFpbnMgbW9yZSBsaW5rIGZ1bmN0aW9uc1xuICogaW5zaWRlLiBUaGlzIHRvcCBsZXZlbCBjb21waWxlIGZ1bmN0aW9uIHdvdWxkIG5vcm1hbGx5XG4gKiBiZSBjYWxsZWQgb24gaW5zdGFuY2Ugcm9vdCBub2RlcywgYnV0IGNhbiBhbHNvIGJlIHVzZWRcbiAqIGZvciBwYXJ0aWFsIGNvbXBpbGF0aW9uIGlmIHRoZSBwYXJ0aWFsIGFyZ3VtZW50IGlzIHRydWUuXG4gKlxuICogVGhlIHJldHVybmVkIGNvbXBvc2l0ZSBsaW5rIGZ1bmN0aW9uLCB3aGVuIGNhbGxlZCwgd2lsbFxuICogcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBhbGwgZGlyZWN0aXZlc1xuICogY3JlYXRlZCBkdXJpbmcgdGhlIGxpbmtpbmcgcGhhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBwYXJ0aWFsXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlKGVsLCBvcHRpb25zLCBwYXJ0aWFsKSB7XG4gIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBub2RlIGl0c2VsZi5cbiAgdmFyIG5vZGVMaW5rRm4gPSBwYXJ0aWFsIHx8ICFvcHRpb25zLl9hc0NvbXBvbmVudCA/IGNvbXBpbGVOb2RlKGVsLCBvcHRpb25zKSA6IG51bGw7XG4gIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBjaGlsZE5vZGVzXG4gIHZhciBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiAhaXNTY3JpcHQoZWwpICYmIGVsLmhhc0NoaWxkTm9kZXMoKSA/IGNvbXBpbGVOb2RlTGlzdChlbC5jaGlsZE5vZGVzLCBvcHRpb25zKSA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgY29tcG9zaXRlIGxpbmtlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYSBhbHJlYWR5XG4gICAqIGNvbXBpbGVkIHBpZWNlIG9mIERPTSwgd2hpY2ggaW5zdGFudGlhdGVzIGFsbCBkaXJlY3RpdmVcbiAgICogaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSBob3N0IHZtIG9mIHRyYW5zY2x1ZGVkIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBsaW5rIGNvbnRleHQgZnJhZ21lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cblxuICByZXR1cm4gZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAvLyBjYWNoZSBjaGlsZE5vZGVzIGJlZm9yZSBsaW5raW5nIHBhcmVudCwgZml4ICM2NTdcbiAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkoZWwuY2hpbGROb2Rlcyk7XG4gICAgLy8gbGlua1xuICAgIHZhciBkaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gY29tcG9zaXRlTGlua0NhcHR1cmVyKCkge1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICBpZiAoY2hpbGRMaW5rRm4pIGNoaWxkTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfSwgdm0pO1xuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIGRpcnMpO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGx5IGEgbGlua2VyIHRvIGEgdm0vZWxlbWVudCBwYWlyIGFuZCBjYXB0dXJlIHRoZVxuICogZGlyZWN0aXZlcyBjcmVhdGVkIGR1cmluZyB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIGxpbmtBbmRDYXB0dXJlKGxpbmtlciwgdm0pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gcmVzZXQgZGlyZWN0aXZlcyBiZWZvcmUgZXZlcnkgY2FwdHVyZSBpbiBwcm9kdWN0aW9uXG4gICAgLy8gbW9kZSwgc28gdGhhdCB3aGVuIHVubGlua2luZyB3ZSBkb24ndCBuZWVkIHRvIHNwbGljZVxuICAgIC8vIHRoZW0gb3V0ICh3aGljaCB0dXJucyBvdXQgdG8gYmUgYSBwZXJmIGhpdCkuXG4gICAgLy8gdGhleSBhcmUga2VwdCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgdGhleSBhcmVcbiAgICAvLyB1c2VmdWwgZm9yIFZ1ZSdzIG93biB0ZXN0cy5cbiAgICB2bS5fZGlyZWN0aXZlcyA9IFtdO1xuICB9XG4gIHZhciBvcmlnaW5hbERpckNvdW50ID0gdm0uX2RpcmVjdGl2ZXMubGVuZ3RoO1xuICBsaW5rZXIoKTtcbiAgdmFyIGRpcnMgPSB2bS5fZGlyZWN0aXZlcy5zbGljZShvcmlnaW5hbERpckNvdW50KTtcbiAgZGlycy5zb3J0KGRpcmVjdGl2ZUNvbXBhcmF0b3IpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyc1tpXS5fYmluZCgpO1xuICB9XG4gIHJldHVybiBkaXJzO1xufVxuXG4vKipcbiAqIERpcmVjdGl2ZSBwcmlvcml0eSBzb3J0IGNvbXBhcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqL1xuXG5mdW5jdGlvbiBkaXJlY3RpdmVDb21wYXJhdG9yKGEsIGIpIHtcbiAgYSA9IGEuZGVzY3JpcHRvci5kZWYucHJpb3JpdHkgfHwgREVGQVVMVF9QUklPUklUWTtcbiAgYiA9IGIuZGVzY3JpcHRvci5kZWYucHJpb3JpdHkgfHwgREVGQVVMVF9QUklPUklUWTtcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5cbi8qKlxuICogTGlua2VyIGZ1bmN0aW9ucyByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXRcbiAqIHRlYXJzZG93biBhbGwgZGlyZWN0aXZlcyBpbnN0YW5jZXMgZ2VuZXJhdGVkIGR1cmluZ1xuICogdGhlIHByb2Nlc3MuXG4gKlxuICogV2UgY3JlYXRlIHVubGluayBmdW5jdGlvbnMgd2l0aCBvbmx5IHRoZSBuZWNlc3NhcnlcbiAqIGluZm9ybWF0aW9uIHRvIGF2b2lkIHJldGFpbmluZyBhZGRpdGlvbmFsIGNsb3N1cmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtBcnJheX0gZGlyc1xuICogQHBhcmFtIHtWdWV9IFtjb250ZXh0XVxuICogQHBhcmFtIHtBcnJheX0gW2NvbnRleHREaXJzXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gbWFrZVVubGlua0ZuKHZtLCBkaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycykge1xuICBmdW5jdGlvbiB1bmxpbmsoZGVzdHJveWluZykge1xuICAgIHRlYXJkb3duRGlycyh2bSwgZGlycywgZGVzdHJveWluZyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dERpcnMpIHtcbiAgICAgIHRlYXJkb3duRGlycyhjb250ZXh0LCBjb250ZXh0RGlycyk7XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBsaW5rZWQgZGlyZWN0aXZlc1xuICB1bmxpbmsuZGlycyA9IGRpcnM7XG4gIHJldHVybiB1bmxpbms7XG59XG5cbi8qKlxuICogVGVhcmRvd24gcGFydGlhbCBsaW5rZWQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveWluZ1xuICovXG5cbmZ1bmN0aW9uIHRlYXJkb3duRGlycyh2bSwgZGlycywgZGVzdHJveWluZykge1xuICB2YXIgaSA9IGRpcnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgZGlyc1tpXS5fdGVhcmRvd24oKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZGVzdHJveWluZykge1xuICAgICAgdm0uX2RpcmVjdGl2ZXMuJHJlbW92ZShkaXJzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGxpbmsgcHJvcHMgb24gYW4gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlQW5kTGlua1Byb3BzKHZtLCBlbCwgcHJvcHMsIHNjb3BlKSB7XG4gIHZhciBwcm9wc0xpbmtGbiA9IGNvbXBpbGVQcm9wcyhlbCwgcHJvcHMsIHZtKTtcbiAgdmFyIHByb3BEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgIHByb3BzTGlua0ZuKHZtLCBzY29wZSk7XG4gIH0sIHZtKTtcbiAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgcHJvcERpcnMpO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIHJvb3QgZWxlbWVudCBvZiBhbiBpbnN0YW5jZS5cbiAqXG4gKiAxLiBhdHRycyBvbiBjb250ZXh0IGNvbnRhaW5lciAoY29udGV4dCBzY29wZSlcbiAqIDIuIGF0dHJzIG9uIHRoZSBjb21wb25lbnQgdGVtcGxhdGUgcm9vdCBub2RlLCBpZlxuICogICAgcmVwbGFjZTp0cnVlIChjaGlsZCBzY29wZSlcbiAqXG4gKiBJZiB0aGlzIGlzIGEgZnJhZ21lbnQgaW5zdGFuY2UsIHdlIG9ubHkgbmVlZCB0byBjb21waWxlIDEuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzO1xuICB2YXIgcmVwbGFjZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnM7XG4gIHZhciBjb250ZXh0TGlua0ZuLCByZXBsYWNlckxpbmtGbjtcblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGxhY2VyQXR0cnMpIHtcbiAgICAgICAgLy8gMy4gcmVwbGFjZXIgYXR0cmlidXRlc1xuICAgICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKHJlcGxhY2VyQXR0cnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub24tY29tcG9uZW50LCBqdXN0IGNvbXBpbGUgYXMgYSBub3JtYWwgZWxlbWVudC5cbiAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIGFsbG93IHZ1ZS1sb2FkZXIvdnVlaWZ5IHNjb3BlZCBjc3MgYXR0cmlidXRlc1xuICAgICAgcmV0dXJuIGF0dHIubmFtZS5pbmRleE9mKCdfdi0nKSA8IDAgJiZcbiAgICAgIC8vIGFsbG93IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgIW9uUkUudGVzdChhdHRyLm5hbWUpICYmXG4gICAgICAvLyBhbGxvdyBzbG90c1xuICAgICAgYXR0ci5uYW1lICE9PSAnc2xvdCc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIGF0dHIubmFtZSArICdcIic7XG4gICAgfSk7XG4gICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHBsdXJhbCA9IG5hbWVzLmxlbmd0aCA+IDE7XG4gICAgICB3YXJuKCdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMuam9pbignLCAnKSArIChwbHVyYWwgPyAnIGFyZScgOiAnIGlzJykgKyAnIGlnbm9yZWQgb24gY29tcG9uZW50ICcgKyAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArICd0aGUgY29tcG9uZW50IGlzIGEgZnJhZ21lbnQgaW5zdGFuY2U6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9jb21wb25lbnRzLmh0bWwjRnJhZ21lbnQtSW5zdGFuY2UnKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbih2bSwgZWwsIHNjb3BlKSB7XG4gICAgLy8gbGluayBjb250ZXh0IHNjb3BlIGRpcnNcbiAgICB2YXIgY29udGV4dCA9IHZtLl9jb250ZXh0O1xuICAgIHZhciBjb250ZXh0RGlycztcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0TGlua0ZuKSB7XG4gICAgICBjb250ZXh0RGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dExpbmtGbihjb250ZXh0LCBlbCwgbnVsbCwgc2NvcGUpO1xuICAgICAgfSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpO1xuICAgIH0sIHZtKTtcblxuICAgIC8vIHJldHVybiB0aGUgdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGNvbnRleHRcbiAgICAvLyBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBzZWxmRGlycywgY29udGV4dCwgY29udGV4dERpcnMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuIGJhc2VkIG9uIHRoZVxuICogbm9kZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gIGlmICh0eXBlID09PSAxICYmICFpc1NjcmlwdChub2RlKSkge1xuICAgIHJldHVybiBjb21waWxlRWxlbWVudChub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAzICYmIG5vZGUuZGF0YS50cmltKCkpIHtcbiAgICByZXR1cm4gY29tcGlsZVRleHROb2RlKG5vZGUsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50KGVsLCBvcHRpb25zKSB7XG4gIC8vIHByZXByb2Nlc3MgdGV4dGFyZWFzLlxuICAvLyB0ZXh0YXJlYSB0cmVhdHMgaXRzIHRleHQgY29udGVudCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgLy8ganVzdCBiaW5kIGl0IGFzIGFuIGF0dHIgZGlyZWN0aXZlIGZvciB2YWx1ZS5cbiAgaWYgKGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KGVsLnZhbHVlKTtcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJzp2YWx1ZScsIHRva2Vuc1RvRXhwKHRva2VucykpO1xuICAgICAgZWwudmFsdWUgPSAnJztcbiAgICB9XG4gIH1cbiAgdmFyIGxpbmtGbjtcbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpO1xuICB2YXIgYXR0cnMgPSBoYXNBdHRycyAmJiB0b0FycmF5KGVsLmF0dHJpYnV0ZXMpO1xuICAvLyBjaGVjayB0ZXJtaW5hbCBkaXJlY3RpdmVzIChmb3IgJiBpZilcbiAgaWYgKGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY2hlY2tUZXJtaW5hbERpcmVjdGl2ZXMoZWwsIGF0dHJzLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBjb21wb25lbnRcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4gJiYgaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhhdHRycywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGxpbmtGbjtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgdGV4dE5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtUZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9IHRleHROb2RlTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVRleHROb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgLy8gc2tpcCBtYXJrZWQgdGV4dCBub2Rlc1xuICBpZiAobm9kZS5fc2tpcCkge1xuICAgIHJldHVybiByZW1vdmVUZXh0O1xuICB9XG5cbiAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChub2RlLndob2xlVGV4dCk7XG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBtYXJrIGFkamFjZW50IHRleHQgbm9kZXMgYXMgc2tpcHBlZCxcbiAgLy8gYmVjYXVzZSB3ZSBhcmUgdXNpbmcgbm9kZS53aG9sZVRleHQgdG8gY29tcGlsZVxuICAvLyBhbGwgYWRqYWNlbnQgdGV4dCBub2RlcyB0b2dldGhlci4gVGhpcyBmaXhlc1xuICAvLyBpc3N1ZXMgaW4gSUUgd2hlcmUgc29tZXRpbWVzIGl0IHNwbGl0cyB1cCBhIHNpbmdsZVxuICAvLyB0ZXh0IG5vZGUgaW50byBtdWx0aXBsZSBvbmVzLlxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgPT09IDMpIHtcbiAgICBuZXh0Ll9za2lwID0gdHJ1ZTtcbiAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgfVxuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgZWwsIHRva2VuO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBlbCA9IHRva2VuLnRhZyA/IHByb2Nlc3NUZXh0VG9rZW4odG9rZW4sIG9wdGlvbnMpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG4gIHJldHVybiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBMaW5rZXIgZm9yIGFuIHNraXBwZWQgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtUZXh0fSBub2RlXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVGV4dCh2bSwgbm9kZSkge1xuICByZW1vdmUobm9kZSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHNpbmdsZSB0ZXh0IHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykge1xuICB2YXIgZWw7XG4gIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRva2VuLmh0bWwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgndi1odG1sJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ2h0bWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgd2lsbCBjbGVhbiB1cCBlbXB0eSB0ZXh0Tm9kZXMgZHVyaW5nXG4gICAgICAvLyBmcmFnLmNsb25lTm9kZSh0cnVlKSwgc28gd2UgaGF2ZSB0byBnaXZlIGl0XG4gICAgICAvLyBzb21ldGhpbmcgaGVyZS4uLlxuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpO1xuICAgICAgc2V0VG9rZW5UeXBlKCd0ZXh0Jyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFRva2VuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHRva2VuLmRlc2NyaXB0b3IpIHJldHVybjtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodG9rZW4udmFsdWUpO1xuICAgIHRva2VuLmRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiB0eXBlLFxuICAgICAgZGVmOiBkaXJlY3RpdmVzW3R5cGVdLFxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVyc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSB0ZXh0Tm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHRva2Vuc1xuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKi9cblxuZnVuY3Rpb24gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZykge1xuICByZXR1cm4gZnVuY3Rpb24gdGV4dE5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSkge1xuICAgIHZhciBmcmFnQ2xvbmUgPSBmcmFnLmNsb25lTm9kZSh0cnVlKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkoZnJhZ0Nsb25lLmNoaWxkTm9kZXMpO1xuICAgIHZhciB0b2tlbiwgdmFsdWUsIG5vZGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICBpZiAodG9rZW4udGFnKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAodG9rZW4ub25lVGltZSkge1xuICAgICAgICAgIHZhbHVlID0gKHNjb3BlIHx8IHZtKS4kZXZhbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRva2VuLmh0bWwpIHtcbiAgICAgICAgICAgIHJlcGxhY2Uobm9kZSwgcGFyc2VUZW1wbGF0ZSh2YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShlbCwgZnJhZ0Nsb25lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBsaXN0IGFuZCByZXR1cm4gYSBjaGlsZExpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZUxpc3Qobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXTtcbiAgdmFyIG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuLCBub2RlO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5vZGUgPSBub2RlTGlzdFtpXTtcbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucyk7XG4gICAgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJyAmJiBub2RlLmhhc0NoaWxkTm9kZXMoKSA/IGNvbXBpbGVOb2RlTGlzdChub2RlLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgICBsaW5rRm5zLnB1c2gobm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4pO1xuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aCA/IG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSA6IG51bGw7XG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGlsZExpbmtGbih2bSwgbm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdmFyIG5vZGUsIG5vZGVMaW5rRm4sIGNoaWxkcmVuTGlua0ZuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gMCwgbCA9IGxpbmtGbnMubGVuZ3RoOyBpIDwgbDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgY2hpbGRyZW5MaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAvLyBjYWNoZSBjaGlsZE5vZGVzIGJlZm9yZSBsaW5raW5nIHBhcmVudCwgZml4ICM2NTdcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIHtcbiAgICAgICAgbm9kZUxpbmtGbih2bSwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkcmVuTGlua0ZuKSB7XG4gICAgICAgIGNoaWxkcmVuTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBlbGVtZW50IGRpcmVjdGl2ZXMgKGN1c3RvbSBlbGVtZW50cyB0aGF0IHNob3VsZFxuICogYmUgcmVzb3ZsZWQgYXMgdGVybWluYWwgZGlyZWN0aXZlcykuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjb21tb25UYWdSRS50ZXN0KHRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpO1xuICBpZiAoZGVmKSB7XG4gICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIHRhZywgJycsIG9wdGlvbnMsIGRlZik7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LiBJZiB5ZXMsIHJldHVyblxuICogYSBjb21wb25lbnQgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKSB7XG4gIHZhciBjb21wb25lbnQgPSBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpO1xuICBpZiAoY29tcG9uZW50KSB7XG4gICAgdmFyIHJlZiA9IGZpbmRSZWYoZWwpO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogJ2NvbXBvbmVudCcsXG4gICAgICByZWY6IHJlZixcbiAgICAgIGV4cHJlc3Npb246IGNvbXBvbmVudC5pZCxcbiAgICAgIGRlZjogaW50ZXJuYWxEaXJlY3RpdmVzLmNvbXBvbmVudCxcbiAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICBsaXRlcmFsOiAhY29tcG9uZW50LmR5bmFtaWNcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRMaW5rRm4gPSBmdW5jdGlvbiBjb21wb25lbnRMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCByZWYsIG51bGwpO1xuICAgICAgfVxuICAgICAgdm0uX2JpbmREaXIoZGVzY3JpcHRvciwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9O1xuICAgIGNvbXBvbmVudExpbmtGbi50ZXJtaW5hbCA9IHRydWU7XG4gICAgcmV0dXJuIGNvbXBvbmVudExpbmtGbjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGFuIGVsZW1lbnQgZm9yIHRlcm1pbmFsIGRpcmVjdGl2ZXMgaW4gZml4ZWQgb3JkZXIuXG4gKiBJZiBpdCBmaW5kcyBvbmUsIHJldHVybiBhIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gYXR0cnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGVybWluYWxMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgYXR0cnMsIG9wdGlvbnMpIHtcbiAgLy8gc2tpcCB2LXByZVxuICBpZiAoZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2tpcDtcbiAgfVxuICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndi1lbHNlJykpIHtcbiAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKHByZXYgJiYgcHJldi5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgcmV0dXJuIHNraXA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHIsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIG1hdGNoZWQsIGRpck5hbWUsIHJhd05hbWUsIGFyZywgZGVmLCB0ZXJtRGVmO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IGF0dHJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBuYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgIGlmIChtYXRjaGVkID0gbmFtZS5tYXRjaChkaXJBdHRyUkUpKSB7XG4gICAgICBkZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBtYXRjaGVkWzFdKTtcbiAgICAgIGlmIChkZWYgJiYgZGVmLnRlcm1pbmFsKSB7XG4gICAgICAgIGlmICghdGVybURlZiB8fCAoZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfVEVSTUlOQUxfUFJJT1JJVFkpID4gdGVybURlZi5wcmlvcml0eSkge1xuICAgICAgICAgIHRlcm1EZWYgPSBkZWY7XG4gICAgICAgICAgcmF3TmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhhdHRyLm5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICBkaXJOYW1lID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICBhcmcgPSBtYXRjaGVkWzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRlcm1EZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMsIHRlcm1EZWYsIHJhd05hbWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBza2lwKCkge31cbnNraXAudGVybWluYWwgPSB0cnVlO1xuXG4vKipcbiAqIEJ1aWxkIGEgbm9kZSBsaW5rIGZ1bmN0aW9uIGZvciBhIHRlcm1pbmFsIGRpcmVjdGl2ZS5cbiAqIEEgdGVybWluYWwgbGluayBmdW5jdGlvbiB0ZXJtaW5hdGVzIHRoZSBjdXJyZW50XG4gKiBjb21waWxhdGlvbiByZWN1cnNpb24gYW5kIGhhbmRsZXMgY29tcGlsYXRpb24gb2YgdGhlXG4gKiBzdWJ0cmVlIGluIHRoZSBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcmF3TmFtZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbYXJnXVxuICogQHBhcmFtIHtPYmplY3R9IFttb2RpZmllcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGVybWluYWxMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgZGVmLCByYXdOYW1lLCBhcmcsIG1vZGlmaWVycykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICBuYW1lOiBkaXJOYW1lLFxuICAgIGFyZzogYXJnLFxuICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzLFxuICAgIHJhdzogdmFsdWUsXG4gICAgYXR0cjogcmF3TmFtZSxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICBkZWY6IGRlZlxuICB9O1xuICAvLyBjaGVjayByZWYgZm9yIHYtZm9yIGFuZCByb3V0ZXItdmlld1xuICBpZiAoZGlyTmFtZSA9PT0gJ2ZvcicgfHwgZGlyTmFtZSA9PT0gJ3JvdXRlci12aWV3Jykge1xuICAgIGRlc2NyaXB0b3IucmVmID0gZmluZFJlZihlbCk7XG4gIH1cbiAgdmFyIGZuID0gZnVuY3Rpb24gdGVybWluYWxOb2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIGRlc2NyaXB0b3IucmVmLCBudWxsKTtcbiAgICB9XG4gICAgdm0uX2JpbmREaXIoZGVzY3JpcHRvciwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgfTtcbiAgZm4udGVybWluYWwgPSB0cnVlO1xuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZGlyZWN0aXZlcyBvbiBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBsaW5rZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheXxOYW1lZE5vZGVNYXB9IGF0dHJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZURpcmVjdGl2ZXMoYXR0cnMsIG9wdGlvbnMpIHtcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gIHZhciBkaXJzID0gW107XG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgcmF3TmFtZSwgcmF3VmFsdWUsIGRpck5hbWUsIGFyZywgbW9kaWZpZXJzLCBkaXJEZWYsIHRva2VucywgbWF0Y2hlZDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGF0dHIubmFtZTtcbiAgICB2YWx1ZSA9IHJhd1ZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICB0b2tlbnMgPSBwYXJzZVRleHQodmFsdWUpO1xuICAgIC8vIHJlc2V0IGFyZ1xuICAgIGFyZyA9IG51bGw7XG4gICAgLy8gY2hlY2sgbW9kaWZpZXJzXG4gICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG5cbiAgICAvLyBhdHRyaWJ1dGUgaW50ZXJwb2xhdGlvbnNcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICB2YWx1ZSA9IHRva2Vuc1RvRXhwKHRva2Vucyk7XG4gICAgICBhcmcgPSBuYW1lO1xuICAgICAgcHVzaERpcignYmluZCcsIGRpcmVjdGl2ZXMuYmluZCwgdG9rZW5zKTtcbiAgICAgIC8vIHdhcm4gYWdhaW5zdCBtaXhpbmcgbXVzdGFjaGVzIHdpdGggdi1iaW5kXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBhdHRyLm5hbWUgPT09ICc6Y2xhc3MnIHx8IGF0dHIubmFtZSA9PT0gJ3YtYmluZDpjbGFzcyc7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd2FybignY2xhc3M9XCInICsgcmF3VmFsdWUgKyAnXCI6IERvIG5vdCBtaXggbXVzdGFjaGUgaW50ZXJwb2xhdGlvbiAnICsgJ2FuZCB2LWJpbmQgZm9yIFwiY2xhc3NcIiBvbiB0aGUgc2FtZSBlbGVtZW50LiBVc2Ugb25lIG9yIHRoZSBvdGhlci4nLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZVxuXG4gICAgICAvLyBzcGVjaWFsIGF0dHJpYnV0ZTogdHJhbnNpdGlvblxuICAgICAgaWYgKHRyYW5zaXRpb25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gIWJpbmRSRS50ZXN0KG5hbWUpO1xuICAgICAgICBwdXNoRGlyKCd0cmFuc2l0aW9uJywgaW50ZXJuYWxEaXJlY3RpdmVzLnRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlXG5cbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIGFyZyA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgICAgcHVzaERpcignb24nLCBkaXJlY3RpdmVzLm9uKTtcbiAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgYmluZGluZ3NcbiAgICAgICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGRpck5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ3N0eWxlJyB8fCBkaXJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgaW50ZXJuYWxEaXJlY3RpdmVzW2Rpck5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFyZyA9IGRpck5hbWU7XG4gICAgICAgICAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQgPSBuYW1lLm1hdGNoKGRpckF0dHJSRSkpIHtcbiAgICAgICAgICAgICAgZGlyTmFtZSA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgICAgIGFyZyA9IG1hdGNoZWRbMl07XG5cbiAgICAgICAgICAgICAgLy8gc2tpcCB2LWVsc2UgKHdoZW4gdXNlZCB3aXRoIHYtc2hvdylcbiAgICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlyRGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmIChkaXJEZWYpIHtcbiAgICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGRpckRlZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtpbnRlcnBUb2tlbnNdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHB1c2hEaXIoZGlyTmFtZSwgZGVmLCBpbnRlcnBUb2tlbnMpIHtcbiAgICB2YXIgaGFzT25lVGltZVRva2VuID0gaW50ZXJwVG9rZW5zICYmIGhhc09uZVRpbWUoaW50ZXJwVG9rZW5zKTtcbiAgICB2YXIgcGFyc2VkID0gIWhhc09uZVRpbWVUb2tlbiAmJiBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgZGlycy5wdXNoKHtcbiAgICAgIG5hbWU6IGRpck5hbWUsXG4gICAgICBhdHRyOiByYXdOYW1lLFxuICAgICAgcmF3OiByYXdWYWx1ZSxcbiAgICAgIGRlZjogZGVmLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgIC8vIGNvbnZlcnNpb24gZnJvbSBpbnRlcnBvbGF0aW9uIHN0cmluZ3Mgd2l0aCBvbmUtdGltZSB0b2tlblxuICAgICAgLy8gdG8gZXhwcmVzc2lvbiBpcyBkaWZmZXJlZCB1bnRpbCBkaXJlY3RpdmUgYmluZCB0aW1lIHNvIHRoYXQgd2VcbiAgICAgIC8vIGhhdmUgYWNjZXNzIHRvIHRoZSBhY3R1YWwgdm0gY29udGV4dCBmb3Igb25lLXRpbWUgYmluZGluZ3MuXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQgJiYgcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICBpbnRlcnA6IGludGVycFRva2VucyxcbiAgICAgIGhhc09uZVRpbWU6IGhhc09uZVRpbWVUb2tlblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGRpcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgbW9kaWZpZXJzIGZyb20gZGlyZWN0aXZlIGF0dHJpYnV0ZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMobmFtZSkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGkgPSBtYXRjaC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQnVpbGQgYSBsaW5rIGZ1bmN0aW9uIGZvciBhbGwgZGlyZWN0aXZlcyBvbiBhIHNpbmdsZSBub2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBkaXJlY3RpdmVzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZU5vZGVMaW5rRm4oZGlyZWN0aXZlcykge1xuICByZXR1cm4gZnVuY3Rpb24gbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gcmV2ZXJzZSBhcHBseSBiZWNhdXNlIGl0J3Mgc29ydGVkIGxvdyB0byBoaWdoXG4gICAgdmFyIGkgPSBkaXJlY3RpdmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fYmluZERpcihkaXJlY3RpdmVzW2ldLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBpbnRlcnBvbGF0aW9uIHN0cmluZyBjb250YWlucyBvbmUtdGltZSB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc09uZVRpbWUodG9rZW5zKSB7XG4gIHZhciBpID0gdG9rZW5zLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICh0b2tlbnNbaV0ub25lVGltZSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTY3JpcHQoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgPT09ICdTQ1JJUFQnICYmICghZWwuaGFzQXR0cmlidXRlKCd0eXBlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICd0ZXh0L2phdmFzY3JpcHQnKTtcbn1cblxudmFyIHNwZWNpYWxDaGFyUkUgPSAvW15cXHdcXC06XFwuXS87XG5cbi8qKlxuICogUHJvY2VzcyBhbiBlbGVtZW50IG9yIGEgRG9jdW1lbnRGcmFnbWVudCBiYXNlZCBvbiBhXG4gKiBpbnN0YW5jZSBvcHRpb24gb2JqZWN0LiBUaGlzIGFsbG93cyB1cyB0byB0cmFuc2NsdWRlXG4gKiBhIHRlbXBsYXRlIG5vZGUvZnJhZ21lbnQgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkLFxuICogc28gdGhlIHByb2Nlc3NlZCBmcmFnbWVudCBjYW4gdGhlbiBiZSBjbG9uZWQgYW5kIHJldXNlZFxuICogaW4gdi1mb3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKSB7XG4gIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgLy8gdG8gY29tcGlsZXIsIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIGNvbXBpbGVkIGluXG4gIC8vIHBhcmVudCBzY29wZS4gd2UgYXJlIG11dGF0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBoZXJlXG4gIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgLy8gcmlnaHQgYWZ0ZXIgdGhpcy5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbCk7XG4gIH1cbiAgLy8gZm9yIHRlbXBsYXRlIHRhZ3MsIHdoYXQgd2Ugd2FudCBpcyBpdHMgY29udGVudCBhc1xuICAvLyBhIGRvY3VtZW50RnJhZ21lbnQgKGZvciBmcmFnbWVudCBpbnN0YW5jZXMpXG4gIGlmIChpc1RlbXBsYXRlKGVsKSkge1xuICAgIGVsID0gcGFyc2VUZW1wbGF0ZShlbCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQgJiYgIW9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSAnPHNsb3Q+PC9zbG90Pic7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLl9jb250ZW50ID0gZXh0cmFjdENvbnRlbnQoZWwpO1xuICAgICAgZWwgPSB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGcmFnbWVudChlbCkpIHtcbiAgICAvLyBhbmNob3JzIGZvciBmcmFnbWVudCBpbnN0YW5jZVxuICAgIC8vIHBhc3NpbmcgaW4gYHBlcnNpc3Q6IHRydWVgIHRvIGF2b2lkIHRoZW0gYmVpbmdcbiAgICAvLyBkaXNjYXJkZWQgYnkgSUUgZHVyaW5nIHRlbXBsYXRlIGNsb25pbmdcbiAgICBwcmVwZW5kKGNyZWF0ZUFuY2hvcigndi1zdGFydCcsIHRydWUpLCBlbCk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY3JlYXRlQW5jaG9yKCd2LWVuZCcsIHRydWUpKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgb3B0aW9uLlxuICogSWYgdGhlIHJlcGxhY2Ugb3B0aW9uIGlzIHRydWUgdGhpcyB3aWxsIHN3YXAgdGhlICRlbC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucykge1xuICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICB2YXIgZnJhZyA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpO1xuICBpZiAoZnJhZykge1xuICAgIHZhciByZXBsYWNlciA9IGZyYWcuZmlyc3RDaGlsZDtcbiAgICB2YXIgdGFnID0gcmVwbGFjZXIudGFnTmFtZSAmJiByZXBsYWNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdZb3UgYXJlIG1vdW50aW5nIGFuIGluc3RhbmNlIHdpdGggYSB0ZW1wbGF0ZSB0byAnICsgJzxib2R5Pi4gVGhpcyB3aWxsIHJlcGxhY2UgPGJvZHk+IGVudGlyZWx5LiBZb3UgJyArICdzaG91bGQgcHJvYmFibHkgdXNlIGByZXBsYWNlOiBmYWxzZWAgaGVyZS4nKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZXJlIGFyZSBtYW55IGNhc2VzIHdoZXJlIHRoZSBpbnN0YW5jZSBtdXN0XG4gICAgICAvLyBiZWNvbWUgYSBmcmFnbWVudCBpbnN0YW5jZTogYmFzaWNhbGx5IGFueXRoaW5nIHRoYXRcbiAgICAgIC8vIGNhbiBjcmVhdGUgbW9yZSB0aGFuIDEgcm9vdCBub2Rlcy5cbiAgICAgIGlmIChcbiAgICAgIC8vIG11bHRpLWNoaWxkcmVuIHRlbXBsYXRlXG4gICAgICBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgLy8gbm9uLWVsZW1lbnQgdGVtcGxhdGVcbiAgICAgIHJlcGxhY2VyLm5vZGVUeXBlICE9PSAxIHx8XG4gICAgICAvLyBzaW5nbGUgbmVzdGVkIGNvbXBvbmVudFxuICAgICAgdGFnID09PSAnY29tcG9uZW50JyB8fCByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpIHx8IGhhc0JpbmRBdHRyKHJlcGxhY2VyLCAnaXMnKSB8fFxuICAgICAgLy8gZWxlbWVudCBkaXJlY3RpdmVcbiAgICAgIHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpIHx8XG4gICAgICAvLyBmb3IgYmxvY2tcbiAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1mb3InKSB8fFxuICAgICAgLy8gaWYgYmxvY2tcbiAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IGV4dHJhY3RBdHRycyhyZXBsYWNlcik7XG4gICAgICAgIG1lcmdlQXR0cnMoZWwsIHJlcGxhY2VyKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjogJyArIHRlbXBsYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBleHRyYWN0IGEgY29tcG9uZW50IGNvbnRhaW5lcidzIGF0dHJpYnV0ZXNcbiAqIGludG8gYSBwbGFpbiBvYmplY3QgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEF0dHJzKGVsKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSAmJiBlbC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICByZXR1cm4gdG9BcnJheShlbC5hdHRyaWJ1dGVzKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSBhdHRyaWJ1dGVzIG9mIHR3byBlbGVtZW50cywgYW5kIG1ha2Ugc3VyZVxuICogdGhlIGNsYXNzIG5hbWVzIGFyZSBtZXJnZWQgcHJvcGVybHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBmcm9tXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRvXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBdHRycyhmcm9tLCB0bykge1xuICB2YXIgYXR0cnMgPSBmcm9tLmF0dHJpYnV0ZXM7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgbmFtZSwgdmFsdWU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgIGlmICghdG8uaGFzQXR0cmlidXRlKG5hbWUpICYmICFzcGVjaWFsQ2hhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIHRvLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnICYmICFwYXJzZVRleHQodmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlLnRyaW0oKSkpIHtcbiAgICAgIHZhbHVlLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIGFkZENsYXNzKHRvLCBjbHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2NhbiBhbmQgZGV0ZXJtaW5lIHNsb3QgY29udGVudCBkaXN0cmlidXRpb24uXG4gKiBXZSBkbyB0aGlzIGR1cmluZyB0cmFuc2NsdXNpb24gaW5zdGVhZCBhdCBjb21waWxlIHRpbWUgc28gdGhhdFxuICogdGhlIGRpc3RyaWJ1dGlvbiBpcyBkZWNvdXBsZWQgZnJvbSB0aGUgY29tcGlsYXRpb24gb3JkZXIgb2ZcbiAqIHRoZSBzbG90cy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGVudFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzKHZtLCBjb250ZW50KSB7XG4gIGlmICghY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29udGVudHMgPSB2bS5fc2xvdENvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGVsLCBuYW1lO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZWwgPSBjb250ZW50LmNoaWxkcmVuW2ldO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkge1xuICAgICAgKGNvbnRlbnRzW25hbWVdIHx8IChjb250ZW50c1tuYW1lXSA9IFtdKSkucHVzaChlbCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXRCaW5kQXR0cihlbCwgJ3Nsb3QnKSkge1xuICAgICAgd2FybignVGhlIFwic2xvdFwiIGF0dHJpYnV0ZSBtdXN0IGJlIHN0YXRpYy4nLCB2bS4kcGFyZW50KTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIGNvbnRlbnRzKSB7XG4gICAgY29udGVudHNbbmFtZV0gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudHNbbmFtZV0sIGNvbnRlbnQpO1xuICB9XG4gIGlmIChjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHZhciBub2RlcyA9IGNvbnRlbnQuY2hpbGROb2RlcztcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxICYmIG5vZGVzWzBdLm5vZGVUeXBlID09PSAzICYmICFub2Rlc1swXS5kYXRhLnRyaW0oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZW50c1snZGVmYXVsdCddID0gZXh0cmFjdEZyYWdtZW50KGNvbnRlbnQuY2hpbGROb2RlcywgY29udGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHF1YWxpZmllZCBjb250ZW50IG5vZGVzIGZyb20gYSBub2RlIGxpc3QuXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZXNcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEZyYWdtZW50KG5vZGVzLCBwYXJlbnQpIHtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIG5vZGVzID0gdG9BcnJheShub2Rlcyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoaXNUZW1wbGF0ZShub2RlKSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIG5vZGUgPSBwYXJzZVRlbXBsYXRlKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG5cblxudmFyIGNvbXBpbGVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNvbXBpbGU6IGNvbXBpbGUsXG5cdGNvbXBpbGVBbmRMaW5rUHJvcHM6IGNvbXBpbGVBbmRMaW5rUHJvcHMsXG5cdGNvbXBpbGVSb290OiBjb21waWxlUm9vdCxcblx0dHJhbnNjbHVkZTogdHJhbnNjbHVkZSxcblx0cmVzb2x2ZVNsb3RzOiByZXNvbHZlU2xvdHNcbn0pO1xuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIEFjY2Vzc29yIGZvciBgJGRhdGFgIHByb3BlcnR5LCBzaW5jZSBzZXR0aW5nICRkYXRhXG4gICAqIHJlcXVpcmVzIG9ic2VydmluZyB0aGUgbmV3IG9iamVjdCBhbmQgdXBkYXRpbmdcbiAgICogcHJveGllZCBwcm9wZXJ0aWVzLlxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdEYXRhKSB7XG4gICAgICBpZiAobmV3RGF0YSAhPT0gdGhpcy5fZGF0YSkge1xuICAgICAgICB0aGlzLl9zZXREYXRhKG5ld0RhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBzY29wZSBvZiBhbiBpbnN0YW5jZSwgd2hpY2ggY29udGFpbnM6XG4gICAqIC0gb2JzZXJ2ZWQgZGF0YVxuICAgKiAtIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICogLSB1c2VyIG1ldGhvZHNcbiAgICogLSBtZXRhIHByb3BlcnRpZXNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luaXRQcm9wcygpO1xuICAgIHRoaXMuX2luaXRNZXRhKCk7XG4gICAgdGhpcy5faW5pdE1ldGhvZHMoKTtcbiAgICB0aGlzLl9pbml0RGF0YSgpO1xuICAgIHRoaXMuX2luaXRDb21wdXRlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHByb3BzLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIHZhciBlbCA9IG9wdGlvbnMuZWw7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAocHJvcHMgJiYgIWVsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Byb3BzIHdpbGwgbm90IGJlIGNvbXBpbGVkIGlmIG5vIGBlbGAgb3B0aW9uIGlzICcgKyAncHJvdmlkZWQgYXQgaW5zdGFudGlhdGlvbi4nLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRvIGNvbnZlcnQgc3RyaW5nIHNlbGVjdG9ycyBpbnRvIGVsZW1lbnQgbm93XG4gICAgZWwgPSBvcHRpb25zLmVsID0gcXVlcnkoZWwpO1xuICAgIHRoaXMuX3Byb3BzVW5saW5rRm4gPSBlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiBwcm9wc1xuICAgIC8vIHByb3BzIG11c3QgYmUgbGlua2VkIGluIHByb3BlciBzY29wZSBpZiBpbnNpZGUgdi1mb3JcbiAgICA/IGNvbXBpbGVBbmRMaW5rUHJvcHModGhpcywgZWwsIHByb3BzLCB0aGlzLl9zY29wZSkgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkYXRhLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YUZuID0gdGhpcy4kb3B0aW9ucy5kYXRhO1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSA9IGRhdGFGbiA/IGRhdGFGbigpIDoge307XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICBkYXRhID0ge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LicsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgaSwga2V5O1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gdGhlcmUgYXJlIHR3byBzY2VuYXJpb3Mgd2hlcmUgd2UgY2FuIHByb3h5IGEgZGF0YSBrZXk6XG4gICAgICAvLyAxLiBpdCdzIG5vdCBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wXG4gICAgICAvLyAyLiBpdCdzIHByb3ZpZGVkIHZpYSBhIGluc3RhbnRpYXRpb24gb3B0aW9uIEFORCB0aGVyZSBhcmUgbm9cbiAgICAgIC8vICAgIHRlbXBsYXRlIHByb3AgcHJlc2VudFxuICAgICAgaWYgKCFwcm9wcyB8fCAhaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybignRGF0YSBmaWVsZCBcIicgKyBrZXkgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkICcgKyAnYXMgYSBwcm9wLiBUbyBwcm92aWRlIGRlZmF1bHQgdmFsdWUgZm9yIGEgcHJvcCwgdXNlIHRoZSBcImRlZmF1bHRcIiAnICsgJ3Byb3Agb3B0aW9uOyBpZiB5b3Ugd2FudCB0byBwYXNzIHByb3AgdmFsdWVzIHRvIGFuIGluc3RhbnRpYXRpb24gJyArICdjYWxsLCB1c2UgdGhlIFwicHJvcHNEYXRhXCIgb3B0aW9uLicsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvYnNlcnZlIGRhdGFcbiAgICBvYnNlcnZlKGRhdGEsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTd2FwIHRoZSBpbnN0YW5jZSdzICRkYXRhLiBDYWxsZWQgaW4gJGRhdGEncyBzZXR0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdEYXRhXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgIG5ld0RhdGEgPSBuZXdEYXRhIHx8IHt9O1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gbmV3RGF0YTtcbiAgICB2YXIga2V5cywga2V5LCBpO1xuICAgIC8vIHVucHJveHkga2V5cyBub3QgcHJlc2VudCBpbiBuZXcgZGF0YVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghKGtleSBpbiBuZXdEYXRhKSkge1xuICAgICAgICB0aGlzLl91bnByb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByb3h5IGtleXMgbm90IGFscmVhZHkgcHJveGllZCxcbiAgICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKG5ld0RhdGEpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCFoYXNPd24odGhpcywga2V5KSkge1xuICAgICAgICAvLyBuZXcgcHJvcGVydHlcbiAgICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2xkRGF0YS5fX29iX18ucmVtb3ZlVm0odGhpcyk7XG4gICAgb2JzZXJ2ZShuZXdEYXRhLCB0aGlzKTtcbiAgICB0aGlzLl9kaWdlc3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJveHkgYSBwcm9wZXJ0eSwgc28gdGhhdFxuICAgKiB2bS5wcm9wID09PSB2bS5fZGF0YS5wcm9wXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIC8vIG5lZWQgdG8gc3RvcmUgcmVmIHRvIHNlbGYgaGVyZVxuICAgICAgLy8gYmVjYXVzZSB0aGVzZSBnZXR0ZXIvc2V0dGVycyBtaWdodFxuICAgICAgLy8gYmUgY2FsbGVkIGJ5IGNoaWxkIHNjb3BlcyB2aWFcbiAgICAgIC8vIHByb3RvdHlwZSBpbmhlcml0YW5jZS5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9kYXRhW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gcHJveHlTZXR0ZXIodmFsKSB7XG4gICAgICAgICAgc2VsZi5fZGF0YVtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVucHJveHkgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl91bnByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2UgdXBkYXRlIG9uIGV2ZXJ5IHdhdGNoZXIgaW4gc2NvcGUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3dhdGNoZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKHRydWUpOyAvLyBzaGFsbG93IHVwZGF0ZXNcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIGNvbXB1dGVkIHByb3BlcnRpZXMuIFRoZXkgYXJlIGVzc2VudGlhbGx5XG4gICAqIHNwZWNpYWwgZ2V0dGVyL3NldHRlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRDb21wdXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLiRvcHRpb25zLmNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgdmFyIGRlZiA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYsIHRoaXMpO1xuICAgICAgICAgIGRlZi5zZXQgPSBub29wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZi5nZXQgPSB1c2VyRGVmLmdldCA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IGJpbmQodXNlckRlZi5nZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgICBkZWYuc2V0ID0gdXNlckRlZi5zZXQgPyBiaW5kKHVzZXJEZWYuc2V0LCB0aGlzKSA6IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyKGdldHRlciwgb3duZXIpIHtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKG93bmVyLCBnZXR0ZXIsIG51bGwsIHtcbiAgICAgIGxhenk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBpbnN0YW5jZSBtZXRob2RzLiBNZXRob2RzIG11c3QgYmUgYm91bmQgdG8gdGhlXG4gICAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFzc2VkIGRvd24gYXMgYSBwcm9wIHRvXG4gICAqIGNoaWxkIGNvbXBvbmVudHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2RzID0gdGhpcy4kb3B0aW9ucy5tZXRob2RzO1xuICAgIGlmIChtZXRob2RzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICB0aGlzW2tleV0gPSBiaW5kKG1ldGhvZHNba2V5XSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG1ldGEgaW5mb3JtYXRpb24gbGlrZSAkaW5kZXgsICRrZXkgJiAkdmFsdWUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRNZXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRhcyA9IHRoaXMuJG9wdGlvbnMuX21ldGE7XG4gICAgaWYgKG1ldGFzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0YXMpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodGhpcywga2V5LCBtZXRhc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBldmVudFJFID0gL152LW9uOnxeQC87XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFNldHVwIHRoZSBpbnN0YW5jZSdzIG9wdGlvbiBldmVudHMgJiB3YXRjaGVycy5cbiAgICogSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB3ZSBwdWxsIGl0IGZyb20gdGhlXG4gICAqIGluc3RhbmNlJ3MgbWV0aG9kcyBieSBuYW1lLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQpIHtcbiAgICAgIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHRoaXMsIG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJG9uJywgb3B0aW9ucy5ldmVudHMpO1xuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckd2F0Y2gnLCBvcHRpb25zLndhdGNoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgdi1vbiBldmVudHMgb24gYSBjaGlsZCBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRFdmVudHModm0sIGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcztcbiAgICB2YXIgbmFtZSwgdmFsdWUsIGhhbmRsZXI7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKGV2ZW50UkUudGVzdChuYW1lKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGV2ZW50UkUsICcnKTtcbiAgICAgICAgLy8gZm9yY2UgdGhlIGV4cHJlc3Npb24gaW50byBhIHN0YXRlbWVudCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGFsd2F5cyBkeW5hbWljYWxseSByZXNvbHZlcyB0aGUgbWV0aG9kIHRvIGNhbGwgKCMyNjcwKVxuICAgICAgICAvLyBraW5kYSB1Z2x5IGhhY2ssIGJ1dCBkb2VzIHRoZSBqb2IuXG4gICAgICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWU7XG4gICAgICAgIGlmIChpc1NpbXBsZVBhdGgodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJy5hcHBseSh0aGlzLCAkYXJndW1lbnRzKSc7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgaGFuZGxlci5fZnJvbVBhcmVudCA9IHRydWU7XG4gICAgICAgIHZtLiRvbihuYW1lLnJlcGxhY2UoZXZlbnRSRSksIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjYWxsYmFja3MgZm9yIG9wdGlvbiBldmVudHMgYW5kIHdhdGNoZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaFxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyh2bSwgYWN0aW9uLCBoYXNoKSB7XG4gICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgdmFyIGhhbmRsZXJzLCBrZXksIGksIGo7XG4gICAgZm9yIChrZXkgaW4gaGFzaCkge1xuICAgICAgaGFuZGxlcnMgPSBoYXNoW2tleV07XG4gICAgICBpZiAoaXNBcnJheShoYW5kbGVycykpIHtcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIHJlZ2lzdGVyIGFuIGV2ZW50L3dhdGNoIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfE9iamVjdH0gaGFuZGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGhhbmRsZXI7XG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZtW2FjdGlvbl0oa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgICB2YXIgbWV0aG9kID0gbWV0aG9kcyAmJiBtZXRob2RzW2hhbmRsZXJdO1xuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICB2bVthY3Rpb25dKGtleSwgbWV0aG9kLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVW5rbm93biBtZXRob2Q6IFwiJyArIGhhbmRsZXIgKyAnXCIgd2hlbiAnICsgJ3JlZ2lzdGVyaW5nIGNhbGxiYWNrIGZvciAnICsgYWN0aW9uICsgJzogXCInICsga2V5ICsgJ1wiLicsIHZtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlci5oYW5kbGVyLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgcmVjdXJzaXZlIGF0dGFjaGVkL2RldGFjaGVkIGNhbGxzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRET01Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRvbignaG9vazphdHRhY2hlZCcsIG9uQXR0YWNoZWQpO1xuICAgIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgYXR0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkF0dGFjaGVkKCkge1xuICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxBdHRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxBdHRhY2goY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gcmVjdXJzaXZlbHkgY2FsbCBkZXRhY2hlZCBob29rIG9uIGNoaWxkcmVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRGV0YWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdG9yIHRvIGNhbGwgZGV0YWNoZWQgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbERldGFjaChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCBoYW5kbGVycyBmb3IgYSBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob29rXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICB0aGlzLiRlbWl0KCdwcmUtaG9vazonICsgaG9vayk7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy4kb3B0aW9uc1tob29rXTtcbiAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIGxpbmtzIGEgRE9NIGVsZW1lbnQgd2l0aCBhIHBpZWNlIG9mIGRhdGEsXG4gKiB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbi5cbiAqIEl0IHJlZ2lzdGVycyBhIHdhdGNoZXIgd2l0aCB0aGUgZXhwcmVzc2lvbiBhbmQgY2FsbHNcbiAqIHRoZSBET00gdXBkYXRlIGZ1bmN0aW9uIHdoZW4gYSBjaGFuZ2UgaXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBkZWZcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGV4cHJlc3Npb25cbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheTxPYmplY3Q+fSBbZmlsdGVyc11cbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IFttb2RpZmllcnNdXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gbGl0ZXJhbFxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYXR0clxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYXJnXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSByYXdcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IFtyZWZdXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXk8T2JqZWN0Pn0gW2ludGVycF1cbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaGFzT25lVGltZV1cbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLnZtID0gdm07XG4gIHRoaXMuZWwgPSBlbDtcbiAgLy8gY29weSBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbiAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgdGhpcy5uYW1lID0gZGVzY3JpcHRvci5uYW1lO1xuICB0aGlzLmV4cHJlc3Npb24gPSBkZXNjcmlwdG9yLmV4cHJlc3Npb247XG4gIHRoaXMuYXJnID0gZGVzY3JpcHRvci5hcmc7XG4gIHRoaXMubW9kaWZpZXJzID0gZGVzY3JpcHRvci5tb2RpZmllcnM7XG4gIHRoaXMuZmlsdGVycyA9IGRlc2NyaXB0b3IuZmlsdGVycztcbiAgdGhpcy5saXRlcmFsID0gdGhpcy5tb2RpZmllcnMgJiYgdGhpcy5tb2RpZmllcnMubGl0ZXJhbDtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9sb2NrZWQgPSBmYWxzZTtcbiAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgLy8gbGluayBjb250ZXh0XG4gIHRoaXMuX2hvc3QgPSBob3N0O1xuICB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICB0aGlzLl9mcmFnID0gZnJhZztcbiAgLy8gc3RvcmUgZGlyZWN0aXZlcyBvbiBub2RlIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyA9IHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzIHx8IFtdO1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzLnB1c2godGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkaXJlY3RpdmUsIG1peGluIGRlZmluaXRpb24gcHJvcGVydGllcyxcbiAqIHNldHVwIHRoZSB3YXRjaGVyLCBjYWxsIGRlZmluaXRpb24gYmluZCgpIGFuZCB1cGRhdGUoKVxuICogaWYgcHJlc2VudC5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9iaW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG5cbiAgLy8gcmVtb3ZlIGF0dHJpYnV0ZVxuICBpZiAoKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgIHZhciBhdHRyID0gZGVzY3JpcHRvci5hdHRyIHx8ICd2LScgKyBuYW1lO1xuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICB9XG5cbiAgLy8gY29weSBkZWYgcHJvcGVydGllc1xuICB2YXIgZGVmID0gZGVzY3JpcHRvci5kZWY7XG4gIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy51cGRhdGUgPSBkZWY7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKHRoaXMsIGRlZik7XG4gIH1cblxuICAvLyBzZXR1cCBkaXJlY3RpdmUgcGFyYW1zXG4gIHRoaXMuX3NldHVwUGFyYW1zKCk7XG5cbiAgLy8gaW5pdGlhbCBiaW5kXG4gIGlmICh0aGlzLmJpbmQpIHtcbiAgICB0aGlzLmJpbmQoKTtcbiAgfVxuICB0aGlzLl9ib3VuZCA9IHRydWU7XG5cbiAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgIHRoaXMudXBkYXRlICYmIHRoaXMudXBkYXRlKGRlc2NyaXB0b3IucmF3KTtcbiAgfSBlbHNlIGlmICgodGhpcy5leHByZXNzaW9uIHx8IHRoaXMubW9kaWZpZXJzKSAmJiAodGhpcy51cGRhdGUgfHwgdGhpcy50d29XYXkpICYmICF0aGlzLl9jaGVja1N0YXRlbWVudCgpKSB7XG4gICAgLy8gd3JhcHBlZCB1cGRhdGVyIGZvciBjb250ZXh0XG4gICAgdmFyIGRpciA9IHRoaXM7XG4gICAgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKCFkaXIuX2xvY2tlZCkge1xuICAgICAgICAgIGRpci51cGRhdGUodmFsLCBvbGRWYWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGUgPSBub29wJDE7XG4gICAgfVxuICAgIHZhciBwcmVQcm9jZXNzID0gdGhpcy5fcHJlUHJvY2VzcyA/IGJpbmQodGhpcy5fcHJlUHJvY2VzcywgdGhpcykgOiBudWxsO1xuICAgIHZhciBwb3N0UHJvY2VzcyA9IHRoaXMuX3Bvc3RQcm9jZXNzID8gYmluZCh0aGlzLl9wb3N0UHJvY2VzcywgdGhpcykgOiBudWxsO1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHRoaXMudm0sIHRoaXMuZXhwcmVzc2lvbiwgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgIHtcbiAgICAgIGZpbHRlcnM6IHRoaXMuZmlsdGVycyxcbiAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICBkZWVwOiB0aGlzLmRlZXAsXG4gICAgICBwcmVQcm9jZXNzOiBwcmVQcm9jZXNzLFxuICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgfSk7XG4gICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAvLyBtb2RlbCBpbnN0ZWFkIG9mIHVwZGF0ZSB0byBET00gb24gaW5pdC4gVGhleSB3b3VsZFxuICAgIC8vIHNldCB0aGUgYWZ0ZXJCaW5kIGhvb2sgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGUod2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGFsbCBwYXJhbSBhdHRyaWJ1dGVzLCBlLmcuIHRyYWNrLWJ5LFxuICogdHJhbnNpdGlvbi1tb2RlLCBldGMuLi5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9zZXR1cFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhcmFtcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gIC8vIHN3YXAgdGhlIHBhcmFtcyBhcnJheSB3aXRoIGEgZnJlc2ggb2JqZWN0LlxuICB0aGlzLnBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBpID0gcGFyYW1zLmxlbmd0aDtcbiAgdmFyIGtleSwgdmFsLCBtYXBwZWRLZXk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBoeXBoZW5hdGUocGFyYW1zW2ldKTtcbiAgICBtYXBwZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgIHZhbCA9IGdldEJpbmRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAvLyBkeW5hbWljXG4gICAgICB0aGlzLl9zZXR1cFBhcmFtV2F0Y2hlcihtYXBwZWRLZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0YXRpY1xuICAgICAgdmFsID0gZ2V0QXR0cih0aGlzLmVsLCBrZXkpO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFyYW1zW21hcHBlZEtleV0gPSB2YWwgPT09ICcnID8gdHJ1ZSA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYSB3YXRjaGVyIGZvciBhIGR5bmFtaWMgcGFyYW0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9zZXR1cFBhcmFtV2F0Y2hlciA9IGZ1bmN0aW9uIChrZXksIGV4cHJlc3Npb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHZhciB1bndhdGNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiR3YXRjaChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsO1xuICAgIC8vIHNpbmNlIHdlIGFyZSBpbiBpbW1lZGlhdGUgbW9kZSxcbiAgICAvLyBvbmx5IGNhbGwgdGhlIHBhcmFtIGNoYW5nZSBjYWxsYmFja3MgaWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLnBhcmFtV2F0Y2hlcnMgJiYgc2VsZi5wYXJhbVdhdGNoZXJzW2tleV07XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IuY2FsbChzZWxmLCB2YWwsIG9sZFZhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgIHVzZXI6IGZhbHNlXG4gIH0pOyh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgfHwgKHRoaXMuX3BhcmFtVW53YXRjaEZucyA9IFtdKSkucHVzaCh1bndhdGNoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGRpcmVjdGl2ZSBpcyBhIGZ1bmN0aW9uIGNhbGxlclxuICogYW5kIGlmIHRoZSBleHByZXNzaW9uIGlzIGEgY2FsbGFibGUgb25lLiBJZiBib3RoIHRydWUsXG4gKiB3ZSB3cmFwIHVwIHRoZSBleHByZXNzaW9uIGFuZCB1c2UgaXQgYXMgdGhlIGV2ZW50XG4gKiBoYW5kbGVyLlxuICpcbiAqIGUuZy4gb24tY2xpY2s9XCJhKytcIlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fY2hlY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uO1xuICBpZiAoZXhwcmVzc2lvbiAmJiB0aGlzLmFjY2VwdFN0YXRlbWVudCAmJiAhaXNTaW1wbGVQYXRoKGV4cHJlc3Npb24pKSB7XG4gICAgdmFyIGZuID0gcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pLmdldDtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICBzY29wZS4kZXZlbnQgPSBlO1xuICAgICAgZm4uY2FsbChzY29wZSwgc2NvcGUpO1xuICAgICAgc2NvcGUuJGV2ZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICAgIGhhbmRsZXIgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKGhhbmRsZXIsIG51bGwsIHRoaXMuZmlsdGVycyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSB3aXRoIHRoZSBzZXR0ZXIuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdHdvLXdheSBkaXJlY3RpdmVzXG4gKiBlLmcuIHYtbW9kZWwuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHB1YmxpY1xuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLnR3b1dheSkge1xuICAgIHRoaXMuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIuc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybignRGlyZWN0aXZlLnNldCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHR3b1dheScgKyAnZGlyZWN0aXZlcy4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hpbGUgcHJldmVudGluZyB0aGF0IGZ1bmN0aW9uIGZyb21cbiAqIHRyaWdnZXJpbmcgdXBkYXRlcyBvbiB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3dpdGhMb2NrID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fbG9ja2VkID0gdHJ1ZTtcbiAgZm4uY2FsbChzZWxmKTtcbiAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2xvY2tlZCA9IGZhbHNlO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXR0YWNoZXMgYSBET00gZXZlbnQgbGlzdGVuZXJcbiAqIHRvIHRoZSBkaXJlY3RpdmUgZWxlbWVudCBhbmQgYXV0b21ldGljYWxseSB0ZWFycyBpdCBkb3duXG4gKiBkdXJpbmcgdW5iaW5kLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV1cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIG9uKHRoaXMuZWwsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKTsodGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSkpLnB1c2goW2V2ZW50LCBoYW5kbGVyXSk7XG59O1xuXG4vKipcbiAqIFRlYXJkb3duIHRoZSB3YXRjaGVyIGFuZCBjYWxsIHVuYmluZC5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl90ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2JvdW5kKSB7XG4gICAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy51bmJpbmQpIHtcbiAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl93YXRjaGVyKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgdmFyIGk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG9mZih0aGlzLmVsLCBsaXN0ZW5lcnNbaV1bMF0sIGxpc3RlbmVyc1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1bndhdGNoRm5zID0gdGhpcy5fcGFyYW1VbndhdGNoRm5zO1xuICAgIGlmICh1bndhdGNoRm5zKSB7XG4gICAgICBpID0gdW53YXRjaEZucy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVud2F0Y2hGbnNbaV0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbCkge1xuICAgICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMuJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy52bSA9IHRoaXMuZWwgPSB0aGlzLl93YXRjaGVyID0gdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogVXBkYXRlIHYtcmVmIGZvciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZVJlZiA9IGZ1bmN0aW9uIChyZW1vdmUpIHtcbiAgICB2YXIgcmVmID0gdGhpcy4kb3B0aW9ucy5fcmVmO1xuICAgIGlmIChyZWYpIHtcbiAgICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMuX2NvbnRleHQpLiRyZWZzO1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBpZiAocmVmc1tyZWZdID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1tyZWZdID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYW5zY2x1ZGUsIGNvbXBpbGUgYW5kIGxpbmsgZWxlbWVudC5cbiAgICpcbiAgICogSWYgYSBwcmUtY29tcGlsZWQgbGlua2VyIGlzIGF2YWlsYWJsZSwgdGhhdCBtZWFucyB0aGVcbiAgICogcGFzc2VkIGluIGVsZW1lbnQgd2lsbCBiZSBwcmUtdHJhbnNjbHVkZWQgYW5kIGNvbXBpbGVkXG4gICAqIGFzIHdlbGwgLSBhbGwgd2UgbmVlZCB0byBkbyBpcyB0byBjYWxsIHRoZSBsaW5rZXIuXG4gICAqXG4gICAqIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGNhbGwgdHJhbnNjbHVkZS9jb21waWxlL2xpbmsgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgLy8gdHJhbnNjbHVkZSBhbmQgaW5pdCBlbGVtZW50XG4gICAgLy8gdHJhbnNjbHVkZSBjYW4gcG90ZW50aWFsbHkgcmVwbGFjZSBvcmlnaW5hbFxuICAgIC8vIHNvIHdlIG5lZWQgdG8ga2VlcCByZWZlcmVuY2U7IHRoaXMgc3RlcCBhbHNvIGluamVjdHNcbiAgICAvLyB0aGUgdGVtcGxhdGUgYW5kIGNhY2hlcyB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAgIC8vIG9uIHRoZSBjb250YWluZXIgbm9kZSBhbmQgcmVwbGFjZXIgbm9kZS5cbiAgICB2YXIgb3JpZ2luYWwgPSBlbDtcbiAgICBlbCA9IHRyYW5zY2x1ZGUoZWwsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2luaXRFbGVtZW50KGVsKTtcblxuICAgIC8vIGhhbmRsZSB2LXByZSBvbiByb290IG5vZGUgKCMyMDI2KVxuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSAmJiBnZXRBdHRyKGVsLCAndi1wcmUnKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJvb3QgaXMgYWx3YXlzIGNvbXBpbGVkIHBlci1pbnN0YW5jZSwgYmVjYXVzZVxuICAgIC8vIGNvbnRhaW5lciBhdHRycyBhbmQgcHJvcHMgY2FuIGJlIGRpZmZlcmVudCBldmVyeSB0aW1lLlxuICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHRoaXMuX2NvbnRleHQgJiYgdGhpcy5fY29udGV4dC4kb3B0aW9ucztcbiAgICB2YXIgcm9vdExpbmtlciA9IGNvbXBpbGVSb290KGVsLCBvcHRpb25zLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAvLyByZXNvbHZlIHNsb3QgZGlzdHJpYnV0aW9uXG4gICAgcmVzb2x2ZVNsb3RzKHRoaXMsIG9wdGlvbnMuX2NvbnRlbnQpO1xuXG4gICAgLy8gY29tcGlsZSBhbmQgbGluayB0aGUgcmVzdFxuICAgIHZhciBjb250ZW50TGlua0ZuO1xuICAgIHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjb21wb25lbnQgY29tcGlsYXRpb24gY2FuIGJlIGNhY2hlZFxuICAgIC8vIGFzIGxvbmcgYXMgaXQncyBub3QgdXNpbmcgaW5saW5lLXRlbXBsYXRlXG4gICAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXI7XG4gICAgICBpZiAoIWNvbnRlbnRMaW5rRm4pIHtcbiAgICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyID0gY29tcGlsZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbGluayBwaGFzZVxuICAgIC8vIG1ha2Ugc3VyZSB0byBsaW5rIHJvb3Qgd2l0aCBwcm9wIHNjb3BlIVxuICAgIHZhciByb290VW5saW5rRm4gPSByb290TGlua2VyKHRoaXMsIGVsLCB0aGlzLl9zY29wZSk7XG4gICAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm4gPyBjb250ZW50TGlua0ZuKHRoaXMsIGVsKSA6IGNvbXBpbGUoZWwsIG9wdGlvbnMpKHRoaXMsIGVsKTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvc2l0ZSB1bmxpbmsgZnVuY3Rpb25cbiAgICAvLyB0byBiZSBjYWxsZWQgZHVyaW5nIGluc3RhbmNlIGRlc3RydWN0aW9uXG4gICAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByb290VW5saW5rRm4oKTtcbiAgICAgIC8vIHBhc3NpbmcgZGVzdHJveWluZzogdHJ1ZSB0byBhdm9pZCBzZWFyY2hpbmcgYW5kXG4gICAgICAvLyBzcGxpY2luZyB0aGUgZGlyZWN0aXZlc1xuICAgICAgY29udGVudFVubGlua0ZuKHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICByZXBsYWNlKG9yaWdpbmFsLCBlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNDb21waWxlZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2NvbXBpbGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgaW5zdGFuY2UgZWxlbWVudC4gQ2FsbGVkIGluIHRoZSBwdWJsaWNcbiAgICogJG1vdW50KCkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzRnJhZ21lbnQoZWwpKSB7XG4gICAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsID0gdGhpcy5fZnJhZ21lbnRTdGFydCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLl9mcmFnbWVudEVuZCA9IGVsLmxhc3RDaGlsZDtcbiAgICAgIC8vIHNldCBwZXJzaXN0ZWQgdGV4dCBhbmNob3JzIHRvIGVtcHR5XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRTdGFydC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICB0aGlzLl9mcmFnbWVudFN0YXJ0LmRhdGEgPSB0aGlzLl9mcmFnbWVudEVuZC5kYXRhID0gJyc7XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFnbWVudCA9IGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbCA9IGVsO1xuICAgIH1cbiAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gdGhpcztcbiAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlQ29tcGlsZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGJpbmQgYSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgLSBwYXJzZWQgZGlyZWN0aXZlIGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICAgLSB0YXJnZXQgbm9kZVxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fYmluZERpciA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHRoaXMuX2RpcmVjdGl2ZXMucHVzaChuZXcgRGlyZWN0aXZlKGRlc2NyaXB0b3IsIHRoaXMsIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIGFuIGluc3RhbmNlLCB1bm9ic2VydmVzIHRoZSBkYXRhLCB1bmJpbmQgYWxsIHRoZVxuICAgKiBkaXJlY3RpdmVzLCB0dXJuIG9mZiBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycywgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSAtIHdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBET00gbm9kZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlckNsZWFudXAgLSBpZiB0cnVlLCBkZWZlciBjbGVhbnVwIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY2FsbGVkIGxhdGVyXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlLCBkZWZlckNsZWFudXApIHtcbiAgICBpZiAodGhpcy5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCFkZWZlckNsZWFudXApIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZXN0cm95UmVhZHk7XG4gICAgdmFyIHBlbmRpbmdSZW1vdmFsO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIENsZWFudXAgc2hvdWxkIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25veXNseSBhc1xuICAgIC8vIGNhbGxiYWNrIG9mIHRoaXMuJHJlbW92ZSgpLCBvciBpZiByZW1vdmUgYW5kIGRlZmVyQ2xlYW51cCBhcmUgZmFsc2UuXG4gICAgLy8gSW4gYW55IGNhc2UgaXQgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhbGwgb3RoZXIgcmVtb3ZpbmcsIHVuYmluZGluZyBhbmRcbiAgICAvLyB0dXJuaW5nIG9mIGlzIGRvbmVcbiAgICB2YXIgY2xlYW51cElmUG9zc2libGUgPSBmdW5jdGlvbiBjbGVhbnVwSWZQb3NzaWJsZSgpIHtcbiAgICAgIGlmIChkZXN0cm95UmVhZHkgJiYgIXBlbmRpbmdSZW1vdmFsICYmICFkZWZlckNsZWFudXApIHtcbiAgICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZW1vdmUgRE9NIGVsZW1lbnRcbiAgICBpZiAocmVtb3ZlICYmIHRoaXMuJGVsKSB7XG4gICAgICBwZW5kaW5nUmVtb3ZhbCA9IHRydWU7XG4gICAgICB0aGlzLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBwZW5kaW5nUmVtb3ZhbCA9IGZhbHNlO1xuICAgICAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudC4gb25seSBuZWNlc3NhcnlcbiAgICAvLyBpZiBwYXJlbnQgaXMgbm90IGJlaW5nIGRlc3Ryb3llZCBhcyB3ZWxsLlxuICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICBwYXJlbnQuJGNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgICAvLyB1bnJlZ2lzdGVyIHJlZiAocmVtb3ZlOiB0cnVlKVxuICAgICAgdGhpcy5fdXBkYXRlUmVmKHRydWUpO1xuICAgIH1cbiAgICAvLyBkZXN0cm95IGFsbCBjaGlsZHJlbi5cbiAgICBpID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuJGNoaWxkcmVuW2ldLiRkZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHByb3BzXG4gICAgaWYgKHRoaXMuX3Byb3BzVW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3Byb3BzVW5saW5rRm4oKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gYWxsIGRpcmVjdGl2ZXMuIHRoaXMgYWxzbyB0ZWFyc2Rvd24gYWxsXG4gICAgLy8gZGlyZWN0aXZlLW93bmVkIHdhdGNoZXJzLlxuICAgIGlmICh0aGlzLl91bmxpbmtGbikge1xuICAgICAgdGhpcy5fdW5saW5rRm4oKTtcbiAgICB9XG4gICAgaSA9IHRoaXMuX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHNlbGYgb24gJGVsXG4gICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95UmVhZHkgPSB0cnVlO1xuICAgIGNsZWFudXBJZlBvc3NpYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRvIGVuc3VyZSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIGlmIHRoZXJlXG4gICAqIGlzIGFueS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBvd25lciBmcmFnbWVudFxuICAgIC8vIGRvIGl0IGluIGNsZWFudXAgc28gdGhhdCB3ZSBjYW4gY2FsbCAkZGVzdHJveSB3aXRoXG4gICAgLy8gZGVmZXIgcmlnaHQgd2hlbiBhIGZyYWdtZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYgKHRoaXMuX2ZyYWcpIHtcbiAgICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLl9fb2JfXykge1xuICAgICAgdGhpcy5fZGF0YS5fX29iX18ucmVtb3ZlVm0odGhpcyk7XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIHJlZmVyZW5jZXMgdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBvdGhlclxuICAgIC8vIGluc3RhbmNlcy4gcHJlc2VydmUgcmVmZXJlbmNlIHRvIF9kYXRhIHNvIHRoYXQgcHJveHlcbiAgICAvLyBhY2Nlc3NvcnMgc3RpbGwgd29yay4gVGhlIG9ubHkgcG90ZW50aWFsIHNpZGUgZWZmZWN0XG4gICAgLy8gaGVyZSBpcyB0aGF0IG11dGF0aW5nIHRoZSBpbnN0YW5jZSBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICAgIC8vIG1heSBhZmZlY3QgdGhlIHN0YXRlIG9mIG90aGVyIGNvbXBvbmVudHMgdGhhdCBhcmUgc3RpbGxcbiAgICAvLyBvYnNlcnZpbmcgdGhlIHNhbWUgb2JqZWN0LCBidXQgdGhhdCBzZWVtcyB0byBiZSBhXG4gICAgLy8gcmVhc29uYWJsZSByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHVzZXIgcmF0aGVyIHRoYW5cbiAgICAvLyBhbHdheXMgdGhyb3dpbmcgYW4gZXJyb3Igb24gdGhlbS5cbiAgICB0aGlzLiRlbCA9IHRoaXMuJHBhcmVudCA9IHRoaXMuJHJvb3QgPSB0aGlzLiRjaGlsZHJlbiA9IHRoaXMuX3dhdGNoZXJzID0gdGhpcy5fY29udGV4dCA9IHRoaXMuX3Njb3BlID0gdGhpcy5fZGlyZWN0aXZlcyA9IG51bGw7XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHRoaXMuJG9mZigpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtaXNjTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogQXBwbHkgYSBsaXN0IG9mIGZpbHRlciAoZGVzY3JpcHRvcnMpIHRvIGEgdmFsdWUuXG4gICAqIFVzaW5nIHBsYWluIGZvciBsb29wcyBoZXJlIGJlY2F1c2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICAgKiB0aGUgZ2V0dGVyIG9mIGFueSB3YXRjaGVyIHdpdGggZmlsdGVycyBzbyBpdCBpcyB2ZXJ5XG4gICAqIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IFtvbGRWYWx1ZV1cbiAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdyaXRlXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2FwcGx5RmlsdGVycyA9IGZ1bmN0aW9uICh2YWx1ZSwgb2xkVmFsdWUsIGZpbHRlcnMsIHdyaXRlKSB7XG4gICAgdmFyIGZpbHRlciwgZm4sIGFyZ3MsIGFyZywgb2Zmc2V0LCBpLCBsLCBqLCBrO1xuICAgIGZvciAoaSA9IDAsIGwgPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZmlsdGVyID0gZmlsdGVyc1t3cml0ZSA/IGwgLSBpIC0gMSA6IGldO1xuICAgICAgZm4gPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXIubmFtZSwgdHJ1ZSk7XG4gICAgICBpZiAoIWZuKSBjb250aW51ZTtcbiAgICAgIGZuID0gd3JpdGUgPyBmbi53cml0ZSA6IGZuLnJlYWQgfHwgZm47XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgIGFyZ3MgPSB3cml0ZSA/IFt2YWx1ZSwgb2xkVmFsdWVdIDogW3ZhbHVlXTtcbiAgICAgIG9mZnNldCA9IHdyaXRlID8gMiA6IDE7XG4gICAgICBpZiAoZmlsdGVyLmFyZ3MpIHtcbiAgICAgICAgZm9yIChqID0gMCwgayA9IGZpbHRlci5hcmdzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgIGFyZyA9IGZpbHRlci5hcmdzW2pdO1xuICAgICAgICAgIGFyZ3NbaiArIG9mZnNldF0gPSBhcmcuZHluYW1pYyA/IHRoaXMuJGdldChhcmcudmFsdWUpIDogYXJnLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYSBjb21wb25lbnQsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjb21wb25lbnRcbiAgICogaXMgZGVmaW5lZCBub3JtYWxseSBvciB1c2luZyBhbiBhc3luYyBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBSZXNvbHZlcyBzeW5jaHJvbm91c2x5IGlmIGFscmVhZHkgcmVzb2x2ZWQsIG90aGVyd2lzZVxuICAgKiByZXNvbHZlcyBhc3luY2hyb25vdXNseSBhbmQgY2FjaGVzIHRoZSByZXNvbHZlZFxuICAgKiBjb25zdHJ1Y3RvciBvbiB0aGUgZmFjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Jlc29sdmVDb21wb25lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGNiKSB7XG4gICAgdmFyIGZhY3Rvcnk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmFjdG9yeSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWN0b3J5ID0gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnlcbiAgICBpZiAoIWZhY3Rvcnkub3B0aW9ucykge1xuICAgICAgaWYgKGZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgICAgLy8gY2FjaGVkXG4gICAgICAgIGNiKGZhY3RvcnkucmVzb2x2ZWQpO1xuICAgICAgfSBlbHNlIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgICAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgICAgICBmYWN0b3J5LmNhbGwodGhpcywgZnVuY3Rpb24gcmVzb2x2ZShyZXMpIHtcbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBWdWUuZXh0ZW5kKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjYnNbaV0ocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCcgKyAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICc6ICcgKyB2YWx1ZSA6ICcnKSArICcuICcgKyAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgICBjYihmYWN0b3J5KTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBmaWx0ZXJSRSQxID0gL1tefF1cXHxbXnxdLztcblxuZnVuY3Rpb24gZGF0YUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBpZiAoYXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RhdGVtZW50SGFuZGxlcigpIHtcbiAgICAgICAgICBzZWxmLiRhcmd1bWVudHMgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcy5nZXQuY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgICBzZWxmLiRhcmd1bWVudHMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXMuZ2V0LmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgKiBUaGUgZXhwcmVzc2lvbiBtdXN0IGJlIGEgdmFsaWQgbGVmdC1oYW5kXG4gICAqIGV4cHJlc3Npb24gaW4gYW4gYXNzaWdubWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcGFyYW0geyp9IHZhbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBmdW5jdGlvbiAoZXhwLCB2YWwpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cCwgdHJ1ZSk7XG4gICAgaWYgKHJlcyAmJiByZXMuc2V0KSB7XG4gICAgICByZXMuc2V0LmNhbGwodGhpcywgdGhpcywgdmFsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHByb3BlcnR5IG9uIHRoZSBWTVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWwodGhpcy5fZGF0YSwga2V5KTtcbiAgfTtcblxuICAvKipcbiAgICogV2F0Y2ggYW4gZXhwcmVzc2lvbiwgdHJpZ2dlciBjYWxsYmFjayB3aGVuIGl0c1xuICAgKiB2YWx1ZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZXhwT3JGblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBpbW1lZGlhdGVcbiAgICogQHJldHVybiB7RnVuY3Rpb259IC0gdW53YXRjaEZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcGFyc2VkO1xuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKGV4cE9yRm4pO1xuICAgICAgZXhwT3JGbiA9IHBhcnNlZC5leHByZXNzaW9uO1xuICAgIH1cbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwge1xuICAgICAgZGVlcDogb3B0aW9ucyAmJiBvcHRpb25zLmRlZXAsXG4gICAgICBzeW5jOiBvcHRpb25zICYmIG9wdGlvbnMuc3luYyxcbiAgICAgIGZpbHRlcnM6IHBhcnNlZCAmJiBwYXJzZWQuZmlsdGVycyxcbiAgICAgIHVzZXI6ICFvcHRpb25zIHx8IG9wdGlvbnMudXNlciAhPT0gZmFsc2VcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4oKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgYSB0ZXh0IGRpcmVjdGl2ZSwgaW5jbHVkaW5nIGZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGV2YWwgPSBmdW5jdGlvbiAodGV4dCwgYXNTdGF0ZW1lbnQpIHtcbiAgICAvLyBjaGVjayBmb3IgZmlsdGVycy5cbiAgICBpZiAoZmlsdGVyUkUkMS50ZXN0KHRleHQpKSB7XG4gICAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUodGV4dCk7XG4gICAgICAvLyB0aGUgZmlsdGVyIHJlZ2V4IGNoZWNrIG1pZ2h0IGdpdmUgZmFsc2UgcG9zaXRpdmVcbiAgICAgIC8vIGZvciBwaXBlcyBpbnNpZGUgc3RyaW5ncywgc28gaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgICAvLyB3ZSBkb24ndCBnZXQgYW55IGZpbHRlcnMgaGVyZVxuICAgICAgdmFyIHZhbCA9IHRoaXMuJGdldChkaXIuZXhwcmVzc2lvbiwgYXNTdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIGRpci5maWx0ZXJzID8gdGhpcy5fYXBwbHlGaWx0ZXJzKHZhbCwgbnVsbCwgZGlyLmZpbHRlcnMpIDogdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBmaWx0ZXJcbiAgICAgIHJldHVybiB0aGlzLiRnZXQodGV4dCwgYXNTdGF0ZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJwb2xhdGUgYSBwaWVjZSBvZiB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGludGVycG9sYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KHRleHQpO1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZtLiRldmFsKHRva2Vuc1swXS52YWx1ZSkgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHJldHVybiB0b2tlbi50YWcgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTG9nIGluc3RhbmNlIGRhdGEgYXMgYSBwbGFpbiBKUyBvYmplY3RcbiAgICogc28gdGhhdCBpdCBpcyBlYXNpZXIgdG8gaW5zcGVjdCBpbiBjb25zb2xlLlxuICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIGNvbnNvbGUgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGxvZyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGRhdGEgPSBwYXRoID8gZ2V0UGF0aCh0aGlzLl9kYXRhLCBwYXRoKSA6IHRoaXMuX2RhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGRhdGEgPSBjbGVhbihkYXRhKTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBjb21wdXRlZCBmaWVsZHNcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBmb3IgKGtleSBpbiB0aGlzLiRvcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGNsZWFuKHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcHJvcHMpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImNsZWFuXCIgYSBnZXR0ZXIvc2V0dGVyIGNvbnZlcnRlZCBvYmplY3QgaW50byBhIHBsYWluXG4gICAqIG9iamVjdCBjb3B5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gLSBvYmpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBjbGVhbihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21BUEkgKFZ1ZSkge1xuICAvKipcbiAgICogQ29udmVuaWVuY2Ugb24taW5zdGFuY2UgbmV4dFRpY2suIFRoZSBjYWxsYmFjayBpc1xuICAgKiBhdXRvLWJvdW5kIHRvIHRoZSBpbnN0YW5jZSwgYW5kIHRoaXMgYXZvaWRzIGNvbXBvbmVudFxuICAgKiBtb2R1bGVzIGhhdmluZyB0byByZWx5IG9uIHRoZSBnbG9iYWwgVnVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIG5leHRUaWNrKGZuLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQXBwZW5kIGluc3RhbmNlIHRvIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYXBwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBhcHBlbmQsIGFwcGVuZFdpdGhUcmFuc2l0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJlcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHByZXBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQuZmlyc3RDaGlsZCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kYXBwZW5kVG8odGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGluc3RhbmNlIGJlZm9yZSB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGJlZm9yZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBpbnNlcnQodGhpcywgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIGJlZm9yZVdpdGhDYiwgYmVmb3JlV2l0aFRyYW5zaXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgaW5zdGFuY2UgYWZ0ZXIgdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRhZnRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgICAgdGhpcy4kYmVmb3JlKHRhcmdldC5uZXh0U2libGluZywgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kYXBwZW5kVG8odGFyZ2V0LnBhcmVudE5vZGUsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgaW5zdGFuY2UgZnJvbSBET01cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHJlbW92ZSA9IGZ1bmN0aW9uIChjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuJGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBjYiAmJiBjYigpO1xuICAgIH1cbiAgICB2YXIgaW5Eb2N1bWVudCA9IHRoaXMuX2lzQXR0YWNoZWQgJiYgaW5Eb2ModGhpcy4kZWwpO1xuICAgIC8vIGlmIHdlIGFyZSBub3QgaW4gZG9jdW1lbnQsIG5vIG5lZWQgdG8gY2hlY2tcbiAgICAvLyBmb3IgdHJhbnNpdGlvbnNcbiAgICBpZiAoIWluRG9jdW1lbnQpIHdpdGhUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZWFsQ2IgPSBmdW5jdGlvbiByZWFsQ2IoKSB7XG4gICAgICBpZiAoaW5Eb2N1bWVudCkgc2VsZi5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5faXNGcmFnbWVudCkge1xuICAgICAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMuX2ZyYWdtZW50U3RhcnQsIHRoaXMuX2ZyYWdtZW50RW5kLCB0aGlzLCB0aGlzLl9mcmFnbWVudCwgcmVhbENiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlID8gcmVtb3ZlV2l0aENiIDogcmVtb3ZlV2l0aFRyYW5zaXRpb247XG4gICAgICBvcCh0aGlzLiRlbCwgdGhpcywgcmVhbENiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNoYXJlZCBET00gaW5zZXJ0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AxIC0gb3AgZm9yIG5vbi10cmFuc2l0aW9uIGluc2VydFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDIgLSBvcCBmb3IgdHJhbnNpdGlvbiBpbnNlcnRcbiAgICogQHJldHVybiB2bVxuICAgKi9cblxuICBmdW5jdGlvbiBpbnNlcnQodm0sIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBvcDEsIG9wMikge1xuICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgdmFyIHRhcmdldElzRGV0YWNoZWQgPSAhaW5Eb2ModGFyZ2V0KTtcbiAgICB2YXIgb3AgPSB3aXRoVHJhbnNpdGlvbiA9PT0gZmFsc2UgfHwgdGFyZ2V0SXNEZXRhY2hlZCA/IG9wMSA6IG9wMjtcbiAgICB2YXIgc2hvdWxkQ2FsbEhvb2sgPSAhdGFyZ2V0SXNEZXRhY2hlZCAmJiAhdm0uX2lzQXR0YWNoZWQgJiYgIWluRG9jKHZtLiRlbCk7XG4gICAgaWYgKHZtLl9pc0ZyYWdtZW50KSB7XG4gICAgICBtYXBOb2RlUmFuZ2Uodm0uX2ZyYWdtZW50U3RhcnQsIHZtLl9mcmFnbWVudEVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgb3Aobm9kZSwgdGFyZ2V0LCB2bSk7XG4gICAgICB9KTtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wKHZtLiRlbCwgdGFyZ2V0LCB2bSwgY2IpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQ2FsbEhvb2spIHtcbiAgICAgIHZtLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzZWxlY3RvcnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gZWxcbiAgICovXG5cbiAgZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpIDogZWw7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYXBwZW5kKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydEJlZm9yZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJlZm9yZVdpdGhDYihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVdpdGhDYihlbCwgdm0sIGNiKSB7XG4gICAgcmVtb3ZlKGVsKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRzQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAodGhpcy5fZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICBzZWxmLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdGhpcy4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIGNicztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgICAgZm9yIChldmVudCBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC0xKTtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gc2hvdWxkUHJvcGFnYXRlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgdmFyIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGlzU291cmNlIHx8ICFjYnM7XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgaGFja3kgc29sdXRpb24gdG8gdGhlIHF1ZXN0aW9uIHJhaXNlZFxuICAgICAgLy8gaW4gIzIxMDI6IGZvciBhbiBpbmxpbmUgY29tcG9uZW50IGxpc3RlbmVyIGxpa2UgPGNvbXAgQHRlc3Q9XCJkb1RoaXNcIj4sXG4gICAgICAvLyB0aGUgcHJvcGFnYXRpb24gaGFuZGxpbmcgaXMgc29tZXdoYXQgYnJva2VuLiBUaGVyZWZvcmUgd2VcbiAgICAgIC8vIG5lZWQgdG8gdHJlYXQgdGhlc2UgaW5saW5lIGNhbGxiYWNrcyBkaWZmZXJlbnRseS5cbiAgICAgIHZhciBoYXNQYXJlbnRDYnMgPSBpc1NvdXJjZSAmJiBjYnMuc29tZShmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiLl9mcm9tUGFyZW50O1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzUGFyZW50Q2JzKSB7XG4gICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNiID0gY2JzW2ldO1xuICAgICAgICB2YXIgcmVzID0gY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGlmIChyZXMgPT09IHRydWUgJiYgKCFoYXNQYXJlbnRDYnMgfHwgY2IuX2Zyb21QYXJlbnQpKSB7XG4gICAgICAgICAgc2hvdWxkUHJvcGFnYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkUHJvcGFnYXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBicm9hZGNhc3QgYW4gZXZlbnQgdG8gYWxsIGNoaWxkcmVuIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiBAcGFyYW0gey4uLip9IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGJyb2FkY2FzdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpc1NvdXJjZSA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZyc7XG4gICAgZXZlbnQgPSBpc1NvdXJjZSA/IGV2ZW50IDogZXZlbnQubmFtZTtcbiAgICAvLyBpZiBubyBjaGlsZCBoYXMgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudCxcbiAgICAvLyB0aGVuIHRoZXJlJ3Mgbm8gbmVlZCB0byBicm9hZGNhc3QuXG4gICAgaWYgKCF0aGlzLl9ldmVudHNDb3VudFtldmVudF0pIHJldHVybjtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlbjtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBpZiAoaXNTb3VyY2UpIHtcbiAgICAgIC8vIHVzZSBvYmplY3QgZXZlbnQgdG8gaW5kaWNhdGUgbm9uLXNvdXJjZSBlbWl0XG4gICAgICAvLyBvbiBjaGlsZHJlblxuICAgICAgYXJnc1swXSA9IHsgbmFtZTogZXZlbnQsIHNvdXJjZTogdGhpcyB9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgaWYgKHNob3VsZFByb3BhZ2F0ZSkge1xuICAgICAgICBjaGlsZC4kYnJvYWRjYXN0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSBhbiBldmVudCB1cCB0aGUgcGFyZW50IGNoYWluLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkaXNwYXRjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCFzaG91bGRQcm9wYWdhdGUpIHJldHVybjtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIC8vIHVzZSBvYmplY3QgZXZlbnQgdG8gaW5kaWNhdGUgbm9uLXNvdXJjZSBlbWl0XG4gICAgLy8gb24gcGFyZW50c1xuICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBzaG91bGRQcm9wYWdhdGUgPSBwYXJlbnQuJGVtaXQuYXBwbHkocGFyZW50LCBhcmdzKTtcbiAgICAgIHBhcmVudCA9IHNob3VsZFByb3BhZ2F0ZSA/IHBhcmVudC4kcGFyZW50IDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgbGlzdGVuZXIgY291bnRzIG9uIGFsbCBwYXJlbnRzLlxuICAgKiBUaGlzIGJvb2trZWVwaW5nIGFsbG93cyAkYnJvYWRjYXN0IHRvIHJldHVybiBlYXJseSB3aGVuXG4gICAqIG5vIGNoaWxkIGhhcyBsaXN0ZW5lZCB0byBhIGNlcnRhaW4gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gICAqL1xuXG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgZnVuY3Rpb24gbW9kaWZ5TGlzdGVuZXJDb3VudCh2bSwgZXZlbnQsIGNvdW50KSB7XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgLy8gaG9va3MgZG8gbm90IGdldCBicm9hZGNhc3RlZCBzbyBubyBuZWVkXG4gICAgLy8gdG8gZG8gYm9va2tlZXBpbmcgZm9yIHRoZW1cbiAgICBpZiAoIXBhcmVudCB8fCAhY291bnQgfHwgaG9va1JFLnRlc3QoZXZlbnQpKSByZXR1cm47XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgcGFyZW50Ll9ldmVudHNDb3VudFtldmVudF0gPSAocGFyZW50Ll9ldmVudHNDb3VudFtldmVudF0gfHwgMCkgKyBjb3VudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogU2V0IGluc3RhbmNlIHRhcmdldCBlbGVtZW50IGFuZCBraWNrIG9mZiB0aGUgY29tcGlsYXRpb25cbiAgICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAgICogZXhpc3RpbmcgRWxlbWVudCwgb3IgYSBEb2N1bWVudEZyYWdtZW50IChmb3IgYmxvY2tcbiAgICogaW5zdGFuY2VzKS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8c3RyaW5nfSBlbFxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29tcGlsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignJG1vdW50KCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJywgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsID0gcXVlcnkoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBpbGUoZWwpO1xuICAgIHRoaXMuX2luaXRET01Ib29rcygpO1xuICAgIGlmIChpbkRvYyh0aGlzLiRlbCkpIHtcbiAgICAgIHRoaXMuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgICAgcmVhZHkuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kb25jZSgnaG9vazphdHRhY2hlZCcsIHJlYWR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgcmVhZHkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdyZWFkeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBfZGVzdHJveS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlckNsZWFudXBcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgIHRoaXMuX2Rlc3Ryb3kocmVtb3ZlLCBkZWZlckNsZWFudXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY29tcGlsZSBhIHBpZWNlIG9mIERPTSBhbmQgcmV0dXJuIGFcbiAgICogZGVjb21waWxlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ11cbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGNvbXBpbGUgPSBmdW5jdGlvbiAoZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgcmV0dXJuIGNvbXBpbGUoZWwsIHRoaXMuJG9wdGlvbnMsIHRydWUpKHRoaXMsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGV4cG9zZWQgVnVlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEFQSSBjb252ZW50aW9uczpcbiAqIC0gcHVibGljIEFQSSBtZXRob2RzL3Byb3BlcnRpZXMgYXJlIHByZWZpeGVkIHdpdGggYCRgXG4gKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAqIC0gbm9uLXByZWZpeGVkIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgcHJveGllZCB1c2VyXG4gKiAgIGRhdGEuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVnVlKG9wdGlvbnMpIHtcbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuLy8gaW5zdGFsbCBpbnRlcm5hbHNcbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5taXNjTWl4aW4oVnVlKTtcblxuLy8gaW5zdGFsbCBpbnN0YW5jZSBBUElzXG5kYXRhQVBJKFZ1ZSk7XG5kb21BUEkoVnVlKTtcbmV2ZW50c0FQSShWdWUpO1xubGlmZWN5Y2xlQVBJKFZ1ZSk7XG5cbnZhciBzbG90ID0ge1xuXG4gIHByaW9yaXR5OiBTTE9ULFxuICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gdGhpcyB3YXMgcmVzb2x2ZWQgZHVyaW5nIGNvbXBvbmVudCB0cmFuc2NsdXNpb25cbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyYW1zLm5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgIHZhciBjb250ZW50ID0gdGhpcy52bS5fc2xvdENvbnRlbnRzICYmIHRoaXMudm0uX3Nsb3RDb250ZW50c1tuYW1lXTtcbiAgICBpZiAoIWNvbnRlbnQgfHwgIWNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tcGlsZShjb250ZW50LmNsb25lTm9kZSh0cnVlKSwgdGhpcy52bS5fY29udGV4dCwgdGhpcy52bSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoY29udGVudCwgY29udGV4dCwgaG9zdCkge1xuICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLmVsLmhhc0NoaWxkTm9kZXMoKSAmJiBjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gMSAmJiBjb250ZW50LmNoaWxkTm9kZXNbMF0uaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgICAgLy8gaWYgdGhlIGluc2VydGVkIHNsb3QgaGFzIHYtaWZcbiAgICAgICAgLy8gaW5qZWN0IGZhbGxiYWNrIGNvbnRlbnQgYXMgdGhlIHYtZWxzZVxuICAgICAgICB2YXIgZWxzZUJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgZWxzZUJsb2NrLnNldEF0dHJpYnV0ZSgndi1lbHNlJywgJycpO1xuICAgICAgICBlbHNlQmxvY2suaW5uZXJIVE1MID0gdGhpcy5lbC5pbm5lckhUTUw7XG4gICAgICAgIC8vIHRoZSBlbHNlIGJsb2NrIHNob3VsZCBiZSBjb21waWxlZCBpbiBjaGlsZCBzY29wZVxuICAgICAgICBlbHNlQmxvY2suX2NvbnRleHQgPSB0aGlzLnZtO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsc2VCbG9jayk7XG4gICAgICB9XG4gICAgICB2YXIgc2NvcGUgPSBob3N0ID8gaG9zdC5fc2NvcGUgOiB0aGlzLl9zY29wZTtcbiAgICAgIHRoaXMudW5saW5rID0gY29udGV4dC4kY29tcGlsZShjb250ZW50LCBob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUodGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICB0aGlzLmNvbXBpbGUoZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSksIHRoaXMudm0pO1xuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLnVubGluaykge1xuICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJ0aWFsID0ge1xuXG4gIHByaW9yaXR5OiBQQVJUSUFMLFxuXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgLy8gd2F0Y2ggY2hhbmdlcyB0byBuYW1lIGZvciBkeW5hbWljIHBhcnRpYWxzXG4gIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKHZhbHVlKSB7XG4gICAgICB2SWYucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LXBhcnRpYWwnKTtcbiAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB0aGlzLmluc2VydCh0aGlzLnBhcmFtcy5uYW1lKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChpZCkge1xuICAgIHZhciBwYXJ0aWFsID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdwYXJ0aWFscycsIGlkLCB0cnVlKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBwYXJ0aWFsKTtcbiAgICAgIHZJZi5pbnNlcnQuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbGVtZW50RGlyZWN0aXZlcyA9IHtcbiAgc2xvdDogc2xvdCxcbiAgcGFydGlhbDogcGFydGlhbFxufTtcblxudmFyIGNvbnZlcnRBcnJheSA9IHZGb3IuX3Bvc3RQcm9jZXNzO1xuXG4vKipcbiAqIExpbWl0IGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgKERlY2ltYWwgZXhwZWN0ZWQpXG4gKi9cblxuZnVuY3Rpb24gbGltaXRCeShhcnIsIG4sIG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPyBwYXJzZUludChvZmZzZXQsIDEwKSA6IDA7XG4gIG4gPSB0b051bWJlcihuKTtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IGFyci5zbGljZShvZmZzZXQsIG9mZnNldCArIG4pIDogYXJyO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGVsaW1pdGVyXVxuICogQHBhcmFtIHtTdHJpbmd9IC4uLmRhdGFLZXlzXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyQnkoYXJyLCBzZWFyY2gsIGRlbGltaXRlcikge1xuICBhcnIgPSBjb252ZXJ0QXJyYXkoYXJyKTtcbiAgaWYgKHNlYXJjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKHNlYXJjaCk7XG4gIH1cbiAgLy8gY2FzdCB0byBsb3dlcmNhc2Ugc3RyaW5nXG4gIHNlYXJjaCA9ICgnJyArIHNlYXJjaCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gYWxsb3cgb3B0aW9uYWwgYGluYCBkZWxpbWl0ZXJcbiAgLy8gYmVjYXVzZSB3aHkgbm90XG4gIHZhciBuID0gZGVsaW1pdGVyID09PSAnaW4nID8gMyA6IDI7XG4gIC8vIGV4dHJhY3QgYW5kIGZsYXR0ZW4ga2V5c1xuICB2YXIga2V5cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRvQXJyYXkoYXJndW1lbnRzLCBuKSk7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGl0ZW0sIGtleSwgdmFsLCBqO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpdGVtID0gYXJyW2ldO1xuICAgIHZhbCA9IGl0ZW0gJiYgaXRlbS4kdmFsdWUgfHwgaXRlbTtcbiAgICBqID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGopIHtcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJyRrZXknICYmIGNvbnRhaW5zKGl0ZW0uJGtleSwgc2VhcmNoKSB8fCBjb250YWlucyhnZXRQYXRoKHZhbCwga2V5KSwgc2VhcmNoKSkge1xuICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250YWlucyhpdGVtLCBzZWFyY2gpKSB7XG4gICAgICByZXMucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxTdHJpbmc+fEZ1bmN0aW9ufSAuLi5zb3J0S2V5c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcl1cbiAqL1xuXG5mdW5jdGlvbiBvcmRlckJ5KGFycikge1xuICB2YXIgY29tcGFyYXRvciA9IG51bGw7XG4gIHZhciBzb3J0S2V5cyA9IHVuZGVmaW5lZDtcbiAgYXJyID0gY29udmVydEFycmF5KGFycik7XG5cbiAgLy8gZGV0ZXJtaW5lIG9yZGVyIChsYXN0IGFyZ3VtZW50KVxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgdmFyIG9yZGVyID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJykge1xuICAgIG9yZGVyID0gb3JkZXIgPCAwID8gLTEgOiAxO1xuICAgIGFyZ3MgPSBhcmdzLmxlbmd0aCA+IDEgPyBhcmdzLnNsaWNlKDAsIC0xKSA6IGFyZ3M7XG4gIH0gZWxzZSB7XG4gICAgb3JkZXIgPSAxO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHNvcnRLZXlzICYgY29tcGFyYXRvclxuICB2YXIgZmlyc3RBcmcgPSBhcmdzWzBdO1xuICBpZiAoIWZpcnN0QXJnKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBjdXN0b20gY29tcGFyYXRvclxuICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZpcnN0QXJnKGEsIGIpICogb3JkZXI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJpbmcga2V5cy4gZmxhdHRlbiBmaXJzdFxuICAgIHNvcnRLZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJncyk7XG4gICAgY29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiLCBpKSB7XG4gICAgICBpID0gaSB8fCAwO1xuICAgICAgcmV0dXJuIGkgPj0gc29ydEtleXMubGVuZ3RoIC0gMSA/IGJhc2VDb21wYXJlKGEsIGIsIGkpIDogYmFzZUNvbXBhcmUoYSwgYiwgaSkgfHwgY29tcGFyYXRvcihhLCBiLCBpICsgMSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2VDb21wYXJlKGEsIGIsIHNvcnRLZXlJbmRleCkge1xuICAgIHZhciBzb3J0S2V5ID0gc29ydEtleXNbc29ydEtleUluZGV4XTtcbiAgICBpZiAoc29ydEtleSkge1xuICAgICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgICBpZiAoaXNPYmplY3QoYSkgJiYgJyR2YWx1ZScgaW4gYSkgYSA9IGEuJHZhbHVlO1xuICAgICAgICBpZiAoaXNPYmplY3QoYikgJiYgJyR2YWx1ZScgaW4gYikgYiA9IGIuJHZhbHVlO1xuICAgICAgfVxuICAgICAgYSA9IGlzT2JqZWN0KGEpID8gZ2V0UGF0aChhLCBzb3J0S2V5KSA6IGE7XG4gICAgICBiID0gaXNPYmplY3QoYikgPyBnZXRQYXRoKGIsIHNvcnRLZXkpIDogYjtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyBvcmRlciA6IC1vcmRlcjtcbiAgfVxuXG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGNvbXBhcmF0b3IpO1xufVxuXG4vKipcbiAqIFN0cmluZyBjb250YWluIGhlbHBlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKi9cblxuZnVuY3Rpb24gY29udGFpbnModmFsLCBzZWFyY2gpIHtcbiAgdmFyIGk7XG4gIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjb250YWlucyh2YWxba2V5c1tpXV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjb250YWlucyh2YWxbaV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTE7XG4gIH1cbn1cblxudmFyIGRpZ2l0c1JFID0gLyhcXGR7M30pKD89XFxkKS9nO1xuXG4vLyBhc3NldCBjb2xsZWN0aW9ucyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LlxudmFyIGZpbHRlcnMgPSB7XG5cbiAgb3JkZXJCeTogb3JkZXJCeSxcbiAgZmlsdGVyQnk6IGZpbHRlckJ5LFxuICBsaW1pdEJ5OiBsaW1pdEJ5LFxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlbnRcbiAgICovXG5cbiAganNvbjoge1xuICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQodmFsdWUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGluZGVudCA6IDIpO1xuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqICdhYmMnID0+ICdBYmMnXG4gICAqL1xuXG4gIGNhcGl0YWxpemU6IGZ1bmN0aW9uIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQUJDJ1xuICAgKi9cblxuICB1cHBlcmNhc2U6IGZ1bmN0aW9uIHVwcGVyY2FzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA6ICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiAnQWJDJyA9PiAnYWJjJ1xuICAgKi9cblxuICBsb3dlcmNhc2U6IGZ1bmN0aW9uIGxvd2VyY2FzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiAxMjM0NSA9PiAkMTIsMzQ1LjAwXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaWduXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWNpbWFscyBEZWNpbWFsIHBsYWNlc1xuICAgKi9cblxuICBjdXJyZW5jeTogZnVuY3Rpb24gY3VycmVuY3kodmFsdWUsIF9jdXJyZW5jeSwgZGVjaW1hbHMpIHtcbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmICghaXNGaW5pdGUodmFsdWUpIHx8ICF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIF9jdXJyZW5jeSA9IF9jdXJyZW5jeSAhPSBudWxsID8gX2N1cnJlbmN5IDogJyQnO1xuICAgIGRlY2ltYWxzID0gZGVjaW1hbHMgIT0gbnVsbCA/IGRlY2ltYWxzIDogMjtcbiAgICB2YXIgc3RyaW5naWZpZWQgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZChkZWNpbWFscyk7XG4gICAgdmFyIF9pbnQgPSBkZWNpbWFscyA/IHN0cmluZ2lmaWVkLnNsaWNlKDAsIC0xIC0gZGVjaW1hbHMpIDogc3RyaW5naWZpZWQ7XG4gICAgdmFyIGkgPSBfaW50Lmxlbmd0aCAlIDM7XG4gICAgdmFyIGhlYWQgPSBpID4gMCA/IF9pbnQuc2xpY2UoMCwgaSkgKyAoX2ludC5sZW5ndGggPiAzID8gJywnIDogJycpIDogJyc7XG4gICAgdmFyIF9mbG9hdCA9IGRlY2ltYWxzID8gc3RyaW5naWZpZWQuc2xpY2UoLTEgLSBkZWNpbWFscykgOiAnJztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/ICctJyA6ICcnO1xuICAgIHJldHVybiBzaWduICsgX2N1cnJlbmN5ICsgaGVhZCArIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICsgX2Zsb2F0O1xuICB9LFxuXG4gIC8qKlxuICAgKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICAgKlxuICAgKiBAcGFyYW1zXG4gICAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICogIHRoZSBzaW5nbGUsIGRvdWJsZSwgdHJpcGxlIC4uLiBmb3JtcyBvZiB0aGUgd29yZCB0b1xuICAgKiAgYmUgcGx1cmFsaXplZC4gV2hlbiB0aGUgbnVtYmVyIHRvIGJlIHBsdXJhbGl6ZWRcbiAgICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAgICogIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICpcbiAgICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gICAqL1xuXG4gIHBsdXJhbGl6ZTogZnVuY3Rpb24gcGx1cmFsaXplKHZhbHVlKSB7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSB2YWx1ZSAlIDEwIC0gMTtcbiAgICAgIHJldHVybiBpbmRleCBpbiBhcmdzID8gYXJnc1tpbmRleF0gOiBhcmdzW2xlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJnc1swXSArICh2YWx1ZSA9PT0gMSA/ICcnIDogJ3MnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlYm91bmNlIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgPSAzMDBcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShoYW5kbGVyLCBkZWxheSkge1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgIGlmICghZGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gMzAwO1xuICAgIH1cbiAgICByZXR1cm4gX2RlYm91bmNlKGhhbmRsZXIsIGRlbGF5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBWdWUgYW5kIGV2ZXJ5IGNvbnN0cnVjdG9yIHRoYXQgZXh0ZW5kcyBWdWUgaGFzIGFuXG4gICAqIGFzc29jaWF0ZWQgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBkdXJpbmdcbiAgICogY29tcGlsYXRpb24gc3RlcHMgYXMgYHRoaXMuY29uc3RydWN0b3Iub3B0aW9uc2AuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSBzZWVuIGFzIHRoZSBkZWZhdWx0IG9wdGlvbnMgb2YgZXZlcnlcbiAgICogVnVlIGluc3RhbmNlLlxuICAgKi9cblxuICBWdWUub3B0aW9ucyA9IHtcbiAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgIGVsZW1lbnREaXJlY3RpdmVzOiBlbGVtZW50RGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgIHRyYW5zaXRpb25zOiB7fSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBwYXJ0aWFsczoge30sXG4gICAgcmVwbGFjZTogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBvc2UgdXNlZnVsIGludGVybmFsc1xuICAgKi9cblxuICBWdWUudXRpbCA9IHV0aWw7XG4gIFZ1ZS5jb25maWcgPSBjb25maWc7XG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZVsnZGVsZXRlJ10gPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2FnZSAvIHBsdWdpbnNcbiAgICovXG5cbiAgVnVlLmNvbXBpbGVyID0gY29tcGlsZXI7XG4gIFZ1ZS5GcmFnbWVudEZhY3RvcnkgPSBGcmFnbWVudEZhY3Rvcnk7XG4gIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMgPSBpbnRlcm5hbERpcmVjdGl2ZXM7XG4gIFZ1ZS5wYXJzZXJzID0ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgdGV4dDogdGV4dCxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgZGlyZWN0aXZlOiBkaXJlY3RpdmUsXG4gICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICB9O1xuXG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG5cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5kT3B0aW9uc1xuICAgKi9cblxuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwO1xuICAgIGlmIChpc0ZpcnN0RXh0ZW5kICYmIGV4dGVuZE9wdGlvbnMuX0N0b3IpIHtcbiAgICAgIHJldHVybiBleHRlbmRPcHRpb25zLl9DdG9yO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICsgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY2F0ZXJzIGFuZCB0aGUgaHlwaGVuLicpO1xuICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFN1YiA9IGNyZWF0ZUNsYXNzKG5hbWUgfHwgJ1Z1ZUNvbXBvbmVudCcpO1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoU3VwZXIub3B0aW9ucywgZXh0ZW5kT3B0aW9ucyk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb25cbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgICAgZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IFN1YjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YjtcbiAgfTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAgICogZ2l2ZW4gbmFtZS4gVGhpcyBnaXZlcyB1cyBtdWNoIG5pY2VyIG91dHB1dCB3aGVuXG4gICAqIGxvZ2dpbmcgaW5zdGFuY2VzIGluIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MobmFtZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uICcgKyBjbGFzc2lmeShuYW1lKSArICcgKG9wdGlvbnMpIHsgdGhpcy5faW5pdChvcHRpb25zKSB9JykoKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH1cblxuICAvKipcbiAgICogUGx1Z2luIHN5c3RlbVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gICAqL1xuXG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgZ2xvYmFsIG1peGluIGJ5IG1lcmdpbmcgaXQgaW50byB0aGUgZGVmYXVsdFxuICAgKiBvcHRpb25zLlxuICAgKi9cblxuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICBWdWUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhWdWUub3B0aW9ucywgbWl4aW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHNpZ25hdHVyZTpcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICAgKi9cblxuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIChjb21tb25UYWdSRS50ZXN0KGlkKSB8fCByZXNlcnZlZFRhZ1JFLnRlc3QoaWQpKSkge1xuICAgICAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGlmICghZGVmaW5pdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IFZ1ZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIGV4cG9zZSBpbnRlcm5hbCB0cmFuc2l0aW9uIEFQSVxuICBleHRlbmQoVnVlLnRyYW5zaXRpb24sIHRyYW5zaXRpb24pO1xufVxuXG5pbnN0YWxsR2xvYmFsQVBJKFZ1ZSk7XG5cblZ1ZS52ZXJzaW9uID0gJzEuMC4yNic7XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbkJyb3dzZXIgJiYgL0Nocm9tZVxcL1xcZCsvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zb2xlLmxvZygnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnKTtcbiAgICB9XG4gIH1cbn0sIDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUvZGlzdC92dWUuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXHJcbiAqIEtlZW4gVUkgdjAuOC45IChodHRwczovL2dpdGh1Yi5jb20vSm9zZXBodXNQYXllL2tlZW4tdWkpXHJcbiAqIChjKSAyMDE2IEpvc2VwaHVzIFBheWUgSUlcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiS2VlblwiXSA9IGZhY3RvcnkoKTtcclxuXHRlbHNlXHJcblx0XHRyb290W1wiS2VlblwiXSA9IGZhY3RvcnkoKTtcclxufSkodGhpcywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxyXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxyXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2VcclxuLyoqKioqKi8gXHRcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxyXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblx0XHJcblx0dmFyIF9VaUFsZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHRcclxuXHR2YXIgX1VpQWxlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlBbGVydCk7XHJcblx0XHJcblx0dmFyIF9VaUF1dG9jb21wbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xyXG5cdFxyXG5cdHZhciBfVWlBdXRvY29tcGxldGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlBdXRvY29tcGxldGUpO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUJ1dHRvbik7XHJcblx0XHJcblx0dmFyIF9VaUNoZWNrYm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTMpO1xyXG5cdFxyXG5cdHZhciBfVWlDaGVja2JveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUNoZWNrYm94KTtcclxuXHRcclxuXHR2YXIgX1VpQ29sbGFwc2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XHJcblx0XHJcblx0dmFyIF9VaUNvbGxhcHNpYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQ29sbGFwc2libGUpO1xyXG5cdFxyXG5cdHZhciBfVWlDb25maXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpO1xyXG5cdFxyXG5cdHZhciBfVWlDb25maXJtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQ29uZmlybSk7XHJcblx0XHJcblx0dmFyIF9VaUZhYiA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5KTtcclxuXHRcclxuXHR2YXIgX1VpRmFiMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpRmFiKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaU1lbnUpO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnVPcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNZW51T3B0aW9uKTtcclxuXHRcclxuXHR2YXIgX1VpTW9kYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XHJcblx0XHJcblx0dmFyIF9VaU1vZGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTW9kYWwpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQb3BvdmVyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJlbG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMpO1xyXG5cdFxyXG5cdHZhciBfVWlQcmVsb2FkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcmVsb2FkZXIpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0NpcmN1bGFyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NMaW5lYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzTGluZWFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NMaW5lYXIpO1xyXG5cdFxyXG5cdHZhciBfVWlSYWRpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQxKTtcclxuXHRcclxuXHR2YXIgX1VpUmFkaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYWRpbyk7XHJcblx0XHJcblx0dmFyIF9VaVJhZGlvR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NSk7XHJcblx0XHJcblx0dmFyIF9VaVJhZGlvR3JvdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYWRpb0dyb3VwKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDkpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYXRpbmcpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmdJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTIpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmdJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmF0aW5nSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ1ByZXZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Nyk7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ1ByZXZpZXcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYXRpbmdQcmV2aWV3KTtcclxuXHRcclxuXHR2YXIgX1VpUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblx0XHJcblx0dmFyIF9VaVJpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJpcHBsZUluayk7XHJcblx0XHJcblx0dmFyIF9VaVNlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYxKTtcclxuXHRcclxuXHR2YXIgX1VpU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU2VsZWN0KTtcclxuXHRcclxuXHR2YXIgX1VpU2xpZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzIpO1xyXG5cdFxyXG5cdHZhciBfVWlTbGlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTbGlkZXIpO1xyXG5cdFxyXG5cdHZhciBfVWlTbmFja2JhciA9IF9fd2VicGFja19yZXF1aXJlX18oMTg0KTtcclxuXHRcclxuXHR2YXIgX1VpU25hY2tiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTbmFja2Jhcik7XHJcblx0XHJcblx0dmFyIF9VaVNuYWNrYmFyQ29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODgpO1xyXG5cdFxyXG5cdHZhciBfVWlTbmFja2JhckNvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVNuYWNrYmFyQ29udGFpbmVyKTtcclxuXHRcclxuXHR2YXIgX1VpU3dpdGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTIpO1xyXG5cdFxyXG5cdHZhciBfVWlTd2l0Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTd2l0Y2gpO1xyXG5cdFxyXG5cdHZhciBfVWlUYWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5Nik7XHJcblx0XHJcblx0dmFyIF9VaVRhYjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRhYik7XHJcblx0XHJcblx0dmFyIF9VaVRhYnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMCk7XHJcblx0XHJcblx0dmFyIF9VaVRhYnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUYWJzKTtcclxuXHRcclxuXHR2YXIgX1VpVGV4dGJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA4KTtcclxuXHRcclxuXHR2YXIgX1VpVGV4dGJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRleHRib3gpO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpVG9vbGJhcik7XHJcblx0XHJcblx0dmFyIF9VaVRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcclxuXHRcclxuXHR2YXIgX1VpVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRvb2x0aXApO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0dmFyIEtlZW4gPSB7XHJcblx0ICAgIFVpQWxlcnQ6IF9VaUFsZXJ0Mi5kZWZhdWx0LFxyXG5cdCAgICBVaUF1dG9jb21wbGV0ZTogX1VpQXV0b2NvbXBsZXRlMi5kZWZhdWx0LFxyXG5cdCAgICBVaUJ1dHRvbjogX1VpQnV0dG9uMi5kZWZhdWx0LFxyXG5cdCAgICBVaUNoZWNrYm94OiBfVWlDaGVja2JveDIuZGVmYXVsdCxcclxuXHQgICAgVWlDb2xsYXBzaWJsZTogX1VpQ29sbGFwc2libGUyLmRlZmF1bHQsXHJcblx0ICAgIFVpQ29uZmlybTogX1VpQ29uZmlybTIuZGVmYXVsdCxcclxuXHQgICAgVWlGYWI6IF9VaUZhYjIuZGVmYXVsdCxcclxuXHQgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0LFxyXG5cdCAgICBVaUljb25CdXR0b246IF9VaUljb25CdXR0b24yLmRlZmF1bHQsXHJcblx0ICAgIFVpTWVudTogX1VpTWVudTIuZGVmYXVsdCxcclxuXHQgICAgVWlNZW51T3B0aW9uOiBfVWlNZW51T3B0aW9uMi5kZWZhdWx0LFxyXG5cdCAgICBVaU1vZGFsOiBfVWlNb2RhbDIuZGVmYXVsdCxcclxuXHQgICAgVWlQb3BvdmVyOiBfVWlQb3BvdmVyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVByZWxvYWRlcjogX1VpUHJlbG9hZGVyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHQsXHJcblx0ICAgIFVpUHJvZ3Jlc3NMaW5lYXI6IF9VaVByb2dyZXNzTGluZWFyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhZGlvOiBfVWlSYWRpbzIuZGVmYXVsdCxcclxuXHQgICAgVWlSYWRpb0dyb3VwOiBfVWlSYWRpb0dyb3VwMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhdGluZzogX1VpUmF0aW5nMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhdGluZ0ljb246IF9VaVJhdGluZ0ljb24yLmRlZmF1bHQsXHJcblx0ICAgIFVpUmF0aW5nUHJldmlldzogX1VpUmF0aW5nUHJldmlldzIuZGVmYXVsdCxcclxuXHQgICAgVWlSaXBwbGVJbms6IF9VaVJpcHBsZUluazIuZGVmYXVsdCxcclxuXHQgICAgVWlTZWxlY3Q6IF9VaVNlbGVjdDIuZGVmYXVsdCxcclxuXHQgICAgVWlTbGlkZXI6IF9VaVNsaWRlcjIuZGVmYXVsdCxcclxuXHQgICAgVWlTbmFja2JhcjogX1VpU25hY2tiYXIyLmRlZmF1bHQsXHJcblx0ICAgIFVpU25hY2tiYXJDb250YWluZXI6IF9VaVNuYWNrYmFyQ29udGFpbmVyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVN3aXRjaDogX1VpU3dpdGNoMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRhYjogX1VpVGFiMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRhYnM6IF9VaVRhYnMyLmRlZmF1bHQsXHJcblx0ICAgIFVpVGV4dGJveDogX1VpVGV4dGJveDIuZGVmYXVsdCxcclxuXHQgICAgVWlUb29sYmFyOiBfVWlUb29sYmFyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRvb2x0aXA6IF9VaVRvb2x0aXAyLmRlZmF1bHQsXHJcblx0XHJcblx0ICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1hbGVydCcsIF9VaUFsZXJ0Mi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWF1dG9jb21wbGV0ZScsIF9VaUF1dG9jb21wbGV0ZTIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1idXR0b24nLCBfVWlCdXR0b24yLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktY2hlY2tib3gnLCBfVWlDaGVja2JveDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1jb2xsYXBzaWJsZScsIF9VaUNvbGxhcHNpYmxlMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWNvbmZpcm0nLCBfVWlDb25maXJtMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWZhYicsIF9VaUZhYjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1pY29uJywgX1VpSWNvbjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1pY29uLWJ1dHRvbicsIF9VaUljb25CdXR0b24yLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktbWVudScsIF9VaU1lbnUyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktbWVudS1vcHRpb24nLCBfVWlNZW51T3B0aW9uMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLW1vZGFsJywgX1VpTW9kYWwyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcG9wb3ZlcicsIF9VaVBvcG92ZXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcHJlbG9hZGVyJywgX1VpUHJlbG9hZGVyMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXByb2dyZXNzLWNpcmN1bGFyJywgX1VpUHJvZ3Jlc3NDaXJjdWxhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1wcm9ncmVzcy1saW5lYXInLCBfVWlQcm9ncmVzc0xpbmVhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yYWRpbycsIF9VaVJhZGlvMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXJhZGlvLWdyb3VwJywgX1VpUmFkaW9Hcm91cDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yYXRpbmcnLCBfVWlSYXRpbmcyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcmF0aW5nLWljb24nLCBfVWlSYXRpbmdJY29uMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXJhdGluZy1wcmV2aWV3JywgX1VpUmF0aW5nUHJldmlldzIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yaXBwbGUtaW5rJywgX1VpUmlwcGxlSW5rMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXNlbGVjdCcsIF9VaVNlbGVjdDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zbGlkZXInLCBfVWlTbGlkZXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktc25hY2tiYXInLCBfVWlTbmFja2JhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zbmFja2Jhci1jb250YWluZXInLCBfVWlTbmFja2JhckNvbnRhaW5lcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zd2l0Y2gnLCBfVWlTd2l0Y2gyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktdGFiJywgX1VpVGFiMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRhYnMnLCBfVWlUYWJzMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRleHRib3gnLCBfVWlUZXh0Ym94Mi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRvb2xiYXInLCBfVWlUb29sYmFyMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRvb2x0aXAnLCBfVWlUb29sdGlwMi5kZWZhdWx0KTtcclxuXHQgICAgfVxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBLZWVuO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHZhciBoYWRLZXlib2FyZEV2ZW50ID0gZmFsc2U7XHJcblx0ICAgIHZhciBrZXlib2FyZE1vZGFsaXR5V2hpdGVsaXN0ID0gWydpbnB1dDpub3QoW3R5cGVdKScsICdpbnB1dFt0eXBlPXRleHRdJywgJ2lucHV0W3R5cGU9bnVtYmVyXScsICdpbnB1dFt0eXBlPWRhdGVdJywgJ2lucHV0W3R5cGU9dGltZV0nLCAnaW5wdXRbdHlwZT1kYXRldGltZV0nLCAndGV4dGFyZWEnLCAnW3JvbGU9dGV4dGJveF0nLCAnW3N1cHBvcnRzLW1vZGFsaXR5PWtleWJvYXJkXSddLmpvaW4oJywnKTtcclxuXHRcclxuXHQgICAgdmFyIGlzSGFuZGxpbmdLZXlib2FyZFRocm90dGxlO1xyXG5cdFxyXG5cdCAgICB2YXIgbWF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmJvZHk7XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWwubWF0Y2hlc1NlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXNTZWxlY3RvcjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKGVsLm1vek1hdGNoZXNTZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBlbC5tb3pNYXRjaGVzU2VsZWN0b3I7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3I7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZG5cXCd0IGZpbmQgYW55IG1hdGNoZXNTZWxlY3RvciBtZXRob2Qgb24gZG9jdW1lbnQuYm9keS4nKTtcclxuXHQgICAgfSgpO1xyXG5cdFxyXG5cdCAgICB2YXIgZGlzYWJsZUZvY3VzUmluZ0J5RGVmYXVsdCA9IGZ1bmN0aW9uIGRpc2FibGVGb2N1c1JpbmdCeURlZmF1bHQoKSB7XHJcblx0ICAgICAgICB2YXIgY3NzID0gJ2JvZHk6bm90KFttb2RhbGl0eT1rZXlib2FyZF0pIDpmb2N1cyB7IG91dGxpbmU6IG5vbmU7IH0nO1xyXG5cdCAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XHJcblx0ICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5cdFxyXG5cdCAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcblx0ICAgICAgICBzdHlsZS5pZCA9ICdkaXNhYmxlLWZvY3VzLXJpbmcnO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuXHQgICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIHZhciBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSA9IGZ1bmN0aW9uIGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KGVsKSB7XHJcblx0ICAgICAgICB2YXIgdHJpZ2dlcnMgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICAgIGlmIChtYXRjaGVyKSB7XHJcblx0ICAgICAgICAgICAgdHJpZ2dlcnMgPSBtYXRjaGVyLmNhbGwoZWwsIGtleWJvYXJkTW9kYWxpdHlXaGl0ZWxpc3QpICYmIG1hdGNoZXIuY2FsbChlbCwgJzpub3QoW3JlYWRvbmx5XSknKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiB0cmlnZ2VycztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgZGlzYWJsZUZvY3VzUmluZ0J5RGVmYXVsdCgpO1xyXG5cdFxyXG5cdCAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgIGlmIChpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZSkge1xyXG5cdCAgICAgICAgICAgIGNsZWFyVGltZW91dChpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZSk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIGhhZEtleWJvYXJkRXZlbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH0sIDEwMCk7XHJcblx0ICAgIH0sIHRydWUpO1xyXG5cdFxyXG5cdCAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgIGlmIChoYWRLZXlib2FyZEV2ZW50IHx8IGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KGUudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdtb2RhbGl0eScsICdrZXlib2FyZCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LCB0cnVlKTtcclxuXHRcclxuXHQgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ21vZGFsaXR5Jyk7XHJcblx0ICAgIH0sIHRydWUpO1xyXG5cdH0pO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygzKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQWxlcnQudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaUFsZXJ0LnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogNCAqLyxcclxuLyogNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0XHJcblx0dmFyIF9VaUljb25CdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWFsZXJ0JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdpbmZvJyB9LFxyXG5cdCAgICAgICAgdGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzbWlzc2libGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGljb25OYW1lOiBmdW5jdGlvbiBpY29uTmFtZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5pY29uKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmljb247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy50eXBlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChpY29uID09PSAnc3VjY2VzcycpIHtcclxuXHQgICAgICAgICAgICAgICAgaWNvbiA9ICdjaGVja19jaXJjbGUnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gaWNvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkaXNtaXNzZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlJY29uQnV0dG9uOiBfVWlJY29uQnV0dG9uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpSWNvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlJY29uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWljb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJlbW92ZVRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxpXFxuICAgIGNsYXNzPVxcXCJ1aS1pY29uIG1hdGVyaWFsLWljb25zXFxcIiA6Y2xhc3M9XFxcIltpY29uXVxcXCIgdi10ZXh0PVxcXCJyZW1vdmVUZXh0ID8gbnVsbCA6IGljb25cXFwiXFxuICAgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIlxcbj48L2k+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlJY29uQnV0dG9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlJY29uQnV0dG9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaU1lbnUpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQb3BvdmVyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NDaXJjdWxhciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NDaXJjdWxhcik7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfSGFzRHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcclxuXHRcclxuXHR2YXIgX0hhc0Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc0Ryb3Bkb3duKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NUb29sdGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzVG9vbHRpcCk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluayA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NSaXBwbGVJbmspO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktaWNvbi1idXR0b24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3VpLWljb24tYnV0dG9uLScgKyB0eXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBidXR0b25UeXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGFyaWFMYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgbG9hZGluZzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHN0eWxlQ2xhc3NlczogZnVuY3Rpb24gc3R5bGVDbGFzc2VzKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW3RoaXMudHlwZSwgdGhpcy5jb2xvcl07XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaGFzRHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd1aS1kcm9wZG93bicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzcGlubmVyQ29sb3I6IGZ1bmN0aW9uIHNwaW5uZXJDb2xvcigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb2xvciA9PT0gJ2NvbG9yLWRlZmF1bHQnIHx8IHRoaXMuY29sb3IgPT09ICdjb2xvci1ibGFjaycpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdibGFjayc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaU1lbnU6IF9VaU1lbnUyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVBvcG92ZXI6IF9VaVBvcG92ZXIyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc0Ryb3Bkb3duMi5kZWZhdWx0LCBfU2hvd3NUb29sdGlwMi5kZWZhdWx0LCBfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHRdLFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTQpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpTWVudS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpTWVudS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnVPcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNZW51T3B0aW9uKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzRHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzRHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NEcm9wZG93bik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1tZW51JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG9wdGlvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93SWNvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd1NlY29uZGFyeVRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZVJpcHBsZUluazoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZU9uU2VsZWN0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGFydGlhbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndWktbWVudS1kZWZhdWx0J1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICdkcm9wZG93bi1vcGVuZWQnOiBmdW5jdGlvbiBkcm9wZG93bk9wZW5lZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250YWluRm9jdXMpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgJ2Ryb3Bkb3duLWNsb3NlZCc6IGZ1bmN0aW9uIGRyb3Bkb3duQ2xvc2VkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5Gb2N1cykge1xyXG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMucmVzdHJpY3RGb2N1cywgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgb3B0aW9uU2VsZWN0OiBmdW5jdGlvbiBvcHRpb25TZWxlY3Qob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCEob3B0aW9uLmRpc2FibGVkIHx8IG9wdGlvbi50eXBlID09PSAnZGl2aWRlcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdvcHRpb24tc2VsZWN0ZWQnLCBvcHRpb24pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9zZU9uU2VsZWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZXN0cmljdEZvY3VzOiBmdW5jdGlvbiByZXN0cmljdEZvY3VzKGUpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuJGVscy5kcm9wZG93bi5jb250YWlucyhlLnRhcmdldCkpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZWxzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy51aS1tZW51LW9wdGlvbicpLmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJlZGlyZWN0Rm9jdXM6IGZ1bmN0aW9uIHJlZGlyZWN0Rm9jdXMoZSkge1xyXG5cdCAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZWxzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy51aS1tZW51LW9wdGlvbicpLmZvY3VzKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpTWVudU9wdGlvbjogX1VpTWVudU9wdGlvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfU2hvd3NEcm9wZG93bjIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTcpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpTWVudU9wdGlvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpTWVudU9wdGlvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLW1lbnUtb3B0aW9uJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgIHRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIHNob3dJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlY29uZGFyeVRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIHNob3dTZWNvbmRhcnlUZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLW1lbnUtZGVmYXVsdCdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb246IE9iamVjdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgaXNEaXZpZGVyOiBmdW5jdGlvbiBpc0RpdmlkZXIoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2RpdmlkZXInO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcGFydGlhbHM6IHtcclxuXHQgICAgICAgICd1aS1tZW51LWRlZmF1bHQnOiAnXFxuICAgICAgICAgICAgPHVpLWljb25cXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ1aS1tZW51LW9wdGlvbi1pY29uXCIgOmljb249XCJpY29uXCIgdi1pZj1cInNob3dJY29uICYmICFpc0RpdmlkZXIgJiYgaWNvblwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktbWVudS1vcHRpb24tdGV4dFwiIHYtdGV4dD1cInRleHRcIiB2LWlmPVwiIWlzRGl2aWRlclwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ1aS1tZW51LW9wdGlvbi1zZWNvbmRhcnktdGV4dFwiIHYtdGV4dD1cInNlY29uZGFyeVRleHRcIlxcbiAgICAgICAgICAgICAgICB2LWlmPVwic2hvd1NlY29uZGFyeVRleHQgJiYgIWlzRGl2aWRlciAmJiBzZWNvbmRhcnlUZXh0XCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICAnXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1JpcHBsZUluazIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblx0XHJcblx0dmFyIF9VaVJpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJpcHBsZUluayk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBoaWRlUmlwcGxlSW5rOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVJpcHBsZUluazogX1VpUmlwcGxlSW5rMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjEpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUmlwcGxlSW5rLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlSaXBwbGVJbmsudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbGlzdCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHR2YXIgc3RhcnRSaXBwbGUgPSBmdW5jdGlvbiBzdGFydFJpcHBsZShldmVudFR5cGUsIGV2ZW50KSB7XHJcblx0ICAgIHZhciBob2xkZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cdFxyXG5cdCAgICBpZiAoIV9jbGFzc2xpc3QyLmRlZmF1bHQuaGFzKGhvbGRlciwgJ3VpLXJpcHBsZS1pbmsnKSkge1xyXG5cdCAgICAgICAgaG9sZGVyID0gaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy51aS1yaXBwbGUtaW5rJyk7XHJcblx0XHJcblx0ICAgICAgICBpZiAoIWhvbGRlcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgcHJldiA9IGhvbGRlci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdWktZXZlbnQnKTtcclxuXHRcclxuXHQgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gZXZlbnRUeXBlKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaG9sZGVyLnNldEF0dHJpYnV0ZSgnZGF0YS11aS1ldmVudCcsIGV2ZW50VHlwZSk7XHJcblx0XHJcblx0ICAgIHZhciByZWN0ID0gaG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdCAgICB2YXIgeCA9IGV2ZW50Lm9mZnNldFg7XHJcblx0ICAgIHZhciB5O1xyXG5cdFxyXG5cdCAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICB5ID0gZXZlbnQub2Zmc2V0WTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG5cdCAgICAgICAgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgcmlwcGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgIHZhciBtYXg7XHJcblx0XHJcblx0ICAgIGlmIChyZWN0LndpZHRoID09PSByZWN0LmhlaWdodCkge1xyXG5cdCAgICAgICAgbWF4ID0gcmVjdC53aWR0aCAqIDEuNDEyO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgbWF4ID0gTWF0aC5zcXJ0KHJlY3Qud2lkdGggKiByZWN0LndpZHRoICsgcmVjdC5oZWlnaHQgKiByZWN0LmhlaWdodCk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIGRpbSA9IG1heCAqIDIgKyAncHgnO1xyXG5cdFxyXG5cdCAgICByaXBwbGUuc3R5bGUud2lkdGggPSBkaW07XHJcblx0ICAgIHJpcHBsZS5zdHlsZS5oZWlnaHQgPSBkaW07XHJcblx0ICAgIHJpcHBsZS5zdHlsZS5tYXJnaW5MZWZ0ID0gLW1heCArIHggKyAncHgnO1xyXG5cdCAgICByaXBwbGUuc3R5bGUubWFyZ2luVG9wID0gLW1heCArIHkgKyAncHgnO1xyXG5cdFxyXG5cdCAgICByaXBwbGUuY2xhc3NOYW1lID0gJ3JpcHBsZSc7XHJcblx0ICAgIGhvbGRlci5hcHBlbmRDaGlsZChyaXBwbGUpO1xyXG5cdFxyXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQuYWRkKHJpcHBsZSwgJ2hlbGQnKTtcclxuXHQgICAgfSwgMCk7XHJcblx0XHJcblx0ICAgIHZhciByZWxlYXNlRXZlbnQgPSBldmVudFR5cGUgPT09ICdtb3VzZWRvd24nID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kJztcclxuXHRcclxuXHQgICAgdmFyIHJlbGVhc2UgPSBmdW5jdGlvbiByZWxlYXNlKCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWxlYXNlRXZlbnQsIHJlbGVhc2UpO1xyXG5cdFxyXG5cdCAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5hZGQocmlwcGxlLCAnZG9uZScpO1xyXG5cdFxyXG5cdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgaG9sZGVyLnJlbW92ZUNoaWxkKHJpcHBsZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCFob2xkZXIuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQucmVtb3ZlKGhvbGRlciwgJ2FjdGl2ZScpO1xyXG5cdCAgICAgICAgICAgICAgICBob2xkZXIucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXVpLWV2ZW50Jyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSwgNDUwKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihyZWxlYXNlRXZlbnQsIHJlbGVhc2UpO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihlKSB7XHJcblx0ICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xyXG5cdCAgICAgICAgc3RhcnRSaXBwbGUoZS50eXBlLCBlKTtcclxuXHQgICAgfVxyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcclxuXHQgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIHtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHN0YXJ0UmlwcGxlKGUudHlwZSwgZS5jaGFuZ2VkVG91Y2hlc1tpXSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJpcHBsZS1pbmsnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHJpZ2dlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEVsZW1lbnQsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0b3J5OiBmdW5jdGlvbiBiZWZvcmVEZXN0b3J5KCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoU3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuXHRcclxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdHZhciB0cmltID0gL15cXHMrfFxccyskL2c7XHJcblx0dmFyIHdoaXRlc3BhY2UgPSAvXFxzKy9nO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGludGVycHJldChpbnB1dCkge1xyXG5cdCAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IGlucHV0LnJlcGxhY2UodHJpbSwgJycpLnNwbGl0KHdoaXRlc3BhY2UpIDogaW5wdXQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGNsYXNzZXMoZWwpIHtcclxuXHQgICAgaWYgKGlzRWxlbWVudChlbCkpIHtcclxuXHQgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUucmVwbGFjZSh0cmltLCAnJykuc3BsaXQod2hpdGVzcGFjZSk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIFtdO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBzZXQoZWwsIGlucHV0KSB7XHJcblx0ICAgIGlmIChpc0VsZW1lbnQoZWwpKSB7XHJcblx0ICAgICAgICBlbC5jbGFzc05hbWUgPSBpbnRlcnByZXQoaW5wdXQpLmpvaW4oJyAnKTtcclxuXHQgICAgfVxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBhZGQoZWwsIGlucHV0KSB7XHJcblx0ICAgIHZhciBjdXJyZW50ID0gcmVtb3ZlKGVsLCBpbnB1dCk7XHJcblx0ICAgIHZhciB2YWx1ZXMgPSBpbnRlcnByZXQoaW5wdXQpO1xyXG5cdFxyXG5cdCAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgdmFsdWVzKTtcclxuXHQgICAgc2V0KGVsLCBjdXJyZW50KTtcclxuXHRcclxuXHQgICAgcmV0dXJuIGN1cnJlbnQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHJlbW92ZShlbCwgaW5wdXQpIHtcclxuXHQgICAgdmFyIGN1cnJlbnQgPSBjbGFzc2VzKGVsKTtcclxuXHQgICAgdmFyIHZhbHVlcyA9IGludGVycHJldChpbnB1dCk7XHJcblx0XHJcblx0ICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIGkgPSBjdXJyZW50LmluZGV4T2YodmFsdWUpO1xyXG5cdCAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBzZXQoZWwsIGN1cnJlbnQpO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gY3VycmVudDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gY29udGFpbnMoZWwsIGlucHV0KSB7XHJcblx0ICAgIHZhciBjdXJyZW50ID0gY2xhc3NlcyhlbCk7XHJcblx0ICAgIHZhciB2YWx1ZXMgPSBpbnRlcnByZXQoaW5wdXQpO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gdmFsdWVzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGN1cnJlbnQuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xyXG5cdCAgICB9KTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcclxuXHQgICAgdmFyIGVsZW1lbnRPYmplY3RzID0gKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShIVE1MRWxlbWVudCkpID09PSAnb2JqZWN0JztcclxuXHRcclxuXHQgICAgcmV0dXJuIGVsZW1lbnRPYmplY3RzID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogaXNFbGVtZW50T2JqZWN0KG8pO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBpc0VsZW1lbnRPYmplY3Qobykge1xyXG5cdCAgICByZXR1cm4gbyAmJiAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobykpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgby5ub2RlVHlwZSA9PT0gMTtcclxuXHR9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBhZGQ6IGFkZCxcclxuXHQgICAgcmVtb3ZlOiByZW1vdmUsXHJcblx0ICAgIGNvbnRhaW5zOiBjb250YWlucyxcclxuXHQgICAgaGFzOiBjb250YWlucyxcclxuXHQgICAgc2V0OiBzZXQsXHJcblx0ICAgIGdldDogY2xhc3Nlc1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0dmFyIF9TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KVtcImRlZmF1bHRcIl07XHJcblx0XHJcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICByZXR1cm4gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX1N5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xyXG5cdH07XHJcblx0XHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDI1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMjYpLCBfX2VzTW9kdWxlOiB0cnVlIH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KS5TeW1ib2w7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cclxuXHR2YXIgJCAgICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxyXG5cdCAgLCBnbG9iYWwgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXHJcblx0ICAsIGhhcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcclxuXHQgICwgREVTQ1JJUFRPUlMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKVxyXG5cdCAgLCAkZXhwb3J0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpXHJcblx0ICAsIHJlZGVmaW5lICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNylcclxuXHQgICwgJGZhaWxzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxyXG5cdCAgLCBzaGFyZWQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDApXHJcblx0ICAsIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSlcclxuXHQgICwgdWlkICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxyXG5cdCAgLCB3a3MgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpXHJcblx0ICAsIGtleU9mICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcclxuXHQgICwgJG5hbWVzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KVxyXG5cdCAgLCBlbnVtS2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTApXHJcblx0ICAsIGlzQXJyYXkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSlcclxuXHQgICwgYW5PYmplY3QgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKVxyXG5cdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpXHJcblx0ICAsIGNyZWF0ZURlc2MgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSlcclxuXHQgICwgZ2V0RGVzYyAgICAgICAgPSAkLmdldERlc2NcclxuXHQgICwgc2V0RGVzYyAgICAgICAgPSAkLnNldERlc2NcclxuXHQgICwgX2NyZWF0ZSAgICAgICAgPSAkLmNyZWF0ZVxyXG5cdCAgLCBnZXROYW1lcyAgICAgICA9ICRuYW1lcy5nZXRcclxuXHQgICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXHJcblx0ICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cclxuXHQgICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcclxuXHQgICwgc2V0dGVyICAgICAgICAgPSBmYWxzZVxyXG5cdCAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXHJcblx0ICAsIGlzRW51bSAgICAgICAgID0gJC5pc0VudW1cclxuXHQgICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXHJcblx0ICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcclxuXHQgICwgdXNlTmF0aXZlICAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXHJcblx0ICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHRcclxuXHQvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcclxuXHR2YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xyXG5cdCAgcmV0dXJuIF9jcmVhdGUoc2V0RGVzYyh7fSwgJ2EnLCB7XHJcblx0ICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHNldERlc2ModGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XHJcblx0ICB9KSkuYSAhPSA3O1xyXG5cdH0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XHJcblx0ICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcclxuXHQgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcclxuXHQgIHNldERlc2MoaXQsIGtleSwgRCk7XHJcblx0ICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcclxuXHR9IDogc2V0RGVzYztcclxuXHRcclxuXHR2YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XHJcblx0ICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSk7XHJcblx0ICBzeW0uX2sgPSB0YWc7XHJcblx0ICBERVNDUklQVE9SUyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XHJcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XHJcblx0ICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xyXG5cdCAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdCAgcmV0dXJuIHN5bTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XHJcblx0ICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcclxuXHQgICAgaWYoIUQuZW51bWVyYWJsZSl7XHJcblx0ICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlzZXREZXNjKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcclxuXHQgICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XHJcblx0ICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XHJcblx0ICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XHJcblx0ICB9IHJldHVybiBzZXREZXNjKGl0LCBrZXksIEQpO1xyXG5cdH07XHJcblx0dmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XHJcblx0ICBhbk9iamVjdChpdCk7XHJcblx0ICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXHJcblx0ICAgICwgaSAgICA9IDBcclxuXHQgICAgLCBsID0ga2V5cy5sZW5ndGhcclxuXHQgICAgLCBrZXk7XHJcblx0ICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcclxuXHQgIHJldHVybiBpdDtcclxuXHR9O1xyXG5cdHZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcclxuXHQgIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcclxuXHR9O1xyXG5cdHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xyXG5cdCAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkpO1xyXG5cdCAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XVxyXG5cdCAgICA/IEUgOiB0cnVlO1xyXG5cdH07XHJcblx0dmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XHJcblx0ICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xyXG5cdCAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XHJcblx0ICByZXR1cm4gRDtcclxuXHR9O1xyXG5cdHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xyXG5cdCAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXHJcblx0ICAgICwgcmVzdWx0ID0gW11cclxuXHQgICAgLCBpICAgICAgPSAwXHJcblx0ICAgICwga2V5O1xyXG5cdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcclxuXHQgIHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHR2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XHJcblx0ICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcclxuXHQgICAgLCByZXN1bHQgPSBbXVxyXG5cdCAgICAsIGkgICAgICA9IDBcclxuXHQgICAgLCBrZXk7XHJcblx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xyXG5cdCAgcmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cdHZhciAkc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcclxuXHQgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxyXG5cdCAgdmFyIGFyZ3MgPSBbaXRdXHJcblx0ICAgICwgaSAgICA9IDFcclxuXHQgICAgLCAkJCAgID0gYXJndW1lbnRzXHJcblx0ICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcclxuXHQgIHdoaWxlKCQkLmxlbmd0aCA+IGkpYXJncy5wdXNoKCQkW2krK10pO1xyXG5cdCAgcmVwbGFjZXIgPSBhcmdzWzFdO1xyXG5cdCAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XHJcblx0ICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XHJcblx0ICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG5cdCAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcclxuXHQgIH07XHJcblx0ICBhcmdzWzFdID0gcmVwbGFjZXI7XHJcblx0ICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XHJcblx0fTtcclxuXHR2YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XHJcblx0ICB2YXIgUyA9ICRTeW1ib2woKTtcclxuXHQgIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XHJcblx0ICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcclxuXHQgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXHJcblx0ICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xyXG5cdH0pO1xyXG5cdFxyXG5cdC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxyXG5cdGlmKCF1c2VOYXRpdmUpe1xyXG5cdCAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xyXG5cdCAgICBpZihpc1N5bWJvbCh0aGlzKSl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xyXG5cdCAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpKTtcclxuXHQgIH07XHJcblx0ICByZWRlZmluZSgkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcclxuXHQgICAgcmV0dXJuIHRoaXMuX2s7XHJcblx0ICB9KTtcclxuXHRcclxuXHQgIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xyXG5cdCAgfTtcclxuXHRcclxuXHQgICQuY3JlYXRlICAgICA9ICRjcmVhdGU7XHJcblx0ICAkLmlzRW51bSAgICAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XHJcblx0ICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cdCAgJC5zZXREZXNjICAgID0gJGRlZmluZVByb3BlcnR5O1xyXG5cdCAgJC5zZXREZXNjcyAgID0gJGRlZmluZVByb3BlcnRpZXM7XHJcblx0ICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XHJcblx0ICAkLmdldFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG5cdFxyXG5cdCAgaWYoREVTQ1JJUFRPUlMgJiYgIV9fd2VicGFja19yZXF1aXJlX18oNTQpKXtcclxuXHQgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdHZhciBzeW1ib2xTdGF0aWNzID0ge1xyXG5cdCAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXHJcblx0ICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcclxuXHQgICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxyXG5cdCAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxyXG5cdCAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcclxuXHQgIH0sXHJcblx0ICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcclxuXHQgIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XHJcblx0ICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcclxuXHQgIH0sXHJcblx0ICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXHJcblx0ICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XHJcblx0fTtcclxuXHQvLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2VcclxuXHQvLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXHJcblx0Ly8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXHJcblx0Ly8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXHJcblx0Ly8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2VcclxuXHQvLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXHJcblx0Ly8gMTkuNC4yLjEwIFN5bWJvbC5zcGVjaWVzXHJcblx0Ly8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxyXG5cdC8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcclxuXHQvLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXHJcblx0Ly8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xyXG5cdCQuZWFjaC5jYWxsKChcclxuXHQgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXHJcblx0ICAnc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcclxuXHQpLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcclxuXHQgIHZhciBzeW0gPSB3a3MoaXQpO1xyXG5cdCAgc3ltYm9sU3RhdGljc1tpdF0gPSB1c2VOYXRpdmUgPyBzeW0gOiB3cmFwKHN5bSk7XHJcblx0fSk7XHJcblx0XHJcblx0c2V0dGVyID0gdHJ1ZTtcclxuXHRcclxuXHQkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVywge1N5bWJvbDogJFN5bWJvbH0pO1xyXG5cdFxyXG5cdCRleHBvcnQoJGV4cG9ydC5TLCAnU3ltYm9sJywgc3ltYm9sU3RhdGljcyk7XHJcblx0XHJcblx0JGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xyXG5cdCAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG5cdCAgY3JlYXRlOiAkY3JlYXRlLFxyXG5cdCAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXHJcblx0ICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxyXG5cdCAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcclxuXHQgIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxyXG5cdCAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxyXG5cdCAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxyXG5cdCAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxuXHQgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG5cdCAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxyXG5cdCAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXHJcblx0fSk7XHJcblx0XHJcblx0Ly8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXHJcblx0JEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIXVzZU5hdGl2ZSB8fCBidWdneUpTT04pLCAnSlNPTicsIHtzdHJpbmdpZnk6ICRzdHJpbmdpZnl9KTtcclxuXHRcclxuXHQvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXHJcblx0c2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xyXG5cdC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuXHRzZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xyXG5cdC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXHJcblx0c2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyICRPYmplY3QgPSBPYmplY3Q7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcclxuXHQgIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXHJcblx0ICBpc0VudW06ICAgICB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcclxuXHQgIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxyXG5cdCAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcclxuXHQgIHNldERlc2NzOiAgICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyxcclxuXHQgIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcclxuXHQgIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcclxuXHQgIGdldFN5bWJvbHM6ICRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxyXG5cdCAgZWFjaDogICAgICAgW10uZm9yRWFjaFxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcclxuXHR2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcclxuXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHRpZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG5cclxuLyoqKi8gfSxcclxuLyogMzAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XHJcblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcclxuXHRtb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKShmdW5jdGlvbigpe1xyXG5cdCAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxuXHR9KTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xyXG5cdCAgdHJ5IHtcclxuXHQgICAgcmV0dXJuICEhZXhlYygpO1xyXG5cdCAgfSBjYXRjaChlKXtcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgZ2xvYmFsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcclxuXHQgICwgY29yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNClcclxuXHQgICwgY3R4ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlcclxuXHQgICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XHJcblx0XHJcblx0dmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG5cdCAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcclxuXHQgICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXHJcblx0ICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xyXG5cdCAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcclxuXHQgICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXHJcblx0ICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xyXG5cdCAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXHJcblx0ICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxyXG5cdCAgICAsIGtleSwgb3duLCBvdXQ7XHJcblx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcclxuXHQgIGZvcihrZXkgaW4gc291cmNlKXtcclxuXHQgICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXHJcblx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XHJcblx0ICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcclxuXHQgICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcclxuXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcclxuXHQgICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXHJcblx0ICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXHJcblx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XHJcblx0ICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXHJcblx0ICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcblx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XHJcblx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbihwYXJhbSl7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcclxuXHQgICAgICB9O1xyXG5cdCAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcclxuXHQgICAgICByZXR1cm4gRjtcclxuXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXHJcblx0ICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcclxuXHQgICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xyXG5cdCAgfVxyXG5cdH07XHJcblx0Ly8gdHlwZSBiaXRtYXBcclxuXHQkZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXHJcblx0JGV4cG9ydC5HID0gMjsgIC8vIGdsb2JhbFxyXG5cdCRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcclxuXHQkZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cclxuXHQkZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxyXG5cdCRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXHJcblx0bW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMzQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi42J307XHJcblx0aWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXHJcblxyXG4vKioqLyB9LFxyXG4vKiAzNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXHJcblx0dmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XHJcblx0ICBhRnVuY3Rpb24oZm4pO1xyXG5cdCAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcclxuXHQgIHN3aXRjaChsZW5ndGgpe1xyXG5cdCAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcclxuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcclxuXHQgICAgfTtcclxuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XHJcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XHJcblx0ICAgIH07XHJcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xyXG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xyXG5cdCAgICB9O1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG5cdCAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcclxuXHQgIH07XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XHJcblx0ICByZXR1cm4gaXQ7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMzggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciAkICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOClcclxuXHQgICwgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSkgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xyXG5cdCAgcmV0dXJuICQuc2V0RGVzYyhvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xyXG5cdH0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xyXG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuXHQgIHJldHVybiBvYmplY3Q7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxyXG5cdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXHJcblx0ICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcclxuXHQgICAgdmFsdWUgICAgICAgOiB2YWx1ZVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxyXG5cdCAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xyXG5cdCAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG5cdCAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCkuc2V0RGVzY1xyXG5cdCAgLCBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxyXG5cdCAgLCBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSgndG9TdHJpbmdUYWcnKTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xyXG5cdCAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIHN0b3JlICA9IF9fd2VicGFja19yZXF1aXJlX18oNDApKCd3a3MnKVxyXG5cdCAgLCB1aWQgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxyXG5cdCAgLCBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KS5TeW1ib2w7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcclxuXHQgIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxyXG5cdCAgICBTeW1ib2wgJiYgU3ltYm9sW25hbWVdIHx8IChTeW1ib2wgfHwgdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgaWQgPSAwXHJcblx0ICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcblx0ICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyICQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXHJcblx0ICAsIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XHJcblx0ICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuXHQgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcclxuXHQgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG5cdCAgICAsIGluZGV4ICA9IDBcclxuXHQgICAgLCBrZXk7XHJcblx0ICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXHJcblx0dmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KVxyXG5cdCAgLCBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQ2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xyXG5cdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xyXG5cdCAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XHJcblx0ICByZXR1cm4gaXQ7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQ5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XHJcblx0dmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpXHJcblx0ICAsIGdldE5hbWVzICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLmdldE5hbWVzXHJcblx0ICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xyXG5cdFxyXG5cdHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcclxuXHQgID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xyXG5cdFxyXG5cdHZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHRyeSB7XHJcblx0ICAgIHJldHVybiBnZXROYW1lcyhpdCk7XHJcblx0ICB9IGNhdGNoKGUpe1xyXG5cdCAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xyXG5cdCAgaWYod2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScpcmV0dXJuIGdldFdpbmRvd05hbWVzKGl0KTtcclxuXHQgIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXHJcblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxyXG5cdCAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHM7XHJcblx0ICBpZihnZXRTeW1ib2xzKXtcclxuXHQgICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxyXG5cdCAgICAgICwgaXNFbnVtICA9ICQuaXNFbnVtXHJcblx0ICAgICAgLCBpICAgICAgID0gMFxyXG5cdCAgICAgICwga2V5O1xyXG5cdCAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpa2V5cy5wdXNoKGtleSk7XHJcblx0ICB9XHJcblx0ICByZXR1cm4ga2V5cztcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXHJcblx0dmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcmcpe1xyXG5cdCAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDUyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xyXG5cdCAgcmV0dXJuIGl0O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDU2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktcmlwcGxlLWlua1xcXCI+PC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxhXFxuICAgIGNsYXNzPVxcXCJ1aS1tZW51LW9wdGlvblxcXCIgcm9sZT1cXFwibWVudS1pdGVtXFxcIiA6dGFiaW5kZXg9XFxcIihpc0RpdmlkZXIgfHwgZGlzYWJsZWQpID8gbnVsbCA6ICcwJ1xcXCJcXG4gICAgOmNsYXNzPVxcXCJ7ICdkaXZpZGVyJzogaXNEaXZpZGVyLCAnZGlzYWJsZWQnIDogZGlzYWJsZWQgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLW1lbnUtb3B0aW9uLWNvbnRlbnRcXFwiIDpjbGFzcz1cXFwiW3BhcnRpYWxdXFxcIj5cXG4gICAgICAgIDxwYXJ0aWFsIDpuYW1lPVxcXCJwYXJ0aWFsXFxcIj48L3BhcnRpYWw+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8dWktcmlwcGxlLWlua1xcbiAgICAgICAgOnRyaWdnZXI9XFxcIiRlbFxcXCIgdi1pZj1cXFwiIWhpZGVSaXBwbGVJbmsgJiYgIWRpc2FibGVkICYmICFpc0RpdmlkZXJcXFwiXFxuICAgID48L3VpLXJpcHBsZS1pbms+XFxuPC9hPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3RldGhlckRyb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxuXHRcclxuXHR2YXIgX3RldGhlckRyb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV0aGVyRHJvcCk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc2xpc3QpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICB0cmlnZ2VyOiBFbGVtZW50LFxyXG5cdCAgICAgICAgY29udGFpbkZvY3VzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHJvcGRvd25Qb3NpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnYm90dG9tIGxlZnQnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3Blbk9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdjbGljaycgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBkcm9wOiBudWxsLFxyXG5cdCAgICAgICAgICAgIGxhc3RGb2N1c3NlZEVsZW1lbnQ6IG51bGxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVEcm9wZG93bigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuZHJvcCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJvcC5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3AuZGVzdHJveSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1kcm9wZG93bjo6b3Blbic6IGZ1bmN0aW9uIHVpRHJvcGRvd25PcGVuKGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLm9wZW5Ecm9wZG93bigpO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICd1aS1kcm9wZG93bjo6Y2xvc2UnOiBmdW5jdGlvbiB1aURyb3Bkb3duQ2xvc2UoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICd1aS1kcm9wZG93bjo6dG9nZ2xlJzogZnVuY3Rpb24gdWlEcm9wZG93blRvZ2dsZShpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy50b2dnbGVEcm9wZG93bigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBpbml0aWFsaXplRHJvcGRvd246IGZ1bmN0aW9uIGluaXRpYWxpemVEcm9wZG93bigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3AgPSBuZXcgX3RldGhlckRyb3AyLmRlZmF1bHQoe1xyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMudHJpZ2dlcixcclxuXHQgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy4kZWxzLmRyb3Bkb3duLFxyXG5cdCAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5kcm9wZG93blBvc2l0aW9uLFxyXG5cdCAgICAgICAgICAgICAgICBjb25zdHJhaW5Ub1dpbmRvdzogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgb3Blbk9uOiB0aGlzLm9wZW5PblxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3Bkb3duUG9zaXRpb24gIT09ICdib3R0b20gbGVmdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLm9wZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5vcGVuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5jbG9zZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3Aub24oJ29wZW4nLCB0aGlzLnBvc2l0aW9uRHJvcCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wLm9uKCdvcGVuJywgdGhpcy5kcm9wZG93bk9wZW5lZCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wLm9uKCdjbG9zZScsIHRoaXMuZHJvcGRvd25DbG9zZWQpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW5Ecm9wZG93bjogZnVuY3Rpb24gb3BlbkRyb3Bkb3duKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcG9zaXRpb25Ecm9wOiBmdW5jdGlvbiBwb3NpdGlvbkRyb3AoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGRyb3AgPSB0aGlzLmRyb3A7XHJcblx0ICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIGRyb3BXaWR0aCA9IGRyb3AuZHJvcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGRyb3AudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XHJcblx0ICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVNwYWNlID0gd2luZG93V2lkdGggLSBsZWZ0O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChkcm9wV2lkdGggPiBhdmFpbGFibGVTcGFjZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZHJvcFdpZHRoID4gYXZhaWxhYmxlU3BhY2UgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBkcm9wLnRldGhlci5hdHRhY2htZW50LmxlZnQgPSBkaXJlY3Rpb247XHJcblx0ICAgICAgICAgICAgICAgIGRyb3AudGV0aGVyLnRhcmdldEF0dGFjaG1lbnQubGVmdCA9IGRpcmVjdGlvbjtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgZHJvcC5wb3NpdGlvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZURyb3Bkb3duOiBmdW5jdGlvbiBjbG9zZURyb3Bkb3duKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRvZ2dsZURyb3Bkb3duOiBmdW5jdGlvbiB0b2dnbGVEcm9wZG93bihlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZHJvcCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyb3AudG9nZ2xlKGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkcm9wZG93bk9wZW5lZDogZnVuY3Rpb24gZHJvcGRvd25PcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5hZGQodGhpcy50cmlnZ2VyLCAnZHJvcGRvd24tb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdEZvY3Vzc2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZWxzLmRyb3Bkb3duLmZvY3VzKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Ryb3Bkb3duLW9wZW5lZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRyb3Bkb3duQ2xvc2VkOiBmdW5jdGlvbiBkcm9wZG93bkNsb3NlZCgpIHtcclxuXHQgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LnJlbW92ZSh0aGlzLnRyaWdnZXIsICdkcm9wZG93bi1vcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubGFzdEZvY3Vzc2VkRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxhc3RGb2N1c3NlZEVsZW1lbnQuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Ryb3Bkb3duLWNsb3NlZCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIHRldGhlci1kcm9wIDEuNC4xICovXHJcblx0XHJcblx0KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHQgIGlmICh0cnVlKSB7XHJcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3RldGhlcicpKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJvb3QuRHJvcCA9IGZhY3Rvcnkocm9vdC5UZXRoZXIpO1xyXG5cdCAgfVxyXG5cdH0odGhpcywgZnVuY3Rpb24oVGV0aGVyKSB7XHJcblx0XHJcblx0LyogZ2xvYmFsIFRldGhlciAqL1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcclxuXHRcclxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcclxuXHRcclxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xyXG5cdFxyXG5cdHZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MiwgX3gzLCBfeDQpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gyLCBwcm9wZXJ0eSA9IF94MywgcmVjZWl2ZXIgPSBfeDQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gyID0gcGFyZW50OyBfeDMgPSBwcm9wZXJ0eTsgX3g0ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxyXG5cdFxyXG5cdHZhciBfVGV0aGVyJFV0aWxzID0gVGV0aGVyLlV0aWxzO1xyXG5cdHZhciBleHRlbmQgPSBfVGV0aGVyJFV0aWxzLmV4dGVuZDtcclxuXHR2YXIgYWRkQ2xhc3MgPSBfVGV0aGVyJFV0aWxzLmFkZENsYXNzO1xyXG5cdHZhciByZW1vdmVDbGFzcyA9IF9UZXRoZXIkVXRpbHMucmVtb3ZlQ2xhc3M7XHJcblx0dmFyIGhhc0NsYXNzID0gX1RldGhlciRVdGlscy5oYXNDbGFzcztcclxuXHR2YXIgRXZlbnRlZCA9IF9UZXRoZXIkVXRpbHMuRXZlbnRlZDtcclxuXHRcclxuXHRmdW5jdGlvbiBzb3J0QXR0YWNoKHN0cikge1xyXG5cdCAgdmFyIF9zdHIkc3BsaXQgPSBzdHIuc3BsaXQoJyAnKTtcclxuXHRcclxuXHQgIHZhciBfc3RyJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9zdHIkc3BsaXQsIDIpO1xyXG5cdFxyXG5cdCAgdmFyIGZpcnN0ID0gX3N0ciRzcGxpdDJbMF07XHJcblx0ICB2YXIgc2Vjb25kID0gX3N0ciRzcGxpdDJbMV07XHJcblx0XHJcblx0ICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihmaXJzdCkgPj0gMCkge1xyXG5cdCAgICB2YXIgX3JlZiA9IFtzZWNvbmQsIGZpcnN0XTtcclxuXHQgICAgZmlyc3QgPSBfcmVmWzBdO1xyXG5cdCAgICBzZWNvbmQgPSBfcmVmWzFdO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIFtmaXJzdCwgc2Vjb25kXS5qb2luKCcgJyk7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIGl0ZW0pIHtcclxuXHQgIHZhciBpbmRleCA9IHVuZGVmaW5lZDtcclxuXHQgIHZhciByZXN1bHRzID0gW107XHJcblx0ICB3aGlsZSAoKGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSkpICE9PSAtMSkge1xyXG5cdCAgICByZXN1bHRzLnB1c2goYXJyLnNwbGljZShpbmRleCwgMSkpO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHJlc3VsdHM7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBjbGlja0V2ZW50cyA9IFsnY2xpY2snXTtcclxuXHRpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcblx0ICBjbGlja0V2ZW50cy5wdXNoKCd0b3VjaHN0YXJ0Jyk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciB0cmFuc2l0aW9uRW5kRXZlbnRzID0ge1xyXG5cdCAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXHJcblx0ICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcclxuXHQgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCcsXHJcblx0ICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICcnO1xyXG5cdGZvciAodmFyIF9uYW1lIGluIHRyYW5zaXRpb25FbmRFdmVudHMpIHtcclxuXHQgIGlmICgoe30pLmhhc093blByb3BlcnR5LmNhbGwodHJhbnNpdGlvbkVuZEV2ZW50cywgX25hbWUpKSB7XHJcblx0ICAgIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcblx0ICAgIGlmICh0eXBlb2YgdGVtcEVsLnN0eWxlW19uYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSB0cmFuc2l0aW9uRW5kRXZlbnRzW19uYW1lXTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHR2YXIgTUlSUk9SX0FUVEFDSCA9IHtcclxuXHQgIGxlZnQ6ICdyaWdodCcsXHJcblx0ICByaWdodDogJ2xlZnQnLFxyXG5cdCAgdG9wOiAnYm90dG9tJyxcclxuXHQgIGJvdHRvbTogJ3RvcCcsXHJcblx0ICBtaWRkbGU6ICdtaWRkbGUnLFxyXG5cdCAgY2VudGVyOiAnY2VudGVyJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGFsbERyb3BzID0ge307XHJcblx0XHJcblx0Ly8gRHJvcCBjYW4gYmUgaW5jbHVkZWQgaW4gZXh0ZXJuYWwgbGlicmFyaWVzLiAgQ2FsbGluZyBjcmVhdGVDb250ZXh0IGdpdmVzIHlvdSBhIGZyZXNoXHJcblx0Ly8gY29weSBvZiBkcm9wIHdoaWNoIHdvbid0IGludGVyYWN0IHdpdGggb3RoZXIgY29waWVzIG9uIHRoZSBwYWdlIChiZXlvbmQgY2FsbGluZyB0aGUgZG9jdW1lbnQgZXZlbnRzKS5cclxuXHRcclxuXHRmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xyXG5cdCAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcclxuXHRcclxuXHQgIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcCgpIHtcclxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBuZXcgKF9iaW5kLmFwcGx5KERyb3BJbnN0YW5jZSwgW251bGxdLmNvbmNhdChhcmdzKSkpKCk7XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgZXh0ZW5kKGRyb3AsIHtcclxuXHQgICAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcclxuXHQgICAgZHJvcHM6IFtdLFxyXG5cdCAgICBkZWZhdWx0czoge31cclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG5cdCAgICBjbGFzc1ByZWZpeDogJ2Ryb3AnLFxyXG5cdCAgICBkZWZhdWx0czoge1xyXG5cdCAgICAgIHBvc2l0aW9uOiAnYm90dG9tIGxlZnQnLFxyXG5cdCAgICAgIG9wZW5PbjogJ2NsaWNrJyxcclxuXHQgICAgICBiZWZvcmVDbG9zZTogbnVsbCxcclxuXHQgICAgICBjb25zdHJhaW5Ub1Njcm9sbFBhcmVudDogdHJ1ZSxcclxuXHQgICAgICBjb25zdHJhaW5Ub1dpbmRvdzogdHJ1ZSxcclxuXHQgICAgICBjbGFzc2VzOiAnJyxcclxuXHQgICAgICByZW1vdmU6IGZhbHNlLFxyXG5cdCAgICAgIG9wZW5EZWxheTogMCxcclxuXHQgICAgICBjbG9zZURlbGF5OiA1MCxcclxuXHQgICAgICAvLyBpbmhlcml0ZWQgZnJvbSBvcGVuRGVsYXkgYW5kIGNsb3NlRGVsYXkgaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG5cdCAgICAgIGZvY3VzRGVsYXk6IG51bGwsXHJcblx0ICAgICAgYmx1ckRlbGF5OiBudWxsLFxyXG5cdCAgICAgIGhvdmVyT3BlbkRlbGF5OiBudWxsLFxyXG5cdCAgICAgIGhvdmVyQ2xvc2VEZWxheTogbnVsbCxcclxuXHQgICAgICB0ZXRoZXJPcHRpb25zOiB7fVxyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgZXh0ZW5kKGRyb3AsIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuXHQgIGV4dGVuZChkcm9wLmRlZmF1bHRzLCBkZWZhdWx0T3B0aW9ucy5kZWZhdWx0cywgb3B0aW9ucy5kZWZhdWx0cyk7XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIGFsbERyb3BzW2Ryb3AuY2xhc3NQcmVmaXhdID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBhbGxEcm9wc1tkcm9wLmNsYXNzUHJlZml4XSA9IFtdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgZHJvcC51cGRhdGVCb2R5Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgYm9keSwgc28gZGVzcGl0ZSB0aGUgY29udGV4dCBjb25jZXB0LCB3ZSBzdGlsbCBpdGVyYXRlIHRocm91Z2ggYWxsXHJcblx0ICAgIC8vIGRyb3BzIHdoaWNoIHNoYXJlIG91ciBjbGFzc1ByZWZpeC5cclxuXHRcclxuXHQgICAgdmFyIGFueU9wZW4gPSBmYWxzZTtcclxuXHQgICAgdmFyIGRyb3BzID0gYWxsRHJvcHNbZHJvcC5jbGFzc1ByZWZpeF07XHJcblx0ICAgIHZhciBsZW4gPSBkcm9wcy5sZW5ndGg7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICBpZiAoZHJvcHNbaV0uaXNPcGVuZWQoKSkge1xyXG5cdCAgICAgICAgYW55T3BlbiA9IHRydWU7XHJcblx0ICAgICAgICBicmVhaztcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKGFueU9wZW4pIHtcclxuXHQgICAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgdmFyIERyb3BJbnN0YW5jZSA9IChmdW5jdGlvbiAoX0V2ZW50ZWQpIHtcclxuXHQgICAgX2luaGVyaXRzKERyb3BJbnN0YW5jZSwgX0V2ZW50ZWQpO1xyXG5cdFxyXG5cdCAgICBmdW5jdGlvbiBEcm9wSW5zdGFuY2Uob3B0cykge1xyXG5cdCAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wSW5zdGFuY2UpO1xyXG5cdFxyXG5cdCAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3BJbnN0YW5jZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZHJvcC5kZWZhdWx0cywgb3B0cyk7XHJcblx0ICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0O1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ryb3AgRXJyb3I6IFlvdSBtdXN0IHByb3ZpZGUgYSB0YXJnZXQuJyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBkYXRhUHJlZml4ID0gJ2RhdGEtJyArIGRyb3AuY2xhc3NQcmVmaXg7XHJcblx0XHJcblx0ICAgICAgdmFyIGNvbnRlbnRBdHRyID0gdGhpcy50YXJnZXQuZ2V0QXR0cmlidXRlKGRhdGFQcmVmaXgpO1xyXG5cdCAgICAgIGlmIChjb250ZW50QXR0ciAmJiB0aGlzLm9wdGlvbnMuY29udGVudCA9PSBudWxsKSB7XHJcblx0ICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudCA9IGNvbnRlbnRBdHRyO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgYXR0cnNPdmVycmlkZSA9IFsncG9zaXRpb24nLCAnb3Blbk9uJ107XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyc092ZXJyaWRlLmxlbmd0aDsgKytpKSB7XHJcblx0XHJcblx0ICAgICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLnRhcmdldC5nZXRBdHRyaWJ1dGUoZGF0YVByZWZpeCArICctJyArIGF0dHJzT3ZlcnJpZGVbaV0pO1xyXG5cdCAgICAgICAgaWYgKG92ZXJyaWRlICYmIHRoaXMub3B0aW9uc1thdHRyc092ZXJyaWRlW2ldXSA9PSBudWxsKSB7XHJcblx0ICAgICAgICAgIHRoaXMub3B0aW9uc1thdHRyc092ZXJyaWRlW2ldXSA9IG92ZXJyaWRlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmNsYXNzZXMgJiYgdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5vcHRpb25zLmNsYXNzZXMpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBkcm9wLmRyb3BzLnB1c2godGhpcyk7XHJcblx0ICAgICAgYWxsRHJvcHNbZHJvcC5jbGFzc1ByZWZpeF0ucHVzaCh0aGlzKTtcclxuXHRcclxuXHQgICAgICB0aGlzLl9ib3VuZEV2ZW50cyA9IFtdO1xyXG5cdCAgICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcclxuXHQgICAgICB0aGlzLnNldHVwRWxlbWVudHMoKTtcclxuXHQgICAgICB0aGlzLnNldHVwRXZlbnRzKCk7XHJcblx0ICAgICAgdGhpcy5zZXR1cFRldGhlcigpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIF9jcmVhdGVDbGFzcyhEcm9wSW5zdGFuY2UsIFt7XHJcblx0ICAgICAga2V5OiAnX29uJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XHJcblx0ICAgICAgICB0aGlzLl9ib3VuZEV2ZW50cy5wdXNoKHsgZWxlbWVudDogZWxlbWVudCwgZXZlbnQ6IGV2ZW50LCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xyXG5cdCAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0sIHtcclxuXHQgICAgICBrZXk6ICdiaW5kTWV0aG9kcycsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRNZXRob2RzKCkge1xyXG5cdCAgICAgICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlciA9IHRoaXMuX3RyYW5zaXRpb25FbmRIYW5kbGVyLmJpbmQodGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnc2V0dXBFbGVtZW50cycsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwRWxlbWVudHMoKSB7XHJcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5kcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXgpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGFzc2VzKSB7XHJcblx0ICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJvcCwgdGhpcy5vcHRpb25zLmNsYXNzZXMpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmNvbnRlbnQsIGRyb3AuY2xhc3NQcmVmaXggKyAnLWNvbnRlbnQnKTtcclxuXHRcclxuXHQgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgdmFyIGdlbmVyYXRlQW5kU2V0Q29udGVudCA9IGZ1bmN0aW9uIGdlbmVyYXRlQW5kU2V0Q29udGVudCgpIHtcclxuXHQgICAgICAgICAgICAvLyBjb250ZW50IGZ1bmN0aW9uIG1pZ2h0IHJldHVybiBhIHN0cmluZyBvciBhbiBlbGVtZW50XHJcblx0ICAgICAgICAgICAgdmFyIGNvbnRlbnRFbGVtZW50T3JIVE1MID0gX3RoaXMub3B0aW9ucy5jb250ZW50LmNhbGwoX3RoaXMsIF90aGlzKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRFbGVtZW50T3JIVE1MID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSBjb250ZW50RWxlbWVudE9ySFRNTDtcclxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZW50RWxlbWVudE9ySFRNTCA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICAgICAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XHJcblx0ICAgICAgICAgICAgICBfdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnRFbGVtZW50T3JIVE1MKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wIEVycm9yOiBDb250ZW50IGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgb3IgSFRNTEVsZW1lbnQuJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICBnZW5lcmF0ZUFuZFNldENvbnRlbnQoKTtcclxuXHQgICAgICAgICAgdGhpcy5vbignb3BlbicsIGdlbmVyYXRlQW5kU2V0Q29udGVudC5iaW5kKHRoaXMpKTtcclxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb250ZW50ID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5vcHRpb25zLmNvbnRlbnQpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5kcm9wLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnc2V0dXBUZXRoZXInLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFRldGhlcigpIHtcclxuXHQgICAgICAgIC8vIFRldGhlciBleHBlY3RzIHR3byBhdHRhY2htZW50IHBvaW50cywgb25lIGluIHRoZSB0YXJnZXQgZWxlbWVudCwgb25lIGluIHRoZVxyXG5cdCAgICAgICAgLy8gZHJvcC4gIFdlIHVzZSBhIHNpbmdsZSBvbmUsIGFuZCB1c2UgdGhlIG9yZGVyIGFzIHdlbGwsIHRvIGFsbG93IHVzIHRvIHB1dFxyXG5cdCAgICAgICAgLy8gdGhlIGRyb3Agb24gZWl0aGVyIHNpZGUgb2YgYW55IG9mIHRoZSBmb3VyIGNvcm5lcnMuICBUaGlzIG1hZ2ljIGNvbnZlcnRzIGJldHdlZW5cclxuXHQgICAgICAgIC8vIHRoZSB0d286XHJcblx0ICAgICAgICB2YXIgZHJvcEF0dGFjaCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbi5zcGxpdCgnICcpO1xyXG5cdCAgICAgICAgZHJvcEF0dGFjaFswXSA9IE1JUlJPUl9BVFRBQ0hbZHJvcEF0dGFjaFswXV07XHJcblx0ICAgICAgICBkcm9wQXR0YWNoID0gZHJvcEF0dGFjaC5qb2luKCcgJyk7XHJcblx0XHJcblx0ICAgICAgICB2YXIgY29uc3RyYWludHMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWluVG9TY3JvbGxQYXJlbnQpIHtcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICdzY3JvbGxQYXJlbnQnLFxyXG5cdCAgICAgICAgICAgIHBpbjogJ3RvcCwgYm90dG9tJyxcclxuXHQgICAgICAgICAgICBhdHRhY2htZW50OiAndG9nZXRoZXIgbm9uZSdcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAvLyBUbyBnZXQgJ291dCBvZiBib3VuZHMnIGNsYXNzZXNcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICdzY3JvbGxQYXJlbnQnXHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW5Ub1dpbmRvdyAhPT0gZmFsc2UpIHtcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICd3aW5kb3cnLFxyXG5cdCAgICAgICAgICAgIGF0dGFjaG1lbnQ6ICd0b2dldGhlcidcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAvLyBUbyBnZXQgJ291dCBvZiBib3VuZHMnIGNsYXNzZXNcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICd3aW5kb3cnXHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFyIG9wdHMgPSB7XHJcblx0ICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZHJvcCxcclxuXHQgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcclxuXHQgICAgICAgICAgYXR0YWNobWVudDogc29ydEF0dGFjaChkcm9wQXR0YWNoKSxcclxuXHQgICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogc29ydEF0dGFjaCh0aGlzLm9wdGlvbnMucG9zaXRpb24pLFxyXG5cdCAgICAgICAgICBjbGFzc1ByZWZpeDogZHJvcC5jbGFzc1ByZWZpeCxcclxuXHQgICAgICAgICAgb2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgICAgdGFyZ2V0T2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcblx0ICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyxcclxuXHQgICAgICAgICAgYWRkVGFyZ2V0Q2xhc3NlczogdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXNcclxuXHQgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRldGhlck9wdGlvbnMgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgIHRoaXMudGV0aGVyID0gbmV3IFRldGhlcihleHRlbmQoe30sIG9wdHMsIHRoaXMub3B0aW9ucy50ZXRoZXJPcHRpb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnc2V0dXBFdmVudHMnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEV2ZW50cygpIHtcclxuXHQgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3Blbk9uKSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3Blbk9uID09PSAnYWx3YXlzJykge1xyXG5cdCAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMub3Blbi5iaW5kKHRoaXMpKTtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMub3B0aW9ucy5vcGVuT24uc3BsaXQoJyAnKTtcclxuXHRcclxuXHQgICAgICAgIGlmIChldmVudHMuaW5kZXhPZignY2xpY2snKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHZhciBvcGVuSGFuZGxlciA9IGZ1bmN0aW9uIG9wZW5IYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICAgICAgX3RoaXMyLnRvZ2dsZShldmVudCk7XHJcblx0ICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIGNsb3NlSGFuZGxlciA9IGZ1bmN0aW9uIGNsb3NlSGFuZGxlcihldmVudCkge1xyXG5cdCAgICAgICAgICAgIGlmICghX3RoaXMyLmlzT3BlbmVkKCkpIHtcclxuXHQgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgLy8gQ2xpY2tpbmcgaW5zaWRlIGRyb3Bkb3duXHJcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMyLmRyb3AgfHwgX3RoaXMyLmRyb3AuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICAvLyBDbGlja2luZyB0YXJnZXRcclxuXHQgICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBfdGhpczIudGFyZ2V0IHx8IF90aGlzMi50YXJnZXQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBfdGhpczIuY2xvc2UoZXZlbnQpO1xyXG5cdCAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaWNrRXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBjbGlja0V2ZW50c1tpXTtcclxuXHQgICAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgY2xpY2tFdmVudCwgb3BlbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuX29uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBjbG9zZUhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB2YXIgaW5UaW1lb3V0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBvdXRUaW1lb3V0ID0gbnVsbDtcclxuXHRcclxuXHQgICAgICAgIHZhciBpbkhhbmRsZXIgPSBmdW5jdGlvbiBpbkhhbmRsZXIoZXZlbnQpIHtcclxuXHQgICAgICAgICAgaWYgKG91dFRpbWVvdXQgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQob3V0VGltZW91dCk7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgaW5UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICBfdGhpczIub3BlbihldmVudCk7XHJcblx0ICAgICAgICAgICAgICBpblRpbWVvdXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIH0sIChldmVudC50eXBlID09PSAnZm9jdXMnID8gX3RoaXMyLm9wdGlvbnMuZm9jdXNEZWxheSA6IF90aGlzMi5vcHRpb25zLmhvdmVyT3BlbkRlbGF5KSB8fCBfdGhpczIub3B0aW9ucy5vcGVuRGVsYXkpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIG91dEhhbmRsZXIgPSBmdW5jdGlvbiBvdXRIYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICAgIGlmIChpblRpbWVvdXQgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5UaW1lb3V0KTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBvdXRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICBfdGhpczIuY2xvc2UoZXZlbnQpO1xyXG5cdCAgICAgICAgICAgICAgb3V0VGltZW91dCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgfSwgKGV2ZW50LnR5cGUgPT09ICdibHVyJyA/IF90aGlzMi5vcHRpb25zLmJsdXJEZWxheSA6IF90aGlzMi5vcHRpb25zLmhvdmVyQ2xvc2VEZWxheSkgfHwgX3RoaXMyLm9wdGlvbnMuY2xvc2VEZWxheSk7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICBpZiAoZXZlbnRzLmluZGV4T2YoJ2hvdmVyJykgPj0gMCkge1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgJ21vdXNlb3ZlcicsIGluSGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMuZHJvcCwgJ21vdXNlb3ZlcicsIGluSGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMudGFyZ2V0LCAnbW91c2VvdXQnLCBvdXRIYW5kbGVyKTtcclxuXHQgICAgICAgICAgdGhpcy5fb24odGhpcy5kcm9wLCAnbW91c2VvdXQnLCBvdXRIYW5kbGVyKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChldmVudHMuaW5kZXhPZignZm9jdXMnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMudGFyZ2V0LCAnZm9jdXMnLCBpbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLmRyb3AsICdmb2N1cycsIGluSGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMudGFyZ2V0LCAnYmx1cicsIG91dEhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLmRyb3AsICdibHVyJywgb3V0SGFuZGxlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnaXNPcGVuZWQnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW5lZCgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3RvZ2dsZScsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaXNPcGVuZWQoKSkge1xyXG5cdCAgICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHRoaXMub3BlbihldmVudCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnb3BlbicsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oZXZlbnQpIHtcclxuXHQgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiAwICovXHJcblx0ICAgICAgICBpZiAodGhpcy5pc09wZW5lZCgpKSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5kcm9wLnBhcmVudE5vZGUpIHtcclxuXHQgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyb3ApO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIuZW5hYmxlKCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLW9wZW4nKTtcclxuXHQgICAgICAgIGFkZENsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3Blbi10cmFuc2l0aW9uZW5kJyk7XHJcblx0XHJcblx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgaWYgKF90aGlzMy5kcm9wKSB7XHJcblx0ICAgICAgICAgICAgYWRkQ2xhc3MoX3RoaXMzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLWFmdGVyLW9wZW4nKTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMudGV0aGVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlci5wb3NpdGlvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdGhpcy50cmlnZ2VyKCdvcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICBkcm9wLnVwZGF0ZUJvZHlDbGFzc2VzKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnX3RyYW5zaXRpb25FbmRIYW5kbGVyJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25FbmRIYW5kbGVyKGUpIHtcclxuXHQgICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICghaGFzQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJykpIHtcclxuXHQgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuLXRyYW5zaXRpb25lbmQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZHJvcC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcik7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnYmVmb3JlQ2xvc2VIYW5kbGVyJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlQ2xvc2VIYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICB2YXIgc2hvdWxkQ2xvc2UgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2luZyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmJlZm9yZUNsb3NlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgIHRoaXMuaXNDbG9zaW5nID0gdHJ1ZTtcclxuXHQgICAgICAgICAgc2hvdWxkQ2xvc2UgPSB0aGlzLm9wdGlvbnMuYmVmb3JlQ2xvc2UoZXZlbnQsIHRoaXMpICE9PSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuaXNDbG9zaW5nID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gc2hvdWxkQ2xvc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnY2xvc2UnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShldmVudCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzT3BlbmVkKCkpIHtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmJlZm9yZUNsb3NlSGFuZGxlcihldmVudCkpIHtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJyk7XHJcblx0ICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLWFmdGVyLW9wZW4nKTtcclxuXHRcclxuXHQgICAgICAgIHRoaXMuZHJvcC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcik7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLnRyaWdnZXIoJ2Nsb3NlJyk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMudGV0aGVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlci5kaXNhYmxlKCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBkcm9wLnVwZGF0ZUJvZHlDbGFzc2VzKCk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZSkge1xyXG5cdCAgICAgICAgICB0aGlzLnJlbW92ZShldmVudCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAncmVtb3ZlJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50KSB7XHJcblx0ICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyb3AucGFyZW50Tm9kZSkge1xyXG5cdCAgICAgICAgICB0aGlzLmRyb3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRyb3ApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3Bvc2l0aW9uJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5pc09wZW5lZCgpICYmIHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIucG9zaXRpb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH0sIHtcclxuXHQgICAgICBrZXk6ICdkZXN0cm95JyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuXHQgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMudGV0aGVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlci5kZXN0cm95KCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2JvdW5kRXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgIHZhciBfYm91bmRFdmVudHMkaSA9IHRoaXMuX2JvdW5kRXZlbnRzW2ldO1xyXG5cdCAgICAgICAgICB2YXIgZWxlbWVudCA9IF9ib3VuZEV2ZW50cyRpLmVsZW1lbnQ7XHJcblx0ICAgICAgICAgIHZhciBfZXZlbnQgPSBfYm91bmRFdmVudHMkaS5ldmVudDtcclxuXHQgICAgICAgICAgdmFyIGhhbmRsZXIgPSBfYm91bmRFdmVudHMkaS5oYW5kbGVyO1xyXG5cdFxyXG5cdCAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoX2V2ZW50LCBoYW5kbGVyKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuX2JvdW5kRXZlbnRzID0gW107XHJcblx0XHJcblx0ICAgICAgICB0aGlzLnRldGhlciA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmRyb3AgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuXHRcclxuXHQgICAgICAgIHJlbW92ZUZyb21BcnJheShhbGxEcm9wc1tkcm9wLmNsYXNzUHJlZml4XSwgdGhpcyk7XHJcblx0ICAgICAgICByZW1vdmVGcm9tQXJyYXkoZHJvcC5kcm9wcywgdGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XSk7XHJcblx0XHJcblx0ICAgIHJldHVybiBEcm9wSW5zdGFuY2U7XHJcblx0ICB9KShFdmVudGVkKTtcclxuXHRcclxuXHQgIHJldHVybiBkcm9wO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgRHJvcCA9IGNyZWF0ZUNvbnRleHQoKTtcclxuXHRcclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgRHJvcC51cGRhdGVCb2R5Q2xhc3NlcygpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBEcm9wO1xyXG5cdFxyXG5cdH0pKTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIHRldGhlciAxLjIuMCAqL1xyXG5cdFxyXG5cdChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0ICBpZiAodHJ1ZSkge1xyXG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcm9vdC5UZXRoZXIgPSBmYWN0b3J5KCk7XHJcblx0ICB9XHJcblx0fSh0aGlzLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHR2YXIgVGV0aGVyQmFzZSA9IHVuZGVmaW5lZDtcclxuXHRpZiAodHlwZW9mIFRldGhlckJhc2UgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICBUZXRoZXJCYXNlID0geyBtb2R1bGVzOiBbXSB9O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWwpIHtcclxuXHQgIC8vIEluIGZpcmVmb3ggaWYgdGhlIGVsIGlzIGluc2lkZSBhbiBpZnJhbWUgd2l0aCBkaXNwbGF5OiBub25lOyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgpIHdpbGwgcmV0dXJuIG51bGw7XHJcblx0ICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcclxuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkgfHwge307XHJcblx0ICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xyXG5cdFxyXG5cdCAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnKSB7XHJcblx0ICAgIHJldHVybiBlbDtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBwYXJlbnQgPSBlbDtcclxuXHQgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xyXG5cdCAgICB2YXIgc3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0ICAgIHRyeSB7XHJcblx0ICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XHJcblx0ICAgIH0gY2F0Y2ggKGVycikge31cclxuXHRcclxuXHQgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGUgPT09IG51bGwpIHtcclxuXHQgICAgICByZXR1cm4gcGFyZW50O1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBfc3R5bGUgPSBzdHlsZTtcclxuXHQgICAgdmFyIG92ZXJmbG93ID0gX3N0eWxlLm92ZXJmbG93O1xyXG5cdCAgICB2YXIgb3ZlcmZsb3dYID0gX3N0eWxlLm92ZXJmbG93WDtcclxuXHQgICAgdmFyIG92ZXJmbG93WSA9IF9zdHlsZS5vdmVyZmxvd1k7XHJcblx0XHJcblx0ICAgIGlmICgvKGF1dG98c2Nyb2xsKS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcclxuXHQgICAgICBpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgfHwgWydyZWxhdGl2ZScsICdhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2Yoc3R5bGUucG9zaXRpb24pID49IDApIHtcclxuXHQgICAgICAgIHJldHVybiBwYXJlbnQ7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gZG9jdW1lbnQuYm9keTtcclxuXHR9XHJcblx0XHJcblx0dmFyIHVuaXF1ZUlkID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIHZhciBpZCA9IDA7XHJcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdCAgICByZXR1cm4gKytpZDtcclxuXHQgIH07XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgemVyb1Bvc0NhY2hlID0ge307XHJcblx0dmFyIGdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbihkb2MpIHtcclxuXHQgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB1bmZvcnR1bmF0ZWx5IHRvbyBhY2N1cmF0ZS4gIEl0IGludHJvZHVjZXMgYSBwaXhlbCBvciB0d28gb2ZcclxuXHQgIC8vIGppdHRlciBhcyB0aGUgdXNlciBzY3JvbGxzIHRoYXQgbWVzc2VzIHdpdGggb3VyIGFiaWxpdHkgdG8gZGV0ZWN0IGlmIHR3byBwb3NpdGlvbnNcclxuXHQgIC8vIGFyZSBlcXVpdmlsYW50IG9yIG5vdC4gIFdlIHBsYWNlIGFuIGVsZW1lbnQgYXQgdGhlIHRvcCBsZWZ0IG9mIHRoZSBwYWdlIHRoYXQgd2lsbFxyXG5cdCAgLy8gZ2V0IHRoZSBzYW1lIGppdHRlciwgc28gd2UgY2FuIGNhbmNlbCB0aGUgdHdvIG91dC5cclxuXHQgIHZhciBub2RlID0gZG9jLl90ZXRoZXJaZXJvRWxlbWVudDtcclxuXHQgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgbm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHQgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGV0aGVyLWlkJywgdW5pcXVlSWQoKSk7XHJcblx0ICAgIGV4dGVuZChub2RlLnN0eWxlLCB7XHJcblx0ICAgICAgdG9wOiAwLFxyXG5cdCAgICAgIGxlZnQ6IDAsXHJcblx0ICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xyXG5cdFxyXG5cdCAgICBkb2MuX3RldGhlclplcm9FbGVtZW50ID0gbm9kZTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRldGhlci1pZCcpO1xyXG5cdCAgaWYgKHR5cGVvZiB6ZXJvUG9zQ2FjaGVbaWRdID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICB6ZXJvUG9zQ2FjaGVbaWRdID0ge307XHJcblx0XHJcblx0ICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHQgICAgZm9yICh2YXIgayBpbiByZWN0KSB7XHJcblx0ICAgICAgLy8gQ2FuJ3QgdXNlIGV4dGVuZCwgYXMgb24gSUU5LCBlbGVtZW50cyBkb24ndCByZXNvbHZlIHRvIGJlIGhhc093blByb3BlcnR5XHJcblx0ICAgICAgemVyb1Bvc0NhY2hlW2lkXVtrXSA9IHJlY3Rba107XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgLy8gQ2xlYXIgdGhlIGNhY2hlIHdoZW4gdGhpcyBwb3NpdGlvbiBjYWxsIGlzIGRvbmVcclxuXHQgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIGRlbGV0ZSB6ZXJvUG9zQ2FjaGVbaWRdO1xyXG5cdCAgICB9KTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB6ZXJvUG9zQ2FjaGVbaWRdO1xyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0Qm91bmRzKGVsKSB7XHJcblx0ICB2YXIgZG9jID0gdW5kZWZpbmVkO1xyXG5cdCAgaWYgKGVsID09PSBkb2N1bWVudCkge1xyXG5cdCAgICBkb2MgPSBkb2N1bWVudDtcclxuXHQgICAgZWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcclxuXHQgIHZhciBib3ggPSB7fTtcclxuXHQgIC8vIFRoZSBvcmlnaW5hbCBvYmplY3QgcmV0dXJuZWQgYnkgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGltbXV0YWJsZSwgc28gd2UgY2xvbmUgaXRcclxuXHQgIC8vIFdlIGNhbid0IHVzZSBleHRlbmQgYmVjYXVzZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgb2JqZWN0IGJ5IGhhc093blByb3BlcnR5IGluIElFOVxyXG5cdCAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHQgIGZvciAodmFyIGsgaW4gcmVjdCkge1xyXG5cdCAgICBib3hba10gPSByZWN0W2tdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbihkb2MpO1xyXG5cdFxyXG5cdCAgYm94LnRvcCAtPSBvcmlnaW4udG9wO1xyXG5cdCAgYm94LmxlZnQgLT0gb3JpZ2luLmxlZnQ7XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIGJveC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgYm94LndpZHRoID0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCAtIGJveC5sZWZ0IC0gYm94LnJpZ2h0O1xyXG5cdCAgfVxyXG5cdCAgaWYgKHR5cGVvZiBib3guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBib3guaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSBib3gudG9wIC0gYm94LmJvdHRvbTtcclxuXHQgIH1cclxuXHRcclxuXHQgIGJveC50b3AgPSBib3gudG9wIC0gZG9jRWwuY2xpZW50VG9wO1xyXG5cdCAgYm94LmxlZnQgPSBib3gubGVmdCAtIGRvY0VsLmNsaWVudExlZnQ7XHJcblx0ICBib3gucmlnaHQgPSBkb2MuYm9keS5jbGllbnRXaWR0aCAtIGJveC53aWR0aCAtIGJveC5sZWZ0O1xyXG5cdCAgYm94LmJvdHRvbSA9IGRvYy5ib2R5LmNsaWVudEhlaWdodCAtIGJveC5oZWlnaHQgLSBib3gudG9wO1xyXG5cdFxyXG5cdCAgcmV0dXJuIGJveDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsKSB7XHJcblx0ICByZXR1cm4gZWwub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0U2Nyb2xsQmFyU2l6ZSgpIHtcclxuXHQgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblx0ICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xyXG5cdFxyXG5cdCAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICBleHRlbmQob3V0ZXIuc3R5bGUsIHtcclxuXHQgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcblx0ICAgIHRvcDogMCxcclxuXHQgICAgbGVmdDogMCxcclxuXHQgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxyXG5cdCAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcclxuXHQgICAgd2lkdGg6ICcyMDBweCcsXHJcblx0ICAgIGhlaWdodDogJzE1MHB4JyxcclxuXHQgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcblx0ICB9KTtcclxuXHRcclxuXHQgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcclxuXHRcclxuXHQgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xyXG5cdFxyXG5cdCAgdmFyIHdpZHRoQ29udGFpbmVkID0gaW5uZXIub2Zmc2V0V2lkdGg7XHJcblx0ICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xyXG5cdCAgdmFyIHdpZHRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XHJcblx0XHJcblx0ICBpZiAod2lkdGhDb250YWluZWQgPT09IHdpZHRoU2Nyb2xsKSB7XHJcblx0ICAgIHdpZHRoU2Nyb2xsID0gb3V0ZXIuY2xpZW50V2lkdGg7XHJcblx0ICB9XHJcblx0XHJcblx0ICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcclxuXHRcclxuXHQgIHZhciB3aWR0aCA9IHdpZHRoQ29udGFpbmVkIC0gd2lkdGhTY3JvbGw7XHJcblx0XHJcblx0ICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogd2lkdGggfTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG5cdCAgdmFyIG91dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xyXG5cdFxyXG5cdCAgdmFyIGFyZ3MgPSBbXTtcclxuXHRcclxuXHQgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XHJcblx0XHJcblx0ICBhcmdzLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG5cdCAgICBpZiAob2JqKSB7XHJcblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG5cdCAgICAgICAgaWYgKCh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuXHQgICAgICAgICAgb3V0W2tleV0gPSBvYmpba2V5XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIG91dDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHQgIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcblx0ICAgICAgaWYgKGNscy50cmltKCkpIHtcclxuXHQgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoIHwkKScsICdnaScpO1xyXG5cdCAgICB2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKGVsKS5yZXBsYWNlKHJlZ2V4LCAnICcpO1xyXG5cdCAgICBzZXRDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSk7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0ICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICAgIGlmIChjbHMudHJpbSgpKSB7XHJcblx0ICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcclxuXHQgICAgdmFyIGNscyA9IGdldENsYXNzTmFtZShlbCkgKyAoJyAnICsgbmFtZSk7XHJcblx0ICAgIHNldENsYXNzTmFtZShlbCwgY2xzKTtcclxuXHQgIH1cclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHQgIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdCAgfVxyXG5cdCAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCk7XHJcblx0ICByZXR1cm4gbmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZSArICcoIHwkKScsICdnaScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGVsKSB7XHJcblx0ICBpZiAoZWwuY2xhc3NOYW1lIGluc3RhbmNlb2YgU1ZHQW5pbWF0ZWRTdHJpbmcpIHtcclxuXHQgICAgcmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpIHtcclxuXHQgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKGVsLCBhZGQsIGFsbCkge1xyXG5cdCAgLy8gT2YgdGhlIHNldCBvZiAnYWxsJyBjbGFzc2VzLCB3ZSBuZWVkIHRoZSAnYWRkJyBjbGFzc2VzLCBhbmQgb25seSB0aGVcclxuXHQgIC8vICdhZGQnIGNsYXNzZXMgdG8gYmUgc2V0LlxyXG5cdCAgYWxsLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICBpZiAoYWRkLmluZGV4T2YoY2xzKSA9PT0gLTEgJiYgaGFzQ2xhc3MoZWwsIGNscykpIHtcclxuXHQgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0XHJcblx0ICBhZGQuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcblx0ICAgIGlmICghaGFzQ2xhc3MoZWwsIGNscykpIHtcclxuXHQgICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBkZWZlcnJlZCA9IFtdO1xyXG5cdFxyXG5cdHZhciBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGZuKSB7XHJcblx0ICBkZWZlcnJlZC5wdXNoKGZuKTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xyXG5cdCAgdmFyIGZuID0gdW5kZWZpbmVkO1xyXG5cdCAgd2hpbGUgKGZuID0gZGVmZXJyZWQucG9wKCkpIHtcclxuXHQgICAgZm4oKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdHZhciBFdmVudGVkID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIGZ1bmN0aW9uIEV2ZW50ZWQoKSB7XHJcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudGVkKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIF9jcmVhdGVDbGFzcyhFdmVudGVkLCBbe1xyXG5cdCAgICBrZXk6ICdvbicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgY3R4KSB7XHJcblx0ICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5nc1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlcjogaGFuZGxlciwgY3R4OiBjdHgsIG9uY2U6IG9uY2UgfSk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnb25jZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcclxuXHQgICAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIHRydWUpO1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ29mZicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLmJpbmRpbmdzW2V2ZW50XSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHJldHVybjtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbZXZlbnRdO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB2YXIgaSA9IDA7XHJcblx0ICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYmluZGluZ3NbZXZlbnRdLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tldmVudF1baV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICArK2k7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAndHJpZ2dlcicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50KSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmJpbmRpbmdzW2V2ZW50XSkge1xyXG5cdCAgICAgICAgdmFyIGkgPSAwO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcblx0ICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgdmFyIF9iaW5kaW5ncyRldmVudCRpID0gdGhpcy5iaW5kaW5nc1tldmVudF1baV07XHJcblx0ICAgICAgICAgIHZhciBoYW5kbGVyID0gX2JpbmRpbmdzJGV2ZW50JGkuaGFuZGxlcjtcclxuXHQgICAgICAgICAgdmFyIGN0eCA9IF9iaW5kaW5ncyRldmVudCRpLmN0eDtcclxuXHQgICAgICAgICAgdmFyIG9uY2UgPSBfYmluZGluZ3MkZXZlbnQkaS5vbmNlO1xyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgY29udGV4dCA9IGN0eDtcclxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHJcblx0ICAgICAgICAgIGlmIChvbmNlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICsraTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfV0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIEV2ZW50ZWQ7XHJcblx0fSkoKTtcclxuXHRcclxuXHRUZXRoZXJCYXNlLlV0aWxzID0ge1xyXG5cdCAgZ2V0U2Nyb2xsUGFyZW50OiBnZXRTY3JvbGxQYXJlbnQsXHJcblx0ICBnZXRCb3VuZHM6IGdldEJvdW5kcyxcclxuXHQgIGdldE9mZnNldFBhcmVudDogZ2V0T2Zmc2V0UGFyZW50LFxyXG5cdCAgZXh0ZW5kOiBleHRlbmQsXHJcblx0ICBhZGRDbGFzczogYWRkQ2xhc3MsXHJcblx0ICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXHJcblx0ICBoYXNDbGFzczogaGFzQ2xhc3MsXHJcblx0ICB1cGRhdGVDbGFzc2VzOiB1cGRhdGVDbGFzc2VzLFxyXG5cdCAgZGVmZXI6IGRlZmVyLFxyXG5cdCAgZmx1c2g6IGZsdXNoLFxyXG5cdCAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxyXG5cdCAgRXZlbnRlZDogRXZlbnRlZCxcclxuXHQgIGdldFNjcm9sbEJhclNpemU6IGdldFNjcm9sbEJhclNpemVcclxuXHR9O1xyXG5cdC8qIGdsb2JhbHMgVGV0aGVyQmFzZSwgcGVyZm9ybWFuY2UgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XHJcblx0XHJcblx0dmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHRpZiAodHlwZW9mIFRldGhlckJhc2UgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGluY2x1ZGUgdGhlIHV0aWxzLmpzIGZpbGUgYmVmb3JlIHRldGhlci5qcycpO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xyXG5cdHZhciBnZXRTY3JvbGxQYXJlbnQgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRTY3JvbGxQYXJlbnQ7XHJcblx0dmFyIGdldEJvdW5kcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldEJvdW5kcztcclxuXHR2YXIgZ2V0T2Zmc2V0UGFyZW50ID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0T2Zmc2V0UGFyZW50O1xyXG5cdHZhciBleHRlbmQgPSBfVGV0aGVyQmFzZSRVdGlscy5leHRlbmQ7XHJcblx0dmFyIGFkZENsYXNzID0gX1RldGhlckJhc2UkVXRpbHMuYWRkQ2xhc3M7XHJcblx0dmFyIHJlbW92ZUNsYXNzID0gX1RldGhlckJhc2UkVXRpbHMucmVtb3ZlQ2xhc3M7XHJcblx0dmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xyXG5cdHZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xyXG5cdHZhciBmbHVzaCA9IF9UZXRoZXJCYXNlJFV0aWxzLmZsdXNoO1xyXG5cdHZhciBnZXRTY3JvbGxCYXJTaXplID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0U2Nyb2xsQmFyU2l6ZTtcclxuXHRcclxuXHRmdW5jdGlvbiB3aXRoaW4oYSwgYikge1xyXG5cdCAgdmFyIGRpZmYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAxIDogYXJndW1lbnRzWzJdO1xyXG5cdFxyXG5cdCAgcmV0dXJuIGEgKyBkaWZmID49IGIgJiYgYiA+PSBhIC0gZGlmZjtcclxuXHR9XHJcblx0XHJcblx0dmFyIHRyYW5zZm9ybUtleSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICByZXR1cm4gJyc7XHJcblx0ICB9XHJcblx0ICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcclxuXHQgIHZhciB0cmFuc2Zvcm1zID0gWyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ107XHJcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgdmFyIGtleSA9IHRyYW5zZm9ybXNbaV07XHJcblx0ICAgIGlmIChlbC5zdHlsZVtrZXldICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICByZXR1cm4ga2V5O1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgdGV0aGVycyA9IFtdO1xyXG5cdFxyXG5cdHZhciBwb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG5cdCAgdGV0aGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXRoZXIpIHtcclxuXHQgICAgdGV0aGVyLnBvc2l0aW9uKGZhbHNlKTtcclxuXHQgIH0pO1xyXG5cdCAgZmx1c2goKTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG5vdygpIHtcclxuXHQgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHQgIH1cclxuXHQgIHJldHVybiArbmV3IERhdGUoKTtcclxuXHR9XHJcblx0XHJcblx0KGZ1bmN0aW9uICgpIHtcclxuXHQgIHZhciBsYXN0Q2FsbCA9IG51bGw7XHJcblx0ICB2YXIgbGFzdER1cmF0aW9uID0gbnVsbDtcclxuXHQgIHZhciBwZW5kaW5nVGltZW91dCA9IG51bGw7XHJcblx0XHJcblx0ICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgbGFzdER1cmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsYXN0RHVyYXRpb24gPiAxNikge1xyXG5cdCAgICAgIC8vIFdlIHZvbHVudGFyaWx5IHRocm90dGxlIG91cnNlbHZlcyBpZiB3ZSBjYW4ndCBtYW5hZ2UgNjBmcHNcclxuXHQgICAgICBsYXN0RHVyYXRpb24gPSBNYXRoLm1pbihsYXN0RHVyYXRpb24gLSAxNiwgMjUwKTtcclxuXHRcclxuXHQgICAgICAvLyBKdXN0IGluIGNhc2UgdGhpcyBpcyB0aGUgbGFzdCBldmVudCwgcmVtZW1iZXIgdG8gcG9zaXRpb24ganVzdCBvbmNlIG1vcmVcclxuXHQgICAgICBwZW5kaW5nVGltZW91dCA9IHNldFRpbWVvdXQodGljaywgMjUwKTtcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHR5cGVvZiBsYXN0Q2FsbCAhPT0gJ3VuZGVmaW5lZCcgJiYgbm93KCkgLSBsYXN0Q2FsbCA8IDEwKSB7XHJcblx0ICAgICAgLy8gU29tZSBicm93c2VycyBjYWxsIGV2ZW50cyBhIGxpdHRsZSB0b28gZnJlcXVlbnRseSwgcmVmdXNlIHRvIHJ1biBtb3JlIHRoYW4gaXMgcmVhc29uYWJsZVxyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHBlbmRpbmdUaW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nVGltZW91dCk7XHJcblx0ICAgICAgcGVuZGluZ1RpbWVvdXQgPSBudWxsO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGxhc3RDYWxsID0gbm93KCk7XHJcblx0ICAgIHBvc2l0aW9uKCk7XHJcblx0ICAgIGxhc3REdXJhdGlvbiA9IG5vdygpIC0gbGFzdENhbGw7XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIFsncmVzaXplJywgJ3Njcm9sbCcsICd0b3VjaG1vdmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aWNrKTtcclxuXHQgICAgfSk7XHJcblx0ICB9XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgTUlSUk9SX0xSID0ge1xyXG5cdCAgY2VudGVyOiAnY2VudGVyJyxcclxuXHQgIGxlZnQ6ICdyaWdodCcsXHJcblx0ICByaWdodDogJ2xlZnQnXHJcblx0fTtcclxuXHRcclxuXHR2YXIgTUlSUk9SX1RCID0ge1xyXG5cdCAgbWlkZGxlOiAnbWlkZGxlJyxcclxuXHQgIHRvcDogJ2JvdHRvbScsXHJcblx0ICBib3R0b206ICd0b3AnXHJcblx0fTtcclxuXHRcclxuXHR2YXIgT0ZGU0VUX01BUCA9IHtcclxuXHQgIHRvcDogMCxcclxuXHQgIGxlZnQ6IDAsXHJcblx0ICBtaWRkbGU6ICc1MCUnLFxyXG5cdCAgY2VudGVyOiAnNTAlJyxcclxuXHQgIGJvdHRvbTogJzEwMCUnLFxyXG5cdCAgcmlnaHQ6ICcxMDAlJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGF1dG9Ub0ZpeGVkQXR0YWNobWVudCA9IGZ1bmN0aW9uIGF1dG9Ub0ZpeGVkQXR0YWNobWVudChhdHRhY2htZW50LCByZWxhdGl2ZVRvQXR0YWNobWVudCkge1xyXG5cdCAgdmFyIGxlZnQgPSBhdHRhY2htZW50LmxlZnQ7XHJcblx0ICB2YXIgdG9wID0gYXR0YWNobWVudC50b3A7XHJcblx0XHJcblx0ICBpZiAobGVmdCA9PT0gJ2F1dG8nKSB7XHJcblx0ICAgIGxlZnQgPSBNSVJST1JfTFJbcmVsYXRpdmVUb0F0dGFjaG1lbnQubGVmdF07XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAodG9wID09PSAnYXV0bycpIHtcclxuXHQgICAgdG9wID0gTUlSUk9SX1RCW3JlbGF0aXZlVG9BdHRhY2htZW50LnRvcF07XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGF0dGFjaG1lbnRUb09mZnNldCA9IGZ1bmN0aW9uIGF0dGFjaG1lbnRUb09mZnNldChhdHRhY2htZW50KSB7XHJcblx0ICB2YXIgbGVmdCA9IGF0dGFjaG1lbnQubGVmdDtcclxuXHQgIHZhciB0b3AgPSBhdHRhY2htZW50LnRvcDtcclxuXHRcclxuXHQgIGlmICh0eXBlb2YgT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBsZWZ0ID0gT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiBPRkZTRVRfTUFQW2F0dGFjaG1lbnQudG9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgdG9wID0gT0ZGU0VUX01BUFthdHRhY2htZW50LnRvcF07XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gYWRkT2Zmc2V0KCkge1xyXG5cdCAgdmFyIG91dCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcblx0XHJcblx0ICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb2Zmc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG5cdCAgICBvZmZzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XHJcblx0ICAgIHZhciB0b3AgPSBfcmVmLnRvcDtcclxuXHQgICAgdmFyIGxlZnQgPSBfcmVmLmxlZnQ7XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdG9wID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgIHRvcCA9IHBhcnNlRmxvYXQodG9wLCAxMCk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgIGxlZnQgPSBwYXJzZUZsb2F0KGxlZnQsIDEwKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBvdXQudG9wICs9IHRvcDtcclxuXHQgICAgb3V0LmxlZnQgKz0gbGVmdDtcclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIG91dDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gb2Zmc2V0VG9QeChvZmZzZXQsIHNpemUpIHtcclxuXHQgIGlmICh0eXBlb2Ygb2Zmc2V0LmxlZnQgPT09ICdzdHJpbmcnICYmIG9mZnNldC5sZWZ0LmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcclxuXHQgICAgb2Zmc2V0LmxlZnQgPSBwYXJzZUZsb2F0KG9mZnNldC5sZWZ0LCAxMCkgLyAxMDAgKiBzaXplLndpZHRoO1xyXG5cdCAgfVxyXG5cdCAgaWYgKHR5cGVvZiBvZmZzZXQudG9wID09PSAnc3RyaW5nJyAmJiBvZmZzZXQudG9wLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcclxuXHQgICAgb2Zmc2V0LnRvcCA9IHBhcnNlRmxvYXQob2Zmc2V0LnRvcCwgMTApIC8gMTAwICogc2l6ZS5oZWlnaHQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gb2Zmc2V0O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgcGFyc2VPZmZzZXQgPSBmdW5jdGlvbiBwYXJzZU9mZnNldCh2YWx1ZSkge1xyXG5cdCAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCcgJyk7XHJcblx0XHJcblx0ICB2YXIgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMik7XHJcblx0XHJcblx0ICB2YXIgdG9wID0gX3ZhbHVlJHNwbGl0MlswXTtcclxuXHQgIHZhciBsZWZ0ID0gX3ZhbHVlJHNwbGl0MlsxXTtcclxuXHRcclxuXHQgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XHJcblx0fTtcclxuXHR2YXIgcGFyc2VBdHRhY2htZW50ID0gcGFyc2VPZmZzZXQ7XHJcblx0XHJcblx0dmFyIFRldGhlckNsYXNzID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIGZ1bmN0aW9uIFRldGhlckNsYXNzKG9wdGlvbnMpIHtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRldGhlckNsYXNzKTtcclxuXHRcclxuXHQgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYmluZCh0aGlzKTtcclxuXHRcclxuXHQgICAgdGV0aGVycy5wdXNoKHRoaXMpO1xyXG5cdFxyXG5cdCAgICB0aGlzLmhpc3RvcnkgPSBbXTtcclxuXHRcclxuXHQgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIGZhbHNlKTtcclxuXHRcclxuXHQgICAgVGV0aGVyQmFzZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xyXG5cdCAgICAgIGlmICh0eXBlb2YgbW9kdWxlLmluaXRpYWxpemUgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZS5jYWxsKF90aGlzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB0aGlzLnBvc2l0aW9uKCk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBfY3JlYXRlQ2xhc3MoVGV0aGVyQ2xhc3MsIFt7XHJcblx0ICAgIGtleTogJ2dldENsYXNzJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsYXNzKCkge1xyXG5cdCAgICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnJyA6IGFyZ3VtZW50c1swXTtcclxuXHQgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5jbGFzc2VzO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgY2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2xhc3Nlc1trZXldKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsYXNzZXNba2V5XTtcclxuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCArICctJyArIGtleTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgcmV0dXJuIGtleTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnc2V0T3B0aW9ucycsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuXHQgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHRcclxuXHQgICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcclxuXHRcclxuXHQgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcblx0ICAgICAgICBvZmZzZXQ6ICcwIDAnLFxyXG5cdCAgICAgICAgdGFyZ2V0T2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6ICdhdXRvIGF1dG8nLFxyXG5cdCAgICAgICAgY2xhc3NQcmVmaXg6ICd0ZXRoZXInXHJcblx0ICAgICAgfTtcclxuXHRcclxuXHQgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cdFxyXG5cdCAgICAgIHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHQgICAgICB2YXIgZWxlbWVudCA9IF9vcHRpb25zLmVsZW1lbnQ7XHJcblx0ICAgICAgdmFyIHRhcmdldCA9IF9vcHRpb25zLnRhcmdldDtcclxuXHQgICAgICB2YXIgdGFyZ2V0TW9kaWZpZXIgPSBfb3B0aW9ucy50YXJnZXRNb2RpZmllcjtcclxuXHRcclxuXHQgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSB0YXJnZXRNb2RpZmllcjtcclxuXHRcclxuXHQgICAgICBpZiAodGhpcy50YXJnZXQgPT09ICd2aWV3cG9ydCcpIHtcclxuXHQgICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcclxuXHQgICAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSAndmlzaWJsZSc7XHJcblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LmJvZHk7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Njcm9sbC1oYW5kbGUnO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBbJ2VsZW1lbnQnLCAndGFyZ2V0J10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcblx0ICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RldGhlciBFcnJvcjogQm90aCBlbGVtZW50IGFuZCB0YXJnZXQgbXVzdCBiZSBkZWZpbmVkJyk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldLmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgX3RoaXMyW2tleV0gPSBfdGhpczJba2V5XVswXTtcclxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICBfdGhpczJba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMyW2tleV0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZWxlbWVudCcpKTtcclxuXHQgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygndGFyZ2V0JykpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hdHRhY2htZW50KSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RldGhlciBFcnJvcjogWW91IG11c3QgcHJvdmlkZSBhbiBhdHRhY2htZW50Jyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHRoaXMudGFyZ2V0QXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudCh0aGlzLm9wdGlvbnMudGFyZ2V0QXR0YWNobWVudCk7XHJcblx0ICAgICAgdGhpcy5hdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHRoaXMub3B0aW9ucy5hdHRhY2htZW50KTtcclxuXHQgICAgICB0aGlzLm9mZnNldCA9IHBhcnNlT2Zmc2V0KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0T2Zmc2V0ID0gcGFyc2VPZmZzZXQodGhpcy5vcHRpb25zLnRhcmdldE9mZnNldCk7XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLnNjcm9sbFBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodGhpcy50YXJnZXRNb2RpZmllciA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0O1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLnRhcmdldCk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICghKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIHRoaXMuZW5hYmxlKHBvcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2dldFRhcmdldEJvdW5kcycsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYXJnZXRCb3VuZHMoKSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhcmdldE1vZGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICd2aXNpYmxlJykge1xyXG5cdCAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4geyB0b3A6IHBhZ2VZT2Zmc2V0LCBsZWZ0OiBwYWdlWE9mZnNldCwgaGVpZ2h0OiBpbm5lckhlaWdodCwgd2lkdGg6IGlubmVyV2lkdGggfTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRzKHRoaXMudGFyZ2V0KTtcclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgb3V0ID0ge1xyXG5cdCAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxyXG5cdCAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcclxuXHQgICAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCxcclxuXHQgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCAtIGJvdW5kcy50b3ApKTtcclxuXHQgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCArIGlubmVySGVpZ2h0KSkpO1xyXG5cdCAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihpbm5lckhlaWdodCwgb3V0LmhlaWdodCk7XHJcblx0ICAgICAgICAgICAgb3V0LmhlaWdodCAtPSAyO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIG91dC53aWR0aCA9IE1hdGgubWluKG91dC53aWR0aCwgYm91bmRzLndpZHRoIC0gKHBhZ2VYT2Zmc2V0IC0gYm91bmRzLmxlZnQpKTtcclxuXHQgICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihvdXQud2lkdGgsIGJvdW5kcy53aWR0aCAtIChib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIChwYWdlWE9mZnNldCArIGlubmVyV2lkdGgpKSk7XHJcblx0ICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4oaW5uZXJXaWR0aCwgb3V0LndpZHRoKTtcclxuXHQgICAgICAgICAgICBvdXQud2lkdGggLT0gMjtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAob3V0LnRvcCA8IHBhZ2VZT2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICBvdXQudG9wID0gcGFnZVlPZmZzZXQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChvdXQubGVmdCA8IHBhZ2VYT2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICBvdXQubGVmdCA9IHBhZ2VYT2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xyXG5cdCAgICAgICAgICB2YXIgYm91bmRzID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcblx0ICAgICAgICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHJcblx0ICAgICAgICAgICAgYm91bmRzID0ge1xyXG5cdCAgICAgICAgICAgICAgbGVmdDogcGFnZVhPZmZzZXQsXHJcblx0ICAgICAgICAgICAgICB0b3A6IHBhZ2VZT2Zmc2V0LFxyXG5cdCAgICAgICAgICAgICAgaGVpZ2h0OiBpbm5lckhlaWdodCxcclxuXHQgICAgICAgICAgICAgIHdpZHRoOiBpbm5lcldpZHRoXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBib3VuZHMgPSBnZXRCb3VuZHModGFyZ2V0KTtcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBoYXNCb3R0b21TY3JvbGwgPSB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGggfHwgW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1hdLmluZGV4T2YoJ3Njcm9sbCcpID49IDAgfHwgdGhpcy50YXJnZXQgIT09IGRvY3VtZW50LmJvZHk7XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBzY3JvbGxCb3R0b20gPSAwO1xyXG5cdCAgICAgICAgICBpZiAoaGFzQm90dG9tU2Nyb2xsKSB7XHJcblx0ICAgICAgICAgICAgc2Nyb2xsQm90dG9tID0gMTU7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKSAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIC0gc2Nyb2xsQm90dG9tO1xyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgb3V0ID0ge1xyXG5cdCAgICAgICAgICAgIHdpZHRoOiAxNSxcclxuXHQgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIDAuOTc1ICogKGhlaWdodCAvIHRhcmdldC5zY3JvbGxIZWlnaHQpLFxyXG5cdCAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIC0gMTVcclxuXHQgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIGZpdEFkaiA9IDA7XHJcblx0ICAgICAgICAgIGlmIChoZWlnaHQgPCA0MDggJiYgdGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICBmaXRBZGogPSAtMC4wMDAxMSAqIE1hdGgucG93KGhlaWdodCwgMikgLSAwLjAwNzI3ICogaGVpZ2h0ICsgMjIuNTg7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0ICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgc2Nyb2xsUGVyY2VudGFnZSA9IHRoaXMudGFyZ2V0LnNjcm9sbFRvcCAvICh0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0KTtcclxuXHQgICAgICAgICAgb3V0LnRvcCA9IHNjcm9sbFBlcmNlbnRhZ2UgKiAoaGVpZ2h0IC0gb3V0LmhlaWdodCAtIGZpdEFkaikgKyBib3VuZHMudG9wICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCk7XHJcblx0XHJcblx0ICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xyXG5cdCAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1heChvdXQuaGVpZ2h0LCAyNCk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgcmV0dXJuIGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2NsZWFyQ2FjaGUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuXHQgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2NhY2hlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNhY2hlKGssIGdldHRlcikge1xyXG5cdCAgICAgIC8vIE1vcmUgdGhhbiBvbmUgbW9kdWxlIHdpbGwgb2Z0ZW4gbmVlZCB0aGUgc2FtZSBET00gaW5mbywgc29cclxuXHQgICAgICAvLyB3ZSBrZWVwIGEgY2FjaGUgd2hpY2ggaXMgY2xlYXJlZCBvbiBlYWNoIHBvc2l0aW9uIGNhbGxcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuX2NhY2hlID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZVtrXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHRoaXMuX2NhY2hlW2tdID0gZ2V0dGVyLmNhbGwodGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtrXTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdlbmFibGUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xyXG5cdCAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xyXG5cdFxyXG5cdCAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIGFkZENsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XHJcblx0ICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQgIT09IGRvY3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnBvc2l0aW9uKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHBvcykge1xyXG5cdCAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdkaXNhYmxlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xyXG5cdCAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5zY3JvbGxQYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnBvc2l0aW9uKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnZGVzdHJveScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG5cdCAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG5cdFxyXG5cdCAgICAgIHRldGhlcnMuZm9yRWFjaChmdW5jdGlvbiAodGV0aGVyLCBpKSB7XHJcblx0ICAgICAgICBpZiAodGV0aGVyID09PSBfdGhpczMpIHtcclxuXHQgICAgICAgICAgdGV0aGVycy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICd1cGRhdGVBdHRhY2hDbGFzc2VzJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUF0dGFjaENsYXNzZXMoZWxlbWVudEF0dGFjaCwgdGFyZ2V0QXR0YWNoKSB7XHJcblx0ICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XHJcblx0XHJcblx0ICAgICAgZWxlbWVudEF0dGFjaCA9IGVsZW1lbnRBdHRhY2ggfHwgdGhpcy5hdHRhY2htZW50O1xyXG5cdCAgICAgIHRhcmdldEF0dGFjaCA9IHRhcmdldEF0dGFjaCB8fCB0aGlzLnRhcmdldEF0dGFjaG1lbnQ7XHJcblx0ICAgICAgdmFyIHNpZGVzID0gWydsZWZ0JywgJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbWlkZGxlJywgJ2NlbnRlciddO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5sZW5ndGgpIHtcclxuXHQgICAgICAgIC8vIHVwZGF0ZUF0dGFjaENsYXNzZXMgY2FuIGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBpbiBhIHBvc2l0aW9uIGNhbGwsIHNvXHJcblx0ICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlcyBzdWNoIHRoYXQgd2hlbiB0aGUgbGFzdCBkZWZlciBnZXRzXHJcblx0ICAgICAgICAvLyByYW4gaXQgZG9lc24ndCBhZGQgYW55IGV4dHJhIGNsYXNzZXMgZnJvbSBwcmV2aW91cyBjYWxscy5cclxuXHQgICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMuc3BsaWNlKDAsIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMubGVuZ3RoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA9IFtdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB2YXIgYWRkID0gdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcztcclxuXHRcclxuXHQgICAgICBpZiAoZWxlbWVudEF0dGFjaC50b3ApIHtcclxuXHQgICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIGVsZW1lbnRBdHRhY2gudG9wKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKGVsZW1lbnRBdHRhY2gubGVmdCkge1xyXG5cdCAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpICsgJy0nICsgZWxlbWVudEF0dGFjaC5sZWZ0KTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRhcmdldEF0dGFjaC50b3ApIHtcclxuXHQgICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgdGFyZ2V0QXR0YWNoLnRvcCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0YXJnZXRBdHRhY2gubGVmdCkge1xyXG5cdCAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyB0YXJnZXRBdHRhY2gubGVmdCk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBhbGwgPSBbXTtcclxuXHQgICAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICBhbGwucHVzaChfdGhpczQuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xyXG5cdCAgICAgICAgYWxsLnB1c2goX3RoaXM0LmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xyXG5cdCAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghKHR5cGVvZiBfdGhpczQuX2FkZEF0dGFjaENsYXNzZXMgIT09ICd1bmRlZmluZWQnKSkge1xyXG5cdCAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzNC5lbGVtZW50LCBfdGhpczQuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XHJcblx0ICAgICAgICBpZiAoIShfdGhpczQub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpczQudGFyZ2V0LCBfdGhpczQuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBkZWxldGUgX3RoaXM0Ll9hZGRBdHRhY2hDbGFzc2VzO1xyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ3Bvc2l0aW9uJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG5cdCAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIHZhciBmbHVzaENoYW5nZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xyXG5cdFxyXG5cdCAgICAgIC8vIGZsdXNoQ2hhbmdlcyBjb21taXRzIHRoZSBjaGFuZ2VzIGltbWVkaWF0ZWx5LCBsZWF2ZSB0cnVlIHVubGVzcyB5b3UgYXJlIHBvc2l0aW9uaW5nIG11bHRpcGxlXHJcblx0ICAgICAgLy8gdGV0aGVycyAoaW4gd2hpY2ggY2FzZSBjYWxsIFRldGhlci5VdGlscy5mbHVzaCB5b3Vyc2VsZiB3aGVuIHlvdSdyZSBkb25lKVxyXG5cdFxyXG5cdCAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG5cdFxyXG5cdCAgICAgIC8vIFR1cm4gJ2F1dG8nIGF0dGFjaG1lbnRzIGludG8gdGhlIGFwcHJvcHJpYXRlIGNvcm5lciBvciBlZGdlXHJcblx0ICAgICAgdmFyIHRhcmdldEF0dGFjaG1lbnQgPSBhdXRvVG9GaXhlZEF0dGFjaG1lbnQodGhpcy50YXJnZXRBdHRhY2htZW50LCB0aGlzLmF0dGFjaG1lbnQpO1xyXG5cdFxyXG5cdCAgICAgIHRoaXMudXBkYXRlQXR0YWNoQ2xhc3Nlcyh0aGlzLmF0dGFjaG1lbnQsIHRhcmdldEF0dGFjaG1lbnQpO1xyXG5cdFxyXG5cdCAgICAgIHZhciBlbGVtZW50UG9zID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzNS5lbGVtZW50KTtcclxuXHQgICAgICB9KTtcclxuXHRcclxuXHQgICAgICB2YXIgd2lkdGggPSBlbGVtZW50UG9zLndpZHRoO1xyXG5cdCAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50UG9zLmhlaWdodDtcclxuXHRcclxuXHQgICAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XHJcblx0XHJcblx0ICAgICAgICAvLyBXZSBjYWNoZSB0aGUgaGVpZ2h0IGFuZCB3aWR0aCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHBvc2l0aW9uIGVsZW1lbnRzIHRoYXQgYXJlXHJcblx0ICAgICAgICAvLyBnZXR0aW5nIGhpZGRlbi5cclxuXHQgICAgICAgIHdpZHRoID0gX2xhc3RTaXplLndpZHRoO1xyXG5cdCAgICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5sYXN0U2l6ZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgdGFyZ2V0UG9zID0gdGhpcy5jYWNoZSgndGFyZ2V0LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiBfdGhpczUuZ2V0VGFyZ2V0Qm91bmRzKCk7XHJcblx0ICAgICAgfSk7XHJcblx0ICAgICAgdmFyIHRhcmdldFNpemUgPSB0YXJnZXRQb3M7XHJcblx0XHJcblx0ICAgICAgLy8gR2V0IGFuIGFjdHVhbCBweCBvZmZzZXQgZnJvbSB0aGUgYXR0YWNobWVudFxyXG5cdCAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0aGlzLmF0dGFjaG1lbnQpLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcblx0ICAgICAgdmFyIHRhcmdldE9mZnNldCA9IG9mZnNldFRvUHgoYXR0YWNobWVudFRvT2Zmc2V0KHRhcmdldEF0dGFjaG1lbnQpLCB0YXJnZXRTaXplKTtcclxuXHRcclxuXHQgICAgICB2YXIgbWFudWFsT2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLm9mZnNldCwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG5cdCAgICAgIHZhciBtYW51YWxUYXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KHRoaXMudGFyZ2V0T2Zmc2V0LCB0YXJnZXRTaXplKTtcclxuXHRcclxuXHQgICAgICAvLyBBZGQgdGhlIG1hbnVhbGx5IHByb3ZpZGVkIG9mZnNldFxyXG5cdCAgICAgIG9mZnNldCA9IGFkZE9mZnNldChvZmZzZXQsIG1hbnVhbE9mZnNldCk7XHJcblx0ICAgICAgdGFyZ2V0T2Zmc2V0ID0gYWRkT2Zmc2V0KHRhcmdldE9mZnNldCwgbWFudWFsVGFyZ2V0T2Zmc2V0KTtcclxuXHRcclxuXHQgICAgICAvLyBJdCdzIG5vdyBvdXIgZ29hbCB0byBtYWtlIChlbGVtZW50IHBvc2l0aW9uICsgb2Zmc2V0KSA9PSAodGFyZ2V0IHBvc2l0aW9uICsgdGFyZ2V0IG9mZnNldClcclxuXHQgICAgICB2YXIgbGVmdCA9IHRhcmdldFBvcy5sZWZ0ICsgdGFyZ2V0T2Zmc2V0LmxlZnQgLSBvZmZzZXQubGVmdDtcclxuXHQgICAgICB2YXIgdG9wID0gdGFyZ2V0UG9zLnRvcCArIHRhcmdldE9mZnNldC50b3AgLSBvZmZzZXQudG9wO1xyXG5cdFxyXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGV0aGVyQmFzZS5tb2R1bGVzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICB2YXIgX21vZHVsZTIgPSBUZXRoZXJCYXNlLm1vZHVsZXNbaV07XHJcblx0ICAgICAgICB2YXIgcmV0ID0gX21vZHVsZTIucG9zaXRpb24uY2FsbCh0aGlzLCB7XHJcblx0ICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcblx0ICAgICAgICAgIHRvcDogdG9wLFxyXG5cdCAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0YXJnZXRBdHRhY2htZW50LFxyXG5cdCAgICAgICAgICB0YXJnZXRQb3M6IHRhcmdldFBvcyxcclxuXHQgICAgICAgICAgZWxlbWVudFBvczogZWxlbWVudFBvcyxcclxuXHQgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcblx0ICAgICAgICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0LFxyXG5cdCAgICAgICAgICBtYW51YWxPZmZzZXQ6IG1hbnVhbE9mZnNldCxcclxuXHQgICAgICAgICAgbWFudWFsVGFyZ2V0T2Zmc2V0OiBtYW51YWxUYXJnZXRPZmZzZXQsXHJcblx0ICAgICAgICAgIHNjcm9sbGJhclNpemU6IHNjcm9sbGJhclNpemUsXHJcblx0ICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudFxyXG5cdCAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByZXQgIT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgdG9wID0gcmV0LnRvcDtcclxuXHQgICAgICAgICAgbGVmdCA9IHJldC5sZWZ0O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICAvLyBXZSBkZXNjcmliZSB0aGUgcG9zaXRpb24gdGhyZWUgZGlmZmVyZW50IHdheXMgdG8gZ2l2ZSB0aGUgb3B0aW1pemVyXHJcblx0ICAgICAgLy8gYSBjaGFuY2UgdG8gZGVjaWRlIHRoZSBiZXN0IHBvc3NpYmxlIHdheSB0byBwb3NpdGlvbiB0aGUgZWxlbWVudFxyXG5cdCAgICAgIC8vIHdpdGggdGhlIGZld2VzdCByZXBhaW50cy5cclxuXHQgICAgICB2YXIgbmV4dCA9IHtcclxuXHQgICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhZ2UgKGFic29sdXRlIHBvc2l0aW9uaW5nIHdoZW5cclxuXHQgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIGJvZHkpXHJcblx0ICAgICAgICBwYWdlOiB7XHJcblx0ICAgICAgICAgIHRvcDogdG9wLFxyXG5cdCAgICAgICAgICBsZWZ0OiBsZWZ0XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgKGZpeGVkIHBvc2l0aW9uaW5nKVxyXG5cdCAgICAgICAgdmlld3BvcnQ6IHtcclxuXHQgICAgICAgICAgdG9wOiB0b3AgLSBwYWdlWU9mZnNldCxcclxuXHQgICAgICAgICAgYm90dG9tOiBwYWdlWU9mZnNldCAtIHRvcCAtIGhlaWdodCArIGlubmVySGVpZ2h0LFxyXG5cdCAgICAgICAgICBsZWZ0OiBsZWZ0IC0gcGFnZVhPZmZzZXQsXHJcblx0ICAgICAgICAgIHJpZ2h0OiBwYWdlWE9mZnNldCAtIGxlZnQgLSB3aWR0aCArIGlubmVyV2lkdGhcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoID4gd2luZG93LmlubmVyV2lkdGgpIHtcclxuXHQgICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xyXG5cdCAgICAgICAgbmV4dC52aWV3cG9ydC5ib3R0b20gLT0gc2Nyb2xsYmFyU2l6ZS5oZWlnaHQ7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG5cdCAgICAgICAgc2Nyb2xsYmFyU2l6ZSA9IHRoaXMuY2FjaGUoJ3Njcm9sbGJhci1zaXplJywgZ2V0U2Nyb2xsQmFyU2l6ZSk7XHJcblx0ICAgICAgICBuZXh0LnZpZXdwb3J0LnJpZ2h0IC09IHNjcm9sbGJhclNpemUud2lkdGg7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChbJycsICdzdGF0aWMnXS5pbmRleE9mKGRvY3VtZW50LmJvZHkuc3R5bGUucG9zaXRpb24pID09PSAtMSB8fCBbJycsICdzdGF0aWMnXS5pbmRleE9mKGRvY3VtZW50LmJvZHkucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbikgPT09IC0xKSB7XHJcblx0ICAgICAgICAvLyBBYnNvbHV0ZSBwb3NpdGlvbmluZyBpbiB0aGUgYm9keSB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBwYWdlLCBub3QgdGhlICdpbml0aWFsIGNvbnRhaW5pbmcgYmxvY2snXHJcblx0ICAgICAgICBuZXh0LnBhZ2UuYm90dG9tID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSB0b3AgLSBoZWlnaHQ7XHJcblx0ICAgICAgICBuZXh0LnBhZ2UucmlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gbGVmdCAtIHdpZHRoO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vcHRpbWl6YXRpb25zICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wdGlvbnMub3B0aW1pemF0aW9ucy5tb3ZlRWxlbWVudCAhPT0gZmFsc2UgJiYgISh0eXBlb2YgdGhpcy50YXJnZXRNb2RpZmllciAhPT0gJ3VuZGVmaW5lZCcpKSB7XHJcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM1LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoX3RoaXM1LnRhcmdldCk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UG9zaXRpb24gPSBfdGhpczUuY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBnZXRCb3VuZHMob2Zmc2V0UGFyZW50KTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcclxuXHQgICAgICAgICAgdmFyIG9mZnNldFBhcmVudFNpemUgPSBvZmZzZXRQb3NpdGlvbjtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIG9mZnNldEJvcmRlciA9IHt9O1xyXG5cdCAgICAgICAgICBbJ1RvcCcsICdMZWZ0JywgJ0JvdHRvbScsICdSaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgICAgICBvZmZzZXRCb3JkZXJbc2lkZS50b0xvd2VyQ2FzZSgpXSA9IHBhcnNlRmxvYXQob2Zmc2V0UGFyZW50U3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xyXG5cdCAgICAgICAgICB9KTtcclxuXHRcclxuXHQgICAgICAgICAgb2Zmc2V0UG9zaXRpb24ucmlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gb2Zmc2V0UG9zaXRpb24ubGVmdCAtIG9mZnNldFBhcmVudFNpemUud2lkdGggKyBvZmZzZXRCb3JkZXIucmlnaHQ7XHJcblx0ICAgICAgICAgIG9mZnNldFBvc2l0aW9uLmJvdHRvbSA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0UG9zaXRpb24udG9wIC0gb2Zmc2V0UGFyZW50U2l6ZS5oZWlnaHQgKyBvZmZzZXRCb3JkZXIuYm90dG9tO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAobmV4dC5wYWdlLnRvcCA+PSBvZmZzZXRQb3NpdGlvbi50b3AgKyBvZmZzZXRCb3JkZXIudG9wICYmIG5leHQucGFnZS5ib3R0b20gPj0gb2Zmc2V0UG9zaXRpb24uYm90dG9tKSB7XHJcblx0ICAgICAgICAgICAgaWYgKG5leHQucGFnZS5sZWZ0ID49IG9mZnNldFBvc2l0aW9uLmxlZnQgKyBvZmZzZXRCb3JkZXIubGVmdCAmJiBuZXh0LnBhZ2UucmlnaHQgPj0gb2Zmc2V0UG9zaXRpb24ucmlnaHQpIHtcclxuXHQgICAgICAgICAgICAgIC8vIFdlJ3JlIHdpdGhpbiB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZSB0YXJnZXQncyBzY3JvbGwgcGFyZW50XHJcblx0ICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcclxuXHQgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQ7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50IChhYnNvbHV0ZSBwb3NpdGlvbmluZyB3aGVuXHJcblx0ICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBtb3ZlZCB0byBiZSBhIGNoaWxkIG9mIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50KS5cclxuXHQgICAgICAgICAgICAgIG5leHQub2Zmc2V0ID0ge1xyXG5cdCAgICAgICAgICAgICAgICB0b3A6IG5leHQucGFnZS50b3AgLSBvZmZzZXRQb3NpdGlvbi50b3AgKyBzY3JvbGxUb3AgLSBvZmZzZXRCb3JkZXIudG9wLFxyXG5cdCAgICAgICAgICAgICAgICBsZWZ0OiBuZXh0LnBhZ2UubGVmdCAtIG9mZnNldFBvc2l0aW9uLmxlZnQgKyBzY3JvbGxMZWZ0IC0gb2Zmc2V0Qm9yZGVyLmxlZnRcclxuXHQgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICAvLyBXZSBjb3VsZCBhbHNvIHRyYXZlbCB1cCB0aGUgRE9NIGFuZCB0cnkgZWFjaCBjb250YWluaW5nIGNvbnRleHQsIHJhdGhlciB0aGFuIG9ubHlcclxuXHQgICAgICAvLyBsb29raW5nIGF0IHRoZSBib2R5LCBidXQgd2UncmUgZ29ubmEgZ2V0IGRpbWluaXNoaW5nIHJldHVybnMuXHJcblx0XHJcblx0ICAgICAgdGhpcy5tb3ZlKG5leHQpO1xyXG5cdFxyXG5cdCAgICAgIHRoaXMuaGlzdG9yeS51bnNoaWZ0KG5leHQpO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0aGlzLmhpc3RvcnkubGVuZ3RoID4gMykge1xyXG5cdCAgICAgICAgdGhpcy5oaXN0b3J5LnBvcCgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoZmx1c2hDaGFuZ2VzKSB7XHJcblx0ICAgICAgICBmbHVzaCgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICAvLyBUSEUgSVNTVUVcclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnbW92ZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHBvcykge1xyXG5cdCAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIGlmICghKHR5cGVvZiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSAhPT0gJ3VuZGVmaW5lZCcpKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBzYW1lID0ge307XHJcblx0XHJcblx0ICAgICAgZm9yICh2YXIgdHlwZSBpbiBwb3MpIHtcclxuXHQgICAgICAgIHNhbWVbdHlwZV0gPSB7fTtcclxuXHRcclxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBwb3NbdHlwZV0pIHtcclxuXHQgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oaXN0b3J5Lmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5oaXN0b3J5W2ldO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRbdHlwZV0gIT09ICd1bmRlZmluZWQnICYmICF3aXRoaW4ocG9pbnRbdHlwZV1ba2V5XSwgcG9zW3R5cGVdW2tleV0pKSB7XHJcblx0ICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG5cdCAgICAgICAgICAgIHNhbWVbdHlwZV1ba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgdmFyIGNzcyA9IHsgdG9wOiAnJywgbGVmdDogJycsIHJpZ2h0OiAnJywgYm90dG9tOiAnJyB9O1xyXG5cdFxyXG5cdCAgICAgIHZhciB0cmFuc2NyaWJlID0gZnVuY3Rpb24gdHJhbnNjcmliZShfc2FtZSwgX3Bvcykge1xyXG5cdCAgICAgICAgdmFyIGhhc09wdGltaXphdGlvbnMgPSB0eXBlb2YgX3RoaXM2Lm9wdGlvbnMub3B0aW1pemF0aW9ucyAhPT0gJ3VuZGVmaW5lZCc7XHJcblx0ICAgICAgICB2YXIgZ3B1ID0gaGFzT3B0aW1pemF0aW9ucyA/IF90aGlzNi5vcHRpb25zLm9wdGltaXphdGlvbnMuZ3B1IDogbnVsbDtcclxuXHQgICAgICAgIGlmIChncHUgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgIHZhciB5UG9zID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgICAgICAgeFBvcyA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgaWYgKF9zYW1lLnRvcCkge1xyXG5cdCAgICAgICAgICAgIGNzcy50b3AgPSAwO1xyXG5cdCAgICAgICAgICAgIHlQb3MgPSBfcG9zLnRvcDtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBjc3MuYm90dG9tID0gMDtcclxuXHQgICAgICAgICAgICB5UG9zID0gLV9wb3MuYm90dG9tO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGlmIChfc2FtZS5sZWZ0KSB7XHJcblx0ICAgICAgICAgICAgY3NzLmxlZnQgPSAwO1xyXG5cdCAgICAgICAgICAgIHhQb3MgPSBfcG9zLmxlZnQ7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgY3NzLnJpZ2h0ID0gMDtcclxuXHQgICAgICAgICAgICB4UG9zID0gLV9wb3MucmlnaHQ7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgY3NzW3RyYW5zZm9ybUtleV0gPSAndHJhbnNsYXRlWCgnICsgTWF0aC5yb3VuZCh4UG9zKSArICdweCkgdHJhbnNsYXRlWSgnICsgTWF0aC5yb3VuZCh5UG9zKSArICdweCknO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAodHJhbnNmb3JtS2V5ICE9PSAnbXNUcmFuc2Zvcm0nKSB7XHJcblx0ICAgICAgICAgICAgLy8gVGhlIFogdHJhbnNmb3JtIHdpbGwga2VlcCB0aGlzIGluIHRoZSBHUFUgKGZhc3RlciwgYW5kIHByZXZlbnRzIGFydGlmYWN0cyksXHJcblx0ICAgICAgICAgICAgLy8gYnV0IElFOSBkb2Vzbid0IHN1cHBvcnQgM2QgdHJhbnNmb3JtcyBhbmQgd2lsbCBjaG9rZS5cclxuXHQgICAgICAgICAgICBjc3NbdHJhbnNmb3JtS2V5XSArPSBcIiB0cmFuc2xhdGVaKDApXCI7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIGlmIChfc2FtZS50b3ApIHtcclxuXHQgICAgICAgICAgICBjc3MudG9wID0gX3Bvcy50b3AgKyAncHgnO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNzcy5ib3R0b20gPSBfcG9zLmJvdHRvbSArICdweCc7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgaWYgKF9zYW1lLmxlZnQpIHtcclxuXHQgICAgICAgICAgICBjc3MubGVmdCA9IF9wb3MubGVmdCArICdweCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgY3NzLnJpZ2h0ID0gX3Bvcy5yaWdodCArICdweCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIHZhciBtb3ZlZCA9IGZhbHNlO1xyXG5cdCAgICAgIGlmICgoc2FtZS5wYWdlLnRvcCB8fCBzYW1lLnBhZ2UuYm90dG9tKSAmJiAoc2FtZS5wYWdlLmxlZnQgfHwgc2FtZS5wYWdlLnJpZ2h0KSkge1xyXG5cdCAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHQgICAgICAgIHRyYW5zY3JpYmUoc2FtZS5wYWdlLCBwb3MucGFnZSk7XHJcblx0ICAgICAgfSBlbHNlIGlmICgoc2FtZS52aWV3cG9ydC50b3AgfHwgc2FtZS52aWV3cG9ydC5ib3R0b20pICYmIChzYW1lLnZpZXdwb3J0LmxlZnQgfHwgc2FtZS52aWV3cG9ydC5yaWdodCkpIHtcclxuXHQgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcblx0ICAgICAgICB0cmFuc2NyaWJlKHNhbWUudmlld3BvcnQsIHBvcy52aWV3cG9ydCk7XHJcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2FtZS5vZmZzZXQgIT09ICd1bmRlZmluZWQnICYmIHNhbWUub2Zmc2V0LnRvcCAmJiBzYW1lLm9mZnNldC5sZWZ0KSB7XHJcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM2LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoX3RoaXM2LnRhcmdldCk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAoZ2V0T2Zmc2V0UGFyZW50KF90aGlzNi5lbGVtZW50KSAhPT0gb2Zmc2V0UGFyZW50KSB7XHJcblx0ICAgICAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgX3RoaXM2LmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpczYuZWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQuYXBwZW5kQ2hpbGQoX3RoaXM2LmVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIHRyYW5zY3JpYmUoc2FtZS5vZmZzZXQsIHBvcy5vZmZzZXQpO1xyXG5cdCAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdCAgICAgICAgdHJhbnNjcmliZSh7IHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZSB9LCBwb3MucGFnZSk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICghbW92ZWQpIHtcclxuXHQgICAgICAgIHZhciBvZmZzZXRQYXJlbnRJc0JvZHkgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XHJcblx0ICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUudGFnTmFtZSAhPT0gJ0JPRFknKSB7XHJcblx0ICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycpIHtcclxuXHQgICAgICAgICAgICBvZmZzZXRQYXJlbnRJc0JvZHkgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoIW9mZnNldFBhcmVudElzQm9keSkge1xyXG5cdCAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG5cdCAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIC8vIEFueSBjc3MgY2hhbmdlIHdpbGwgdHJpZ2dlciBhIHJlcGFpbnQsIHNvIGxldCdzIGF2b2lkIG9uZSBpZiBub3RoaW5nIGNoYW5nZWRcclxuXHQgICAgICB2YXIgd3JpdGVDU1MgPSB7fTtcclxuXHQgICAgICB2YXIgd3JpdGUgPSBmYWxzZTtcclxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gY3NzKSB7XHJcblx0ICAgICAgICB2YXIgdmFsID0gY3NzW2tleV07XHJcblx0ICAgICAgICB2YXIgZWxWYWwgPSB0aGlzLmVsZW1lbnQuc3R5bGVba2V5XTtcclxuXHRcclxuXHQgICAgICAgIGlmIChlbFZhbCAhPT0gJycgJiYgdmFsICE9PSAnJyAmJiBbJ3RvcCcsICdsZWZ0JywgJ2JvdHRvbScsICdyaWdodCddLmluZGV4T2Yoa2V5KSA+PSAwKSB7XHJcblx0ICAgICAgICAgIGVsVmFsID0gcGFyc2VGbG9hdChlbFZhbCk7XHJcblx0ICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChlbFZhbCAhPT0gdmFsKSB7XHJcblx0ICAgICAgICAgIHdyaXRlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgd3JpdGVDU1Nba2V5XSA9IHZhbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHdyaXRlKSB7XHJcblx0ICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgIGV4dGVuZChfdGhpczYuZWxlbWVudC5zdHlsZSwgd3JpdGVDU1MpO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9XSk7XHJcblx0XHJcblx0ICByZXR1cm4gVGV0aGVyQ2xhc3M7XHJcblx0fSkoKTtcclxuXHRcclxuXHRUZXRoZXJDbGFzcy5tb2R1bGVzID0gW107XHJcblx0XHJcblx0VGV0aGVyQmFzZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cdFxyXG5cdHZhciBUZXRoZXIgPSBleHRlbmQoVGV0aGVyQ2xhc3MsIFRldGhlckJhc2UpO1xyXG5cdC8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcclxuXHRcclxuXHR2YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xyXG5cdHZhciBnZXRCb3VuZHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRCb3VuZHM7XHJcblx0dmFyIGV4dGVuZCA9IF9UZXRoZXJCYXNlJFV0aWxzLmV4dGVuZDtcclxuXHR2YXIgdXBkYXRlQ2xhc3NlcyA9IF9UZXRoZXJCYXNlJFV0aWxzLnVwZGF0ZUNsYXNzZXM7XHJcblx0dmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XHJcblx0XHJcblx0dmFyIEJPVU5EU19GT1JNQVQgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXRoZXIsIHRvKSB7XHJcblx0ICBpZiAodG8gPT09ICdzY3JvbGxQYXJlbnQnKSB7XHJcblx0ICAgIHRvID0gdGV0aGVyLnNjcm9sbFBhcmVudDtcclxuXHQgIH0gZWxzZSBpZiAodG8gPT09ICd3aW5kb3cnKSB7XHJcblx0ICAgIHRvID0gW3BhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCwgaW5uZXJXaWR0aCArIHBhZ2VYT2Zmc2V0LCBpbm5lckhlaWdodCArIHBhZ2VZT2Zmc2V0XTtcclxuXHQgIH1cclxuXHRcclxuXHQgIGlmICh0byA9PT0gZG9jdW1lbnQpIHtcclxuXHQgICAgdG8gPSB0by5kb2N1bWVudEVsZW1lbnQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIHRvLm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIHZhciBzaXplID0gZ2V0Qm91bmRzKHRvKTtcclxuXHQgICAgICB2YXIgcG9zID0gc2l6ZTtcclxuXHQgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRvKTtcclxuXHRcclxuXHQgICAgICB0byA9IFtwb3MubGVmdCwgcG9zLnRvcCwgc2l6ZS53aWR0aCArIHBvcy5sZWZ0LCBzaXplLmhlaWdodCArIHBvcy50b3BdO1xyXG5cdFxyXG5cdCAgICAgIEJPVU5EU19GT1JNQVQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSwgaSkge1xyXG5cdCAgICAgICAgc2lkZSA9IHNpZGVbMF0udG9VcHBlckNhc2UoKSArIHNpZGUuc3Vic3RyKDEpO1xyXG5cdCAgICAgICAgaWYgKHNpZGUgPT09ICdUb3AnIHx8IHNpZGUgPT09ICdMZWZ0Jykge1xyXG5cdCAgICAgICAgICB0b1tpXSArPSBwYXJzZUZsb2F0KHN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHRvW2ldIC09IHBhcnNlRmxvYXQoc3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9KSgpO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgcmV0dXJuIHRvO1xyXG5cdH1cclxuXHRcclxuXHRUZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XHJcblx0ICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdCAgICB2YXIgdGFyZ2V0QXR0YWNobWVudCA9IF9yZWYudGFyZ2V0QXR0YWNobWVudDtcclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29uc3RyYWludHMpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgX2NhY2hlID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xyXG5cdCAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XHJcblx0XHJcblx0ICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDAgJiYgdHlwZW9mIHRoaXMubGFzdFNpemUgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XHJcblx0XHJcblx0ICAgICAgLy8gSGFuZGxlIHRoZSBpdGVtIGdldHRpbmcgaGlkZGVuIGFzIGEgcmVzdWx0IG9mIG91ciBwb3NpdGlvbmluZyB3aXRob3V0IGdsaXRjaGluZ1xyXG5cdCAgICAgIC8vIHRoZSBjbGFzc2VzIGluIGFuZCBvdXRcclxuXHQgICAgICB3aWR0aCA9IF9sYXN0U2l6ZS53aWR0aDtcclxuXHQgICAgICBoZWlnaHQgPSBfbGFzdFNpemUuaGVpZ2h0O1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciB0YXJnZXRTaXplID0gdGhpcy5jYWNoZSgndGFyZ2V0LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICByZXR1cm4gX3RoaXMuZ2V0VGFyZ2V0Qm91bmRzKCk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0U2l6ZS5oZWlnaHQ7XHJcblx0ICAgIHZhciB0YXJnZXRXaWR0aCA9IHRhcmdldFNpemUud2lkdGg7XHJcblx0XHJcblx0ICAgIHZhciBhbGxDbGFzc2VzID0gW3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpLCB0aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyldO1xyXG5cdFxyXG5cdCAgICB0aGlzLm9wdGlvbnMuY29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG5cdCAgICAgIHZhciBvdXRPZkJvdW5kc0NsYXNzID0gY29uc3RyYWludC5vdXRPZkJvdW5kc0NsYXNzO1xyXG5cdCAgICAgIHZhciBwaW5uZWRDbGFzcyA9IGNvbnN0cmFpbnQucGlubmVkQ2xhc3M7XHJcblx0XHJcblx0ICAgICAgaWYgKG91dE9mQm91bmRzQ2xhc3MpIHtcclxuXHQgICAgICAgIGFsbENsYXNzZXMucHVzaChvdXRPZkJvdW5kc0NsYXNzKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHBpbm5lZENsYXNzKSB7XHJcblx0ICAgICAgICBhbGxDbGFzc2VzLnB1c2gocGlubmVkQ2xhc3MpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGFsbENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcblx0ICAgICAgWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICBhbGxDbGFzc2VzLnB1c2goY2xzICsgJy0nICsgc2lkZSk7XHJcblx0ICAgICAgfSk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB2YXIgYWRkQ2xhc3NlcyA9IFtdO1xyXG5cdFxyXG5cdCAgICB2YXIgdEF0dGFjaG1lbnQgPSBleHRlbmQoe30sIHRhcmdldEF0dGFjaG1lbnQpO1xyXG5cdCAgICB2YXIgZUF0dGFjaG1lbnQgPSBleHRlbmQoe30sIHRoaXMuYXR0YWNobWVudCk7XHJcblx0XHJcblx0ICAgIHRoaXMub3B0aW9ucy5jb25zdHJhaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XHJcblx0ICAgICAgdmFyIHRvID0gY29uc3RyYWludC50bztcclxuXHQgICAgICB2YXIgYXR0YWNobWVudCA9IGNvbnN0cmFpbnQuYXR0YWNobWVudDtcclxuXHQgICAgICB2YXIgcGluID0gY29uc3RyYWludC5waW47XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgYXR0YWNobWVudCA9ICcnO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgY2hhbmdlQXR0YWNoWCA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgICAgY2hhbmdlQXR0YWNoWSA9IHVuZGVmaW5lZDtcclxuXHQgICAgICBpZiAoYXR0YWNobWVudC5pbmRleE9mKCcgJykgPj0gMCkge1xyXG5cdCAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0ID0gYXR0YWNobWVudC5zcGxpdCgnICcpO1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9hdHRhY2htZW50JHNwbGl0LCAyKTtcclxuXHRcclxuXHQgICAgICAgIGNoYW5nZUF0dGFjaFkgPSBfYXR0YWNobWVudCRzcGxpdDJbMF07XHJcblx0ICAgICAgICBjaGFuZ2VBdHRhY2hYID0gX2F0dGFjaG1lbnQkc3BsaXQyWzFdO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBjaGFuZ2VBdHRhY2hYID0gY2hhbmdlQXR0YWNoWSA9IGF0dGFjaG1lbnQ7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBib3VuZHMgPSBnZXRCb3VuZGluZ1JlY3QoX3RoaXMsIHRvKTtcclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ3RhcmdldCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAndG9nZXRoZXInKSB7XHJcblx0ICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgICB0b3AgKz0gdGFyZ2V0SGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xyXG5cdCAgICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0XHJcblx0ICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XHJcblx0ICAgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcclxuXHRcclxuXHQgICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICdtaWRkbGUnKSB7XHJcblx0ICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xyXG5cdCAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAodG9wIDwgYm91bmRzWzFdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcclxuXHQgICAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICBsZWZ0ICs9IHRhcmdldFdpZHRoO1xyXG5cdCAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xyXG5cdCAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RvZ2V0aGVyJykge1xyXG5cdCAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHRcclxuXHQgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHRcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSBlbHNlIGlmICh0QXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xyXG5cdCAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAnZWxlbWVudCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgdG9wICs9IGhlaWdodDtcclxuXHQgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgdG9wIC09IGhlaWdodDtcclxuXHQgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAnZWxlbWVudCcgfHwgY2hhbmdlQXR0YWNoWCA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSkge1xyXG5cdCAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHQgICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGggLyAyO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0pIHtcclxuXHQgICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHBpbiA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIHBpbiA9IHBpbi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkge1xyXG5cdCAgICAgICAgICByZXR1cm4gcC50cmltKCk7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICB9IGVsc2UgaWYgKHBpbiA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgICAgcGluID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgcGluID0gcGluIHx8IFtdO1xyXG5cdFxyXG5cdCAgICAgIHZhciBwaW5uZWQgPSBbXTtcclxuXHQgICAgICB2YXIgb29iID0gW107XHJcblx0XHJcblx0ICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSkge1xyXG5cdCAgICAgICAgaWYgKHBpbi5pbmRleE9mKCd0b3AnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHRvcCA9IGJvdW5kc1sxXTtcclxuXHQgICAgICAgICAgcGlubmVkLnB1c2goJ3RvcCcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgb29iLnB1c2goJ3RvcCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XHJcblx0ICAgICAgICBpZiAocGluLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcclxuXHQgICAgICAgICAgdG9wID0gYm91bmRzWzNdIC0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICBwaW5uZWQucHVzaCgnYm90dG9tJyk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICBvb2IucHVzaCgnYm90dG9tJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdKSB7XHJcblx0ICAgICAgICBpZiAocGluLmluZGV4T2YoJ2xlZnQnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIGxlZnQgPSBib3VuZHNbMF07XHJcblx0ICAgICAgICAgIHBpbm5lZC5wdXNoKCdsZWZ0Jyk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICBvb2IucHVzaCgnbGVmdCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XHJcblx0ICAgICAgICBpZiAocGluLmluZGV4T2YoJ3JpZ2h0JykgPj0gMCkge1xyXG5cdCAgICAgICAgICBsZWZ0ID0gYm91bmRzWzJdIC0gd2lkdGg7XHJcblx0ICAgICAgICAgIHBpbm5lZC5wdXNoKCdyaWdodCcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgb29iLnB1c2goJ3JpZ2h0Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChwaW5uZWQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICB2YXIgcGlubmVkQ2xhc3MgPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBwaW5uZWRDbGFzcyA9IF90aGlzLm9wdGlvbnMucGlubmVkQ2xhc3M7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgcGlubmVkQ2xhc3MgPSBfdGhpcy5nZXRDbGFzcygncGlubmVkJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzKTtcclxuXHQgICAgICAgICAgcGlubmVkLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gocGlubmVkQ2xhc3MgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAob29iLmxlbmd0aCkge1xyXG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgdmFyIG9vYkNsYXNzID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMub3V0T2ZCb3VuZHNDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBvb2JDbGFzcyA9IF90aGlzLm9wdGlvbnMub3V0T2ZCb3VuZHNDbGFzcztcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBvb2JDbGFzcyA9IF90aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKG9vYkNsYXNzKTtcclxuXHQgICAgICAgICAgb29iLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAocGlubmVkLmluZGV4T2YoJ2xlZnQnKSA+PSAwIHx8IHBpbm5lZC5pbmRleE9mKCdyaWdodCcpID49IDApIHtcclxuXHQgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSB0QXR0YWNobWVudC5sZWZ0ID0gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChwaW5uZWQuaW5kZXhPZigndG9wJykgPj0gMCB8fCBwaW5uZWQuaW5kZXhPZignYm90dG9tJykgPj0gMCkge1xyXG5cdCAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gdEF0dGFjaG1lbnQudG9wID0gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICh0QXR0YWNobWVudC50b3AgIT09IHRhcmdldEF0dGFjaG1lbnQudG9wIHx8IHRBdHRhY2htZW50LmxlZnQgIT09IHRhcmdldEF0dGFjaG1lbnQubGVmdCB8fCBlQXR0YWNobWVudC50b3AgIT09IF90aGlzLmF0dGFjaG1lbnQudG9wIHx8IGVBdHRhY2htZW50LmxlZnQgIT09IF90aGlzLmF0dGFjaG1lbnQubGVmdCkge1xyXG5cdCAgICAgICAgX3RoaXMudXBkYXRlQXR0YWNoQ2xhc3NlcyhlQXR0YWNobWVudCwgdEF0dGFjaG1lbnQpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICBpZiAoIShfdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xyXG5cdCAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzLmVsZW1lbnQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuXHQgIH1cclxuXHR9KTtcclxuXHQvKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcclxuXHR2YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xyXG5cdHZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcclxuXHR2YXIgZGVmZXIgPSBfVGV0aGVyQmFzZSRVdGlscy5kZWZlcjtcclxuXHRcclxuXHRUZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XHJcblx0ICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdFxyXG5cdCAgICB2YXIgX2NhY2hlID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xyXG5cdCAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XHJcblx0XHJcblx0ICAgIHZhciB0YXJnZXRQb3MgPSB0aGlzLmdldFRhcmdldEJvdW5kcygpO1xyXG5cdFxyXG5cdCAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xyXG5cdCAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XHJcblx0XHJcblx0ICAgIHZhciBhYnV0dGVkID0gW107XHJcblx0ICAgIGlmICh0b3AgPD0gdGFyZ2V0UG9zLmJvdHRvbSAmJiBib3R0b20gPj0gdGFyZ2V0UG9zLnRvcCkge1xyXG5cdCAgICAgIFsnbGVmdCcsICdyaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgIHZhciB0YXJnZXRQb3NTaWRlID0gdGFyZ2V0UG9zW3NpZGVdO1xyXG5cdCAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IGxlZnQgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gcmlnaHQpIHtcclxuXHQgICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmIChsZWZ0IDw9IHRhcmdldFBvcy5yaWdodCAmJiByaWdodCA+PSB0YXJnZXRQb3MubGVmdCkge1xyXG5cdCAgICAgIFsndG9wJywgJ2JvdHRvbSddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgIHZhciB0YXJnZXRQb3NTaWRlID0gdGFyZ2V0UG9zW3NpZGVdO1xyXG5cdCAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IHRvcCB8fCB0YXJnZXRQb3NTaWRlID09PSBib3R0b20pIHtcclxuXHQgICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBhbGxDbGFzc2VzID0gW107XHJcblx0ICAgIHZhciBhZGRDbGFzc2VzID0gW107XHJcblx0XHJcblx0ICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XHJcblx0ICAgIGFsbENsYXNzZXMucHVzaCh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpO1xyXG5cdCAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgYWxsQ2xhc3Nlcy5wdXNoKF90aGlzLmdldENsYXNzKCdhYnV0dGVkJykgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGlmIChhYnV0dGVkLmxlbmd0aCkge1xyXG5cdCAgICAgIGFkZENsYXNzZXMucHVzaCh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGFidXR0ZWQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xyXG5cdCAgICAgIGFkZENsYXNzZXMucHVzaChfdGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpICsgJy0nICsgc2lkZSk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBkZWZlcihmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgaWYgKCEoX3RoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfVxyXG5cdH0pO1xyXG5cdC8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcclxuXHRcclxuXHRUZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XHJcblx0ICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdFxyXG5cdCAgICBpZiAoIXRoaXMub3B0aW9ucy5zaGlmdCkge1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQ7XHJcblx0ICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNoaWZ0ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQuY2FsbCh0aGlzLCB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBzaGlmdFRvcCA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIHNoaWZ0TGVmdCA9IHVuZGVmaW5lZDtcclxuXHQgICAgaWYgKHR5cGVvZiBzaGlmdCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICBzaGlmdCA9IHNoaWZ0LnNwbGl0KCcgJyk7XHJcblx0ICAgICAgc2hpZnRbMV0gPSBzaGlmdFsxXSB8fCBzaGlmdFswXTtcclxuXHRcclxuXHQgICAgICB2YXIgX3NoaWZ0ID0gc2hpZnQ7XHJcblx0XHJcblx0ICAgICAgdmFyIF9zaGlmdDIgPSBfc2xpY2VkVG9BcnJheShfc2hpZnQsIDIpO1xyXG5cdFxyXG5cdCAgICAgIHNoaWZ0VG9wID0gX3NoaWZ0MlswXTtcclxuXHQgICAgICBzaGlmdExlZnQgPSBfc2hpZnQyWzFdO1xyXG5cdFxyXG5cdCAgICAgIHNoaWZ0VG9wID0gcGFyc2VGbG9hdChzaGlmdFRvcCwgMTApO1xyXG5cdCAgICAgIHNoaWZ0TGVmdCA9IHBhcnNlRmxvYXQoc2hpZnRMZWZ0LCAxMCk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgc2hpZnRUb3AgPSBzaGlmdC50b3A7XHJcblx0ICAgICAgc2hpZnRMZWZ0ID0gc2hpZnQubGVmdDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB0b3AgKz0gc2hpZnRUb3A7XHJcblx0ICAgIGxlZnQgKz0gc2hpZnRMZWZ0O1xyXG5cdFxyXG5cdCAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xyXG5cdCAgfVxyXG5cdH0pO1xyXG5cdHJldHVybiBUZXRoZXI7XHJcblx0XHJcblx0fSkpO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDYxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGV2ZW50VGFyZ2V0c0NvbXBvbmVudDogZnVuY3Rpb24gZXZlbnRUYXJnZXRzQ29tcG9uZW50KGV2ZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgaWYgKGV2ZW50VGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5pZCA9PT0gZXZlbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA2MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjx1bFxcbiAgICBjbGFzcz1cXFwidWktbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBAa2V5ZG93bi5lc2M9XFxcImNsb3NlRHJvcGRvd25cXFwiIHYtZWw6ZHJvcGRvd25cXG4gICAgOmNsYXNzPVxcXCJ7ICdoYXMtaWNvbnMnOiBzaG93SWNvbnMsICdoYXMtc2Vjb25kYXJ5LXRleHQnOiBzaG93U2Vjb25kYXJ5VGV4dCB9XFxcIlxcbj5cXG4gICAgPHVpLW1lbnUtb3B0aW9uXFxuICAgICAgICA6dHlwZT1cXFwib3B0aW9uLnR5cGVcXFwiIDppY29uPVxcXCJvcHRpb24uaWNvblxcXCIgOnRleHQ9XFxcIm9wdGlvbi50ZXh0XFxcIiA6ZGlzYWJsZWQ9XFxcIm9wdGlvbi5kaXNhYmxlZFxcXCJcXG4gICAgICAgIDpzZWNvbmRhcnktdGV4dD1cXFwib3B0aW9uLnNlY29uZGFyeVRleHRcXFwiIDpvcHRpb249XFxcIm9wdGlvblxcXCIgOnNob3ctaWNvbj1cXFwic2hvd0ljb25zXFxcIlxcbiAgICAgICAgOnNob3ctc2Vjb25kYXJ5LXRleHQ9XFxcInNob3dTZWNvbmRhcnlUZXh0XFxcIiA6aGlkZS1yaXBwbGUtaW5rPVxcXCJoaWRlUmlwcGxlSW5rXFxcIlxcbiAgICAgICAgOnBhcnRpYWw9XFxcIm9wdGlvbi5wYXJ0aWFsIHx8IHBhcnRpYWxcXFwiXFxuXFxuICAgICAgICBAa2V5ZG93bi5lbnRlci5wcmV2ZW50PVxcXCJvcHRpb25TZWxlY3Qob3B0aW9uKVxcXCIgQGNsaWNrPVxcXCJvcHRpb25TZWxlY3Qob3B0aW9uKVxcXCJcXG5cXG4gICAgICAgIHYtZm9yPVxcXCJvcHRpb24gaW4gb3B0aW9uc1xcXCJcXG4gICAgPjwvdWktbWVudS1vcHRpb24+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1tZW51LWZvY3VzLXJlZGlyZWN0b3JcXFwiIEBmb2N1cz1cXFwicmVkaXJlY3RGb2N1c1xcXCIgdGFiaW5kZXg9XFxcIjBcXFwiXFxuICAgID48L2Rpdj5cXG48L3VsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNjMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjQpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUG9wb3Zlci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUG9wb3Zlci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogNjQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NEcm9wZG93biA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NEcm9wZG93bjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c0Ryb3Bkb3duKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXBvcG92ZXInLFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICdkcm9wZG93bi1vcGVuZWQnOiBmdW5jdGlvbiBkcm9wZG93bk9wZW5lZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250YWluRm9jdXMpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgJ2Ryb3Bkb3duLWNsb3NlZCc6IGZ1bmN0aW9uIGRyb3Bkb3duQ2xvc2VkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5Gb2N1cykge1xyXG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMucmVzdHJpY3RGb2N1cywgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgcmVzdHJpY3RGb2N1czogZnVuY3Rpb24gcmVzdHJpY3RGb2N1cyhlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRlbHMuZHJvcGRvd24uY29udGFpbnMoZS50YXJnZXQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGVscy5kcm9wZG93bi5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1Nob3dzRHJvcGRvd24yLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDY2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcG9wb3ZlclxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIEBrZXlkb3duLmVzYz1cXFwiY2xvc2VEcm9wZG93blxcXCIgdi1lbDpkcm9wZG93blxcbj5cXG4gICAgPHNsb3Q+PC9zbG90PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNjcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjgpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUHJvZ3Jlc3NDaXJjdWxhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUHJvZ3Jlc3NDaXJjdWxhci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogNjggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXByb2dyZXNzLWNpcmN1bGFyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnaW5kZXRlcm1pbmF0ZScgfSxcclxuXHQgICAgICAgIGNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5JyB9LFxyXG5cdCAgICAgICAgdmFsdWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNpemU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMzJcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdHJva2U6IE51bWJlcixcclxuXHQgICAgICAgIGF1dG9TdHJva2U6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlVHJhbnNpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHN0cm9rZURhc2hBcnJheTogZnVuY3Rpb24gc3Ryb2tlRGFzaEFycmF5KCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cztcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjaXJjdW1mZXJlbmNlICogMTAwMCkgLyAxMDAwO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIHN0cm9rZURhc2hPZmZzZXQoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlcmF0ZVZhbHVlKHRoaXMudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIHZhciBjaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cztcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gKDEwMCAtIHZhbHVlKSAvIDEwMCAqIGNpcmN1bWZlcmVuY2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcmFkaXVzOiBmdW5jdGlvbiByYWRpdXMoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNpemUgLSB0aGlzLnN0cm9rZSkgLyAyO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLnN0cm9rZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmF1dG9TdHJva2UpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBwYXJzZUludCh0aGlzLnNpemUgLyA4LCAxMCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSA0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgbW9kZXJhdGVWYWx1ZTogZnVuY3Rpb24gbW9kZXJhdGVWYWx1ZSh2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPiAxMDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDcwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtY2lyY3VsYXJcXFwiIDpzdHlsZT1cXFwieyAnd2lkdGgnOiBzaXplICsgJ3B4JywgJ2hlaWdodCc6IHNpemUgKyAncHgnIH1cXFwiXFxuICAgIHYtc2hvdz1cXFwic2hvd1xcXCIgOnRyYW5zaXRpb249XFxcImRpc2FibGVUcmFuc2l0aW9uID8gbnVsbCA6ICd1aS1wcm9ncmVzcy1jaXJjdWxhci10b2dnbGUnXFxcIlxcbj5cXG4gICAgPHN2Z1xcbiAgICAgICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyLWRldGVybWluYXRlXFxcIiA6d2lkdGg9XFxcInNpemVcXFwiIDpoZWlnaHQ9XFxcInNpemVcXFwiXFxuICAgICAgICByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgOmFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIDphcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIDphcmlhLXZhbHVlbm93PVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgIHYtaWY9XFxcInR5cGUgPT09ICdkZXRlcm1pbmF0ZSdcXFwiXFxuICAgID5cXG4gICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtY2lyY3VsYXItZGV0ZXJtaW5hdGUtcGF0aFxcXCIgOmNsYXNzPVxcXCJbY29sb3JdXFxcIiA6cj1cXFwicmFkaXVzXFxcIlxcbiAgICAgICAgICAgIDpjeD1cXFwic2l6ZSAvIDJcXFwiIDpjeT1cXFwic2l6ZSAvIDJcXFwiIGZpbGw9XFxcInRyYW5zcGFyZW50XFxcIiA6c3Ryb2tlLWRhc2hhcnJheT1cXFwic3Ryb2tlRGFzaEFycmF5XFxcIlxcbiAgICAgICAgICAgIHN0cm9rZS1kYXNob2Zmc2V0PVxcXCIwXFxcIlxcblxcbiAgICAgICAgICAgIDpzdHlsZT1cXFwieyAnc3Ryb2tlLWRhc2hvZmZzZXQnOiBzdHJva2VEYXNoT2Zmc2V0LCAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlIH1cXFwiXFxuICAgICAgICA+PC9jaXJjbGU+XFxuICAgIDwvc3ZnPlxcblxcbiAgICA8c3ZnXFxuICAgICAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtY2lyY3VsYXItaW5kZXRlcm1pbmF0ZVxcXCIgdmlld0JveD1cXFwiMjUgMjUgNTAgNTBcXFwiXFxuICAgICAgICByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgOmFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIDphcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIHYtZWxzZVxcbiAgICA+XFxuICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyLWluZGV0ZXJtaW5hdGUtcGF0aFxcXCIgOmNsYXNzPVxcXCJbY29sb3JdXFxcIiBjeD1cXFwiNTBcXFwiIGN5PVxcXCI1MFxcXCJcXG4gICAgICAgICAgICByPVxcXCIyMFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlLW1pdGVybGltaXQ9XFxcIjEwXFxcIiA6c3Ryb2tlLXdpZHRoPVxcXCJzdHJva2VcXFwiXFxuICAgICAgICA+XFxuICAgIDwvc3ZnPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICB0aGlzLmVsLmRpc2FibGVkID0gQm9vbGVhbih2YWx1ZSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDcyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgb3BlbkRyb3Bkb3duT246IFN0cmluZyxcclxuXHQgICAgICAgIGRyb3Bkb3duUG9zaXRpb246IFN0cmluZyxcclxuXHQgICAgICAgIGhhc1BvcG92ZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGFzRHJvcGRvd25NZW51OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1lbnVPcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd01lbnVJY29uczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93TWVudVNlY29uZGFyeVRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIG1lbnVPcHRpb25TZWxlY3Q6IGZ1bmN0aW9uIG1lbnVPcHRpb25TZWxlY3Qob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21lbnUtb3B0aW9uLXNlbGVjdGVkJywgb3B0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XHJcblx0XHJcblx0dmFyIF9VaVRvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUb29sdGlwKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHRvb2x0aXA6IFN0cmluZyxcclxuXHQgICAgICAgIG9wZW5Ub29sdGlwT246IFN0cmluZyxcclxuXHQgICAgICAgIHRvb2x0aXBQb3NpdGlvbjogU3RyaW5nXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpVG9vbHRpcDogX1VpVG9vbHRpcDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDc0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NilcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVRvb2x0aXAudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRvb2x0aXAudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDc1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogNzYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3RldGhlclRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KTtcclxuXHRcclxuXHR2YXIgX3RldGhlclRvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV0aGVyVG9vbHRpcCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10b29sdGlwJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGNvbnRlbnQ6IFN0cmluZyxcclxuXHQgICAgICAgIHRyaWdnZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBFbGVtZW50LFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcG9zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2JvdHRvbSBjZW50ZXInXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3Blbk9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdob3ZlciBmb2N1cydcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdG9vbHRpcDogbnVsbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdG9yeTogZnVuY3Rpb24gYmVmb3JlRGVzdG9yeSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvb2x0aXApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvb2x0aXAucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy50b29sdGlwLmRlc3Ryb3koKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBfdGV0aGVyVG9vbHRpcDIuZGVmYXVsdCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMudHJpZ2dlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuJGVscy50b29sdGlwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogJ3VpLXRvb2x0aXAtdGhlbWUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvcGVuT246ICdob3ZlciBmb2N1cydcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDc3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgdGV0aGVyLXRvb2x0aXAgMS4xLjAgKi9cclxuXHRcclxuXHQoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdCAgaWYgKHRydWUpIHtcclxuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oNTkpLF9fd2VicGFja19yZXF1aXJlX18oNjApXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XHJcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgndGV0aGVyLWRyb3AnKSwgcmVxdWlyZSgndGV0aGVyJykpO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcm9vdC5Ub29sdGlwID0gZmFjdG9yeShyb290LkRyb3AsIHJvb3QuVGV0aGVyKTtcclxuXHQgIH1cclxuXHR9KHRoaXMsIGZ1bmN0aW9uKERyb3AsIFRldGhlcikge1xyXG5cdFxyXG5cdC8qIGdsb2JhbCBUZXRoZXIgRHJvcCAqL1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxyXG5cdFxyXG5cdHZhciBleHRlbmQgPSBUZXRoZXIuVXRpbHMuZXh0ZW5kO1xyXG5cdFxyXG5cdHZhciBfRHJvcCA9IERyb3AuY3JlYXRlQ29udGV4dCh7XHJcblx0ICBjbGFzc1ByZWZpeDogJ3Rvb2x0aXAnXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdCAgcG9zaXRpb246ICd0b3AgY2VudGVyJyxcclxuXHQgIG9wZW5PbjogJ2hvdmVyJyxcclxuXHQgIGNsYXNzZXM6ICd0b29sdGlwLXRoZW1lLWFycm93cycsXHJcblx0ICBjb25zdHJhaW5Ub1dpbmRvdzogdHJ1ZSxcclxuXHQgIGNvbnN0cmFpblRvU2Nyb2xsUGFyZW50OiBmYWxzZVxyXG5cdH07XHJcblx0XHJcblx0dmFyIHRvb2x0aXBDb3VudCA9IDA7XHJcblx0XHJcblx0dmFyIFRvb2x0aXAgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgZnVuY3Rpb24gVG9vbHRpcChvcHRpb25zKSB7XHJcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcclxuXHRcclxuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMudGFyZ2V0KSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sdGlwIEVycm9yOiBZb3UgbXVzdCBwcm92aWRlIGEgdGFyZ2V0IGZvciBUb29sdGlwIHRvIGF0dGFjaCB0bycpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAtcG9zaXRpb24nKTtcclxuXHQgICAgaWYgKHBvc2l0aW9uKSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwJyk7XHJcblx0XHJcblx0ICAgIGlmIChjb250ZW50KSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHZhciBjb250ZW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHQgICAgICAgIGNvbnRlbnRFbC5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFxyXG5cdCAgICAgICAgLy8gQWRkIEFSSUEgYXR0cmlidXRlcyAoc2VlICM1MClcclxuXHQgICAgICAgIGNvbnRlbnRFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xyXG5cdCAgICAgICAgY29udGVudEVsLmlkID0gJ2Ryb3AtdG9vbHRpcC0nICsgdG9vbHRpcENvdW50O1xyXG5cdCAgICAgICAgdGhpcy5vcHRpb25zLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCBjb250ZW50RWwuaWQpO1xyXG5cdCAgICAgICAgdG9vbHRpcENvdW50ICs9IDE7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudCA9IGNvbnRlbnRFbDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29udGVudCkge1xyXG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbHRpcCBFcnJvcjogWW91IG11c3QgcHJvdmlkZSBjb250ZW50IGZvciBUb29sdGlwIHRvIGRpc3BsYXknKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCB0aGlzLm9wdGlvbnMpO1xyXG5cdFxyXG5cdCAgICB0aGlzLmRyb3AgPSBuZXcgX0Ryb3AodGhpcy5vcHRpb25zKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xyXG5cdCAgICBrZXk6ICdjbG9zZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcclxuXHQgICAgICB0aGlzLmRyb3AuY2xvc2UoKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdvcGVuJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XHJcblx0ICAgICAgdGhpcy5kcm9wLm9wZW4oKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICd0b2dnbGUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xyXG5cdCAgICAgIHRoaXMuZHJvcC50b2dnbGUoKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdyZW1vdmUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG5cdCAgICAgIHRoaXMuZHJvcC5yZW1vdmUoKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdkZXN0cm95JyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcblx0ICAgICAgdGhpcy5kcm9wLmRlc3Ryb3koKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdwb3NpdGlvbicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcclxuXHQgICAgICB0aGlzLmRyb3AucG9zaXRpb24oKTtcclxuXHQgICAgfVxyXG5cdCAgfV0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIFRvb2x0aXA7XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgaW5pdGlhbGl6ZWQgPSBbXTtcclxuXHRcclxuXHRUb29sdGlwLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICB2YXIgdG9vbHRpcEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdG9vbHRpcF0nKTtcclxuXHQgIHZhciBsZW4gPSB0b29sdGlwRWxlbWVudHMubGVuZ3RoO1xyXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG5cdCAgICB2YXIgZWwgPSB0b29sdGlwRWxlbWVudHNbaV07XHJcblx0ICAgIGlmIChpbml0aWFsaXplZC5pbmRleE9mKGVsKSA9PT0gLTEpIHtcclxuXHQgICAgICBuZXcgVG9vbHRpcCh7XHJcblx0ICAgICAgICB0YXJnZXQ6IGVsXHJcblx0ICAgICAgfSk7XHJcblx0ICAgICAgaW5pdGlhbGl6ZWQucHVzaChlbCk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICBpZiAoVG9vbHRpcC5hdXRvaW5pdCAhPT0gZmFsc2UpIHtcclxuXHQgICAgVG9vbHRpcC5pbml0KCk7XHJcblx0ICB9XHJcblx0fSk7XHJcblx0cmV0dXJuIFRvb2x0aXA7XHJcblx0XHJcblx0fSkpO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDc4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktdG9vbHRpcFxcXCIgdi10ZXh0PVxcXCJjb250ZW50XFxcIiB2LWVsOnRvb2x0aXA+PC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxidXR0b25cXG4gICAgY2xhc3M9XFxcInVpLWljb24tYnV0dG9uXFxcIiA6Y2xhc3M9XFxcInN0eWxlQ2xhc3Nlc1xcXCIgOmFyaWEtbGFiZWw9XFxcImFyaWFMYWJlbCB8fCB0b29sdGlwXFxcIlxcbiAgICA6dHlwZT1cXFwiYnV0dG9uVHlwZVxcXCIgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWQgfHwgbG9hZGluZ1xcXCIgdi1lbDpidXR0b25cXG4+XFxuICAgIDx1aS1pY29uXFxuICAgICAgICBjbGFzcz1cXFwidWktaWNvbi1idXR0b24taWNvblxcXCIgOmljb249XFxcImljb25cXFwiIHYtc2hvdz1cXFwiIWxvYWRpbmdcXFwiXFxuICAgID48L3VpLWljb24+XFxuXFxuICAgIDx1aS1wcm9ncmVzcy1jaXJjdWxhclxcbiAgICAgICAgY2xhc3M9XFxcInVpLWljb24tYnV0dG9uLXNwaW5uZXJcXFwiIDpjb2xvcj1cXFwic3Bpbm5lckNvbG9yXFxcIiA6c2l6ZT1cXFwiMjRcXFwiIDpzdHJva2U9XFxcIjQuNVxcXCJcXG4gICAgICAgIGRpc2FibGUtdHJhbnNpdGlvbiB2LXNob3c9XFxcImxvYWRpbmdcXFwiXFxuICAgID48L3VpLXByb2dyZXNzLWNpcmN1bGFyPlxcblxcbiAgICA8dWktcmlwcGxlLWluayB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCI+PC91aS1yaXBwbGUtaW5rPlxcblxcbiAgICA8dWktdG9vbHRpcFxcbiAgICAgICAgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiA6Y29udGVudD1cXFwidG9vbHRpcFxcXCIgOnBvc2l0aW9uPVxcXCJ0b29sdGlwUG9zaXRpb25cXFwiIHYtaWY9XFxcInRvb2x0aXBcXFwiXFxuICAgICAgICA6b3Blbi1vbj1cXFwib3BlblRvb2x0aXBPblxcXCJcXG4gICAgPjwvdWktdG9vbHRpcD5cXG5cXG4gICAgPHVpLW1lbnVcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1idXR0b24tZHJvcGRvd24tbWVudVxcXCIgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiA6b3B0aW9ucz1cXFwibWVudU9wdGlvbnNcXFwiXFxuICAgICAgICA6c2hvdy1pY29ucz1cXFwic2hvd01lbnVJY29uc1xcXCIgOnNob3ctc2Vjb25kYXJ5LXRleHQ9XFxcInNob3dNZW51U2Vjb25kYXJ5VGV4dFxcXCJcXG4gICAgICAgIDpvcGVuLW9uPVxcXCJvcGVuRHJvcGRvd25PblxcXCIgQG9wdGlvbi1zZWxlY3RlZD1cXFwibWVudU9wdGlvblNlbGVjdFxcXCJcXG4gICAgICAgIDpkcm9wZG93bi1wb3NpdGlvbj1cXFwiZHJvcGRvd25Qb3NpdGlvblxcXCIgdi1pZj1cXFwiaGFzRHJvcGRvd25NZW51XFxcIlxcbiAgICA+PC91aS1tZW51PlxcblxcbiAgICA8dWktcG9wb3ZlclxcbiAgICAgICAgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiA6b3Blbi1vbj1cXFwib3BlbkRyb3Bkb3duT25cXFwiIDpkcm9wZG93bi1wb3NpdGlvbj1cXFwiZHJvcGRvd25Qb3NpdGlvblxcXCJcXG4gICAgICAgIHYtaWY9XFxcImhhc1BvcG92ZXJcXFwiXFxuICAgID5cXG4gICAgICAgIDxzbG90IG5hbWU9XFxcInBvcG92ZXJcXFwiPjwvc2xvdD5cXG4gICAgPC91aS1wb3BvdmVyPlxcbjwvYnV0dG9uPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogODAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ1aS1hbGVydFxcXCI+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1hbGVydC1ib2R5XFxcIiA6Y2xhc3M9XFxcIlt0eXBlXVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiIHYtc2hvdz1cXFwic2hvd1xcXCJcXG4gICAgICAgIHRyYW5zaXRpb249XFxcInVpLWFsZXJ0LXRvZ2dsZVxcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLWljb24gY2xhc3M9XFxcInVpLWFsZXJ0LWljb25cXFwiIDppY29uPVxcXCJpY29uTmFtZVxcXCIgdi1pZj1cXFwiIWhpZGVJY29uXFxcIj48L3VpLWljb24+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1hbGVydC10ZXh0XFxcIj5cXG4gICAgICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJ0ZXh0XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktYWxlcnQtY2xvc2UtYnV0dG9uXFxcIiB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiJiN4RTVDRFxcXCIgYXJpYS1sYWJlbD1cXFwiQ2xvc2VcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJjbG9zZVxcXCIgdi1pZj1cXFwiZGlzbWlzc2libGVcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg4MilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlBdXRvY29tcGxldGUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlBdXRvY29tcGxldGUudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDgyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogODMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2Z1enp5c2VhcmNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XHJcblx0XHJcblx0dmFyIF9mdXp6eXNlYXJjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mdXp6eXNlYXJjaCk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcclxuXHRcclxuXHR2YXIgX1VpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24pO1xyXG5cdFxyXG5cdHZhciBfYXV0b2ZvY3VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XHJcblx0XHJcblx0dmFyIF9hdXRvZm9jdXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXV0b2ZvY3VzKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc1RleHRJbnB1dCk7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdGVzSW5wdXQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktYXV0b2NvbXBsZXRlJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHN1Z2dlc3Rpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogW11cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsaW1pdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiA4XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGFydGlhbDogU3RyaW5nLFxyXG5cdCAgICAgICAgYXBwZW5kOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGFwcGVuZERlbGltaXRlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnLCAnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbWluQ2hhcnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMlxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dPblVwRG93bjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGF1dG9mb2N1czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmaWx0ZXI6IEZ1bmN0aW9uLFxyXG5cdCAgICAgICAgYXV0b0hpZ2hsaWdodEZpcnN0TWF0Y2g6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjeWNsZUhpZ2hsaWdodDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAndGV4dCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIGltYWdlOiAnaW1hZ2UnXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaG93RHJvcGRvd246IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGhpZ2hsaWdodGVkSXRlbTogLTEsXHJcblx0ICAgICAgICAgICAgaWdub3JlVmFsdWVDaGFuZ2U6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ljb246IGZ1bmN0aW9uIHNob3dJY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaWNvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJGVscy5pbnB1dCkge1xyXG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaWdub3JlVmFsdWVDaGFuZ2UgJiYgdGhpcy52YWx1ZS5sZW5ndGggPj0gdGhpcy5taW5DaGFycykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSB0aGlzLmF1dG9IaWdobGlnaHRGaXJzdE1hdGNoID8gMCA6IC0xO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2spO1xyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2goaXRlbSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaXRlbSwgdGhpcy52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciB0ZXh0ID0gaXRlbVt0aGlzLmtleXMudGV4dF0gfHwgaXRlbTtcclxuXHQgICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnZhbHVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfZnV6enlzZWFyY2gyLmRlZmF1bHQpKHF1ZXJ5LCB0ZXh0LnRvTG93ZXJDYXNlKCkpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGl0ZW0pIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IHRoaXMuYXBwZW5kRGVsaW1pdGVyICsgKGl0ZW1bdGhpcy5rZXlzLnZhbHVlXSB8fCBpdGVtKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gaXRlbVt0aGlzLmtleXMudmFsdWVdIHx8IGl0ZW07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzZWxlY3RlZCcsIGl0ZW0pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzLiRlbHMuaW5wdXQuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChpbmRleCkge1xyXG5cdCAgICAgICAgICAgIHZhciBmaXJzdEluZGV4ID0gMDtcclxuXHQgICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy4kcmVmcy5pdGVtcy5sZW5ndGggLSAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTIpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IGZpcnN0SW5kZXgpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmN5Y2xlSGlnaGxpZ2h0ID8gbGFzdEluZGV4IDogaW5kZXg7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuY3ljbGVIaWdobGlnaHQgPyBmaXJzdEluZGV4IDogLTE7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gaW5kZXg7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd09uVXBEb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoaW5kZXggPCBmaXJzdEluZGV4IHx8IGluZGV4ID4gbGFzdEluZGV4KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdoaWdobGlnaHQtb3ZlcmZsb3cnLCBpbmRleCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2hpZ2hsaWdodGVkJywgdGhpcy4kcmVmcy5pdGVtc1tpbmRleF0uaXRlbSwgaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWxlY3RIaWdobGlnaHRlZDogZnVuY3Rpb24gc2VsZWN0SGlnaGxpZ2h0ZWQoaW5kZXgsIGUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24gJiYgdGhpcy4kcmVmcy5pdGVtcy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLiRyZWZzLml0ZW1zW2luZGV4XS5pdGVtKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xlYXJTZWFyY2g6IGZ1bmN0aW9uIGNsZWFyU2VhcmNoKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSAtMTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Nsb3NlZCcpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsb3NlT25FeHRlcm5hbENsaWNrOiBmdW5jdGlvbiBjbG9zZU9uRXh0ZXJuYWxDbGljayhlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRlbHMuYXV0b2NvbXBsZXRlLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiB0aGlzLnNob3dEcm9wZG93bikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdCxcclxuXHQgICAgICAgIFVpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbjogX1VpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBhdXRvZm9jdXM6IF9hdXRvZm9jdXMyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc1RleHRJbnB1dDIuZGVmYXVsdCwgX1ZhbGlkYXRlc0lucHV0Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGZ1enp5c2VhcmNoIChuZWVkbGUsIGhheXN0YWNrKSB7XHJcblx0ICB2YXIgdGxlbiA9IGhheXN0YWNrLmxlbmd0aDtcclxuXHQgIHZhciBxbGVuID0gbmVlZGxlLmxlbmd0aDtcclxuXHQgIGlmIChxbGVuID4gdGxlbikge1xyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0ICBpZiAocWxlbiA9PT0gdGxlbikge1xyXG5cdCAgICByZXR1cm4gbmVlZGxlID09PSBoYXlzdGFjaztcclxuXHQgIH1cclxuXHQgIG91dGVyOiBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBxbGVuOyBpKyspIHtcclxuXHQgICAgdmFyIG5jaCA9IG5lZWRsZS5jaGFyQ29kZUF0KGkpO1xyXG5cdCAgICB3aGlsZSAoaiA8IHRsZW4pIHtcclxuXHQgICAgICBpZiAoaGF5c3RhY2suY2hhckNvZGVBdChqKyspID09PSBuY2gpIHtcclxuXHQgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdXp6eXNlYXJjaDtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg4NilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODcpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlBdXRvY29tcGxldGVTdWdnZXN0aW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODkpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlBdXRvY29tcGxldGVTdWdnZXN0aW9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDg3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF91dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XHJcblx0XHJcblx0dmFyIF91dWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V1aWQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdXVpZDIuZGVmYXVsdC5zaG9ydCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpdGVtOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLWF1dG9jb21wbGV0ZS1zaW1wbGUnIH0sXHJcblx0ICAgICAgICBoaWdobGlnaHRlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBrZXlzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3RleHQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd2YWx1ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbWFnZTogJ2ltYWdlJ1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcGFydGlhbHM6IHtcclxuXHQgICAgICAgICd1aS1hdXRvY29tcGxldGUtc2ltcGxlJzogJ1xcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uLWl0ZW1cIiB2LXRleHQ9XCJpdGVtW2tleXMudGV4dF0gfHwgaXRlbVwiPjwvbGk+XFxuICAgICAgICAnLFxyXG5cdFxyXG5cdCAgICAgICAgJ3VpLWF1dG9jb21wbGV0ZS1pbWFnZSc6ICdcXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiaW1hZ2VcIiA6c3R5bGU9XCJ7IFxcJ2JhY2tncm91bmQtaW1hZ2VcXCc6IFxcJ3VybChcXCcgKyBpdGVtW2tleXMuaW1hZ2VdICsgXFwnKVxcJyB9XCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHRcIiB2LXRleHQ9XCJpdGVtW2tleXMudGV4dF1cIj48L2Rpdj5cXG4gICAgICAgICdcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdC8qKlxyXG5cdCAqIEZhc3QgVVVJRCBnZW5lcmF0b3IsIFJGQzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudC5cclxuXHQgKiBAYXV0aG9yIEplZmYgV2FyZCAoamN3YXJkLmNvbSkuXHJcblx0ICogQGxpY2Vuc2UgTUlUIGxpY2Vuc2VcclxuXHQgKiBAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcclxuXHQgKiovXHJcblx0XHJcblx0dmFyIGx1dCA9IFtdO1xyXG5cdFxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuXHQgICAgbHV0W2ldID0gKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcclxuXHQgICAgdmFyIGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdCAgICB2YXIgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0ICAgIHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHQgICAgdmFyIGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gbHV0W2QwICYgMHhmZl0gKyBsdXRbZDAgPj4gOCAmIDB4ZmZdICsgbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBsdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArIGx1dFtkMSAmIDB4ZmZdICsgbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIGx1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIGx1dFtkMSA+PiAyNCAmIDB4ZmZdICsgJy0nICsgbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIGx1dFtkMiA+PiAxNiAmIDB4ZmZdICsgbHV0W2QyID4+IDI0ICYgMHhmZl0gKyBsdXRbZDMgJiAweGZmXSArIGx1dFtkMyA+PiA4ICYgMHhmZl0gKyBsdXRbZDMgPj4gMTYgJiAweGZmXSArIGx1dFtkMyA+PiAyNCAmIDB4ZmZdO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIHNob3J0ID0gZnVuY3Rpb24gc2hvcnQocHJlZml4KSB7XHJcblx0ICAgIHByZWZpeCA9IHByZWZpeCB8fCAnJztcclxuXHRcclxuXHQgICAgdmFyIHV1aWQgPSBnZW5lcmF0ZSgpO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gcHJlZml4ICsgdXVpZC5zcGxpdCgnLScpWzBdO1xyXG5cdH07XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBnZW5lcmF0ZTogZ2VuZXJhdGUsXHJcblx0ICAgIHNob3J0OiBzaG9ydFxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsaVxcbiAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb25cXFwiIDpjbGFzcz1cXFwiW3BhcnRpYWwsIHsgJ2hpZ2hsaWdodGVkJzogaGlnaGxpZ2h0ZWQgfV1cXFwiXFxuICAgIDppZD1cXFwiaWRcXFwiXFxuPlxcbiAgICA8cGFydGlhbCA6bmFtZT1cXFwicGFydGlhbFxcXCI+PC9wYXJ0aWFsPlxcbjwvbGk+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA5MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgIHRoaXMuZWwuYXV0b2ZvY3VzID0gQm9vbGVhbih2YWx1ZSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDkxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBuYW1lOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnJyxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpY29uOiBTdHJpbmcsXHJcblx0ICAgICAgICBpY29uUmlnaHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoZWxwVGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVib3VuY2U6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93RmVlZGJhY2s6IGZ1bmN0aW9uIHNob3dGZWVkYmFjaygpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2FuQmVWYWxpZGF0ZWQgPSBCb29sZWFuKHRoaXMudmFsaWRhdGlvblJ1bGVzKTtcclxuXHQgICAgICAgICAgICB2YXIgaGFzSGVscFRleHQgPSBCb29sZWFuKHRoaXMuaGVscFRleHQpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjYW5CZVZhbGlkYXRlZCB8fCBoYXNIZWxwVGV4dDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA5MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdmFsaWRhdG9yanMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcclxuXHRcclxuXHR2YXIgX3ZhbGlkYXRvcmpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkYXRvcmpzKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHZhbGlkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpcnR5OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlVmFsaWRhdGlvbkVycm9yczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB2YWxpZGF0aW9uUnVsZXM6IFtTdHJpbmcsIEFycmF5XSxcclxuXHQgICAgICAgIHZhbGlkYXRpb25NZXNzYWdlczogT2JqZWN0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcjogJydcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpzZXQtdmFsaWRpdHknOiBmdW5jdGlvbiB1aUlucHV0U2V0VmFsaWRpdHkodmFsaWQsIGVycm9yLCBpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWxpZGl0eSh2YWxpZCwgZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRpb25SdWxlcyB8fCAhdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIHJ1bGVzID0ge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWxpZGF0aW9uUnVsZXNcclxuXHQgICAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uID0gbmV3IF92YWxpZGF0b3JqczIuZGVmYXVsdChkYXRhLCBydWxlcywgdGhpcy52YWxpZGF0aW9uTWVzc2FnZXMpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhbGlkYXRpb24uc2V0QXR0cmlidXRlTmFtZXMoeyB2YWx1ZTogdGhpcy5uYW1lLnJlcGxhY2UoL18vZywgJyAnKSB9KTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbGlkaXR5KHZhbGlkYXRpb24ucGFzc2VzKCksIHZhbGlkYXRpb24uZXJyb3JzLmZpcnN0KCd2YWx1ZScpKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZXRWYWxpZGl0eTogZnVuY3Rpb24gc2V0VmFsaWRpdHkodmFsaWQsIGVycm9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZCA9IHZhbGlkO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdmFsaWQgJiYgZXJyb3IgJiYgZXJyb3IubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yID0gZXJyb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDkzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgUnVsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcclxuXHR2YXIgTGFuZyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xyXG5cdHZhciBFcnJvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNik7XHJcblx0dmFyIEF0dHJpYnV0ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcclxuXHR2YXIgQXN5bmNSZXNvbHZlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XHJcblx0XHJcblx0dmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uKGlucHV0LCBydWxlcywgY3VzdG9tTWVzc2FnZXMpIHtcclxuXHQgIHZhciBsYW5nID0gVmFsaWRhdG9yLmdldERlZmF1bHRMYW5nKCk7XHJcblx0ICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcblx0ICB0aGlzLm1lc3NhZ2VzID0gTGFuZy5fbWFrZShsYW5nKTtcclxuXHQgIHRoaXMubWVzc2FnZXMuX3NldEN1c3RvbShjdXN0b21NZXNzYWdlcyk7XHJcblx0ICB0aGlzLnNldEF0dHJpYnV0ZUZvcm1hdHRlcihWYWxpZGF0b3IucHJvdG90eXBlLmF0dHJpYnV0ZUZvcm1hdHRlcik7XHJcblx0XHJcblx0ICB0aGlzLmVycm9ycyA9IG5ldyBFcnJvcnMoKTtcclxuXHQgIHRoaXMuZXJyb3JDb3VudCA9IDA7XHJcblx0XHJcblx0ICB0aGlzLmhhc0FzeW5jID0gZmFsc2U7XHJcblx0ICB0aGlzLnJ1bGVzID0gdGhpcy5fcGFyc2VSdWxlcyhydWxlcyk7XHJcblx0fTtcclxuXHRcclxuXHRWYWxpZGF0b3IucHJvdG90eXBlID0ge1xyXG5cdFxyXG5cdCAgY29uc3RydWN0b3I6IFZhbGlkYXRvcixcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGVmYXVsdCBsYW5ndWFnZVxyXG5cdCAgICpcclxuXHQgICAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIGxhbmc6ICdlbicsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIE51bWVyaWMgYmFzZWQgcnVsZXNcclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7YXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIG51bWVyaWNSdWxlczogWydpbnRlZ2VyJywgJ251bWVyaWMnXSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQXR0cmlidXRlIGZvcm1hdHRlci5cclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcblx0ICAgKi9cclxuXHQgIGF0dHJpYnV0ZUZvcm1hdHRlcjogQXR0cmlidXRlcy5mb3JtYXR0ZXIsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJ1biB2YWxpZGF0b3JcclxuXHQgICAqXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGl0IHBhc3NlczsgdHJ1ZSA9IHBhc3NlcywgZmFsc2UgPSBmYWlsc1xyXG5cdCAgICovXHJcblx0ICBjaGVjazogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHZhciBzZWxmID0gdGhpcztcclxuXHRcclxuXHQgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIHRoaXMucnVsZXMpIHtcclxuXHQgICAgICB2YXIgYXR0cmlidXRlUnVsZXMgPSB0aGlzLnJ1bGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLmlucHV0W2F0dHJpYnV0ZV07IC8vIGlmIGl0IGRvZXNudCBleGlzdCBpbiBpbnB1dCwgaXQgd2lsbCBiZSB1bmRlZmluZWRcclxuXHRcclxuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXR0cmlidXRlUnVsZXMubGVuZ3RoLCBydWxlLCBydWxlT3B0aW9ucywgcnVsZVBhc3NlZDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgICBydWxlT3B0aW9ucyA9IGF0dHJpYnV0ZVJ1bGVzW2ldO1xyXG5cdCAgICAgICAgcnVsZSA9IHRoaXMuZ2V0UnVsZShydWxlT3B0aW9ucy5uYW1lKTtcclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5faXNWYWxpZGF0YWJsZShydWxlLCBpbnB1dFZhbHVlKSkge1xyXG5cdCAgICAgICAgICBjb250aW51ZTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJ1bGVQYXNzZWQgPSBydWxlLnZhbGlkYXRlKGlucHV0VmFsdWUsIHJ1bGVPcHRpb25zLnZhbHVlLCBhdHRyaWJ1dGUpO1xyXG5cdCAgICAgICAgaWYgKCFydWxlUGFzc2VkKSB7XHJcblx0ICAgICAgICAgIHRoaXMuX2FkZEZhaWx1cmUocnVsZSk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5fc2hvdWxkU3RvcFZhbGlkYXRpbmcoYXR0cmlidXRlLCBydWxlUGFzc2VkKSkge1xyXG5cdCAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3VudCA9PT0gMDtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJ1biBhc3luYyB2YWxpZGF0b3JcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXNzZXNcclxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhaWxzXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBjaGVja0FzeW5jOiBmdW5jdGlvbihwYXNzZXMsIGZhaWxzKSB7XHJcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICAgIHBhc3NlcyA9IHBhc3NlcyB8fCBmdW5jdGlvbigpIHt9O1xyXG5cdCAgICBmYWlscyA9IGZhaWxzIHx8IGZ1bmN0aW9uKCkge307XHJcblx0XHJcblx0ICAgIHZhciBmYWlsc09uZSA9IGZ1bmN0aW9uKHJ1bGUsIG1lc3NhZ2UpIHtcclxuXHQgICAgICBfdGhpcy5fYWRkRmFpbHVyZShydWxlLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgdmFyIHJlc29sdmVkQWxsID0gZnVuY3Rpb24oYWxsUGFzc2VkKSB7XHJcblx0ICAgICAgaWYgKGFsbFBhc3NlZCkge1xyXG5cdCAgICAgICAgcGFzc2VzKCk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIGZhaWxzKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICB2YXIgdmFsaWRhdGVSdWxlID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSwgcnVsZU9wdGlvbnMsIGF0dHJpYnV0ZSwgcnVsZSkge1xyXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgIHZhciByZXNvbHZlckluZGV4ID0gYXN5bmNSZXNvbHZlcnMuYWRkKHJ1bGUpO1xyXG5cdCAgICAgICAgcnVsZS52YWxpZGF0ZShpbnB1dFZhbHVlLCBydWxlT3B0aW9ucy52YWx1ZSwgYXR0cmlidXRlLCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgYXN5bmNSZXNvbHZlcnMucmVzb2x2ZShyZXNvbHZlckluZGV4KTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgIH07XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIHZhciBhc3luY1Jlc29sdmVycyA9IG5ldyBBc3luY1Jlc29sdmVycyhmYWlsc09uZSwgcmVzb2x2ZWRBbGwpO1xyXG5cdFxyXG5cdCAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gdGhpcy5ydWxlcykge1xyXG5cdCAgICAgIHZhciBhdHRyaWJ1dGVSdWxlcyA9IHRoaXMucnVsZXNbYXR0cmlidXRlXTtcclxuXHQgICAgICB2YXIgaW5wdXRWYWx1ZSA9IHRoaXMuaW5wdXRbYXR0cmlidXRlXTsgLy8gaWYgaXQgZG9lc250IGV4aXN0IGluIGlucHV0LCBpdCB3aWxsIGJlIHVuZGVmaW5lZFxyXG5cdFxyXG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhdHRyaWJ1dGVSdWxlcy5sZW5ndGgsIHJ1bGUsIHJ1bGVPcHRpb25zOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAgIHJ1bGVPcHRpb25zID0gYXR0cmlidXRlUnVsZXNbaV07XHJcblx0XHJcblx0ICAgICAgICBydWxlID0gdGhpcy5nZXRSdWxlKHJ1bGVPcHRpb25zLm5hbWUpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkYXRhYmxlKHJ1bGUsIGlucHV0VmFsdWUpKSB7XHJcblx0ICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFsaWRhdGVSdWxlKGlucHV0VmFsdWUsIHJ1bGVPcHRpb25zLCBhdHRyaWJ1dGUsIHJ1bGUpKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGFzeW5jUmVzb2x2ZXJzLmVuYWJsZUZpcmluZygpO1xyXG5cdCAgICBhc3luY1Jlc29sdmVycy5maXJlKCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBBZGQgZmFpbHVyZSBhbmQgZXJyb3IgbWVzc2FnZSBmb3IgZ2l2ZW4gcnVsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7UnVsZX0gcnVsZVxyXG5cdCAgICovXHJcblx0ICBfYWRkRmFpbHVyZTogZnVuY3Rpb24ocnVsZSkge1xyXG5cdCAgICB2YXIgbXNnID0gdGhpcy5tZXNzYWdlcy5yZW5kZXIocnVsZSk7XHJcblx0ICAgIHRoaXMuZXJyb3JzLmFkZChydWxlLmF0dHJpYnV0ZSwgbXNnKTtcclxuXHQgICAgdGhpcy5lcnJvckNvdW50Kys7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBQYXJzZSBydWxlcywgbm9ybWFsaXppbmcgZm9ybWF0IGludG86IHsgYXR0cmlidXRlOiBbeyBuYW1lOiAnYWdlJywgdmFsdWU6IDMgfV0gfVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge29iamVjdH0gcnVsZXNcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH1cclxuXHQgICAqL1xyXG5cdCAgX3BhcnNlUnVsZXM6IGZ1bmN0aW9uKHJ1bGVzKSB7XHJcblx0ICAgIHZhciBwYXJzZWRSdWxlcyA9IHt9O1xyXG5cdCAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gcnVsZXMpIHtcclxuXHQgICAgICB2YXIgcnVsZXNBcnJheSA9IHJ1bGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgICAgdmFyIGF0dHJpYnV0ZVJ1bGVzID0gW107XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBydWxlc0FycmF5ID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgcnVsZXNBcnJheSA9IHJ1bGVzQXJyYXkuc3BsaXQoJ3wnKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJ1bGVzQXJyYXkubGVuZ3RoLCBydWxlOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAgIHJ1bGUgPSB0aGlzLl9leHRyYWN0UnVsZUFuZFJ1bGVWYWx1ZShydWxlc0FycmF5W2ldKTtcclxuXHQgICAgICAgIGlmIChSdWxlcy5pc0FzeW5jKHJ1bGUubmFtZSkpIHtcclxuXHQgICAgICAgICAgdGhpcy5oYXNBc3luYyA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBhdHRyaWJ1dGVSdWxlcy5wdXNoKHJ1bGUpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBwYXJzZWRSdWxlc1thdHRyaWJ1dGVdID0gYXR0cmlidXRlUnVsZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHBhcnNlZFJ1bGVzO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRXh0cmFjdCBhIHJ1bGUgYW5kIGEgdmFsdWUgZnJvbSBhIHJ1bGVTdHJpbmcgKGkuZS4gbWluOjMpLCBydWxlID0gbWluLCB2YWx1ZSA9IDNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJ1bGVTdHJpbmcgbWluOjNcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIHJ1bGUgYW5kIHZhbHVlXHJcblx0ICAgKi9cclxuXHQgIF9leHRyYWN0UnVsZUFuZFJ1bGVWYWx1ZTogZnVuY3Rpb24ocnVsZVN0cmluZykge1xyXG5cdCAgICB2YXIgcnVsZSA9IHt9LFxyXG5cdCAgICAgIHJ1bGVBcnJheTtcclxuXHRcclxuXHQgICAgcnVsZS5uYW1lID0gcnVsZVN0cmluZztcclxuXHRcclxuXHQgICAgaWYgKHJ1bGVTdHJpbmcuaW5kZXhPZignOicpID49IDApIHtcclxuXHQgICAgICBydWxlQXJyYXkgPSBydWxlU3RyaW5nLnNwbGl0KCc6Jyk7XHJcblx0ICAgICAgcnVsZS5uYW1lID0gcnVsZUFycmF5WzBdO1xyXG5cdCAgICAgIHJ1bGUudmFsdWUgPSBydWxlQXJyYXkuc2xpY2UoMSkuam9pbihcIjpcIik7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHJ1bGU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgYXR0cmlidXRlIGhhcyBhbnkgb2YgdGhlIGdpdmVuIHJ1bGVzXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlXHJcblx0ICAgKiBAcGFyYW0gIHthcnJheX0gICBmaW5kUnVsZXNcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIF9oYXNSdWxlOiBmdW5jdGlvbihhdHRyaWJ1dGUsIGZpbmRSdWxlcykge1xyXG5cdCAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzW2F0dHJpYnV0ZV0gfHwgW107XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBydWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmIChmaW5kUnVsZXMuaW5kZXhPZihydWxlc1tpXS5uYW1lKSA+IC0xKSB7XHJcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIGF0dHJpYnV0ZSBoYXMgYW55IG51bWVyaWMtYmFzZWQgcnVsZXMuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlXHJcblx0ICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfaGFzTnVtZXJpY1J1bGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5faGFzUnVsZShhdHRyaWJ1dGUsIHRoaXMubnVtZXJpY1J1bGVzKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiBydWxlIGlzIHZhbGlkYXRhYmxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7UnVsZX0gICBydWxlXHJcblx0ICAgKiBAcGFyYW0gIHttaXhlZH0gIHZhbHVlXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfaXNWYWxpZGF0YWJsZTogZnVuY3Rpb24ocnVsZSwgdmFsdWUpIHtcclxuXHQgICAgaWYgKFJ1bGVzLmlzSW1wbGljaXQocnVsZS5uYW1lKSkge1xyXG5cdCAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0aGlzLmdldFJ1bGUoJ3JlcXVpcmVkJykudmFsaWRhdGUodmFsdWUpO1xyXG5cdCAgfSxcclxuXHRcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBzdG9wIHZhbGlkYXRpbmcuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSAge2Jvb2xlYW59IHJ1bGVQYXNzZWRcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIF9zaG91bGRTdG9wVmFsaWRhdGluZzogZnVuY3Rpb24oYXR0cmlidXRlLCBydWxlUGFzc2VkKSB7XHJcblx0XHJcblx0ICAgIHZhciBzdG9wT25BdHRyaWJ1dGVzID0gdGhpcy5zdG9wT25BdHRyaWJ1dGVzO1xyXG5cdCAgICBpZiAoc3RvcE9uQXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgcnVsZVBhc3NlZCA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAoc3RvcE9uQXR0cmlidXRlcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0ICAgICAgcmV0dXJuIHN0b3BPbkF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGUpID4gLTE7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgY3VzdG9tIGF0dHJpYnV0ZSBuYW1lcy5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgc2V0QXR0cmlidXRlTmFtZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgdGhpcy5tZXNzYWdlcy5fc2V0QXR0cmlidXRlTmFtZXMoYXR0cmlidXRlcyk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdGhlIGF0dHJpYnV0ZSBmb3JtYXR0ZXIuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtmdWN0aW9ufSBmdW5jXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBzZXRBdHRyaWJ1dGVGb3JtYXR0ZXI6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHQgICAgdGhpcy5tZXNzYWdlcy5fc2V0QXR0cmlidXRlRm9ybWF0dGVyKGZ1bmMpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHZhbGlkYXRpb24gcnVsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxyXG5cdCAgICogQHJldHVybiB7UnVsZX1cclxuXHQgICAqL1xyXG5cdCAgZ2V0UnVsZTogZnVuY3Rpb24obmFtZSkge1xyXG5cdCAgICByZXR1cm4gUnVsZXMubWFrZShuYW1lLCB0aGlzKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFN0b3Agb24gZmlyc3QgZXJyb3IuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7Ym9vbGVhbnxhcnJheX0gQW4gYXJyYXkgb2YgYXR0cmlidXRlcyBvciBib29sZWFuIHRydWUvZmFsc2UgZm9yIGFsbCBhdHRyaWJ1dGVzLlxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgc3RvcE9uRXJyb3I6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgdGhpcy5zdG9wT25BdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiB2YWxpZGF0aW9uIHBhc3Nlc1xyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhc3Nlc1xyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcblx0ICAgKi9cclxuXHQgIHBhc3NlczogZnVuY3Rpb24ocGFzc2VzKSB7XHJcblx0ICAgIHZhciBhc3luYyA9IHRoaXMuX2NoZWNrQXN5bmMoJ3Bhc3NlcycsIHBhc3Nlcyk7XHJcblx0ICAgIGlmIChhc3luYykge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmNoZWNrQXN5bmMocGFzc2VzKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIHZhbGlkYXRpb24gZmFpbHNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWlsc1xyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcblx0ICAgKi9cclxuXHQgIGZhaWxzOiBmdW5jdGlvbihmYWlscykge1xyXG5cdCAgICB2YXIgYXN5bmMgPSB0aGlzLl9jaGVja0FzeW5jKCdmYWlscycsIGZhaWxzKTtcclxuXHQgICAgaWYgKGFzeW5jKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuY2hlY2tBc3luYyhmdW5jdGlvbigpIHt9LCBmYWlscyk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuICF0aGlzLmNoZWNrKCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBDaGVjayBpZiB2YWxpZGF0aW9uIHNob3VsZCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHlcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgZnVuY05hbWUgTmFtZSBvZiB0aGUgY2FsbGVyXHJcblx0ICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIF9jaGVja0FzeW5jOiBmdW5jdGlvbihmdW5jTmFtZSwgY2FsbGJhY2spIHtcclxuXHQgICAgdmFyIGhhc0NhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nO1xyXG5cdCAgICBpZiAodGhpcy5oYXNBc3luYyAmJiAhaGFzQ2FsbGJhY2spIHtcclxuXHQgICAgICB0aHJvdyBmdW5jTmFtZSArICcgZXhwZWN0cyBhIGNhbGxiYWNrIHdoZW4gYXN5bmMgcnVsZXMgYXJlIGJlaW5nIHRlc3RlZC4nO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0aGlzLmhhc0FzeW5jIHx8IGhhc0NhbGxiYWNrO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU2V0IG1lc3NhZ2VzIGZvciBsYW5ndWFnZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbWVzc2FnZXNcclxuXHQgKiBAcmV0dXJuIHt0aGlzfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci5zZXRNZXNzYWdlcyA9IGZ1bmN0aW9uKGxhbmcsIG1lc3NhZ2VzKSB7XHJcblx0ICBMYW5nLl9zZXQobGFuZywgbWVzc2FnZXMpO1xyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBHZXQgbWVzc2FnZXMgZm9yIGdpdmVuIGxhbmd1YWdlXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGxhbmdcclxuXHQgKiBAcmV0dXJuIHtNZXNzYWdlc31cclxuXHQgKi9cclxuXHRWYWxpZGF0b3IuZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbihsYW5nKSB7XHJcblx0ICByZXR1cm4gTGFuZy5fZ2V0KGxhbmcpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgbGFuZ3VhZ2UgdG8gdXNlXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ1xyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnVzZUxhbmcgPSBmdW5jdGlvbihsYW5nKSB7XHJcblx0ICB0aGlzLnByb3RvdHlwZS5sYW5nID0gbGFuZztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEdldCBkZWZhdWx0IGxhbmd1YWdlXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLmdldERlZmF1bHRMYW5nID0gZnVuY3Rpb24oKSB7XHJcblx0ICByZXR1cm4gdGhpcy5wcm90b3R5cGUubGFuZztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgYXR0cmlidXRlIGZvcm1hdHRlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7ZnVjdGlvbn0gZnVuY1xyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnNldEF0dHJpYnV0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHQgIHRoaXMucHJvdG90eXBlLmF0dHJpYnV0ZUZvcm1hdHRlciA9IGZ1bmM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBTdG9wIG9uIGZpcnN0IGVycm9yLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7Ym9vbGVhbnxhcnJheX0gQW4gYXJyYXkgb2YgYXR0cmlidXRlcyBvciBib29sZWFuIHRydWUvZmFsc2UgZm9yIGFsbCBhdHRyaWJ1dGVzLlxyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnN0b3BPbkVycm9yID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xyXG5cdCAgdGhpcy5wcm90b3R5cGUuc3RvcE9uQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZWdpc3RlciBjdXN0b20gdmFsaWRhdGlvbiBydWxlXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZVxyXG5cdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmblxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gICBtZXNzYWdlXHJcblx0ICogQHJldHVybiB7dm9pZH1cclxuXHQgKi9cclxuXHRWYWxpZGF0b3IucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lLCBmbiwgbWVzc2FnZSkge1xyXG5cdCAgdmFyIGxhbmcgPSBWYWxpZGF0b3IuZ2V0RGVmYXVsdExhbmcoKTtcclxuXHQgIFJ1bGVzLnJlZ2lzdGVyKG5hbWUsIGZuKTtcclxuXHQgIExhbmcuX3NldFJ1bGVNZXNzYWdlKGxhbmcsIG5hbWUsIG1lc3NhZ2UpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXIgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gcnVsZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm5cclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWVzc2FnZVxyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnJlZ2lzdGVyQXN5bmMgPSBmdW5jdGlvbihuYW1lLCBmbiwgbWVzc2FnZSkge1xyXG5cdCAgdmFyIGxhbmcgPSBWYWxpZGF0b3IuZ2V0RGVmYXVsdExhbmcoKTtcclxuXHQgIFJ1bGVzLnJlZ2lzdGVyQXN5bmMobmFtZSwgZm4pO1xyXG5cdCAgTGFuZy5fc2V0UnVsZU1lc3NhZ2UobGFuZywgbmFtZSwgbWVzc2FnZSk7XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA5NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIHJ1bGVzID0ge1xyXG5cdFxyXG5cdCAgcmVxdWlyZWQ6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICB2YXIgc3RyO1xyXG5cdFxyXG5cdCAgICBpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XHJcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHN0ciA9IFN0cmluZyh2YWwpLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcclxuXHQgICAgcmV0dXJuIHN0ci5sZW5ndGggPiAwID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIHJlcXVpcmVkX2lmOiBmdW5jdGlvbih2YWwsIHJlcSwgYXR0cmlidXRlKSB7XHJcblx0ICAgIHJlcSA9IHRoaXMuZ2V0UGFyYW1ldGVycygpO1xyXG5cdCAgICBpZiAodGhpcy52YWxpZGF0b3IuaW5wdXRbcmVxWzBdXSA9PT0gcmVxWzFdKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yLmdldFJ1bGUoJ3JlcXVpcmVkJykudmFsaWRhdGUodmFsKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvLyBjb21wYXJlcyB0aGUgc2l6ZSBvZiBzdHJpbmdzXHJcblx0ICAvLyB3aXRoIG51bWJlcnMsIGNvbXBhcmVzIHRoZSB2YWx1ZVxyXG5cdCAgc2l6ZTogZnVuY3Rpb24odmFsLCByZXEsIGF0dHJpYnV0ZSkge1xyXG5cdCAgICBpZiAodmFsKSB7XHJcblx0ICAgICAgcmVxID0gcGFyc2VGbG9hdChyZXEpO1xyXG5cdFxyXG5cdCAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHJcblx0ICAgICAgcmV0dXJuIHNpemUgPT09IHJlcTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBzdHJpbmc6IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQ29tcGFyZXMgdGhlIHNpemUgb2Ygc3RyaW5ncyBvciB0aGUgdmFsdWUgb2YgbnVtYmVycyBpZiB0aGVyZSBpcyBhIHRydXRoeSB2YWx1ZVxyXG5cdCAgICovXHJcblx0ICBtaW46IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHQgICAgcmV0dXJuIHNpemUgPj0gcmVxO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQ29tcGFyZXMgdGhlIHNpemUgb2Ygc3RyaW5ncyBvciB0aGUgdmFsdWUgb2YgbnVtYmVycyBpZiB0aGVyZSBpcyBhIHRydXRoeSB2YWx1ZVxyXG5cdCAgICovXHJcblx0ICBtYXg6IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHQgICAgcmV0dXJuIHNpemUgPD0gcmVxO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGJldHdlZW46IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgcmVxID0gdGhpcy5nZXRQYXJhbWV0ZXJzKCk7XHJcblx0ICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0ICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KHJlcVswXSwgMTApO1xyXG5cdCAgICB2YXIgbWF4ID0gcGFyc2VGbG9hdChyZXFbMV0sIDEwKTtcclxuXHQgICAgcmV0dXJuIHNpemUgPj0gbWluICYmIHNpemUgPD0gbWF4O1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGVtYWlsOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgdmFyIHJlID0gL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XHJcblx0ICAgIHJldHVybiByZS50ZXN0KHZhbCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgbnVtZXJpYzogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHZhciBudW07XHJcblx0XHJcblx0ICAgIG51bSA9IE51bWJlcih2YWwpOyAvLyB0cmllcyB0byBjb252ZXJ0IHZhbHVlIHRvIGEgbnVtYmVyLiB1c2VmdWwgaWYgdmFsdWUgaXMgY29taW5nIGZyb20gZm9ybSBlbGVtZW50XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtKSAmJiB0eXBlb2YgdmFsICE9PSAnYm9vbGVhbicpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblx0XHJcblx0ICBhcnJheTogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICB1cmw6IGZ1bmN0aW9uKHVybCkge1xyXG5cdCAgICByZXR1cm4gKC9eaHR0cHM/OlxcL1xcL1xcUysvKS50ZXN0KHVybCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgYWxwaGE6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICByZXR1cm4gKC9eW2EtekEtWl0rJC8pLnRlc3QodmFsKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBhbHBoYV9kYXNoOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgcmV0dXJuICgvXlthLXpBLVowLTlfXFwtXSskLykudGVzdCh2YWwpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGFscGhhX251bTogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiAoL15bYS16QS1aMC05XSskLykudGVzdCh2YWwpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIHNhbWU6IGZ1bmN0aW9uKHZhbCwgcmVxKSB7XHJcblx0ICAgIHZhciB2YWwxID0gdGhpcy52YWxpZGF0b3IuaW5wdXRbcmVxXTtcclxuXHQgICAgdmFyIHZhbDIgPSB2YWw7XHJcblx0XHJcblx0ICAgIGlmICh2YWwxID09PSB2YWwyKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGRpZmZlcmVudDogZnVuY3Rpb24odmFsLCByZXEpIHtcclxuXHQgICAgdmFyIHZhbDEgPSB0aGlzLnZhbGlkYXRvci5pbnB1dFtyZXFdO1xyXG5cdCAgICB2YXIgdmFsMiA9IHZhbDtcclxuXHRcclxuXHQgICAgaWYgKHZhbDEgIT09IHZhbDIpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgXCJpblwiOiBmdW5jdGlvbih2YWwsIHJlcSkge1xyXG5cdCAgICB2YXIgbGlzdCwgaTtcclxuXHRcclxuXHQgICAgaWYgKHZhbCkge1xyXG5cdCAgICAgIGxpc3QgPSByZXEuc3BsaXQoJywnKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodmFsICYmICEodmFsIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcblx0ICAgICAgdmFsID0gU3RyaW5nKHZhbCk7IC8vIGlmIGl0IGlzIGEgbnVtYmVyXHJcblx0XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgIGlmICh2YWwgPT09IGxpc3RbaV0pIHtcclxuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodmFsICYmIHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgaWYgKGxpc3QuaW5kZXhPZih2YWxbaV0pIDwgMCkge1xyXG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIG5vdF9pbjogZnVuY3Rpb24odmFsLCByZXEpIHtcclxuXHQgICAgdmFyIGxpc3QgPSByZXEuc3BsaXQoJywnKTtcclxuXHQgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xyXG5cdCAgICB2YXIgcmV0dXJuVmFsID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgdmFsID0gU3RyaW5nKHZhbCk7IC8vIGNvbnZlcnQgdmFsIHRvIGEgc3RyaW5nIGlmIGl0IGlzIGEgbnVtYmVyXHJcblx0XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICBpZiAodmFsID09PSBsaXN0W2ldKSB7XHJcblx0ICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcclxuXHQgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gcmV0dXJuVmFsO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGFjY2VwdGVkOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgaWYgKHZhbCA9PT0gJ29uJyB8fCB2YWwgPT09ICd5ZXMnIHx8IHZhbCA9PT0gMSB8fCB2YWwgPT09ICcxJyB8fCB2YWwgPT09IHRydWUpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgY29uZmlybWVkOiBmdW5jdGlvbih2YWwsIHJlcSwga2V5KSB7XHJcblx0ICAgIHZhciBjb25maXJtZWRLZXkgPSBrZXkgKyAnX2NvbmZpcm1hdGlvbic7XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLnZhbGlkYXRvci5pbnB1dFtjb25maXJtZWRLZXldID09PSB2YWwpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgaW50ZWdlcjogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiBTdHJpbmcocGFyc2VJbnQodmFsLCAxMCkpID09PSBTdHJpbmcodmFsKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBkaWdpdHM6IGZ1bmN0aW9uKHZhbCwgcmVxKSB7XHJcblx0ICAgIHZhciBudW1lcmljUnVsZSA9IHRoaXMudmFsaWRhdG9yLmdldFJ1bGUoJ251bWVyaWMnKTtcclxuXHQgICAgaWYgKG51bWVyaWNSdWxlLnZhbGlkYXRlKHZhbCkgJiYgU3RyaW5nKHZhbCkubGVuZ3RoID09PSBwYXJzZUludChyZXEpKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIHJlZ2V4OiBmdW5jdGlvbih2YWwsIHJlcSkge1xyXG5cdCAgICB2YXIgbW9kID0gL1tnfGl8bV17MSwzfSQvO1xyXG5cdCAgICB2YXIgZmxhZyA9IHJlcS5tYXRjaChtb2QpO1xyXG5cdCAgICBmbGFnID0gZmxhZyA/IGZsYWdbMF0gOiBcImlcIjtcclxuXHQgICAgcmVxID0gcmVxLnJlcGxhY2UobW9kLCBcIlwiKS5zbGljZSgxLCAtMSk7XHJcblx0ICAgIHJlcSA9IG5ldyBSZWdFeHAocmVxLCBmbGFnKTtcclxuXHQgICAgcmV0dXJuICEhdmFsLm1hdGNoKHJlcSk7XHJcblx0ICB9XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBSdWxlKG5hbWUsIGZuLCBhc3luYykge1xyXG5cdCAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgIHRoaXMuZm4gPSBmbjtcclxuXHQgIHRoaXMucGFzc2VzID0gbnVsbDtcclxuXHQgIHRoaXMuY3VzdG9tTWVzc2FnZSA9IHVuZGVmaW5lZDtcclxuXHQgIHRoaXMuYXN5bmMgPSBhc3luYztcclxuXHR9XHJcblx0XHJcblx0UnVsZS5wcm90b3R5cGUgPSB7XHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFZhbGlkYXRlIHJ1bGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHttaXhlZH0gaW5wdXRWYWx1ZVxyXG5cdCAgICogQHBhcmFtICB7bWl4ZWR9IHJ1bGVWYWx1ZVxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcblx0ICAgKi9cclxuXHQgIHZhbGlkYXRlOiBmdW5jdGlvbihpbnB1dFZhbHVlLCBydWxlVmFsdWUsIGF0dHJpYnV0ZSwgY2FsbGJhY2spIHtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHQgICAgdGhpcy5fc2V0VmFsaWRhdGluZ0RhdGEoYXR0cmlidXRlLCBpbnB1dFZhbHVlLCBydWxlVmFsdWUpO1xyXG5cdCAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdCAgICAgIHZhciBoYW5kbGVSZXNwb25zZSA9IGZ1bmN0aW9uKHBhc3NlcywgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgX3RoaXMucmVzcG9uc2UocGFzc2VzLCBtZXNzYWdlKTtcclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIGlmICh0aGlzLmFzeW5jKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5mbi5hcHBseSh0aGlzLCBbaW5wdXRWYWx1ZSwgcnVsZVZhbHVlLCBhdHRyaWJ1dGUsIGhhbmRsZVJlc3BvbnNlXSk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZSh0aGlzLmZuLmFwcGx5KHRoaXMsIFtpbnB1dFZhbHVlLCBydWxlVmFsdWUsIGF0dHJpYnV0ZV0pKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRoaXMuZm4uYXBwbHkodGhpcywgW2lucHV0VmFsdWUsIHJ1bGVWYWx1ZSwgYXR0cmlidXRlXSk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdmFsaWRhdGluZyBkYXRhXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxyXG5cdCAgICogQHBhcmFtIHttaXhlZH0gaW5wdXRWYWx1ZVxyXG5cdCAgICogQHBhcmFtIHttaXhlZH0gcnVsZVZhbHVlXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfc2V0VmFsaWRhdGluZ0RhdGE6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgaW5wdXRWYWx1ZSwgcnVsZVZhbHVlKSB7XHJcblx0ICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xyXG5cdCAgICB0aGlzLmlucHV0VmFsdWUgPSBpbnB1dFZhbHVlO1xyXG5cdCAgICB0aGlzLnJ1bGVWYWx1ZSA9IHJ1bGVWYWx1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCBwYXJhbWV0ZXJzXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7YXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIGdldFBhcmFtZXRlcnM6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5ydWxlVmFsdWUgPyB0aGlzLnJ1bGVWYWx1ZS5zcGxpdCgnLCcpIDogW107XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgdHJ1ZSBzaXplIG9mIHZhbHVlXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7aW50ZWdlcnxmbG9hdH1cclxuXHQgICAqL1xyXG5cdCAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXRWYWx1ZTtcclxuXHRcclxuXHQgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHQgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLnZhbGlkYXRvci5faGFzTnVtZXJpY1J1bGUodGhpcy5hdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHRoZSB0eXBlIG9mIHZhbHVlIGJlaW5nIGNoZWNrZWQ7IG51bWVyaWMgb3Igc3RyaW5nLlxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgX2dldFZhbHVlVHlwZTogZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdGhpcy5pbnB1dFZhbHVlID09PSAnbnVtYmVyJyB8fCB0aGlzLnZhbGlkYXRvci5faGFzTnVtZXJpY1J1bGUodGhpcy5hdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuICdudW1lcmljJztcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gJ3N0cmluZyc7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdGhlIGFzeW5jIGNhbGxiYWNrIHJlc3BvbnNlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7Ym9vbGVhbnx1bmRlZmluZWR9IHBhc3NlcyAgV2hldGhlciB2YWxpZGF0aW9uIHBhc3NlZFxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfHVuZGVmaW5lZH0gbWVzc2FnZSBDdXN0b20gZXJyb3IgbWVzc2FnZVxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVzcG9uc2U6IGZ1bmN0aW9uKHBhc3NlcywgbWVzc2FnZSkge1xyXG5cdCAgICB0aGlzLnBhc3NlcyA9IChwYXNzZXMgPT09IHVuZGVmaW5lZCB8fCBwYXNzZXMgPT09IHRydWUpO1xyXG5cdCAgICB0aGlzLmN1c3RvbU1lc3NhZ2UgPSBtZXNzYWdlO1xyXG5cdCAgICB0aGlzLmNhbGxiYWNrKHRoaXMucGFzc2VzLCBtZXNzYWdlKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCB2YWxpZGF0b3IgaW5zdGFuY2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1ZhbGlkYXRvcn0gdmFsaWRhdG9yXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBzZXRWYWxpZGF0b3I6IGZ1bmN0aW9uKHZhbGlkYXRvcikge1xyXG5cdCAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcclxuXHQgIH1cclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBtYW5hZ2VyID0ge1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBMaXN0IG9mIGFzeW5jIHJ1bGUgbmFtZXNcclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIGFzeW5jUnVsZXM6IFtdLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBJbXBsaWNpdCBydWxlcyAocnVsZXMgdG8gYWx3YXlzIHZhbGlkYXRlKVxyXG5cdCAgICpcclxuXHQgICAqIEB0eXBlIHtBcnJheX1cclxuXHQgICAqL1xyXG5cdCAgaW1wbGljaXRSdWxlczogWydyZXF1aXJlZCcsICdyZXF1aXJlZF9pZicsICdhY2NlcHRlZCddLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgcnVsZSBieSBuYW1lXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXHJcblx0ICAgKiBAcGFyYW0ge1ZhbGlkYXRvcn1cclxuXHQgICAqIEByZXR1cm4ge1J1bGV9XHJcblx0ICAgKi9cclxuXHQgIG1ha2U6IGZ1bmN0aW9uKG5hbWUsIHZhbGlkYXRvcikge1xyXG5cdCAgICB2YXIgYXN5bmMgPSB0aGlzLmlzQXN5bmMobmFtZSk7XHJcblx0ICAgIHZhciBydWxlID0gbmV3IFJ1bGUobmFtZSwgcnVsZXNbbmFtZV0sIGFzeW5jKTtcclxuXHQgICAgcnVsZS5zZXRWYWxpZGF0b3IodmFsaWRhdG9yKTtcclxuXHQgICAgcmV0dXJuIHJ1bGU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgZ2l2ZW4gcnVsZSBpcyBhc3luY1xyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWVcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIGlzQXN5bmM6IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXN5bmNSdWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmICh0aGlzLmFzeW5jUnVsZXNbaV0gPT09IG5hbWUpIHtcclxuXHQgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgcnVsZSBpcyBpbXBsaWNpdCAoc2hvdWxkIGFsd2F5cyB2YWxpZGF0ZSlcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuXHQgICAqL1xyXG5cdCAgaXNJbXBsaWNpdDogZnVuY3Rpb24obmFtZSkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5pbXBsaWNpdFJ1bGVzLmluZGV4T2YobmFtZSkgPiAtMTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJlZ2lzdGVyIG5ldyBydWxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmblxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XHJcblx0ICAgIHJ1bGVzW25hbWVdID0gZm47XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZWdpc3RlciBhc3luYyBydWxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmblxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVnaXN0ZXJBc3luYzogZnVuY3Rpb24obmFtZSwgZm4pIHtcclxuXHQgICAgdGhpcy5yZWdpc3RlcihuYW1lLCBmbik7XHJcblx0ICAgIHRoaXMuYXN5bmNSdWxlcy5wdXNoKG5hbWUpO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBtYW5hZ2VyO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDk1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgTWVzc2FnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcclxuXHRcclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcclxuXHRcclxuXHR2YXIgY29udGFpbmVyID0ge1xyXG5cdFxyXG5cdCAgbWVzc2FnZXM6IHt9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgbWVzc2FnZXMgZm9yIGxhbmd1YWdlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcclxuXHQgICAqIEBwYXJhbSB7b2JqZWN0fSByYXdNZXNzYWdlc1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgX3NldDogZnVuY3Rpb24obGFuZywgcmF3TWVzc2FnZXMpIHtcclxuXHQgICAgdGhpcy5tZXNzYWdlc1tsYW5nXSA9IHJhd01lc3NhZ2VzO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IG1lc3NhZ2UgZm9yIGdpdmVuIGxhbmd1YWdlJ3MgcnVsZS5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ1xyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBtZXNzYWdlXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfc2V0UnVsZU1lc3NhZ2U6IGZ1bmN0aW9uKGxhbmcsIGF0dHJpYnV0ZSwgbWVzc2FnZSkge1xyXG5cdCAgICB0aGlzLl9sb2FkKGxhbmcpO1xyXG5cdCAgICBpZiAobWVzc2FnZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbbGFuZ10uZGVmO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHRoaXMubWVzc2FnZXNbbGFuZ11bYXR0cmlidXRlXSA9IG1lc3NhZ2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBMb2FkIG1lc3NhZ2VzIChpZiBub3QgYWxyZWFkeSBsb2FkZWQpXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBsYW5nXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfbG9hZDogZnVuY3Rpb24obGFuZykge1xyXG5cdCAgICBpZiAoIXRoaXMubWVzc2FnZXNbbGFuZ10pIHtcclxuXHQgICAgICB2YXIgcmF3TWVzc2FnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KShcIi4vXCIgKyBsYW5nKTtcclxuXHQgICAgICB0aGlzLl9zZXQobGFuZywgcmF3TWVzc2FnZXMpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgcmF3IG1lc3NhZ2VzIGZvciBsYW5ndWFnZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbGFuZ1xyXG5cdCAgICogQHJldHVybiB7b2JqZWN0fVxyXG5cdCAgICovXHJcblx0ICBfZ2V0OiBmdW5jdGlvbihsYW5nKSB7XHJcblx0ICAgIHRoaXMuX2xvYWQobGFuZyk7XHJcblx0ICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzW2xhbmddO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogTWFrZSBtZXNzYWdlcyBmb3IgZ2l2ZW4gbGFuZ3VhZ2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxhbmdcclxuXHQgICAqIEByZXR1cm4ge01lc3NhZ2VzfVxyXG5cdCAgICovXHJcblx0ICBfbWFrZTogZnVuY3Rpb24obGFuZykge1xyXG5cdCAgICB0aGlzLl9sb2FkKGxhbmcpO1xyXG5cdCAgICByZXR1cm4gbmV3IE1lc3NhZ2VzKGxhbmcsIHRoaXMubWVzc2FnZXNbbGFuZ10pO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBjb250YWluZXI7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogOTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBBdHRyaWJ1dGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XHJcblx0XHJcblx0dmFyIE1lc3NhZ2VzID0gZnVuY3Rpb24obGFuZywgbWVzc2FnZXMpIHtcclxuXHQgIHRoaXMubGFuZyA9IGxhbmc7XHJcblx0ICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XHJcblx0ICB0aGlzLmN1c3RvbU1lc3NhZ2VzID0ge307XHJcblx0ICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0ge307XHJcblx0fTtcclxuXHRcclxuXHRNZXNzYWdlcy5wcm90b3R5cGUgPSB7XHJcblx0ICBjb25zdHJ1Y3RvcjogTWVzc2FnZXMsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCBjdXN0b20gbWVzc2FnZXNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tTWVzc2FnZXNcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIF9zZXRDdXN0b206IGZ1bmN0aW9uKGN1c3RvbU1lc3NhZ2VzKSB7XHJcblx0ICAgIHRoaXMuY3VzdG9tTWVzc2FnZXMgPSBjdXN0b21NZXNzYWdlcyB8fCB7fTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCBjdXN0b20gYXR0cmlidXRlIG5hbWVzLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXHJcblx0ICAgKi9cclxuXHQgIF9zZXRBdHRyaWJ1dGVOYW1lczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xyXG5cdCAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0gYXR0cmlidXRlcztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCB0aGUgYXR0cmlidXRlIGZvcm1hdHRlci5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1Y3Rpb259IGZ1bmNcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIF9zZXRBdHRyaWJ1dGVGb3JtYXR0ZXI6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHQgICAgdGhpcy5hdHRyaWJ1dGVGb3JtYXR0ZXIgPSBmdW5jO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IGF0dHJpYnV0ZSBuYW1lIHRvIGRpc3BsYXkuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgX2dldEF0dHJpYnV0ZU5hbWU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZTtcclxuXHQgICAgaWYgKHRoaXMuYXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU5hbWVzW2F0dHJpYnV0ZV07XHJcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5tZXNzYWdlcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcclxuXHQgICAgICBuYW1lID0gdGhpcy5tZXNzYWdlcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHRoaXMuYXR0cmlidXRlRm9ybWF0dGVyKSB7XHJcblx0ICAgICAgbmFtZSA9IHRoaXMuYXR0cmlidXRlRm9ybWF0dGVyKG5hbWUpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBuYW1lO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IGFsbCBtZXNzYWdlc1xyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH1cclxuXHQgICAqL1xyXG5cdCAgYWxsOiBmdW5jdGlvbigpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZW5kZXIgbWVzc2FnZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgcmVuZGVyOiBmdW5jdGlvbihydWxlKSB7XHJcblx0ICAgIGlmIChydWxlLmN1c3RvbU1lc3NhZ2UpIHtcclxuXHQgICAgICByZXR1cm4gcnVsZS5jdXN0b21NZXNzYWdlO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuX2dldFRlbXBsYXRlKHJ1bGUpO1xyXG5cdFxyXG5cdCAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgaWYgKEF0dHJpYnV0ZXMucmVwbGFjZW1lbnRzW3J1bGUubmFtZV0pIHtcclxuXHQgICAgICBtZXNzYWdlID0gQXR0cmlidXRlcy5yZXBsYWNlbWVudHNbcnVsZS5uYW1lXS5hcHBseSh0aGlzLCBbdGVtcGxhdGUsIHJ1bGVdKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBtZXNzYWdlID0gdGhpcy5fcmVwbGFjZVBsYWNlaG9sZGVycyhydWxlLCB0ZW1wbGF0ZSwge30pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBtZXNzYWdlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHRoZSB0ZW1wbGF0ZSB0byB1c2UgZm9yIGdpdmVuIHJ1bGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtSdWxlfSBydWxlXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIF9nZXRUZW1wbGF0ZTogZnVuY3Rpb24ocnVsZSkge1xyXG5cdFxyXG5cdCAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xyXG5cdCAgICB2YXIgdGVtcGxhdGUgPSBtZXNzYWdlcy5kZWY7XHJcblx0ICAgIHZhciBjdXN0b21NZXNzYWdlcyA9IHRoaXMuY3VzdG9tTWVzc2FnZXM7XHJcblx0ICAgIHZhciBmb3JtYXRzID0gW3J1bGUubmFtZSArICcuJyArIHJ1bGUuYXR0cmlidXRlLCBydWxlLm5hbWVdO1xyXG5cdFxyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgZm9ybWF0OyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgIGZvcm1hdCA9IGZvcm1hdHNbaV07XHJcblx0ICAgICAgaWYgKGN1c3RvbU1lc3NhZ2VzLmhhc093blByb3BlcnR5KGZvcm1hdCkpIHtcclxuXHQgICAgICAgIHRlbXBsYXRlID0gY3VzdG9tTWVzc2FnZXNbZm9ybWF0XTtcclxuXHQgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAobWVzc2FnZXMuaGFzT3duUHJvcGVydHkoZm9ybWF0KSkge1xyXG5cdCAgICAgICAgdGVtcGxhdGUgPSBtZXNzYWdlc1tmb3JtYXRdO1xyXG5cdCAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZVtydWxlLl9nZXRWYWx1ZVR5cGUoKV07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSBkYXRhIG9iamVjdFxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gdGVtcGxhdGVcclxuXHQgICAqIEBwYXJhbSAge29iamVjdH0gZGF0YVxyXG5cdCAgICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAgICovXHJcblx0ICBfcmVwbGFjZVBsYWNlaG9sZGVyczogZnVuY3Rpb24ocnVsZSwgdGVtcGxhdGUsIGRhdGEpIHtcclxuXHQgICAgdmFyIG1lc3NhZ2UsIGF0dHJpYnV0ZTtcclxuXHRcclxuXHQgICAgZGF0YS5hdHRyaWJ1dGUgPSB0aGlzLl9nZXRBdHRyaWJ1dGVOYW1lKHJ1bGUuYXR0cmlidXRlKTtcclxuXHQgICAgZGF0YVtydWxlLm5hbWVdID0gcnVsZS5nZXRQYXJhbWV0ZXJzKCkuam9pbignLCcpO1xyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICBtZXNzYWdlID0gdGVtcGxhdGU7XHJcblx0XHJcblx0ICAgICAgZm9yIChhdHRyaWJ1dGUgaW4gZGF0YSkge1xyXG5cdCAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKCc6JyArIGF0dHJpYnV0ZSwgJ2cnKSwgZGF0YVthdHRyaWJ1dGVdKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIG1lc3NhZ2U7XHJcblx0ICB9XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VzO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDk3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgcmVwbGFjZW1lbnRzID0ge1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBCZXR3ZWVuIHJlcGxhY2VtZW50IChyZXBsYWNlcyA6bWluIGFuZCA6bWF4KVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gdGVtcGxhdGVcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgYmV0d2VlbjogZnVuY3Rpb24odGVtcGxhdGUsIHJ1bGUpIHtcclxuXHQgICAgdmFyIHBhcmFtZXRlcnMgPSBydWxlLmdldFBhcmFtZXRlcnMoKTtcclxuXHQgICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VQbGFjZWhvbGRlcnMocnVsZSwgdGVtcGxhdGUsIHtcclxuXHQgICAgICBtaW46IHBhcmFtZXRlcnNbMF0sXHJcblx0ICAgICAgbWF4OiBwYXJhbWV0ZXJzWzFdXHJcblx0ICAgIH0pO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVxdWlyZWRfaWYgcmVwbGFjZW1lbnQuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSB0ZW1wbGF0ZVxyXG5cdCAgICogQHBhcmFtICB7UnVsZX0gcnVsZVxyXG5cdCAgICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAgICovXHJcblx0ICByZXF1aXJlZF9pZjogZnVuY3Rpb24odGVtcGxhdGUsIHJ1bGUpIHtcclxuXHQgICAgdmFyIHBhcmFtZXRlcnMgPSBydWxlLmdldFBhcmFtZXRlcnMoKTtcclxuXHQgICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VQbGFjZWhvbGRlcnMocnVsZSwgdGVtcGxhdGUsIHtcclxuXHQgICAgICBvdGhlcjogcGFyYW1ldGVyc1swXSxcclxuXHQgICAgICB2YWx1ZTogcGFyYW1ldGVyc1sxXVxyXG5cdCAgICB9KTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGZvcm1hdHRlcihhdHRyaWJ1dGUpIHtcclxuXHQgIHJldHVybiBhdHRyaWJ1dGUucmVwbGFjZSgvW19cXFtdL2csICcgJykucmVwbGFjZSgvXS9nLCAnJyk7XHJcblx0fVxyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgcmVwbGFjZW1lbnRzOiByZXBsYWNlbWVudHMsXHJcblx0ICBmb3JtYXR0ZXI6IGZvcm1hdHRlclxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogOTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgYWNjZXB0ZWQ6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGFjY2VwdGVkLicsXHJcblx0ICBhbHBoYTogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG11c3QgY29udGFpbiBvbmx5IGFscGhhYmV0aWMgY2hhcmFjdGVycy4nLFxyXG5cdCAgYWxwaGFfZGFzaDogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGRhc2hlcyBhbmQgdW5kZXJzY29yZXMuJyxcclxuXHQgIGFscGhhX251bTogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG11c3QgYmUgYWxwaGFudW1lcmljLicsXHJcblx0ICBiZXR3ZWVuOiAnVGhlIDphdHRyaWJ1dGUgZmllbGQgbXVzdCBiZSBiZXR3ZWVuIDptaW4gYW5kIDptYXguJyxcclxuXHQgIGNvbmZpcm1lZDogJ1RoZSA6YXR0cmlidXRlIGNvbmZpcm1hdGlvbiBkb2VzIG5vdCBtYXRjaC4nLFxyXG5cdCAgZW1haWw6ICdUaGUgOmF0dHJpYnV0ZSBmb3JtYXQgaXMgaW52YWxpZC4nLFxyXG5cdCAgZGVmOiAnVGhlIDphdHRyaWJ1dGUgYXR0cmlidXRlIGhhcyBlcnJvcnMuJyxcclxuXHQgIGRpZ2l0czogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgOmRpZ2l0cyBkaWdpdHMuJyxcclxuXHQgIGRpZmZlcmVudDogJ1RoZSA6YXR0cmlidXRlIGFuZCA6ZGlmZmVyZW50IG11c3QgYmUgZGlmZmVyZW50LicsXHJcblx0ICAnaW4nOiAnVGhlIHNlbGVjdGVkIDphdHRyaWJ1dGUgaXMgaW52YWxpZC4nLFxyXG5cdCAgaW50ZWdlcjogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgYW4gaW50ZWdlci4nLFxyXG5cdCAgbWluOiB7XHJcblx0ICAgIG51bWVyaWM6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGF0IGxlYXN0IDptaW4uJyxcclxuXHQgICAgc3RyaW5nOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSBhdCBsZWFzdCA6bWluIGNoYXJhY3RlcnMuJ1xyXG5cdCAgfSxcclxuXHQgIG1heDoge1xyXG5cdCAgICBudW1lcmljOiAnVGhlIDphdHRyaWJ1dGUgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICdUaGUgOmF0dHJpYnV0ZSBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiA6bWF4IGNoYXJhY3RlcnMuJ1xyXG5cdCAgfSxcclxuXHQgIG5vdF9pbjogJ1RoZSBzZWxlY3RlZCA6YXR0cmlidXRlIGlzIGludmFsaWQuJyxcclxuXHQgIG51bWVyaWM6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGEgbnVtYmVyLicsXHJcblx0ICByZXF1aXJlZDogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIGlzIHJlcXVpcmVkLicsXHJcblx0ICByZXF1aXJlZF9pZjogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIGlzIHJlcXVpcmVkIHdoZW4gOm90aGVyIGlzIDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ1RoZSA6YXR0cmlidXRlIGFuZCA6c2FtZSBmaWVsZHMgbXVzdCBtYXRjaC4nLFxyXG5cdCAgc2l6ZToge1xyXG5cdCAgICBudW1lcmljOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIDpzaXplIGNoYXJhY3RlcnMuJ1xyXG5cdCAgfSxcclxuXHQgIHN0cmluZzogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgYSBzdHJpbmcuJyxcclxuXHQgIHVybDogJ1RoZSA6YXR0cmlidXRlIGZvcm1hdCBpcyBpbnZhbGlkLicsXHJcblx0ICByZWdleDogJ1RoZSA6YXR0cmlidXRlIGZvcm1hdCBpcyBpbnZhbGlkJyxcclxuXHQgIGF0dHJpYnV0ZXM6IHt9XHJcblx0fTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA5OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIG1hcCA9IHtcclxuXHRcdFwiLi9lblwiOiA5OCxcclxuXHRcdFwiLi9lbi5qc1wiOiA5OCxcclxuXHRcdFwiLi9lc1wiOiAxMDAsXHJcblx0XHRcIi4vZXMuanNcIjogMTAwLFxyXG5cdFx0XCIuL2ZyXCI6IDEwMSxcclxuXHRcdFwiLi9mci5qc1wiOiAxMDEsXHJcblx0XHRcIi4vaXRcIjogMTAyLFxyXG5cdFx0XCIuL2l0LmpzXCI6IDEwMixcclxuXHRcdFwiLi9qYVwiOiAxMDMsXHJcblx0XHRcIi4vamEuanNcIjogMTAzLFxyXG5cdFx0XCIuL3BsXCI6IDEwNCxcclxuXHRcdFwiLi9wbC5qc1wiOiAxMDQsXHJcblx0XHRcIi4vcnVcIjogMTA1LFxyXG5cdFx0XCIuL3J1LmpzXCI6IDEwNVxyXG5cdH07XHJcblx0ZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XHJcblx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XHJcblx0fTtcclxuXHRmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XHJcblx0XHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xyXG5cdH07XHJcblx0d2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xyXG5cdH07XHJcblx0d2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xyXG5cdHdlYnBhY2tDb250ZXh0LmlkID0gOTk7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciBhY2VwdGFkby4nLFxyXG5cdCAgYWxwaGE6ICdFbCBjYW1wbyA6YXR0cmlidXRlIHNvbG8gZGViZSBjb250ZW5lciBsZXRyYXMuJyxcclxuXHQgIGFscGhhX2Rhc2g6ICdFbCBjYW1wbyA6YXR0cmlidXRlIHNvbG8gZGViZSBjb250ZW5lciBsZXRyYXMsIG7Dum1lcm9zIHkgZ3Vpb25lcy4nLFxyXG5cdCAgYWxwaGFfbnVtOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBzb2xvIGRlYmUgY29udGVuZXIgbGV0cmFzIHkgbsO6bWVyb3MuJyxcclxuXHQgIGF0dHJpYnV0ZXM6IHt9LFxyXG5cdCAgYmV0d2VlbjogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgdGllbmUgcXVlIGVzdGFyIGVudHJlIDptaW4gLSA6bWF4LicsXHJcblx0ICBjb25maXJtZWQ6ICdMYSBjb25maXJtYWNpw7NuIGRlIDphdHRyaWJ1dGUgbm8gY29pbmNpZGUuJyxcclxuXHQgIGRpZmZlcmVudDogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgeSA6b3RoZXIgZGViZW4gc2VyIGRpZmVyZW50ZXMuJyxcclxuXHQgIGRpZ2l0czogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSB0ZW5lciA6ZGlnaXRzIGTDrWdpdG9zLicsXHJcblx0ICBlbWFpbDogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgbm8gZXMgdW4gY29ycmVvIHbDoWxpZG8nLFxyXG5cdCAgJ2luJzogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZXMgaW52w6FsaWRvLicsXHJcblx0ICBpbnRlZ2VyOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciB1biBuw7ptZXJvIGVudGVyby4nLFxyXG5cdCAgbWF4OiB7XHJcblx0ICAgIG51bWVyaWM6ICdFbCBjYW1wbyA6YXR0cmlidXRlIG5vIGRlYmUgc2VyIG1heW9yIGEgOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICdFbCBjYW1wbyA6YXR0cmlidXRlIG5vIGRlYmUgc2VyIG1heW9yIHF1ZSA6bWF4IGNhcmFjdGVyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnRWwgdGFtYcOxbyBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciBkZSBhbCBtZW5vcyA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBjb250ZW5lciBhbCBtZW5vcyA6bWluIGNhcmFjdGVyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIG5vdF9pbjogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZXMgaW52w6FsaWRvLicsXHJcblx0ICBudW1lcmljOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciBudW3DqXJpY28uJyxcclxuXHQgIHJlZ2V4OiAnRWwgZm9ybWF0byBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBlcyBpbnbDoWxpZG8uJyxcclxuXHQgIHJlcXVpcmVkOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBlcyBvYmxpZ2F0b3Jpby4nLFxyXG5cdCAgcmVxdWlyZWRfaWY6ICdFbCBjYW1wbyA6YXR0cmlidXRlIGVzIG9ibGlnYXRvcmlvIGN1YW5kbyA6b3RoZXIgZXMgOnZhbHVlLicsXHJcblx0ICBzYW1lOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSB5IDpvdGhlciBkZWJlbiBjb2luY2lkaXIuJyxcclxuXHQgIHNpemU6IHtcclxuXHQgICAgbnVtZXJpYzogJ0VsIHRhbWHDsW8gZGVsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBzZXIgOnNpemUuJyxcclxuXHQgICAgc3RyaW5nOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIGNvbnRlbmVyIDpzaXplIGNhcmFjdGVyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIHVybDogJ0VsIGZvcm1hdG8gZGUgOmF0dHJpYnV0ZSBlcyBpbnbDoWxpZG8uJ1xyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBhY2NlcHTDqS4nLFxyXG5cdCAgYWxwaGE6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBwZXV0IGNvbnRlbmlyIHF1ZSBkZXMgY2FyYWN0w6hyZXMgYWxwaGFiw6l0aXF1ZXMuJyxcclxuXHQgIGFscGhhX2Rhc2g6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBwZXV0IGNvbnRlbmlyIHF1ZSBkZXMgY2FyYWN0w6hyZXMgYWxwaGFudW3DqXJpcXVlcywgZGVzIHRpcmV0cyBldCB1bmRlcnNjb3Jlcy4nLFxyXG5cdCAgYWxwaGFfbnVtOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBhbHBoYW51bcOpcmlxdWUuJyxcclxuXHQgIGJldHdlZW46ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIGNvbXByaXMgZW50cmUgOm1pbiBhbmQgOm1heC4nLFxyXG5cdCAgY29uZmlybWVkOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgbmUgY29ycmVzcG9uZCBwYXMuJyxcclxuXHQgIGVtYWlsOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgY29udGllbnQgdW4gZm9ybWF0IGludmFsaWRlLicsXHJcblx0ICBkZWY6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBjb250aWVudCB1biBhdHRyaWJ1dCBlcnJvbsOpLicsXHJcblx0ICBkaWdpdHM6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIGRlIDpkaWdpdHMgY2hpZmZyZXMuJyxcclxuXHQgIGRpZmZlcmVudDogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGV0IDpkaWZmZXJlbnQgZG9pdmVudCDDqnRyZSBkaWZmZXJlbnRzLicsXHJcblx0ICAnaW4nOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IGludmFsaWRlLicsXHJcblx0ICBpbnRlZ2VyOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSB1biBlbnRpZXIuJyxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBjb250ZW5pciBhdSBtb2lucyA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgY29udGVuaXIgYXUgbW9pbnMgOm1pbiBjYXJhY3TDqHJlcy4nXHJcblx0ICB9LFxyXG5cdCAgbWF4OiB7XHJcblx0ICAgIG51bWVyaWM6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBkb2l0IMOqdHJlIHN1cMOpcmlldXIgw6AgOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBkb2l0IMOqdHJlIHBsdXMgZGUgOm1heCBjaGFyYWN0ZXJzLidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBlc3QgaW52YWxpZGUuJyxcclxuXHQgIG51bWVyaWM6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIHVuIG51bcOpcm8uJyxcclxuXHQgIHJlcXVpcmVkOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IG9ibGlnYXRvaXJlLicsXHJcblx0ICByZXF1aXJlZF9pZjogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGVzdCBvYmxpZ2F0b2lyZSBxdWFuZCA6b3RoZXIgZXN0IDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGV0IDpzYW1lIGRvaXZlbnQgY29ycmVzcG9uZHJlLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICdMYSB0YWlsbGUgZHUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICdMYSB0YWlsbGUgZHUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBkZSA6c2l6ZSBjYXJhY3TDqHJlcy4nXHJcblx0ICB9LFxyXG5cdCAgdXJsOiAnTGUgZm9ybWF0IGR1IGNoYW1wcyA6YXR0cmlidXRlIGVzdCBpbnZhbGlkZS4nLFxyXG5cdCAgcmVnZXg6ICdMZSBmb3JtYXQgZHUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IGludmFsaWRlLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBhY2NldHRhdG8uJyxcclxuXHQgIGFscGhhOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGNvbnRlbmVyZSBzb25vIGNhcmF0dGVyaSBhbGZhYmV0aWNpLicsXHJcblx0ICBhbHBoYV9kYXNoOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBwdcOyIGNvbnRlbmVyZSBzb2xvIGNhcmF0dGVyaSBhbGZhbnVtZXJpY2kgb2x0cmUgYSB0cmF0dGluaSBlIHRyYXR0aW5pIGJhc3NpLicsXHJcblx0ICBhbHBoYV9udW06ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIGFsZmFudW1lcmljby4nLFxyXG5cdCAgYmV0d2VlbjogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgY29tcHJlc28gdHJhIDptaW4gZSA6bWF4LicsXHJcblx0ICBjb25maXJtZWQ6ICdJbCBjYW1wbyBjb25mZXJtYSA6YXR0cmlidXRlIG5vbiDDqCB1Z3VhbGUuJyxcclxuXHQgIGVtYWlsOiAnSWwgZm9ybWF0byBkZWxsXFwnYXR0cmlidXRvIDphdHRyaWJ1dGUgbm9uIMOoIHZhbGlkby4nLFxyXG5cdCAgZGVmOiAnR2xpIGF0dHJpYnV0aSBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBjb250ZW5nb25vIGRlZ2xpIGVycm9yaS4nLFxyXG5cdCAgZGlnaXRzOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBkaSA6ZGlnaXRzIGNpZnJlLicsXHJcblx0ICBkaWZmZXJlbnQ6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGUgOmRpZmZlcmVudCBkZXZvIGVzc2VyZSBkaXZlcnNpLicsXHJcblx0ICAnaW4nOiAnSWwgdmFsb3JlIGRlbCBjYW1wbyA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIGludGVnZXI6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVuIHZhbG9yZSBpbnRlcm8uJyxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBvIHVndWFsZSBkaSA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgY29tcG9zdG8gZGEgYWxtZW5vIDptaW4gY2FyYXR0ZXJpLidcclxuXHQgIH0sXHJcblx0ICBtYXg6IHtcclxuXHQgICAgbnVtZXJpYzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgbWlub3JlIG8gdWd1YWxlIGRpIDptYXguJyxcclxuXHQgICAgc3RyaW5nOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBjb21wb3N0byBkYSBtYXNzaW1vIDptYXggY2FyYXR0ZXJpLidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICdJbCBjYW1wbyA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIG51bWVyaWM6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVuIG51bWVyby4nLFxyXG5cdCAgcmVxdWlyZWQ6ICdJbCBjYW1wbyA6YXR0cmlidXRlIMOoIHJpY2hpZXN0by4nLFxyXG5cdCAgcmVxdWlyZWRfaWY6ICdJbCBjYW1wbyA6YXR0cmlidXRlIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgY2FtcG8gOm90aGVyIMOoIHVndWFsZSBhIDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ0kgY2FtcGkgOmF0dHJpYnV0ZSBlIDpzYW1lIGRldm9ubyBlc3NlcmUgdWd1YWxpLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICdMYSBkaW1lbnNpb25lIGRlbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVndWFsZSBhIDpzaXplLicsXHJcblx0ICAgIHN0cmluZzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgZGkgOnNpemUgY2FyYXR0ZXJpLidcclxuXHQgIH0sXHJcblx0ICBzdHJpbmc6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVuYSBzdHJpbmdhLicsXHJcblx0ICB1cmw6ICdJbCBmb3JtYXRvIGRlbCBjYW1wbyA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIHJlZ2V4OiAnSWwgZm9ybWF0byBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBub24gw6ggdmFsaWRvLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgYWNjZXB0ZWQ6ICc6YXR0cmlidXRl44KS56K66KqN44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYWxwaGE6ICc6YXR0cmlidXRl44Gv6Iux5a2X44Gu44G/44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYWxwaGFfZGFzaDogJzphdHRyaWJ1dGXjga/oi7HlrZfjgajjg4Djg4Pjgrfjg6XjgajkuIvnt5rjga7jgb/jgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBhbHBoYV9udW06ICc6YXR0cmlidXRl44Gv6Iux5pWw5a2X44Gu44G/44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYmV0d2VlbjogJzphdHRyaWJ1dGXjga86bWlu44CcOm1heOaWh+Wtl+OBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAgicsXHJcblx0ICAgIGNvbmZpcm1lZDogJzphdHRyaWJ1dGXjga/norroqo3jgYzkuIDoh7TjgZfjgb7jgZvjgpPjgIInLFxyXG5cdCAgICBlbWFpbDogJzphdHRyaWJ1dGXjga/mraPjgZfjgYTjg6Hjg7zjg6vjgqLjg4njg6zjgrnjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBkZWY6ICc6YXR0cmlidXRl44Gv5qSc6Ki844Ko44Op44O844GM5ZCr44G+44KM44Gm44GE44G+44GZ44CCJyxcclxuXHQgICAgZGlnaXRzOiAnOmF0dHJpYnV0ZeOBrzpkaWdpdHPjga7mlbDlrZfjga7jgb/jgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBkaWZmZXJlbnQ6ICc6YXR0cmlidXRl44GoOmRpZmZlcmVudOOBr+WQjOOBmOOBp+OBguOBo+OBpuOBr+OBquOCiuOBvuOBm+OCk+OAgicsXHJcblx0ICAgICdpbic6ICfpgbjmip7jgZXjgozjgZ86YXR0cmlidXRl44Gv54Sh5Yq544Gn44GZ44CCJyxcclxuXHQgICAgaW50ZWdlcjogJzphdHRyaWJ1dGXjga/mlbTmlbDjgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBtaW4gICAgICAgIDoge1xyXG5cdCAgICAgICAgbnVtZXJpYyA6IFwiOmF0dHJpYnV0ZeOBrzptaW7ku6XkuIrjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgICAgIHN0cmluZyAgOiBcIjphdHRyaWJ1dGXjga86bWlu5paH5a2X5Lul5LiK44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCJcclxuXHQgICAgfSxcclxuXHQgICAgbWF4IDoge1xyXG5cdCAgICAgICAgbnVtZXJpYyA6IFwiOmF0dHJpYnV0ZeOBrzptYXjku6XkuIvjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgICAgIHN0cmluZyAgOiBcIjphdHRyaWJ1dGXjga86bWF45paH5a2X5Lul5LiK44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCJcclxuXHQgICAgfSxcclxuXHQgICAgbm90X2luICAgICAgOiBcIumBuOaKnuOBleOCjOOBnzphdHRyaWJ1dGXjga/nhKHlirnjgafjgZnjgIJcIixcclxuXHQgICAgbnVtZXJpYyAgICAgOiBcIjphdHRyaWJ1dGXjga/mlbDlgKTjgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgcmVxdWlyZWQgICAgOiBcIjphdHRyaWJ1dGXjga/lv4XpoIjjgafjgZnjgIJcIixcclxuXHQgICAgcmVxdWlyZWRfaWYgOiBcIjpvdGhlcuOBrzp2YWx1ZeOBq+OBquOBo+OBn+OCiTphdHRyaWJ1dGXjga/lv4XpoIjjgafjgZnjgIJcIixcclxuXHQgICAgc2FtZSAgICAgICAgOiBcIjphdHRyaWJ1dGXjgag6c2FtZeOBr+WQjOOBmOOBp+OBquOBkeOCjOOBsOOBquOCiuOBvuOBm+OCk+OAglwiLFxyXG5cdCAgICBzaXplICAgICAgICA6IHtcclxuXHQgICAgICAgIG51bWVyaWMgOiBcIjphdHRyaWJ1dGXjga86c2l6ZeOCkuWFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiLFxyXG5cdCAgICAgICAgc3RyaW5nICA6IFwiOmF0dHJpYnV0ZeOBrzpzaXpl5paH5a2X44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCJcclxuXHQgICAgfSxcclxuXHQgICAgdXJsICAgICAgICA6IFwiOmF0dHJpYnV0ZeOBr1VSSeOCkuWFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiLFxyXG5cdCAgICByZWdleCAgICAgIDogXCI6YXR0cmlidXRl44Gu5YCkIFxcXCI6dmFsdWVcXFwiIOOBr+ODkeOCv+ODvOODs+OBq+ODnuODg+ODgeOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglwiLFxyXG5cdCAgICBhdHRyaWJ1dGVzIDoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGFjY2VwdGVkOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyB6YWFrY2VwdG93YW5lLicsXHJcblx0ICAgIGFscGhhOiAnUG9sZSA6YXR0cmlidXRlIG1vxbxlIHphd2llcmHEhyB0eWxrbyBsaXRlcnkuJyxcclxuXHQgICAgYWxwaGFfZGFzaDogJ1BvbGUgOmF0dHJpYnV0ZSBtb3plIHphd2llcmHEhyB0eWxrbyBsaXRlcnksIG15xZtsbmlrIGkgcG9kcmtlxZtsZW5pZS4nLFxyXG5cdCAgICBhbHBoYV9udW06ICdQb2xlIDphdHRyaWJ1dGUgbW96ZSB6YXdpZXJhYyB0eWxrbyB6bmFraSBhbGZhbnVtZXJ5Y3puZS4nLFxyXG5cdCAgICBiZXR3ZWVuOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgbWllxIcgZMWCdWdvxZvEhyBvZCA6bWluIGRvIDptYXguJyxcclxuXHQgICAgY29uZmlybWVkOiAnUG9sZSA6YXR0cmlidXRlIG5pZSBzcGXFgm5pYSB3YXJ1bmt1IHBvdHdpZXJkemVuaWEuJyxcclxuXHQgICAgZW1haWw6ICdQb2xlIDphdHRyaWJ1dGUgbWEgbmllcG9wcmF3bnkgZm9ybWF0IGFkcmVzdSBlbWFpbC4nLFxyXG5cdCAgICBkZWY6ICdQb2xlIDphdHRyaWJ1dGUgemF3aWVyYSBixYLEmWR5LicsXHJcblx0ICAgIGRpZ2l0czogJ1BvbGUgOmF0dHJpYnV0ZSBtb8W8ZSB6YXdpZXJhxIcgdHlsa28gY3lmcnkgemUgemJpb3J1IDpkaWdpdHMuJyxcclxuXHQgICAgZGlmZmVyZW50OiAnUG9sYSA6YXR0cmlidXRlIGkgOmRpZmZlcmVudCBtdXN6xIUgc2nEmSByw7PFvG5pxIcuJyxcclxuXHQgICAgJ2luJzogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIG5hbGXFvGXEhyBkbyB6YmlvcnUgOmluLicsXHJcblx0ICAgIGludGVnZXI6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBiecSHIGxpY3pixIUgY2HFgmtvd2l0xIUuJyxcclxuXHQgICAgbWluOiB7XHJcblx0ICAgICAgICBudW1lcmljOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyByw7N3bmUgY29uYWptbmllaiA6bWluLicsXHJcblx0ICAgICAgICBzdHJpbmc6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSB6YXdpZXJhxIcgY29uYWptbmllaiA6bWluIHpuYWvDs3cuJ1xyXG5cdCAgICB9LFxyXG5cdCAgICBtYXg6IHtcclxuXHQgICAgICAgIG51bWVyaWM6ICdQb2xlIDphdHRyaWJ1dGUgbmllIG1vemUgYnnEhyB3acSZa3N6ZSA6bWF4LicsXHJcblx0ICAgICAgICBzdHJpbmc6ICdQb2xlIDphdHRyaWJ1dGUgbmllIG1vemUgYnnEhyBkxYJ1xbxzemUgbmnFvCA6bWF4IHpuYWvDs3cuJ1xyXG5cdCAgICB9LFxyXG5cdCAgICBub3RfaW46ICdQb2xlIDphdHRyaWJ1dGUgbmllIG1vxbxlIG5hbGXFvGXEhyBkbyB6YmlvcnUgOm5vdF9pbi4nLFxyXG5cdCAgICBudW1lcmljOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyBsaWN6YsSFLicsXHJcblx0ICAgIHJlcXVpcmVkOiAnUG9sZSA6YXR0cmlidXRlIGplc3Qgd3ltYWdhbmUuJyxcclxuXHQgICAgcmVxdWlyZWRfaWY6ICdQb2xlIDphdHRyaWJ1dGUgamVzdCB3eW1hZ2FuZSBqZcWbbGkgcG9sZSA6b3RoZXIgamVzdCByw7N3bmUgOnZhbHVlLicsXHJcblx0ICAgIHNhbWU6ICdQb2xhIDphdHRyaWJ1dGUgaSA6c2FtZSBtdXN6xIUgYnnEhyB0YWtpZSBzYW1lLicsXHJcblx0ICAgIHNpemU6IHtcclxuXHQgICAgICAgIG51bWVyaWM6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBiecSHIHLDs3duZSA6c2l6ZS4nLFxyXG5cdCAgICAgICAgc3RyaW5nOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgemF3aWVyYcSHIDpzaXplIHpuYWvDs3cuJ1xyXG5cdCAgICB9LFxyXG5cdCAgICBzdHJpbmc6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBiecSHIGNpxIVnaWVtIHpuYWvDs3cuJyxcclxuXHQgICAgdXJsOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyBwb3ByYXdueW0gYWRyZXNlbSBVUkwuJyxcclxuXHQgICAgcmVnZXg6ICdQb2xlIDphdHRyaWJ1dGUgbmllIHNwZcWCbmlhIHdhcnVua3UuJyxcclxuXHQgICAgYXR0cmlidXRlczoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBhY2NlcHRlZDogJ9CS0Ysg0LTQvtC70LbQvdGLINC/0YDQuNC90Y/RgtGMIDphdHRyaWJ1dGUuJyxcclxuXHQgIGFscGhhOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjCDRgtC+0LvRjNC60L4g0LHRg9C60LLRiy4nLFxyXG5cdCAgYWxwaGFfZGFzaDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LzQvtC20LXRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCx0YPQutCy0YssINGG0LjRhNGA0YssINC00LXRhNC40YHRiyDQuCDRgdC40LzQstC+0LvRiyDQv9C+0LTRh9GR0YDQutC40LLQsNC90LjRjy4nLFxyXG5cdCAgYWxwaGFfbnVtOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjCDRgtC+0LvRjNC60L4g0LHRg9C60LLRiyDQuCDRhtC40YTRgNGLLicsXHJcblx0ICBiZXR3ZWVuOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LzQtdC20LTRgyA6bWluINC4IDptYXguJyxcclxuXHQgIGNvbmZpcm1lZDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0L3QtSDRgdC+0LLQv9Cw0LTQsNC10YIg0YEg0L/QvtC00YLQstC10YDQttC00LXQvdC40LXQvC4nLFxyXG5cdCAgZW1haWw6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3Ri9C8INGN0LvQtdC60YLRgNC+0L3QvdGL0Lwg0LDQtNGA0LXRgdC+0LwuJyxcclxuXHQgIGRlZjogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0YHQvtC00LXRgNC20LjRgiDQvtGI0LjQsdC60LguJyxcclxuXHQgIGRpZ2l0czogJ9CU0LvQuNC90LAg0YbQuNGE0YDQvtCy0L7Qs9C+INC/0L7Qu9GPIDphdHRyaWJ1dGUg0LTQvtC70LbQvdCwINCx0YvRgtGMIDpkaWdpdHMuJyxcclxuXHQgIGRpZmZlcmVudDogJ9Cf0L7Qu9GPIDphdHRyaWJ1dGUg0LggOmRpZmZlcmVudCDQtNC+0LvQttC90Ysg0YDQsNC30LvQuNGH0LDRgtGM0YHRjy4nLFxyXG5cdCAgJ2luJzogJ9CS0YvQsdGA0LDQvdC90L7QtSDQt9C90LDRh9C10L3QuNC1INC00LvRjyA6YXR0cmlidXRlINC+0YjQuNCx0L7Rh9C90L4uJyxcclxuXHQgIGludGVnZXI6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDRhtC10LvRi9C8INGH0LjRgdC70L7QvC4nLFxyXG5cdCAgbWluOiB7XHJcblx0ICAgIG51bWVyaWM6ICfQl9C90LDRh9C10L3QuNC1INC/0L7Qu9GPIDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINCx0L7Qu9GM0YjQtSDQuNC70Lgg0YDQsNCy0L3QviA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ9Ca0L7Qu9C40YfQtdGB0YLQstC+INGB0LjQvNCy0L7Qu9C+0LIg0LIg0L/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0L3QtSDQvNC10L3QtdC1IDptaW4uJ1xyXG5cdCAgfSxcclxuXHQgIG1heDoge1xyXG5cdCAgICBudW1lcmljOiAn0JfQvdCw0YfQtdC90LjQtSDQv9C+0LvRjyA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDQvNC10L3RjNGI0LUg0LjQu9C4INGA0LDQstC90L4gOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICfQmtC+0LvQuNGH0LXRgdGC0LLQviDRgdC40LzQstC+0LvQvtCyINCyINC/0L7Qu9C1IDphdHRyaWJ1dGUg0L3QtSDQvNC+0LbQtdGCINC/0YDQtdCy0YvRiNCw0YLRjCA6bWF4LidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICfQktGL0LHRgNCw0L3QvdC+0LUg0LfQvdCw0YfQtdC90LjQtSDQtNC70Y8gOmF0dHJpYnV0ZSDQvtGI0LjQsdC+0YfQvdC+LicsXHJcblx0ICBudW1lcmljOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YfQuNGB0LvQvtC8LicsXHJcblx0ICByZXF1aXJlZDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviDQtNC70Y8g0LfQsNC/0L7Qu9C90LXQvdC40Y8uJyxcclxuXHQgIHJlcXVpcmVkX2lmOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDRgtGA0LXQsdGD0LXRgtGB0Y8g0LrQvtCz0LTQsCDQt9C90LDRh9C10L3QuNGPINC/0L7Qu9GPIDpvdGhlciDRgNCw0LLQvdC+IDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ9CX0L3QsNGH0LXQvdC40LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0YHQvtCy0L/QsNC00LDRgtGMINGBIDpzYW1lLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICfQl9C90LDRh9C10L3QuNC1INC/0L7Qu9GPIDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINGA0LDQstC90YvQvCA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICfQmtC+0LvQuNGH0LXRgdGC0LLQviDRgdC40LzQstC+0LvQvtCyINCyINC/0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINGA0LDQstC90L4gOnNpemUuJ1xyXG5cdCAgfSxcclxuXHQgIHVybDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INGB0L7QtNC10YDQttCw0YLRjCDQstCw0LvQuNC00L3Ri9C5IFVSTC4nLFxyXG5cdCAgcmVnZXg6ICfQndC10LLQtdGA0L3Ri9C5INGE0L7RgNC80LDRgiDQv9C+0LvRjyA6YXR0cmlidXRlLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTA2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgRXJyb3JzID0gZnVuY3Rpb24oKSB7XHJcblx0ICB0aGlzLmVycm9ycyA9IHt9O1xyXG5cdH07XHJcblx0XHJcblx0RXJyb3JzLnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbnN0cnVjdG9yOiBFcnJvcnMsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEFkZCBuZXcgZXJyb3IgbWVzc2FnZSBmb3IgZ2l2ZW4gYXR0cmlidXRlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZVxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgYWRkOiBmdW5jdGlvbihhdHRyaWJ1dGUsIG1lc3NhZ2UpIHtcclxuXHQgICAgaWYgKCF0aGlzLmhhcyhhdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgdGhpcy5lcnJvcnNbYXR0cmlidXRlXSA9IFtdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLmVycm9yc1thdHRyaWJ1dGVdLmluZGV4T2YobWVzc2FnZSkgPT09IC0xKSB7XHJcblx0ICAgICAgdGhpcy5lcnJvcnNbYXR0cmlidXRlXS5wdXNoKG1lc3NhZ2UpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzIGZvciBhbiBhdHRyaWJ1dGUsIG9yIGFuIGVtcHR5IGFycmF5XHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGUgQSBrZXkgaW4gdGhlIGRhdGEgb2JqZWN0IGJlaW5nIHZhbGlkYXRlZFxyXG5cdCAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzXHJcblx0ICAgKi9cclxuXHQgIGdldDogZnVuY3Rpb24oYXR0cmlidXRlKSB7XHJcblx0ICAgIGlmICh0aGlzLmhhcyhhdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW2F0dHJpYnV0ZV07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIFtdO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmV0dXJucyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYW4gYXR0cmlidXRlLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IGF0dHJpYnV0ZSBBIGtleSBpbiB0aGUgZGF0YSBvYmplY3QgYmVpbmcgdmFsaWRhdGVkXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd8ZmFsc2V9IEZpcnN0IGVycm9yIG1lc3NhZ2Ugb3IgZmFsc2VcclxuXHQgICAqL1xyXG5cdCAgZmlyc3Q6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICBpZiAodGhpcy5oYXMoYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmVycm9yc1thdHRyaWJ1dGVdWzBdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBmYWxzZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCBhbGwgZXJyb3IgbWVzc2FnZXMgZnJvbSBhbGwgZmFpbGluZyBhdHRyaWJ1dGVzXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSBGYWlsZWQgYXR0cmlidXRlIG5hbWVzIGZvciBrZXlzIGFuZCBhbiBhcnJheSBvZiBtZXNzYWdlcyBmb3IgdmFsdWVzXHJcblx0ICAgKi9cclxuXHQgIGFsbDogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLmVycm9ycztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiB0aGVyZSBhcmUgYW55IGVycm9yIG1lc3NhZ2VzIGZvciBhbiBhdHRyaWJ1dGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBhdHRyaWJ1dGUgQSBrZXkgaW4gdGhlIGRhdGEgb2JqZWN0IGJlaW5nIHZhbGlkYXRlZFxyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuXHQgICAqL1xyXG5cdCAgaGFzOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcclxuXHQgICAgaWYgKHRoaXMuZXJyb3JzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEVycm9ycztcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMDcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdGZ1bmN0aW9uIEFzeW5jUmVzb2x2ZXJzKG9uRmFpbGVkT25lLCBvblJlc29sdmVkQWxsKSB7XHJcblx0ICB0aGlzLm9uUmVzb2x2ZWRBbGwgPSBvblJlc29sdmVkQWxsO1xyXG5cdCAgdGhpcy5vbkZhaWxlZE9uZSA9IG9uRmFpbGVkT25lO1xyXG5cdCAgdGhpcy5yZXNvbHZlcnMgPSB7fTtcclxuXHQgIHRoaXMucmVzb2x2ZXJzQ291bnQgPSAwO1xyXG5cdCAgdGhpcy5wYXNzZWQgPSBbXTtcclxuXHQgIHRoaXMuZmFpbGVkID0gW107XHJcblx0ICB0aGlzLmZpcmluZyA9IGZhbHNlO1xyXG5cdH1cclxuXHRcclxuXHRBc3luY1Jlc29sdmVycy5wcm90b3R5cGUgPSB7XHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEFkZCByZXNvbHZlclxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7UnVsZX0gcnVsZVxyXG5cdCAgICogQHJldHVybiB7aW50ZWdlcn1cclxuXHQgICAqL1xyXG5cdCAgYWRkOiBmdW5jdGlvbihydWxlKSB7XHJcblx0ICAgIHZhciBpbmRleCA9IHRoaXMucmVzb2x2ZXJzQ291bnQ7XHJcblx0ICAgIHRoaXMucmVzb2x2ZXJzW2luZGV4XSA9IHJ1bGU7XHJcblx0ICAgIHRoaXMucmVzb2x2ZXJzQ291bnQrKztcclxuXHQgICAgcmV0dXJuIGluZGV4O1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVzb2x2ZSBnaXZlbiBpbmRleFxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge2ludGVnZXJ9IGluZGV4XHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICByZXNvbHZlOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdCAgICB2YXIgcnVsZSA9IHRoaXMucmVzb2x2ZXJzW2luZGV4XTtcclxuXHQgICAgaWYgKHJ1bGUucGFzc2VzID09PSB0cnVlKSB7XHJcblx0ICAgICAgdGhpcy5wYXNzZWQucHVzaChydWxlKTtcclxuXHQgICAgfSBlbHNlIGlmIChydWxlLnBhc3NlcyA9PT0gZmFsc2UpIHtcclxuXHQgICAgICB0aGlzLmZhaWxlZC5wdXNoKHJ1bGUpO1xyXG5cdCAgICAgIHRoaXMub25GYWlsZWRPbmUocnVsZSk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdGhpcy5maXJlKCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgYWxsIGhhdmUgYmVlbiByZXNvbHZlZFxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIGlzQWxsUmVzb2x2ZWQ6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICByZXR1cm4gKHRoaXMucGFzc2VkLmxlbmd0aCArIHRoaXMuZmFpbGVkLmxlbmd0aCkgPT09IHRoaXMucmVzb2x2ZXJzQ291bnQ7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBBdHRlbXB0IHRvIGZpcmUgZmluYWwgYWxsIHJlc29sdmVkIGNhbGxiYWNrIGlmIGNvbXBsZXRlZFxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIGZpcmU6IGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdCAgICBpZiAoIXRoaXMuZmlyaW5nKSB7XHJcblx0ICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLmlzQWxsUmVzb2x2ZWQoKSkge1xyXG5cdCAgICAgIHRoaXMub25SZXNvbHZlZEFsbCh0aGlzLmZhaWxlZC5sZW5ndGggPT09IDApO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBFbmFibGUgZmlyaW5nXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgZW5hYmxlRmlyaW5nOiBmdW5jdGlvbigpIHtcclxuXHQgICAgdGhpcy5maXJpbmcgPSB0cnVlO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBBc3luY1Jlc29sdmVycztcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGVcXFwiIHYtZWw6YXV0b2NvbXBsZXRlXFxuICAgIDpjbGFzcz1cXFwie1xcbiAgICAgICAgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdpbnZhbGlkJzogIXZhbGlkLCAnZGlydHknOiBkaXJ0eSwgJ2FjdGl2ZSc6IGFjdGl2ZSxcXG4gICAgICAgICdoYXMtbGFiZWwnOiAhaGlkZUxhYmVsLCAnaWNvbi1yaWdodCc6IGljb25SaWdodFxcbiAgICB9XFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWljb24td3JhcHBlclxcXCIgdi1pZj1cXFwic2hvd0ljb25cXFwiPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtaWNvblxcXCI+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtbGFiZWxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1sYWJlbC10ZXh0XFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8dWktaWNvblxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvblxcXCIgaWNvbj1cXFwiJiN4RTVDRFxcXCIgdGl0bGU9XFxcIkNsZWFyXFxcIlxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcImNsZWFyU2VhcmNoXFxcIiB2LXNob3c9XFxcIiFkaXNhYmxlZCAmJiB2YWx1ZS5sZW5ndGhcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbj5cXG5cXG4gICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFxcXCIgOnBsYWNlaG9sZGVyPVxcXCJwbGFjZWhvbGRlclxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgIDppZD1cXFwiaWRcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiB2LWF1dG9mb2N1cz1cXFwiYXV0b2ZvY3VzXFxcIiA6ZGVib3VuY2U9XFxcImRlYm91bmNlXFxcIlxcblxcbiAgICAgICAgICAgICAgICBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCIgQGtleWRvd24udXAucHJldmVudD1cXFwiaGlnaGxpZ2h0KGhpZ2hsaWdodGVkSXRlbSAtIDEpXFxcIlxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi5kb3duLnByZXZlbnQ9XFxcImhpZ2hsaWdodChoaWdobGlnaHRlZEl0ZW0gKyAxKVxcXCIgQGtleWRvd24udGFiPVxcXCJjbG9zZVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24uZW50ZXI9XFxcInNlbGVjdEhpZ2hsaWdodGVkKGhpZ2hsaWdodGVkSXRlbSwgJGV2ZW50KVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgdi1tb2RlbD1cXFwidmFsdWVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB2LWVsOmlucHV0XFxuICAgICAgICAgICAgPlxcblxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb25zXFxcIiB2LXNob3c9XFxcInNob3dEcm9wZG93blxcXCI+XFxuICAgICAgICAgICAgICAgIDx1aS1hdXRvY29tcGxldGUtc3VnZ2VzdGlvblxcbiAgICAgICAgICAgICAgICAgICAgOmhpZ2hsaWdodGVkPVxcXCJoaWdobGlnaHRlZEl0ZW0gPT09IGluZGV4XFxcIiA6aXRlbT1cXFwiaXRlbVxcXCIgOnBhcnRpYWw9XFxcInBhcnRpYWxcXFwiXFxuICAgICAgICAgICAgICAgICAgICA6a2V5cz1cXFwia2V5c1xcXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIGl0ZW0pIGluIHN1Z2dlc3Rpb25zIHwgZmlsdGVyQnkgc2VhcmNoIHwgbGltaXRCeSBsaW1pdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIHYtcmVmOml0ZW1zIEBjbGljaz1cXFwic2VsZWN0KGl0ZW0pXFxcIlxcbiAgICAgICAgICAgICAgICA+PC91aS1hdXRvY29tcGxldGUtc3VnZ2VzdGlvbj5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9sYWJlbD5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1mZWVkYmFja1xcXCIgdi1pZj1cXFwic2hvd0ZlZWRiYWNrXFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtZXJyb3ItdGV4dFxcXCIgdi10ZXh0PVxcXCJ2YWxpZGF0aW9uRXJyb3JcXFwiXFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb249XFxcInVpLWF1dG9jb21wbGV0ZS1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtc2hvdz1cXFwiIWhpZGVWYWxpZGF0aW9uRXJyb3JzICYmICF2YWxpZFxcXCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWhlbHAtdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktYXV0b2NvbXBsZXRlLWZlZWRiYWNrLXRvZ2dsZVxcXCJcXG4gICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCIgdi1lbHNlXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTA5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDExMClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQnV0dG9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQnV0dG9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTWVudSk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcclxuXHRcclxuXHR2YXIgX1VpUG9wb3ZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVBvcG92ZXIpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0NpcmN1bGFyKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9IYXNEcm9wZG93biA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xyXG5cdFxyXG5cdHZhciBfSGFzRHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGFzRHJvcGRvd24pO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWJ1dHRvbicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndWktYnV0dG9uLScgKyB0eXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBidXR0b25UeXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdzdWJtaXQnIH0sXHJcblx0ICAgICAgICBjb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByYWlzZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvblJpZ2h0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxvYWRpbmc6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd0Ryb3Bkb3duSWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc3R5bGVDbGFzc2VzOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbdGhpcy50eXBlLCB0aGlzLmNvbG9yXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5yYWlzZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd1aS1idXR0b24tcmFpc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhhc0Ryb3Bkb3duTWVudSB8fCB0aGlzLmhhc1BvcG92ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdoYXMtZHJvcGRvd24nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3Bpbm5lckNvbG9yOiBmdW5jdGlvbiBzcGlubmVyQ29sb3IoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IgPT09ICdjb2xvci1kZWZhdWx0JyB8fCB0aGlzLnR5cGUgPT09ICd1aS1idXR0b24tZmxhdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdibGFjayc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dJY29uOiBmdW5jdGlvbiBzaG93SWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmljb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaU1lbnU6IF9VaU1lbnUyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVBvcG92ZXI6IF9VaVBvcG92ZXIyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc0Ryb3Bkb3duMi5kZWZhdWx0LCBfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHRdLFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTEyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGJ1dHRvblxcbiAgICBjbGFzcz1cXFwidWktYnV0dG9uXFxcIiA6Y2xhc3M9XFxcInN0eWxlQ2xhc3Nlc1xcXCIgOnR5cGU9XFxcImJ1dHRvblR5cGVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkIHx8IGxvYWRpbmdcXFwiXFxuICAgIHYtZWw6YnV0dG9uXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1idXR0b24tY29udGVudFxcXCIgOmNsYXNzPVxcXCJ7ICdpbnZpc2libGUnOiBsb2FkaW5nIH1cXFwiPlxcbiAgICAgICAgPHVpLWljb25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktYnV0dG9uLWljb25cXFwiIDpjbGFzcz1cXFwieyAncG9zaXRpb24tcmlnaHQnOiBpY29uUmlnaHQgfVxcXCIgOmljb249XFxcImljb25cXFwiXFxuICAgICAgICAgICAgdi1pZj1cXFwic2hvd0ljb25cXFwiXFxuICAgICAgICA+PC91aS1pY29uPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktYnV0dG9uLXRleHRcXFwiPlxcbiAgICAgICAgICAgIDxzbG90PlxcbiAgICAgICAgICAgICAgICA8c3BhbiB2LXRleHQ9XFxcInRleHRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDx1aS1pY29uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLWJ1dHRvbi1kcm9wZG93bi1pY29uXFxcIiBpY29uPVxcXCImI3hFNUM1O1xcXCJcXG4gICAgICAgICAgICB2LWlmPVxcXCIhaWNvblJpZ2h0ICYmIHNob3dEcm9wZG93bkljb24gJiYgKGhhc0Ryb3Bkb3duTWVudSB8fCBoYXNQb3BvdmVyKVxcXCJcXG4gICAgICAgID48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8dWktcHJvZ3Jlc3MtY2lyY3VsYXJcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1idXR0b24tc3Bpbm5lclxcXCIgOmNvbG9yPVxcXCJzcGlubmVyQ29sb3JcXFwiIDpzaXplPVxcXCIxOFxcXCIgOnN0cm9rZT1cXFwiNC41XFxcIlxcbiAgICAgICAgZGlzYWJsZS10cmFuc2l0aW9uIHYtc2hvdz1cXFwibG9hZGluZ1xcXCJcXG4gICAgPjwvdWktcHJvZ3Jlc3MtY2lyY3VsYXI+XFxuXFxuICAgIDx1aS1yaXBwbGUtaW5rIHYtaWY9XFxcIiFoaWRlUmlwcGxlSW5rICYmICFkaXNhYmxlZFxcXCIgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIj48L3VpLXJpcHBsZS1pbms+XFxuXFxuICAgIDx1aS1tZW51XFxuICAgICAgICBjbGFzcz1cXFwidWktYnV0dG9uLWRyb3Bkb3duLW1lbnVcXFwiIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOm9wdGlvbnM9XFxcIm1lbnVPcHRpb25zXFxcIlxcbiAgICAgICAgOnNob3ctaWNvbnM9XFxcInNob3dNZW51SWNvbnNcXFwiIDpzaG93LXNlY29uZGFyeS10ZXh0PVxcXCJzaG93TWVudVNlY29uZGFyeVRleHRcXFwiXFxuICAgICAgICA6b3Blbi1vbj1cXFwib3BlbkRyb3Bkb3duT25cXFwiIEBvcHRpb24tc2VsZWN0ZWQ9XFxcIm1lbnVPcHRpb25TZWxlY3RcXFwiXFxuICAgICAgICA6ZHJvcGRvd24tcG9zaXRpb249XFxcImRyb3Bkb3duUG9zaXRpb25cXFwiIHYtaWY9XFxcImhhc0Ryb3Bkb3duTWVudVxcXCJcXG4gICAgPjwvdWktbWVudT5cXG5cXG4gICAgPHVpLXBvcG92ZXJcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOm9wZW4tb249XFxcIm9wZW5Ecm9wZG93bk9uXFxcIiA6ZHJvcGRvd24tcG9zaXRpb249XFxcImRyb3Bkb3duUG9zaXRpb25cXFwiXFxuICAgICAgICB2LWlmPVxcXCJoYXNQb3BvdmVyXFxcIlxcbiAgICA+XFxuICAgICAgICA8c2xvdCBuYW1lPVxcXCJwb3BvdmVyXFxcIj48L3Nsb3Q+XFxuICAgIDwvdWktcG9wb3Zlcj5cXG48L2J1dHRvbj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDExMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMTQpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUNoZWNrYm94LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQ2hlY2tib3gudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDExNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDExNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1jaGVja2JveCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBuYW1lOiBTdHJpbmcsXHJcblx0ICAgICAgICBtb2RlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFtBcnJheSwgU3RyaW5nLCBCb29sZWFuXSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB2YWx1ZTogU3RyaW5nLFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbExlZnQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGlzQ2hlY2tlZDogZnVuY3Rpb24gaXNDaGVja2VkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmluZGV4T2YodGhpcy52YWx1ZSkgPiAtMTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMubW9kZWw7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGFiZWxcXG4gICAgY2xhc3M9XFxcInVpLWNoZWNrYm94XFxcIlxcbiAgICA6Y2xhc3M9XFxcIntcXG4gICAgICAgICdkaXNhYmxlZCc6IGRpc2FibGVkLCAnY2hlY2tlZCc6IGlzQ2hlY2tlZCwgJ2FjdGl2ZSc6IGFjdGl2ZSwgJ2xhYmVsLWxlZnQnOiBsYWJlbExlZnRcXG4gICAgfVxcXCJcXG4+XFxuICAgIDxpbnB1dFxcbiAgICAgICAgY2xhc3M9XFxcInVpLWNoZWNrYm94LWlucHV0XFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiIEBmb2N1cz1cXFwiZm9jdXNcXFwiIEBibHVyPVxcXCJibHVyXFxcIlxcbiAgICAgICAgOnZhbHVlPVxcXCJ2YWx1ZSA/IHZhbHVlIDogbnVsbFxcXCIgdi1tb2RlbD1cXFwibW9kZWxcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIlxcbiAgICA+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoZWNrYm94LWNoZWNrbWFya1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGVja2JveC1mb2N1cy1yaW5nXFxcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoZWNrYm94LWxhYmVsLXRleHRcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJsYWJlbFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9zbG90PlxcbiAgICA8L2Rpdj5cXG48L2xhYmVsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTE3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDExOClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQ29sbGFwc2libGUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlDb2xsYXBzaWJsZS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTE4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTE5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF91dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XHJcblx0XHJcblx0dmFyIF91dWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V1aWQpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1JpcHBsZUluayk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktY29sbGFwc2libGUnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIG9wZW46IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVhZGVyOiBTdHJpbmcsXHJcblx0ICAgICAgICB0cmFuc2l0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd1aS1jb2xsYXBzaWJsZS10b2dnbGUnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZUljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGhlaWdodDogMCxcclxuXHQgICAgICAgICAgICBpc1JlYWR5OiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGljb246IGZ1bmN0aW9uIGljb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbiA/ICdrZXlib2FyZF9hcnJvd191cCcgOiAna2V5Ym9hcmRfYXJyb3dfZG93bic7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2FsY3VsYXRlZEhlaWdodDogZnVuY3Rpb24gY2FsY3VsYXRlZEhlaWdodCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdpbml0aWFsJztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ICsgJ3B4JztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IF91dWlkMi5kZWZhdWx0LnNob3J0KCd1aS1jb2xsYXBzaWJsZS0nKTtcclxuXHQgICAgfSxcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCk7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWNvbGxhcHNpYmxlOjpyZWZyZXNoLWhlaWdodCc6IGZ1bmN0aW9uIHVpQ29sbGFwc2libGVSZWZyZXNoSGVpZ2h0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnNldEhlaWdodCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIHRvZ2dsZU1lbnU6IGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24gc2V0SGVpZ2h0KCkge1xyXG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gdGhpcy4kZWxzLmJvZHk7XHJcblx0XHJcblx0ICAgICAgICAgICAgYm9keS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGJvZHkuc2Nyb2xsSGVpZ2h0O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5vcGVuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1JpcHBsZUluazIuZGVmYXVsdCwgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF0sXHJcblx0XHJcblx0ICAgIHRyYW5zaXRpb25zOiB7XHJcblx0ICAgICAgICAndWktY29sbGFwc2libGUtdG9nZ2xlJzoge1xyXG5cdCAgICAgICAgICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdvcGVuZWQnKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGFmdGVyTGVhdmU6IGZ1bmN0aW9uIGFmdGVyTGVhdmUoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTIwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktY29sbGFwc2libGVcXFwiPlxcbiAgICA8YnV0dG9uXFxuICAgICAgICBjbGFzcz1cXFwidWktY29sbGFwc2libGUtaGVhZGVyXFxcIiA6Y2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogZGlzYWJsZWQgfVxcXCIgOmFyaWEtY29udHJvbHM9XFxcImlkXFxcIlxcbiAgICAgICAgOmFyaWEtZXhwYW5kZWQ9XFxcIm9wZW4gPyAndHJ1ZScgOiAnZmFsc2UnXFxcIiBAY2xpY2s9XFxcInRvZ2dsZU1lbnVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgdi1lbDpidXR0b25cXG4gICAgPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY29sbGFwc2libGUtaGVhZGVyLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxzbG90IG5hbWU9XFxcImhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgdi10ZXh0PVxcXCJoZWFkZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvc2xvdD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPHVpLWljb24gY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlLWhlYWRlci1pY29uXFxcIiA6aWNvbj1cXFwiaWNvblxcXCIgdi1pZj1cXFwiIWhpZGVJY29uXFxcIj48L3VpLWljb24+XFxuXFxuICAgICAgICA8dWktcmlwcGxlLWlua1xcbiAgICAgICAgICAgIHYtaWY9XFxcIiFoaWRlUmlwcGxlSW5rICYmICFkaXNhYmxlZCAmJiBpc1JlYWR5XFxcIiA6dHJpZ2dlcj1cXFwiJGVscy5idXR0b25cXFwiXFxuICAgICAgICA+PC91aS1yaXBwbGUtaW5rPlxcbiAgICA8L2J1dHRvbj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlLWJvZHktd3JhcHBlclxcXCIgOnRyYW5zaXRpb249XFxcInRyYW5zaXRpb25cXFwiXFxuICAgICAgICA6c3R5bGU9XFxcInsgJ2hlaWdodCc6IGNhbGN1bGF0ZWRIZWlnaHQgfVxcXCIgdi1zaG93PVxcXCJvcGVuXFxcInYtZWw6Ym9keVxcbiAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jb2xsYXBzaWJsZS1ib2R5XFxcIiA6aWQ9XFxcImlkXFxcIiA6YXJpYS1oaWRkZW49XFxcIm9wZW4gPyBudWxsIDogJ3RydWUnXFxcIj5cXG4gICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMjEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTIyKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlDb25maXJtLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQ29uZmlybS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTIyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTIzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc2xpc3QpO1xyXG5cdFxyXG5cdHZhciBfVWlNb2RhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0KTtcclxuXHRcclxuXHR2YXIgX1VpTW9kYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNb2RhbCk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWNvbmZpcm0nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgc2hvdzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeScgfSxcclxuXHQgICAgICAgIGhlYWRlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnVWlDb25maXJtJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNvbmZpcm1CdXR0b25UZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdPSydcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjb25maXJtQnV0dG9uSWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgZGVueUJ1dHRvblRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ0NhbmNlbCdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZW55QnV0dG9uSWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgYXV0b2ZvY3VzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdkZW55LWJ1dHRvbicgfSxcclxuXHQgICAgICAgIGNsb3NlT25Db25maXJtOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJhY2tkcm9wRGlzbWlzc2libGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBjb25maXJtOiBmdW5jdGlvbiBjb25maXJtKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjb25maXJtZWQnKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jbG9zZU9uQ29uZmlybSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVueTogZnVuY3Rpb24gZGVueSgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGVuaWVkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbmVkOiBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHZvaWQgMDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5hdXRvZm9jdXMgPT09ICdjb25maXJtLWJ1dHRvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgYnV0dG9uID0gdGhpcy4kZWxzLmNvbmZpcm1CdXR0b247XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9mb2N1cyA9PT0gJ2RlbnktYnV0dG9uJykge1xyXG5cdCAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLiRlbHMuZGVueUJ1dHRvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGJ1dHRvbikge1xyXG5cdCAgICAgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LmFkZChidXR0b24sICdhdXRvZm9jdXMnKTtcclxuXHQgICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnJlbW92ZUF1dG9Gb2N1cyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbi5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZW1vdmVBdXRvRm9jdXM6IGZ1bmN0aW9uIHJlbW92ZUF1dG9Gb2N1cygpIHtcclxuXHQgICAgICAgICAgICB2YXIgYnV0dG9uID0gdm9pZCAwO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmF1dG9mb2N1cyA9PT0gJ2NvbmZpcm0tYnV0dG9uJykge1xyXG5cdCAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLiRlbHMuY29uZmlybUJ1dHRvbjtcclxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b2ZvY3VzID09PSAnZGVueS1idXR0b24nKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbiA9IHRoaXMuJGVscy5kZW55QnV0dG9uO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoYnV0dG9uKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5yZW1vdmVBdXRvRm9jdXMpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LnJlbW92ZShidXR0b24sICdhdXRvZm9jdXMnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpTW9kYWw6IF9VaU1vZGFsMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlCdXR0b246IF9VaUJ1dHRvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMjUpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNilcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaU1vZGFsLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpTW9kYWwudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NsaXN0KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLW1vZGFsJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd1aS1tb2RhbC0nICsgdHlwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVhZGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdVaU1vZGFsIEhlYWRlcidcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBib2R5OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdVaU1vZGFsIGJvZHknXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcm9sZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGlhbG9nJyB9LFxyXG5cdCAgICAgICAgdHJhbnNpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndWktbW9kYWwtc2NhbGUnIH0sXHJcblx0ICAgICAgICBzaG93Q2xvc2VCdXR0b246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlRm9vdGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc21pc3NpYmxlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmFja2Ryb3BEaXNtaXNzaWJsZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBsYXN0Rm9jdXNzZWRFbGVtZW50OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICB3YXRjaDoge1xyXG5cdCAgICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNob3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLm9wZW5lZCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2VkKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnNob3cpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRlYXJEb3duKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmRpc21pc3NpYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PT0gdGhpcy4kZWxzLm1vZGFsTWFzayAmJiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PT0gdGhpcy4kZWxzLm1vZGFsTWFzayAmJiAhdGhpcy5iYWNrZHJvcERpc21pc3NpYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbmVkOiBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0Rm9jdXNzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuXHQgICAgICAgICAgICB0aGlzLiRlbHMubW9kYWxDb250YWluZXIuZm9jdXMoKTtcclxuXHRcclxuXHQgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LmFkZChkb2N1bWVudC5ib2R5LCAndWktbW9kYWwtb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZXN0cmljdEZvY3VzLCB0cnVlKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VkOiBmdW5jdGlvbiBjbG9zZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50ZWFyRG93bigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZWRpcmVjdEZvY3VzOiBmdW5jdGlvbiByZWRpcmVjdEZvY3VzKGUpIHtcclxuXHQgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGVscy5tb2RhbENvbnRhaW5lci5mb2N1cygpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJlc3RyaWN0Rm9jdXM6IGZ1bmN0aW9uIHJlc3RyaWN0Rm9jdXMoZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy4kZWxzLm1vZGFsQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRlbHMubW9kYWxDb250YWluZXIuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xyXG5cdCAgICAgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQucmVtb3ZlKGRvY3VtZW50LmJvZHksICd1aS1tb2RhbC1vcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxhc3RGb2N1c3NlZEVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5sYXN0Rm9jdXNzZWRFbGVtZW50LmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgncmV2ZWFsZWQnKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnaGlkZGVuJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb25CdXR0b246IF9VaUljb25CdXR0b24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaUJ1dHRvbjogX1VpQnV0dG9uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTI3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktbW9kYWwgdWktbW9kYWwtbWFza1xcXCIgdi1zaG93PVxcXCJzaG93XFxcIiA6dHJhbnNpdGlvbj1cXFwidHJhbnNpdGlvblxcXCIgOmNsYXNzPVxcXCJbdHlwZV1cXFwiXFxuICAgIDpyb2xlPVxcXCJyb2xlXFxcIiBAdHJhbnNpdGlvbmVuZD1cXFwidHJhbnNpdGlvbkVuZCB8IGRlYm91bmNlIDEwMFxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLW1vZGFsLXdyYXBwZXJcXFwiIEBjbGljaz1cXFwiY2xvc2VcXFwiIHYtZWw6bW9kYWwtbWFzaz5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktbW9kYWwtY29udGFpbmVyXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIEBrZXlkb3duLmVzYz1cXFwiY2xvc2VcXFwiXFxuICAgICAgICAgICAgdi1lbDptb2RhbC1jb250YWluZXJcXG4gICAgICAgID5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVxcXCJoZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGgxIHYtdGV4dD1cXFwiaGVhZGVyXFxcIiBjbGFzcz1cXFwidWktbW9kYWwtaGVhZGVyLXRleHRcXFwiPjwvaDE+XFxuICAgICAgICAgICAgICAgIDwvc2xvdD5cXG5cXG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiJiN4RTVDRFxcXCIgY2xhc3M9XFxcInVpLW1vZGFsLWNsb3NlLWJ1dHRvblxcXCIgQGNsaWNrPVxcXCJjbG9zZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cXFwiIWRpc21pc3NpYmxlXFxcIiB2LWlmPVxcXCJzaG93Q2xvc2VCdXR0b25cXFwiIHYtZWw6Y2xvc2UtYnV0dG9uXFxuICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi10ZXh0PVxcXCJib2R5XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW1vZGFsLWZvb3RlclxcXCIgdi1pZj1cXFwiIWhpZGVGb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHVpLWJ1dHRvbiBAY2xpY2s9XFxcImNsb3NlXFxcIiB2LWlmPVxcXCJkaXNtaXNzaWJsZVxcXCI+Q2xvc2U8L3VpLWJ1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvY3VzLXJlZGlyZWN0b3JcXFwiIEBmb2N1cz1cXFwicmVkaXJlY3RGb2N1c1xcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTI4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktY29uZmlybVxcXCI+XFxuICAgIDx1aS1tb2RhbFxcbiAgICAgICAgOnNob3cuc3luYz1cXFwic2hvd1xcXCIgcm9sZT1cXFwiYWxlcnRkaWFsb2dcXFwiIDpoZWFkZXI9XFxcImhlYWRlclxcXCIgQG9wZW5lZD1cXFwib3BlbmVkXFxcIiBzaG93LWNsb3NlLWJ1dHRvblxcbiAgICAgICAgOmRpc21pc3NpYmxlPVxcXCIhbG9hZGluZ1xcXCIgOmJhY2tkcm9wLWRpc21pc3NpYmxlPVxcXCJiYWNrZHJvcERpc21pc3NpYmxlXFxcIlxcbiAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jb25maXJtLW1lc3NhZ2VcXFwiPlxcbiAgICAgICAgICAgIDxzbG90Pjwvc2xvdD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBzbG90PVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgIDx1aS1idXR0b25cXG4gICAgICAgICAgICAgICAgOmNvbG9yPVxcXCJ0eXBlXFxcIiA6dGV4dD1cXFwiY29uZmlybUJ1dHRvblRleHRcXFwiIDppY29uPVxcXCJjb25maXJtQnV0dG9uSWNvblxcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJjb25maXJtXFxcIiA6bG9hZGluZz1cXFwibG9hZGluZ1xcXCIgdi1lbDpjb25maXJtLWJ1dHRvblxcbiAgICAgICAgICAgID48L3VpLWJ1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgICAgIDp0ZXh0PVxcXCJkZW55QnV0dG9uVGV4dFxcXCIgOmljb249XFxcImRlbnlCdXR0b25JY29uXFxcIiBAY2xpY2s9XFxcImRlbnlcXFwiXFxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cXFwibG9hZGluZ1xcXCIgdi1lbDpkZW55LWJ1dHRvblxcbiAgICAgICAgICAgID48L3VpLWJ1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L3VpLW1vZGFsPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTI5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMxKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpRmFiLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMyKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpRmFiLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9TaG93c1Rvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1Rvb2x0aXApO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWZhYicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd1aS1mYWItJyArIHR5cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhcmlhTGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1Nob3dzVG9vbHRpcDIuZGVmYXVsdCwgX1Nob3dzUmlwcGxlSW5rMi5kZWZhdWx0XSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxidXR0b25cXG4gICAgY2xhc3M9XFxcInVpLWZhYlxcXCIgOmNsYXNzPVxcXCJbdGhpcy50eXBlLCB0aGlzLmNvbG9yXVxcXCIgOmFyaWEtbGFiZWw9XFxcImFyaWFMYWJlbCB8fCB0b29sdGlwXFxcIlxcbiAgICB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdi1lbDpidXR0b25cXG4+XFxuICAgIDx1aS1pY29uIGNsYXNzPVxcXCJ1aS1mYWItaWNvblxcXCIgOmljb249XFxcImljb25cXFwiPjwvdWktaWNvbj5cXG5cXG4gICAgPHVpLXJpcHBsZS1pbmsgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiPjwvdWktcmlwcGxlLWluaz5cXG5cXG4gICAgPHVpLXRvb2x0aXBcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOmNvbnRlbnQ9XFxcInRvb2x0aXBcXFwiIDpwb3NpdGlvbj1cXFwidG9vbHRpcFBvc2l0aW9uXFxcIiB2LWlmPVxcXCJ0b29sdGlwXFxcIlxcbiAgICAgICAgOm9wZW4tb249XFxcIm9wZW5Ub29sdGlwT25cXFwiXFxuICAgID48L3VpLXRvb2x0aXA+XFxuPC9idXR0b24+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTM0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlQcmVsb2FkZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlQcmVsb2FkZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXByZWxvYWRlcicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBzaG93OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXByZWxvYWRlclxcXCI+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcmVsb2FkZXItcHJvZ3Jlc3NiYXJcXFwiIDpjbGFzcz1cXFwieyAnbG9hZGluZycgOiBzaG93IH1cXFwiXFxuICAgICAgICA6YXJpYS1idXN5PVxcXCJzaG93ID8gJ3RydWUnIDogZmFsc2VcXFwiIHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIlxcbiAgICA+PC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTM4KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzkpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlQcm9ncmVzc0xpbmVhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVByb2dyZXNzTGluZWFyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1wcm9ncmVzcy1saW5lYXInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgc2hvdzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdpbmRldGVybWluYXRlJyB9LFxyXG5cdCAgICAgICAgY29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdmFsdWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMFxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPiAxMDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTQwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtbGluZWFyXFxcIiA6Y2xhc3M9XFxcIltjb2xvcl1cXFwiIHYtc2hvdz1cXFwic2hvd1xcXCJcXG4gICAgdHJhbnNpdGlvbj1cXFwidWktcHJvZ3Jlc3MtbGluZWFyLXRvZ2dsZVxcXCJcXG4+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcm9ncmVzcy1saW5lYXItZGV0ZXJtaW5hdGVcXFwiIDpzdHlsZT1cXFwieyAnd2lkdGgnOiBwcm9ncmVzcyArICclJyB9XFxcIlxcbiAgICAgICAgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIiA6YXJpYS12YWx1ZW5vdz1cXFwidmFsdWVcXFwiXFxuICAgICAgICB2LWlmPVxcXCJ0eXBlID09PSAnZGV0ZXJtaW5hdGUnXFxcIlxcbiAgICA+PC9kaXY+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcm9ncmVzcy1saW5lYXItaW5kZXRlcm1pbmF0ZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIlxcbiAgICAgICAgOmFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCIgdi1lbHNlXFxuICAgID48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNDIpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MylcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVJhZGlvLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmFkaW8udnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJhZGlvJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBuYW1lOiBTdHJpbmcsXHJcblx0ICAgICAgICBtb2RlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnJyxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjaGVja2VkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHZhbHVlOiBTdHJpbmcsXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsTGVmdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZm9jdXNzZWQnKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2JsdXJyZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsYWJlbFxcbiAgICBjbGFzcz1cXFwidWktcmFkaW9cXFwiXFxuICAgIDpjbGFzcz1cXFwieyAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2NoZWNrZWQnOiBhY3RpdmUsICdsYWJlbC1sZWZ0JzogbGFiZWxMZWZ0IH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpby1pbnB1dC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1yYWRpby1pbnB1dFxcXCIgdHlwZT1cXFwicmFkaW9cXFwiIDppZD1cXFwiaWRcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIiA6dmFsdWU9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgIDpjaGVja2VkPVxcXCJjaGVja2VkXFxcIiBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCIgdi1tb2RlbD1cXFwibW9kZWxcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgPlxcblxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXJhZGlvLWJvcmRlclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXJhZGlvLWlubmVyLWRvdFxcXCI+PC9zcGFuPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktcmFkaW8tbGFiZWwtdGV4dFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+XFxuICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICA8c3BhbiB2LXRleHQ9XFxcImxhYmVsXFxcIj48L3NwYW4+XFxuICAgICAgICA8L3Nsb3Q+XFxuICAgIDwvZGl2PlxcbjwvbGFiZWw+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTQ2KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDcpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlSYWRpb0dyb3VwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ4KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmFkaW9Hcm91cC52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfVWlSYWRpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQxKTtcclxuXHRcclxuXHR2YXIgX1VpUmFkaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYWRpbyk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktcmFkaW8tZ3JvdXAnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgbmFtZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICcnLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wdGlvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBoaWRlTGFiZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVscFRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIHZlcnRpY2FsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93RmVlZGJhY2s6IGZ1bmN0aW9uIHNob3dGZWVkYmFjaygpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhlbHBUZXh0KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVJhZGlvOiBfVWlSYWRpbzIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19SZWNlaXZlc1RhcmdldGVkRXZlbnQyLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwXFxcIiA6aWQ9XFxcImlkXFxcIlxcbiAgICA6Y2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdhY3RpdmUnOiBhY3RpdmUsICd2ZXJ0aWNhbCc6IHZlcnRpY2FsIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpby1ncm91cC1sYWJlbFxcXCIgdi10ZXh0PVxcXCJsYWJlbFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+PC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLW9wdGlvbnMtd3JhcHBlclxcXCI+XFxuICAgICAgICA8dWktcmFkaW9cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktcmFkaW8tZ3JvdXAtcmFkaW9cXFwiIHYtZm9yPVxcXCJvcHRpb24gaW4gb3B0aW9uc1xcXCIgOm1vZGVsLnN5bmM9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgIDpuYW1lPVxcXCJuYW1lXFxcIiA6bGFiZWw9XFxcIm9wdGlvbi50ZXh0IHx8IG9wdGlvblxcXCIgOnZhbHVlPVxcXCJvcHRpb24udmFsdWUgfHwgb3B0aW9uXFxcIlxcbiAgICAgICAgICAgIDpkaXNhYmxlZD1cXFwiZGlzYWJsZWQgfHwgb3B0aW9uLmRpc2FibGVkXFxcIiBAZm9jdXNzZWQ9XFxcImZvY3VzXFxcIiBAYmx1cnJlZD1cXFwiYmx1clxcXCJcXG4gICAgICAgID48L3VpLXJhZGlvPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2tcXFwiXFxuICAgICAgICB0cmFuc2l0aW9uPVxcXCJ1aS1yYWRpby1ncm91cC1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLWhlbHAtdGV4dFxcXCIgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUmF0aW5nLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTU2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmF0aW5nLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJhdGluZ0ljb24pO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJhdGluZycsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdzdGFyJyB9LFxyXG5cdCAgICAgICAgdmFsdWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG90YWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhlbHBUZXh0OiBTdHJpbmcsXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbml0aWFsVmFsdWU6IDAsXHJcblx0ICAgICAgICAgICAgcHJldmlld1ZhbHVlOiAwLFxyXG5cdCAgICAgICAgICAgIHByZXZpZXdpbmc6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ZlZWRiYWNrOiBmdW5jdGlvbiBzaG93RmVlZGJhY2soKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5oZWxwVGV4dCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5wcmV2aWV3VmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHByZXZpZXdWYWx1ZTogZnVuY3Rpb24gcHJldmlld1ZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdwcmV2aWV3LXZhbHVlLWNoYW5nZWQnLCB0aGlzLnByZXZpZXdWYWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLnByZXZpZXdWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBzdGFydFByZXZpZXc6IGZ1bmN0aW9uIHN0YXJ0UHJldmlldygpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld2luZyA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZW5kUHJldmlldzogZnVuY3Rpb24gZW5kUHJldmlldygpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld2luZyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld1ZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwcmV2aWV3OiBmdW5jdGlvbiBwcmV2aWV3KG4pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld1ZhbHVlID0gbiArIDE7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY29tbWl0VmFsdWU6IGZ1bmN0aW9uIGNvbW1pdFZhbHVlKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPiAwICYmIHZhbHVlIDw9IHRoaXMudG90YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmNyZW1lbnRQcmV2aWV3VmFsdWU6IGZ1bmN0aW9uIGluY3JlbWVudFByZXZpZXdWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBwcm9wb3NlZFZhbHVlID0gdGhpcy5wcmV2aWV3VmFsdWUgKyAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChwcm9wb3NlZFZhbHVlIDw9IHRoaXMudG90YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wcmV2aWV3VmFsdWUgPSBwcm9wb3NlZFZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZWNyZW1lbnRQcmV2aWV3VmFsdWU6IGZ1bmN0aW9uIGRlY3JlbWVudFByZXZpZXdWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBwcm9wb3NlZFZhbHVlID0gdGhpcy5wcmV2aWV3VmFsdWUgLSAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChwcm9wb3NlZFZhbHVlID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnByZXZpZXdWYWx1ZSA9IHByb3Bvc2VkVmFsdWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydFByZXZpZXcoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5jb21taXRWYWx1ZSh0aGlzLnByZXZpZXdWYWx1ZSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5lbmRQcmV2aWV3KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpUmF0aW5nSWNvbjogX1VpUmF0aW5nSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTUzKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTQpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlSYXRpbmdJY29uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTU1KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmF0aW5nSWNvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTUzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTU0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1yYXRpbmctaWNvbicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdzdGFyJyB9LFxyXG5cdCAgICAgICAgc2VsZWN0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZmlsbGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgaWNvbjogZnVuY3Rpb24gaWNvbigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5maWxsZWQgfHwgdGhpcy5zZWxlY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RhcicgPyAnc3RhcicgOiAnZmF2b3JpdGUnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RhcicgPyAnc3Rhcl9ib3JkZXInIDogJ2Zhdm9yaXRlX2JvcmRlcic7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXJhdGluZy1pY29uXFxcIj5cXG4gICAgPHVpLWljb25cXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1yYXRpbmctaWNvbi1pY29uXFxcIiA6aWNvbj1cXFwiaWNvblxcXCJcXG4gICAgICAgIDpjbGFzcz1cXFwieyAnc2VsZWN0ZWQnOiBzZWxlY3RlZCwgJ2ZpbGxlZCcgOiBmaWxsZWQgfVxcXCJcXG4gICAgPjwvdWktaWNvbj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXJhdGluZ1xcXCIgOmNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6IGRpc2FibGVkLCAncHJldmlldyc6IHByZXZpZXdpbmcsICdhY3RpdmUnOiBhY3RpdmUgfVxcXCJcXG5cXG4gICAgOnRhYmluZGV4PVxcXCJkaXNhYmxlZCA/IG51bGwgOiAwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwidG90YWxcXFwiXFxuICAgIDphcmlhLXZhbHVlbm93PVxcXCJwcmV2aWV3VmFsdWVcXFwiXFxuXFxuICAgIEBrZXlkb3duLnVwLnByZXZlbnQ9XFxcImluY3JlbWVudFByZXZpZXdWYWx1ZVxcXCIgQGtleWRvd24uZG93bi5wcmV2ZW50PVxcXCJkZWNyZW1lbnRQcmV2aWV3VmFsdWVcXFwiXFxuICAgIEBrZXlkb3duLnJpZ2h0LnByZXZlbnQ9XFxcImluY3JlbWVudFByZXZpZXdWYWx1ZVxcXCIgQGtleWRvd24ubGVmdC5wcmV2ZW50PVxcXCJkZWNyZW1lbnRQcmV2aWV3VmFsdWVcXFwiXFxuICAgIEBrZXlkb3duLmVudGVyLnByZXZlbnQ9XFxcImNvbW1pdFZhbHVlKHByZXZpZXdWYWx1ZSlcXFwiIEBmb2N1cz1cXFwiZm9jdXNcXFwiIEBibHVyPVxcXCJibHVyXFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktcmF0aW5nLWxhYmVsXFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLXJhdGluZy1pY29ucy13cmFwcGVyXFxcIiBAbW91c2VlbnRlcj1cXFwic3RhcnRQcmV2aWV3XFxcIiBAbW91c2VsZWF2ZT1cXFwiZW5kUHJldmlld1xcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLXJhdGluZy1pY29uXFxuICAgICAgICAgICAgOnR5cGU9XFxcInR5cGVcXFwiIHYtZm9yPVxcXCJuIGluIHRvdGFsXFxcIiA6c2VsZWN0ZWQ9XFxcIihuICsgMSkgPD0gdmFsdWVcXFwiIEBtb3VzZW92ZXI9XFxcInByZXZpZXcobilcXFwiXFxuICAgICAgICAgICAgOmZpbGxlZD1cXFwiKG4gKyAxKSA8PSBwcmV2aWV3VmFsdWVcXFwiIEBjbGljaz1cXFwiY29tbWl0VmFsdWUobiArIDEpXFxcIlxcbiAgICAgICAgPjwvdWktcmF0aW5nLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktcmF0aW5nLWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2tcXFwiIHRyYW5zaXRpb249XFxcInVpLXJhdGluZy1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhdGluZy1oZWxwLXRleHRcXFwiIHYtdGV4dD1cXFwiaGVscFRleHRcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNTgpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVJhdGluZ1ByZXZpZXcudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjApXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlSYXRpbmdQcmV2aWV3LnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJhdGluZ0ljb24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktcmF0aW5nLXByZXZpZXcnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnc3RhcicgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG90YWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlSYXRpbmdJY29uOiBfVWlSYXRpbmdJY29uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTYwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcmF0aW5nLXByZXZpZXdcXFwiIHJvbGU9XFxcInNsaWRlclxcXCIgOmFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIDphcmlhLXZhbHVlbWF4PVxcXCJ0b3RhbFxcXCJcXG4gICAgOmFyaWEtdmFsdWVub3c9XFxcInZhbHVlXFxcIlxcbj5cXG4gICAgPHVpLXJhdGluZy1pY29uXFxuICAgICAgICA6dHlwZT1cXFwidHlwZVxcXCIgdi1mb3I9XFxcIm4gaW4gdG90YWxcXFwiIDpzZWxlY3RlZD1cXFwiKG4gKyAxKSA8PSB2YWx1ZVxcXCJcXG4gICAgPjwvdWktcmF0aW5nLWljb24+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTYyKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTZWxlY3QudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzEpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlTZWxlY3QudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfbWVyZ2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQpO1xyXG5cdFxyXG5cdHZhciBfbWVyZ2VPcHRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlT3B0aW9ucyk7XHJcblx0XHJcblx0dmFyIF9mdXp6eXNlYXJjaCA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xyXG5cdFxyXG5cdHZhciBfZnV6enlzZWFyY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnV6enlzZWFyY2gpO1xyXG5cdFxyXG5cdHZhciBfZWxlbWVudFNjcm9sbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpU2VsZWN0T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlTZWxlY3RPcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTZWxlY3RPcHRpb24pO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0NpcmN1bGFyKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc1RleHRJbnB1dCk7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdGVzSW5wdXQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc2VsZWN0JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW09iamVjdCwgQXJyYXksIFN0cmluZywgTnVtYmVyXSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlZmF1bHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBBcnJheSwgU3RyaW5nLCBOdW1iZXJdLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogW11cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJ0aWFsOiBTdHJpbmcsXHJcblx0ICAgICAgICBzaG93U2VhcmNoOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlYXJjaFBsYWNlaG9sZGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdTZWFyY2gnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbXVsdGlwbGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbXVsdGlwbGVEZWxpbWl0ZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJywgJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wdGlvbnNEeW5hbWljOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wdGlvbnNMb2FkZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAndGV4dCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIGltYWdlOiAnaW1hZ2UnXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZpbHRlcjogRnVuY3Rpb25cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgcXVlcnk6ICcnLFxyXG5cdCAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IC0xLFxyXG5cdCAgICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXg6IC0xLFxyXG5cdCAgICAgICAgICAgIHNob3dEcm9wZG93bjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaWdub3JlUXVlcnlDaGFuZ2U6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgZmlsdGVyZWRPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJlZE9wdGlvbnMoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0R5bmFtaWMpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWx0ZXIodGhpcy5zZWFyY2gpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc3BsYXlUZXh0OiBmdW5jdGlvbiBkaXNwbGF5VGV4dCgpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMudmFsdWUubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLnZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtfdGhpcy5rZXlzLnRleHRdIHx8IHZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVscy5qb2luKHRoaXMubXVsdGlwbGVEZWxpbWl0ZXIpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWVbdGhpcy5rZXlzLnRleHRdIHx8IHRoaXMudmFsdWUgOiAnJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoYXNEaXNwbGF5VGV4dDogZnVuY3Rpb24gaGFzRGlzcGxheVRleHQoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVRleHQgJiYgQm9vbGVhbih0aGlzLmRpc3BsYXlUZXh0Lmxlbmd0aCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd0ljb246IGZ1bmN0aW9uIHNob3dJY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaWNvbik7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbm90aGluZ0ZvdW5kOiBmdW5jdGlvbiBub3RoaW5nRm91bmQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0R5bmFtaWMgJiYgIXRoaXMub3B0aW9uc0xvYWRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCAmJiAhdGhpcy5sb2FkaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhQm9vbGVhbih0aGlzLmZpbHRlcmVkT3B0aW9ucy5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICBmaWx0ZXJlZE9wdGlvbnM6IGZ1bmN0aW9uIGZpbHRlcmVkT3B0aW9ucygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSAwO1xyXG5cdCAgICAgICAgICAgICgwLCBfZWxlbWVudFNjcm9sbC5yZXNldFNjcm9sbCkodGhpcy4kZWxzLm9wdGlvbnNMaXN0KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93RHJvcGRvd246IGZ1bmN0aW9uIHNob3dEcm9wZG93bigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vcGVuZWQoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ29wZW5lZCcpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VkKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcXVlcnk6IGZ1bmN0aW9uIHF1ZXJ5KCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5pZ25vcmVRdWVyeUNoYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgncXVlcnktY2hhbmdlZCcsIHRoaXMucXVlcnkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdFZhbHVlKCk7XHJcblx0XHJcblx0ICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IHtcclxuXHQgICAgICAgICAgICBtaW46ICdZb3UgbXVzdCBzZWxlY3QgYXQgbGVhc3QgOm1pbiBvcHRpb25zLicsXHJcblx0ICAgICAgICAgICAgbWF4OiAnWW91IG11c3Qgc2VsZWN0IG5vIG1vcmUgdGhhbiA6bWF4IG9wdGlvbnMuJyxcclxuXHQgICAgICAgICAgICBiZXR3ZWVuOiAnWW91IG11c3Qgc2VsZWN0IGF0IGxlYXN0IDptaW4gYnV0IG5vIG1vcmUgdGhhbiA6bWF4IG9wdGlvbnMuJ1xyXG5cdCAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgIGlmICh0aGlzLnZhbGlkYXRpb25SdWxlcykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzID0gKDAsIF9tZXJnZU9wdGlvbnMyLmRlZmF1bHQpKGVycm9yTWVzc2FnZXMsIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayk7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLXNlbGVjdDo6c2V0LXNlbGVjdGVkJzogZnVuY3Rpb24gdWlTZWxlY3RTZXRTZWxlY3RlZCh2YWx1ZSwgaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuZGVmYXVsdCA9IHZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5pbml0VmFsdWUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5jbGVhclF1ZXJ5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gLTE7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGluaXRWYWx1ZTogZnVuY3Rpb24gaW5pdFZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm11bHRpcGxlID8gW10gOiBudWxsO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gQXJyYXkuaXNBcnJheSh0aGlzLmRlZmF1bHQpID8gdGhpcy5kZWZhdWx0IDogW3RoaXMuZGVmYXVsdF07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdFZhbHVlKGRlZmF1bHRzKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaChvcHRpb24pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG9wdGlvbiwgdGhpcy5xdWVyeSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkudG9Mb3dlckNhc2UoKTtcclxuXHQgICAgICAgICAgICB2YXIgdGV4dCA9IG9wdGlvblt0aGlzLmtleXMudGV4dF0gfHwgb3B0aW9uO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfZnV6enlzZWFyY2gyLmRlZmF1bHQpKHF1ZXJ5LCB0ZXh0KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbGVhclF1ZXJ5OiBmdW5jdGlvbiBjbGVhclF1ZXJ5KCkge1xyXG5cdCAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaWdub3JlUXVlcnlDaGFuZ2UgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgX3RoaXMyLnF1ZXJ5ID0gJyc7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzMi4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmlnbm9yZVF1ZXJ5Q2hhbmdlID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KG9wdGlvbiwgaW5kZXgpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2xvc2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzJdO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQob3B0aW9uKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdChvcHRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKG9wdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9uO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3NlbGVjdGVkJywgb3B0aW9uKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmNsZWFyUXVlcnkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmIGNsb3NlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KG9wdGlvbikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUuJHJlbW92ZShvcHRpb24pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaW5kZXhPZihvcHRpb24pID4gLTE7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvcHRpb247XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0SGlnaGxpZ2h0ZWQ6IGZ1bmN0aW9uIHNlbGVjdEhpZ2hsaWdodGVkKGluZGV4LCBlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMub3B0aW9ucy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLiRyZWZzLm9wdGlvbnNbaW5kZXhdLm9wdGlvbiwgaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChpbmRleCwgcHJldmVudFNjcm9sbCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkSW5kZXggPT09IGluZGV4IHx8IHRoaXMuJHJlZnMub3B0aW9ucy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IDA7XHJcblx0ICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuJHJlZnMub3B0aW9ucy5sZW5ndGggLSAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChpbmRleCA8IGZpcnN0SW5kZXgpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IGZpcnN0SW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IGluZGV4O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghcHJldmVudFNjcm9sbCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE9wdGlvbkludG9WaWV3KHRoaXMuJHJlZnMub3B0aW9uc1tpbmRleF0uJGVsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcGVuZWQ6IGZ1bmN0aW9uIG9wZW5lZCgpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChfdGhpczMuc2hvd1NlYXJjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMzLiRlbHMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMy4kZWxzLmRyb3Bkb3duLmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICAgICAgX3RoaXMzLnNjcm9sbE9wdGlvbkludG9WaWV3KF90aGlzMy4kZWxzLm9wdGlvbnNMaXN0LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3RlZCcpKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoZGVhY3RpdmF0ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmRpcnR5KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoZGVhY3RpdmF0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGVscy5sYWJlbC5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZU9uRXh0ZXJuYWxDbGljazogZnVuY3Rpb24gY2xvc2VPbkV4dGVybmFsQ2xpY2soZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy4kZWwuY29udGFpbnMoZS50YXJnZXQpICYmICh0aGlzLnNob3dEcm9wZG93biB8fCB0aGlzLmFjdGl2ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VkOiBmdW5jdGlvbiBjbG9zZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IC0xO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2V0RGVmYXVsdFZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUoZGVmYXVsdHMpIHtcclxuXHQgICAgICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25WYWx1ZSA9IHZvaWQgMDtcclxuXHRcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25WYWx1ZSA9IGRlZmF1bHRzW2ldW3RoaXMua2V5cy52YWx1ZV0gfHwgZGVmYXVsdHNbaV07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5vcHRpb25zLmxlbmd0aDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9IHRoaXMub3B0aW9uc1tqXVt0aGlzLmtleXMudmFsdWVdIHx8IHRoaXMub3B0aW9uc1tqXTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gZGVmYXVsdE9wdGlvblZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5vcHRpb25zW2pdLCBqLCBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2Nyb2xsT3B0aW9uSW50b1ZpZXc6IGZ1bmN0aW9uIHNjcm9sbE9wdGlvbkludG9WaWV3KG9wdGlvbkVsKSB7XHJcblx0ICAgICAgICAgICAgKDAsIF9lbGVtZW50U2Nyb2xsLnNjcm9sbEludG9WaWV3KShvcHRpb25FbCwgdGhpcy4kZWxzLm9wdGlvbnNMaXN0LCA4MCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdCxcclxuXHQgICAgICAgIFVpU2VsZWN0T3B0aW9uOiBfVWlTZWxlY3RPcHRpb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc1RleHRJbnB1dDIuZGVmYXVsdCwgX1ZhbGlkYXRlc0lucHV0Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHR2YXIgaXNPcHRpb25PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NSk7XHJcblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHR2YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxuXHR2YXIgZ2xvYmFsVGhpcyA9IHRoaXM7XHJcblx0dmFyIGRlZmF1bHRNZXJnZU9wdHMgPSB7XHJcblx0XHRjb25jYXRBcnJheXM6IGZhbHNlXHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKHZhbHVlKSB7XHJcblx0XHR2YXIga2V5cyA9IFtdO1xyXG5cdFxyXG5cdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XHJcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcclxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XHJcblx0XHRcdHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XHJcblx0XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbHNbaV0pKSB7XHJcblx0XHRcdFx0XHRrZXlzLnB1c2goc3ltYm9sc1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHJcblx0XHRyZXR1cm4ga2V5cztcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gY2xvbmVBcnJheSh2YWx1ZSk7XHJcblx0XHR9XHJcblx0XHJcblx0XHRpZiAoaXNPcHRpb25PYmplY3QodmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBjbG9uZU9wdGlvbk9iamVjdCh2YWx1ZSk7XHJcblx0XHR9XHJcblx0XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXkpIHtcclxuXHRcdHZhciByZXN1bHQgPSBhcnJheS5zbGljZSgwLCAwKTtcclxuXHRcclxuXHRcdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRyZXN1bHRba2V5XSA9IGNsb25lKGFycmF5W2tleV0pO1xyXG5cdFx0fSk7XHJcblx0XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBjbG9uZU9wdGlvbk9iamVjdChvYmopIHtcclxuXHRcdHZhciByZXN1bHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcclxuXHRcclxuXHRcdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdFx0cmVzdWx0W2tleV0gPSBjbG9uZShvYmpba2V5XSk7XHJcblx0XHR9KTtcclxuXHRcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBtZXJnZWQge2FscmVhZHkgY2xvbmVkfVxyXG5cdCAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gbWVyZ2VLZXlzKG1lcmdlZCwgc291cmNlLCBrZXlzLCBtZXJnZU9wdHMpIHtcclxuXHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHRcdGlmIChrZXkgaW4gbWVyZ2VkKSB7XHJcblx0XHRcdFx0bWVyZ2VkW2tleV0gPSBtZXJnZShtZXJnZWRba2V5XSwgc291cmNlW2tleV0sIG1lcmdlT3B0cyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bWVyZ2VkW2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogQHBhcmFtIG1lcmdlZCB7YWxyZWFkeSBjbG9uZWR9XHJcblx0ICogQHJldHVybiB7Y2xvbmVkIE9iamVjdH1cclxuXHQgKlxyXG5cdCAqIHNlZSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdClcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBjb25jYXRBcnJheXMobWVyZ2VkLCBzb3VyY2UsIG1lcmdlT3B0cykge1xyXG5cdFx0dmFyIHJlc3VsdCA9IG1lcmdlZC5zbGljZSgwLCAwKTtcclxuXHRcdHZhciByZXN1bHRJbmRleCA9IDA7XHJcblx0XHJcblx0XHRbbWVyZ2VkLCBzb3VyY2VdLmZvckVhY2goZnVuY3Rpb24gKGFycmF5KSB7XHJcblx0XHRcdHZhciBpbmRpY2VzID0gW107XHJcblx0XHJcblx0XHRcdC8vIHJlc3VsdC5jb25jYXQoYXJyYXkpIHdpdGggY2xvbmluZ1xyXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGFycmF5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBrKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdGluZGljZXMucHVzaChTdHJpbmcoaykpO1xyXG5cdFxyXG5cdFx0XHRcdGlmIChhcnJheSA9PT0gbWVyZ2VkKSB7XHJcblx0XHRcdFx0XHQvLyBhbHJlYWR5IGNsb25lZFxyXG5cdFx0XHRcdFx0cmVzdWx0W3Jlc3VsdEluZGV4KytdID0gYXJyYXlba107XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJlc3VsdFtyZXN1bHRJbmRleCsrXSA9IGNsb25lKGFycmF5W2tdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcclxuXHRcdFx0Ly8gbWVyZ2Ugbm9uLWluZGV4IGtleXNcclxuXHRcdFx0cmVzdWx0ID0gbWVyZ2VLZXlzKHJlc3VsdCwgYXJyYXksIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHRcdFx0cmV0dXJuIGluZGljZXMuaW5kZXhPZihrZXkpID09PSAtMTtcclxuXHRcdFx0fSksIG1lcmdlT3B0cyk7XHJcblx0XHR9KTtcclxuXHRcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBtZXJnZWQge2FscmVhZHkgY2xvbmVkfVxyXG5cdCAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gbWVyZ2UobWVyZ2VkLCBzb3VyY2UsIG1lcmdlT3B0cykge1xyXG5cdFx0aWYgKG1lcmdlT3B0cy5jb25jYXRBcnJheXMgJiYgQXJyYXkuaXNBcnJheShtZXJnZWQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xyXG5cdFx0XHRyZXR1cm4gY29uY2F0QXJyYXlzKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0aWYgKCFpc09wdGlvbk9iamVjdChzb3VyY2UpIHx8ICFpc09wdGlvbk9iamVjdChtZXJnZWQpKSB7XHJcblx0XHRcdHJldHVybiBjbG9uZShzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0cmV0dXJuIG1lcmdlS2V5cyhtZXJnZWQsIHNvdXJjZSwgZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhzb3VyY2UpLCBtZXJnZU9wdHMpO1xyXG5cdH1cclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtZXJnZU9wdHMgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRzKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdHMpO1xyXG5cdFx0dmFyIG1lcmdlZCA9IHt9O1xyXG5cdFxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIG9wdGlvbiA9IGFyZ3VtZW50c1tpXTtcclxuXHRcclxuXHRcdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcclxuXHRcdFx0aWYgKCFpc09wdGlvbk9iamVjdChvcHRpb24pKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYCcgKyBvcHRpb24gKyAnYCBpcyBub3QgYW4gT3B0aW9uIE9iamVjdCcpO1xyXG5cdFx0XHR9XHJcblx0XHJcblx0XHRcdG1lcmdlZCA9IG1lcmdlKG1lcmdlZCwgb3B0aW9uLCBtZXJnZU9wdHMpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xyXG5cdFx0dmFyIHByb3RvdHlwZTtcclxuXHRcdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAocHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLCBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5pblZpZXcgPSBpblZpZXc7XHJcblx0ZXhwb3J0cy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xyXG5cdGV4cG9ydHMucmVzZXRTY3JvbGwgPSByZXNldFNjcm9sbDtcclxuXHRmdW5jdGlvbiBpblZpZXcoZWxlbWVudCwgY29udGFpbmVyKSB7XHJcblx0ICAgIGlmICghZWxlbWVudCkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblx0XHJcblx0ICAgIHZhciB0b3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuXHQgICAgdmFyIHBhcmVudFRvcCA9IGNvbnRhaW5lci5zY3JvbGxUb3A7XHJcblx0ICAgIHZhciBib3R0b20gPSB0b3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuXHQgICAgdmFyIHBhcmVudEJvdHRvbSA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblx0XHJcblx0ICAgIHJldHVybiB0b3AgPj0gcGFyZW50VG9wICYmIGJvdHRvbSA8PSBwYXJlbnRCb3R0b207XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIGNvbnRhaW5lcikge1xyXG5cdCAgICB2YXIgbWFyZ2luVG9wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcclxuXHRcclxuXHQgICAgaWYgKCFlbGVtZW50IHx8IGluVmlldyhlbGVtZW50LCBjb250YWluZXIpKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHRcclxuXHQgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIC0gbWFyZ2luVG9wO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiByZXNldFNjcm9sbChlbGVtZW50KSB7XHJcblx0ICAgIGlmICghZWxlbWVudCkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcclxuXHR9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBpblZpZXc6IGluVmlldyxcclxuXHQgICAgc2Nyb2xsSW50b1ZpZXc6IHNjcm9sbEludG9WaWV3LFxyXG5cdCAgICByZXNldFNjcm9sbDogcmVzZXRTY3JvbGxcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTY3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU2VsZWN0T3B0aW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcwKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU2VsZWN0T3B0aW9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXNlbGVjdC1vcHRpb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgb3B0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLXNlbGVjdC1zaW1wbGUnIH0sXHJcblx0ICAgICAgICBzaG93Q2hlY2tib3g6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlnaGxpZ2h0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAga2V5czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd0ZXh0JyxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndmFsdWUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW1hZ2U6ICdpbWFnZSdcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBpY29uOiBmdW5jdGlvbiBpY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkID8gJ2NoZWNrX2JveCcgOiAnY2hlY2tfYm94X291dGxpbmVfYmxhbmsnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcGFydGlhbHM6IHtcclxuXHQgICAgICAgICd1aS1zZWxlY3Qtc2ltcGxlJzogJ1xcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cInVpLXNlbGVjdC1pdGVtLXRleHRcIiB2LXRleHQ9XCJvcHRpb25ba2V5cy50ZXh0XSB8fCBvcHRpb25cIj48L2xpPlxcbiAgICAgICAgJyxcclxuXHRcclxuXHQgICAgICAgICd1aS1zZWxlY3QtaW1hZ2UnOiAnXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cInVpLXNlbGVjdC1pdGVtLWltYWdlXCJcXG4gICAgICAgICAgICAgICAgOnN0eWxlPVwieyBcXCdiYWNrZ3JvdW5kLWltYWdlXFwnOiBcXCd1cmwoXFwnICsgb3B0aW9uW2tleXMuaW1hZ2VdICsgXFwnKVxcJyB9XCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLXNlbGVjdC1pdGVtLXRleHRcIiB2LXRleHQ9XCJvcHRpb25ba2V5cy50ZXh0XVwiPjwvZGl2PlxcbiAgICAgICAgJ1xyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsaVxcbiAgICBjbGFzcz1cXFwidWktc2VsZWN0LW9wdGlvblxcXCIgOmNsYXNzPVxcXCJ7IGhpZ2hsaWdodGVkOiBoaWdobGlnaHRlZCwgc2VsZWN0ZWQ6IHNlbGVjdGVkIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3Qtb3B0aW9uLWNvbnRlbnRcXFwiIDpjbGFzcz1cXFwiW3BhcnRpYWxdXFxcIj5cXG4gICAgICAgIDxwYXJ0aWFsIDpuYW1lPVxcXCJwYXJ0aWFsXFxcIj48L3BhcnRpYWw+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8dWktaWNvblxcbiAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1vcHRpb24tY2hlY2tib3hcXFwiIDppY29uPVxcXCJpY29uXFxcIiB2LWlmPVxcXCJzaG93Q2hlY2tib3hcXFwiXFxuICAgID48L3VpLWljb24+XFxuPC9saT5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXNlbGVjdFxcXCIgOmlkPVxcXCJpZFxcXCIgOmNsYXNzPVxcXCJ7XFxuICAgICAgICAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2ludmFsaWQnOiAhdmFsaWQsICdkaXJ0eSc6IGRpcnR5LCAnYWN0aXZlJzogYWN0aXZlLFxcbiAgICAgICAgJ2hhcy1sYWJlbCc6ICFoaWRlTGFiZWwsICdpY29uLXJpZ2h0JzogaWNvblJpZ2h0XFxuICAgIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtaWNvbi13cmFwcGVyXFxcIiB2LWlmPVxcXCJzaG93SWNvblxcXCI+XFxuICAgICAgICA8dWktaWNvbiA6aWNvbj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1pY29uXFxcIj48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1sYWJlbFxcXCIgOnRhYmluZGV4PVxcXCJkaXNhYmxlZCA/IG51bGwgOiAnMCdcXFwiIHYtZWw6bGFiZWxcXG4gICAgICAgICAgICBAZm9jdXM9XFxcImZvY3VzXFxcIiBAa2V5ZG93bi50YWI9XFxcImJsdXJcXFwiIEBjbGljaz1cXFwidG9nZ2xlXFxcIiBAa2V5ZG93bi5zcGFjZS5wcmV2ZW50PVxcXCJvcGVuXFxcIlxcbiAgICAgICAgICAgIEBrZXlkb3duLmVudGVyLnByZXZlbnQ9XFxcIm9wZW5cXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWxhYmVsLXRleHRcXFwiIHYtdGV4dD1cXFwibGFiZWxcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1kaXNwbGF5XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC12YWx1ZVxcXCIgOmNsYXNzPVxcXCJ7IHBsYWNlaG9sZGVyOiAhaGFzRGlzcGxheVRleHQgfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiaGFzRGlzcGxheVRleHQgPyBkaXNwbGF5VGV4dCA6IHBsYWNlaG9sZGVyXFxcIlxcbiAgICAgICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDx1aS1pY29uIGljb249XFxcImFycm93X2Ryb3BfZG93blxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1kcm9wZG93bi1pY29uXFxcIj48L3VpLWljb24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktc2VsZWN0LWRyb3Bkb3duXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHYtc2hvdz1cXFwic2hvd0Ryb3Bkb3duXFxcIiB2LWVsOmRyb3Bkb3duXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVzYy5wcmV2ZW50PVxcXCJjbG9zZSgpXFxcIiBAa2V5ZG93bi50YWI9XFxcImNsb3NlKClcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLnVwLnByZXZlbnQ9XFxcImhpZ2hsaWdodChoaWdobGlnaHRlZEluZGV4IC0gMSlcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmRvd24ucHJldmVudD1cXFwiaGlnaGxpZ2h0KGhpZ2hsaWdodGVkSW5kZXggKyAxKVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24uZW50ZXIucHJldmVudC5zdG9wPVxcXCJzZWxlY3RIaWdobGlnaHRlZChoaWdobGlnaHRlZEluZGV4LCAkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LXNlYXJjaFxcXCIgdi1pZj1cXFwic2hvd1NlYXJjaFxcXCIgQGNsaWNrLnN0b3AgQGtleWRvd24uc3BhY2Uuc3RvcD5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoLWlucHV0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LWVsOnNlYXJjaC1pbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cXFwic2VhcmNoUGxhY2Vob2xkZXJcXFwiIHYtbW9kZWw9XFxcInF1ZXJ5XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCJcXG4gICAgICAgICAgICAgICAgICAgID5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDx1aS1wcm9ncmVzcy1jaXJjdWxhclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoLXNwaW5uZXJcXFwiIDpzaXplPVxcXCIyNFxcXCIgOnN0cm9rZT1cXFwiNFxcXCIgOnNob3c9XFxcImxvYWRpbmdcXFwiXFxuICAgICAgICAgICAgICAgICAgICA+PC91aS1wcm9ncmVzcy1jaXJjdWxhcj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktc2VsZWN0LW9wdGlvbnNcXFwiIHYtZWw6b3B0aW9ucy1saXN0PlxcbiAgICAgICAgICAgICAgICAgICAgPHVpLXNlbGVjdC1vcHRpb25cXG4gICAgICAgICAgICAgICAgICAgICAgICA6b3B0aW9uPVxcXCJvcHRpb25cXFwiIDpwYXJ0aWFsPVxcXCJwYXJ0aWFsXFxcIiA6c2hvdy1jaGVja2JveD1cXFwibXVsdGlwbGVcXFwiIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICA6a2V5cz1cXFwia2V5c1xcXCIgQGNsaWNrLnN0b3AucHJldmVudD1cXFwic2VsZWN0KG9wdGlvbiwgaW5kZXgpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIEBtb3VzZW92ZXIuc3RvcD1cXFwiaGlnaGxpZ2h0KGluZGV4LCB0cnVlKVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA6aGlnaGxpZ2h0ZWQ9XFxcImhpZ2hsaWdodGVkSW5kZXggPT09IGluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDpzZWxlY3RlZD1cXFwiaXNTZWxlY3RlZChvcHRpb24pXFxcIlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIG9wdGlvbikgaW4gZmlsdGVyZWRPcHRpb25zXFxcIiB2LXJlZjpvcHRpb25zXFxuICAgICAgICAgICAgICAgICAgICA+PC91aS1zZWxlY3Qtb3B0aW9uPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtbm8tcmVzdWx0c1xcXCIgdi1pZj1cXFwibm90aGluZ0ZvdW5kXFxcIj5ObyByZXN1bHRzIGZvdW5kPC9saT5cXG4gICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2tcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1lcnJvci10ZXh0XFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1zZWxlY3QtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICAgICAgICAgICAgICB2LXRleHQ9XFxcInZhbGlkYXRpb25FcnJvclxcXCIgdi1zaG93PVxcXCIhaGlkZVZhbGlkYXRpb25FcnJvcnMgJiYgIXZhbGlkXFxcIlxcbiAgICAgICAgICAgID48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3QtaGVscC10ZXh0XFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1zZWxlY3QtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICAgICAgICAgICAgICB2LXRleHQ9XFxcImhlbHBUZXh0XFxcIiB2LWVsc2VcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTczKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzQpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTbGlkZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODMpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlTbGlkZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZHJhZ2dhYmlsbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NSk7XHJcblx0XHJcblx0dmFyIF9kcmFnZ2FiaWxseTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kcmFnZ2FiaWxseSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc2xpZGVyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG5hbWU6IFN0cmluZyxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHN0ZXA6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogNVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBoaWRlTGFiZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiAwLFxyXG5cdCAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBkcmFnZ2FibGU6IG51bGxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93SWNvbjogZnVuY3Rpb24gc2hvd0ljb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pY29uKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoYXNMYWJlbDogZnVuY3Rpb24gaGFzTGFiZWwoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaGlkZUxhYmVsKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmxhYmVsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZWxzLnRodW1iLnN0eWxlLmxlZnQgPSB0aGlzLnZhbHVlICsgJyUnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuZGlzYWJsZSgpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHRcclxuXHQgICAgICAgIHRoaXMuJGVscy50aHVtYi5zdHlsZS5sZWZ0ID0gdGhpcy52YWx1ZSArICclJztcclxuXHRcclxuXHQgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gbmV3IF9kcmFnZ2FiaWxseTIuZGVmYXVsdCh0aGlzLiRlbHMudGh1bWIsIHtcclxuXHQgICAgICAgICAgICBjb250YWlubWVudDogdGhpcy4kZWxzLmNvbnRhaW5tZW50LFxyXG5cdCAgICAgICAgICAgIGF4aXM6ICd4J1xyXG5cdCAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ1N0YXJ0JywgdGhpcy5kcmFnU3RhcnQpO1xyXG5cdCAgICAgICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdNb3ZlJywgdGhpcy5kcmFnTW92ZSk7XHJcblx0ICAgICAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ0VuZCcsIHRoaXMuZHJhZ0VuZCk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmRpc2FibGUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmRlc3Ryb3koKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2xpZGVyQ2xpY2s6IGZ1bmN0aW9uIHNsaWRlckNsaWNrKGUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBzbGlkZXJQb3NpdGlvbiA9IHRoaXMuJGVscy5zbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gKGUuY2xpZW50WCAtIHNsaWRlclBvc2l0aW9uLmxlZnQpIC8gc2xpZGVyUG9zaXRpb24ud2lkdGggKiAxMDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLiRlbHMudGh1bWIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuX3BvaW50ZXJEb3duKGUsIGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHJhZ01vdmU6IGZ1bmN0aW9uIGRyYWdNb3ZlKCkge1xyXG5cdCAgICAgICAgICAgIHZhciB4ID0gdGhpcy5kcmFnZ2FibGUucG9zaXRpb24ueDtcclxuXHQgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB4IC8gdGhpcy4kZWxzLnNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAqIDEwMDtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlKG5ld1ZhbHVlKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkcmFnRW5kOiBmdW5jdGlvbiBkcmFnRW5kKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmNyZW1lbnQ6IGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gMTAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlICsgdGhpcy5zdGVwKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZWNyZW1lbnQ6IGZ1bmN0aW9uIGRlY3JlbWVudCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZSAtIHRoaXMuc3RlcCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIG1vZGVyYXRlZFZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG1vZGVyYXRlZFZhbHVlID49IDEwMCkge1xyXG5cdCAgICAgICAgICAgICAgICBtb2RlcmF0ZWRWYWx1ZSA9IDEwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG1vZGVyYXRlZFZhbHVlIDw9IDApIHtcclxuXHQgICAgICAgICAgICAgICAgbW9kZXJhdGVkVmFsdWUgPSAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gbW9kZXJhdGVkVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIERyYWdnYWJpbGx5IHYxLjIuNFxyXG5cdCAqIE1ha2UgdGhhdCBzaGl6IGRyYWdnYWJsZVxyXG5cdCAqIGh0dHA6Ly9kcmFnZ2FiaWxseS5kZXNhbmRyby5jb21cclxuXHQgKiBNSVQgbGljZW5zZVxyXG5cdCAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcclxuXHQgICd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblx0ICAgIC8vIEFNRFxyXG5cdCAgICBkZWZpbmUoIFtcclxuXHQgICAgICAgICdjbGFzc2llL2NsYXNzaWUnLFxyXG5cdCAgICAgICAgJ2dldC1zdHlsZS1wcm9wZXJ0eS9nZXQtc3R5bGUtcHJvcGVydHknLFxyXG5cdCAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcclxuXHQgICAgICAgICd1bmlkcmFnZ2VyL3VuaWRyYWdnZXInXHJcblx0ICAgICAgXSxcclxuXHQgICAgICBmdW5jdGlvbiggY2xhc3NpZSwgZ2V0U3R5bGVQcm9wZXJ0eSwgZ2V0U2l6ZSwgVW5pZHJhZ2dlciApIHtcclxuXHQgICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGNsYXNzaWUsIGdldFN0eWxlUHJvcGVydHksIGdldFNpemUsIFVuaWRyYWdnZXIgKTtcclxuXHQgICAgICB9KTtcclxuXHQgIH0gZWxzZSBpZiAoIHRydWUgKSB7XHJcblx0ICAgIC8vIENvbW1vbkpTXHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxNzYpLFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTc3KSxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OCksXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxNzkpXHJcblx0ICAgICk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgICB3aW5kb3cuRHJhZ2dhYmlsbHkgPSBmYWN0b3J5KFxyXG5cdCAgICAgIHdpbmRvdyxcclxuXHQgICAgICB3aW5kb3cuY2xhc3NpZSxcclxuXHQgICAgICB3aW5kb3cuZ2V0U3R5bGVQcm9wZXJ0eSxcclxuXHQgICAgICB3aW5kb3cuZ2V0U2l6ZSxcclxuXHQgICAgICB3aW5kb3cuVW5pZHJhZ2dlclxyXG5cdCAgICApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBjbGFzc2llLCBnZXRTdHlsZVByb3BlcnR5LCBnZXRTaXplLCBVbmlkcmFnZ2VyICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQvLyB2YXJzXHJcblx0dmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHQvLyBleHRlbmQgb2JqZWN0c1xyXG5cdGZ1bmN0aW9uIGV4dGVuZCggYSwgYiApIHtcclxuXHQgIGZvciAoIHZhciBwcm9wIGluIGIgKSB7XHJcblx0ICAgIGFbIHByb3AgXSA9IGJbIHByb3AgXTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBhO1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLSBnZXQgc3R5bGUgLS0tLS0gLy9cclxuXHRcclxuXHR2YXIgZGVmVmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cdFxyXG5cdHZhciBnZXRTdHlsZSA9IGRlZlZpZXcgJiYgZGVmVmlldy5nZXRDb21wdXRlZFN0eWxlID9cclxuXHQgIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgICByZXR1cm4gZGVmVmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XHJcblx0ICB9IDpcclxuXHQgIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgICByZXR1cm4gZWxlbS5jdXJyZW50U3R5bGU7XHJcblx0ICB9O1xyXG5cdFxyXG5cdFxyXG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4NDM4MC8xODIxODNcclxuXHR2YXIgaXNFbGVtZW50ID0gKCB0eXBlb2YgSFRNTEVsZW1lbnQgPT0gJ29iamVjdCcgKSA/XHJcblx0ICBmdW5jdGlvbiBpc0VsZW1lbnRET00yKCBvYmogKSB7XHJcblx0ICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcclxuXHQgIH0gOlxyXG5cdCAgZnVuY3Rpb24gaXNFbGVtZW50UXVpcmt5KCBvYmogKSB7XHJcblx0ICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyAmJlxyXG5cdCAgICAgIG9iai5ub2RlVHlwZSA9PSAxICYmIHR5cGVvZiBvYmoubm9kZU5hbWUgPT0gJ3N0cmluZyc7XHJcblx0ICB9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHJlcXVlc3RBbmltYXRpb25GcmFtZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE4NjY0NzRcclxuXHRcclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cdHZhciBwcmVmaXhlcyA9ICd3ZWJraXQgbW96IG1zIG8nLnNwbGl0KCcgJyk7XHJcblx0Ly8gZ2V0IHVucHJlZml4ZWQgckFGIGFuZCBjQUYsIGlmIHByZXNlbnRcclxuXHR2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXHR2YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcblx0Ly8gbG9vcCB0aHJvdWdoIHZlbmRvciBwcmVmaXhlcyBhbmQgZ2V0IHByZWZpeGVkIHJBRiBhbmQgY0FGXHJcblx0dmFyIHByZWZpeDtcclxuXHRmb3IoIHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrICkge1xyXG5cdCAgaWYgKCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSB7XHJcblx0ICAgIGJyZWFrO1xyXG5cdCAgfVxyXG5cdCAgcHJlZml4ID0gcHJlZml4ZXNbaV07XHJcblx0ICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93WyBwcmVmaXggKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cdCAgY2FuY2VsQW5pbWF0aW9uRnJhbWUgID0gY2FuY2VsQW5pbWF0aW9uRnJhbWUgIHx8IHdpbmRvd1sgcHJlZml4ICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJyBdIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1sgcHJlZml4ICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcclxuXHR9XHJcblx0XHJcblx0Ly8gZmFsbGJhY2sgdG8gc2V0VGltZW91dCBhbmQgY2xlYXJUaW1lb3V0IGlmIGVpdGhlciByZXF1ZXN0L2NhbmNlbCBpcyBub3Qgc3VwcG9ydGVkXHJcblx0aWYgKCAhcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICFjYW5jZWxBbmltYXRpb25GcmFtZSApICB7XHJcblx0ICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XHJcblx0ICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdCAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XHJcblx0ICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICBjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XHJcblx0ICAgIH0sIHRpbWVUb0NhbGwgKTtcclxuXHQgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcblx0ICAgIHJldHVybiBpZDtcclxuXHQgIH07XHJcblx0XHJcblx0ICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBpZCApIHtcclxuXHQgICAgd2luZG93LmNsZWFyVGltZW91dCggaWQgKTtcclxuXHQgIH07XHJcblx0fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHN1cHBvcnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHR2YXIgdHJhbnNmb3JtUHJvcGVydHkgPSBnZXRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nKTtcclxuXHQvLyBUT0RPIGZpeCBxdWljayAmIGRpcnR5IGNoZWNrIGZvciAzRCBzdXBwb3J0XHJcblx0dmFyIGlzM2QgPSAhIWdldFN0eWxlUHJvcGVydHkoJ3BlcnNwZWN0aXZlJyk7XHJcblx0XHJcblx0dmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0ZnVuY3Rpb24gRHJhZ2dhYmlsbHkoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XHJcblx0ICAvLyBxdWVyeVNlbGVjdG9yIGlmIHN0cmluZ1xyXG5cdCAgdGhpcy5lbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xyXG5cdCAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtZW50ICkgOiBlbGVtZW50O1xyXG5cdFxyXG5cdCAgaWYgKCBqUXVlcnkgKSB7XHJcblx0ICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gb3B0aW9uc1xyXG5cdCAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKCB7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cyApO1xyXG5cdCAgdGhpcy5vcHRpb24oIG9wdGlvbnMgKTtcclxuXHRcclxuXHQgIHRoaXMuX2NyZWF0ZSgpO1xyXG5cdH1cclxuXHRcclxuXHQvLyBpbmhlcml0IFVuaWRyYWdnZXIgbWV0aG9kc1xyXG5cdGV4dGVuZCggRHJhZ2dhYmlsbHkucHJvdG90eXBlLCBVbmlkcmFnZ2VyLnByb3RvdHlwZSApO1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LmRlZmF1bHRzID0ge1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogc2V0IG9wdGlvbnNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiggb3B0cyApIHtcclxuXHQgIGV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRzICk7XHJcblx0fTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdCAgLy8gcHJvcGVydGllc1xyXG5cdCAgdGhpcy5wb3NpdGlvbiA9IHt9O1xyXG5cdCAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcclxuXHRcclxuXHQgIHRoaXMuc3RhcnRQb2ludCA9IHsgeDogMCwgeTogMCB9O1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHRcclxuXHQgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IGV4dGVuZCgge30sIHRoaXMucG9zaXRpb24gKTtcclxuXHRcclxuXHQgIC8vIHNldCByZWxhdGl2ZSBwb3NpdGlvbmluZ1xyXG5cdCAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIHRoaXMuZWxlbWVudCApO1xyXG5cdCAgaWYgKCBzdHlsZS5wb3NpdGlvbiAhPSAncmVsYXRpdmUnICYmIHN0eWxlLnBvc2l0aW9uICE9ICdhYnNvbHV0ZScgKSB7XHJcblx0ICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0ICB9XHJcblx0XHJcblx0ICB0aGlzLmVuYWJsZSgpO1xyXG5cdCAgdGhpcy5zZXRIYW5kbGVzKCk7XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBzZXQgdGhpcy5oYW5kbGVzIGFuZCBiaW5kIHN0YXJ0IGV2ZW50cyB0byAnZW1cclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuc2V0SGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5oYW5kbGVzID0gdGhpcy5vcHRpb25zLmhhbmRsZSA/XHJcblx0ICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCB0aGlzLm9wdGlvbnMuaGFuZGxlICkgOiBbIHRoaXMuZWxlbWVudCBdO1xyXG5cdFxyXG5cdCAgdGhpcy5iaW5kSGFuZGxlcygpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogZW1pdHMgZXZlbnRzIHZpYSBldmVudEVtaXR0ZXIgYW5kIGpRdWVyeSBldmVudHNcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIG5hbWUgb2YgZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIG9yaWdpbmFsIGV2ZW50XHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJncyAtIGV4dHJhIGFyZ3VtZW50c1xyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xyXG5cdCAgdmFyIGVtaXRBcmdzID0gWyBldmVudCBdLmNvbmNhdCggYXJncyApO1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XHJcblx0ICB2YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcclxuXHQgIC8vIHRyaWdnZXIgalF1ZXJ5IGV2ZW50XHJcblx0ICBpZiAoIGpRdWVyeSAmJiB0aGlzLiRlbGVtZW50ICkge1xyXG5cdCAgICBpZiAoIGV2ZW50ICkge1xyXG5cdCAgICAgIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcclxuXHQgICAgICB2YXIgJGV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xyXG5cdCAgICAgICRldmVudC50eXBlID0gdHlwZTtcclxuXHQgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwgYXJncyApO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIC8vIGp1c3QgdHJpZ2dlciB3aXRoIHR5cGUgaWYgbm8gZXZlbnQgYXZhaWxhYmxlXHJcblx0ICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCB0eXBlLCBhcmdzICk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHBvc2l0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZ2V0IGxlZnQvdG9wIHBvc2l0aW9uIGZyb20gc3R5bGVcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0ICAvLyBwcm9wZXJ0aWVzXHJcblx0ICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggdGhpcy5lbGVtZW50ICk7XHJcblx0XHJcblx0ICB2YXIgeCA9IHBhcnNlSW50KCBzdHlsZS5sZWZ0LCAxMCApO1xyXG5cdCAgdmFyIHkgPSBwYXJzZUludCggc3R5bGUudG9wLCAxMCApO1xyXG5cdFxyXG5cdCAgLy8gY2xlYW4gdXAgJ2F1dG8nIG9yIG90aGVyIG5vbi1pbnRlZ2VyIHZhbHVlc1xyXG5cdCAgdGhpcy5wb3NpdGlvbi54ID0gaXNOYU4oIHggKSA/IDAgOiB4O1xyXG5cdCAgdGhpcy5wb3NpdGlvbi55ID0gaXNOYU4oIHkgKSA/IDAgOiB5O1xyXG5cdFxyXG5cdCAgdGhpcy5fYWRkVHJhbnNmb3JtUG9zaXRpb24oIHN0eWxlICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBhZGQgdHJhbnNmb3JtOiB0cmFuc2xhdGUoIHgsIHkgKSB0byBwb3NpdGlvblxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5fYWRkVHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiggc3R5bGUgKSB7XHJcblx0ICBpZiAoICF0cmFuc2Zvcm1Qcm9wZXJ0eSApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlWyB0cmFuc2Zvcm1Qcm9wZXJ0eSBdO1xyXG5cdCAgLy8gYmFpbCBvdXQgaWYgdmFsdWUgaXMgJ25vbmUnXHJcblx0ICBpZiAoIHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgnKSAhPT0gMCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgLy8gc3BsaXQgbWF0cml4KDEsIDAsIDAsIDEsIHgsIHkpXHJcblx0ICB2YXIgbWF0cml4VmFsdWVzID0gdHJhbnNmb3JtLnNwbGl0KCcsJyk7XHJcblx0ICAvLyB0cmFuc2xhdGUgWCB2YWx1ZSBpcyBpbiAxMnRoIG9yIDR0aCBwb3NpdGlvblxyXG5cdCAgdmFyIHhJbmRleCA9IHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgzZCcpID09PSAwID8gMTIgOiA0O1xyXG5cdCAgdmFyIHRyYW5zbGF0ZVggPSBwYXJzZUludCggbWF0cml4VmFsdWVzWyB4SW5kZXggXSwgMTAgKTtcclxuXHQgIC8vIHRyYW5zbGF0ZSBZIHZhbHVlIGlzIGluIDEzdGggb3IgNXRoIHBvc2l0aW9uXHJcblx0ICB2YXIgdHJhbnNsYXRlWSA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCArIDEgXSwgMTAgKTtcclxuXHQgIHRoaXMucG9zaXRpb24ueCArPSB0cmFuc2xhdGVYO1xyXG5cdCAgdGhpcy5wb3NpdGlvbi55ICs9IHRyYW5zbGF0ZVk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBldmVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHQvKipcclxuXHQgKiBwb2ludGVyIHN0YXJ0XHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgLy8ga2x1ZGdlIHRvIGJsdXIgZm9jdXNlZCBpbnB1dHMgaW4gZHJhZ2dlclxyXG5cdCAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdCAgaWYgKCBmb2N1c2VkICYmIGZvY3VzZWQuYmx1ciApIHtcclxuXHQgICAgZm9jdXNlZC5ibHVyKCk7XHJcblx0ICB9XHJcblx0ICAvLyBiaW5kIG1vdmUgYW5kIGVuZCBldmVudHNcclxuXHQgIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XHJcblx0ICBjbGFzc2llLmFkZCggdGhpcy5lbGVtZW50LCAnaXMtcG9pbnRlci1kb3duJyApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAncG9pbnRlckRvd24nLCBldmVudCwgWyBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgbW92ZVxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHZhciBtb3ZlVmVjdG9yID0gdGhpcy5fZHJhZ1BvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAncG9pbnRlck1vdmUnLCBldmVudCwgWyBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHQgIHRoaXMuX2RyYWdNb3ZlKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogZHJhZyBzdGFydFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcclxuXHQgIHRoaXMubWVhc3VyZUNvbnRhaW5tZW50KCk7XHJcblx0ICAvLyBwb3NpdGlvbiBfd2hlbl8gZHJhZyBiZWdhblxyXG5cdCAgdGhpcy5zdGFydFBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLng7XHJcblx0ICB0aGlzLnN0YXJ0UG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ueTtcclxuXHQgIC8vIHJlc2V0IGxlZnQvdG9wIHN0eWxlXHJcblx0ICB0aGlzLnNldExlZnRUb3AoKTtcclxuXHRcclxuXHQgIHRoaXMuZHJhZ1BvaW50LnggPSAwO1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQueSA9IDA7XHJcblx0XHJcblx0ICAvLyByZXNldCBpc0RyYWdnaW5nIGZsYWdcclxuXHQgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcblx0ICBjbGFzc2llLmFkZCggdGhpcy5lbGVtZW50LCAnaXMtZHJhZ2dpbmcnICk7XHJcblx0ICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnU3RhcnQnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcclxuXHQgIC8vIHN0YXJ0IGFuaW1hdGlvblxyXG5cdCAgdGhpcy5hbmltYXRlKCk7XHJcblx0fTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUubWVhc3VyZUNvbnRhaW5tZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0ICB2YXIgY29udGFpbm1lbnQgPSB0aGlzLm9wdGlvbnMuY29udGFpbm1lbnQ7XHJcblx0ICBpZiAoICFjb250YWlubWVudCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5zaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XHJcblx0ICB2YXIgZWxlbVJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHJcblx0ICAvLyB1c2UgZWxlbWVudCBpZiBlbGVtZW50XHJcblx0ICB2YXIgY29udGFpbmVyID0gaXNFbGVtZW50KCBjb250YWlubWVudCApID8gY29udGFpbm1lbnQgOlxyXG5cdCAgICAvLyBmYWxsYmFjayB0byBxdWVyeVNlbGVjdG9yIGlmIHN0cmluZ1xyXG5cdCAgICB0eXBlb2YgY29udGFpbm1lbnQgPT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBjb250YWlubWVudCApIDpcclxuXHQgICAgLy8gb3RoZXJ3aXNlIGp1c3QgYHRydWVgLCB1c2UgdGhlIHBhcmVudFxyXG5cdCAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHRcclxuXHQgIHRoaXMuY29udGFpbmVyU2l6ZSA9IGdldFNpemUoIGNvbnRhaW5lciApO1xyXG5cdCAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHJcblx0ICB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvbiA9IHtcclxuXHQgICAgeDogZWxlbVJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCxcclxuXHQgICAgeTogZWxlbVJlY3QudG9wICAtIGNvbnRhaW5lclJlY3QudG9wXHJcblx0ICB9O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbW92ZSBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgbW92ZVxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcclxuXHQgIGlmICggIXRoaXMuaXNFbmFibGVkICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0ICB2YXIgZHJhZ1ggPSBtb3ZlVmVjdG9yLng7XHJcblx0ICB2YXIgZHJhZ1kgPSBtb3ZlVmVjdG9yLnk7XHJcblx0XHJcblx0ICB2YXIgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xyXG5cdCAgdmFyIGdyaWRYID0gZ3JpZCAmJiBncmlkWzBdO1xyXG5cdCAgdmFyIGdyaWRZID0gZ3JpZCAmJiBncmlkWzFdO1xyXG5cdFxyXG5cdCAgZHJhZ1ggPSBhcHBseUdyaWQoIGRyYWdYLCBncmlkWCApO1xyXG5cdCAgZHJhZ1kgPSBhcHBseUdyaWQoIGRyYWdZLCBncmlkWSApO1xyXG5cdFxyXG5cdCAgZHJhZ1ggPSB0aGlzLmNvbnRhaW5EcmFnKCAneCcsIGRyYWdYLCBncmlkWCApO1xyXG5cdCAgZHJhZ1kgPSB0aGlzLmNvbnRhaW5EcmFnKCAneScsIGRyYWdZLCBncmlkWSApO1xyXG5cdFxyXG5cdCAgLy8gY29uc3RyYWluIHRvIGF4aXNcclxuXHQgIGRyYWdYID0gdGhpcy5vcHRpb25zLmF4aXMgPT0gJ3knID8gMCA6IGRyYWdYO1xyXG5cdCAgZHJhZ1kgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PSAneCcgPyAwIDogZHJhZ1k7XHJcblx0XHJcblx0ICB0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnN0YXJ0UG9zaXRpb24ueCArIGRyYWdYO1xyXG5cdCAgdGhpcy5wb3NpdGlvbi55ID0gdGhpcy5zdGFydFBvc2l0aW9uLnkgKyBkcmFnWTtcclxuXHQgIC8vIHNldCBkcmFnUG9pbnQgcHJvcGVydGllc1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQueCA9IGRyYWdYO1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQueSA9IGRyYWdZO1xyXG5cdFxyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ01vdmUnLCBldmVudCwgWyBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGFwcGx5R3JpZCggdmFsdWUsIGdyaWQsIG1ldGhvZCApIHtcclxuXHQgIG1ldGhvZCA9IG1ldGhvZCB8fCAncm91bmQnO1xyXG5cdCAgcmV0dXJuIGdyaWQgPyBNYXRoWyBtZXRob2QgXSggdmFsdWUgLyBncmlkICkgKiBncmlkIDogdmFsdWU7XHJcblx0fVxyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5jb250YWluRHJhZyA9IGZ1bmN0aW9uKCBheGlzLCBkcmFnLCBncmlkICkge1xyXG5cdCAgaWYgKCAhdGhpcy5vcHRpb25zLmNvbnRhaW5tZW50ICkge1xyXG5cdCAgICByZXR1cm4gZHJhZztcclxuXHQgIH1cclxuXHQgIHZhciBtZWFzdXJlID0gYXhpcyA9PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XHJcblx0XHJcblx0ICB2YXIgcmVsID0gdGhpcy5yZWxhdGl2ZVN0YXJ0UG9zaXRpb25bIGF4aXMgXTtcclxuXHQgIHZhciBtaW4gPSBhcHBseUdyaWQoIC1yZWwsIGdyaWQsICdjZWlsJyApO1xyXG5cdCAgdmFyIG1heCA9IHRoaXMuY29udGFpbmVyU2l6ZVsgbWVhc3VyZSBdIC0gcmVsIC0gdGhpcy5zaXplWyBtZWFzdXJlIF07XHJcblx0ICBtYXggPSBhcHBseUdyaWQoIG1heCwgZ3JpZCwgJ2Zsb29yJyApO1xyXG5cdCAgcmV0dXJuICBNYXRoLm1pbiggbWF4LCBNYXRoLm1heCggbWluLCBkcmFnICkgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgdXBcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUucG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgY2xhc3NpZS5yZW1vdmUoIHRoaXMuZWxlbWVudCwgJ2lzLXBvaW50ZXItZG93bicgKTtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3BvaW50ZXJVcCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgZW5kXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcblx0ICAvLyB1c2UgdG9wIGxlZnQgcG9zaXRpb24gd2hlbiBjb21wbGV0ZVxyXG5cdCAgaWYgKCB0cmFuc2Zvcm1Qcm9wZXJ0eSApIHtcclxuXHQgICAgdGhpcy5lbGVtZW50LnN0eWxlWyB0cmFuc2Zvcm1Qcm9wZXJ0eSBdID0gJyc7XHJcblx0ICAgIHRoaXMuc2V0TGVmdFRvcCgpO1xyXG5cdCAgfVxyXG5cdCAgY2xhc3NpZS5yZW1vdmUoIHRoaXMuZWxlbWVudCwgJ2lzLWRyYWdnaW5nJyApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ0VuZCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYW5pbWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbigpIHtcclxuXHQgIC8vIG9ubHkgcmVuZGVyIGFuZCBhbmltYXRlIGlmIGRyYWdnaW5nXHJcblx0ICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHRcclxuXHQgIHRoaXMucG9zaXRpb25EcmFnKCk7XHJcblx0XHJcblx0ICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdCAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbiBhbmltYXRlRnJhbWUoKSB7XHJcblx0ICAgIF90aGlzLmFuaW1hdGUoKTtcclxuXHQgIH0pO1xyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0Ly8gdHJhbnNmb3JtIHRyYW5zbGF0ZSBmdW5jdGlvblxyXG5cdHZhciB0cmFuc2xhdGUgPSBpczNkID9cclxuXHQgIGZ1bmN0aW9uKCB4LCB5ICkge1xyXG5cdCAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCAnICsgeCArICdweCwgJyArIHkgKyAncHgsIDApJztcclxuXHQgIH0gOlxyXG5cdCAgZnVuY3Rpb24oIHgsIHkgKSB7XHJcblx0ICAgIHJldHVybiAndHJhbnNsYXRlKCAnICsgeCArICdweCwgJyArIHkgKyAncHgpJztcclxuXHQgIH07XHJcblx0XHJcblx0Ly8gbGVmdC90b3AgcG9zaXRpb25pbmdcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuc2V0TGVmdFRvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLnggKyAncHgnO1xyXG5cdCAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCAgPSB0aGlzLnBvc2l0aW9uLnkgKyAncHgnO1xyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnBvc2l0aW9uRHJhZyA9IHRyYW5zZm9ybVByb3BlcnR5ID9cclxuXHQgIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAvLyBwb3NpdGlvbiB3aXRoIHRyYW5zZm9ybVxyXG5cdCAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIHRyYW5zZm9ybVByb3BlcnR5IF0gPSB0cmFuc2xhdGUoIHRoaXMuZHJhZ1BvaW50LngsIHRoaXMuZHJhZ1BvaW50LnkgKTtcclxuXHQgIH0gOiBEcmFnZ2FiaWxseS5wcm90b3R5cGUuc2V0TGVmdFRvcDtcclxuXHRcclxuXHQvLyAtLS0tLSBzdGF0aWNDbGljayAtLS0tLSAvL1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5zdGF0aWNDbGljayA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3N0YXRpY0NsaWNrJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBtZXRob2RzIC0tLS0tIC8vXHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XHJcblx0ICBpZiAoIHRoaXMuaXNEcmFnZ2luZyApIHtcclxuXHQgICAgdGhpcy5kcmFnRW5kKCk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5kaXNhYmxlKCk7XHJcblx0ICAvLyByZXNldCBzdHlsZXNcclxuXHQgIGlmICggdHJhbnNmb3JtUHJvcGVydHkgKSB7XHJcblx0ICAgIHRoaXMuZWxlbWVudC5zdHlsZVsgdHJhbnNmb3JtUHJvcGVydHkgXSA9ICcnO1xyXG5cdCAgfVxyXG5cdCAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAnJztcclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAnJztcclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICcnO1xyXG5cdCAgLy8gdW5iaW5kIGhhbmRsZXNcclxuXHQgIHRoaXMudW5iaW5kSGFuZGxlcygpO1xyXG5cdCAgLy8gcmVtb3ZlIGpRdWVyeSBkYXRhXHJcblx0ICBpZiAoIHRoaXMuJGVsZW1lbnQgKSB7XHJcblx0ICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZHJhZ2dhYmlsbHknKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIGpRdWVyeSBicmlkZ2V0IC0tLS0tIC8vXHJcblx0XHJcblx0Ly8gcmVxdWlyZWQgZm9yIGpRdWVyeSBicmlkZ2V0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLl9pbml0ID0gbm9vcDtcclxuXHRcclxuXHRpZiAoIGpRdWVyeSAmJiBqUXVlcnkuYnJpZGdldCApIHtcclxuXHQgIGpRdWVyeS5icmlkZ2V0KCAnZHJhZ2dhYmlsbHknLCBEcmFnZ2FiaWxseSApO1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLSAgLS0tLS0gLy9cclxuXHRcclxuXHRyZXR1cm4gRHJhZ2dhYmlsbHk7XHJcblx0XHJcblx0fSkpO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogY2xhc3NpZSB2MS4wLjFcclxuXHQgKiBjbGFzcyBoZWxwZXIgZnVuY3Rpb25zXHJcblx0ICogZnJvbSBib256byBodHRwczovL2dpdGh1Yi5jb20vZGVkL2JvbnpvXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKiBcclxuXHQgKiBjbGFzc2llLmhhcyggZWxlbSwgJ215LWNsYXNzJyApIC0+IHRydWUvZmFsc2VcclxuXHQgKiBjbGFzc2llLmFkZCggZWxlbSwgJ215LW5ldy1jbGFzcycgKVxyXG5cdCAqIGNsYXNzaWUucmVtb3ZlKCBlbGVtLCAnbXktdW53YW50ZWQtY2xhc3MnIClcclxuXHQgKiBjbGFzc2llLnRvZ2dsZSggZWxlbSwgJ215LWNsYXNzJyApXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdyApIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0Ly8gY2xhc3MgaGVscGVyIGZ1bmN0aW9ucyBmcm9tIGJvbnpvIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm9uem9cclxuXHRcclxuXHRmdW5jdGlvbiBjbGFzc1JlZyggY2xhc3NOYW1lICkge1xyXG5cdCAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIgKyBjbGFzc05hbWUgKyBcIihcXFxccyt8JClcIik7XHJcblx0fVxyXG5cdFxyXG5cdC8vIGNsYXNzTGlzdCBzdXBwb3J0IGZvciBjbGFzcyBtYW5hZ2VtZW50XHJcblx0Ly8gYWx0aG8gdG8gYmUgZmFpciwgdGhlIGFwaSBzdWNrcyBiZWNhdXNlIGl0IHdvbid0IGFjY2VwdCBtdWx0aXBsZSBjbGFzc2VzIGF0IG9uY2VcclxuXHR2YXIgaGFzQ2xhc3MsIGFkZENsYXNzLCByZW1vdmVDbGFzcztcclxuXHRcclxuXHRpZiAoICdjbGFzc0xpc3QnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcclxuXHQgIGhhc0NsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyggYyApO1xyXG5cdCAgfTtcclxuXHQgIGFkZENsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIGVsZW0uY2xhc3NMaXN0LmFkZCggYyApO1xyXG5cdCAgfTtcclxuXHQgIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSggYyApO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0ICBoYXNDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICByZXR1cm4gY2xhc3NSZWcoIGMgKS50ZXN0KCBlbGVtLmNsYXNzTmFtZSApO1xyXG5cdCAgfTtcclxuXHQgIGFkZENsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIGlmICggIWhhc0NsYXNzKCBlbGVtLCBjICkgKSB7XHJcblx0ICAgICAgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZSArICcgJyArIGM7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblx0ICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICBlbGVtLmNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLnJlcGxhY2UoIGNsYXNzUmVnKCBjICksICcgJyApO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoIGVsZW0sIGMgKSB7XHJcblx0ICB2YXIgZm4gPSBoYXNDbGFzcyggZWxlbSwgYyApID8gcmVtb3ZlQ2xhc3MgOiBhZGRDbGFzcztcclxuXHQgIGZuKCBlbGVtLCBjICk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBjbGFzc2llID0ge1xyXG5cdCAgLy8gZnVsbCBuYW1lc1xyXG5cdCAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxyXG5cdCAgYWRkQ2xhc3M6IGFkZENsYXNzLFxyXG5cdCAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxyXG5cdCAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxyXG5cdCAgLy8gc2hvcnQgbmFtZXNcclxuXHQgIGhhczogaGFzQ2xhc3MsXHJcblx0ICBhZGQ6IGFkZENsYXNzLFxyXG5cdCAgcmVtb3ZlOiByZW1vdmVDbGFzcyxcclxuXHQgIHRvZ2dsZTogdG9nZ2xlQ2xhc3NcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHRyYW5zcG9ydFxyXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgLy8gQU1EXHJcblx0ICBkZWZpbmUoIGNsYXNzaWUgKTtcclxuXHR9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgLy8gQ29tbW9uSlNcclxuXHQgIG1vZHVsZS5leHBvcnRzID0gY2xhc3NpZTtcclxuXHR9IGVsc2Uge1xyXG5cdCAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgIHdpbmRvdy5jbGFzc2llID0gY2xhc3NpZTtcclxuXHR9XHJcblx0XHJcblx0fSkoIHdpbmRvdyApO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogZ2V0U3R5bGVQcm9wZXJ0eSB2MS4wLjRcclxuXHQgKiBvcmlnaW5hbCBieSBrYW5nYXhcclxuXHQgKiBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9mZWF0dXJlLXRlc3RpbmctY3NzLXByb3BlcnRpZXMvXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKi9cclxuXHRcclxuXHQvKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgZXhwb3J0czogZmFsc2UsIG1vZHVsZTogZmFsc2UgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdHZhciBwcmVmaXhlcyA9ICdXZWJraXQgTW96IG1zIE1zIE8nLnNwbGl0KCcgJyk7XHJcblx0dmFyIGRvY0VsZW1TdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcclxuXHRmdW5jdGlvbiBnZXRTdHlsZVByb3BlcnR5KCBwcm9wTmFtZSApIHtcclxuXHQgIGlmICggIXByb3BOYW1lICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyB0ZXN0IHN0YW5kYXJkIHByb3BlcnR5IGZpcnN0XHJcblx0ICBpZiAoIHR5cGVvZiBkb2NFbGVtU3R5bGVbIHByb3BOYW1lIF0gPT09ICdzdHJpbmcnICkge1xyXG5cdCAgICByZXR1cm4gcHJvcE5hbWU7XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyBjYXBpdGFsaXplXHJcblx0ICBwcm9wTmFtZSA9IHByb3BOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcE5hbWUuc2xpY2UoMSk7XHJcblx0XHJcblx0ICAvLyB0ZXN0IHZlbmRvciBzcGVjaWZpYyBwcm9wZXJ0aWVzXHJcblx0ICB2YXIgcHJlZml4ZWQ7XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBwcmVmaXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHByb3BOYW1lO1xyXG5cdCAgICBpZiAoIHR5cGVvZiBkb2NFbGVtU3R5bGVbIHByZWZpeGVkIF0gPT09ICdzdHJpbmcnICkge1xyXG5cdCAgICAgIHJldHVybiBwcmVmaXhlZDtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHQvLyB0cmFuc3BvcnRcclxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHQgIC8vIEFNRFxyXG5cdCAgZGVmaW5lKCBmdW5jdGlvbigpIHtcclxuXHQgICAgcmV0dXJuIGdldFN0eWxlUHJvcGVydHk7XHJcblx0ICB9KTtcclxuXHR9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgLy8gQ29tbW9uSlMgZm9yIENvbXBvbmVudFxyXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBnZXRTdHlsZVByb3BlcnR5O1xyXG5cdH0gZWxzZSB7XHJcblx0ICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgd2luZG93LmdldFN0eWxlUHJvcGVydHkgPSBnZXRTdHlsZVByb3BlcnR5O1xyXG5cdH1cclxuXHRcclxuXHR9KSggd2luZG93ICk7XHJcblx0XHJcblx0fS5jYWxsKHdpbmRvdykpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTc4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXHJcblx0dmFyIGRlZmluZSA9IGZhbHNlO1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvKiFcclxuXHQgKiBnZXRTaXplIHYxLjIuMlxyXG5cdCAqIG1lYXN1cmUgc2l6ZSBvZiBlbGVtZW50c1xyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgZXhwb3J0czogZmFsc2UsIHJlcXVpcmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdywgdW5kZWZpbmVkICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZ2V0IGEgbnVtYmVyIGZyb20gYSBzdHJpbmcsIG5vdCBhIHBlcmNlbnRhZ2VcclxuXHRmdW5jdGlvbiBnZXRTdHlsZVNpemUoIHZhbHVlICkge1xyXG5cdCAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XHJcblx0ICAvLyBub3QgYSBwZXJjZW50IGxpa2UgJzEwMCUnLCBhbmQgYSBudW1iZXJcclxuXHQgIHZhciBpc1ZhbGlkID0gdmFsdWUuaW5kZXhPZignJScpID09PSAtMSAmJiAhaXNOYU4oIG51bSApO1xyXG5cdCAgcmV0dXJuIGlzVmFsaWQgJiYgbnVtO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRcclxuXHR2YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcgPyBub29wIDpcclxuXHQgIGZ1bmN0aW9uKCBtZXNzYWdlICkge1xyXG5cdCAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XHJcblx0ICB9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1lYXN1cmVtZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdHZhciBtZWFzdXJlbWVudHMgPSBbXHJcblx0ICAncGFkZGluZ0xlZnQnLFxyXG5cdCAgJ3BhZGRpbmdSaWdodCcsXHJcblx0ICAncGFkZGluZ1RvcCcsXHJcblx0ICAncGFkZGluZ0JvdHRvbScsXHJcblx0ICAnbWFyZ2luTGVmdCcsXHJcblx0ICAnbWFyZ2luUmlnaHQnLFxyXG5cdCAgJ21hcmdpblRvcCcsXHJcblx0ICAnbWFyZ2luQm90dG9tJyxcclxuXHQgICdib3JkZXJMZWZ0V2lkdGgnLFxyXG5cdCAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxyXG5cdCAgJ2JvcmRlclRvcFdpZHRoJyxcclxuXHQgICdib3JkZXJCb3R0b21XaWR0aCdcclxuXHRdO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldFplcm9TaXplKCkge1xyXG5cdCAgdmFyIHNpemUgPSB7XHJcblx0ICAgIHdpZHRoOiAwLFxyXG5cdCAgICBoZWlnaHQ6IDAsXHJcblx0ICAgIGlubmVyV2lkdGg6IDAsXHJcblx0ICAgIGlubmVySGVpZ2h0OiAwLFxyXG5cdCAgICBvdXRlcldpZHRoOiAwLFxyXG5cdCAgICBvdXRlckhlaWdodDogMFxyXG5cdCAgfTtcclxuXHQgIGZvciAoIHZhciBpPTAsIGxlbiA9IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xyXG5cdCAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gMDtcclxuXHQgIH1cclxuXHQgIHJldHVybiBzaXplO1xyXG5cdH1cclxuXHRcclxuXHRcclxuXHRcclxuXHRmdW5jdGlvbiBkZWZpbmVHZXRTaXplKCBnZXRTdHlsZVByb3BlcnR5ICkge1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0dmFyIGlzU2V0dXAgPSBmYWxzZTtcclxuXHRcclxuXHR2YXIgZ2V0U3R5bGUsIGJveFNpemluZ1Byb3AsIGlzQm94U2l6ZU91dGVyO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHNldHVwIHZhcnMgYW5kIGZ1bmN0aW9uc1xyXG5cdCAqIGRvIGl0IG9uIGluaXRpYWwgZ2V0U2l6ZSgpLCByYXRoZXIgdGhhbiBvbiBzY3JpcHQgbG9hZFxyXG5cdCAqIEZvciBGaXJlZm94IGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBzZXR1cCgpIHtcclxuXHQgIC8vIHNldHVwIG9uY2VcclxuXHQgIGlmICggaXNTZXR1cCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgaXNTZXR1cCA9IHRydWU7XHJcblx0XHJcblx0ICB2YXIgZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlO1xyXG5cdCAgZ2V0U3R5bGUgPSAoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICB2YXIgZ2V0U3R5bGVGbiA9IGdldENvbXB1dGVkU3R5bGUgP1xyXG5cdCAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcclxuXHQgICAgICB9IDpcclxuXHQgICAgICBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgICAgICAgIHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZTtcclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRTdHlsZSggZWxlbSApIHtcclxuXHQgICAgICAgIHZhciBzdHlsZSA9IGdldFN0eWxlRm4oIGVsZW0gKTtcclxuXHQgICAgICAgIGlmICggIXN0eWxlICkge1xyXG5cdCAgICAgICAgICBsb2dFcnJvciggJ1N0eWxlIHJldHVybmVkICcgKyBzdHlsZSArXHJcblx0ICAgICAgICAgICAgJy4gQXJlIHlvdSBydW5uaW5nIHRoaXMgY29kZSBpbiBhIGhpZGRlbiBpZnJhbWUgb24gRmlyZWZveD8gJyArXHJcblx0ICAgICAgICAgICAgJ1NlZSBodHRwOi8vYml0Lmx5L2dldHNpemVidWcxJyApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG5cdCAgICAgIH07XHJcblx0ICB9KSgpO1xyXG5cdFxyXG5cdCAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYm94IHNpemluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdCAgYm94U2l6aW5nUHJvcCA9IGdldFN0eWxlUHJvcGVydHkoJ2JveFNpemluZycpO1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBXZWJLaXQgbWVhc3VyZXMgdGhlIG91dGVyLXdpZHRoIG9uIHN0eWxlLndpZHRoIG9uIGJvcmRlci1ib3ggZWxlbXNcclxuXHQgICAqIElFICYgRmlyZWZveCBtZWFzdXJlcyB0aGUgaW5uZXItd2lkdGhcclxuXHQgICAqL1xyXG5cdCAgaWYgKCBib3hTaXppbmdQcm9wICkge1xyXG5cdCAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgIGRpdi5zdHlsZS53aWR0aCA9ICcyMDBweCc7XHJcblx0ICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gJzFweCAycHggM3B4IDRweCc7XHJcblx0ICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XHJcblx0ICAgIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHggMnB4IDNweCA0cHgnO1xyXG5cdCAgICBkaXYuc3R5bGVbIGJveFNpemluZ1Byb3AgXSA9ICdib3JkZXItYm94JztcclxuXHRcclxuXHQgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHQgICAgYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XHJcblx0ICAgIHZhciBzdHlsZSA9IGdldFN0eWxlKCBkaXYgKTtcclxuXHRcclxuXHQgICAgaXNCb3hTaXplT3V0ZXIgPSBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICkgPT09IDIwMDtcclxuXHQgICAgYm9keS5yZW1vdmVDaGlsZCggZGl2ICk7XHJcblx0ICB9XHJcblx0XHJcblx0fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHRmdW5jdGlvbiBnZXRTaXplKCBlbGVtICkge1xyXG5cdCAgc2V0dXAoKTtcclxuXHRcclxuXHQgIC8vIHVzZSBxdWVyeVNlbGV0b3IgaWYgZWxlbSBpcyBzdHJpbmdcclxuXHQgIGlmICggdHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnICkge1xyXG5cdCAgICBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbSApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gZG8gbm90IHByb2NlZWQgb24gbm9uLW9iamVjdHNcclxuXHQgIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT09ICdvYmplY3QnIHx8ICFlbGVtLm5vZGVUeXBlICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZWxlbSApO1xyXG5cdFxyXG5cdCAgLy8gaWYgaGlkZGVuLCBldmVyeXRoaW5nIGlzIDBcclxuXHQgIGlmICggc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnICkge1xyXG5cdCAgICByZXR1cm4gZ2V0WmVyb1NpemUoKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBzaXplID0ge307XHJcblx0ICBzaXplLndpZHRoID0gZWxlbS5vZmZzZXRXaWR0aDtcclxuXHQgIHNpemUuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XHJcblx0XHJcblx0ICB2YXIgaXNCb3JkZXJCb3ggPSBzaXplLmlzQm9yZGVyQm94ID0gISEoIGJveFNpemluZ1Byb3AgJiZcclxuXHQgICAgc3R5bGVbIGJveFNpemluZ1Byb3AgXSAmJiBzdHlsZVsgYm94U2l6aW5nUHJvcCBdID09PSAnYm9yZGVyLWJveCcgKTtcclxuXHRcclxuXHQgIC8vIGdldCBhbGwgbWVhc3VyZW1lbnRzXHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBtZWFzdXJlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0ICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcclxuXHQgICAgdmFyIHZhbHVlID0gc3R5bGVbIG1lYXN1cmVtZW50IF07XHJcblx0ICAgIHZhbHVlID0gbXVuZ2VOb25QaXhlbCggZWxlbSwgdmFsdWUgKTtcclxuXHQgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XHJcblx0ICAgIC8vIGFueSAnYXV0bycsICdtZWRpdW0nIHZhbHVlIHdpbGwgYmUgMFxyXG5cdCAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gIWlzTmFOKCBudW0gKSA/IG51bSA6IDA7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgcGFkZGluZ1dpZHRoID0gc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUucGFkZGluZ1JpZ2h0O1xyXG5cdCAgdmFyIHBhZGRpbmdIZWlnaHQgPSBzaXplLnBhZGRpbmdUb3AgKyBzaXplLnBhZGRpbmdCb3R0b207XHJcblx0ICB2YXIgbWFyZ2luV2lkdGggPSBzaXplLm1hcmdpbkxlZnQgKyBzaXplLm1hcmdpblJpZ2h0O1xyXG5cdCAgdmFyIG1hcmdpbkhlaWdodCA9IHNpemUubWFyZ2luVG9wICsgc2l6ZS5tYXJnaW5Cb3R0b207XHJcblx0ICB2YXIgYm9yZGVyV2lkdGggPSBzaXplLmJvcmRlckxlZnRXaWR0aCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aDtcclxuXHQgIHZhciBib3JkZXJIZWlnaHQgPSBzaXplLmJvcmRlclRvcFdpZHRoICsgc2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcclxuXHRcclxuXHQgIHZhciBpc0JvcmRlckJveFNpemVPdXRlciA9IGlzQm9yZGVyQm94ICYmIGlzQm94U2l6ZU91dGVyO1xyXG5cdFxyXG5cdCAgLy8gb3ZlcndyaXRlIHdpZHRoIGFuZCBoZWlnaHQgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHN0eWxlXHJcblx0ICB2YXIgc3R5bGVXaWR0aCA9IGdldFN0eWxlU2l6ZSggc3R5bGUud2lkdGggKTtcclxuXHQgIGlmICggc3R5bGVXaWR0aCAhPT0gZmFsc2UgKSB7XHJcblx0ICAgIHNpemUud2lkdGggPSBzdHlsZVdpZHRoICtcclxuXHQgICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XHJcblx0ICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIHN0eWxlSGVpZ2h0ID0gZ2V0U3R5bGVTaXplKCBzdHlsZS5oZWlnaHQgKTtcclxuXHQgIGlmICggc3R5bGVIZWlnaHQgIT09IGZhbHNlICkge1xyXG5cdCAgICBzaXplLmhlaWdodCA9IHN0eWxlSGVpZ2h0ICtcclxuXHQgICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XHJcblx0ICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBzaXplLmlubmVyV2lkdGggPSBzaXplLndpZHRoIC0gKCBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xyXG5cdCAgc2l6ZS5pbm5lckhlaWdodCA9IHNpemUuaGVpZ2h0IC0gKCBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XHJcblx0XHJcblx0ICBzaXplLm91dGVyV2lkdGggPSBzaXplLndpZHRoICsgbWFyZ2luV2lkdGg7XHJcblx0ICBzaXplLm91dGVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyBtYXJnaW5IZWlnaHQ7XHJcblx0XHJcblx0ICByZXR1cm4gc2l6ZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gSUU4IHJldHVybnMgcGVyY2VudCB2YWx1ZXMsIG5vdCBwaXhlbHNcclxuXHQvLyB0YWtlbiBmcm9tIGpRdWVyeSdzIGN1ckNTU1xyXG5cdGZ1bmN0aW9uIG11bmdlTm9uUGl4ZWwoIGVsZW0sIHZhbHVlICkge1xyXG5cdCAgLy8gSUU4IGFuZCBoYXMgcGVyY2VudCB2YWx1ZVxyXG5cdCAgaWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCB2YWx1ZS5pbmRleE9mKCclJykgPT09IC0xICkge1xyXG5cdCAgICByZXR1cm4gdmFsdWU7XHJcblx0ICB9XHJcblx0ICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xyXG5cdCAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xyXG5cdCAgdmFyIGxlZnQgPSBzdHlsZS5sZWZ0O1xyXG5cdCAgdmFyIHJzID0gZWxlbS5ydW50aW1lU3R5bGU7XHJcblx0ICB2YXIgcnNMZWZ0ID0gcnMgJiYgcnMubGVmdDtcclxuXHRcclxuXHQgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcclxuXHQgIGlmICggcnNMZWZ0ICkge1xyXG5cdCAgICBycy5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcclxuXHQgIH1cclxuXHQgIHN0eWxlLmxlZnQgPSB2YWx1ZTtcclxuXHQgIHZhbHVlID0gc3R5bGUucGl4ZWxMZWZ0O1xyXG5cdFxyXG5cdCAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xyXG5cdCAgc3R5bGUubGVmdCA9IGxlZnQ7XHJcblx0ICBpZiAoIHJzTGVmdCApIHtcclxuXHQgICAgcnMubGVmdCA9IHJzTGVmdDtcclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB2YWx1ZTtcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIGdldFNpemU7XHJcblx0XHJcblx0fVxyXG5cdFxyXG5cdC8vIHRyYW5zcG9ydFxyXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgLy8gQU1EIGZvciBSZXF1aXJlSlNcclxuXHQgIGRlZmluZSggWyAnZ2V0LXN0eWxlLXByb3BlcnR5L2dldC1zdHlsZS1wcm9wZXJ0eScgXSwgZGVmaW5lR2V0U2l6ZSApO1xyXG5cdH0gZWxzZSBpZiAoIHRydWUgKSB7XHJcblx0ICAvLyBDb21tb25KUyBmb3IgQ29tcG9uZW50XHJcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluZUdldFNpemUoIF9fd2VicGFja19yZXF1aXJlX18oMTc3KSApO1xyXG5cdH0gZWxzZSB7XHJcblx0ICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgd2luZG93LmdldFNpemUgPSBkZWZpbmVHZXRTaXplKCB3aW5kb3cuZ2V0U3R5bGVQcm9wZXJ0eSApO1xyXG5cdH1cclxuXHRcclxuXHR9KSggd2luZG93ICk7XHJcblx0XHJcblx0fS5jYWxsKHdpbmRvdykpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTc5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXHJcblx0dmFyIGRlZmluZSA9IGZhbHNlO1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvKiFcclxuXHQgKiBVbmlkcmFnZ2VyIHYxLjEuNVxyXG5cdCAqIERyYWdnYWJsZSBiYXNlIGNsYXNzXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKi9cclxuXHRcclxuXHQvKmpzaGludCBicm93c2VyOiB0cnVlLCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XHJcblx0ICAvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZSAqL1xyXG5cdCAgJ3VzZSBzdHJpY3QnO1xyXG5cdCAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXHJcblx0XHJcblx0ICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgICAvLyBBTURcclxuXHQgICAgZGVmaW5lKCBbXHJcblx0ICAgICAgJ2V2ZW50aWUvZXZlbnRpZScsXHJcblx0ICAgICAgJ3VuaXBvaW50ZXIvdW5pcG9pbnRlcidcclxuXHQgICAgXSwgZnVuY3Rpb24oIGV2ZW50aWUsIFVuaXBvaW50ZXIgKSB7XHJcblx0ICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgZXZlbnRpZSwgVW5pcG9pbnRlciApO1xyXG5cdCAgICB9KTtcclxuXHQgIH0gZWxzZSBpZiAoIHRydWUgKSB7XHJcblx0ICAgIC8vIENvbW1vbkpTXHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxODApLFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTgxKVxyXG5cdCAgICApO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgICAgd2luZG93LlVuaWRyYWdnZXIgPSBmYWN0b3J5KFxyXG5cdCAgICAgIHdpbmRvdyxcclxuXHQgICAgICB3aW5kb3cuZXZlbnRpZSxcclxuXHQgICAgICB3aW5kb3cuVW5pcG9pbnRlclxyXG5cdCAgICApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBldmVudGllLCBVbmlwb2ludGVyICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQvLyAtLS0tLSAgLS0tLS0gLy9cclxuXHRcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRcclxuXHQvLyBoYW5kbGUgSUU4IHByZXZlbnQgZGVmYXVsdFxyXG5cdGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0RXZlbnQoIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wcmV2ZW50RGVmYXVsdCApIHtcclxuXHQgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFVuaWRyYWdnZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHRmdW5jdGlvbiBVbmlkcmFnZ2VyKCkge31cclxuXHRcclxuXHQvLyBpbmhlcml0IFVuaXBvaW50ZXIgJiBFdmVudEVtaXR0ZXJcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZSA9IG5ldyBVbmlwb2ludGVyKCk7XHJcblx0XHJcblx0Ly8gLS0tLS0gYmluZCBzdGFydCAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmJpbmRIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcblx0ICB0aGlzLl9iaW5kSGFuZGxlcyggdHJ1ZSApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUudW5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5fYmluZEhhbmRsZXMoIGZhbHNlICk7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcclxuXHQvKipcclxuXHQgKiB3b3JrcyBhcyB1bmJpbmRlciwgYXMgeW91IGNhbiAuYmluZEhhbmRsZXMoIGZhbHNlICkgdG8gdW5iaW5kXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmQgLSB3aWxsIHVuYmluZCBpZiBmYWxzZXlcclxuXHQgKi9cclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5fYmluZEhhbmRsZXMgPSBmdW5jdGlvbiggaXNCaW5kICkge1xyXG5cdCAgLy8gbXVuZ2UgaXNCaW5kLCBkZWZhdWx0IHRvIHRydWVcclxuXHQgIGlzQmluZCA9IGlzQmluZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhaXNCaW5kO1xyXG5cdCAgLy8gZXh0cmEgYmluZCBsb2dpY1xyXG5cdCAgdmFyIGJpbmRlckV4dHJhO1xyXG5cdCAgaWYgKCBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIGJpbmRlckV4dHJhID0gZnVuY3Rpb24oIGhhbmRsZSApIHtcclxuXHQgICAgICAvLyBkaXNhYmxlIHNjcm9sbGluZyBvbiB0aGUgZWxlbWVudFxyXG5cdCAgICAgIGhhbmRsZS5zdHlsZS50b3VjaEFjdGlvbiA9IGlzQmluZCA/ICdub25lJyA6ICcnO1xyXG5cdCAgICB9O1xyXG5cdCAgfSBlbHNlIGlmICggbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIGJpbmRlckV4dHJhID0gZnVuY3Rpb24oIGhhbmRsZSApIHtcclxuXHQgICAgICAvLyBkaXNhYmxlIHNjcm9sbGluZyBvbiB0aGUgZWxlbWVudFxyXG5cdCAgICAgIGhhbmRsZS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gaXNCaW5kID8gJ25vbmUnIDogJyc7XHJcblx0ICAgIH07XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBiaW5kZXJFeHRyYSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgIC8vIFRPRE8gcmUtZW5hYmxlIGltZy5vbmRyYWdzdGFydCB3aGVuIHVuYmluZGluZ1xyXG5cdCAgICAgIGlmICggaXNCaW5kICkge1xyXG5cdCAgICAgICAgZGlzYWJsZUltZ09uZHJhZ3N0YXJ0KCBoYW5kbGUgKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICB9XHJcblx0ICAvLyBiaW5kIGVhY2ggaGFuZGxlXHJcblx0ICB2YXIgYmluZE1ldGhvZCA9IGlzQmluZCA/ICdiaW5kJyA6ICd1bmJpbmQnO1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgaGFuZGxlID0gdGhpcy5oYW5kbGVzW2ldO1xyXG5cdCAgICB0aGlzLl9iaW5kU3RhcnRFdmVudCggaGFuZGxlLCBpc0JpbmQgKTtcclxuXHQgICAgYmluZGVyRXh0cmEoIGhhbmRsZSApO1xyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGhhbmRsZSwgJ2NsaWNrJywgdGhpcyApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gcmVtb3ZlIGRlZmF1bHQgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb24gYWxsIGltYWdlcyBpbiBJRThcclxuXHQvLyBJRTggZG9lcyBpdHMgb3duIGRyYWcgdGhpbmcgb24gaW1hZ2VzLCB3aGljaCBtZXNzZXMgc3R1ZmYgdXBcclxuXHRcclxuXHRmdW5jdGlvbiBub0RyYWdTdGFydCgpIHtcclxuXHQgIHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gVE9ETyByZXBsYWNlIHRoaXMgd2l0aCBhIElFOCB0ZXN0XHJcblx0dmFyIGlzSUU4ID0gJ2F0dGFjaEV2ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHJcblx0Ly8gSUU4IG9ubHlcclxuXHR2YXIgZGlzYWJsZUltZ09uZHJhZ3N0YXJ0ID0gIWlzSUU4ID8gbm9vcCA6IGZ1bmN0aW9uKCBoYW5kbGUgKSB7XHJcblx0XHJcblx0ICBpZiAoIGhhbmRsZS5ub2RlTmFtZSA9PSAnSU1HJyApIHtcclxuXHQgICAgaGFuZGxlLm9uZHJhZ3N0YXJ0ID0gbm9EcmFnU3RhcnQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgaW1hZ2VzID0gaGFuZGxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpO1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gaW1hZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgaW1nID0gaW1hZ2VzW2ldO1xyXG5cdCAgICBpbWcub25kcmFnc3RhcnQgPSBub0RyYWdTdGFydDtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIHN0YXJ0IGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBzdGFydFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgLy8gZGlzbWlzcyByYW5nZSBzbGlkZXJzXHJcblx0ICBpZiAoIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PSAnSU5QVVQnICYmIGV2ZW50LnRhcmdldC50eXBlID09ICdyYW5nZScgKSB7XHJcblx0ICAgIC8vIHJlc2V0IHBvaW50ZXJEb3duIGxvZ2ljXHJcblx0ICAgIHRoaXMuaXNQb2ludGVyRG93biA9IGZhbHNlO1xyXG5cdCAgICBkZWxldGUgdGhpcy5wb2ludGVySWRlbnRpZmllcjtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgLy8ga2x1ZGdlIHRvIGJsdXIgZm9jdXNlZCBpbnB1dHMgaW4gZHJhZ2dlclxyXG5cdCAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdCAgaWYgKCBmb2N1c2VkICYmIGZvY3VzZWQuYmx1ciApIHtcclxuXHQgICAgZm9jdXNlZC5ibHVyKCk7XHJcblx0ICB9XHJcblx0ICAvLyBiaW5kIG1vdmUgYW5kIGVuZCBldmVudHNcclxuXHQgIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XHJcblx0ICAvLyB0cmFjayBzY3JvbGxpbmdcclxuXHQgIHRoaXMucG9pbnRlckRvd25TY3JvbGwgPSBVbmlkcmFnZ2VyLmdldFNjcm9sbFBvc2l0aW9uKCk7XHJcblx0ICBldmVudGllLmJpbmQoIHdpbmRvdywgJ3Njcm9sbCcsIHRoaXMgKTtcclxuXHRcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGJhc2UgcG9pbnRlciBkb3duIGxvZ2ljXHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdQb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIC8vIHRyYWNrIHRvIHNlZSB3aGVuIGRyYWdnaW5nIHN0YXJ0c1xyXG5cdCAgdGhpcy5wb2ludGVyRG93blBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQoIHBvaW50ZXIgKTtcclxuXHRcclxuXHQgIC8vIHByZXZlbnQgZGVmYXVsdCwgdW5sZXNzIHRvdWNoc3RhcnQgb3IgPHNlbGVjdD5cclxuXHQgIHZhciBpc1RvdWNoc3RhcnQgPSBldmVudC50eXBlID09ICd0b3VjaHN0YXJ0JztcclxuXHQgIHZhciB0YXJnZXROb2RlTmFtZSA9IGV2ZW50LnRhcmdldC5ub2RlTmFtZTtcclxuXHQgIGlmICggIWlzVG91Y2hzdGFydCAmJiB0YXJnZXROb2RlTmFtZSAhPSAnU0VMRUNUJyApIHtcclxuXHQgICAgcHJldmVudERlZmF1bHRFdmVudCggZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHQvKipcclxuXHQgKiBkcmFnIG1vdmVcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHZhciBtb3ZlVmVjdG9yID0gdGhpcy5fZHJhZ1BvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xyXG5cdCAgdGhpcy5fZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBiYXNlIHBvaW50ZXIgbW92ZSBsb2dpY1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnUG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB2YXIgbW92ZVBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQoIHBvaW50ZXIgKTtcclxuXHQgIHZhciBtb3ZlVmVjdG9yID0ge1xyXG5cdCAgICB4OiBtb3ZlUG9pbnQueCAtIHRoaXMucG9pbnRlckRvd25Qb2ludC54LFxyXG5cdCAgICB5OiBtb3ZlUG9pbnQueSAtIHRoaXMucG9pbnRlckRvd25Qb2ludC55XHJcblx0ICB9O1xyXG5cdCAgLy8gc3RhcnQgZHJhZyBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcclxuXHQgIGlmICggIXRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLmhhc0RyYWdTdGFydGVkKCBtb3ZlVmVjdG9yICkgKSB7XHJcblx0ICAgIHRoaXMuX2RyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBtb3ZlVmVjdG9yO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gY29uZGl0aW9uIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XHJcblx0ICByZXR1cm4gTWF0aC5hYnMoIG1vdmVWZWN0b3IueCApID4gMyB8fCBNYXRoLmFicyggbW92ZVZlY3Rvci55ICkgPiAzO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0Ly8gLS0tLS0gZW5kIGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciB1cFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0ICB0aGlzLl9kcmFnUG9pbnRlclVwKCBldmVudCwgcG9pbnRlciApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdQb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICBpZiAoIHRoaXMuaXNEcmFnZ2luZyApIHtcclxuXHQgICAgdGhpcy5fZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIC8vIHBvaW50ZXIgZGlkbid0IG1vdmUgZW5vdWdoIGZvciBkcmFnIHRvIHN0YXJ0XHJcblx0ICAgIHRoaXMuX3N0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUucG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcclxuXHQgIGV2ZW50aWUudW5iaW5kKCB3aW5kb3csICdzY3JvbGwnLCB0aGlzICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZHJhZ1N0YXJ0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcblx0ICB0aGlzLmRyYWdTdGFydFBvaW50ID0gVW5pZHJhZ2dlci5nZXRQb2ludGVyUG9pbnQoIHBvaW50ZXIgKTtcclxuXHQgIC8vIHByZXZlbnQgY2xpY2tzXHJcblx0ICB0aGlzLmlzUHJldmVudGluZ0NsaWNrcyA9IHRydWU7XHJcblx0XHJcblx0ICB0aGlzLmRyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ1N0YXJ0JywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBkcmFnTW92ZVxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcclxuXHQgIC8vIGRvIG5vdCBkcmFnIGlmIG5vdCBkcmFnZ2luZyB5ZXRcclxuXHQgIGlmICggIXRoaXMuaXNEcmFnZ2luZyApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5kcmFnTW92ZSggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmRyYWdNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xyXG5cdCAgcHJldmVudERlZmF1bHRFdmVudCggZXZlbnQgKTtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ01vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGRyYWdFbmRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5fZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIC8vIHNldCBmbGFnc1xyXG5cdCAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcblx0ICAvLyByZS1lbmFibGUgY2xpY2tpbmcgYXN5bmNcclxuXHQgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHQgICAgZGVsZXRlIF90aGlzLmlzUHJldmVudGluZ0NsaWNrcztcclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgdGhpcy5kcmFnRW5kKCBldmVudCwgcG9pbnRlciApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ0VuZCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUucG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcclxuXHQgIGV2ZW50aWUudW5iaW5kKCB3aW5kb3csICdzY3JvbGwnLCB0aGlzICk7XHJcblx0ICBkZWxldGUgdGhpcy5wb2ludGVyRG93blNjcm9sbDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG9uY2xpY2sgLS0tLS0gLy9cclxuXHRcclxuXHQvLyBoYW5kbGUgYWxsIGNsaWNrcyBhbmQgcHJldmVudCBjbGlja3Mgd2hlbiBkcmFnZ2luZ1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICBpZiAoIHRoaXMuaXNQcmV2ZW50aW5nQ2xpY2tzICkge1xyXG5cdCAgICBwcmV2ZW50RGVmYXVsdEV2ZW50KCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cclxuXHRcclxuXHQvLyB0cmlnZ2VyZWQgYWZ0ZXIgcG9pbnRlciBkb3duICYgdXAgd2l0aCBuby90aW55IG1vdmVtZW50XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX3N0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgLy8gaWdub3JlIGVtdWxhdGVkIG1vdXNlIHVwIGNsaWNrc1xyXG5cdCAgaWYgKCB0aGlzLmlzSWdub3JpbmdNb3VzZVVwICYmIGV2ZW50LnR5cGUgPT0gJ21vdXNldXAnICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyBhbGxvdyBjbGljayBpbiA8aW5wdXQ+cyBhbmQgPHRleHRhcmVhPnNcclxuXHQgIHZhciBub2RlTmFtZSA9IGV2ZW50LnRhcmdldC5ub2RlTmFtZTtcclxuXHQgIGlmICggbm9kZU5hbWUgPT0gJ0lOUFVUJyB8fCBub2RlTmFtZSA9PSAnVEVYVEFSRUEnICkge1xyXG5cdCAgICBldmVudC50YXJnZXQuZm9jdXMoKTtcclxuXHQgIH1cclxuXHQgIHRoaXMuc3RhdGljQ2xpY2soIGV2ZW50LCBwb2ludGVyICk7XHJcblx0XHJcblx0ICAvLyBzZXQgZmxhZyBmb3IgZW11bGF0ZWQgY2xpY2tzIDMwMG1zIGFmdGVyIHRvdWNoZW5kXHJcblx0ICBpZiAoIGV2ZW50LnR5cGUgIT0gJ21vdXNldXAnICkge1xyXG5cdCAgICB0aGlzLmlzSWdub3JpbmdNb3VzZVVwID0gdHJ1ZTtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHQgICAgLy8gcmVzZXQgZmxhZyBhZnRlciAzMDBtc1xyXG5cdCAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICBkZWxldGUgX3RoaXMuaXNJZ25vcmluZ01vdXNlVXA7XHJcblx0ICAgIH0sIDQwMCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3N0YXRpY0NsaWNrJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBzY3JvbGwgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5vbnNjcm9sbCA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdmFyIHNjcm9sbCA9IFVuaWRyYWdnZXIuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcclxuXHQgIHZhciBzY3JvbGxNb3ZlWCA9IHRoaXMucG9pbnRlckRvd25TY3JvbGwueCAtIHNjcm9sbC54O1xyXG5cdCAgdmFyIHNjcm9sbE1vdmVZID0gdGhpcy5wb2ludGVyRG93blNjcm9sbC55IC0gc2Nyb2xsLnk7XHJcblx0ICAvLyBjYW5jZWwgY2xpY2svdGFwIGlmIHNjcm9sbCBpcyB0b28gbXVjaFxyXG5cdCAgaWYgKCBNYXRoLmFicyggc2Nyb2xsTW92ZVggKSA+IDMgfHwgTWF0aC5hYnMoIHNjcm9sbE1vdmVZICkgPiAzICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyRG9uZSgpO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gdXRpbHMgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IGZ1bmN0aW9uKCBwb2ludGVyICkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgeDogcG9pbnRlci5wYWdlWCAhPT0gdW5kZWZpbmVkID8gcG9pbnRlci5wYWdlWCA6IHBvaW50ZXIuY2xpZW50WCxcclxuXHQgICAgeTogcG9pbnRlci5wYWdlWSAhPT0gdW5kZWZpbmVkID8gcG9pbnRlci5wYWdlWSA6IHBvaW50ZXIuY2xpZW50WVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBpc1BhZ2VPZmZzZXQgPSB3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZDtcclxuXHRcclxuXHQvLyBnZXQgc2Nyb2xsIGluIHsgeCwgeSB9XHJcblx0VW5pZHJhZ2dlci5nZXRTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgeDogaXNQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxyXG5cdCAgICB5OiBpc1BhZ2VPZmZzZXQgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcFxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tICAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIuZ2V0UG9pbnRlclBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQ7XHJcblx0XHJcblx0cmV0dXJuIFVuaWRyYWdnZXI7XHJcblx0XHJcblx0fSkpO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXHJcblx0ICogZXZlbnRpZSB2MS4wLjZcclxuXHQgKiBldmVudCBiaW5kaW5nIGhlbHBlclxyXG5cdCAqICAgZXZlbnRpZS5iaW5kKCBlbGVtLCAnY2xpY2snLCBteUZuIClcclxuXHQgKiAgIGV2ZW50aWUudW5iaW5kKCBlbGVtLCAnY2xpY2snLCBteUZuIClcclxuXHQgKiBNSVQgbGljZW5zZVxyXG5cdCAqL1xyXG5cdFxyXG5cdC8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuXHQvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlICovXHJcblx0XHJcblx0KCBmdW5jdGlvbiggd2luZG93ICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHRcclxuXHR2YXIgYmluZCA9IGZ1bmN0aW9uKCkge307XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0SUVFdmVudCggb2JqICkge1xyXG5cdCAgdmFyIGV2ZW50ID0gd2luZG93LmV2ZW50O1xyXG5cdCAgLy8gYWRkIGV2ZW50LnRhcmdldFxyXG5cdCAgZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgb2JqO1xyXG5cdCAgcmV0dXJuIGV2ZW50O1xyXG5cdH1cclxuXHRcclxuXHRpZiAoIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcclxuXHQgIGJpbmQgPSBmdW5jdGlvbiggb2JqLCB0eXBlLCBmbiApIHtcclxuXHQgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGZuLCBmYWxzZSApO1xyXG5cdCAgfTtcclxuXHR9IGVsc2UgaWYgKCBkb2NFbGVtLmF0dGFjaEV2ZW50ICkge1xyXG5cdCAgYmluZCA9IGZ1bmN0aW9uKCBvYmosIHR5cGUsIGZuICkge1xyXG5cdCAgICBvYmpbIHR5cGUgKyBmbiBdID0gZm4uaGFuZGxlRXZlbnQgP1xyXG5cdCAgICAgIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgdmFyIGV2ZW50ID0gZ2V0SUVFdmVudCggb2JqICk7XHJcblx0ICAgICAgICBmbi5oYW5kbGVFdmVudC5jYWxsKCBmbiwgZXZlbnQgKTtcclxuXHQgICAgICB9IDpcclxuXHQgICAgICBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgIHZhciBldmVudCA9IGdldElFRXZlbnQoIG9iaiApO1xyXG5cdCAgICAgICAgZm4uY2FsbCggb2JqLCBldmVudCApO1xyXG5cdCAgICAgIH07XHJcblx0ICAgIG9iai5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgb2JqWyB0eXBlICsgZm4gXSApO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0XHJcblx0dmFyIHVuYmluZCA9IGZ1bmN0aW9uKCkge307XHJcblx0XHJcblx0aWYgKCBkb2NFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XHJcblx0ICB1bmJpbmQgPSBmdW5jdGlvbiggb2JqLCB0eXBlLCBmbiApIHtcclxuXHQgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGZuLCBmYWxzZSApO1xyXG5cdCAgfTtcclxuXHR9IGVsc2UgaWYgKCBkb2NFbGVtLmRldGFjaEV2ZW50ICkge1xyXG5cdCAgdW5iaW5kID0gZnVuY3Rpb24oIG9iaiwgdHlwZSwgZm4gKSB7XHJcblx0ICAgIG9iai5kZXRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgb2JqWyB0eXBlICsgZm4gXSApO1xyXG5cdCAgICB0cnkge1xyXG5cdCAgICAgIGRlbGV0ZSBvYmpbIHR5cGUgKyBmbiBdO1xyXG5cdCAgICB9IGNhdGNoICggZXJyICkge1xyXG5cdCAgICAgIC8vIGNhbid0IGRlbGV0ZSB3aW5kb3cgb2JqZWN0IHByb3BlcnRpZXNcclxuXHQgICAgICBvYmpbIHR5cGUgKyBmbiBdID0gdW5kZWZpbmVkO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZXZlbnRpZSA9IHtcclxuXHQgIGJpbmQ6IGJpbmQsXHJcblx0ICB1bmJpbmQ6IHVuYmluZFxyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbW9kdWxlIGRlZmluaXRpb24gLS0tLS0gLy9cclxuXHRcclxuXHRpZiAoIHRydWUgKSB7XHJcblx0ICAvLyBBTURcclxuXHQgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGV2ZW50aWUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcclxuXHQgIC8vIENvbW1vbkpTXHJcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGV2ZW50aWU7XHJcblx0fSBlbHNlIHtcclxuXHQgIC8vIGJyb3dzZXIgZ2xvYmFsXHJcblx0ICB3aW5kb3cuZXZlbnRpZSA9IGV2ZW50aWU7XHJcblx0fVxyXG5cdFxyXG5cdH0pKCB3aW5kb3cgKTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIFVuaXBvaW50ZXIgdjEuMS4wXHJcblx0ICogYmFzZSBjbGFzcyBmb3IgZG9pbmcgb25lIHRoaW5nIHdpdGggcG9pbnRlciBldmVudFxyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSwgcmVxdWlyZTogZmFsc2UgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XHJcblx0ICAndXNlIHN0cmljdCc7XHJcblx0ICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cclxuXHRcclxuXHQgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblx0ICAgIC8vIEFNRFxyXG5cdCAgICBkZWZpbmUoIFtcclxuXHQgICAgICAnZXZlbnRFbWl0dGVyL0V2ZW50RW1pdHRlcicsXHJcblx0ICAgICAgJ2V2ZW50aWUvZXZlbnRpZSdcclxuXHQgICAgXSwgZnVuY3Rpb24oIEV2ZW50RW1pdHRlciwgZXZlbnRpZSApIHtcclxuXHQgICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdmVudEVtaXR0ZXIsIGV2ZW50aWUgKTtcclxuXHQgICAgfSk7XHJcblx0ICB9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgICAvLyBDb21tb25KU1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXHJcblx0ICAgICAgd2luZG93LFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTgyKSxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MClcclxuXHQgICAgKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIC8vIGJyb3dzZXIgZ2xvYmFsXHJcblx0ICAgIHdpbmRvdy5Vbmlwb2ludGVyID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgd2luZG93LkV2ZW50RW1pdHRlcixcclxuXHQgICAgICB3aW5kb3cuZXZlbnRpZVxyXG5cdCAgICApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdmVudEVtaXR0ZXIsIGV2ZW50aWUgKSB7XHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFVuaXBvaW50ZXIoKSB7fVxyXG5cdFxyXG5cdC8vIGluaGVyaXQgRXZlbnRFbWl0dGVyXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuYmluZFN0YXJ0RXZlbnQgPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgIHRoaXMuX2JpbmRTdGFydEV2ZW50KCBlbGVtLCB0cnVlICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS51bmJpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0ICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgZmFsc2UgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHdvcmtzIGFzIHVuYmluZGVyLCBhcyB5b3UgY2FuIC5fYmluZFN0YXJ0KCBmYWxzZSApIHRvIHVuYmluZFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5kIC0gd2lsbCB1bmJpbmQgaWYgZmFsc2V5XHJcblx0ICovXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX2JpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIGlzQmluZCApIHtcclxuXHQgIC8vIG11bmdlIGlzQmluZCwgZGVmYXVsdCB0byB0cnVlXHJcblx0ICBpc0JpbmQgPSBpc0JpbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWlzQmluZDtcclxuXHQgIHZhciBiaW5kTWV0aG9kID0gaXNCaW5kID8gJ2JpbmQnIDogJ3VuYmluZCc7XHJcblx0XHJcblx0ICBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIC8vIFczQyBQb2ludGVyIEV2ZW50cywgSUUxMS4gU2VlIGh0dHBzOi8vY29kZXJ3YWxsLmNvbS9wL21mcmVjYVxyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICdwb2ludGVyZG93bicsIHRoaXMgKTtcclxuXHQgIH0gZWxzZSBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCApIHtcclxuXHQgICAgLy8gSUUxMCBQb2ludGVyIEV2ZW50c1xyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICdNU1BvaW50ZXJEb3duJywgdGhpcyApO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgLy8gbGlzdGVuIGZvciBib3RoLCBmb3IgZGV2aWNlcyBsaWtlIENocm9tZSBQaXhlbFxyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICdtb3VzZWRvd24nLCB0aGlzICk7XHJcblx0ICAgIGV2ZW50aWVbIGJpbmRNZXRob2QgXSggZWxlbSwgJ3RvdWNoc3RhcnQnLCB0aGlzICk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyB0cmlnZ2VyIGhhbmRsZXIgbWV0aG9kcyBmb3IgZXZlbnRzXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XHJcblx0ICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xyXG5cdCAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIHJldHVybnMgdGhlIHRvdWNoIHRoYXQgd2UncmUga2VlcGluZyB0cmFjayBvZlxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLmdldFRvdWNoID0gZnVuY3Rpb24oIHRvdWNoZXMgKSB7XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xyXG5cdCAgICBpZiAoIHRvdWNoLmlkZW50aWZpZXIgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgICByZXR1cm4gdG91Y2g7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIHN0YXJ0IGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25tb3VzZWRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICAvLyBkaXNtaXNzIGNsaWNrcyBmcm9tIHJpZ2h0IG9yIG1pZGRsZSBidXR0b25zXHJcblx0ICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG5cdCAgaWYgKCBidXR0b24gJiYgKCBidXR0b24gIT09IDAgJiYgYnV0dG9uICE9PSAxICkgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9uTVNQb2ludGVyRG93biA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVyZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgc3RhcnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5fcG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICAvLyBkaXNtaXNzIG90aGVyIHBvaW50ZXJzXHJcblx0ICBpZiAoIHRoaXMuaXNQb2ludGVyRG93biApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5pc1BvaW50ZXJEb3duID0gdHJ1ZTtcclxuXHQgIC8vIHNhdmUgcG9pbnRlciBpZGVudGlmaWVyIHRvIG1hdGNoIHVwIHRvdWNoIGV2ZW50c1xyXG5cdCAgdGhpcy5wb2ludGVySWRlbnRpZmllciA9IHBvaW50ZXIucG9pbnRlcklkICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAvLyBwb2ludGVySWQgZm9yIHBvaW50ZXIgZXZlbnRzLCB0b3VjaC5pbmRlbnRpZmllciBmb3IgdG91Y2ggZXZlbnRzXHJcblx0ICAgIHBvaW50ZXIucG9pbnRlcklkIDogcG9pbnRlci5pZGVudGlmaWVyO1xyXG5cdFxyXG5cdCAgdGhpcy5wb2ludGVyRG93biggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5fYmluZFBvc3RTdGFydEV2ZW50cyggZXZlbnQgKTtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGhhc2ggb2YgZXZlbnRzIHRvIGJlIGJvdW5kIGFmdGVyIHN0YXJ0IGV2ZW50XHJcblx0dmFyIHBvc3RTdGFydEV2ZW50cyA9IHtcclxuXHQgIG1vdXNlZG93bjogWyAnbW91c2Vtb3ZlJywgJ21vdXNldXAnIF0sXHJcblx0ICB0b3VjaHN0YXJ0OiBbICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIF0sXHJcblx0ICBwb2ludGVyZG93bjogWyAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJjYW5jZWwnIF0sXHJcblx0ICBNU1BvaW50ZXJEb3duOiBbICdNU1BvaW50ZXJNb3ZlJywgJ01TUG9pbnRlclVwJywgJ01TUG9pbnRlckNhbmNlbCcgXVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX2JpbmRQb3N0U3RhcnRFdmVudHMgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICBpZiAoICFldmVudCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgLy8gZ2V0IHByb3BlciBldmVudHMgdG8gbWF0Y2ggc3RhcnQgZXZlbnRcclxuXHQgIHZhciBldmVudHMgPSBwb3N0U3RhcnRFdmVudHNbIGV2ZW50LnR5cGUgXTtcclxuXHQgIC8vIElFOCBuZWVkcyB0byBiZSBib3VuZCB0byBkb2N1bWVudFxyXG5cdCAgdmFyIG5vZGUgPSBldmVudC5wcmV2ZW50RGVmYXVsdCA/IHdpbmRvdyA6IGRvY3VtZW50O1xyXG5cdCAgLy8gYmluZCBldmVudHMgdG8gbm9kZVxyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgZXZudCA9IGV2ZW50c1tpXTtcclxuXHQgICAgZXZlbnRpZS5iaW5kKCBub2RlLCBldm50LCB0aGlzICk7XHJcblx0ICB9XHJcblx0ICAvLyBzYXZlIHRoZXNlIGFyZ3VtZW50c1xyXG5cdCAgdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzID0ge1xyXG5cdCAgICBldmVudHM6IGV2ZW50cyxcclxuXHQgICAgbm9kZTogbm9kZVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl91bmJpbmRQb3N0U3RhcnRFdmVudHMgPSBmdW5jdGlvbigpIHtcclxuXHQgIHZhciBhcmdzID0gdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzO1xyXG5cdCAgLy8gSUU4IGNhbiB0cmlnZ2VyIGRyYWdFbmQgdHdpY2UsIGNoZWNrIGZvciBfYm91bmRFdmVudHNcclxuXHQgIGlmICggIWFyZ3MgfHwgIWFyZ3MuZXZlbnRzICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBhcmdzLmV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIGV2ZW50ID0gYXJncy5ldmVudHNbaV07XHJcblx0ICAgIGV2ZW50aWUudW5iaW5kKCBhcmdzLm5vZGUsIGV2ZW50LCB0aGlzICk7XHJcblx0ICB9XHJcblx0ICBkZWxldGUgdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbW92ZSBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCBldmVudCApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25NU1BvaW50ZXJNb3ZlID1cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbnBvaW50ZXJtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wb2ludGVySWQgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub250b3VjaG1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB2YXIgdG91Y2ggPSB0aGlzLmdldFRvdWNoKCBldmVudC5jaGFuZ2VkVG91Y2hlcyApO1xyXG5cdCAgaWYgKCB0b3VjaCApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCB0b3VjaCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBtb3ZlXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5fcG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLnBvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gcHVibGljXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJNb3ZlJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbm1vdXNldXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCBldmVudCApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25NU1BvaW50ZXJVcCA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVydXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub250b3VjaGVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XHJcblx0ICBpZiAoIHRvdWNoICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCB0b3VjaCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciB1cFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX3BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb25lKCk7XHJcblx0ICB0aGlzLnBvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHB1YmxpY1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBwb2ludGVyIGRvbmUgLS0tLS0gLy9cclxuXHRcclxuXHQvLyB0cmlnZ2VyZWQgb24gcG9pbnRlciB1cCAmIHBvaW50ZXIgY2FuY2VsXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX3BvaW50ZXJEb25lID0gZnVuY3Rpb24oKSB7XHJcblx0ICAvLyByZXNldCBwcm9wZXJ0aWVzXHJcblx0ICB0aGlzLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcclxuXHQgIGRlbGV0ZSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyO1xyXG5cdCAgLy8gcmVtb3ZlIGV2ZW50c1xyXG5cdCAgdGhpcy5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzKCk7XHJcblx0ICB0aGlzLnBvaW50ZXJEb25lKCk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5wb2ludGVyRG9uZSA9IG5vb3A7XHJcblx0XHJcblx0Ly8gLS0tLS0gcG9pbnRlciBjYW5jZWwgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbk1TUG9pbnRlckNhbmNlbCA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVyY2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wb2ludGVySWQgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIGV2ZW50ICk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbnRvdWNoY2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdmFyIHRvdWNoID0gdGhpcy5nZXRUb3VjaCggZXZlbnQuY2hhbmdlZFRvdWNoZXMgKTtcclxuXHQgIGlmICggdG91Y2ggKSB7XHJcblx0ICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwoIGV2ZW50LCB0b3VjaCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBjYW5jZWxcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl9wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5fcG9pbnRlckRvbmUoKTtcclxuXHQgIHRoaXMucG9pbnRlckNhbmNlbCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHB1YmxpY1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJDYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJDYW5jZWwnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tICAtLS0tLSAvL1xyXG5cdFxyXG5cdC8vIHV0aWxpdHkgZnVuY3Rpb24gZm9yIGdldHRpbmcgeC95IGNvb3JpZGluYXRlcyBmcm9tIGV2ZW50LCBiZWNhdXNlIElFOFxyXG5cdFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50ID0gZnVuY3Rpb24oIHBvaW50ZXIgKSB7XHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB4OiBwb2ludGVyLnBhZ2VYICE9PSB1bmRlZmluZWQgPyBwb2ludGVyLnBhZ2VYIDogcG9pbnRlci5jbGllbnRYLFxyXG5cdCAgICB5OiBwb2ludGVyLnBhZ2VZICE9PSB1bmRlZmluZWQgPyBwb2ludGVyLnBhZ2VZIDogcG9pbnRlci5jbGllbnRZXHJcblx0ICB9O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gIC0tLS0tIC8vXHJcblx0XHJcblx0cmV0dXJuIFVuaXBvaW50ZXI7XHJcblx0XHJcblx0fSkpO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogRXZlbnRFbWl0dGVyIHY0LjIuMTEgLSBnaXQuaW8vZWVcclxuXHQgKiBVbmxpY2Vuc2UgLSBodHRwOi8vdW5saWNlbnNlLm9yZy9cclxuXHQgKiBPbGl2ZXIgQ2FsZHdlbGwgLSBodHRwOi8vb2xpLm1lLnVrL1xyXG5cdCAqIEBwcmVzZXJ2ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdDsoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAndXNlIHN0cmljdCc7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnRzLlxyXG5cdCAgICAgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBjbGFzcyBFdmVudEVtaXR0ZXIgTWFuYWdlcyBldmVudCByZWdpc3RlcmluZyBhbmQgZW1pdHRpbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxyXG5cdFxyXG5cdCAgICAvLyBTaG9ydGN1dHMgdG8gaW1wcm92ZSBzcGVlZCBhbmQgc2l6ZVxyXG5cdCAgICB2YXIgcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xyXG5cdCAgICB2YXIgZXhwb3J0cyA9IHRoaXM7XHJcblx0ICAgIHZhciBvcmlnaW5hbEdsb2JhbFZhbHVlID0gZXhwb3J0cy5FdmVudEVtaXR0ZXI7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgaW4gaXRzIHN0b3JhZ2UgYXJyYXkuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cclxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGxvb2sgZm9yLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIsIC0xIGlmIG5vdCBmb3VuZFxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICB2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XHJcblx0ICAgICAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIC0xO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBhIG1ldGhvZCB3aGlsZSBrZWVwaW5nIHRoZSBjb250ZXh0IGNvcnJlY3QsIHRvIGFsbG93IGZvciBvdmVyd3JpdGluZyBvZiB0YXJnZXQgbWV0aG9kLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IG1ldGhvZC5cclxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBhbGlhc2VkIG1ldGhvZFxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcclxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiBhbGlhc0Nsb3N1cmUoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAgICAgKiBXaWxsIGluaXRpYWxpc2UgdGhlIGV2ZW50IG9iamVjdCBhbmQgbGlzdGVuZXIgYXJyYXlzIGlmIHJlcXVpcmVkLlxyXG5cdCAgICAgKiBXaWxsIHJldHVybiBhbiBvYmplY3QgaWYgeW91IHVzZSBhIHJlZ2V4IHNlYXJjaC4gVGhlIG9iamVjdCBjb250YWlucyBrZXlzIGZvciBlYWNoIG1hdGNoZWQgZXZlbnQuIFNvIC9iYVtyel0vIG1pZ2h0IHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBiYXIgYW5kIGJhei4gQnV0IG9ubHkgaWYgeW91IGhhdmUgZWl0aGVyIGRlZmluZWQgdGhlbSB3aXRoIGRlZmluZUV2ZW50IG9yIGFkZGVkIHNvbWUgbGlzdGVuZXJzIHRvIHRoZW0uXHJcblx0ICAgICAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXHJcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XHJcblx0ICAgICAgICB2YXIgcmVzcG9uc2U7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdFxyXG5cdCAgICAgICAgLy8gUmV0dXJuIGEgY29uY2F0ZW5hdGVkIGFycmF5IG9mIGFsbCBtYXRjaGluZyBldmVudHMgaWZcclxuXHQgICAgICAgIC8vIHRoZSBzZWxlY3RvciBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuXHQgICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuXHQgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xyXG5cdCAgICAgICAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Vba2V5XSA9IGV2ZW50c1trZXldO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgcmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUYWtlcyBhIGxpc3Qgb2YgbGlzdGVuZXIgb2JqZWN0cyBhbmQgZmxhdHRlbnMgaXQgaW50byBhIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBsaXN0ZW5lcnMgUmF3IGxpc3RlbmVyIG9iamVjdHMuXHJcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW119IEp1c3QgdGhlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmZsYXR0ZW5MaXN0ZW5lcnMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuZXJzKGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgdmFyIGZsYXRMaXN0ZW5lcnMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdCAgICAgICAgICAgIGZsYXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIGZsYXRMaXN0ZW5lcnM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBGZXRjaGVzIHRoZSByZXF1ZXN0ZWQgbGlzdGVuZXJzIHZpYSBnZXRMaXN0ZW5lcnMgYnV0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgcmVzdWx0cyBpbnNpZGUgYW4gb2JqZWN0LiBUaGlzIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlIGJ1dCBvdGhlcnMgbWF5IGZpbmQgaXQgdXNlZnVsLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IGluIGFuIG9iamVjdC5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmdldExpc3RlbmVyc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcclxuXHQgICAgICAgIHZhciByZXNwb25zZTtcclxuXHRcclxuXHQgICAgICAgIGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdCAgICAgICAgICAgIHJlc3BvbnNlID0ge307XHJcblx0ICAgICAgICAgICAgcmVzcG9uc2VbZXZ0XSA9IGxpc3RlbmVycztcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiByZXNwb25zZSB8fCBsaXN0ZW5lcnM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgICAgICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxyXG5cdCAgICAgKiBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGl0IGlzIGNhbGxlZC5cclxuXHQgICAgICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUgdGhlbiB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcclxuXHQgICAgICAgIHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdFxyXG5cdCAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpID09PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVySXNXcmFwcGVkID8gbGlzdGVuZXIgOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFsaWFzIG9mIGFkZExpc3RlbmVyXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcclxuXHQgICAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIGl0cyBmaXJzdCBleGVjdXRpb24uXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmFkZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZE9uY2VMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldnQsIHtcclxuXHQgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXHJcblx0ICAgICAgICAgICAgb25jZTogdHJ1ZVxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBvZiBhZGRPbmNlTGlzdGVuZXIuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogRGVmaW5lcyBhbiBldmVudCBuYW1lLiBUaGlzIGlzIHJlcXVpcmVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHJlZ2V4IHRvIGFkZCBhIGxpc3RlbmVyIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBJZiB5b3UgZG9uJ3QgZG8gdGhpcyB0aGVuIGhvdyBkbyB5b3UgZXhwZWN0IGl0IHRvIGtub3cgd2hhdCBldmVudCB0byBhZGQgdG8/IFNob3VsZCBpdCBqdXN0IGFkZCB0byBldmVyeSBwb3NzaWJsZSBtYXRjaCBmb3IgYSByZWdleD8gTm8uIFRoYXQgaXMgc2NhcnkgYW5kIGJhZC5cclxuXHQgICAgICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gY3JlYXRlLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gZGVmaW5lRXZlbnQoZXZ0KSB7XHJcblx0ICAgICAgICB0aGlzLmdldExpc3RlbmVycyhldnQpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBVc2VzIGRlZmluZUV2ZW50IHRvIGRlZmluZSBtdWx0aXBsZSBldmVudHMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGV2dHMgQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGVmaW5lLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmRlZmluZUV2ZW50cyA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50cyhldnRzKSB7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRlZmluZUV2ZW50KGV2dHNbaV0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAgICAgKiBXaGVuIHBhc3NlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSwgaXQgd2lsbCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xyXG5cdCAgICAgICAgdmFyIGluZGV4O1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHRcclxuXHQgICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBvZiByZW1vdmVMaXN0ZW5lclxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ub2ZmID0gYWxpYXMoJ3JlbW92ZUxpc3RlbmVyJyk7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBZGRzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cclxuXHQgICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy4gWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBhZGQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqIFllYWgsIHRoaXMgZnVuY3Rpb24gZG9lcyBxdWl0ZSBhIGJpdC4gVGhhdCdzIHByb2JhYmx5IGEgYmFkIHRoaW5nLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyhmYWxzZSwgZXZ0LCBsaXN0ZW5lcnMpO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogUmVtb3ZlcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXHJcblx0ICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIHJlbW92ZWQuXHJcblx0ICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHJlbW92ZS5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcclxuXHQgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKHRydWUsIGV2dCwgbGlzdGVuZXJzKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEVkaXRzIGxpc3RlbmVycyBpbiBidWxrLiBUaGUgYWRkTGlzdGVuZXJzIGFuZCByZW1vdmVMaXN0ZW5lcnMgbWV0aG9kcyBib3RoIHVzZSB0aGlzIHRvIGRvIHRoZWlyIGpvYi4gWW91IHNob3VsZCByZWFsbHkgdXNlIHRob3NlIGluc3RlYWQsIHRoaXMgaXMgYSBsaXR0bGUgbG93ZXIgbGV2ZWwuXHJcblx0ICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCB3aWxsIGRldGVybWluZSBpZiB0aGUgbGlzdGVuZXJzIGFyZSByZW1vdmVkICh0cnVlKSBvciBhZGRlZCAoZmFsc2UpLlxyXG5cdCAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQvcmVtb3ZlZC5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWFuaXB1bGF0ZSB0aGUgbGlzdGVuZXJzIG9mIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgVHJ1ZSBpZiB5b3Ugd2FudCB0byByZW1vdmUgbGlzdGVuZXJzLCBmYWxzZSBpZiB5b3Ugd2FudCB0byBhZGQuXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC9yZW1vdmUuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIG1hbmlwdWxhdGVMaXN0ZW5lcnMocmVtb3ZlLCBldnQsIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgdmFyIGk7XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICB2YXIgc2luZ2xlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lciA6IHRoaXMuYWRkTGlzdGVuZXI7XHJcblx0ICAgICAgICB2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xyXG5cdFxyXG5cdCAgICAgICAgLy8gSWYgZXZ0IGlzIGFuIG9iamVjdCB0aGVuIHBhc3MgZWFjaCBvZiBpdHMgcHJvcGVydGllcyB0byB0aGlzIG1ldGhvZFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG5cdCAgICAgICAgICAgIGZvciAoaSBpbiBldnQpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAodmFsdWUgPSBldnRbaV0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHBhc3MgYmFjayB0byB0aGUgbXVsdGlwbGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXHJcblx0ICAgICAgICAgICAgLy8gQW5kIGxpc3RlbmVycyBtdXN0IGJlIGFuIGFycmF5IG9mIGxpc3RlbmVyc1xyXG5cdCAgICAgICAgICAgIC8vIExvb3Agb3ZlciBpdCBhbmQgcGFzcyBlYWNoIG9uZSB0byB0aGUgbXVsdGlwbGUgbWV0aG9kXHJcblx0ICAgICAgICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG5cdCAgICAgICAgICAgICAgICBzaW5nbGUuY2FsbCh0aGlzLCBldnQsIGxpc3RlbmVyc1tpXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSBhIHNwZWNpZmllZCBldmVudC5cclxuXHQgICAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGFuIGV2ZW50IHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICAgICAqIFRoYXQgbWVhbnMgZXZlcnkgZXZlbnQgd2lsbCBiZSBlbXB0aWVkLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ2V4IHRvIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gW2V2dF0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLiBXaWxsIHJlbW92ZSBmcm9tIGV2ZXJ5IGV2ZW50IGlmIG5vdCBwYXNzZWQuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChldnQpIHtcclxuXHQgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGV2dDtcclxuXHQgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0XHJcblx0ICAgICAgICAvLyBSZW1vdmUgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIGV2dFxyXG5cdCAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcclxuXHQgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2V2dF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgcmVnZXguXHJcblx0ICAgICAgICAgICAgZm9yIChrZXkgaW4gZXZlbnRzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2tleV07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBhbGwgZXZlbnRzXHJcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBhbGlhcygncmVtb3ZlRXZlbnQnKTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEVtaXRzIGFuIGV2ZW50IG9mIHlvdXIgY2hvaWNlLlxyXG5cdCAgICAgKiBXaGVuIGVtaXR0ZWQsIGV2ZXJ5IGxpc3RlbmVyIGF0dGFjaGVkIHRvIHRoYXQgZXZlbnQgd2lsbCBiZSBleGVjdXRlZC5cclxuXHQgICAgICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxyXG5cdCAgICAgKiBCZWNhdXNlIGl0IHVzZXMgYGFwcGx5YCwgeW91ciBhcnJheSBvZiBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgaWYgeW91IHdyb3RlIHRoZW0gb3V0IHNlcGFyYXRlbHkuXHJcblx0ICAgICAqIFNvIHRoZXkgd2lsbCBub3QgYXJyaXZlIHdpdGhpbiB0aGUgYXJyYXkgb24gdGhlIG90aGVyIHNpZGUsIHRoZXkgd2lsbCBiZSBzZXBhcmF0ZS5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cclxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVyO1xyXG5cdCAgICAgICAgdmFyIGk7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgdmFyIHJlc3BvbnNlO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGkgPSBsaXN0ZW5lcnNba2V5XS5sZW5ndGg7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCBzaGFsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2tleV1baV07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25jZSA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGxpc3RlbmVyLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFsaWFzIG9mIGVtaXRFdmVudFxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8udHJpZ2dlciA9IGFsaWFzKCdlbWl0RXZlbnQnKTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cclxuXHQgICAgICogQXMgd2l0aCBlbWl0RXZlbnQsIHlvdSBjYW4gcGFzcyBhIHJlZ2V4IGluIHBsYWNlIG9mIHRoZSBldmVudCBuYW1lIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXHJcblx0ICAgICAqIEBwYXJhbSB7Li4uKn0gT3B0aW9uYWwgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmIGFcclxuXHQgICAgICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcclxuXHQgICAgICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLnNldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIHNldE9uY2VSZXR1cm5WYWx1ZSh2YWx1ZSkge1xyXG5cdCAgICAgICAgdGhpcy5fb25jZVJldHVyblZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEZldGNoZXMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmXHJcblx0ICAgICAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxyXG5cdCAgICAgKiBhdXRvbWF0aWNhbGx5LiBJdCB3aWxsIHJldHVybiB0cnVlIGJ5IGRlZmF1bHQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLl9nZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBfZ2V0T25jZVJldHVyblZhbHVlKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ19vbmNlUmV0dXJuVmFsdWUnKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmNlUmV0dXJuVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEZldGNoZXMgdGhlIGV2ZW50cyBvYmplY3QgYW5kIGNyZWF0ZXMgb25lIGlmIHJlcXVpcmVkLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXHJcblx0ICAgICAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZXZlcnRzIHRoZSBnbG9iYWwge0BsaW5rIEV2ZW50RW1pdHRlcn0gdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmVyc2lvbi5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259IE5vbiBjb25mbGljdGluZyBFdmVudEVtaXR0ZXIgY2xhc3MuXHJcblx0ICAgICAqL1xyXG5cdCAgICBFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XHJcblx0ICAgICAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IG9yaWdpbmFsR2xvYmFsVmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvLyBFeHBvc2UgdGhlIGNsYXNzIGVpdGhlciB2aWEgQU1ELCBDb21tb25KUyBvciB0aGUgZ2xvYmFsIG9iamVjdFxyXG5cdCAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0ICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyl7XHJcblx0ICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIHtcclxuXHQgICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xyXG5cdCAgICB9XHJcblx0fS5jYWxsKHRoaXMpKTtcclxuXHRcclxuXHR9LmNhbGwod2luZG93KSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1zbGlkZXJcXFwiIDppZD1cXFwiaWRcXFwiXFxuICAgIDpjbGFzcz1cXFwie1xcbiAgICAgICAgbWluOiB2YWx1ZSA9PT0gMCwgbWF4OiB2YWx1ZSA9PT0gMTAwLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRpc2FibGVkOiBkaXNhYmxlZCxcXG4gICAgICAgIGFjdGl2ZTogYWN0aXZlLCAnaGFzLWxhYmVsJzogaGFzTGFiZWxcXG4gICAgfVxcXCJcXG5cXG4gICAgOnRhYmluZGV4PVxcXCJkaXNhYmxlZCA/IG51bGwgOiAwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIlxcbiAgICA6YXJpYS12YWx1ZW5vdz1cXFwidmFsdWVcXFwiXFxuXFxuICAgIEBrZXlkb3duLmxlZnQucHJldmVudD1cXFwiZGVjcmVtZW50XFxcIiBAa2V5ZG93bi5yaWdodC5wcmV2ZW50PVxcXCJpbmNyZW1lbnRcXFwiXFxuICAgIEBrZXlkb3duLmRvd24ucHJldmVudD1cXFwiZGVjcmVtZW50XFxcIiBAa2V5ZG93bi51cC5wcmV2ZW50PVxcXCJpbmNyZW1lbnRcXFwiXFxuICAgIEBmb2N1cz1cXFwiZm9jdXNcXFwiIEBibHVyPVxcXCJibHVyXFxcIlxcbj5cXG4gICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgOnZhbHVlPVxcXCJ2YWx1ZVxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItaWNvbi13cmFwcGVyXFxcIiB2LWlmPVxcXCJzaG93SWNvblxcXCI+XFxuICAgICAgICA8dWktaWNvbiA6aWNvbj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInVpLXNsaWRlci1pY29uXFxcIj48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItbGFiZWxcXFwiIHYtdGV4dD1cXFwibGFiZWxcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXdyYXBwZXJcXFwiIHYtZWw6c2xpZGVyIEBtb3VzZWRvd249XFxcInNsaWRlckNsaWNrXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItY29udGFpbm1lbnRcXFwiIHYtZWw6Y29udGFpbm1lbnQ+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXRyYWNrXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXRyYWNrLWZpbGxcXFwiIDpzdHlsZT1cXFwieyB3aWR0aDogdmFsdWUgKyAnJSd9XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItdGh1bWItY29udGFpbmVyXFxcIiB2LWVsOnRodW1iPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItZm9jdXMtcmluZ1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNsaWRlci10aHVtYlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTg1KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODYpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTbmFja2Jhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NylcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVNuYWNrYmFyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlCdXR0b24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc25hY2tiYXInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1lc3NhZ2U6IFN0cmluZyxcclxuXHQgICAgICAgIGFjdGlvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgYWN0aW9uQ29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2FjY2VudCcgfSxcclxuXHQgICAgICAgIHBlcnNpc3RlbnQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHVyYXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogNTAwMFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGF1dG9IaWRlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGhlaWdodDogMCxcclxuXHQgICAgICAgICAgICB0aW1lb3V0OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xyXG5cdCAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWNrZWQnKTtcclxuXHQgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhY3Rpb25DbGljazogZnVuY3Rpb24gYWN0aW9uQ2xpY2soKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FjdGlvbi1jbGlja2VkJyk7XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMucGVyc2lzdGVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpQnV0dG9uOiBfVWlCdXR0b24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgdHJhbnNpdGlvbnM6IHtcclxuXHQgICAgICAgICd1aS1zbmFja2Jhci10b2dnbGUnOiB7XHJcblx0ICAgICAgICAgICAgYWZ0ZXJFbnRlcjogZnVuY3Rpb24gYWZ0ZXJFbnRlcigpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3duJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9IaWRlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZSwgdGhpcy5kdXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGFmdGVyTGVhdmU6IGZ1bmN0aW9uIGFmdGVyTGVhdmUoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdoaWRkZW4nKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXNuYWNrYmFyXFxcIiA6aWQ9XFxcImlkXFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1zbmFja2Jhci10b2dnbGVcXFwiIEBjbGljaz1cXFwiY2xpY2tcXFwiIHYtc2hvdz1cXFwic2hvd1xcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXNuYWNrYmFyLXRleHRcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJtZXNzYWdlXFxcIj48L3NwYW4+XFxuICAgICAgICA8L3Nsb3Q+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbmFja2Jhci1hY3Rpb25cXFwiPlxcbiAgICAgICAgPHVpLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zbmFja2Jhci1hY3Rpb24tYnV0dG9uXFxcIiB0eXBlPVxcXCJmbGF0XFxcIiA6Y29sb3I9XFxcImFjdGlvbkNvbG9yXFxcIlxcbiAgICAgICAgICAgIDp0ZXh0PVxcXCJhY3Rpb25cXFwiIEBjbGljay5zdG9wPVxcXCJhY3Rpb25DbGlja1xcXCIgdi1pZj1cXFwiYWN0aW9uXFxcIlxcbiAgICAgICAgPjwvdWktYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxODkpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MClcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVNuYWNrYmFyQ29udGFpbmVyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU25hY2tiYXJDb250YWluZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG5cdFxyXG5cdHZhciBfdXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dWlkKTtcclxuXHRcclxuXHR2YXIgX1VpU25hY2tiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NCk7XHJcblx0XHJcblx0dmFyIF9VaVNuYWNrYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU25hY2tiYXIpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc25hY2tiYXItY29udGFpbmVyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHF1ZXVlU25hY2tiYXJzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlZmF1bHREdXJhdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiA1MDAwXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcG9zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2xlZnQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShwb3NpdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3Bvc2l0aW9uLScgKyBwb3NpdGlvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLXNuYWNrYmFyOjpjcmVhdGUnOiBmdW5jdGlvbiB1aVNuYWNrYmFyQ3JlYXRlKHNuYWNrYmFyKSB7XHJcblx0ICAgICAgICAgICAgc25hY2tiYXIuc2hvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHNuYWNrYmFyLmlkID0gc25hY2tiYXIuaWQgfHwgX3V1aWQyLmRlZmF1bHQuc2hvcnQoJ3VpLXNuYWNrYmFyLScpO1xyXG5cdCAgICAgICAgICAgIHNuYWNrYmFyLmR1cmF0aW9uID0gc25hY2tiYXIuZHVyYXRpb24gfHwgdGhpcy5kZWZhdWx0RHVyYXRpb247XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHNuYWNrYmFyKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93TmV4dCgpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5xdWV1ZVNuYWNrYmFycykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVswXS5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHF1ZXVlOiBbXSB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBzaG93TmV4dDogZnVuY3Rpb24gc2hvd05leHQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucXVldWVbMF0uc2hvdyA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd246IGZ1bmN0aW9uIHNob3duKHNuYWNrYmFyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3NuYWNrYmFyLXNob3duJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY2FsbEhvb2soJ29uU2hvdycsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRkZW46IGZ1bmN0aW9uIGhpZGRlbihzbmFja2Jhcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzbmFja2Jhci1oaWRkZW4nLCBzbmFja2Jhcik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jYWxsSG9vaygnb25IaWRlJywgc25hY2tiYXIpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucXVldWUuJHJlbW92ZShzbmFja2Jhcik7XHJcblx0ICAgICAgICAgICAgdGhpcy5zaG93TmV4dCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsaWNrZWQ6IGZ1bmN0aW9uIGNsaWNrZWQoc25hY2tiYXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNhbGxIb29rKCdvbkNsaWNrJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGFjdGlvbkNsaWNrZWQ6IGZ1bmN0aW9uIGFjdGlvbkNsaWNrZWQoc25hY2tiYXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNhbGxIb29rKCdvbkFjdGlvbkNsaWNrJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNhbGxIb29rOiBmdW5jdGlvbiBjYWxsSG9vayhob29rLCBzbmFja2Jhcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygc25hY2tiYXJbaG9va10gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgc25hY2tiYXJbaG9va10uY2FsbCh1bmRlZmluZWQsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpU25hY2tiYXI6IF9VaVNuYWNrYmFyMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTkxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktc25hY2tiYXItY29udGFpbmVyXFxcIiA6Y2xhc3M9XFxcIltwb3NpdGlvbl1cXFwiPlxcbiAgICA8dWktc25hY2tiYXJcXG4gICAgICAgIDpkdXJhdGlvbj1cXFwicy5kdXJhdGlvblxcXCIgOnNob3cuc3luYz1cXFwicy5zaG93XFxcIiA6YWN0aW9uPVxcXCJzLmFjdGlvblxcXCJcXG4gICAgICAgIDphY3Rpb24tY29sb3I9XFxcInMuYWN0aW9uQ29sb3JcXFwiIDpwZXJzaXN0ZW50PVxcXCJzLnBlcnNpc3RlbnRcXFwiIDppZD1cXFwicy5pZFxcXCIgYXV0by1oaWRlXFxuXFxuICAgICAgICBAc2hvd249XFxcInNob3duKHMpXFxcIiBAaGlkZGVuPVxcXCJoaWRkZW4ocylcXFwiIEBjbGlja2VkPVxcXCJjbGlja2VkKHMpXFxcIlxcbiAgICAgICAgQGFjdGlvbi1jbGlja2VkPVxcXCJhY3Rpb25DbGlja2VkKHMpXFxcIlxcblxcbiAgICAgICAgdi1mb3I9XFxcInMgaW4gcXVldWVcXFwiXFxuICAgID5cXG4gICAgICAgIDxkaXYgdi1odG1sPVxcXCJzLm1lc3NhZ2VcXFwiIHYtaWY9XFxcInMuYWxsb3dIdG1sXFxcIj48L2Rpdj5cXG4gICAgICAgIDxzcGFuIHYtdGV4dD1cXFwicy5tZXNzYWdlXFxcIiB2LWVsc2U+PC9zcGFuPlxcbiAgICA8L3VpLXNuYWNrYmFyPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTkyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk0KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU3dpdGNoLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk1KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU3dpdGNoLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc3dpdGNoJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG5hbWU6IFN0cmluZyxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsTGVmdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTk1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGxhYmVsXFxuICAgIGNsYXNzPVxcXCJ1aS1zd2l0Y2hcXFwiXFxuICAgIDpjbGFzcz1cXFwieyAnY2hlY2tlZCc6IHZhbHVlLCAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2xhYmVsLWxlZnQnOiBsYWJlbExlZnQgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXN3aXRjaC1jb250YWluZXJcXFwiPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXN3aXRjaC1pbnB1dFxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIiA6aWQ9XFxcImlkXFxcIiB2LW1vZGVsPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgID5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXN3aXRjaC10cmFja1xcXCI+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zd2l0Y2gtdGh1bWJcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc3dpdGNoLWZvY3VzLXJpbmdcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc3dpdGNoLWxhYmVsLXRleHRcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJsYWJlbFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9zbG90PlxcbiAgICA8L2Rpdj5cXG48L2xhYmVsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTk2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE5NylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk4KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVGFiLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk5KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVGFiLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10YWInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIGhlYWRlcjogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZSgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy4kcGFyZW50LmFjdGl2ZVRhYiA9PT0gdGhpcy5pZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2VsZWN0ZWQnLCB0aGlzLmlkKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGVzZWxlY3RlZCcsIHRoaXMuaWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS10YWJcXFwiIDppZD1cXFwiaWRcXFwiIHJvbGU9XFxcInRhYnBhbmVsXFxcIiA6dGFiaW5kZXg9XFxcImFjdGl2ZSA/ICcwJyA6IG51bGxcXFwiXFxuICAgIDphcmlhLWhpZGRlbj1cXFwiIWFjdGl2ZSA/ICd0cnVlJyA6IG51bGxcXFwiIHYtc2hvdz1cXFwiYWN0aXZlXFxcIlxcbj5cXG4gICAgPHNsb3Q+PC9zbG90PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjAwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjAyKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVGFicy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNylcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRhYnMudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG5cdFxyXG5cdHZhciBfdXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dWlkKTtcclxuXHRcclxuXHR2YXIgX1VpVGFiSGVhZGVySXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMjAzKTtcclxuXHRcclxuXHR2YXIgX1VpVGFiSGVhZGVySXRlbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRhYkhlYWRlckl0ZW0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10YWJzJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnIH0sXHJcblx0ICAgICAgICBhY3RpdmVUYWI6IFN0cmluZyxcclxuXHQgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnYmFja2dyb3VuZC1jb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRleHRDb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnYmxhY2snLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQtY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0ZXh0Q29sb3JBY3RpdmU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQtY29sb3ItYWN0aXZlLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaW5kaWNhdG9yQ29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZnVsbHdpZHRoOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJhaXNlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlUmlwcGxlSW5rOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmVUYWJFbGVtZW50OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc3R5bGVDbGFzc2VzOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ3VpLXRhYnMtdHlwZS0nICsgdGhpcy50eXBlXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5yYWlzZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdyYWlzZWQnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZnVsbHdpZHRoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZnVsbHdpZHRoJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGluZGljYXRvckxlZnQ6IGZ1bmN0aW9uIGluZGljYXRvckxlZnQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUYWJFbGVtZW50Lm9mZnNldExlZnQgKyAncHgnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gMDtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmRpY2F0b3JSaWdodDogZnVuY3Rpb24gaW5kaWNhdG9yUmlnaHQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuYWN0aXZlVGFiRWxlbWVudC5vZmZzZXRMZWZ0O1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0YWJDb250YWluZXJXaWR0aCA9IHRoaXMuJGVscy50YWJzQ29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGFiQ29udGFpbmVyV2lkdGggLSAobGVmdCArIHdpZHRoKSArICdweCc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuW2ldLmlkID0gdGhpcy4kY2hpbGRyZW5baV0uaWQgfHwgX3V1aWQyLmRlZmF1bHQuc2hvcnQoJ3VpLXRhYi0nKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuYWN0aXZlVGFiID0gdGhpcy5hY3RpdmVUYWIgfHwgdGhpcy4kY2hpbGRyZW5bMF0uaWQ7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKF90aGlzLiRlbHMudGFic0NvbnRhaW5lcikge1xyXG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVUYWJFbGVtZW50ID0gX3RoaXMuJGVscy50YWJzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktdGFiczo6c2VsZWN0JzogZnVuY3Rpb24gdWlUYWJzU2VsZWN0KHRhYklkLCBpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIHRhYiA9IHRoaXMuZmluZFRhYkJ5SWQodGFiSWQpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0YWIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodGFiLiRlbCwgdGFiKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGUsIHRhYikge1xyXG5cdCAgICAgICAgICAgIHZhciBuZXdUYWJFbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0IDogZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGFiLmRpc2FibGVkIHx8IHRoaXMuYWN0aXZlVGFiRWxlbWVudCA9PT0gbmV3VGFiRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiRWxlbWVudCA9IG5ld1RhYkVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWIgPSB0YWIuaWQ7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FjdGl2ZS10YWItY2hhbmdlZCcsIHRhYi5pZCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0UHJldjogZnVuY3Rpb24gc2VsZWN0UHJldihjdXJyZW50VGFiSW5kZXgpIHtcclxuXHQgICAgICAgICAgICBpZiAoY3VycmVudFRhYkluZGV4ID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZUYWIgPSB0aGlzLmZpbmRUYWIoY3VycmVudFRhYkluZGV4KTtcclxuXHQgICAgICAgICAgICB0aGlzLnNlbGVjdChwcmV2VGFiLiRlbCwgcHJldlRhYik7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJFbGVtZW50LmZvY3VzKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0TmV4dDogZnVuY3Rpb24gc2VsZWN0TmV4dChjdXJyZW50VGFiSW5kZXgpIHtcclxuXHQgICAgICAgICAgICBpZiAoY3VycmVudFRhYkluZGV4ID09PSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzLmxlbmd0aCAtIDEpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgbmV4dFRhYiA9IHRoaXMuZmluZFRhYihjdXJyZW50VGFiSW5kZXgsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2VsZWN0KG5leHRUYWIuJGVsLCBuZXh0VGFiKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQuZm9jdXMoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmaW5kVGFiOiBmdW5jdGlvbiBmaW5kVGFiKGN1cnJlbnRUYWJJbmRleCwgbmV4dCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0YWIgPSB2b2lkIDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRUYWJJbmRleCArIDE7IGkgPCB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMudGFiRWxlbWVudHNbaV0uZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWIgPSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSBjdXJyZW50VGFiSW5kZXggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMudGFiRWxlbWVudHNbX2ldLmRpc2FibGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFiID0gdGhpcy4kcmVmcy50YWJFbGVtZW50c1tfaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGFiID0gdGFiIHx8IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbY3VycmVudFRhYkluZGV4XTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGFiO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZpbmRUYWJCeUlkOiBmdW5jdGlvbiBmaW5kVGFiQnlJZChpZCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0YWIgPSBudWxsO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBudW1PZlRhYnMgPSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzLmxlbmd0aDtcclxuXHRcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBudW1PZlRhYnM7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoaWQgPT09IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbaV0uaWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhYiA9IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGFiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVRhYkhlYWRlckl0ZW06IF9VaVRhYkhlYWRlckl0ZW0yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjA0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDUpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUYWJIZWFkZXJJdGVtLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVGFiSGVhZGVySXRlbS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjA0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjA1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXRhYi1oZWFkZXItaXRlbScsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nLFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndGV4dCcgfSxcclxuXHQgICAgICAgIHRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGFjdGl2ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1JpcHBsZUluazIuZGVmYXVsdF0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGlcXG4gICAgY2xhc3M9XFxcInVpLXRhYi1oZWFkZXItaXRlbVxcXCIgcm9sZT1cXFwidGFiXFxcIlxcbiAgICA6Y2xhc3M9XFxcIlsndHlwZS0nICsgdHlwZSwgeyAnYWN0aXZlJzogYWN0aXZlLCAnZGlzYWJsZWQnOiBkaXNhYmxlZCB9XVxcXCJcXG5cXG4gICAgOnRhYmluZGV4PVxcXCJhY3RpdmUgPyAwIDogLTFcXFwiIDphcmlhLWNvbnRyb2xzPVxcXCJpZFxcXCIgOmFyaWEtc2VsZWN0ZWQ9XFxcImFjdGl2ZSA/ICd0cnVlJyA6IG51bGxcXFwiXFxuICAgIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB2LWVsOml0ZW1cXG4+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS10YWItaGVhZGVyLWl0ZW0taWNvblxcXCIgdi1pZj1cXFwidHlwZSA9PT0gJ2ljb24nIHx8IHR5cGUgPT09ICdpY29uLWFuZC10ZXh0J1xcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiPjwvdWktaWNvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS10YWItaGVhZGVyLWl0ZW0tdGV4dFxcXCIgdi10ZXh0PVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgdi1pZj1cXFwidHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdpY29uLWFuZC10ZXh0J1xcXCJcXG4gICAgPjwvZGl2PlxcblxcbiAgICA8dWktcmlwcGxlLWluayA6dHJpZ2dlcj1cXFwiJGVscy5pdGVtXFxcIiB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiPjwvdWktcmlwcGxlLWluaz5cXG48L2xpPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjA3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktdGFic1xcXCIgOmNsYXNzPVxcXCJzdHlsZUNsYXNzZXNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10YWJzLWhlYWRlclxcXCIgOmNsYXNzPVxcXCJbYmFja2dyb3VuZENvbG9yXVxcXCI+XFxuICAgICAgICA8dWxcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktdGFicy1oZWFkZXItaXRlbXNcXFwiIDpjbGFzcz1cXFwiW3RleHRDb2xvciwgdGV4dENvbG9yQWN0aXZlXVxcXCIgcm9sZT1cXFwidGFibGlzdFxcXCJcXG4gICAgICAgICAgICB2LWVsOnRhYnMtY29udGFpbmVyXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPHVpLXRhYi1oZWFkZXItaXRlbVxcbiAgICAgICAgICAgICAgICA6dHlwZT1cXFwidHlwZVxcXCIgOmlkPVxcXCJ0YWIuaWRcXFwiIDppY29uPVxcXCJ0YWIuaWNvblxcXCIgOnRleHQ9XFxcInRhYi5oZWFkZXJcXFwiXFxuICAgICAgICAgICAgICAgIDphY3RpdmU9XFxcImFjdGl2ZVRhYiA9PT0gdGFiLmlkXFxcIiA6ZGlzYWJsZWQ9XFxcInRhYi5kaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgOmhpZGUtcmlwcGxlLWluaz1cXFwiaGlkZVJpcHBsZUlua1xcXCJcXG5cXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJzZWxlY3QoJGV2ZW50LCB0YWIpXFxcIiBAa2V5ZG93bi5sZWZ0PVxcXCJzZWxlY3RQcmV2KGluZGV4KVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24ucmlnaHQ9XFxcInNlbGVjdE5leHQoJGluZGV4KVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgdi1mb3I9XFxcIihpbmRleCwgdGFiKSBpbiAkY2hpbGRyZW5cXFwiIHYtcmVmOnRhYi1lbGVtZW50c1xcbiAgICAgICAgICAgID48L3VpLXRhYi1oZWFkZXItaXRlbT5cXG4gICAgICAgIDwvdWw+XFxuXFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRhYnMtYWN0aXZlLXRhYi1pbmRpY2F0b3JcXFwiIDpjbGFzcz1cXFwiW2luZGljYXRvckNvbG9yXVxcXCJcXG4gICAgICAgICAgICA6c3R5bGU9XFxcInsgJ2xlZnQnOiBpbmRpY2F0b3JMZWZ0LCAncmlnaHQnOiBpbmRpY2F0b3JSaWdodCB9XFxcIlxcbiAgICAgICAgPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktdGFicy1ib2R5XFxcIj5cXG4gICAgICAgIDxzbG90Pjwvc2xvdD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjA5KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTApXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUZXh0Ym94LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjExKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVGV4dGJveC52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjA5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjEwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9hdXRvZm9jdXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcclxuXHRcclxuXHR2YXIgX2F1dG9mb2N1czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hdXRvZm9jdXMpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XHJcblx0XHJcblx0dmFyIF9IYXNUZXh0SW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGFzVGV4dElucHV0KTtcclxuXHRcclxuXHR2YXIgX1ZhbGlkYXRlc0lucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WYWxpZGF0ZXNJbnB1dCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10ZXh0Ym94JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbXVsdGlMaW5lOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJvd3M6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMlxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1heExlbmd0aDogTnVtYmVyLFxyXG5cdCAgICAgICAgdHJpbVZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdmFsaWRhdGVPbkJsdXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYXV0b2NvbXBsZXRlOiBTdHJpbmcsXHJcblx0ICAgICAgICBhdXRvZm9jdXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbWluOiBOdW1iZXIsXHJcblx0ICAgICAgICBtYXg6IE51bWJlcixcclxuXHQgICAgICAgIHN0ZXA6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2FueScsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBTdHJpbmdcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5pZ25vcmVWYWx1ZUNoYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlT25CbHVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGlnbm9yZVZhbHVlQ2hhbmdlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHNob3dJY29uOiBmdW5jdGlvbiBzaG93SWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmljb24pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1pblZhbHVlOiBmdW5jdGlvbiBtaW5WYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWluIHx8IHRoaXMubWluID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbWF4VmFsdWU6IGZ1bmN0aW9uIG1heFZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXggfHwgdGhpcy5tYXggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdGVwVmFsdWU6IGZ1bmN0aW9uIHN0ZXBWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaWdub3JlVmFsdWVDaGFuZ2UgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJykpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yID0gJyc7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzLmlnbm9yZVZhbHVlQ2hhbmdlID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGZvY3Vzc2VkOiBmdW5jdGlvbiBmb2N1c3NlZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2ZvY3Vzc2VkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cnJlZDogZnVuY3Rpb24gYmx1cnJlZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2JsdXJyZWQnKTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2hhbmdlZDogZnVuY3Rpb24gY2hhbmdlZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2hhbmdlZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdrZXlkb3duJywgZSk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAga2V5ZG93bkVudGVyOiBmdW5jdGlvbiBrZXlkb3duRW50ZXIoZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdrZXlkb3duLWVudGVyJywgZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGZpbHRlcnM6IHtcclxuXHQgICAgICAgIHRyaW06IHtcclxuXHQgICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ251bWJlcicgJiYgdGhpcy50cmltVmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGF1dG9mb2N1czogX2F1dG9mb2N1czIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfSGFzVGV4dElucHV0Mi5kZWZhdWx0LCBfVmFsaWRhdGVzSW5wdXQyLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXRleHRib3hcXFwiXFxuICAgIDpjbGFzcz1cXFwie1xcbiAgICAgICAgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdpbnZhbGlkJzogIXZhbGlkLCAnZGlydHknOiBkaXJ0eSwgJ2FjdGl2ZSc6IGFjdGl2ZSxcXG4gICAgICAgICdoYXMtbGFiZWwnOiAhaGlkZUxhYmVsLCAnaXMtbXVsdGktbGluZSc6IG11bHRpTGluZSwgJ2ljb24tcmlnaHQnOiBpY29uUmlnaHQsXFxuICAgICAgICAnaGFzLWNvdW50ZXInOiBtYXhMZW5ndGhcXG4gICAgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRleHRib3gtaWNvbi13cmFwcGVyXFxcIiB2LWlmPVxcXCJzaG93SWNvblxcXCI+XFxuICAgICAgICA8dWktaWNvbiA6aWNvbj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInVpLXRleHRib3gtaWNvblxcXCI+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktdGV4dGJveC1jb250ZW50XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidWktdGV4dGJveC1sYWJlbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdGV4dGJveC1sYWJlbC10ZXh0XFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtaW5wdXRcXFwiIDp0eXBlPVxcXCJ0eXBlXFxcIiA6cGxhY2Vob2xkZXI9XFxcInBsYWNlaG9sZGVyXFxcIiA6bmFtZT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgOmlkPVxcXCJpZFxcXCIgOm51bWJlcj1cXFwidHlwZSA9PT0gJ251bWJlcicgPyB0cnVlIDogbnVsbFxcXCIgOm1pbj1cXFwibWluVmFsdWVcXFwiXFxuICAgICAgICAgICAgICAgIDptYXg9XFxcIm1heFZhbHVlXFxcIiA6c3RlcD1cXFwic3RlcFZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgICA6YXV0b2NvbXBsZXRlPVxcXCJhdXRvY29tcGxldGUgPyBhdXRvY29tcGxldGUgOiBudWxsXFxcIlxcblxcbiAgICAgICAgICAgICAgICBAZm9jdXM9XFxcImZvY3Vzc2VkXFxcIiBAYmx1cj1cXFwiYmx1cnJlZFxcXCIgQGNoYW5nZT1cXFwiY2hhbmdlZFxcXCIgQGtleWRvd249XFxcImtleWRvd25cXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVudGVyPVxcXCJrZXlkb3duRW50ZXJcXFwiIDpkZWJvdW5jZT1cXFwiZGVib3VuY2VcXFwiXFxuXFxuICAgICAgICAgICAgICAgIHYtbW9kZWw9XFxcInZhbHVlIHwgdHJpbVxcXCIgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHYtaWY9XFxcIiFtdWx0aUxpbmVcXFwiXFxuICAgICAgICAgICAgICAgIHYtYXV0b2ZvY3VzPVxcXCJhdXRvZm9jdXNcXFwiXFxuICAgICAgICAgICAgPlxcblxcbiAgICAgICAgICAgIDx0ZXh0YXJlYVxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktdGV4dGJveC10ZXh0YXJlYVxcXCIgOnBsYWNlaG9sZGVyPVxcXCJwbGFjZWhvbGRlclxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiIDppZD1cXFwiaWRcXFwiXFxuICAgICAgICAgICAgICAgIDpyb3dzPVxcXCJyb3dzXFxcIlxcblxcbiAgICAgICAgICAgICAgICBAZm9jdXM9XFxcImZvY3Vzc2VkXFxcIiBAYmx1cj1cXFwiYmx1cnJlZFxcXCIgQGNoYW5nZT1cXFwiY2hhbmdlZFxcXCIgQGtleWRvd249XFxcImtleWRvd25cXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVudGVyPVxcXCJrZXlkb3duRW50ZXJcXFwiIDpkZWJvdW5jZT1cXFwiZGVib3VuY2VcXFwiXFxuXFxuICAgICAgICAgICAgICAgIHYtbW9kZWw9XFxcInZhbHVlIHwgdHJpbVxcXCIgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHYtZWxzZVxcbiAgICAgICAgICAgID48L3RleHRhcmVhPlxcbiAgICAgICAgPC9sYWJlbD5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRleHRib3gtZmVlZGJhY2tcXFwiIHYtaWY9XFxcInNob3dGZWVkYmFjayB8fCBtYXhMZW5ndGhcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtZXJyb3ItdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktdGV4dGJveC1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwidmFsaWRhdGlvbkVycm9yXFxcIiB2LXNob3c9XFxcIiFoaWRlVmFsaWRhdGlvbkVycm9ycyAmJiAhdmFsaWRcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtaGVscC10ZXh0XFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS10ZXh0Ym94LWZlZWRiYWNrLXRvZ2dsZVxcXCJcXG4gICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCIgdi1lbHNlXFxuICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtY291bnRlclxcXCIgdi10ZXh0PVxcXCJ2YWx1ZS5sZW5ndGggKyAnLycgKyBtYXhMZW5ndGhcXFwiXFxuICAgICAgICAgICAgICAgIHYtaWY9XFxcIm1heExlbmd0aFxcXCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMTIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjEzKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUb29sYmFyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjE1KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVG9vbGJhci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjEzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjE0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzTGluZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0xpbmVhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVByb2dyZXNzTGluZWFyKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10b29sYmFyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndWktdG9vbGJhci0nICsgdHlwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGV4dENvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdibGFjaycsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndGV4dC1jb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRpdGxlOiBTdHJpbmcsXHJcblx0ICAgICAgICBicmFuZDogU3RyaW5nLFxyXG5cdCAgICAgICAgc2hvd0JyYW5kOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dCcmFuZERpdmlkZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBuYXZJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdtZW51J1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhpZGVOYXZJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZsYXQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcHJlbG9hZGVyVG9wOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxvYWRpbmc6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzdHlsZUNsYXNzZXM6IGZ1bmN0aW9uIHN0eWxlQ2xhc3NlcygpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFt0aGlzLnR5cGUsIHRoaXMudGV4dENvbG9yXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZmxhdCkge1xyXG5cdCAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ3VpLXRvb2xiYXItcmFpc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb25Db2xvcjogZnVuY3Rpb24gaWNvbkNvbG9yKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnRleHRDb2xvciA9PT0gJ3RleHQtY29sb3ItYmxhY2snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnYmxhY2snO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gJ3doaXRlJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwcmVsb2FkZXJDb2xvcjogZnVuY3Rpb24gcHJlbG9hZGVyQ29sb3IoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudGV4dENvbG9yID09PSAndGV4dC1jb2xvci1ibGFjaycpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdwcmltYXJ5JztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICd3aGl0ZSc7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYnJhbmREaXZpZGVyVmlzaWJsZTogZnVuY3Rpb24gYnJhbmREaXZpZGVyVmlzaWJsZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93QnJhbmREaXZpZGVyICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dCcmFuZERpdmlkZXI7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zaG93QnJhbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgbmF2SWNvbkNsaWNrOiBmdW5jdGlvbiBuYXZJY29uQ2xpY2soKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ25hdi1pY29uLWNsaWNrZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlQcm9ncmVzc0xpbmVhcjogX1VpUHJvZ3Jlc3NMaW5lYXIyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaUljb25CdXR0b246IF9VaUljb25CdXR0b24yLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyXFxcIiA6Y2xhc3M9XFxcInN0eWxlQ2xhc3Nlc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItbGVmdFxcXCI+XFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktdG9vbGJhci1uYXYtaWNvblxcXCIgdHlwZT1cXFwiY2xlYXJcXFwiIDpjb2xvcj1cXFwiaWNvbkNvbG9yXFxcIiA6aWNvbj1cXFwibmF2SWNvblxcXCJcXG4gICAgICAgICAgICBAY2xpY2s9XFxcIm5hdkljb25DbGlja1xcXCIgdi1pZj1cXFwiIWhpZGVOYXZJY29uXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLWJyYW5kXFxcIiB2LWlmPVxcXCJzaG93QnJhbmRcXFwiPlxcbiAgICAgICAgICAgIDxzbG90IG5hbWU9XFxcImJyYW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdG9vbGJhci1icmFuZC10ZXh0XFxcIiB2LXRleHQ9XFxcImJyYW5kXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItY2VudGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItZGl2aWRlclxcXCIgdi1pZj1cXFwiYnJhbmREaXZpZGVyVmlzaWJsZVxcXCI+PC9kaXY+XFxuXFxuICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLXRpdGxlXFxcIiB2LXRleHQ9XFxcInRpdGxlXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvc2xvdD5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItcmlnaHRcXFwiPlxcbiAgICAgICAgPHNsb3QgbmFtZT1cXFwiYWN0aW9uc1xcXCI+PC9zbG90PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPHVpLXByb2dyZXNzLWxpbmVhclxcbiAgICAgICAgOnNob3c9XFxcImxvYWRpbmdcXFwiIGNsYXNzPVxcXCJ1aS10b29sYmFyLXByZWxvYWRlclxcXCIgOmNsYXNzPVxcXCJ7ICdwb3NpdGlvbi10b3AnIDogcHJlbG9hZGVyVG9wIH1cXFwiXFxuICAgICAgICA6Y29sb3I9XFxcInByZWxvYWRlckNvbG9yXFxcIlxcbiAgICA+PC91aS1wcm9ncmVzcy1saW5lYXI+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9XHJcbi8qKioqKiovIF0pXHJcbn0pO1xyXG47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlZW4tdWkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34va2Vlbi11aS9kaXN0L2tlZW4tdWkuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL0FwcC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BcHAudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9BcHAudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLWFwcFwiPlxuICAgICAgICA8dWktdGFic1xuICAgICAgICAgICAgY2xhc3M9XCJtYWluLXRhYi1jb250YWluZXJcIiBiYWNrZ3JvdW5kLWNvbG9yPVwiZGFya1wiIHRleHQtY29sb3I9XCJsaWdodFwiXG4gICAgICAgICAgICBpbmRpY2F0b3ItY29sb3I9XCJ0cmFuc3BhcmVudFwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDx1aS10YWIgaGVhZGVyPVwiTWFwXCI+XG4gICAgICAgICAgICAgICAgPG1hcC12aWV3PjwvbWFwLXZpZXc+XG4gICAgICAgICAgICA8L3VpLXRhYj5cblxuICAgICAgICAgICAgPHVpLXRhYiBoZWFkZXI9XCJQYXJhbXNcIj5cbiAgICAgICAgICAgICAgICA8cGFyYW1zLXZpZXc+PC9wYXJhbXMtdmlldz5cbiAgICAgICAgICAgIDwvdWktdGFiPlxuXG4gICAgICAgICAgICA8dWktdGFiIGhlYWRlcj1cIlNldHRpbmdzXCI+XG4gICAgICAgICAgICAgICAgPHNldHRpbmdzLXZpZXc+PC9zZXR0aW5ncy12aWV3PlxuICAgICAgICAgICAgPC91aS10YWI+XG4gICAgICAgIDwvdWktdGFicz5cblxuICAgICAgICA8Z2NzLWluZGljYXRvcnM+PC9nY3MtaW5kaWNhdG9ycz5cblxuICAgICAgICA8dWktc25hY2tiYXItY29udGFpbmVyIHBvc2l0aW9uPVwiY2VudGVyXCI+PC91aS1zbmFja2Jhci1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gICAgPHNvY2tldC1pby1tYW5hZ2VyPjwvc29ja2V0LWlvLW1hbmFnZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1hcFZpZXcgZnJvbSAndmlld3MvTWFwVmlldy52dWUnO1xuaW1wb3J0IFBhcmFtc1ZpZXcgZnJvbSAndmlld3MvUGFyYW1zVmlldy52dWUnO1xuaW1wb3J0IFNldHRpbmdzVmlldyBmcm9tICd2aWV3cy9TZXR0aW5nc1ZpZXcudnVlJztcbmltcG9ydCBHY3NJbmRpY2F0b3JzIGZyb20gJ2NvbXBvbmVudHMvR2NzSW5kaWNhdG9ycy52dWUnO1xuaW1wb3J0IFNvY2tldElvTWFuYWdlciBmcm9tICdjb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICAnYXBwOjpjcmVhdGUtc25hY2tiYXInKG1lc3NhZ2UsIHNuYWNrYmFyKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNuYWNrYmFyKG1lc3NhZ2UsIHNuYWNrYmFyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOjpwYW4tdXAnKCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6OnBhbi11cCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6OnBhbi1kb3duJygpIHtcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpwYW4tZG93bicpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6OnBhbi1sZWZ0JygpIHtcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpwYW4tbGVmdCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6OnBhbi1yaWdodCcoKSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6cGFuLXJpZ2h0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ21hcDo6cGFuLWNlbnRlcicoKSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6cGFuLWNlbnRlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6Onpvb20taW4nKCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6Onpvb20taW4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOjp6b29tLW91dCcoKSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6em9vbS1vdXQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOjpjaGFuZ2UtdHlwZScobmV3VHlwZSkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6OmNoYW5nZS10eXBlJywgbmV3VHlwZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ21hcDpjbGljaycoZSkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6Y2xpY2snLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOmRibGNsaWNrJyhlKSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDpkYmxjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6cmlnaHRjbGljaycoZSkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6cmlnaHRjbGljaycsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY3JlYXRlU25hY2tiYXIobWVzc2FnZSwgc25hY2tiYXIpIHtcbiAgICAgICAgICAgIHNuYWNrYmFyID0gc25hY2tiYXIgfHwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgndWktc25hY2tiYXI6OmNyZWF0ZScsIHNuYWNrYmFyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIE1hcFZpZXcsXG4gICAgICAgIFBhcmFtc1ZpZXcsXG4gICAgICAgIFNldHRpbmdzVmlldyxcbiAgICAgICAgR2NzSW5kaWNhdG9ycyxcbiAgICAgICAgU29ja2V0SW9NYW5hZ2VyXG4gICAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuQGltcG9ydCAnfnN0eWxlcy9tYWluJztcbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBBcHAudnVlPzMxZGY0Y2VkXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01hcFZpZXcudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWFwVmlldy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9NYXBWaWV3LnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi4vTWFwVmlldy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3ZpZXdzL01hcFZpZXcudnVlXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwidmlldyBtYXAtdmlld1wiPlxuICAgICAgICA8Z2NzLW1hcD48L2djcy1tYXA+XG4gICAgICAgIDxnY3MtbWFwLWNvbnRyb2xzPjwvZ2NzLW1hcC1jb250cm9scz5cbiAgICAgICAgPGdjcy1tYXAtc2lkZWJhciA6c2hvdy1zaWRlYmFyPVwic2hvd1NpZGViYXJcIj48L2djcy1tYXAtc2lkZWJhcj5cblxuICAgICAgICA8Z2NzLXNpZGViYXItY29udHJvbHNcbiAgICAgICAgICAgIDpzaG93LXNpZGViYXI9XCJzaG93U2lkZWJhclwiIEB0b2dnbGUtc2lkZWJhcj1cInRvZ2dsZVNpZGViYXJcIlxuICAgICAgICA+PC9nY3Mtc2lkZWJhci1jb250cm9scz5cblxuICAgICAgICA8Z2NzLXdhbXYgdi1pZj1cIndhbXYubG9hZGVkXCJcbiAgICAgICAgICAgIDpsYXQ9XCJ3YW12LnBvc2l0aW9uLmxhdFwiIDpsbmc9XCJ3YW12LnBvc2l0aW9uLmxuZ1wiXG4gICAgICAgICAgICA6cm90YXRpb249XCJ3YW12LmhlYWRpbmdcIlxuICAgICAgICA+PC9nY3Mtd2Ftdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgR2NzTWFwIGZyb20gJ21hcC9HY3NNYXAudnVlJztcbmltcG9ydCBHY3NNYXBDb250cm9scyBmcm9tICdtYXAvR2NzTWFwQ29udHJvbHMudnVlJztcbmltcG9ydCBHY3NNYXBTaWRlYmFyIGZyb20gJ21hcC9HY3NNYXBTaWRlYmFyLnZ1ZSc7XG5pbXBvcnQgR2NzU2lkZWJhckNvbnRyb2xzIGZyb20gJ21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlJztcbmltcG9ydCBHY3NXYW12IGZyb20gJ21hcmtlcnMvR2NzV2Ftdi52dWUnO1xuXG5pbXBvcnQgeyBnZXRXYW12IH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB2dWV4OiB7XG4gICAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXZcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hvd1NpZGViYXI6IHRydWVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGVTaWRlYmFyKCkge1xuICAgICAgICAgICAgdGhpcy5zaG93U2lkZWJhciA9ICF0aGlzLnNob3dTaWRlYmFyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgR2NzTWFwLFxuICAgICAgICBHY3NXYW12LFxuICAgICAgICBHY3NNYXBDb250cm9scyxcbiAgICAgICAgR2NzTWFwU2lkZWJhcixcbiAgICAgICAgR2NzU2lkZWJhckNvbnRyb2xzXG4gICAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcblxuLnZpZXcubWFwLXZpZXcge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBNYXBWaWV3LnZ1ZT82YmIxYjU5Y1xuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNYXAudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWFwLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01hcC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL0djc01hcC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImdjcy1tYXBcIiBpZD1cIm1hcFwiIDpjbGFzcz1cInsgJ2djcy1tYXAtZWRpdC1tb2RlJzogbWFwRWRpdGluZyB9XCI+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGNvcHkgZnJvbSAndXRpbC9jb3B5LW9iamVjdCc7XG5pbXBvcnQgbG9hZEdvb2dsZU1hcHNBUEkgZnJvbSAnbG9hZC1nb29nbGUtbWFwcy1hcGknO1xuXG5pbXBvcnQgeyBzZXRNYXAsIHNldE1hcEVsLCBzZXRNYXBMb2FkZWQgfSBmcm9tICdzdG9yZS9hY3Rpb25zJztcbmltcG9ydCB7IGdldFdhbXYsIGdldFNldHRpbmdzLCBnZXRDb25maWcsIGdldE1hcCwgZ2V0TWFwRWwsIGdldE1hcExvYWRlZCwgZ2V0TWFwRWRpdGluZyB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdnVleDoge1xuICAgICAgICBnZXR0ZXJzOiB7XG4gICAgICAgICAgICBtYXA6IGdldE1hcCxcbiAgICAgICAgICAgIG1hcEVsOiBnZXRNYXBFbCxcbiAgICAgICAgICAgIG1hcExvYWRlZDogZ2V0TWFwTG9hZGVkLFxuICAgICAgICAgICAgbWFwRWRpdGluZzogZ2V0TWFwRWRpdGluZyxcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXYsXG4gICAgICAgICAgICBjb25maWc6IGdldENvbmZpZyxcbiAgICAgICAgICAgIHNldHRpbmdzOiBnZXRTZXR0aW5nc1xuICAgICAgICB9LFxuXG4gICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgIHNldE1hcCxcbiAgICAgICAgICAgIHNldE1hcEVsLFxuICAgICAgICAgICAgc2V0TWFwTG9hZGVkXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgbWFwRWRpdGluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcEVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRPcHRpb25zKHsgZHJhZ2dhYmxlQ3Vyc29yOiAnY3Jvc3NoYWlyJyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0T3B0aW9ucyh7IGRyYWdnYWJsZUN1cnNvcjogJ21vdmUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYWR5KCkge1xuICAgICAgICB0aGlzLnNldE1hcEVsKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXAnKSk7XG5cbiAgICAgICAgbG9hZEdvb2dsZU1hcHNBUEkodGhpcy5jb25maWcuZ29vZ2xlTWFwcylcbiAgICAgICAgICAgIC50aGVuKHRoaXMuaW5pdGlhbGl6ZU1hcClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGxvYWQgR29vZ2xlIE1hcHMgQVBJJywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdtYXA6OnBhbi11cCcoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5wYW5CeSgwLCAtMSAqICh0aGlzLm1hcEVsLmNsaWVudEhlaWdodCAvIDQpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOjpwYW4tZG93bicoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5wYW5CeSgwLCB0aGlzLm1hcEVsLmNsaWVudEhlaWdodCAvIDQpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6OnBhbi1sZWZ0JygpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLnBhbkJ5KC0xICogKHRoaXMubWFwRWwuY2xpZW50V2lkdGggLyA0KSwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ21hcDo6cGFuLXJpZ2h0JygpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLnBhbkJ5KHRoaXMubWFwRWwuY2xpZW50V2lkdGggLyA0LCAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOjpwYW4tY2VudGVyJygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhbXYubG9hZGVkKXtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5wYW5Ubyh0aGlzLndhbXYucG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6Onpvb20taW4nKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbSh0aGlzLm1hcC5nZXRab29tKCkgKyAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOjp6b29tLW91dCcoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRab29tKHRoaXMubWFwLmdldFpvb20oKSAtIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6OmNoYW5nZS10eXBlJyhuZXdUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRNYXBUeXBlSWQoZ29vZ2xlLm1hcHMuTWFwVHlwZUlkW25ld1R5cGVdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXRpYWxpemVNYXAoKSB7XG4gICAgICAgICAgICBsZXQgbWFwQ29uZmlnID0gY29weSh0aGlzLmNvbmZpZy5tYXApO1xuXG4gICAgICAgICAgICBtYXBDb25maWcubWFwVHlwZUlkID0gZ29vZ2xlLm1hcHMuTWFwVHlwZUlkW3RoaXMuc2V0dGluZ3MuZGVmYXVsdE1hcFR5cGVdO1xuXG4gICAgICAgICAgICBsZXQgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcCh0aGlzLm1hcEVsLCBtYXBDb25maWcpO1xuXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKG1hcCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7XG4gICAgICAgICAgICB0aGlzLnNldE1hcExvYWRlZCh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cEV2ZW50cyhtYXApIHtcbiAgICAgICAgICAgIG1hcC5hZGRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtYXA6Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXAuYWRkTGlzdGVuZXIoJ2RibGNsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOmRibGNsaWNrJywgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFwLmFkZExpc3RlbmVyKCdyaWdodGNsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOnJpZ2h0Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcblxuLmdjcy1tYXAge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB6LWluZGV4OiAxO1xuXG4gICAgJi5nY3MtbWFwLWVkaXQtbW9kZSB7XG4gICAgICAgIGN1cnNvcjogY3Jvc3NoYWlyO1xuICAgIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNYXAudnVlP2JkYmE0OWUwXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy91dGlsL2NvcHktb2JqZWN0LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb3JlICA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKVxuICAsICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7c3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeX0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICB2YXIgY2xpZW50ID0gX3JlZi5jbGllbnQ7XG4gIHZhciBrZXkgPSBfcmVmLmtleTtcbiAgdmFyIGxhbmd1YWdlID0gX3JlZi5sYW5ndWFnZTtcbiAgdmFyIF9yZWYkbGlicmFyaWVzID0gX3JlZi5saWJyYXJpZXM7XG4gIHZhciBsaWJyYXJpZXMgPSBfcmVmJGxpYnJhcmllcyA9PT0gdW5kZWZpbmVkID8gW10gOiBfcmVmJGxpYnJhcmllcztcbiAgdmFyIF9yZWYkdGltZW91dCA9IF9yZWYudGltZW91dDtcbiAgdmFyIHRpbWVvdXQgPSBfcmVmJHRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IDEwMDAwIDogX3JlZiR0aW1lb3V0O1xuICB2YXIgdiA9IF9yZWYudjtcblxuICB2YXIgY2FsbGJhY2tOYW1lID0gJ19fZ29vZ2xlTWFwc0FwaU9uTG9hZENhbGxiYWNrJztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgLy8gRXhpdCBpZiBub3QgcnVubmluZyBpbnNpZGUgYSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0NhbiBvbmx5IGxvYWQgdGhlIEdvb2dsZSBNYXBzIEFQSSBpbiB0aGUgYnJvd3NlcicpKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHRoZSBgc2NyaXB0YCB0YWcgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgcGFnZS5cbiAgICB2YXIgc2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHZhciBwYXJhbXMgPSBbJ2NhbGxiYWNrPScgKyBjYWxsYmFja05hbWVdO1xuICAgIGlmIChjbGllbnQpIHBhcmFtcy5wdXNoKCdjbGllbnQ9JyArIGNsaWVudCk7XG4gICAgaWYgKGtleSkgcGFyYW1zLnB1c2goJ2tleT0nICsga2V5KTtcbiAgICBpZiAobGFuZ3VhZ2UpIHBhcmFtcy5wdXNoKCdsYW5ndWFnZT0nICsgbGFuZ3VhZ2UpO1xuICAgIGxpYnJhcmllcyA9IFtdLmNvbmNhdChsaWJyYXJpZXMpOyAvLyBFbnN1cmUgdGhhdCBgbGlicmFyaWVzYCBpcyBhbiBhcnJheVxuICAgIGlmIChsaWJyYXJpZXMubGVuZ3RoKSBwYXJhbXMucHVzaCgnbGlicmFyaWVzPScgKyBsaWJyYXJpZXMuam9pbignLCcpKTtcbiAgICBpZiAodikgcGFyYW1zLnB1c2goJ3Y9JyArIHYpO1xuICAgIHNjcmlwdEVsZW1lbnQuc3JjID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz8nICsgcGFyYW1zLmpvaW4oJyYnKTtcblxuICAgIC8vIFRpbWVvdXQgaWYgbmVjZXNzYXJ5LlxuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7fTsgLy8gU2V0IHRoZSBvbiBsb2FkIGNhbGxiYWNrIHRvIGEgbm8tb3AuXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIHRoZSBHb29nbGUgTWFwcyBBUEknKSk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICAvLyBIb29rIHVwIHRoZSBvbiBsb2FkIGNhbGxiYWNrLlxuICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUod2luZG93Lmdvb2dsZS5tYXBzKTtcbiAgICAgIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcbiAgICB9O1xuXG4gICAgLy8gSW5zZXJ0IHRoZSBgc2NyaXB0YCB0YWcuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvYWQtZ29vZ2xlLW1hcHMtYXBpL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgYXNzaWduIGZyb20gJ2RlZXAtYXNzaWduJztcblxuLyoqXG4gKiBTZXQgdGhlIEdvb2dsZSBNYXBzIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXAoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWFwKSB7XG4gICAgZGlzcGF0Y2goJ1NFVF9NQVAnLCBtYXApO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZWxlbWVudCB0aGUgbWFwIGlzIHJlbmRlcmVkIGludG9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE1hcEVsKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1hcEVsKSB7XG4gICAgZGlzcGF0Y2goJ1NFVF9NQVBfRUwnLCBtYXBFbCk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBtYXAgbG9hZGVkIGZsYWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE1hcExvYWRlZCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBsb2FkZWQpIHtcbiAgICBkaXNwYXRjaCgnU0VUX01BUF9MT0FERUQnLCBsb2FkZWQpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZWRpdGluZyBmbGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXBFZGl0aW5nKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIGVkaXRpbmcpIHtcbiAgICBkaXNwYXRjaCgnU0VUX01BUF9FRElUSU5HJywgZWRpdGluZyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBXYW1WXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRXYW12KHsgZGlzcGF0Y2gsIHN0YXRlIH0sIHdhbXYpIHtcbiAgICBkaXNwYXRjaCgnU0VUX1dBTVYnLCB3YW12KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIFdhbVYgYXJtZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFdhbXZBcm1lZCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBhcm1lZCkge1xuICAgIGRpc3BhdGNoKCdTRVRfV0FNVl9BUk1FRCcsIGFybWVkKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIFdhbVYgbW92aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRXYW12TW9kZSh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtb2RlKSB7XG4gICAgZGlzcGF0Y2goJ1NFVF9XQU1WX01PREUnLCBtb2RlKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBhcHAgc2V0dGluZ3MgYW5kIHNldCBpdCBvbiB0aGUgZ2xvYmFsXG4gKiBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFNldHRpbmdzKHsgZGlzcGF0Y2ggfSkge1xuICAgIC8vIFRPRE86IGZldGNoIHNldHRpbmdzIGZvciBzZXJ2ZXJcbiAgICAvL1xuICAgIC8vIGFwaS5zZXR0aW5ncy5pbml0KClcbiAgICAvLyAgICAgLnRoZW4oZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICAvLyAgICAgICAgIGRpc3BhdGNoKCdJTklUX1NFVFRJTkdTJywgY2xlYW4oc2V0dGluZ3MpKTtcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gICAgICAgICBjb25zb2xlLmVycm9yKCdbc3RvcmUvYWN0aW9uc106IEVycm9yIGZldGNoaW5nIHNldHRpbmdzJywgZXJyb3IpO1xuICAgIC8vICAgICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBzZXR0aW5nIG9uIHRoZSBzZXJ2ZXIgYW5kIG9uIHRoZSBnbG9iYWwgc3RhdGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHNldHRpbmcgdG8gdXBkYXRlXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZSAgICAtIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTZXR0aW5nKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIGtleSwgdmFsdWUpIHtcbiAgICBsZXQgc2V0dGluZ3MgPSBhc3NpZ24oe30sIHN0YXRlLnNldHRpbmdzKTtcbiAgICBzZXR0aW5nc1trZXldID0gdmFsdWU7XG5cbiAgICBkaXNwYXRjaCgnVVBEQVRFX1NFVFRJTkdTJywgc2V0dGluZ3MpO1xuXG4gICAgLy8gc2VuZCB0byBzZXJ2ZXJcbn1cblxuLyoqXG4gKiBTZXQgdGhlIG1pc3Npb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRNaXNzaW9ucyh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtaXNzaW9ucykge1xuICAgIGRpc3BhdGNoKCdTRVRfTUlTU0lPTlMnLCBtaXNzaW9ucyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IG1pc3Npb24gaW5kZXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEN1cnJlbnRNaXNzaW9uSW5kZXgoeyBkaXNwYXRjaCwgc3RhdGUgfSwgaW5kZXgpIHtcbiAgICBkaXNwYXRjaCgnU0VUX0NVUlJFTlRfTUlTU0lPTl9JTkRFWCcsIGluZGV4KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgbWlzc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3VycmVudE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbikge1xuICAgIGRpc3BhdGNoKCdTRVRfQ1VSUkVOVF9NSVNTSU9OJywgbWlzc2lvbik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJzKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIHBhcmFtZXRlcnMpIHtcbiAgICBkaXNwYXRjaCgnU0VUX1BBUkFNRVRFUlMnLCBwYXJhbWV0ZXJzKTtcbn1cblxuLyoqXG4gKiBTZW5kIGdldF9wYXJhbWV0ZXJzIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRHZXRQYXJhbWV0ZXJzKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU0VORF9HRVRfUEFSQU1FVEVSUycpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIGdldF9wYXJhbWV0ZXJzIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWRHZXRQYXJhbWV0ZXJzKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIHBhcmFtZXRlcnMpIHtcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9HRVRfUEFSQU1FVEVSUycsIHBhcmFtZXRlcnMpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBnZXRfcGFyYW1ldGVycyBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWlsR2V0UGFyYW1ldGVycyh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtc2cpIHtcbiAgICBkaXNwYXRjaCgnRkFJTF9HRVRfUEFSQU1FVEVSUycsIG1zZyk7XG59XG5cbi8qKlxuICogU2VuZCBzYXZlX21pc3Npb25zIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRTYXZlTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbnMpIHtcbiAgICBkaXNwYXRjaCgnU0VORF9TQVZFX01JU1NJT05TJywgbWlzc2lvbnMpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIHNhdmVfbWlzc2lvbnMgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZFNhdmVNaXNzaW9ucyh7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfU0FWRV9NSVNTSU9OUycpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBzYXZlX21pc3Npb25zIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxTYXZlTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XG4gICAgZGlzcGF0Y2goJ0ZBSUxfU0FWRV9NSVNTSU9OUycsIG1zZyk7XG59XG5cbi8qKlxuICogU2VuZCBsb2FkX21pc3Npb25zIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRMb2FkTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xuICAgIGRpc3BhdGNoKCdTRU5EX0xPQURfTUlTU0lPTlMnKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSBsb2FkX21pc3Npb25zIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWRMb2FkTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbnMpIHtcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9MT0FEX01JU1NJT05TJywgbWlzc2lvbnMpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBsb2FkX21pc3Npb25zIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxMb2FkTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XG4gICAgZGlzcGF0Y2goJ0ZBSUxfTE9BRF9NSVNTSU9OUycsIG1zZyk7XG59XG5cbi8qKlxuICogU2VuZCB1cGxvYWRfbWlzc2lvbiBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kVXBsb2FkTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtaXNzaW9uKSB7XG4gICAgZGlzcGF0Y2goJ1NFTkRfVVBMT0FEX01JU1NJT04nLCBtaXNzaW9uKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSB1cGxvYWRfbWlzc2lvbiBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkVXBsb2FkTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfVVBMT0FEX01JU1NJT04nKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBmYWlsdXJlIG9mIGEgdXBsb2FkX21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFpbFVwbG9hZE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XG4gICAgZGlzcGF0Y2goJ0ZBSUxfVVBMT0FEX01JU1NJT04nLCBtc2cpO1xufVxuXG4vKipcbiAqIFNlbmQgZG93bmxvYWRfbWlzc2lvbiBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kRG93bmxvYWRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU0VORF9ET1dOTE9BRF9NSVNTSU9OJyk7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEgZG93bmxvYWRfbWlzc2lvbiBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkRG93bmxvYWRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1pc3Npb24pIHtcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9ET1dOTE9BRF9NSVNTSU9OJywgbWlzc2lvbik7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgZmFpbHVyZSBvZiBhIGRvd25sb2FkX21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFpbERvd25sb2FkTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtc2cpIHtcbiAgICBkaXNwYXRjaCgnRkFJTF9ET1dOTE9BRF9NSVNTSU9OJywgbXNnKTtcbn1cblxuLyoqXG4gKiBTZW5kIHN0YXJ0X21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VuZFN0YXJ0TWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XG4gICAgZGlzcGF0Y2goJ1NFTkRfU1RBUlRfTUlTU0lPTicpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIHN0YXJ0X21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZFN0YXJ0TWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfU1RBUlRfTUlTU0lPTicpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBzdGFydF9taXNzaW9uIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxTdGFydE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XG4gICAgZGlzcGF0Y2goJ0ZBSUxfU1RBUlRfTUlTU0lPTicsIG1zZyk7XG59XG5cbi8qKlxuICogU2VuZCBzdG9wX21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VuZFN0b3BNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU0VORF9TVE9QX01JU1NJT04nKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSBzdG9wX21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZFN0b3BNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9TVE9QX01JU1NJT04nKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBmYWlsdXJlIG9mIGEgc3RvcF9taXNzaW9uIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxTdG9wTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtc2cpIHtcbiAgICBkaXNwYXRjaCgnRkFJTF9TVE9QX01JU1NJT04nLCBtc2cpO1xufVxuXG4vKipcbiAqIFNlbmQgcmVzdW1lX21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VuZFJlc3VtZU1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xuICAgIGRpc3BhdGNoKCdTRU5EX1JFU1VNRV9NSVNTSU9OJyk7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEgcmVzdW1lX21pc3Npb24gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZFJlc3VtZU1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xuICAgIGRpc3BhdGNoKCdTVUNDRUVEX1JFU1VNRV9NSVNTSU9OJyk7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgZmFpbHVyZSBvZiBhIHJlc3VtZV9taXNzaW9uIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxSZXN1bWVNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xuICAgIGRpc3BhdGNoKCdGQUlMX1JFU1VNRV9NSVNTSU9OJywgbXNnKTtcbn1cblxuLyoqXG4gKiBTZW5kIGFybSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU0VORF9BUk0nKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYW4gYXJtIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWRBcm0oeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xuICAgIGRpc3BhdGNoKCdTVUNDRUVEX0FSTScpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYW4gYXJtIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxBcm0oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XG4gICAgZGlzcGF0Y2goJ0ZBSUxfQVJNJywgbXNnKTtcbn1cblxuLyoqXG4gKiBTZW5kIGRpc2FybSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kRGlzYXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU0VORF9ESVNBUk0nKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSBkaXNhcm0gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZERpc2FybSh7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfRElTQVJNJyk7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgZmFpbHVyZSBvZiBhIGRpc2FybSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWlsRGlzYXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xuICAgIGRpc3BhdGNoKCdGQUlMX0RJU0FSTScsIG1zZyk7XG59XG5cbi8qKlxuICogU2VuZCBraWxsIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRLaWxsKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU0VORF9LSUxMJyk7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEga2lsbCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkS2lsbCh7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfS0lMTCcpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBraWxsIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxLaWxsKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xuICAgIGRpc3BhdGNoKCdGQUlMX0tJTEwnLCBtc2cpO1xufVxuXG4vKipcbiAqIFNlbmQgdW5raWxsIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRVbmtpbGwoeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xuICAgIGRpc3BhdGNoKCdTRU5EX1VOS0lMTCcpO1xufVxuXG4vKipcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIHVua2lsbCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkVW5raWxsKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9VTktJTEwnKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSBmYWlsdXJlIG9mIGEgdW5raWxsIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhaWxVbmtpbGwoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XG4gICAgZGlzcGF0Y2goJ0ZBSUxfVU5LSUxMJywgbXNnKTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3N0b3JlL2FjdGlvbnMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmogPSByZXF1aXJlKCdpcy1vYmonKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU291cmNlcyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpIHtcblx0dmFyIHZhbCA9IGZyb21ba2V5XTtcblxuXHRpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkpIHtcblx0XHRpZiAodG9ba2V5XSA9PT0gdW5kZWZpbmVkIHx8IHRvW2tleV0gPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCAoJyArIGtleSArICcpJyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpIHx8ICFpc09iaih2YWwpKSB7XG5cdFx0dG9ba2V5XSA9IHZhbDtcblx0fSBlbHNlIHtcblx0XHR0b1trZXldID0gYXNzaWduKE9iamVjdCh0b1trZXldKSwgZnJvbVtrZXldKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NpZ24odG8sIGZyb20pIHtcblx0aWYgKHRvID09PSBmcm9tKSB7XG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cblx0ZnJvbSA9IE9iamVjdChmcm9tKTtcblxuXHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdGFzc2lnbktleSh0bywgZnJvbSwga2V5KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRhc3NpZ25LZXkodG8sIGZyb20sIHN5bWJvbHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCkge1xuXHR0YXJnZXQgPSB0b09iamVjdCh0YXJnZXQpO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0YXNzaWduKHRhcmdldCwgYXJndW1lbnRzW3NdKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZGVlcC1hc3NpZ24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiB4O1xuXHRyZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZGVlcC1hc3NpZ24vfi9pcy1vYmovaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGZ1bmN0aW9uIGdldE1hcChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tYXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBFbChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tYXBFbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcExvYWRlZChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tYXBMb2FkZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBFZGl0aW5nKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1hcEVkaXRpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXYW12KHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLndhbXY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWcoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuY29uZmlnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0dGluZ3Moc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuc2V0dGluZ3M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaXNzaW9ucyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5taXNzaW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuY3VycmVudE1pc3Npb25JbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRNaXNzaW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1pc3Npb25zW3N0YXRlLmN1cnJlbnRNaXNzaW9uSW5kZXhdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5wYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZVN0YXRlV2FpdGluZyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VTdGF0ZVN1Y2Nlc3Moc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXNzYWdlU3RhdGVGYWlsdXJlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2V0UGFyYW1ldGVyU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmdldF9wYXJhbWV0ZXJzWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2V0UGFyYW1ldGVyRGF0YShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuZ2V0X3BhcmFtZXRlcnNbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTYXZlTWlzc2lvbnNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9uc1swXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNhdmVNaXNzaW9uc0RhdGEoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnNhdmVfbWlzc2lvbnNbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2FkTWlzc2lvbnNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUubG9hZF9taXNzaW9uc1swXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRNaXNzaW9uc0RhdGEoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmxvYWRfbWlzc2lvbnNbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVcGxvYWRNaXNzaW9uU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnVwbG9hZF9taXNzaW9uWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXBsb2FkTWlzc2lvbkRhdGEoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnVwbG9hZF9taXNzaW9uWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG93bmxvYWRNaXNzaW9uU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmRvd25sb2FkX21pc3Npb25bMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb3dubG9hZE1pc3Npb25EYXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kb3dubG9hZF9taXNzaW9uWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnRNaXNzaW9uU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnN0YXJ0X21pc3Npb25bMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFydE1pc3Npb25EYXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcE1pc3Npb25TdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuc3RvcF9taXNzaW9uWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcE1pc3Npb25EYXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdG9wX21pc3Npb25bMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXN1bWVNaXNzaW9uU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzdW1lTWlzc2lvbkRhdGEoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJtU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmFybVswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFybURhdGEoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmFybVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc2FybVN0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kaXNhcm1bMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNhcm1EYXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kaXNhcm1bMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLaWxsU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmtpbGxbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLaWxsRGF0YShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUua2lsbFsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVua2lsbFN0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS51bmtpbGxbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmtpbGxEYXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS51bmtpbGxbMV07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zdG9yZS9nZXR0ZXJzLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1tYXBcXFwiIGlkPVxcXCJtYXBcXFwiIDpjbGFzcz1cXFwieyAnZ2NzLW1hcC1lZGl0LW1vZGUnOiBtYXBFZGl0aW5nIH1cXFwiPjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcC52dWVcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01hcENvbnRyb2xzLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0djc01hcENvbnRyb2xzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzTWFwQ29udHJvbHMudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9HY3NNYXBDb250cm9scy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBDb250cm9scy52dWVcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJnY3MtbWFwLWNvbnRyb2xzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW4tY29udHJvbHNcIj5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgdXBcIiBpY29uPVwia2V5Ym9hcmRfYXJyb3dfdXBcIiBAY2xpY2s9XCJwYW4oJ3VwJylcIlxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgcmlnaHRcIiBpY29uPVwia2V5Ym9hcmRfYXJyb3dfcmlnaHRcIiBAY2xpY2s9XCJwYW4oJ3JpZ2h0JylcIlxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgZG93blwiIGljb249XCJrZXlib2FyZF9hcnJvd19kb3duXCIgQGNsaWNrPVwicGFuKCdkb3duJylcIlxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgbGVmdFwiIGljb249XCJrZXlib2FyZF9hcnJvd19sZWZ0XCIgQGNsaWNrPVwicGFuKCdsZWZ0JylcIlxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgY2VudGVyXCIgaWNvbj1cIm15X2xvY2F0aW9uXCIgQGNsaWNrPVwicGFuKCdjZW50ZXInKVwiXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInpvb20tY29udHJvbHNcIj5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwiem9vbS1jb250cm9sIGluXCIgaWNvbj1cImFkZFwiIEBjbGljaz1cInpvb20oJ2luJylcIlxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwiem9vbS1jb250cm9sIG91dFwiIGljb249XCJyZW1vdmVcIiBAY2xpY2s9XCJ6b29tKCdvdXQnKVwiXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInR5cGUtY29udHJvbFwiPlxuICAgICAgICAgICAgPHVpLWJ1dHRvblxuICAgICAgICAgICAgICAgIDptZW51LW9wdGlvbnM9XCJtYXBUeXBlc01lbnVcIiBuYW1lPVwibWFwX3R5cGVzXCIgOnRleHQ9XCJtYXBUeXBlXCJcbiAgICAgICAgICAgICAgICBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XCJjaGFuZ2VNYXBUeXBlXCIgaGFzLWRyb3Bkb3duLW1lbnUgcmFpc2VkXG4gICAgICAgICAgICAgICAgZHJvcGRvd24tcG9zaXRpb249XCJ0b3AgcmlnaHRcIiA6c2hvdy1kcm9wZG93bi1pY29uPVwiZmFsc2VcIlxuICAgICAgICAgICAgPjwvdWktYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcFR5cGU6ICdTYXRlbGxpdGUnLFxuICAgICAgICAgICAgbWFwVHlwZXNNZW51OiBbXG4gICAgICAgICAgICAgICAgeyAndmFsdWUnOiAnUk9BRE1BUCcsIHRleHQ6ICdSb2FkJyB9LFxuICAgICAgICAgICAgICAgIHsgJ3ZhbHVlJzogJ1RFUlJBSU4nLCB0ZXh0OiAnVGVycmFpbicgfSxcbiAgICAgICAgICAgICAgICB7ICd2YWx1ZSc6ICdTQVRFTExJVEUnLCB0ZXh0OiAnU2F0ZWxsaXRlJyB9LFxuICAgICAgICAgICAgICAgIHsgJ3ZhbHVlJzogJ0hZQlJJRCcsIHRleHQ6ICdIeWJyaWQnIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICBwYW4oZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOjpwYW4tJyArIGRpcmVjdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgem9vbSh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOjp6b29tLScgKyB0eXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaGFuZ2VNYXBUeXBlKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1hcFR5cGUgPSBzZWxlY3RlZC50ZXh0O1xuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21hcDo6Y2hhbmdlLXR5cGUnLCBzZWxlY3RlZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLW1hcC1jb250cm9scyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogMjRweDtcbiAgICByaWdodDogMTJweDtcbiAgICB6LWluZGV4OiAxO1xuXG4gICAgLnBhbi1jb250cm9scyB7XG4gICAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgaGVpZ2h0OiAxMDBweDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgIC5wYW4tY29udHJvbCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggNXB4IDAgYWxwaGEoYmxhY2ssIDAuMiksIDAgMnB4IDEwcHggMCBhbHBoYShibGFjaywgMC4xNik7XG4gICAgICAgIC13ZWJraXQtbWFzay1pbWFnZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGUhaW1wb3J0YW50O1xuXG4gICAgICAgICYudXAge1xuICAgICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgICAgbGVmdDogMzRweDtcbiAgICAgICAgICAgIHJpZ2h0OiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgJi5kb3duIHtcbiAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgIGxlZnQ6IDM0cHg7XG4gICAgICAgIH1cblxuICAgICAgICAmLmxlZnQge1xuICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIHRvcDogMzRweDtcbiAgICAgICAgfVxuXG4gICAgICAgICYucmlnaHQge1xuICAgICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgICB0b3A6IDM0cHg7XG4gICAgICAgIH1cblxuICAgICAgICAmLmNlbnRlciB7XG4gICAgICAgICAgICB0b3A6IDM0cHg7XG4gICAgICAgICAgICBsZWZ0OiAzNHB4O1xuXG4gICAgICAgICAgICAudWktaWNvbiB7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLnpvb20tY29udHJvbHMge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBtYXJnaW4tdG9wOiA4cHg7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCAwIGFscGhhKGJsYWNrLCAwLjIpLCAwIDJweCAxMHB4IDAgYWxwaGEoYmxhY2ssIDAuMTYpO1xuXG4gICAgICAgIC56b29tLWNvbnRyb2wge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyOHB4O1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGUhaW1wb3J0YW50XG5cbiAgICAgICAgICAgICYuaW4ge1xuICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNDQ0M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAudHlwZS1jb250cm9sIHtcbiAgICAgICAgbWFyZ2luLXRvcDogOHB4O1xuXG4gICAgICAgIC51aS1idXR0b24ge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc01hcENvbnRyb2xzLnZ1ZT8zN2FiNDA5YVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3MtbWFwLWNvbnRyb2xzXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuLWNvbnRyb2xzXFxcIj5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJwYW4tY29udHJvbCB1cFxcXCIgaWNvbj1cXFwia2V5Ym9hcmRfYXJyb3dfdXBcXFwiIEBjbGljaz1cXFwicGFuKCd1cCcpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwicGFuLWNvbnRyb2wgcmlnaHRcXFwiIGljb249XFxcImtleWJvYXJkX2Fycm93X3JpZ2h0XFxcIiBAY2xpY2s9XFxcInBhbigncmlnaHQnKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInBhbi1jb250cm9sIGRvd25cXFwiIGljb249XFxcImtleWJvYXJkX2Fycm93X2Rvd25cXFwiIEBjbGljaz1cXFwicGFuKCdkb3duJylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJwYW4tY29udHJvbCBsZWZ0XFxcIiBpY29uPVxcXCJrZXlib2FyZF9hcnJvd19sZWZ0XFxcIiBAY2xpY2s9XFxcInBhbignbGVmdCcpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwicGFuLWNvbnRyb2wgY2VudGVyXFxcIiBpY29uPVxcXCJteV9sb2NhdGlvblxcXCIgQGNsaWNrPVxcXCJwYW4oJ2NlbnRlcicpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ6b29tLWNvbnRyb2xzXFxcIj5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ6b29tLWNvbnRyb2wgaW5cXFwiIGljb249XFxcImFkZFxcXCIgQGNsaWNrPVxcXCJ6b29tKCdpbicpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwiem9vbS1jb250cm9sIG91dFxcXCIgaWNvbj1cXFwicmVtb3ZlXFxcIiBAY2xpY2s9XFxcInpvb20oJ291dCcpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0eXBlLWNvbnRyb2xcXFwiPlxcbiAgICAgICAgPHVpLWJ1dHRvblxcbiAgICAgICAgICAgIDptZW51LW9wdGlvbnM9XFxcIm1hcFR5cGVzTWVudVxcXCIgbmFtZT1cXFwibWFwX3R5cGVzXFxcIiA6dGV4dD1cXFwibWFwVHlwZVxcXCJcXG4gICAgICAgICAgICBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XFxcImNoYW5nZU1hcFR5cGVcXFwiIGhhcy1kcm9wZG93bi1tZW51IHJhaXNlZFxcbiAgICAgICAgICAgIGRyb3Bkb3duLXBvc2l0aW9uPVxcXCJ0b3AgcmlnaHRcXFwiIDpzaG93LWRyb3Bkb3duLWljb249XFxcImZhbHNlXFxcIlxcbiAgICAgICAgPjwvdWktYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBDb250cm9scy52dWVcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01hcFNpZGViYXIudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWFwU2lkZWJhci52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzTWFwU2lkZWJhci52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL0djc01hcFNpZGViYXIudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBTaWRlYmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImdjcy1tYXAtc2lkZWJhclwiIHYtc2hvdz1cInNob3dTaWRlYmFyXCIgdHJhbnNpdGlvbj1cInNpZGViYXItY29sbGFwc2VcIj5cbiAgICAgICAgPGdjcy1taXNzaW9ucz48L2djcy1taXNzaW9ucz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgR2NzTWlzc2lvbnMgZnJvbSAnbWlzc2lvbi9HY3NNaXNzaW9ucy52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IHtcbiAgICAgICAgc2hvd1NpZGViYXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgR2NzTWlzc2lvbnNcbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLW1hcC1zaWRlYmFyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDM2MHB4O1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHotaW5kZXg6IDE7XG5cbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIGJveC1zaGFkb3c6IDAgMCA0cHggYWxwaGEoYmxhY2ssIDAuMzUpLCAwIDJweCAzcHggYWxwaGEoYmxhY2ssIDAuMik7XG59XG5cbi5zaWRlYmFyLWNvbGxhcHNlLXRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xufVxuXG4uc2lkZWJhci1jb2xsYXBzZS1lbnRlcixcbi5zaWRlYmFyLWNvbGxhcHNlLWxlYXZlIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTM2MHB4KTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNYXBTaWRlYmFyLnZ1ZT80MmNlY2Q1Y1xuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNaXNzaW9ucy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NNaXNzaW9ucy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HY3NNaXNzaW9ucy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL0djc01pc3Npb25zLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbnMudnVlXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbnMudnVlXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLW1pc3Npb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaWRlYmFyLXBhZ2VcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtaXNzaW9ucy1saXN0XCIgdi1pZj1cImN1cnJlbnRWaWV3ID09PSAnbGlzdGluZydcIj5cbiAgICAgICAgICAgICAgICA8dWktdG9vbGJhciB0aXRsZT1cIk1pc3Npb25zXCIgaGlkZS1uYXYtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzbG90PVwiYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNsZWFyXCIgaWNvbj1cImFkZFwiIHRvb2x0aXA9XCJBZGQgbWlzc2lvblwiIEBjbGljaz1cImFkZE1pc3Npb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJtb3JlX3ZlcnRcIiBoYXMtZHJvcGRvd24tbWVudVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLXBvc2l0aW9uPVwiYm90dG9tIHJpZ2h0XCIgOm1lbnUtb3B0aW9ucz1cIm92ZXJmbG93TWVudVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1lbnUtb3B0aW9uLXNlbGVjdGVkPVwibWVudU9wdGlvblNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L3VpLXRvb2xiYXI+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2lkZWJhci1wYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJsYW5rLXN0YXRlXCIgdi1pZj1cIiFtaXNzaW9ucy5sZW5ndGhcIj5ObyBtaXNzaW9uczwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIDxnY3MtbWlzc2lvbi1yb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKGluZGV4LCBtaXNzaW9uKSBpbiBtaXNzaW9uc1wiIDppbmRleD1cImluZGV4XCIgOm1pc3Npb249XCJtaXNzaW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInNlbGVjdE1pc3Npb24oaW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgPjwvZ2NzLW1pc3Npb24tcm93PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxjb21wb25lbnRcbiAgICAgICAgICAgICAgICB2LWVsc2UgOmlzPVwiY3VycmVudFZpZXdcIiA6bWlzc2lvbj1cImN1cnJlbnRNaXNzaW9uXCIgQGdvLWJhY2s9XCJzaG93TGlzdGluZ1ZpZXdcIlxuICAgICAgICAgICAgPjwvY29tcG9uZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIGhpZGRlbiBpbnB1dCBlbGVtZW50IHVzZWQgZm9yIHNlbGVjdGluZyBhIGZpbGUgdG8gaW1wb3J0IGZyb20gLS0+XG4gICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJpbXBvcnRfbWlzc2lvbnNfaW5wdXRcIiBAY2hhbmdlPVwiaW1wb3J0TWlzc2lvblwiPlxuICAgIDwhLS0gaGlkZGVuIGxpbmsgdXNlZCBmb3IgcHJvbXB0aW5nIGEgZG93bmxvYWQgLS0+XG4gICAgPGEgaWQ9XCJleHBvcnRfbWlzc2lvbnNfbGlua1wiPjwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgR2NzTWlzc2lvbiBmcm9tICdtaXNzaW9uL0djc01pc3Npb24udnVlJztcbmltcG9ydCBHY3NNaXNzaW9uUm93IGZyb20gJ21pc3Npb24vR2NzTWlzc2lvblJvdy52dWUnO1xuXG5pbXBvcnQge1xuICAgIHNldE1pc3Npb25zLCBzZXRDdXJyZW50TWlzc2lvbkluZGV4LFxuICAgIHNlbmRTYXZlTWlzc2lvbnMsIGZhaWxTYXZlTWlzc2lvbnMsXG4gICAgc2VuZExvYWRNaXNzaW9ucywgZmFpbExvYWRNaXNzaW9uc1xufSBmcm9tICdzdG9yZS9hY3Rpb25zJztcbmltcG9ydCB7XG4gICAgZ2V0TWlzc2lvbnMsIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgsIGdldEN1cnJlbnRNaXNzaW9uLFxuICAgIGdldE1lc3NhZ2VTdGF0ZVdhaXRpbmcsIGdldE1lc3NhZ2VTdGF0ZVN1Y2Nlc3MsIGdldE1lc3NhZ2VTdGF0ZUZhaWx1cmUsXG4gICAgZ2V0U2F2ZU1pc3Npb25zU3RhdGUsIGdldFNhdmVNaXNzaW9uc0RhdGEsXG4gICAgZ2V0TG9hZE1pc3Npb25zU3RhdGUsIGdldExvYWRNaXNzaW9uc0RhdGEsXG59IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdnVleDoge1xuICAgICAgICBnZXR0ZXJzOiB7XG4gICAgICAgICAgICBtaXNzaW9uczogICAgICAgICAgICBnZXRNaXNzaW9ucyxcbiAgICAgICAgICAgIGN1cnJlbnRNaXNzaW9uSW5kZXg6IGdldEN1cnJlbnRNaXNzaW9uSW5kZXgsXG4gICAgICAgICAgICBjdXJyZW50TWlzc2lvbjogICAgICBnZXRDdXJyZW50TWlzc2lvbixcbiAgICAgICAgICAgIFdBSVRJTkc6ICAgICAgICAgICAgIGdldE1lc3NhZ2VTdGF0ZVdhaXRpbmcsXG4gICAgICAgICAgICBTVUNDRVNTOiAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVTdWNjZXNzLFxuICAgICAgICAgICAgRkFJTFVSRTogICAgICAgICAgICAgZ2V0TWVzc2FnZVN0YXRlRmFpbHVyZSxcbiAgICAgICAgICAgIHNhdmVNaXNzaW9uc1N0YXRlOiAgIGdldFNhdmVNaXNzaW9uc1N0YXRlLFxuICAgICAgICAgICAgc2F2ZU1pc3Npb25zRGF0YTogICAgZ2V0U2F2ZU1pc3Npb25zRGF0YSxcbiAgICAgICAgICAgIGxvYWRNaXNzaW9uc1N0YXRlOiAgIGdldExvYWRNaXNzaW9uc1N0YXRlLFxuICAgICAgICAgICAgbG9hZE1pc3Npb25zRGF0YTogICAgZ2V0TG9hZE1pc3Npb25zRGF0YVxuICAgICAgICB9LFxuXG4gICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgIHNldE1pc3Npb25zLFxuICAgICAgICAgICAgc2V0Q3VycmVudE1pc3Npb25JbmRleCxcbiAgICAgICAgICAgIHNlbmRTYXZlTWlzc2lvbnMsXG4gICAgICAgICAgICBmYWlsU2F2ZU1pc3Npb25zLFxuICAgICAgICAgICAgc2VuZExvYWRNaXNzaW9ucyxcbiAgICAgICAgICAgIGZhaWxMb2FkTWlzc2lvbnNcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFZpZXc6ICdsaXN0aW5nJyxcbiAgICAgICAgICAgIG92ZXJmbG93TWVudTogW1xuICAgICAgICAgICAgICAgIHsgaWQ6ICdzYXZlJywgdGV4dDogJ1NhdmUgdG8gc2VydmVyJyB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6ICdsb2FkJywgdGV4dDogJ0xvYWQgZnJvbSBzZXJ2ZXInIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogJ3NlcDEnLCB0ZXh0OiAnJywgdHlwZTogJ2RpdmlkZXInIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogJ2V4cG9ydCcsIHRleHQ6ICdFeHBvcnQgdG8gZmlsZScgfSxcbiAgICAgICAgICAgICAgICB7IGlkOiAnaW1wb3J0JywgdGV4dDogJ0ltcG9ydCBmcm9tIGZpbGUnIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogJ3NlcDInLCB0ZXh0OiAnJywgdHlwZTogJ2RpdmlkZXInIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogJ2NsZWFyJywgdGV4dDogJ0NsZWFyIGFsbCcgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzZWxlY3RNaXNzaW9uKGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaXNzaW9uSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICdnY3MtbWlzc2lvbic7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0xpc3RpbmdWaWV3KCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICdsaXN0aW5nJztcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pc3Npb25JbmRleCgtMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTWlzc2lvbigpe1xuICAgICAgICAgICAgdGhpcy5taXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ01pc3Npb24gJyArICh0aGlzLm1pc3Npb25zLmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIHdheXBvaW50czogW11cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVudU9wdGlvblNlbGVjdGVkKG9wdGlvbil7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbi5pZCl7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2F2ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kU2F2ZU1pc3Npb25zKHRoaXMubWlzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNhdmVNaXNzaW9uc1N0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsU2F2ZU1pc3Npb25zKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9hZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTG9hZE1pc3Npb25zKHRoaXMubWlzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRNaXNzaW9uc1N0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsTG9hZE1pc3Npb25zKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0Jzoge1xuICAgICAgICAgICAgICAgICAgICAvL3RyaWdnZXIgZmlsZSBzZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltcG9ydF9taXNzaW9uc19pbnB1dCcpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdleHBvcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGRhdGEgVVJJXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmkgPSAnZGF0YTphcHBsaWNhdGlvbi9qc29uLCc7XG4gICAgICAgICAgICAgICAgICAgIHVyaSArPSBKU09OLnN0cmluZ2lmeSh0aGlzLm1pc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdXJpID0gZW5jb2RlVVJJKHVyaSk7XG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IGxpbmsgdG8gdXNlIGZvciBkb3dubG9hZFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleHBvcnRfbWlzc2lvbnNfbGluaycpO1xuICAgICAgICAgICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSAnbWlzc2lvbnMuanNvbic7XG4gICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlciBkb3dubG9hZFxuICAgICAgICAgICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjbGVhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRNaXNzaW9ucyhbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGltcG9ydE1pc3Npb24oKXtcbiAgICAgICAgICAgIGxldCBmaWxlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbXBvcnRfbWlzc2lvbnNfaW5wdXQnKS5maWxlcztcbiAgICAgICAgICAgIC8vZ2V0IGZpbGUgY29udGVudHNcbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzWzBdO1xuICAgICAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIC8vc3BlY2lmeSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZmlsZSBoYXMgYmVlbiByZWFkXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50cyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdNaXNzaW9ucyA9IEpTT04ucGFyc2UoY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdmVyaWZ5IG1pc3Npb25zIG9iamVjdCBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnMobmV3TWlzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaWxlIGNvbnRlbnRzIGFyZSBpbnZhbGlkOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy9zdGFydCBmaWxlIHJlYWRcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuICAgICAgICBzYXZlTWlzc2lvbnNTdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXsgLy9zdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW9ucyBzYXZlZC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7IC8vZmFpbHVyZSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHNhdmUgbWlzc2lvbnM6ICcgKyB0aGlzLnNhdmVNaXNzaW9uc0RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9hZE1pc3Npb25zU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnModGhpcy5sb2FkTWlzc2lvbnNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3Npb25zIGxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gbG9hZCBtaXNzaW9uczogJyArIHRoaXMubG9hZE1pc3Npb25zRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICAnZGVsZXRlLW1pc3Npb24nKGluZGV4KXtcbiAgICAgICAgICAgIHRoaXMubWlzc2lvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEdjc01pc3Npb24sXG4gICAgICAgIEdjc01pc3Npb25Sb3dcbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLW1pc3Npb25zLFxuLm1pc3Npb25zLWxpc3Qge1xuICAgIGhlaWdodDogMTAwJVxuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbiNpbXBvcnRfbWlzc2lvbnNfaW5wdXQsXG4jZXhwb3J0X21pc3Npb25zX2xpbmsge1xuICAgIGRpc3BsYXk6IG5vbmU7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWlzc2lvbnMudnVlPzYyYjZhMDhmXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01pc3Npb24udnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWlzc2lvbi52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01pc3Npb24udnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9HY3NNaXNzaW9uLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWVcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImdjcy1taXNzaW9uXCI+XG4gICAgICAgIDx1aS10b29sYmFyIDp0aXRsZT1cIm1pc3Npb24udGl0bGVcIiBoaWRlLW5hdi1pY29uIHNob3ctYnJhbmQgOnNob3ctYnJhbmQtZGl2aWRlcj1cImZhbHNlXCI+XG4gICAgICAgICAgICA8ZGl2IHNsb3Q9XCJicmFuZFwiPlxuICAgICAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJnb0JhY2tcIiB0eXBlPVwiY2xlYXJcIiBpY29uPVwiYXJyb3dfYmFja1wiIHRvb2x0aXA9XCJCYWNrIHRvIE1pc3Npb25zXCJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC1wb3NpdGlvbj1cImJvdHRvbSBsZWZ0XCJcbiAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IHNsb3Q9XCJhY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJjbGVhcl9hbGxcIiB0b29sdGlwPVwiQ2xlYXIgYWxsXCIgQGNsaWNrPVwiY2xlYXJXYXlwb2ludHNcIlxuICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxuXG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIDppY29uPVwid2F5cG9pbnRzVmlzaWJsZSA/ICd2aXNpYmlsaXR5JyA6ICd2aXNpYmlsaXR5X29mZidcIlxuICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJ0b2dnbGVXYXlwb2ludFZpc2liaWxpdHlcIlxuICAgICAgICAgICAgICAgICAgICA6dG9vbHRpcD1cIndheXBvaW50c1Zpc2libGUgPyAnSGlkZSB3YXlwb2ludHMnIDogJ1Nob3cgd2F5cG9pbnRzJ1wiXG4gICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG5cbiAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNsZWFyXCIgaWNvbj1cIm1vcmVfdmVydFwiIGhhcy1kcm9wZG93bi1tZW51IGRyb3Bkb3duLXBvc2l0aW9uPVwiYm90dG9tIHJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgOm1lbnUtb3B0aW9ucz1cIm92ZXJmbG93TWVudVwiXG4gICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC91aS10b29sYmFyPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaWRlYmFyLXBhZ2UtY29udGVudFwiIHYtZWw6cGFnZS1jb250ZW50PlxuICAgICAgICAgICAgPHBcbiAgICAgICAgICAgICAgICBjbGFzcz1cIm5vLXdheXBvaW50c1wiIHYtaWY9XCIhbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXCJcbiAgICAgICAgICAgID5ObyB3YXlwb2ludHMgZm9yIHRoaXMgbWlzc2lvbi4gQ2xpY2sgdGhlIG1hcCB0byBhZGQgYSB3YXlwb2ludC48L3A+XG5cbiAgICAgICAgICAgIDxjb21wb25lbnQgdi1lbHNlPlxuICAgICAgICAgICAgICAgIDxnY3Mtd2F5cG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XCIoaW5kZXgsIHdheXBvaW50KSBpbiBtaXNzaW9uLndheXBvaW50c1wiIDppbmRleD1cImluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgOmxhYmVsPVwidG9MZXR0ZXIoaW5kZXggKyAxKVwiIDp0aXRsZT1cIndheXBvaW50LnRpdGxlXCIgOnR5cGU9XCJ3YXlwb2ludC50eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgOmxhdD1cIndheXBvaW50LnBvc2l0aW9uLmxhdFwiIDpsbmc9XCJ3YXlwb2ludC5wb3NpdGlvbi5sbmdcIiA6dmlzaWJsZT1cIndheXBvaW50LnZpc2libGVcIlxuICAgICAgICAgICAgICAgICAgICA6cm90YXRpb249XCJ3YXlwb2ludC5yb3RhdGlvblwiIDpzY2FsZT1cIjEwXCIgZHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgIEBkZWxldGU9XCJkZWxldGVXYXlwb2ludChpbmRleClcIlxuICAgICAgICAgICAgICAgID48L2djcy13YXlwb2ludD5cbiAgICAgICAgICAgICAgICA8Z2NzLXdheXBvaW50LWxpbmtcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XCIoaW5kZXgsIHdheXBvaW50KSBpbiBtaXNzaW9uLndheXBvaW50c1wiXG4gICAgICAgICAgICAgICAgICAgIDppbmRleD1cImluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgOnN0YXJ0PVwid2F5cG9pbnQucG9zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgICA6ZW5kPVwibWlzc2lvbi53YXlwb2ludHNbKGluZGV4KzEpICUgbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXS5wb3NpdGlvbjtcIlxuICAgICAgICAgICAgICAgID48L2djcy13YXlwb2ludC1saW5rPlxuICAgICAgICAgICAgPC9jb21wb25lbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBHY3NXYXlwb2ludCBmcm9tICdtYXJrZXJzL0djc1dheXBvaW50LnZ1ZSc7XG5pbXBvcnQgR2NzV2F5cG9pbnRMaW5rIGZyb20gJ21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZSc7XG5cbmltcG9ydCBlbGVtZW50IGZyb20gJ3V0aWwvZWxlbWVudC1zY3JvbGwnO1xuaW1wb3J0IG51bWJlclRvTGV0dGVyIGZyb20gJ3V0aWwvbnVtYmVyLXRvLWxldHRlcic7XG5cbmltcG9ydCB7IHNldE1hcEVkaXRpbmcgfSBmcm9tICdzdG9yZS9hY3Rpb25zJztcbmltcG9ydCB7IGdldE1hcEVkaXRpbmcgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHZ1ZXg6IHtcbiAgICAgICAgZ2V0dGVyczoge1xuICAgICAgICAgICAgbWFwRWRpdGluZzogZ2V0TWFwRWRpdGluZ1xuICAgICAgICB9LFxuXG4gICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgIHNldE1hcEVkaXRpbmdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgICBtaXNzaW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3YXlwb2ludHNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcmZsb3dNZW51OiBbXG4gICAgICAgICAgICAgICAgeyBpZDogJ2VkaXQnLCB0ZXh0OiAnRWRpdCBtaXNzaW9uJyB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6ICdkZWxldGUnLCB0ZXh0OiAnRGVsZXRlIG1pc3Npb24nIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuc2V0TWFwRWRpdGluZyh0cnVlKTtcbiAgICB9LFxuXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRNYXBFZGl0aW5nKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdtYXA6Y2xpY2snKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYXBFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbGF0ID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxhdCgpKS50b0ZpeGVkKDcpICk7XG4gICAgICAgICAgICBsZXQgbG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XG5cbiAgICAgICAgICAgIGxldCBuZXdXYXlwb2ludCA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhdCxcbiAgICAgICAgICAgICAgICAgICAgbG5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5taXNzaW9uLndheXBvaW50cy5wdXNoKG5ld1dheXBvaW50KTtcblxuICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIGJvdHRvbVxuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9FbmQodGhpcy4kZWxzLnBhZ2VDb250ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgICdtYXA6ZGJsY2xpY2snKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNYXAgZG91YmxlIGNsaWNrZWQnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbWFwOnJpZ2h0Y2xpY2snKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNYXAgcmlnaHQtY2xpY2tlZCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgICd3YXlwb2ludDpkcmFnJyhpbmRleCwgbGF0LCBsbmcpe1xuICAgICAgICAgICAgLy91cGRhdGUgd2F5cG9pbnQgcG9zaXRpb25zXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzW2luZGV4XS5wb3NpdGlvbi5sYXQgPSBsYXQ7XG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzW2luZGV4XS5wb3NpdGlvbi5sbmcgPSBsbmc7XG4gICAgICAgICAgICAvL3VwZGF0ZSB3YXlwb2ludCBsaW5rc1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd3YXlwb2ludExpbms6ZHJhZ19zdGFydCcsIGluZGV4LCBsYXQsIGxuZyk7XG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gKGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IHRoaXMubWlzc2lvbi53YXlwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3dheXBvaW50TGluazpkcmFnX2VuZCcsIG5leHRJbmRleCwgbGF0LCBsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgICd3YXlwb2ludExpbms6Y2xpY2snKGluZGV4LCBsYXQsIGxuZyl7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFwRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaW5zZXJ0IG5ldyB3YXlwb2ludFxuICAgICAgICAgICAgbGV0IG5ld1dheXBvaW50ID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgbGF0LFxuICAgICAgICAgICAgICAgICAgICBsbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5taXNzaW9uLndheXBvaW50cy5zcGxpY2UoaW5kZXgrMSwgMCwgbmV3V2F5cG9pbnQpO1xuICAgICAgICAgICAgLy8gVE9ETzogc2Nyb2xsIHRvIG5ldyB3YXlwb2ludD9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdvQmFjaygpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdnby1iYWNrJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9MZXR0ZXIobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyVG9MZXR0ZXIobnVtYmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVXYXlwb2ludFZpc2liaWxpdHkoKSB7XG4gICAgICAgICAgICB0aGlzLndheXBvaW50c1Zpc2libGUgPSAhdGhpcy53YXlwb2ludHNWaXNpYmxlO1xuXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzID0gdGhpcy5taXNzaW9uLndheXBvaW50cy5tYXAoKHdheXBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgd2F5cG9pbnQudmlzaWJsZSA9IHRoaXMud2F5cG9pbnRzVmlzaWJsZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB3YXlwb2ludDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNldE1hcEVkaXRpbmcodGhpcy53YXlwb2ludHNWaXNpYmxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVXYXlwb2ludChpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5taXNzaW9uLndheXBvaW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyV2F5cG9pbnRzKCkge1xuICAgICAgICAgICAgdGhpcy5taXNzaW9uLndheXBvaW50cyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLndheXBvaW50c1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRNYXBFZGl0aW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgR2NzV2F5cG9pbnQsXG4gICAgICAgIEdjc1dheXBvaW50TGlua1xuICAgIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XG5cbi5nY3MtbWlzc2lvbiB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgLnJvdyB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDRweDtcblxuICAgICAgICAmOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC51aS10b29sYmFyLWJyYW5kIHtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgIH1cblxuICAgIC5uby13YXlwb2ludHMge1xuICAgICAgICBmb250LXNpemU6IDAuOWVtO1xuICAgICAgICBjb2xvcjogIzc3NztcbiAgICAgICAgcGFkZGluZzogMTZweDtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNaXNzaW9uLnZ1ZT9lMjFkNTM1YVxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NXYXlwb2ludC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NXYXlwb2ludC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HY3NXYXlwb2ludC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL0djc1dheXBvaW50LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnQudnVlXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnQudnVlXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLXdheXBvaW50XCIgOmNsYXNzPVwieyAnaGlnaGxpZ2h0ZWQnOiAoZHJhZ2dpbmcgfHwgaGlnaGxpZ2h0ZWQpIH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm51bWJlclwiIHYtdGV4dD1cImluZGV4ICsgMVwiPjwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgPHVpLXRleHRib3hcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW5cIiBsYWJlbD1cIlRpdGxlXCIgbmFtZT1cInRpdGxlXCIgOnZhbHVlLnN5bmM9XCJ0aXRsZVwiXG4gICAgICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgPHVpLXRleHRib3hcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4gb25lLWhhbGZcIiBsYWJlbD1cIkxhdGl0dWRlXCIgbmFtZT1cImxhdGl0dWRlXCIgOnZhbHVlLnN5bmM9XCJsYXRcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCIgOnN0ZXA9XCIwLjAwMDAxXCJcbiAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxuXG4gICAgICAgICAgICAgICAgPHVpLXRleHRib3hcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4gb25lLWhhbGZcIiBsYWJlbD1cIkxvbmdpdHVkZVwiIG5hbWU9XCJsb25naXR1ZGVcIiA6dmFsdWUuc3luYz1cImxuZ1wiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIiA6c3RlcD1cIjAuMDAwMDFcIlxuICAgICAgICAgICAgICAgID48L3VpLXRleHRib3g+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgIDx1aS1zZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4gb25lLWhhbGZcIiBsYWJlbD1cIlR5cGVcIiBuYW1lPVwidHlwZVwiIDp2YWx1ZS5zeW5jPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgICAgIDpvcHRpb25zPVwiW3sgdGV4dDogJ05vcm1hbCcsIHZhbHVlOiAnbm9ybWFsJyB9XVwiIDpkZWZhdWx0PVwidHlwZVwiXG4gICAgICAgICAgICAgICAgPjwvdWktc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBpc01hcmtlciBmcm9tICdtaXhpbnMvaXMtbWFya2VyJztcbmltcG9ydCBlbGVtZW50IGZyb20gJ3V0aWwvZWxlbWVudC1zY3JvbGwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IHtcbiAgICAgICAgaW5kZXg6IE51bWJlcixcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGNvZXJjZTogU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBjb2VyY2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyBTdHJpbmcodmFsdWUpIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbGxDb2xvcjoge25vcm1hbDogJ3llbGxvdycsIGhvdmVyOiAnbGltZSd9LFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBldmVudHM6IHtcbiAgICAgICAgY2xpY2soKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHRoaXMuJGVsLCBudWxsLCA1Nik7IC8vIDU2cHggbWFyZ2luIGZvciBVaVRvb2xiYXJcbiAgICAgICAgfSxcblxuICAgICAgICByaWdodGNsaWNrKCkge1xuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RlbGV0ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWcoZSkge1xuICAgICAgICAgICAgdGhpcy5sYXQgPSBOdW1iZXIoIHBhcnNlRmxvYXQoZS5sYXRMbmcubGF0KCkpLnRvRml4ZWQoNykgKTtcbiAgICAgICAgICAgIHRoaXMubG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnd2F5cG9pbnQ6ZHJhZycsIHRoaXMuaW5kZXgsIHRoaXMubGF0LCB0aGlzLmxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdmVyKCkge1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpe1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldEljb24odGhpcy5nZXRJY29uKHRoaXMuZmlsbENvbG9yLmhvdmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdXQoKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgJiYgIXRoaXMuZHJhZ2dpbmcpe1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldEljb24odGhpcy5nZXRJY29uKHRoaXMuZmlsbENvbG9yLm5vcm1hbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdzdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZXRJY29uKGZpbGxDb2xvciA9IHRoaXMuZmlsbENvbG9yLm5vcm1hbCwgc2NhbGUgPSB0aGlzLnNjYWxlLCByb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aDogZ29vZ2xlLm1hcHMuU3ltYm9sUGF0aC5DSVJDTEUsXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIGlzTWFya2VyXG4gICAgXVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcblxuLmdjcy13YXlwb2ludCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwYWRkaW5nOiA4cHggMTJweDtcbiAgICBwYWRkaW5nLXRvcDogMTJweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMXMgZWFzZTtcblxuICAgICY6bm90KDpmaXJzdC1jaGlsZCkge1xuICAgICAgICBwYWRkaW5nLXRvcDogMThweDtcbiAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNEREQ7XG4gICAgfVxuXG4gICAgJi5oaWdobGlnaHRlZCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMzMsIDE1MCwgMjQzLCAwLjE1KTtcbiAgICB9XG5cbiAgICAubnVtYmVyIHtcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDE2cHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgbWluLXdpZHRoOiAyNHB4O1xuICAgIH1cblxuICAgIC5jb250ZW50IHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuICAgIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NXYXlwb2ludC52dWU/MTE3NDRhZjBcbiAqKi8iLCJpbXBvcnQgeyBnZXRNYXAsIGdldE1hcEVsLCBnZXRNYXBMb2FkZWQgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHZ1ZXg6IHtcbiAgICAgICAgZ2V0dGVyczoge1xuICAgICAgICAgICAgbWFwOiBnZXRNYXAsXG4gICAgICAgICAgICBtYXBFbDogZ2V0TWFwRWwsXG4gICAgICAgICAgICBtYXBMb2FkZWQ6IGdldE1hcExvYWRlZFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgICAgIGxhdDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbG5nOiAge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDZcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFya2VyOiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHBvc2l0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYXQ6IHRoaXMubGF0LFxuICAgICAgICAgICAgICAgIGxuZzogdGhpcy5sbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcExvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTWFya2VyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB0aGlzLm1hcmtlciA9IG51bGw7XG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG4gICAgICAgIG1hcExvYWRlZChuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAgICAgaWYgKCFvbGRWYWwgJiYgbmV3VmFsICYmICF0aGlzLm1hcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZU1hcmtlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1hcCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldE1hcCh0aGlzLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRUaXRsZSh0aGlzLnRpdGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsYWJlbCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldExhYmVsKHRoaXMubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvc2l0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmlzaWJsZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldFZpc2libGUodGhpcy52aXNpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnZ2FibGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXREcmFnZ2FibGUodGhpcy5kcmFnZ2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJvdGF0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJY29uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NhbGUoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUljb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXRpYWxpemVNYXJrZXIoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGljb246IHRoaXMuZ2V0SWNvbigpLFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdGhpcy5kcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgICAgICAgICAgIG1hcDogdGhpcy5tYXBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50aXRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldFRpdGxlKHRoaXMudGl0bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldExhYmVsKHRoaXMubGFiZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnaW5pdGlhbGl6ZWQnLCB0aGlzLm1hcmtlcik7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVJY29uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRJY29uKHRoaXMuZ2V0SWNvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cEV2ZW50cygpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWNrJywgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ2RibGNsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGJsY2xpY2snLCBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcigncmlnaHRjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3JpZ2h0Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignbW91c2VvdmVyJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbW91c2VvdmVyJywgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbW91c2VvdXQnLCBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZHJhZ3N0YXJ0JywgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ2RyYWcnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkcmFnJywgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ2RyYWdlbmQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkcmFnZW5kJywgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ3Bvc2l0aW9uX2NoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdwb3NpdGlvbl9jaGFuZ2VkJywgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9taXhpbnMvaXMtbWFya2VyLmpzXG4gKiovIiwiZXhwb3J0IGZ1bmN0aW9uIGluVmlldyhlbGVtZW50LCBjb250YWluZXIpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICBsZXQgdG9wID0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgbGV0IHBhcmVudFRvcCA9IGNvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgbGV0IGJvdHRvbSA9IHRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIGxldCBwYXJlbnRCb3R0b20gPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgcmV0dXJuIHRvcCA+PSBwYXJlbnRUb3AgJiYgYm90dG9tIDw9IHBhcmVudEJvdHRvbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIGNvbnRhaW5lciwgbWFyZ2luVG9wID0gMCkge1xuICAgIGlmICghZWxlbWVudCB8fCBpblZpZXcoZWxlbWVudCwgY29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcCAtIG1hcmdpblRvcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvU3RhcnQoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9FbmQoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluVmlldyxcbiAgICBzY3JvbGxJbnRvVmlldyxcbiAgICBzY3JvbGxUb1N0YXJ0LFxuICAgIHNjcm9sbFRvRW5kXG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdXRpbC9lbGVtZW50LXNjcm9sbC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3Mtd2F5cG9pbnRcXFwiIDpjbGFzcz1cXFwieyAnaGlnaGxpZ2h0ZWQnOiAoZHJhZ2dpbmcgfHwgaGlnaGxpZ2h0ZWQpIH1cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJudW1iZXJcXFwiIHYtdGV4dD1cXFwiaW5kZXggKyAxXFxcIj48L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2x1bW5cXFwiIGxhYmVsPVxcXCJUaXRsZVxcXCIgbmFtZT1cXFwidGl0bGVcXFwiIDp2YWx1ZS5zeW5jPVxcXCJ0aXRsZVxcXCJcXG4gICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2x1bW4gb25lLWhhbGZcXFwiIGxhYmVsPVxcXCJMYXRpdHVkZVxcXCIgbmFtZT1cXFwibGF0aXR1ZGVcXFwiIDp2YWx1ZS5zeW5jPVxcXCJsYXRcXFwiXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcIm51bWJlclxcXCIgOnN0ZXA9XFxcIjAuMDAwMDFcXFwiXFxuICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cXG5cXG4gICAgICAgICAgICA8dWktdGV4dGJveFxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwiY29sdW1uIG9uZS1oYWxmXFxcIiBsYWJlbD1cXFwiTG9uZ2l0dWRlXFxcIiBuYW1lPVxcXCJsb25naXR1ZGVcXFwiIDp2YWx1ZS5zeW5jPVxcXCJsbmdcXFwiXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcIm51bWJlclxcXCIgOnN0ZXA9XFxcIjAuMDAwMDFcXFwiXFxuICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICA8dWktc2VsZWN0XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2x1bW4gb25lLWhhbGZcXFwiIGxhYmVsPVxcXCJUeXBlXFxcIiBuYW1lPVxcXCJ0eXBlXFxcIiA6dmFsdWUuc3luYz1cXFwidHlwZVxcXCJcXG4gICAgICAgICAgICAgICAgOm9wdGlvbnM9XFxcIlt7IHRleHQ6ICdOb3JtYWwnLCB2YWx1ZTogJ25vcm1hbCcgfV1cXFwiIDpkZWZhdWx0PVxcXCJ0eXBlXFxcIlxcbiAgICAgICAgICAgID48L3VpLXNlbGVjdD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnQudnVlXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NXYXlwb2ludExpbmsudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzV2F5cG9pbnRMaW5rLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50TGluay52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HY3NXYXlwb2ludExpbmsudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9HY3NXYXlwb2ludExpbmsudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludExpbmsudnVlXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImdjcy13YXlwb2ludC1saW5rXCI+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgZ2V0TWFwLCBnZXRNYXBMb2FkZWQgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHZ1ZXg6IHtcbiAgICAgICAgZ2V0dGVyczoge1xuICAgICAgICAgICAgbWFwOiBnZXRNYXAsXG4gICAgICAgICAgICBtYXBMb2FkZWQ6IGdldE1hcExvYWRlZFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIGluZGV4OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5rOiBudWxsLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHtub3JtYWw6ICdibGFjaycsIGhvdmVyOiAnZ3JlZW4nfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVMaW5rKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5saW5rLnNldE1hcChudWxsKTtcbiAgICAgICAgdGhpcy5saW5rID0gbnVsbDtcbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgbWFwTG9hZGVkKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgICAgICBpZiAoIW9sZFZhbCAmJiBuZXdWYWwgJiYgIXRoaXMubGluaykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxpbmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLnNldE1hcCh0aGlzLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnQoKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmspe1xuICAgICAgICAgICAgICAgIHRoaXMubGluay5nZXRQYXRoKCkuc2V0QXQoMCwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh0aGlzLnN0YXJ0LmxhdCwgdGhpcy5zdGFydC5sbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmspe1xuICAgICAgICAgICAgICAgIHRoaXMubGluay5nZXRQYXRoKCkuc2V0QXQoMSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh0aGlzLmVuZC5sYXQsIHRoaXMuZW5kLmxuZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaW5pdGlhbGl6ZUxpbmsoKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmsgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUoe1xuICAgICAgICAgICAgICAgIHBhdGg6IFt0aGlzLnN0YXJ0LCB0aGlzLmVuZF0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3Iubm9ybWFsLFxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAzLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSxcbiAgICAgICAgICAgICAgICBtYXA6IHRoaXMubWFwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGluay5hZGRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYXQgPSBOdW1iZXIoIHBhcnNlRmxvYXQoZS5sYXRMbmcubGF0KCkpLnRvRml4ZWQoNykgKTtcbiAgICAgICAgICAgICAgICBsZXQgbG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3dheXBvaW50TGluazpjbGljaycsIHRoaXMuaW5kZXgsIGxhdCwgbG5nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5saW5rLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluayl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluay5zZXRPcHRpb25zKHtzdHJva2VDb2xvcjogdGhpcy5zdHJva2VDb2xvci5ob3Zlcn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5saW5rLmFkZExpc3RlbmVyKCdtb3VzZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rLnNldE9wdGlvbnMoe3N0cm9rZUNvbG9yOiB0aGlzLnN0cm9rZUNvbG9yLm5vcm1hbH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICAnd2F5cG9pbnRMaW5rOmRyYWdfc3RhcnQnKGluZGV4LCBsYXQsIGxuZyl7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IHtsYXQ6IGxhdCwgbG5nOiBsbmd9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3dheXBvaW50TGluazpkcmFnX2VuZCcoaW5kZXgsIGxhdCwgbG5nKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09IGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IHtsYXQ6IGxhdCwgbG5nOiBsbmd9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XG5cbi5nY3Mtd2F5cG9pbnQtbGluayB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NXYXlwb2ludExpbmsudnVlPzlhZjJiOTg4XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy13YXlwb2ludC1saW5rXFxcIj48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyID4gNTIpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICB9XG5cbiAgICBsZXQgYWxwaGFiZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoJycpO1xuXG4gICAgcmV0dXJuIGFscGhhYmV0W251bWJlciAtIDFdO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdXRpbC9udW1iZXItdG8tbGV0dGVyLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1taXNzaW9uXFxcIj5cXG4gICAgPHVpLXRvb2xiYXIgOnRpdGxlPVxcXCJtaXNzaW9uLnRpdGxlXFxcIiBoaWRlLW5hdi1pY29uIHNob3ctYnJhbmQgOnNob3ctYnJhbmQtZGl2aWRlcj1cXFwiZmFsc2VcXFwiPlxcbiAgICAgICAgPGRpdiBzbG90PVxcXCJicmFuZFxcXCI+XFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwiZ29CYWNrXFxcIiB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiYXJyb3dfYmFja1xcXCIgdG9vbHRpcD1cXFwiQmFjayB0byBNaXNzaW9uc1xcXCJcXG4gICAgICAgICAgICAgICAgdG9vbHRpcC1wb3NpdGlvbj1cXFwiYm90dG9tIGxlZnRcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgc2xvdD1cXFwiYWN0aW9uc1xcXCI+XFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNsZWFyXFxcIiBpY29uPVxcXCJjbGVhcl9hbGxcXFwiIHRvb2x0aXA9XFxcIkNsZWFyIGFsbFxcXCIgQGNsaWNrPVxcXCJjbGVhcldheXBvaW50c1xcXCJcXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIDppY29uPVxcXCJ3YXlwb2ludHNWaXNpYmxlID8gJ3Zpc2liaWxpdHknIDogJ3Zpc2liaWxpdHlfb2ZmJ1xcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJ0b2dnbGVXYXlwb2ludFZpc2liaWxpdHlcXFwiXFxuICAgICAgICAgICAgICAgIDp0b29sdGlwPVxcXCJ3YXlwb2ludHNWaXNpYmxlID8gJ0hpZGUgd2F5cG9pbnRzJyA6ICdTaG93IHdheXBvaW50cydcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNsZWFyXFxcIiBpY29uPVxcXCJtb3JlX3ZlcnRcXFwiIGhhcy1kcm9wZG93bi1tZW51IGRyb3Bkb3duLXBvc2l0aW9uPVxcXCJib3R0b20gcmlnaHRcXFwiXFxuICAgICAgICAgICAgICAgIDptZW51LW9wdGlvbnM9XFxcIm92ZXJmbG93TWVudVxcXCJcXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L3VpLXRvb2xiYXI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItcGFnZS1jb250ZW50XFxcIiB2LWVsOnBhZ2UtY29udGVudD5cXG4gICAgICAgIDxwXFxuICAgICAgICAgICAgY2xhc3M9XFxcIm5vLXdheXBvaW50c1xcXCIgdi1pZj1cXFwiIW1pc3Npb24ud2F5cG9pbnRzLmxlbmd0aFxcXCJcXG4gICAgICAgID5ObyB3YXlwb2ludHMgZm9yIHRoaXMgbWlzc2lvbi4gQ2xpY2sgdGhlIG1hcCB0byBhZGQgYSB3YXlwb2ludC48L3A+XFxuXFxuICAgICAgICA8Y29tcG9uZW50IHYtZWxzZT5cXG4gICAgICAgICAgICA8Z2NzLXdheXBvaW50XFxuICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIHdheXBvaW50KSBpbiBtaXNzaW9uLndheXBvaW50c1xcXCIgOmluZGV4PVxcXCJpbmRleFxcXCJcXG4gICAgICAgICAgICAgICAgOmxhYmVsPVxcXCJ0b0xldHRlcihpbmRleCArIDEpXFxcIiA6dGl0bGU9XFxcIndheXBvaW50LnRpdGxlXFxcIiA6dHlwZT1cXFwid2F5cG9pbnQudHlwZVxcXCJcXG4gICAgICAgICAgICAgICAgOmxhdD1cXFwid2F5cG9pbnQucG9zaXRpb24ubGF0XFxcIiA6bG5nPVxcXCJ3YXlwb2ludC5wb3NpdGlvbi5sbmdcXFwiIDp2aXNpYmxlPVxcXCJ3YXlwb2ludC52aXNpYmxlXFxcIlxcbiAgICAgICAgICAgICAgICA6cm90YXRpb249XFxcIndheXBvaW50LnJvdGF0aW9uXFxcIiA6c2NhbGU9XFxcIjEwXFxcIiBkcmFnZ2FibGVcXG4gICAgICAgICAgICAgICAgQGRlbGV0ZT1cXFwiZGVsZXRlV2F5cG9pbnQoaW5kZXgpXFxcIlxcbiAgICAgICAgICAgID48L2djcy13YXlwb2ludD5cXG4gICAgICAgICAgICA8Z2NzLXdheXBvaW50LWxpbmtcXG4gICAgICAgICAgICAgICAgdi1mb3I9XFxcIihpbmRleCwgd2F5cG9pbnQpIGluIG1pc3Npb24ud2F5cG9pbnRzXFxcIlxcbiAgICAgICAgICAgICAgICA6aW5kZXg9XFxcImluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICA6c3RhcnQ9XFxcIndheXBvaW50LnBvc2l0aW9uXFxcIlxcbiAgICAgICAgICAgICAgICA6ZW5kPVxcXCJtaXNzaW9uLndheXBvaW50c1soaW5kZXgrMSkgJSBtaXNzaW9uLndheXBvaW50cy5sZW5ndGhdLnBvc2l0aW9uO1xcXCJcXG4gICAgICAgICAgICA+PC9nY3Mtd2F5cG9pbnQtbGluaz5cXG4gICAgICAgIDwvY29tcG9uZW50PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWVcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01pc3Npb25Sb3cudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWlzc2lvblJvdy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01pc3Npb25Sb3cudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9HY3NNaXNzaW9uUm93LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImdjcy1taXNzaW9uLXJvd1wiPlxuICAgICAgICA8dWktaWNvbi1idXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJkZWxldGVcIiBjbGFzcz1cImRlbGV0ZS1idXR0b25cIiB0b29sdGlwPVwiRGVsZXRlXCIgQGNsaWNrPVwiZGVsZXRlTWlzc2lvblwiXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxuXG4gICAgICAgIDxoMyBjbGFzcz1cIm1pc3Npb24taGVhZGVyXCIgdi10ZXh0PVwibWlzc2lvbi50aXRsZVwiPjwvaDM+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1pc3Npb24tc3VtbWFyeVwiPlxuICAgICAgICAgICAgPHAgY2xhc3M9XCJkZXNjcmlwdGlvblwiIHYtaWY9XCJtaXNzaW9uLmRlc2NyaXB0aW9uXCIgdi10ZXh0PVwibWlzc2lvbi5kZXNjcmlwdGlvblwiPjwvcD5cblxuICAgICAgICAgICAgPHAgY2xhc3M9XCJ3YXlwb2ludHNcIiB2LWlmPVwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgaGFzV2F5cG9pbnRzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4+RnJvbTogKHt7IGZpcnN0V2F5cG9pbnQucG9zaXRpb24ubGF0IH19LCB7eyBmaXJzdFdheXBvaW50LnBvc2l0aW9uLmxuZyB9fSk8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4+VG86ICh7eyBsYXN0V2F5cG9pbnQucG9zaXRpb24ubGF0IH19LCB7eyBsYXN0V2F5cG9pbnQucG9zaXRpb24ubG5nIH19KTwvc3Bhbj5cbiAgICAgICAgICAgIDwvcD5cblxuICAgICAgICAgICAgPHAgY2xhc3M9XCJuby13YXlwb2ludHNcIiB2LWlmPVwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgIWhhc1dheXBvaW50c1wiPk5vIHdheXBvaW50czwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiB7XG4gICAgICAgIG1pc3Npb246IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGluZGV4OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGhhc1dheXBvaW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pc3Npb24ud2F5cG9pbnRzICYmIHRoaXMubWlzc2lvbi53YXlwb2ludHMubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcnN0V2F5cG9pbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taXNzaW9uLndheXBvaW50c1swXTtcbiAgICAgICAgfSxcblxuICAgICAgICBsYXN0V2F5cG9pbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taXNzaW9uLndheXBvaW50c1t0aGlzLm1pc3Npb24ud2F5cG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZGVsZXRlTWlzc2lvbigpe1xuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RlbGV0ZS1taXNzaW9uJywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLW1pc3Npb24tcm93IHtcbiAgICBwYWRkaW5nOiAxMnB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0VFRTtcblxuICAgICY6aG92ZXIsXG4gICAgJjpmb2N1cyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNFRUU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgcGFkZGluZy1yaWdodDogNDhweDtcblxuICAgICAgICAubWlzc2lvbi1oZWFkZXIge1xuICAgICAgICAgICAgY29sb3I6ICRwcmltYXJ5LWRhcmtlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kZWxldGUtYnV0dG9uIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLm1pc3Npb24taGVhZGVyIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgICAgICBmb250LXNpemU6IDEuMWVtO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgQGV4dGVuZHMgJHRydW5jYXRlLXRleHQ7XG4gICAgfVxuXG4gICAgLm1pc3Npb24tc3VtbWFyeSB7XG4gICAgICAgIHBhZGRpbmctdG9wOiA4cHg7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMC45ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgICAgICBjb2xvcjogIzc3NztcblxuICAgICAgICBwIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICBAZXh0ZW5kcyAkdHJ1bmNhdGUtdGV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5uby13YXlwb2ludHMge1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGNvbG9yOiAjQUFBO1xuICAgIH1cblxuICAgIC5kZWxldGUtYnV0dG9uIHtcbiAgICAgICAgcmlnaHQ6IDZweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBjb2xvcjogJGRhcmstc2Vjb25kYXJ5O1xuXG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgY29sb3I6ICRkYXJrLXByaW1hcnk7XG4gICAgICAgIH1cblxuICAgICAgICAudWktaWNvbiB7XG4gICAgICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIH1cbiAgICB9XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWlzc2lvblJvdy52dWU/MTc2YTQ2YTVcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLW1pc3Npb24tcm93XFxcIj5cXG4gICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiZGVsZXRlXFxcIiBjbGFzcz1cXFwiZGVsZXRlLWJ1dHRvblxcXCIgdG9vbHRpcD1cXFwiRGVsZXRlXFxcIiBAY2xpY2s9XFxcImRlbGV0ZU1pc3Npb25cXFwiXFxuICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICA8aDMgY2xhc3M9XFxcIm1pc3Npb24taGVhZGVyXFxcIiB2LXRleHQ9XFxcIm1pc3Npb24udGl0bGVcXFwiPjwvaDM+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcIm1pc3Npb24tc3VtbWFyeVxcXCI+XFxuICAgICAgICA8cCBjbGFzcz1cXFwiZGVzY3JpcHRpb25cXFwiIHYtaWY9XFxcIm1pc3Npb24uZGVzY3JpcHRpb25cXFwiIHYtdGV4dD1cXFwibWlzc2lvbi5kZXNjcmlwdGlvblxcXCI+PC9wPlxcblxcbiAgICAgICAgPHAgY2xhc3M9XFxcIndheXBvaW50c1xcXCIgdi1pZj1cXFwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgaGFzV2F5cG9pbnRzXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5Gcm9tOiAoe3sgZmlyc3RXYXlwb2ludC5wb3NpdGlvbi5sYXQgfX0sIHt7IGZpcnN0V2F5cG9pbnQucG9zaXRpb24ubG5nIH19KTwvc3Bhbj5cXG4gICAgICAgICAgICA8c3Bhbj5UbzogKHt7IGxhc3RXYXlwb2ludC5wb3NpdGlvbi5sYXQgfX0sIHt7IGxhc3RXYXlwb2ludC5wb3NpdGlvbi5sbmcgfX0pPC9zcGFuPlxcbiAgICAgICAgPC9wPlxcblxcbiAgICAgICAgPHAgY2xhc3M9XFxcIm5vLXdheXBvaW50c1xcXCIgdi1pZj1cXFwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgIWhhc1dheXBvaW50c1xcXCI+Tm8gd2F5cG9pbnRzPC9wPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1taXNzaW9uc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItcGFnZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtaXNzaW9ucy1saXN0XFxcIiB2LWlmPVxcXCJjdXJyZW50VmlldyA9PT0gJ2xpc3RpbmcnXFxcIj5cXG4gICAgICAgICAgICA8dWktdG9vbGJhciB0aXRsZT1cXFwiTWlzc2lvbnNcXFwiIGhpZGUtbmF2LWljb24+XFxuICAgICAgICAgICAgICAgIDxkaXYgc2xvdD1cXFwiYWN0aW9uc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiYWRkXFxcIiB0b29sdGlwPVxcXCJBZGQgbWlzc2lvblxcXCIgQGNsaWNrPVxcXCJhZGRNaXNzaW9uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwibW9yZV92ZXJ0XFxcIiBoYXMtZHJvcGRvd24tbWVudVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLXBvc2l0aW9uPVxcXCJib3R0b20gcmlnaHRcXFwiIDptZW51LW9wdGlvbnM9XFxcIm92ZXJmbG93TWVudVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XFxcIm1lbnVPcHRpb25TZWxlY3RlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L3VpLXRvb2xiYXI+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2lkZWJhci1wYWdlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibGFuay1zdGF0ZVxcXCIgdi1pZj1cXFwiIW1pc3Npb25zLmxlbmd0aFxcXCI+Tm8gbWlzc2lvbnM8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGdjcy1taXNzaW9uLXJvd1xcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XFxcIihpbmRleCwgbWlzc2lvbikgaW4gbWlzc2lvbnNcXFwiIDppbmRleD1cXFwiaW5kZXhcXFwiIDptaXNzaW9uPVxcXCJtaXNzaW9uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJzZWxlY3RNaXNzaW9uKGluZGV4KVxcXCJcXG4gICAgICAgICAgICAgICAgPjwvZ2NzLW1pc3Npb24tcm93PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8Y29tcG9uZW50XFxuICAgICAgICAgICAgdi1lbHNlIDppcz1cXFwiY3VycmVudFZpZXdcXFwiIDptaXNzaW9uPVxcXCJjdXJyZW50TWlzc2lvblxcXCIgQGdvLWJhY2s9XFxcInNob3dMaXN0aW5nVmlld1xcXCJcXG4gICAgICAgID48L2NvbXBvbmVudD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuPCEtLSBoaWRkZW4gaW5wdXQgZWxlbWVudCB1c2VkIGZvciBzZWxlY3RpbmcgYSBmaWxlIHRvIGltcG9ydCBmcm9tIC0tPlxcbjxpbnB1dCB0eXBlPVxcXCJmaWxlXFxcIiBpZD1cXFwiaW1wb3J0X21pc3Npb25zX2lucHV0XFxcIiBAY2hhbmdlPVxcXCJpbXBvcnRNaXNzaW9uXFxcIj5cXG48IS0tIGhpZGRlbiBsaW5rIHVzZWQgZm9yIHByb21wdGluZyBhIGRvd25sb2FkIC0tPlxcbjxhIGlkPVxcXCJleHBvcnRfbWlzc2lvbnNfbGlua1xcXCI+PC9hPlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1tYXAtc2lkZWJhclxcXCIgdi1zaG93PVxcXCJzaG93U2lkZWJhclxcXCIgdHJhbnNpdGlvbj1cXFwic2lkZWJhci1jb2xsYXBzZVxcXCI+XFxuICAgIDxnY3MtbWlzc2lvbnM+PC9nY3MtbWlzc2lvbnM+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwU2lkZWJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc1NpZGViYXJDb250cm9scy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NTaWRlYmFyQ29udHJvbHMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyYy9jb21wb25lbnRzL21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi4vR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiZ2NzLXNpZGViYXItY29udHJvbHNcIlxuICAgICAgICA6c3R5bGU9XCJ7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoJyArIChzaG93U2lkZWJhciA/ICczNzZweCcgOiAnMTZweCcgKyAnKScpIH1cIlxuICAgID5cbiAgICAgICAgPHVpLWJ1dHRvblxuICAgICAgICAgICAgOmNvbG9yPVwic2hvd1NpZGViYXIgPyAncHJpbWFyeScgOiAnZGVmYXVsdCdcIiBAY2xpY2s9XCJ0b2dnbGVTaWRlYmFyXCJcbiAgICAgICAgPk1pc3Npb25zPC91aS1idXR0b24+XG5cbiAgICAgICAgPHVpLWJ1dHRvbiB2LWlmPVwiY3VycmVudE1pc3Npb25JbmRleCAhPSAtMVwiIGhhcy1wb3BvdmVyIHRleHQ9XCJDb21tYW5kc1wiPlxuICAgICAgICAgICAgPGRpdiBzbG90PVwicG9wb3ZlclwiIGNsYXNzPVwiZ2NzLXNpZGViYXItY29udHJvbHMtcG9wb3ZlclwiPlxuICAgICAgICAgICAgICAgIDxnY3MtY29tbWFuZHM+PC9nY3MtY29tbWFuZHM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC91aS1idXR0b24+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEdjc0NvbW1hbmRzIGZyb20gJ21hcC9HY3NDb21tYW5kcy52dWUnO1xuaW1wb3J0IHsgZ2V0Q3VycmVudE1pc3Npb25JbmRleCB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdnVleDoge1xuICAgICAgICBnZXR0ZXJzOiB7XG4gICAgICAgICAgICBjdXJyZW50TWlzc2lvbkluZGV4OiBnZXRDdXJyZW50TWlzc2lvbkluZGV4XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgc2hvd1NpZGViYXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdG9nZ2xlU2lkZWJhcigpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCd0b2dnbGUtc2lkZWJhcicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgR2NzQ29tbWFuZHNcbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLXNpZGViYXItY29udHJvbHMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMTZweDtcbiAgICBsZWZ0OiAwO1xuICAgIHotaW5kZXg6IDE7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTZweCk7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNoYWRvdzogMCAycHggNXB4IDAgYWxwaGEoYmxhY2ssIDAuMiksIDAgMnB4IDEwcHggMCBhbHBoYShibGFjaywgMC4xNik7XG5cbiAgICAudWktYnV0dG9uIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI0NDQztcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xuXG4gICAgICAgIC51aS1idXR0b24tZHJvcGRvd24taWNvbiB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAtMnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgJi5jb2xvci1kZWZhdWx0Om5vdCguZHJvcGRvd24tb3Blbikge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICAgICAgfVxuXG4gICAgICAgICYuY29sb3ItcHJpbWFyeSB7XG4gICAgICAgICAgICBib3JkZXItcmlnaHQ6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICAmOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xuICAgICAgICB9XG4gICAgfVxufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc1NpZGViYXJDb250cm9scy52dWU/MDViYTIwM2FcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzQ29tbWFuZHMudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzQ29tbWFuZHMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HY3NDb21tYW5kcy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL0djc0NvbW1hbmRzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFwL0djc0NvbW1hbmRzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImdjcy1jb21tYW5kc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICA8dWktYnV0dG9uIEBjbGljaz1cInVwbG9hZE1pc3Npb25cIj5VcGxvYWQgTWlzc2lvbjwvdWktYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICA8dWktYnV0dG9uIEBjbGljaz1cImRvd25sb2FkTWlzc2lvblwiPkRvd25sb2FkIE1pc3Npb248L3VpLWJ1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPHVpLWJ1dHRvblxuICAgICAgICAgICAgICAgIHYtaWY9XCJ3YW12Lm1vZGUgPT0gJ2lkbGUnIHx8IHdhbXYubW9kZSA9PSAncGF1c2VkJ1wiXG4gICAgICAgICAgICAgICAgQGNsaWNrPVwic3RhcnRNaXNzaW9uXCJcbiAgICAgICAgICAgID5TdGFydDwvdWktYnV0dG9uPlxuICAgICAgICAgICAgPHVpLWJ1dHRvblxuICAgICAgICAgICAgICAgIHYtaWY9XCJ3YW12Lm1vZGUgPT0gJ3BhdXNlZCdcIlxuICAgICAgICAgICAgICAgIEBjbGljaz1cInJlc3VtZU1pc3Npb25cIlxuICAgICAgICAgICAgPlJlc3VtZTwvdWktYnV0dG9uPlxuICAgICAgICAgICAgPHVpLWJ1dHRvblxuICAgICAgICAgICAgICAgIHYtaWY9XCJ3YW12Lm1vZGUgPT0gJ2F1dG8nXCJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCJzdG9wTWlzc2lvblwiXG4gICAgICAgICAgICA+U3RvcDwvdWktYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCIgdi1pZj1cIndhbXYubG9hZGVkXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIG9uZS1oYWxmXCI+IHt7IGlzQXJtZWQgPyAnQXJtZWQnIDogJ0Rpc2FybWVkJyB9fTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtaGFsZlwiPlxuICAgICAgICAgICAgICAgIDx1aS1zd2l0Y2ggOnZhbHVlLnN5bmM9XCJpc0FybWVkXCI+PC91aS1zd2l0Y2g+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPHVpLWJ1dHRvbiBjb2xvcj1cImRhbmdlclwiXG4gICAgICAgICAgICAgICAgdi1pZj1cIndhbXYubW9kZSAhPSAna2lsbGVkJ1wiIEBjbGljaz1cImtpbGxcIlxuICAgICAgICAgICAgPktpbGw8L3VpLWJ1dHRvbj5cbiAgICAgICAgICAgIDx1aS1idXR0b25cbiAgICAgICAgICAgICAgICB2LWlmPVwid2Ftdi5tb2RlID09ICdraWxsZWQnXCIgQGNsaWNrPVwidW5raWxsXCJcbiAgICAgICAgICAgID5VbmtpbGw8L3VpLWJ1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtcbiAgICBnZXRXYW12LCBnZXRNaXNzaW9ucywgZ2V0Q3VycmVudE1pc3Npb25JbmRleCxcbiAgICBnZXRNZXNzYWdlU3RhdGVXYWl0aW5nLCBnZXRNZXNzYWdlU3RhdGVTdWNjZXNzLCBnZXRNZXNzYWdlU3RhdGVGYWlsdXJlLFxuICAgIGdldFVwbG9hZE1pc3Npb25TdGF0ZSwgZ2V0VXBsb2FkTWlzc2lvbkRhdGEsXG4gICAgZ2V0RG93bmxvYWRNaXNzaW9uU3RhdGUsIGdldERvd25sb2FkTWlzc2lvbkRhdGEsXG4gICAgZ2V0U3RhcnRNaXNzaW9uU3RhdGUsIGdldFN0YXJ0TWlzc2lvbkRhdGEsXG4gICAgZ2V0U3RvcE1pc3Npb25TdGF0ZSwgZ2V0U3RvcE1pc3Npb25EYXRhLFxuICAgIGdldFJlc3VtZU1pc3Npb25TdGF0ZSwgZ2V0UmVzdW1lTWlzc2lvbkRhdGEsXG4gICAgZ2V0QXJtU3RhdGUsIGdldEFybURhdGEsXG4gICAgZ2V0RGlzYXJtU3RhdGUsIGdldERpc2FybURhdGEsXG4gICAgZ2V0S2lsbFN0YXRlLCBnZXRLaWxsRGF0YSxcbiAgICBnZXRVbmtpbGxTdGF0ZSwgZ2V0VW5raWxsRGF0YVxufSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcbmltcG9ydCB7XG4gICAgc2V0V2FtdkFybWVkLCBzZXRDdXJyZW50TWlzc2lvbixcbiAgICBzZW5kVXBsb2FkTWlzc2lvbiwgZmFpbFVwbG9hZE1pc3Npb24sXG4gICAgc2VuZERvd25sb2FkTWlzc2lvbiwgZmFpbERvd25sb2FkTWlzc2lvbixcbiAgICBzZW5kU3RhcnRNaXNzaW9uLCBmYWlsU3RhcnRNaXNzaW9uLFxuICAgIHNlbmRTdG9wTWlzc2lvbiwgZmFpbFN0b3BNaXNzaW9uLFxuICAgIHNlbmRSZXN1bWVNaXNzaW9uLCBmYWlsUmVzdW1lTWlzc2lvbixcbiAgICBzZW5kQXJtLCBmYWlsQXJtLFxuICAgIHNlbmREaXNhcm0sIGZhaWxEaXNhcm0sXG4gICAgc2VuZEtpbGwsIGZhaWxLaWxsLFxuICAgIHNlbmRVbmtpbGwsIGZhaWxVbmtpbGxcbn0gZnJvbSAnc3RvcmUvYWN0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB2dWV4OiB7XG4gICAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgICAgIHdhbXY6ICAgICAgICAgICAgICAgICBnZXRXYW12LFxuICAgICAgICAgICAgbWlzc2lvbnM6ICAgICAgICAgICAgIGdldE1pc3Npb25zLFxuICAgICAgICAgICAgV0FJVElORzogICAgICAgICAgICAgIGdldE1lc3NhZ2VTdGF0ZVdhaXRpbmcsXG4gICAgICAgICAgICBTVUNDRVNTOiAgICAgICAgICAgICAgZ2V0TWVzc2FnZVN0YXRlU3VjY2VzcyxcbiAgICAgICAgICAgIEZBSUxVUkU6ICAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVGYWlsdXJlLFxuICAgICAgICAgICAgY3VycmVudE1pc3Npb25JbmRleDogIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgsXG4gICAgICAgICAgICB1cGxvYWRNaXNzaW9uU3RhdGU6ICAgZ2V0VXBsb2FkTWlzc2lvblN0YXRlLFxuICAgICAgICAgICAgdXBsb2FkTWlzc2lvbkRhdGE6ICAgIGdldFVwbG9hZE1pc3Npb25EYXRhLFxuICAgICAgICAgICAgZG93bmxvYWRNaXNzaW9uU3RhdGU6IGdldERvd25sb2FkTWlzc2lvblN0YXRlLFxuICAgICAgICAgICAgZG93bmxvYWRNaXNzaW9uRGF0YTogIGdldERvd25sb2FkTWlzc2lvbkRhdGEsXG4gICAgICAgICAgICBzdGFydE1pc3Npb25TdGF0ZTogICAgZ2V0U3RhcnRNaXNzaW9uU3RhdGUsXG4gICAgICAgICAgICBzdGFydE1pc3Npb25EYXRhOiAgICAgZ2V0U3RhcnRNaXNzaW9uRGF0YSxcbiAgICAgICAgICAgIHN0b3BNaXNzaW9uU3RhdGU6ICAgICBnZXRTdG9wTWlzc2lvblN0YXRlLFxuICAgICAgICAgICAgc3RvcE1pc3Npb25EYXRhOiAgICAgIGdldFN0b3BNaXNzaW9uRGF0YSxcbiAgICAgICAgICAgIHJlc3VtZU1pc3Npb25TdGF0ZTogICBnZXRSZXN1bWVNaXNzaW9uU3RhdGUsXG4gICAgICAgICAgICByZXN1bWVNaXNzaW9uRGF0YTogICAgZ2V0UmVzdW1lTWlzc2lvbkRhdGEsXG4gICAgICAgICAgICBhcm1TdGF0ZTogICAgICAgICAgICAgZ2V0QXJtU3RhdGUsXG4gICAgICAgICAgICBhcm1EYXRhOiAgICAgICAgICAgICAgZ2V0QXJtRGF0YSxcbiAgICAgICAgICAgIGRpc2FybVN0YXRlOiAgICAgICAgICBnZXREaXNhcm1TdGF0ZSxcbiAgICAgICAgICAgIGRpc2FybURhdGE6ICAgICAgICAgICBnZXREaXNhcm1EYXRhLFxuICAgICAgICAgICAga2lsbFN0YXRlOiAgICAgICAgICAgIGdldEtpbGxTdGF0ZSxcbiAgICAgICAgICAgIGtpbGxEYXRhOiAgICAgICAgICAgICBnZXRLaWxsRGF0YSxcbiAgICAgICAgICAgIHVua2lsbFN0YXRlOiAgICAgICAgICBnZXRVbmtpbGxTdGF0ZSxcbiAgICAgICAgICAgIHVua2lsbERhdGE6ICAgICAgICAgICBnZXRVbmtpbGxEYXRhLFxuICAgICAgICB9LFxuXG4gICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgIHNldEFybWVkOiBzZXRXYW12QXJtZWQsXG4gICAgICAgICAgICBzZXRDdXJyZW50TWlzc2lvbixcbiAgICAgICAgICAgIHNlbmRVcGxvYWRNaXNzaW9uLFxuICAgICAgICAgICAgZmFpbFVwbG9hZE1pc3Npb24sXG4gICAgICAgICAgICBzZW5kRG93bmxvYWRNaXNzaW9uLFxuICAgICAgICAgICAgZmFpbERvd25sb2FkTWlzc2lvbixcbiAgICAgICAgICAgIHNlbmRTdGFydE1pc3Npb24sXG4gICAgICAgICAgICBmYWlsU3RhcnRNaXNzaW9uLFxuICAgICAgICAgICAgc2VuZFN0b3BNaXNzaW9uLFxuICAgICAgICAgICAgZmFpbFN0b3BNaXNzaW9uLFxuICAgICAgICAgICAgc2VuZFJlc3VtZU1pc3Npb24sXG4gICAgICAgICAgICBmYWlsUmVzdW1lTWlzc2lvbixcbiAgICAgICAgICAgIHNlbmRBcm0sXG4gICAgICAgICAgICBmYWlsQXJtLFxuICAgICAgICAgICAgc2VuZERpc2FybSxcbiAgICAgICAgICAgIGZhaWxEaXNhcm0sXG4gICAgICAgICAgICBzZW5kS2lsbCxcbiAgICAgICAgICAgIGZhaWxLaWxsLFxuICAgICAgICAgICAgc2VuZFVua2lsbCxcbiAgICAgICAgICAgIGZhaWxVbmtpbGxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICAvLyBUT0RPOiB1aS1zd2l0Y2ggZG9lc24ndCByZXByZXNlbnQgc3RhdGUgd2hlbiBzZXQoKSBmYWlsc1xuICAgICAgICBpc0FybWVkOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Ftdi5hcm1lZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldChhcm0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJtKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQXJtKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJtU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxBcm0oJ1RpbWVvdXQgcmVhY2hlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kRGlzYXJtKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYXJtU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxEaXNhcm0oJ1RpbWVvdXQgcmVhY2hlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdXBsb2FkTWlzc2lvbigpIHtcbiAgICAgICAgICAgIGxldCBtaXNzaW9uID0gdGhpcy5taXNzaW9uc1t0aGlzLmN1cnJlbnRNaXNzaW9uSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZW5kVXBsb2FkTWlzc2lvbihtaXNzaW9uKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwbG9hZE1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxVcGxvYWRNaXNzaW9uKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd25sb2FkTWlzc2lvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZERvd25sb2FkTWlzc2lvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG93bmxvYWRNaXNzaW9uU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsRG93bmxvYWRNaXNzaW9uKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0TWlzc2lvbigpe1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhcnRNaXNzaW9uKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydE1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxTdGFydE1pc3Npb24oJ1RpbWVvdXQgcmVhY2hlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcE1pc3Npb24oKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0b3BNaXNzaW9uKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9wTWlzc2lvblN0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFN0b3BNaXNzaW9uKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZU1pc3Npb24oKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlc3VtZU1pc3Npb24oKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtZU1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxSZXN1bWVNaXNzaW9uKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGtpbGwoKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZEtpbGwoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtpbGxTdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxLaWxsKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVua2lsbCgpe1xuICAgICAgICAgICAgdGhpcy5zZW5kVW5raWxsKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bmtpbGxTdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxVbmtpbGwoJ1RpbWVvdXQgcmVhY2hlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuICAgICAgICB1cGxvYWRNaXNzaW9uU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7IC8vc3VjY2Vzc2Z1bCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2lvbiB1cGxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7IC8vZmFpbHVyZSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHVwbG9hZCBtaXNzaW9uOiAnICsgdGhpcy51cGxvYWRNaXNzaW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3dubG9hZE1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3Npb24gZG93bmxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlzc2lvbih0aGlzLmRvd25sb2FkTWlzc2lvbkRhdGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkb3dubG9hZCBtaXNzaW9uOiAnICsgdGhpcy5kb3dubG9hZE1pc3Npb25EYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0TWlzc2lvblN0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLlNVQ0NFU1Mpe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2lvbiBzdGFydGVkLicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBzdGFydCBtaXNzaW9uOiAnICsgdGhpcy5zdGFydE1pc3Npb25EYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BNaXNzaW9uU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW9uIHN0b3BwZWQuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLkZBSUxVUkUpe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHN0b3AgbWlzc2lvbjogJyArIHRoaXMuc3RvcE1pc3Npb25EYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZU1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3Npb24gcmVzdW1lZC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gcmVzdW1lIG1pc3Npb246ICcgKyB0aGlzLnJlc3VtZU1pc3Npb25EYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFybVN0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLlNVQ0NFU1Mpe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmVoaWNsZSBhcm1lZC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gYXJtIHZlaGljbGU6ICcgKyB0aGlzLmFybURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzYXJtU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdWZWhpY2xlIGRpc2FybWVkLicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkaXNhcm0gdmVoaWNsZTogJyArIHRoaXMuZGlzYXJtRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBraWxsU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdLaWxsIHN3aXRjaCBhY3RpdmF0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLkZBSUxVUkUpe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGFjdGl2YXRlIGtpbGwgc3dpdGNoOiAnICsgdGhpcy5raWxsRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmtpbGxTdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0tpbGwgc3dpdGNoIGRlYWN0aXZhdGVkLicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkZWFjdGl2YXRlIGtpbGwgc3dpdGNoOiAnICsgdGhpcy51bmtpbGxEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLWNvbW1hbmRzIHtcbiAgICBtaW4td2lkdGg6IDEwMHB4O1xuXG4gICAgLnJvdyB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcblxuICAgICAgICAmOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NDb21tYW5kcy52dWU/NmI4NWFlYjBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLWNvbW1hbmRzXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVxcXCJ1cGxvYWRNaXNzaW9uXFxcIj5VcGxvYWQgTWlzc2lvbjwvdWktYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVxcXCJkb3dubG9hZE1pc3Npb25cXFwiPkRvd25sb2FkIE1pc3Npb248L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgdi1pZj1cXFwid2Ftdi5tb2RlID09ICdpZGxlJyB8fCB3YW12Lm1vZGUgPT0gJ3BhdXNlZCdcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJzdGFydE1pc3Npb25cXFwiXFxuICAgICAgICA+U3RhcnQ8L3VpLWJ1dHRvbj5cXG4gICAgICAgIDx1aS1idXR0b25cXG4gICAgICAgICAgICB2LWlmPVxcXCJ3YW12Lm1vZGUgPT0gJ3BhdXNlZCdcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJyZXN1bWVNaXNzaW9uXFxcIlxcbiAgICAgICAgPlJlc3VtZTwvdWktYnV0dG9uPlxcbiAgICAgICAgPHVpLWJ1dHRvblxcbiAgICAgICAgICAgIHYtaWY9XFxcIndhbXYubW9kZSA9PSAnYXV0bydcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJzdG9wTWlzc2lvblxcXCJcXG4gICAgICAgID5TdG9wPC91aS1idXR0b24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHYtaWY9XFxcIndhbXYubG9hZGVkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbHVtbiBvbmUtaGFsZlxcXCI+IHt7IGlzQXJtZWQgPyAnQXJtZWQnIDogJ0Rpc2FybWVkJyB9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sdW1uIG9uZS1oYWxmXFxcIj5cXG4gICAgICAgICAgICA8dWktc3dpdGNoIDp2YWx1ZS5zeW5jPVxcXCJpc0FybWVkXFxcIj48L3VpLXN3aXRjaD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDx1aS1idXR0b24gY29sb3I9XFxcImRhbmdlclxcXCJcXG4gICAgICAgICAgICB2LWlmPVxcXCJ3YW12Lm1vZGUgIT0gJ2tpbGxlZCdcXFwiIEBjbGljaz1cXFwia2lsbFxcXCJcXG4gICAgICAgID5LaWxsPC91aS1idXR0b24+XFxuICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgdi1pZj1cXFwid2Ftdi5tb2RlID09ICdraWxsZWQnXFxcIiBAY2xpY2s9XFxcInVua2lsbFxcXCJcXG4gICAgICAgID5VbmtpbGw8L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJnY3Mtc2lkZWJhci1jb250cm9sc1xcXCJcXG4gICAgOnN0eWxlPVxcXCJ7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoJyArIChzaG93U2lkZWJhciA/ICczNzZweCcgOiAnMTZweCcgKyAnKScpIH1cXFwiXFxuPlxcbiAgICA8dWktYnV0dG9uXFxuICAgICAgICA6Y29sb3I9XFxcInNob3dTaWRlYmFyID8gJ3ByaW1hcnknIDogJ2RlZmF1bHQnXFxcIiBAY2xpY2s9XFxcInRvZ2dsZVNpZGViYXJcXFwiXFxuICAgID5NaXNzaW9uczwvdWktYnV0dG9uPlxcblxcbiAgICA8dWktYnV0dG9uIHYtaWY9XFxcImN1cnJlbnRNaXNzaW9uSW5kZXggIT0gLTFcXFwiIGhhcy1wb3BvdmVyIHRleHQ9XFxcIkNvbW1hbmRzXFxcIj5cXG4gICAgICAgIDxkaXYgc2xvdD1cXFwicG9wb3ZlclxcXCIgY2xhc3M9XFxcImdjcy1zaWRlYmFyLWNvbnRyb2xzLXBvcG92ZXJcXFwiPlxcbiAgICAgICAgICAgIDxnY3MtY29tbWFuZHM+PC9nY3MtY29tbWFuZHM+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC91aS1idXR0b24+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzV2Ftdi52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NXYW12LnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dhbXYudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzV2Ftdi52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL0djc1dhbXYudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dhbXYudnVlXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLXdhbXZcIj48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgaXNNYXJrZXIgZnJvbSAnbWl4aW5zL2lzLW1hcmtlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBldmVudHM6IHtcbiAgICAgICAgY2xpY2soZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dhbXYgY2xpY2tlZCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemVkKCkge1xuICAgICAgICAgICAgd2luZG93LndhbXYgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0SWNvbihzY2FsZSA9IHRoaXMuc2NhbGUsIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBnb29nbGUubWFwcy5TeW1ib2xQYXRoLkZPUldBUkRfQ0xPU0VEX0FSUk9XLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiAncmVkJyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgaXNNYXJrZXJcbiAgICBdXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLXdhbXYge1xuICAgIGRpc3BsYXk6IG5vbmU7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzV2Ftdi52dWU/NTQyOWNjMmJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLXdhbXZcXFwiPjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidmlldyBtYXAtdmlld1xcXCI+XFxuICAgIDxnY3MtbWFwPjwvZ2NzLW1hcD5cXG4gICAgPGdjcy1tYXAtY29udHJvbHM+PC9nY3MtbWFwLWNvbnRyb2xzPlxcbiAgICA8Z2NzLW1hcC1zaWRlYmFyIDpzaG93LXNpZGViYXI9XFxcInNob3dTaWRlYmFyXFxcIj48L2djcy1tYXAtc2lkZWJhcj5cXG5cXG4gICAgPGdjcy1zaWRlYmFyLWNvbnRyb2xzXFxuICAgICAgICA6c2hvdy1zaWRlYmFyPVxcXCJzaG93U2lkZWJhclxcXCIgQHRvZ2dsZS1zaWRlYmFyPVxcXCJ0b2dnbGVTaWRlYmFyXFxcIlxcbiAgICA+PC9nY3Mtc2lkZWJhci1jb250cm9scz5cXG5cXG4gICAgPGdjcy13YW12IHYtaWY9XFxcIndhbXYubG9hZGVkXFxcIlxcbiAgICAgICAgOmxhdD1cXFwid2Ftdi5wb3NpdGlvbi5sYXRcXFwiIDpsbmc9XFxcIndhbXYucG9zaXRpb24ubG5nXFxcIlxcbiAgICAgICAgOnJvdGF0aW9uPVxcXCJ3YW12LmhlYWRpbmdcXFwiXFxuICAgID48L2djcy13YW12PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BhcmFtc1ZpZXcudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vUGFyYW1zVmlldy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9QYXJhbXNWaWV3LnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi4vUGFyYW1zVmlldy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInZpZXcgcGFyYW1zLXZpZXdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2VcIj5cbiAgICAgICAgICAgIDxoMSBjbGFzcz1cInBhZ2UtaGVhZGVyXCI+UGFyYW1zPC9oMT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8IS0tIGRpc3BsYXkgcGFyYW1ldGVycyAodXAgdG8gaGllcmFyY2h5IGRlcHRoIDMpIC0tPlxuICAgICAgICAgICAgICAgIDxkaXYgdi1mb3I9XCIobmFtZSwgdmFsKSBpbiBwYXJhbWV0ZXJzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJpc0FycmF5KHZhbClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdi10ZXh0PVwibmFtZSArICcgKCcgKyB2YWxbMF0gKyAnKTogJyArIHZhbFsxXVwiXG4gICAgICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi1lbHNlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVwibmFtZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1mb3I9XCIobmFtZTIsIHZhbDIpIGluIHZhbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJpc0FycmF5KHZhbDIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi10ZXh0PVwiJz4gJyArIG5hbWUyICsgJyAoJyArIHZhbDJbMF0gKyAnKTogJyArIHZhbDJbMV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWVsc2U+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cIic+ICcgKyBuYW1lMlwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWZvcj1cIihuYW1lMywgdmFsMykgaW4gdmFsMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi1pZj1cImlzQXJyYXkodmFsMylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cIic+ID4gJyArIG5hbWUzICsgJyAoJyArIHZhbDNbMF0gKyAnKTogJyArIHZhbDNbMV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cIic+ID4gJyArIG5hbWUzICsgJzogLi4uJ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBnZXRQYXJhbWV0ZXJzIH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB2dWV4OiB7XG4gICAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnNcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaXNBcnJheSh4KXtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpOyAvL1Z1ZSBkb2Vzbid0IGxpa2UgaXQgaWYgSSB1c2UgdGhpcyBkaXJlY3RseVxuICAgICAgICB9XG4gICAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcblxuLnZpZXcucGFyYW1zLXZpZXcge1xuICAgIHBhZGRpbmc6IDI0cHg7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogUGFyYW1zVmlldy52dWU/NDY3OTFiZGJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidmlldyBwYXJhbXMtdmlld1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhZ2VcXFwiPlxcbiAgICAgICAgPGgxIGNsYXNzPVxcXCJwYWdlLWhlYWRlclxcXCI+UGFyYW1zPC9oMT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2UtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgPCEtLSBkaXNwbGF5IHBhcmFtZXRlcnMgKHVwIHRvIGhpZXJhcmNoeSBkZXB0aCAzKSAtLT5cXG4gICAgICAgICAgICA8ZGl2IHYtZm9yPVxcXCIobmFtZSwgdmFsKSBpbiBwYXJhbWV0ZXJzXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gdi1pZj1cXFwiaXNBcnJheSh2YWwpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJuYW1lICsgJyAoJyArIHZhbFswXSArICcpOiAnICsgdmFsWzFdXFxcIlxcbiAgICAgICAgICAgICAgICA+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8ZGl2IHYtZWxzZT5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cXFwibmFtZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWZvcj1cXFwiKG5hbWUyLCB2YWwyKSBpbiB2YWxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XFxcImlzQXJyYXkodmFsMilcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiJz4gJyArIG5hbWUyICsgJyAoJyArIHZhbDJbMF0gKyAnKTogJyArIHZhbDJbMV1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtZWxzZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCInPiAnICsgbmFtZTJcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWZvcj1cXFwiKG5hbWUzLCB2YWwzKSBpbiB2YWwyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XFxcImlzQXJyYXkodmFsMylcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi10ZXh0PVxcXCInPiA+ICcgKyBuYW1lMyArICcgKCcgKyB2YWwzWzBdICsgJyk6ICcgKyB2YWwzWzFdXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiJz4gPiAnICsgbmFtZTMgKyAnOiAuLi4nXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU2V0dGluZ3NWaWV3LnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1NldHRpbmdzVmlldy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NldHRpbmdzVmlldy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIuL1NldHRpbmdzVmlldy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy92aWV3cy9TZXR0aW5nc1ZpZXcudnVlXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJ2aWV3IHNldHRpbmdzLXZpZXdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2VcIj5cbiAgICAgICAgICAgIDxoMSBjbGFzcz1cInBhZ2UtaGVhZGVyXCI+U2V0dGluZ3M8L2gxPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtY29udGVudFwiPlxuICAgICAgICAgICAgICAgIFNldHRpbmdzIGhlcmVcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XG5cbi52aWV3LnNldHRpbmdzLXZpZXcge1xuICAgIHBhZGRpbmc6IDI0cHg7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogU2V0dGluZ3NWaWV3LnZ1ZT80YjJjM2QwOFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ2aWV3IHNldHRpbmdzLXZpZXdcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlXFxcIj5cXG4gICAgICAgIDxoMSBjbGFzcz1cXFwicGFnZS1oZWFkZXJcXFwiPlNldHRpbmdzPC9oMT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2UtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgU2V0dGluZ3MgaGVyZVxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzSW5kaWNhdG9ycy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NJbmRpY2F0b3JzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc0luZGljYXRvcnMudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9HY3NJbmRpY2F0b3JzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL0djc0luZGljYXRvcnMudnVlXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0djc0luZGljYXRvcnMudnVlXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8dWwgY2xhc3M9XCJnY3MtaW5kaWNhdG9yc1wiIHYtaWY9XCJ3YW12LmxvYWRlZFwiPlxuICAgICAgICA8bGkgY2xhc3M9XCJpbmRpY2F0b3IgaGVhZGluZ1wiPlxuICAgICAgICAgICAgPHVpLWljb25cbiAgICAgICAgICAgICAgICBpY29uPVwibmF2aWdhdGlvblwiIDpzdHlsZT1cInsgdHJhbnNmb3JtOiAncm90YXRlWignICsgd2Ftdi5oZWFkaW5nICsgJ2RlZyknIH1cIlxuICAgICAgICAgICAgPjwvdWktaWNvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmFsdWVcIiB2LWh0bWw9XCJoZWFkaW5nXCI+PC9zcGFuPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImluZGljYXRvciBzcGVlZFwiPlxuICAgICAgICAgICAgPHVpLWljb24gaWNvbj1cIm5ldHdvcmtfY2hlY2tcIj48L3VpLWljb24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCIgdi10ZXh0PVwic3BlZWRcIj48L3NwYW4+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPGxpIGNsYXNzPVwiaW5kaWNhdG9yIGJhdHRlcnlcIj5cbiAgICAgICAgICAgIDx1aS1pY29uIGljb249XCJiYXR0ZXJ5X2Z1bGxcIj48L3VpLWljb24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCIgdi10ZXh0PVwiYmF0dGVyeVwiPjwvc3Bhbj5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGkgY2xhc3M9XCJpbmRpY2F0b3Igc2lnbmFsXCI+XG4gICAgICAgICAgICA8dWktaWNvbiBpY29uPVwid2lmaVwiPjwvdWktaWNvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmFsdWVcIiB2LXRleHQ9XCJzaWduYWxcIj48L3NwYW4+XG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBnZXRXYW12IH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB2dWV4OiB7XG4gICAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXZcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBoZWFkaW5nKCkge1xuICAgICAgICAgICAgbGV0IGRlZyA9IE1hdGgucm91bmQodGhpcy53YW12LmhlYWRpbmcpOyAvLzAgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgIHJldHVybiBkZWcgKyAnJmRlZzsgJyArIHRoaXMuZGVncmVlVG9Ub0NhcmRpbmFsKHRoaXMud2Ftdi5oZWFkaW5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzcGVlZCgpIHtcbiAgICAgICAgICAgIGxldCBzcGQgPSBNYXRoLnJvdW5kKHRoaXMud2Ftdi5zcGVlZCoxMDApLzEwMDsgLy8yIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YW12LnNwZWVkICsgJyBLTVBIJztcbiAgICAgICAgfSxcblxuICAgICAgICBiYXR0ZXJ5KCkge1xuICAgICAgICAgICAgbGV0IHBlcmMgPSBNYXRoLnJvdW5kKHRoaXMud2Ftdi5iYXR0ZXJ5KjEwMCkvMTAwOyAvLzIgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgIHJldHVybiBwZXJjICsgJyUnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpZ25hbCgpIHtcbiAgICAgICAgICAgIGxldCBwZXJjID0gTWF0aC5yb3VuZCh0aGlzLndhbXYuc2lnbmFsKjEwMCkvMTAwOyAvLzIgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgIHJldHVybiBwZXJjICsgJyUnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZGVncmVlVG9Ub0NhcmRpbmFsKGRlZ3JlZSkge1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDIyLjUgfHwgZGVncmVlID49IDMzNy41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDY3LjUgfHwgZGVncmVlID49IDIyLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05FJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDExMi41IHx8IGRlZ3JlZSA+PSA2Ny41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdFJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDE1Ny41IHx8IGRlZ3JlZSA+PSAxMTIuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnU0UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMjAyLjUgfHwgZGVncmVlID49IDE1Ny41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDI0Ny41IHx8IGRlZ3JlZSA+PSAyMDIuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnU1cnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMjkyLjUgfHwgZGVncmVlID49IDI0Ny41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdXJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDMzNy41IHx8IGRlZ3JlZSA+PSAyOTIuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTlcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xuXG4uZ2NzLWluZGljYXRvcnMge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMTZweDtcbiAgICB0b3A6IDEycHg7XG4gICAgaGVpZ2h0OiAyNHB4O1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG5cbiAgICAuaW5kaWNhdG9yIHtcbiAgICAgICAgY29sb3I6IGFscGhhKHdoaXRlLCAwLjgpO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMThweDtcblxuICAgICAgICAmOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogMDtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5oZWFkaW5nIC51aS1pY29uIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAudWktaWNvbiB7XG4gICAgICAgIGNvbG9yOiBhbHBoYSh3aGl0ZSwgMC41KTtcbiAgICB9XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzSW5kaWNhdG9ycy52dWU/OTg2N2EyMzhcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPHVsIGNsYXNzPVxcXCJnY3MtaW5kaWNhdG9yc1xcXCIgdi1pZj1cXFwid2Ftdi5sb2FkZWRcXFwiPlxcbiAgICA8bGkgY2xhc3M9XFxcImluZGljYXRvciBoZWFkaW5nXFxcIj5cXG4gICAgICAgIDx1aS1pY29uXFxuICAgICAgICAgICAgaWNvbj1cXFwibmF2aWdhdGlvblxcXCIgOnN0eWxlPVxcXCJ7IHRyYW5zZm9ybTogJ3JvdGF0ZVooJyArIHdhbXYuaGVhZGluZyArICdkZWcpJyB9XFxcIlxcbiAgICAgICAgPjwvdWktaWNvbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2YWx1ZVxcXCIgdi1odG1sPVxcXCJoZWFkaW5nXFxcIj48L3NwYW4+XFxuICAgIDwvbGk+XFxuXFxuICAgIDxsaSBjbGFzcz1cXFwiaW5kaWNhdG9yIHNwZWVkXFxcIj5cXG4gICAgICAgIDx1aS1pY29uIGljb249XFxcIm5ldHdvcmtfY2hlY2tcXFwiPjwvdWktaWNvbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2YWx1ZVxcXCIgdi10ZXh0PVxcXCJzcGVlZFxcXCI+PC9zcGFuPlxcbiAgICA8L2xpPlxcblxcbiAgICA8bGkgY2xhc3M9XFxcImluZGljYXRvciBiYXR0ZXJ5XFxcIj5cXG4gICAgICAgIDx1aS1pY29uIGljb249XFxcImJhdHRlcnlfZnVsbFxcXCI+PC91aS1pY29uPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZhbHVlXFxcIiB2LXRleHQ9XFxcImJhdHRlcnlcXFwiPjwvc3Bhbj5cXG4gICAgPC9saT5cXG5cXG4gICAgPGxpIGNsYXNzPVxcXCJpbmRpY2F0b3Igc2lnbmFsXFxcIj5cXG4gICAgICAgIDx1aS1pY29uIGljb249XFxcIndpZmlcXFwiPjwvdWktaWNvbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2YWx1ZVxcXCIgdi10ZXh0PVxcXCJzaWduYWxcXFwiPjwvc3Bhbj5cXG4gICAgPC9saT5cXG48L3VsPlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvR2NzSW5kaWNhdG9ycy52dWVcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1NvY2tldElvTWFuYWdlci52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9Tb2NrZXRJb01hbmFnZXIudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyYy9jb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9Tb2NrZXRJb01hbmFnZXIudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiLi9Tb2NrZXRJb01hbmFnZXIudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvU29ja2V0SW9NYW5hZ2VyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9Tb2NrZXRJb01hbmFnZXIudnVlXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2PjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBzb2NrZXRfaW9fY2xpZW50IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuXG5pbXBvcnQge1xuICAgIHNldFdhbXYsIHNldFBhcmFtZXRlcnMsXG4gICAgc2VuZEdldFBhcmFtZXRlcnMsIHN1Y2NlZWRHZXRQYXJhbWV0ZXJzLCBmYWlsR2V0UGFyYW1ldGVycyxcbiAgICBzZW5kTG9hZE1pc3Npb25zLCAgc3VjY2VlZExvYWRNaXNzaW9ucywgIGZhaWxMb2FkTWlzc2lvbnMsXG4gICAgc3VjY2VlZFNhdmVNaXNzaW9ucywgICAgZmFpbFNhdmVNaXNzaW9ucyxcbiAgICBzdWNjZWVkVXBsb2FkTWlzc2lvbiwgICBmYWlsVXBsb2FkTWlzc2lvbixcbiAgICBzdWNjZWVkRG93bmxvYWRNaXNzaW9uLCBmYWlsRG93bmxvYWRNaXNzaW9uLFxuICAgIHN1Y2NlZWRTdGFydE1pc3Npb24sICAgIGZhaWxTdGFydE1pc3Npb24sXG4gICAgc3VjY2VlZFN0b3BNaXNzaW9uLCAgICAgZmFpbFN0b3BNaXNzaW9uLFxuICAgIHN1Y2NlZWRSZXN1bWVNaXNzaW9uLCAgIGZhaWxSZXN1bWVNaXNzaW9uLFxuICAgIHN1Y2NlZWRBcm0sICAgICAgICAgICAgIGZhaWxBcm0sXG4gICAgc3VjY2VlZERpc2FybSwgICAgICAgICAgZmFpbERpc2FybSxcbiAgICBzdWNjZWVkS2lsbCwgICAgICAgICAgICBmYWlsS2lsbCxcbiAgICBzdWNjZWVkVW5raWxsLCAgICAgICAgICBmYWlsVW5raWxsXG59IGZyb20gJ3N0b3JlL2FjdGlvbnMnO1xuaW1wb3J0IHtcbiAgICBnZXRNZXNzYWdlU3RhdGVXYWl0aW5nLCBnZXRNZXNzYWdlU3RhdGVTdWNjZXNzLCBnZXRNZXNzYWdlU3RhdGVGYWlsdXJlLFxuICAgIGdldEdldFBhcmFtZXRlclN0YXRlLCAgICBnZXRHZXRQYXJhbWV0ZXJEYXRhLFxuICAgIGdldFNhdmVNaXNzaW9uc1N0YXRlLCAgICBnZXRTYXZlTWlzc2lvbnNEYXRhLFxuICAgIGdldExvYWRNaXNzaW9uc1N0YXRlLCAgICBnZXRMb2FkTWlzc2lvbnNEYXRhLFxuICAgIGdldFVwbG9hZE1pc3Npb25TdGF0ZSwgICBnZXRVcGxvYWRNaXNzaW9uRGF0YSxcbiAgICBnZXREb3dubG9hZE1pc3Npb25TdGF0ZSwgZ2V0RG93bmxvYWRNaXNzaW9uRGF0YSxcbiAgICBnZXRTdGFydE1pc3Npb25TdGF0ZSwgICAgZ2V0U3RhcnRNaXNzaW9uRGF0YSxcbiAgICBnZXRTdG9wTWlzc2lvblN0YXRlLCAgICAgZ2V0U3RvcE1pc3Npb25EYXRhLFxuICAgIGdldFJlc3VtZU1pc3Npb25TdGF0ZSwgICBnZXRSZXN1bWVNaXNzaW9uRGF0YSxcbiAgICBnZXRBcm1TdGF0ZSwgICAgICAgICAgICAgZ2V0QXJtRGF0YSxcbiAgICBnZXREaXNhcm1TdGF0ZSwgICAgICAgICAgZ2V0RGlzYXJtRGF0YSxcbiAgICBnZXRLaWxsU3RhdGUsICAgICAgICAgICAgZ2V0S2lsbERhdGEsXG4gICAgZ2V0VW5raWxsU3RhdGUsICAgICAgICAgIGdldFVua2lsbERhdGFcbn0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB2dWV4OiB7XG4gICAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgICAgIFdBSVRJTkc6ICAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVXYWl0aW5nLFxuICAgICAgICAgICAgU1VDQ0VTUzogICAgICAgICAgICAgIGdldE1lc3NhZ2VTdGF0ZVN1Y2Nlc3MsXG4gICAgICAgICAgICBGQUlMVVJFOiAgICAgICAgICAgICAgZ2V0TWVzc2FnZVN0YXRlRmFpbHVyZSxcbiAgICAgICAgICAgIGdldFBhcmFtZXRlclN0YXRlOiAgICBnZXRHZXRQYXJhbWV0ZXJTdGF0ZSxcbiAgICAgICAgICAgIGdldFBhcmFtZXRlckRhdGE6ICAgICBnZXRHZXRQYXJhbWV0ZXJEYXRhLFxuICAgICAgICAgICAgc2F2ZU1pc3Npb25zU3RhdGU6ICAgIGdldFNhdmVNaXNzaW9uc1N0YXRlLFxuICAgICAgICAgICAgc2F2ZU1pc3Npb25zRGF0YTogICAgIGdldFNhdmVNaXNzaW9uc0RhdGEsXG4gICAgICAgICAgICBsb2FkTWlzc2lvbnNTdGF0ZTogICAgZ2V0TG9hZE1pc3Npb25zU3RhdGUsXG4gICAgICAgICAgICBsb2FkTWlzc2lvbnNEYXRhOiAgICAgZ2V0TG9hZE1pc3Npb25zRGF0YSxcbiAgICAgICAgICAgIHVwbG9hZE1pc3Npb25TdGF0ZTogICBnZXRVcGxvYWRNaXNzaW9uU3RhdGUsXG4gICAgICAgICAgICB1cGxvYWRNaXNzaW9uRGF0YTogICAgZ2V0VXBsb2FkTWlzc2lvbkRhdGEsXG4gICAgICAgICAgICBkb3dubG9hZE1pc3Npb25TdGF0ZTogZ2V0RG93bmxvYWRNaXNzaW9uU3RhdGUsXG4gICAgICAgICAgICBkb3dubG9hZE1pc3Npb25EYXRhOiAgZ2V0RG93bmxvYWRNaXNzaW9uRGF0YSxcbiAgICAgICAgICAgIHN0YXJ0TWlzc2lvblN0YXRlOiAgICBnZXRTdGFydE1pc3Npb25TdGF0ZSxcbiAgICAgICAgICAgIHN0YXJ0TWlzc2lvbkRhdGE6ICAgICBnZXRTdGFydE1pc3Npb25EYXRhLFxuICAgICAgICAgICAgc3RvcE1pc3Npb25TdGF0ZTogICAgIGdldFN0b3BNaXNzaW9uU3RhdGUsXG4gICAgICAgICAgICBzdG9wTWlzc2lvbkRhdGE6ICAgICAgZ2V0U3RvcE1pc3Npb25EYXRhLFxuICAgICAgICAgICAgcmVzdW1lTWlzc2lvblN0YXRlOiAgIGdldFJlc3VtZU1pc3Npb25TdGF0ZSxcbiAgICAgICAgICAgIHJlc3VtZU1pc3Npb25EYXRhOiAgICBnZXRSZXN1bWVNaXNzaW9uRGF0YSxcbiAgICAgICAgICAgIGFybVN0YXRlOiAgICAgICAgICAgICBnZXRBcm1TdGF0ZSxcbiAgICAgICAgICAgIGFybURhdGE6ICAgICAgICAgICAgICBnZXRBcm1EYXRhLFxuICAgICAgICAgICAgZGlzYXJtU3RhdGU6ICAgICAgICAgIGdldERpc2FybVN0YXRlLFxuICAgICAgICAgICAgZGlzYXJtRGF0YTogICAgICAgICAgIGdldERpc2FybURhdGEsXG4gICAgICAgICAgICBraWxsU3RhdGU6ICAgICAgICAgICAgZ2V0S2lsbFN0YXRlLFxuICAgICAgICAgICAga2lsbERhdGE6ICAgICAgICAgICAgIGdldEtpbGxEYXRhLFxuICAgICAgICAgICAgdW5raWxsU3RhdGU6ICAgICAgICAgIGdldFVua2lsbFN0YXRlLFxuICAgICAgICAgICAgdW5raWxsRGF0YTogICAgICAgICAgIGdldFVua2lsbERhdGFcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgc2V0V2FtdixcbiAgICAgICAgICAgIHNldFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzZW5kR2V0UGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN1Y2NlZWRHZXRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgZmFpbEdldFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdWNjZWVkTG9hZE1pc3Npb25zLFxuICAgICAgICAgICAgc2VuZExvYWRNaXNzaW9ucyxcbiAgICAgICAgICAgIGZhaWxMb2FkTWlzc2lvbnMsXG4gICAgICAgICAgICBzdWNjZWVkU2F2ZU1pc3Npb25zLFxuICAgICAgICAgICAgZmFpbFNhdmVNaXNzaW9ucyxcbiAgICAgICAgICAgIHN1Y2NlZWRVcGxvYWRNaXNzaW9uLFxuICAgICAgICAgICAgZmFpbFVwbG9hZE1pc3Npb24sXG4gICAgICAgICAgICBzdWNjZWVkRG93bmxvYWRNaXNzaW9uLFxuICAgICAgICAgICAgZmFpbERvd25sb2FkTWlzc2lvbixcbiAgICAgICAgICAgIHN1Y2NlZWRTdGFydE1pc3Npb24sXG4gICAgICAgICAgICBmYWlsU3RhcnRNaXNzaW9uLFxuICAgICAgICAgICAgc3VjY2VlZFN0b3BNaXNzaW9uLFxuICAgICAgICAgICAgZmFpbFN0b3BNaXNzaW9uLFxuICAgICAgICAgICAgc3VjY2VlZFJlc3VtZU1pc3Npb24sXG4gICAgICAgICAgICBmYWlsUmVzdW1lTWlzc2lvbixcbiAgICAgICAgICAgIHN1Y2NlZWRBcm0sXG4gICAgICAgICAgICBmYWlsQXJtLFxuICAgICAgICAgICAgc3VjY2VlZERpc2FybSxcbiAgICAgICAgICAgIGZhaWxEaXNhcm0sXG4gICAgICAgICAgICBzdWNjZWVkS2lsbCxcbiAgICAgICAgICAgIGZhaWxLaWxsLFxuICAgICAgICAgICAgc3VjY2VlZFVua2lsbCxcbiAgICAgICAgICAgIGZhaWxVbmtpbGxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc29ja2V0OiBudWxsIC8vdXNlZCBmb3Igc29ja2V0LmlvIGNvbm5lY3Rpb25cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIC8vaW5pdGlhbGlzZSBzb2NrZXRcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRfaW9fY2xpZW50KCdsb2NhbGhvc3Q6MzAwMCcpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQgdG8gc2VydmVyJylcbiAgICAgICAgICAgIC8vZ2V0IHBhcmFtZXRlcnMgb25jZSBhdCBzdGFydHVwXG4gICAgICAgICAgICB0aGlzLnNlbmRHZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQYXJhbWV0ZXJTdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxHZXRQYXJhbWV0ZXJzKCdUaW1lb3V0IHJlYWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAvL2xvYWQgbWlzc2lvbnMgb25jZSBhdCBzdGFydHVwXG4gICAgICAgICAgICB0aGlzLnNlbmRMb2FkTWlzc2lvbnMoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRNaXNzaW9uc1N0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbExvYWRNaXNzaW9ucygnVGltZW91dCByZWFjaGVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdGVkIGZyb20gc2VydmVyJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbignc3RhdHVzJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlY2VpdmVkIFwic3RhdHVzXCIgbWVzc2FnZScpO1xuICAgICAgICAgICAgZGF0YS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRXYW12KGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2dldF9wYXJhbWV0ZXJzJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNlaXZlZCBcImdldF9wYXJhbWV0ZXJzXCIgbWVzc2FnZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFyYW1ldGVyU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWRHZXRQYXJhbWV0ZXJzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2xvYWRfbWlzc2lvbnMnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmVkIFwibG9hZF9taXNzaW9uc1wiIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRNaXNzaW9uc1N0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZWVkTG9hZE1pc3Npb25zKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2Rvd25sb2FkX21pc3Npb24nLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmVkIFwiZG93bmxvYWRfbWlzc2lvblwiIG1lc3NhZ2U6Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb3dubG9hZE1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2VlZERvd25sb2FkTWlzc2lvbihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKCdzdWNjZXNzJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNlaXZlZCBcInN1Y2Nlc3NcIiBtZXNzYWdlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PSAnc2F2ZV9taXNzaW9ucycgJiYgdGhpcy5zYXZlTWlzc2lvbnNTdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2VlZFNhdmVNaXNzaW9ucygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhID09ICd1cGxvYWRfbWlzc2lvbicgJiYgdGhpcy51cGxvYWRNaXNzaW9uU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWRVcGxvYWRNaXNzaW9uKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gJ3N0YXJ0X21pc3Npb24nICYmIHRoaXMuc3RhcnRNaXNzaW9uU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWRTdGFydE1pc3Npb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PSAnc3RvcF9taXNzaW9uJyAmJiB0aGlzLnN0b3BNaXNzaW9uU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWRTdG9wTWlzc2lvbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhID09ICdyZXN1bWVfbWlzc2lvbicgJiYgdGhpcy5yZXN1bWVNaXNzaW9uU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWRSZXN1bWVNaXNzaW9uKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gJ2FybScgJiYgdGhpcy5hcm1TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2VlZEFybSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhID09ICdkaXNhcm0nICYmIHRoaXMuZGlzYXJtU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWREaXNhcm0oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PSAna2lsbCcgJiYgdGhpcy5raWxsU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2NlZWRLaWxsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gJ3Vua2lsbCcgJiYgdGhpcy51bmtpbGxTdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2VlZFVua2lsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2ZhaWx1cmUnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmVkIFwiZmFpbHVyZVwiIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YVswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ2V0X3BhcmFtZXRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbEdldFBhcmFtZXRlcnMoZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzYXZlX21pc3Npb25zJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxTYXZlTWlzc2lvbnMoZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsb2FkX21pc3Npb25zJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxMb2FkTWlzc2lvbnMoZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd1cGxvYWRfbWlzc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVXBsb2FkTWlzc2lvbihkYXRhWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rvd25sb2FkX21pc3Npb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbERvd25sb2FkTWlzc2lvbihkYXRhWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0X21pc3Npb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFN0YXJ0TWlzc2lvbihkYXRhWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0b3BfbWlzc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsU3RvcE1pc3Npb24oZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdyZXN1bWVfbWlzc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsUmVzdW1lTWlzc2lvbihkYXRhWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2FybSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsQXJtKGRhdGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzYXJtJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxEaXNhcm0oZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdraWxsJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxLaWxsKGRhdGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndW5raWxsJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxVbmtpbGwoZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKCdhdHRlbnRpb24nLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVudGlvbjogJyArIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgZ2V0UGFyYW1ldGVyU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgZ2V0X3BhcmFtZXRlciBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLldBSVRJTkcpeyAvL3NlbmQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdnZXRfcGFyYW1ldGVycycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXsgLy9zdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVycyh0aGlzLmdldFBhcmFtZXRlckRhdGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXsgLy9mYWlsdXJlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gZ2V0IHBhcmFtZXRlcnM6ICcgKyB0aGlzLmdldFBhcmFtZXRlckRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlTWlzc2lvbnNTdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnc2F2ZV9taXNzaW9ucycsIHRoaXMuc2F2ZU1pc3Npb25zRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWRNaXNzaW9uc1N0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdsb2FkX21pc3Npb25zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwbG9hZE1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgndXBsb2FkX21pc3Npb24nLCB0aGlzLnVwbG9hZE1pc3Npb25EYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG93bmxvYWRNaXNzaW9uU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ2Rvd25sb2FkX21pc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRNaXNzaW9uU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ3N0YXJ0X21pc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RvcE1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnc3RvcF9taXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3VtZU1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgncmVzdW1lX21pc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJtU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuV0FJVElORyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ2FybScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhcm1TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnZGlzYXJtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGtpbGxTdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgna2lsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmtpbGxTdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgndW5raWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuQGltcG9ydCAnfnN0eWxlcy9tYWluJztcbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBTb2NrZXRJb01hbmFnZXIudnVlPzc1MzUxMDVlXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gICAgdmFyIHNyYyA9IHN0cixcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxuICAgICAgICB1cmkgPSB7fSxcbiAgICAgICAgaSA9IDE0O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L3BhcnNldXJpL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9kZWJ1Zy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2RlYnVnL2RlYnVnLmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9kZWJ1Zy9+L21zL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbi8qKlxuICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbnNwID0gZmFsc2U7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICBzdHIgKz0gb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuICAgIHN0ciArPSAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT0gb2JqLm5zcCkge1xuICAgIG5zcCA9IHRydWU7XG4gICAgc3RyICs9IG9iai5uc3A7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgaWYgKG5zcCkge1xuICAgICAgc3RyICs9ICcsJztcbiAgICAgIG5zcCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgaWYgKG5zcCkgc3RyICs9ICcsJztcbiAgICBzdHIgKz0ganNvbi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICB9XG5cbiAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBwID0ge307XG4gIHZhciBpID0gMDtcblxuICAvLyBsb29rIHVwIHR5cGVcbiAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB0cnkge1xuICAgICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcidcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL34vanNvbjMvbGliL2pzb24zLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L3NvY2tldC5pby1wYXJzZXIvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGZuKXtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlIC0gdGhpcy5sYXN0UGluZyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbihuc3Ape1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3ApO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldm5ldCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihzb2NrZXQpe1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24oZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3ViO1xuICB3aGlsZSAoc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCkpIHN1Yi5kZXN0cm95KCk7XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbihlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSAgcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IHJlcXVpcmUoJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZignZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoKGUpIHsgfVxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9oYXMtY29ycy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKXt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSKG9wdHMpe1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgdWk4QXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpO1xuICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh1aThBcnJbaWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2hhcy1iaW5hcnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2hhcy1iaW5hcnkvfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9hZnRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL34vdXRmOC91dGY4LmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2Jsb2IvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L3BhcnNlcXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG4gICwgbGVuZ3RoID0gNjRcbiAgLCBtYXAgPSB7fVxuICAsIHNlZWQgPSAwXG4gICwgaSA9IDBcbiAgLCBwcmV2O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgZG8ge1xuICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArJy4nKyBlbmNvZGUoc2VlZCsrKTtcbn1cblxuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG4vL1xueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34veWVhc3QvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBDYWxsYmFja3MgY291bnQuXG4gKi9cblxudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBcbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xudmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cblxuICB0aGlzLndzID0gQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2J1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIUJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy90aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiB3cyAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vaW5kZXhvZi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBKU09OIHBhcnNlLlxuICpcbiAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG52YXIgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xudmFyIHJ0cmltUmlnaHQgPSAvXFxzKyQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3RcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgfVxuXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9wYXJzZWpzb24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCl7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPSB0aGlzLm5zcCkge1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBpZiAocGFja2V0Lm5zcCAhPSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24oaWQpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24oY29tcHJlc3Mpe1xuICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXVxuXG4gICAgaW5kZXggPSBpbmRleCB8fCAwXG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi90by1hcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9jb21wb25lbnQtYmluZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICAgICAgaWYgKG9iai50b0pTT04gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2hhcy1iaW5hcnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vYmFja28yL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdj48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3MtYXBwXFxcIj5cXG4gICAgPHVpLXRhYnNcXG4gICAgICAgIGNsYXNzPVxcXCJtYWluLXRhYi1jb250YWluZXJcXFwiIGJhY2tncm91bmQtY29sb3I9XFxcImRhcmtcXFwiIHRleHQtY29sb3I9XFxcImxpZ2h0XFxcIlxcbiAgICAgICAgaW5kaWNhdG9yLWNvbG9yPVxcXCJ0cmFuc3BhcmVudFxcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLXRhYiBoZWFkZXI9XFxcIk1hcFxcXCI+XFxuICAgICAgICAgICAgPG1hcC12aWV3PjwvbWFwLXZpZXc+XFxuICAgICAgICA8L3VpLXRhYj5cXG5cXG4gICAgICAgIDx1aS10YWIgaGVhZGVyPVxcXCJQYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxwYXJhbXMtdmlldz48L3BhcmFtcy12aWV3PlxcbiAgICAgICAgPC91aS10YWI+XFxuXFxuICAgICAgICA8dWktdGFiIGhlYWRlcj1cXFwiU2V0dGluZ3NcXFwiPlxcbiAgICAgICAgICAgIDxzZXR0aW5ncy12aWV3Pjwvc2V0dGluZ3Mtdmlldz5cXG4gICAgICAgIDwvdWktdGFiPlxcbiAgICA8L3VpLXRhYnM+XFxuXFxuICAgIDxnY3MtaW5kaWNhdG9ycz48L2djcy1pbmRpY2F0b3JzPlxcblxcbiAgICA8dWktc25hY2tiYXItY29udGFpbmVyIHBvc2l0aW9uPVxcXCJjZW50ZXJcXFwiPjwvdWktc25hY2tiYXItY29udGFpbmVyPlxcbjwvZGl2Plxcbjxzb2NrZXQtaW8tbWFuYWdlcj48L3NvY2tldC1pby1tYW5hZ2VyPlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnO1xuaW1wb3J0IGNvbmZpZyBmcm9tICdhcHAvY29uZmlnJztcblxuLy8gVE9ETzogZ2V0IHNldHRpbmdzIGZyb20gc2VydmVyIGFuZCBhZGQgdG8gc3RhdGVcblxuVnVlLnVzZShWdWV4KTtcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIG1hcDogbnVsbCxcbiAgICBtYXBFbDogbnVsbCxcbiAgICBtYXBMb2FkZWQ6IGZhbHNlLFxuICAgIG1hcEVkaXRpbmc6IGZhbHNlLFxuICAgIHdhbXY6IHtcbiAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgcG9zaXRpb246IHtsYXQ6IC0zMi44ODgzMzM4LCBsbmc6IDE1MS43MDc1Mjc5fSxcbiAgICAgICAgaGVhZGluZzogIDAsXG4gICAgICAgIHNwZWVkOiAgICAwLFxuICAgICAgICBiYXR0ZXJ5OiAgMTAwLFxuICAgICAgICBhcm1lZDogICAgZmFsc2UsXG4gICAgICAgIG1vZGU6ICAgICAnaWRsZScsXG4gICAgICAgIHNpZ25hbDogICAxMDBcbiAgICB9LFxuICAgIGNvbmZpZzogY29uZmlnLFxuICAgIHNldHRpbmdzOiBjb25maWcuc2V0dGluZ3MsXG4gICAgc2V0dGluZ3NMb2FkZWQ6IGZhbHNlLFxuICAgIG1pc3Npb25zOiBbXSxcbiAgICBjdXJyZW50TWlzc2lvbkluZGV4OiAtMSxcbiAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICBtZXNzYWdlU3RhdGU6IHtcbiAgICAgICAgLy9jb25zdGFudHMgZm9yIGluZGljYXRpbmcgc3RhdGVcbiAgICAgICAgSU5JVElBTDogMCxcbiAgICAgICAgV0FJVElORzogMSxcbiAgICAgICAgU1VDQ0VTUzogMixcbiAgICAgICAgRkFJTFVSRTogMyxcbiAgICAgICAgLy9mb3IgYSBtZXNzYWdlIHR5cGUgVCBiZWxvdywgVFswXSBzcGVjaWZpZXMgYSBzdGF0ZSwgYW5kIFRbMV0gc3BlY2lmaWVzIGRhdGFcbiAgICAgICAgLy93aGVuIGEgY29tcG9uZW50IHdhbnRzIHRvIHNlbmQgYSBtZXNzYWdlIG9mIHR5cGUgVCwgVFswXSBpcyBzZXQgdG8gV0FJVElOR1xuICAgICAgICAgICAgLy9UWzFdIGlzIHNldCB0byB0aGUgcmVxdWVzdCBkYXRhLCBpZiBhbnlcbiAgICAgICAgLy93aGVuIGEgc2VydmVyIHJlc3BvbnNlIGlzIHJlY2VpdmVkLCBUWzBdIGlzIHNldCB0byBTVUNDRVNTLCBhbmQgVFsxXSB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICAgICAgICAgICAgLy9pZiB0aGUgcmVxdWVzdCBmYWlsZWQsIFRbMF0gaXMgaW5zdGVhZCBzZXQgdG8gRkFJTFVSRSwgYW5kIFRbMV0gdG8gdGhlIGZhaWx1cmUgbWVzc2FnZVxuICAgICAgICBnZXRfcGFyYW1ldGVyczogICBbMCwgbnVsbF0sXG4gICAgICAgIHNldF9wYXJhbWV0ZXI6ICAgIFswLCBudWxsXSxcbiAgICAgICAgc2F2ZV9taXNzaW9uczogICAgWzAsIG51bGxdLFxuICAgICAgICBsb2FkX21pc3Npb25zOiAgICBbMCwgbnVsbF0sXG4gICAgICAgIHVwbG9hZF9taXNzaW9uOiAgIFswLCBudWxsXSxcbiAgICAgICAgZG93bmxvYWRfbWlzc2lvbjogWzAsIG51bGxdLFxuICAgICAgICBhcm06ICAgICAgICAgICAgICBbMCwgbnVsbF0sXG4gICAgICAgIGRpc2FybTogICAgICAgICAgIFswLCBudWxsXSxcbiAgICAgICAgc3RhcnRfbWlzc2lvbjogICAgWzAsIG51bGxdLFxuICAgICAgICBzdG9wX21pc3Npb246ICAgICBbMCwgbnVsbF0sXG4gICAgICAgIHJlc3VtZV9taXNzaW9uOiAgIFswLCBudWxsXSxcbiAgICAgICAga2lsbDogICAgICAgICAgICAgWzAsIG51bGxdLFxuICAgICAgICB1bmtpbGw6ICAgICAgICAgICBbMCwgbnVsbF1cbiAgICB9XG59O1xuXG5jb25zdCBtdXRhdGlvbnMgPSB7XG4gICAgU0VUX01BUChzdGF0ZSwgbWFwKSB7XG4gICAgICAgIHN0YXRlLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgU0VUX01BUF9FTChzdGF0ZSwgbWFwRWwpIHtcbiAgICAgICAgc3RhdGUubWFwRWwgPSBtYXBFbDtcbiAgICB9LFxuXG4gICAgU0VUX01BUF9MT0FERUQoc3RhdGUsIGxvYWRlZCkge1xuICAgICAgICBzdGF0ZS5tYXBMb2FkZWQgPSBsb2FkZWQ7XG4gICAgfSxcblxuICAgIFNFVF9NQVBfRURJVElORyhzdGF0ZSwgZWRpdGluZykge1xuICAgICAgICBzdGF0ZS5tYXBFZGl0aW5nID0gZWRpdGluZztcbiAgICB9LFxuXG4gICAgVVBEQVRFX1dBTVZfUE9TSVRJT04oc3RhdGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIHN0YXRlLndhbXYucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgU0VUX1dBTVYoc3RhdGUsIHdhbXYpIHtcbiAgICAgICAgc3RhdGUud2FtdiA9IHdhbXY7XG4gICAgfSxcblxuICAgIFNFVF9XQU1WX0FSTUVEKHN0YXRlLCBhcm1lZCkge1xuICAgICAgICBzdGF0ZS53YW12LmFybWVkID0gYXJtZWQ7XG4gICAgfSxcblxuICAgIFNFVF9XQU1WX01PREUoc3RhdGUsIG1vZGUpIHtcbiAgICAgICAgc3RhdGUud2Ftdi5tb2RlID0gbW9kZTtcbiAgICB9LFxuXG4gICAgSU5JVF9TRVRUSU5HUyhzdGF0ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgc3RhdGUuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgc3RhdGUuc2V0dGluZ3NMb2FkZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBVUERBVEVfU0VUVElOR1Moc3RhdGUsIHNldHRpbmdzKSB7XG4gICAgICAgIHN0YXRlLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfSxcblxuICAgIFNFVF9NSVNTSU9OUyhzdGF0ZSwgbWlzc2lvbnMpIHtcbiAgICAgICAgc3RhdGUubWlzc2lvbnMgPSBtaXNzaW9ucztcbiAgICB9LFxuXG4gICAgU0VUX0NVUlJFTlRfTUlTU0lPTl9JTkRFWChzdGF0ZSwgaW5kZXgpIHtcbiAgICAgICAgc3RhdGUuY3VycmVudE1pc3Npb25JbmRleCA9IGluZGV4O1xuICAgIH0sXG5cbiAgICBTRVRfQ1VSUkVOVF9NSVNTSU9OKHN0YXRlLCBtaXNzaW9uKSB7XG4gICAgICAgIHN0YXRlLm1pc3Npb25zLiRzZXQoc3RhdGUuY3VycmVudE1pc3Npb25JbmRleCwgbWlzc2lvbik7XG4gICAgfSxcblxuICAgIFNFVF9QQVJBTUVURVJTKHN0YXRlLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN0YXRlLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgIH0sXG5cbiAgICBTRU5EX0dFVF9QQVJBTUVURVJTKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5nZXRfcGFyYW1ldGVycy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcbiAgICB9LFxuXG4gICAgU1VDQ0VFRF9HRVRfUEFSQU1FVEVSUyhzdGF0ZSwgcGFyYW1ldGVycykge1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZ2V0X3BhcmFtZXRlcnMuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5nZXRfcGFyYW1ldGVycy4kc2V0KDEsIHBhcmFtZXRlcnMpO1xuICAgIH0sXG5cbiAgICBGQUlMX0dFVF9QQVJBTUVURVJTKHN0YXRlLCBtc2cpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmdldF9wYXJhbWV0ZXJzLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZ2V0X3BhcmFtZXRlcnMuJHNldCgxLCBtc2cpO1xuICAgIH0sXG5cbiAgICBTRU5EX1NBVkVfTUlTU0lPTlMoc3RhdGUsIG1pc3Npb25zKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zYXZlX21pc3Npb25zLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9ucy4kc2V0KDEsIG1pc3Npb25zKTtcbiAgICB9LFxuXG4gICAgU1VDQ0VFRF9TQVZFX01JU1NJT05TKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zYXZlX21pc3Npb25zLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1MpO1xuICAgIH0sXG5cbiAgICBGQUlMX1NBVkVfTUlTU0lPTlMoc3RhdGUsIG1zZykge1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9ucy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnNhdmVfbWlzc2lvbnMuJHNldCgxLCBtc2cpO1xuICAgIH0sXG5cbiAgICBTRU5EX0xPQURfTUlTU0lPTlMoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmxvYWRfbWlzc2lvbnMuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORyk7XG4gICAgfSxcblxuICAgIFNVQ0NFRURfTE9BRF9NSVNTSU9OUyhzdGF0ZSwgbWlzc2lvbnMpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmxvYWRfbWlzc2lvbnMuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5sb2FkX21pc3Npb25zLiRzZXQoMSwgbWlzc2lvbnMpO1xuICAgIH0sXG5cbiAgICBGQUlMX0xPQURfTUlTU0lPTlMoc3RhdGUsIG1zZykge1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUubG9hZF9taXNzaW9ucy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmxvYWRfbWlzc2lvbnMuJHNldCgxLCBtc2cpO1xuICAgIH0sXG5cbiAgICBTRU5EX1VQTE9BRF9NSVNTSU9OKHN0YXRlLCBtaXNzaW9uKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS51cGxvYWRfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVwbG9hZF9taXNzaW9uLiRzZXQoMSwgbWlzc2lvbik7XG4gICAgfSxcblxuICAgIFNVQ0NFRURfVVBMT0FEX01JU1NJT04oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVwbG9hZF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1MpO1xuICAgIH0sXG5cbiAgICBGQUlMX1VQTE9BRF9NSVNTSU9OKHN0YXRlLCBtc2cpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVwbG9hZF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUudXBsb2FkX21pc3Npb24uJHNldCgxLCBtc2cpO1xuICAgIH0sXG5cbiAgICBTRU5EX0RPV05MT0FEX01JU1NJT04oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRvd25sb2FkX21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORyk7XG4gICAgfSxcblxuICAgIFNVQ0NFRURfRE9XTkxPQURfTUlTU0lPTihzdGF0ZSwgbWlzc2lvbikge1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZG93bmxvYWRfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRvd25sb2FkX21pc3Npb24uJHNldCgxLCBtaXNzaW9uKTtcbiAgICB9LFxuXG4gICAgRkFJTF9ET1dOTE9BRF9NSVNTSU9OKHN0YXRlLCBtc2cpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRvd25sb2FkX21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuRkFJTFVSRSk7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kb3dubG9hZF9taXNzaW9uLiRzZXQoMSwgbXNnKTtcbiAgICB9LFxuXG4gICAgU0VORF9TVEFSVF9NSVNTSU9OKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xuICAgIH0sXG5cbiAgICBTVUNDRUVEX1NUQVJUX01JU1NJT04oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnN0YXJ0X21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XG4gICAgfSxcblxuICAgIEZBSUxfU1RBUlRfTUlTU0lPTihzdGF0ZSwgbXNnKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc3RhcnRfbWlzc2lvbi4kc2V0KDEsIG1zZyk7XG4gICAgfSxcblxuICAgIFNFTkRfU1RPUF9NSVNTSU9OKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdG9wX21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORyk7XG4gICAgfSxcblxuICAgIFNVQ0NFRURfU1RPUF9NSVNTSU9OKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdG9wX21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XG4gICAgfSxcblxuICAgIEZBSUxfU1RPUF9NSVNTSU9OKHN0YXRlLCBtc2cpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnN0b3BfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnN0b3BfbWlzc2lvbi4kc2V0KDEsIG1zZyk7XG4gICAgfSxcblxuICAgIFNFTkRfUkVTVU1FX01JU1NJT04oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xuICAgIH0sXG5cbiAgICBTVUNDRUVEX1JFU1VNRV9NSVNTSU9OKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5yZXN1bWVfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcbiAgICB9LFxuXG4gICAgRkFJTF9SRVNVTUVfTUlTU0lPTihzdGF0ZSwgbXNnKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5yZXN1bWVfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uLiRzZXQoMSwgbXNnKTtcbiAgICB9LFxuXG4gICAgU0VORF9BUk0oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmFybS4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcbiAgICB9LFxuXG4gICAgU1VDQ0VFRF9BUk0oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmFybS4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcbiAgICB9LFxuXG4gICAgRkFJTF9BUk0oc3RhdGUsIG1zZykge1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuYXJtLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuYXJtLiRzZXQoMSwgbXNnKTtcbiAgICB9LFxuXG4gICAgU0VORF9ESVNBUk0oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRpc2FybS4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcbiAgICB9LFxuXG4gICAgU1VDQ0VFRF9ESVNBUk0oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRpc2FybS4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcbiAgICB9LFxuXG4gICAgRkFJTF9ESVNBUk0oc3RhdGUsIG1zZykge1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZGlzYXJtLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZGlzYXJtLiRzZXQoMSwgbXNnKTtcbiAgICB9LFxuXG4gICAgU0VORF9LSUxMKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5raWxsLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xuICAgIH0sXG5cbiAgICBTVUNDRUVEX0tJTEwoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmtpbGwuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XG4gICAgfSxcblxuICAgIEZBSUxfS0lMTChzdGF0ZSwgbXNnKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5raWxsLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUua2lsbC4kc2V0KDEsIG1zZyk7XG4gICAgfSxcblxuICAgIFNFTkRfVU5LSUxMKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS51bmtpbGwuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORyk7XG4gICAgfSxcblxuICAgIFNVQ0NFRURfVU5LSUxMKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS51bmtpbGwuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XG4gICAgfSxcblxuICAgIEZBSUxfVU5LSUxMKHN0YXRlLCBtc2cpIHtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVua2lsbC4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVua2lsbC4kc2V0KDEsIG1zZyk7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBWdWV4LlN0b3JlKHtcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgIG11dGF0aW9uc1xufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zdG9yZS9zdG9yZS5qc1xuICoqLyIsIi8qIVxuICogVnVleCB2MS4wLjAtcmMuMlxuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLlZ1ZXggPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH07XG5cbiAgdmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhcnJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBtZXJnZU9iamVjdHMoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG9iaikge1xuICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gcHJldltrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAvLyBhbGxvdyBtdWx0aXBsZSBtdXRhdGlvbiBvYmplY3RzIHRvIGNvbnRhaW4gZHVwbGljYXRlXG4gICAgICAgICAgLy8gaGFuZGxlcnMgZm9yIHRoZSBzYW1lIG11dGF0aW9uIHR5cGVcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IGV4aXN0aW5nLmNvbmNhdChvYmpba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IFtleGlzdGluZ10uY29uY2F0KG9ialtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldltrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIE9iamVjdCBvciBub3RcbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdGF0ZSBzdWIgdHJlZSBieSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBuZXN0ZWRLZXlzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5lc3RlZFN0YXRlKHN0YXRlLCBuZXN0ZWRLZXlzKSB7XG4gICAgcmV0dXJuIG5lc3RlZEtleXMucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7XG4gICAgICByZXR1cm4gc3RhdGVba2V5XTtcbiAgICB9LCBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogSGFja3MgdG8gZ2V0IGFjY2VzcyB0byBWdWUgaW50ZXJuYWxzLlxuICAgKiBNYXliZSB3ZSBzaG91bGQgZXhwb3NlIHRoZXNlLi4uXG4gICAqL1xuXG4gIHZhciBXYXRjaGVyID0gdm9pZCAwO1xuICBmdW5jdGlvbiBnZXRXYXRjaGVyKHZtKSB7XG4gICAgaWYgKCFXYXRjaGVyKSB7XG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICAgIHZhciB1bndhdGNoID0gdm0uJHdhdGNoKG5vb3AsIG5vb3ApO1xuICAgICAgV2F0Y2hlciA9IHZtLl93YXRjaGVyc1swXS5jb25zdHJ1Y3RvcjtcbiAgICAgIHVud2F0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIFdhdGNoZXI7XG4gIH1cblxuICB2YXIgRGVwID0gdm9pZCAwO1xuICBmdW5jdGlvbiBnZXREZXAodm0pIHtcbiAgICBpZiAoIURlcCkge1xuICAgICAgRGVwID0gdm0uX2RhdGEuX19vYl9fLmRlcC5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIERlcDtcbiAgfVxuXG4gIHZhciBob29rID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgZnVuY3Rpb24gZGV2dG9vbFBsdWdpbihzdG9yZSkge1xuICAgIGlmICghaG9vaykgcmV0dXJuO1xuXG4gICAgaG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgICBob29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgICB9KTtcblxuICAgIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgICBob29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGUgKFZ1ZSkge1xuICAgIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gICAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgICAgdmFyIHVzZXNJbml0ID0gVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTE7XG4gICAgICBWdWUubWl4aW4odXNlc0luaXQgPyB7IGluaXQ6IHZ1ZXhJbml0IH0gOiB7IGJlZm9yZUNyZWF0ZTogdnVleEluaXQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIHZhciBfaW5pdCA9IFZ1ZS5wcm90b3R5cGUuX2luaXQ7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdCA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdCkgOiB2dWV4SW5pdDtcbiAgICAgICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2dWV4SW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAgIHZhciBzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgICB2YXIgdnVleCA9IG9wdGlvbnMudnVleDtcbiAgICAgIC8vIHN0b3JlIGluamVjdGlvblxuXG4gICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgdGhpcy4kc3RvcmUgPSBzdG9yZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgICAgfVxuICAgICAgLy8gdnVleCBvcHRpb24gaGFuZGxpbmdcbiAgICAgIGlmICh2dWV4KSB7XG4gICAgICAgIGlmICghdGhpcy4kc3RvcmUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBzdG9yZSBub3QgaW5qZWN0ZWQuIG1ha2Ugc3VyZSB0byAnICsgJ3Byb3ZpZGUgdGhlIHN0b3JlIG9wdGlvbiBpbiB5b3VyIHJvb3QgY29tcG9uZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHZ1ZXguc3RhdGU7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdnVleC5hY3Rpb25zO1xuICAgICAgICB2YXIgZ2V0dGVycyA9IHZ1ZXguZ2V0dGVycztcbiAgICAgICAgLy8gaGFuZGxlIGRlcHJlY2F0ZWQgc3RhdGUgb3B0aW9uXG5cbiAgICAgICAgaWYgKHN0YXRlICYmICFnZXR0ZXJzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gdnVleC5zdGF0ZSBvcHRpb24gd2lsbCBiZWVuIGRlcHJlY2F0ZWQgaW4gMS4wLiAnICsgJ1VzZSB2dWV4LmdldHRlcnMgaW5zdGVhZC4nKTtcbiAgICAgICAgICBnZXR0ZXJzID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0dGVyc1xuICAgICAgICBpZiAoZ2V0dGVycykge1xuICAgICAgICAgIG9wdGlvbnMuY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkIHx8IHt9O1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBnZXR0ZXJzKSB7XG4gICAgICAgICAgICBkZWZpbmVWdWV4R2V0dGVyKHRoaXMsIGtleSwgZ2V0dGVyc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWN0aW9uc1xuICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMubWV0aG9kcyA9IG9wdGlvbnMubWV0aG9kcyB8fCB7fTtcbiAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kc1tfa2V5XSA9IG1ha2VCb3VuZEFjdGlvbih0aGlzLiRzdG9yZSwgYWN0aW9uc1tfa2V5XSwgX2tleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIGZvciBhbGwgZ2V0dGVyIHByb3BlcnRpZXMuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXR0ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Z1ZXggZ2V0dGVyIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seS4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBWdWV4IGdldHRlciBvbiBhbiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRlZmluZVZ1ZXhHZXR0ZXIodm0sIGtleSwgZ2V0dGVyKSB7XG4gICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBHZXR0ZXIgYm91bmQgdG8ga2V5IFxcJ3Z1ZXguZ2V0dGVycy4nICsga2V5ICsgJ1xcJyBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBtYWtlQ29tcHV0ZWRHZXR0ZXIodm0uJHN0b3JlLCBnZXR0ZXIpLFxuICAgICAgICAgIHNldDogc2V0dGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBjb21wdXRlZCBnZXR0ZXIsIHVzaW5nIHRoZSBzYW1lIGNhY2hpbmcgbWVjaGFuaXNtIG9mIGNvbXB1dGVkXG4gICAgICogcHJvcGVydGllcy4gSW4gYWRkaXRpb24sIGl0IGlzIGNhY2hlZCBvbiB0aGUgcmF3IGdldHRlciBmdW5jdGlvbiB1c2luZ1xuICAgICAqIHRoZSBzdG9yZSdzIHVuaXF1ZSBjYWNoZSBpZC4gVGhpcyBtYWtlcyB0aGUgc2FtZSBnZXR0ZXIgc2hhcmVkXG4gICAgICogYWNyb3NzIGFsbCBjb21wb25lbnRzIHVzZSB0aGUgc2FtZSB1bmRlcmx5aW5nIHdhdGNoZXIsIGFuZCBtYWtlc1xuICAgICAqIHRoZSBnZXR0ZXIgZXZhbHVhdGVkIG9ubHkgb25jZSBkdXJpbmcgZXZlcnkgZmx1c2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0b3JlfSBzdG9yZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyKHN0b3JlLCBnZXR0ZXIpIHtcbiAgICAgIHZhciBpZCA9IHN0b3JlLl9nZXR0ZXJDYWNoZUlkO1xuXG4gICAgICAvLyBjYWNoZWRcbiAgICAgIGlmIChnZXR0ZXJbaWRdKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXJbaWRdO1xuICAgICAgfVxuICAgICAgdmFyIHZtID0gc3RvcmUuX3ZtO1xuICAgICAgdmFyIFdhdGNoZXIgPSBnZXRXYXRjaGVyKHZtKTtcbiAgICAgIHZhciBEZXAgPSBnZXREZXAodm0pO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZnVuY3Rpb24gKHZtKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXIodm0uc3RhdGUpO1xuICAgICAgfSwgbnVsbCwgeyBsYXp5OiB0cnVlIH0pO1xuICAgICAgdmFyIGNvbXB1dGVkR2V0dGVyID0gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgIH07XG4gICAgICBnZXR0ZXJbaWRdID0gY29tcHV0ZWRHZXR0ZXI7XG4gICAgICByZXR1cm4gY29tcHV0ZWRHZXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGJvdW5kLXRvLXN0b3JlIHZlcnNpb24gb2YgYSByYXcgYWN0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdG9yZX0gc3RvcmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBtYWtlQm91bmRBY3Rpb24oc3RvcmUsIGFjdGlvbiwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBBY3Rpb24gYm91bmQgdG8ga2V5IFxcJ3Z1ZXguYWN0aW9ucy4nICsga2V5ICsgJ1xcJyBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB2dWV4Qm91bmRBY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsLmFwcGx5KGFjdGlvbiwgW3RoaXMsIHN0b3JlXS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb24gbWVyZ2luZ1xuICAgIHZhciBtZXJnZSA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLmNvbXB1dGVkO1xuICAgIFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLnZ1ZXggPSBmdW5jdGlvbiAodG9WYWwsIGZyb21WYWwpIHtcbiAgICAgIGlmICghdG9WYWwpIHJldHVybiBmcm9tVmFsO1xuICAgICAgaWYgKCFmcm9tVmFsKSByZXR1cm4gdG9WYWw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXR0ZXJzOiBtZXJnZSh0b1ZhbC5nZXR0ZXJzLCBmcm9tVmFsLmdldHRlcnMpLFxuICAgICAgICBzdGF0ZTogbWVyZ2UodG9WYWwuc3RhdGUsIGZyb21WYWwuc3RhdGUpLFxuICAgICAgICBhY3Rpb25zOiBtZXJnZSh0b1ZhbC5hY3Rpb25zLCBmcm9tVmFsLmFjdGlvbnMpXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgVnVlID0gdm9pZCAwO1xuICB2YXIgdWlkID0gMDtcblxuICB2YXIgU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICAtIHtPYmplY3R9IHN0YXRlXG4gICAgICogICAgICAgIC0ge09iamVjdH0gYWN0aW9uc1xuICAgICAqICAgICAgICAtIHtPYmplY3R9IG11dGF0aW9uc1xuICAgICAqICAgICAgICAtIHtBcnJheX0gcGx1Z2luc1xuICAgICAqICAgICAgICAtIHtCb29sZWFufSBzdHJpY3RcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFN0b3JlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIF9yZWYkc3RhdGUgPSBfcmVmLnN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gX3JlZiRzdGF0ZSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJHN0YXRlO1xuICAgICAgdmFyIF9yZWYkbXV0YXRpb25zID0gX3JlZi5tdXRhdGlvbnM7XG4gICAgICB2YXIgbXV0YXRpb25zID0gX3JlZiRtdXRhdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRtdXRhdGlvbnM7XG4gICAgICB2YXIgX3JlZiRtb2R1bGVzID0gX3JlZi5tb2R1bGVzO1xuICAgICAgdmFyIG1vZHVsZXMgPSBfcmVmJG1vZHVsZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRtb2R1bGVzO1xuICAgICAgdmFyIF9yZWYkcGx1Z2lucyA9IF9yZWYucGx1Z2lucztcbiAgICAgIHZhciBwbHVnaW5zID0gX3JlZiRwbHVnaW5zID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYkcGx1Z2lucztcbiAgICAgIHZhciBfcmVmJHN0cmljdCA9IF9yZWYuc3RyaWN0O1xuICAgICAgdmFyIHN0cmljdCA9IF9yZWYkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkc3RyaWN0O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmUpO1xuXG4gICAgICB0aGlzLl9nZXR0ZXJDYWNoZUlkID0gJ3Z1ZXhfc3RvcmVfJyArIHVpZCsrO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Jvb3RNdXRhdGlvbnMgPSB0aGlzLl9tdXRhdGlvbnMgPSBtdXRhdGlvbnM7XG4gICAgICB0aGlzLl9tb2R1bGVzID0gbW9kdWxlcztcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gICAgICAvLyBiaW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgICAgIHZhciBkaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2g7XG4gICAgICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaC5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgICAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gICAgICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgICAgIGlmICghVnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIG11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLicpO1xuICAgICAgfVxuICAgICAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICAgICAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fdm0gPSBuZXcgVnVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuICAgICAgdGhpcy5fc2V0dXBNb2R1bGVTdGF0ZShzdGF0ZSwgbW9kdWxlcyk7XG4gICAgICB0aGlzLl9zZXR1cE1vZHVsZU11dGF0aW9ucyhtb2R1bGVzKTtcbiAgICAgIC8vIGFkZCBleHRyYSB3YXJuaW5ncyBpbiBzdHJpY3QgbW9kZVxuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aGlzLl9zZXR1cE11dGF0aW9uQ2hlY2soKTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBsdWdpbnNcbiAgICAgIGRldnRvb2xQbHVnaW4odGhpcyk7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luKF90aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRlciBmb3IgdGhlIGVudGlyZSBzdGF0ZSB0cmVlLlxuICAgICAqIFJlYWQgb25seS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cblxuICAgIGNyZWF0ZUNsYXNzKFN0b3JlLCBbe1xuICAgICAga2V5OiAncmVwbGFjZVN0YXRlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2Ugcm9vdCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICAgICAqL1xuXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdm0uc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwYXRjaCBhbiBhY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzcGF0Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHBheWxvYWRbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgLy8gY29tcGF0aWJpbGl0eSBmb3Igb2JqZWN0IGFjdGlvbnMsIGUuZy4gRlNBXG4gICAgICAgIGlmICgodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHR5cGUpKSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHBheWxvYWQgPSB0eXBlO1xuICAgICAgICAgIGlmICh0eXBlLnNpbGVudCkgc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0eXBlID0gdHlwZS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcHBseSB0aGUgbXV0YXRpb25cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlci5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgIGlzT2JqZWN0U3R5bGVEaXNwYXRjaCA/IGgoc3RhdGUsIHBheWxvYWQpIDogaC5hcHBseSh1bmRlZmluZWQsIFtzdGF0ZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHBheWxvYWQpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNPYmplY3RTdHlsZURpc3BhdGNoID8gaGFuZGxlcihzdGF0ZSwgcGF5bG9hZCkgOiBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgW3N0YXRlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocGF5bG9hZCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gaXNPYmplY3RTdHlsZURpc3BhdGNoID8gcGF5bG9hZCA6IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICAgICAgICAgICAgICBfdGhpczIuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWIobXV0YXRpb24sIHN0YXRlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBVbmtub3duIG11dGF0aW9uOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXYXRjaCBzdGF0ZSBjaGFuZ2VzIG9uIHRoZSBzdG9yZS5cbiAgICAgICAqIFNhbWUgQVBJIGFzIFZ1ZSdzICR3YXRjaCwgZXhjZXB0IHdoZW4gd2F0Y2hpbmcgYSBmdW5jdGlvbixcbiAgICAgICAqIHRoZSBmdW5jdGlvbiBnZXRzIHRoZSBzdGF0ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3dhdGNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YXRjaChmbiwgY2IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Z1ZXggc3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX3RoaXMzLnN0YXRlKTtcbiAgICAgICAgfSwgY2IsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN1YnNjcmliZSB0byBzdGF0ZSBjaGFuZ2VzLiBGaXJlcyBhZnRlciBldmVyeSBtdXRhdGlvbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc3Vic2NyaWJlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgICAgICAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgICAgICAgc3Vicy5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSG90IHVwZGF0ZSBtdXRhdGlvbnMgJiBtb2R1bGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiAgICAgICAgLSB7T2JqZWN0fSBbbXV0YXRpb25zXVxuICAgICAgICogICAgICAgIC0ge09iamVjdH0gW21vZHVsZXNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hvdFVwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaG90VXBkYXRlKCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB2YXIgbXV0YXRpb25zID0gX3JlZjIubXV0YXRpb25zO1xuICAgICAgICB2YXIgbW9kdWxlcyA9IF9yZWYyLm1vZHVsZXM7XG5cbiAgICAgICAgdGhpcy5fcm9vdE11dGF0aW9ucyA9IHRoaXMuX211dGF0aW9ucyA9IG11dGF0aW9ucyB8fCB0aGlzLl9yb290TXV0YXRpb25zO1xuICAgICAgICB0aGlzLl9zZXR1cE1vZHVsZU11dGF0aW9ucyhtb2R1bGVzIHx8IHRoaXMuX21vZHVsZXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGFjaCBzdWIgc3RhdGUgdHJlZSBvZiBlYWNoIG1vZHVsZSB0byB0aGUgcm9vdCB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldHVwTW9kdWxlU3RhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZHVsZVN0YXRlKHN0YXRlLCBtb2R1bGVzKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QobW9kdWxlcykpIHJldHVybjtcblxuICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1trZXldO1xuXG4gICAgICAgICAgLy8gc2V0IHRoaXMgbW9kdWxlJ3Mgc3RhdGVcbiAgICAgICAgICBWdWUuc2V0KHN0YXRlLCBrZXksIG1vZHVsZS5zdGF0ZSB8fCB7fSk7XG5cbiAgICAgICAgICAvLyByZXRyaWV2ZSBuZXN0ZWQgbW9kdWxlc1xuICAgICAgICAgIF90aGlzNC5fc2V0dXBNb2R1bGVTdGF0ZShzdGF0ZVtrZXldLCBtb2R1bGUubW9kdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJpbmQgbXV0YXRpb25zIGZvciBlYWNoIG1vZHVsZSB0byBpdHMgc3ViIHRyZWUgYW5kXG4gICAgICAgKiBtZXJnZSB0aGVtIGFsbCBpbnRvIG9uZSBmaW5hbCBtdXRhdGlvbnMgbWFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVkTW9kdWxlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNb2R1bGVNdXRhdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZHVsZU11dGF0aW9ucyh1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IHRoaXMuX21vZHVsZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBtb2R1bGVzW2tleV0gPSB1cGRhdGVkTW9kdWxlc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVwZGF0ZWRNdXRhdGlvbnMgPSB0aGlzLl9jcmVhdGVNb2R1bGVNdXRhdGlvbnMobW9kdWxlcywgW10pO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSBtZXJnZU9iamVjdHMoW3RoaXMuX3Jvb3RNdXRhdGlvbnNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh1cGRhdGVkTXV0YXRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhlbHBlciBtZXRob2QgZm9yIF9zZXR1cE1vZHVsZU11dGF0aW9ucy5cbiAgICAgICAqIFRoZSBtZXRob2QgcmV0cmlldmUgbmVzdGVkIHN1YiBtb2R1bGVzIGFuZFxuICAgICAgICogYmluZCBlYWNoIG11dGF0aW9ucyB0byBpdHMgc3ViIHRyZWUgcmVjdXJzaXZlbHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gbmVzdGVkS2V5c1xuICAgICAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZU1vZHVsZU11dGF0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZU1vZHVsZU11dGF0aW9ucyhtb2R1bGVzLCBuZXN0ZWRLZXlzKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QobW9kdWxlcykpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobW9kdWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1trZXldO1xuICAgICAgICAgIHZhciBuZXdOZXN0ZWRLZXlzID0gbmVzdGVkS2V5cy5jb25jYXQoa2V5KTtcblxuICAgICAgICAgIC8vIHJldHJpZXZlIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgdmFyIG5lc3RlZE11dGF0aW9ucyA9IF90aGlzNS5fY3JlYXRlTW9kdWxlTXV0YXRpb25zKG1vZHVsZS5tb2R1bGVzLCBuZXdOZXN0ZWRLZXlzKTtcblxuICAgICAgICAgIGlmICghbW9kdWxlIHx8ICFtb2R1bGUubXV0YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKG5lc3RlZE11dGF0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYmluZCBtdXRhdGlvbnMgdG8gc3ViIHN0YXRlIHRyZWVcbiAgICAgICAgICB2YXIgbXV0YXRpb25zID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMobW9kdWxlLm11dGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gbW9kdWxlLm11dGF0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIG11dGF0aW9uc1tuYW1lXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHVuZGVmaW5lZCwgW2dldE5lc3RlZFN0YXRlKHN0YXRlLCBuZXdOZXN0ZWRLZXlzKV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBtZXJnZSBtdXRhdGlvbnMgb2YgdGhpcyBtb2R1bGUgYW5kIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhbbXV0YXRpb25zXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkobmVzdGVkTXV0YXRpb25zKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBtdXRhdGlvbiBjaGVjazogaWYgdGhlIHZ1ZXggaW5zdGFuY2UncyBzdGF0ZSBpcyBtdXRhdGVkXG4gICAgICAgKiBvdXRzaWRlIG9mIGEgbXV0YXRpb24gaGFuZGxlciwgd2UgdGhyb3cgZW4gZXJyb3IuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgICAqIGVuZm9yY2VzIGFsbCBtdXRhdGlvbnMgdG8gdGhlIHN0YXRlIHRvIGJlIHRyYWNrYWJsZSBhbmQgaG90LXJlbG9hZGJsZS5cbiAgICAgICAqIEhvd2V2ZXIsIHRoaXMgY29tZXMgYXQgYSBydW4gdGltZSBjb3N0IHNpbmNlIHdlIGFyZSBkb2luZyBhIGRlZXBcbiAgICAgICAqIHdhdGNoIG9uIHRoZSBlbnRpcmUgc3RhdGUgdHJlZSwgc28gaXQgaXMgb25seSBlbmFsYmVkIHdpdGggdGhlXG4gICAgICAgKiBzdHJpY3Qgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNdXRhdGlvbkNoZWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBNdXRhdGlvbkNoZWNrKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgV2F0Y2hlciA9IGdldFdhdGNoZXIodGhpcy5fdm0pO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICAgICAgbmV3IFdhdGNoZXIodGhpcy5fdm0sICdzdGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNi5fZGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIERvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0YXRlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdm0uc3RhdGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1t2dWV4XSBVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS4nKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFN0b3JlO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gaW5zdGFsbChfVnVlKSB7XG4gICAgaWYgKFZ1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFZ1ZSA9IF9WdWU7XG4gICAgb3ZlcnJpZGUoVnVlKTtcbiAgfVxuXG4gIC8vIGF1dG8gaW5zdGFsbCBpbiBkaXN0IG1vZGVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgdmFyIGluZGV4ID0ge1xuICAgIFN0b3JlOiBTdG9yZSxcbiAgICBpbnN0YWxsOiBpbnN0YWxsXG4gIH07XG5cbiAgcmV0dXJuIGluZGV4O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVleC9kaXN0L3Z1ZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBnb29nbGVNYXBzOiB7XG4gICAgICAgIGtleTogJ0FJemFTeUFCbkNjZWt5UGVjR25zQTFSal9OZFdqbVVhZkoxeVZxQScsXG4gICAgICAgIHY6IDNcbiAgICB9LFxuICAgIG1hcDoge1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgIGxhdDogMjEuMzA4NzMxLFxuICAgICAgICAgICAgbG5nOiAtMTU3Ljg4ODgxNVxuICAgICAgICB9LFxuICAgICAgICB6b29tOiAxOSxcbiAgICAgICAgZGlzYWJsZURlZmF1bHRVSTogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZURvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgICAgICAgdGlsdDogMFxuICAgIH0sXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgICAgZGVmYXVsdE1hcFR5cGU6ICdTQVRFTExJVEUnXG4gICAgfVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbmZpZy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=