/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _keenUi = __webpack_require__(3);
	
	var _keenUi2 = _interopRequireDefault(_keenUi);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _store = __webpack_require__(136);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_keenUi2.default);
	
	var app = new _vue2.default({
	    el: 'body',
	    components: {
	        App: _App2.default
	    },
	    store: _store2.default
	});
	
	window.app = app;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Keen UI v0.8.9 (https://github.com/JosephusPaye/keen-ui)
	 * (c) 2016 Josephus Paye II
	 * Released under the MIT License.
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Keen"] = factory();
		else
			root["Keen"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		__webpack_require__(1);
		
		var _UiAlert = __webpack_require__(2);
		
		var _UiAlert2 = _interopRequireDefault(_UiAlert);
		
		var _UiAutocomplete = __webpack_require__(81);
		
		var _UiAutocomplete2 = _interopRequireDefault(_UiAutocomplete);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		var _UiCheckbox = __webpack_require__(113);
		
		var _UiCheckbox2 = _interopRequireDefault(_UiCheckbox);
		
		var _UiCollapsible = __webpack_require__(117);
		
		var _UiCollapsible2 = _interopRequireDefault(_UiCollapsible);
		
		var _UiConfirm = __webpack_require__(121);
		
		var _UiConfirm2 = _interopRequireDefault(_UiConfirm);
		
		var _UiFab = __webpack_require__(129);
		
		var _UiFab2 = _interopRequireDefault(_UiFab);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiMenuOption = __webpack_require__(16);
		
		var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);
		
		var _UiModal = __webpack_require__(124);
		
		var _UiModal2 = _interopRequireDefault(_UiModal);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiPreloader = __webpack_require__(133);
		
		var _UiPreloader2 = _interopRequireDefault(_UiPreloader);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _UiProgressLinear = __webpack_require__(137);
		
		var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);
		
		var _UiRadio = __webpack_require__(141);
		
		var _UiRadio2 = _interopRequireDefault(_UiRadio);
		
		var _UiRadioGroup = __webpack_require__(145);
		
		var _UiRadioGroup2 = _interopRequireDefault(_UiRadioGroup);
		
		var _UiRating = __webpack_require__(149);
		
		var _UiRating2 = _interopRequireDefault(_UiRating);
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		var _UiRatingPreview = __webpack_require__(157);
		
		var _UiRatingPreview2 = _interopRequireDefault(_UiRatingPreview);
		
		var _UiRippleInk = __webpack_require__(20);
		
		var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);
		
		var _UiSelect = __webpack_require__(161);
		
		var _UiSelect2 = _interopRequireDefault(_UiSelect);
		
		var _UiSlider = __webpack_require__(172);
		
		var _UiSlider2 = _interopRequireDefault(_UiSlider);
		
		var _UiSnackbar = __webpack_require__(184);
		
		var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);
		
		var _UiSnackbarContainer = __webpack_require__(188);
		
		var _UiSnackbarContainer2 = _interopRequireDefault(_UiSnackbarContainer);
		
		var _UiSwitch = __webpack_require__(192);
		
		var _UiSwitch2 = _interopRequireDefault(_UiSwitch);
		
		var _UiTab = __webpack_require__(196);
		
		var _UiTab2 = _interopRequireDefault(_UiTab);
		
		var _UiTabs = __webpack_require__(200);
		
		var _UiTabs2 = _interopRequireDefault(_UiTabs);
		
		var _UiTextbox = __webpack_require__(208);
		
		var _UiTextbox2 = _interopRequireDefault(_UiTextbox);
		
		var _UiToolbar = __webpack_require__(212);
		
		var _UiToolbar2 = _interopRequireDefault(_UiToolbar);
		
		var _UiTooltip = __webpack_require__(74);
		
		var _UiTooltip2 = _interopRequireDefault(_UiTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var Keen = {
		    UiAlert: _UiAlert2.default,
		    UiAutocomplete: _UiAutocomplete2.default,
		    UiButton: _UiButton2.default,
		    UiCheckbox: _UiCheckbox2.default,
		    UiCollapsible: _UiCollapsible2.default,
		    UiConfirm: _UiConfirm2.default,
		    UiFab: _UiFab2.default,
		    UiIcon: _UiIcon2.default,
		    UiIconButton: _UiIconButton2.default,
		    UiMenu: _UiMenu2.default,
		    UiMenuOption: _UiMenuOption2.default,
		    UiModal: _UiModal2.default,
		    UiPopover: _UiPopover2.default,
		    UiPreloader: _UiPreloader2.default,
		    UiProgressCircular: _UiProgressCircular2.default,
		    UiProgressLinear: _UiProgressLinear2.default,
		    UiRadio: _UiRadio2.default,
		    UiRadioGroup: _UiRadioGroup2.default,
		    UiRating: _UiRating2.default,
		    UiRatingIcon: _UiRatingIcon2.default,
		    UiRatingPreview: _UiRatingPreview2.default,
		    UiRippleInk: _UiRippleInk2.default,
		    UiSelect: _UiSelect2.default,
		    UiSlider: _UiSlider2.default,
		    UiSnackbar: _UiSnackbar2.default,
		    UiSnackbarContainer: _UiSnackbarContainer2.default,
		    UiSwitch: _UiSwitch2.default,
		    UiTab: _UiTab2.default,
		    UiTabs: _UiTabs2.default,
		    UiTextbox: _UiTextbox2.default,
		    UiToolbar: _UiToolbar2.default,
		    UiTooltip: _UiTooltip2.default,
		
		    install: function install(Vue) {
		        Vue.component('ui-alert', _UiAlert2.default);
		        Vue.component('ui-autocomplete', _UiAutocomplete2.default);
		        Vue.component('ui-button', _UiButton2.default);
		        Vue.component('ui-checkbox', _UiCheckbox2.default);
		        Vue.component('ui-collapsible', _UiCollapsible2.default);
		        Vue.component('ui-confirm', _UiConfirm2.default);
		        Vue.component('ui-fab', _UiFab2.default);
		        Vue.component('ui-icon', _UiIcon2.default);
		        Vue.component('ui-icon-button', _UiIconButton2.default);
		        Vue.component('ui-menu', _UiMenu2.default);
		        Vue.component('ui-menu-option', _UiMenuOption2.default);
		        Vue.component('ui-modal', _UiModal2.default);
		        Vue.component('ui-popover', _UiPopover2.default);
		        Vue.component('ui-preloader', _UiPreloader2.default);
		        Vue.component('ui-progress-circular', _UiProgressCircular2.default);
		        Vue.component('ui-progress-linear', _UiProgressLinear2.default);
		        Vue.component('ui-radio', _UiRadio2.default);
		        Vue.component('ui-radio-group', _UiRadioGroup2.default);
		        Vue.component('ui-rating', _UiRating2.default);
		        Vue.component('ui-rating-icon', _UiRatingIcon2.default);
		        Vue.component('ui-rating-preview', _UiRatingPreview2.default);
		        Vue.component('ui-ripple-ink', _UiRippleInk2.default);
		        Vue.component('ui-select', _UiSelect2.default);
		        Vue.component('ui-slider', _UiSlider2.default);
		        Vue.component('ui-snackbar', _UiSnackbar2.default);
		        Vue.component('ui-snackbar-container', _UiSnackbarContainer2.default);
		        Vue.component('ui-switch', _UiSwitch2.default);
		        Vue.component('ui-tab', _UiTab2.default);
		        Vue.component('ui-tabs', _UiTabs2.default);
		        Vue.component('ui-textbox', _UiTextbox2.default);
		        Vue.component('ui-toolbar', _UiToolbar2.default);
		        Vue.component('ui-tooltip', _UiTooltip2.default);
		    }
		};
		
		module.exports = Keen;
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		'use strict';
		
		document.addEventListener('DOMContentLoaded', function () {
		    var hadKeyboardEvent = false;
		    var keyboardModalityWhitelist = ['input:not([type])', 'input[type=text]', 'input[type=number]', 'input[type=date]', 'input[type=time]', 'input[type=datetime]', 'textarea', '[role=textbox]', '[supports-modality=keyboard]'].join(',');
		
		    var isHandlingKeyboardThrottle;
		
		    var matcher = function () {
		        var el = document.body;
		
		        if (el.matchesSelector) {
		            return el.matchesSelector;
		        }
		
		        if (el.webkitMatchesSelector) {
		            return el.webkitMatchesSelector;
		        }
		
		        if (el.mozMatchesSelector) {
		            return el.mozMatchesSelector;
		        }
		
		        if (el.msMatchesSelector) {
		            return el.msMatchesSelector;
		        }
		
		        console.error('Couldn\'t find any matchesSelector method on document.body.');
		    }();
		
		    var disableFocusRingByDefault = function disableFocusRingByDefault() {
		        var css = 'body:not([modality=keyboard]) :focus { outline: none; }';
		        var head = document.head || document.getElementsByTagName('head')[0];
		        var style = document.createElement('style');
		
		        style.type = 'text/css';
		        style.id = 'disable-focus-ring';
		
		        if (style.styleSheet) {
		            style.styleSheet.cssText = css;
		        } else {
		            style.appendChild(document.createTextNode(css));
		        }
		
		        head.insertBefore(style, head.firstChild);
		    };
		
		    var focusTriggersKeyboardModality = function focusTriggersKeyboardModality(el) {
		        var triggers = false;
		
		        if (matcher) {
		            triggers = matcher.call(el, keyboardModalityWhitelist) && matcher.call(el, ':not([readonly])');
		        }
		
		        return triggers;
		    };
		
		    disableFocusRingByDefault();
		
		    document.body.addEventListener('keydown', function () {
		        hadKeyboardEvent = true;
		
		        if (isHandlingKeyboardThrottle) {
		            clearTimeout(isHandlingKeyboardThrottle);
		        }
		
		        isHandlingKeyboardThrottle = setTimeout(function () {
		            hadKeyboardEvent = false;
		        }, 100);
		    }, true);
		
		    document.body.addEventListener('focus', function (e) {
		        if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
		            document.body.setAttribute('modality', 'keyboard');
		        }
		    }, true);
		
		    document.body.addEventListener('blur', function () {
		        document.body.removeAttribute('modality');
		    }, true);
		});
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(3)
		__vue_script__ = __webpack_require__(5)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAlert.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(80)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAlert.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 4 */,
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-alert',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: true
		        },
		        type: {
		            type: String,
		            default: 'info' },
		        text: String,
		        icon: String,
		        hideIcon: {
		            type: Boolean,
		            default: false
		        },
		        dismissible: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    computed: {
		        iconName: function iconName() {
		            if (this.icon) {
		                return this.icon;
		            }
		
		            var icon = this.type;
		
		            if (icon === 'success') {
		                icon = 'check_circle';
		            }
		
		            return icon;
		        }
		    },
		
		    methods: {
		        close: function close() {
		            this.show = false;
		            this.$dispatch('dismissed');
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiIconButton: _UiIconButton2.default
		    }
		};
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(7)
		__vue_script__ = __webpack_require__(8)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiIcon.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(9)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiIcon.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-icon',
		
		    props: {
		        icon: {
		            type: String,
		            required: true
		        },
		        removeText: {
		            type: Boolean,
		            default: false
		        }
		    }
		};
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
		module.exports = "\n<i\n    class=\"ui-icon material-icons\" :class=\"[icon]\" v-text=\"removeText ? null : icon\"\n    aria-hidden=\"true\"\n></i>\n";
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(11)
		__vue_script__ = __webpack_require__(12)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiIconButton.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(79)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiIconButton.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 11 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _HasDropdown = __webpack_require__(72);
		
		var _HasDropdown2 = _interopRequireDefault(_HasDropdown);
		
		var _ShowsTooltip = __webpack_require__(73);
		
		var _ShowsTooltip2 = _interopRequireDefault(_ShowsTooltip);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-icon-button',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-icon-button-' + type;
		            }
		        },
		        buttonType: {
		            type: String,
		            default: 'button'
		        },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        icon: {
		            type: String,
		            required: true
		        },
		        ariaLabel: String,
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.color];
		
		            if (this.hasDropdown) {
		                classes.push('ui-dropdown');
		            }
		
		            return classes;
		        },
		        spinnerColor: function spinnerColor() {
		            if (this.color === 'color-default' || this.color === 'color-black') {
		                return 'black';
		            }
		
		            return 'white';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiMenu: _UiMenu2.default,
		        UiPopover: _UiPopover2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasDropdown2.default, _ShowsTooltip2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(14)
		__vue_script__ = __webpack_require__(15)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiMenu.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(62)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiMenu.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 14 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiMenuOption = __webpack_require__(16);
		
		var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);
		
		var _ShowsDropdown = __webpack_require__(58);
		
		var _ShowsDropdown2 = _interopRequireDefault(_ShowsDropdown);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-menu',
		
		    props: {
		        options: {
		            type: Array,
		            required: true,
		            default: function _default() {
		                return [];
		            }
		        },
		        showIcons: {
		            type: Boolean,
		            default: false
		        },
		        showSecondaryText: {
		            type: Boolean,
		            default: false
		        },
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        },
		        closeOnSelect: {
		            type: Boolean,
		            default: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-menu-default'
		        }
		    },
		
		    events: {
		        'dropdown-opened': function dropdownOpened() {
		            if (this.containFocus) {
		                document.addEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('opened');
		
		            return true;
		        },
		
		        'dropdown-closed': function dropdownClosed() {
		            if (this.containFocus) {
		                document.removeEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('closed');
		
		            return true;
		        }
		    },
		
		    methods: {
		        optionSelect: function optionSelect(option) {
		            if (!(option.disabled || option.type === 'divider')) {
		                this.$dispatch('option-selected', option);
		
		                if (this.closeOnSelect) {
		                    this.closeDropdown();
		                }
		            }
		        },
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.dropdown.contains(e.target)) {
		                e.stopPropagation();
		
		                this.$els.dropdown.querySelector('.ui-menu-option').focus();
		            }
		        },
		        redirectFocus: function redirectFocus(e) {
		            e.stopPropagation();
		
		            this.$els.dropdown.querySelector('.ui-menu-option').focus();
		        }
		    },
		
		    components: {
		        UiMenuOption: _UiMenuOption2.default
		    },
		
		    mixins: [_ShowsDropdown2.default]
		};
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(17)
		__vue_script__ = __webpack_require__(18)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiMenuOption.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(57)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiMenuOption.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 17 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-menu-option',
		
		    props: {
		        type: String,
		        text: String,
		        icon: String,
		        showIcon: {
		            type: Boolean,
		            default: false
		        },
		        secondaryText: String,
		        showSecondaryText: {
		            type: Boolean,
		            default: false
		        },
		        partial: {
		            type: String,
		            default: 'ui-menu-default'
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        },
		        option: Object
		    },
		
		    computed: {
		        isDivider: function isDivider() {
		            return this.type === 'divider';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    partials: {
		        'ui-menu-default': '\n            <ui-icon\n                class="ui-menu-option-icon" :icon="icon" v-if="showIcon && !isDivider && icon"\n            ></ui-icon>\n\n            <div class="ui-menu-option-text" v-text="text" v-if="!isDivider"></div>\n\n            <div\n                class="ui-menu-option-secondary-text" v-text="secondaryText"\n                v-if="showSecondaryText && !isDivider && secondaryText"\n            ></div>\n        '
		    },
		
		    mixins: [_ShowsRippleInk2.default]
		};
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRippleInk = __webpack_require__(20);
		
		var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiRippleInk: _UiRippleInk2.default
		    }
		};
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(21)
		__vue_script__ = __webpack_require__(22)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRippleInk.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(56)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRippleInk.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 21 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var startRipple = function startRipple(eventType, event) {
		    var holder = event.currentTarget;
		
		    if (!_classlist2.default.has(holder, 'ui-ripple-ink')) {
		        holder = holder.querySelector('.ui-ripple-ink');
		
		        if (!holder) {
		            return;
		        }
		    }
		
		    var prev = holder.getAttribute('data-ui-event');
		
		    if (prev && prev !== eventType) {
		        return;
		    }
		
		    holder.setAttribute('data-ui-event', eventType);
		
		    var rect = holder.getBoundingClientRect();
		    var x = event.offsetX;
		    var y;
		
		    if (x !== undefined) {
		        y = event.offsetY;
		    } else {
		        x = event.clientX - rect.left;
		        y = event.clientY - rect.top;
		    }
		
		    var ripple = document.createElement('div');
		    var max;
		
		    if (rect.width === rect.height) {
		        max = rect.width * 1.412;
		    } else {
		        max = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
		    }
		
		    var dim = max * 2 + 'px';
		
		    ripple.style.width = dim;
		    ripple.style.height = dim;
		    ripple.style.marginLeft = -max + x + 'px';
		    ripple.style.marginTop = -max + y + 'px';
		
		    ripple.className = 'ripple';
		    holder.appendChild(ripple);
		
		    setTimeout(function () {
		        _classlist2.default.add(ripple, 'held');
		    }, 0);
		
		    var releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';
		
		    var release = function release() {
		        document.removeEventListener(releaseEvent, release);
		
		        _classlist2.default.add(ripple, 'done');
		
		        setTimeout(function () {
		            holder.removeChild(ripple);
		
		            if (!holder.children.length) {
		                _classlist2.default.remove(holder, 'active');
		                holder.removeAttribute('data-ui-event');
		            }
		        }, 450);
		    };
		
		    document.addEventListener(releaseEvent, release);
		};
		
		var handleMouseDown = function handleMouseDown(e) {
		    if (e.button === 0) {
		        startRipple(e.type, e);
		    }
		};
		
		var handleTouchStart = function handleTouchStart(e) {
		    if (e.changedTouches) {
		        for (var i = 0; i < e.changedTouches.length; ++i) {
		            startRipple(e.type, e.changedTouches[i]);
		        }
		    }
		};
		
		exports.default = {
		    name: 'ui-ripple-ink',
		
		    props: {
		        trigger: {
		            type: Element,
		            required: true
		        }
		    },
		
		    watch: {
		        trigger: function trigger() {
		            this.initialize();
		        }
		    },
		
		    ready: function ready() {
		        this.initialize();
		    },
		    beforeDestory: function beforeDestory() {
		        if (this.trigger) {
		            this.trigger.removeEventListener('mousedown', handleMouseDown);
		            this.trigger.removeEventListener('touchstart', handleTouchStart);
		        }
		    },
		
		
		    methods: {
		        initialize: function initialize() {
		            if (this.trigger) {
		                this.trigger.addEventListener('touchstart', handleTouchStart);
		                this.trigger.addEventListener('mousedown', handleMouseDown);
		            }
		        }
		    }
		};
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _typeof2 = __webpack_require__(24);
		
		var _typeof3 = _interopRequireDefault(_typeof2);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var trim = /^\s+|\s+$/g;
		var whitespace = /\s+/g;
		
		function interpret(input) {
		    return typeof input === 'string' ? input.replace(trim, '').split(whitespace) : input;
		}
		
		function classes(el) {
		    if (isElement(el)) {
		        return el.className.replace(trim, '').split(whitespace);
		    }
		
		    return [];
		}
		
		function set(el, input) {
		    if (isElement(el)) {
		        el.className = interpret(input).join(' ');
		    }
		}
		
		function add(el, input) {
		    var current = remove(el, input);
		    var values = interpret(input);
		
		    current.push.apply(current, values);
		    set(el, current);
		
		    return current;
		}
		
		function remove(el, input) {
		    var current = classes(el);
		    var values = interpret(input);
		
		    values.forEach(function (value) {
		        var i = current.indexOf(value);
		        if (i !== -1) {
		            current.splice(i, 1);
		        }
		    });
		
		    set(el, current);
		
		    return current;
		}
		
		function contains(el, input) {
		    var current = classes(el);
		    var values = interpret(input);
		
		    return values.every(function (value) {
		        return current.indexOf(value) !== -1;
		    });
		}
		
		function isElement(o) {
		    var elementObjects = (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object';
		
		    return elementObjects ? o instanceof HTMLElement : isElementObject(o);
		}
		
		function isElementObject(o) {
		    return o && (typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) === 'object' && typeof o.nodeName === 'string' && o.nodeType === 1;
		}
		
		exports.default = {
		    add: add,
		    remove: remove,
		    contains: contains,
		    has: contains,
		    set: set,
		    get: classes
		};
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		var _Symbol = __webpack_require__(25)["default"];
		
		exports["default"] = function (obj) {
		  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
		};
		
		exports.__esModule = true;
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = { "default": __webpack_require__(26), __esModule: true };
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(27);
		__webpack_require__(55);
		module.exports = __webpack_require__(34).Symbol;
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// ECMAScript 6 symbols shim
		var $              = __webpack_require__(28)
		  , global         = __webpack_require__(29)
		  , has            = __webpack_require__(30)
		  , DESCRIPTORS    = __webpack_require__(31)
		  , $export        = __webpack_require__(33)
		  , redefine       = __webpack_require__(37)
		  , $fails         = __webpack_require__(32)
		  , shared         = __webpack_require__(40)
		  , setToStringTag = __webpack_require__(41)
		  , uid            = __webpack_require__(43)
		  , wks            = __webpack_require__(42)
		  , keyOf          = __webpack_require__(44)
		  , $names         = __webpack_require__(49)
		  , enumKeys       = __webpack_require__(50)
		  , isArray        = __webpack_require__(51)
		  , anObject       = __webpack_require__(52)
		  , toIObject      = __webpack_require__(45)
		  , createDesc     = __webpack_require__(39)
		  , getDesc        = $.getDesc
		  , setDesc        = $.setDesc
		  , _create        = $.create
		  , getNames       = $names.get
		  , $Symbol        = global.Symbol
		  , $JSON          = global.JSON
		  , _stringify     = $JSON && $JSON.stringify
		  , setter         = false
		  , HIDDEN         = wks('_hidden')
		  , isEnum         = $.isEnum
		  , SymbolRegistry = shared('symbol-registry')
		  , AllSymbols     = shared('symbols')
		  , useNative      = typeof $Symbol == 'function'
		  , ObjectProto    = Object.prototype;
		
		// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
		var setSymbolDesc = DESCRIPTORS && $fails(function(){
		  return _create(setDesc({}, 'a', {
		    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
		  })).a != 7;
		}) ? function(it, key, D){
		  var protoDesc = getDesc(ObjectProto, key);
		  if(protoDesc)delete ObjectProto[key];
		  setDesc(it, key, D);
		  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
		} : setDesc;
		
		var wrap = function(tag){
		  var sym = AllSymbols[tag] = _create($Symbol.prototype);
		  sym._k = tag;
		  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
		    configurable: true,
		    set: function(value){
		      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
		      setSymbolDesc(this, tag, createDesc(1, value));
		    }
		  });
		  return sym;
		};
		
		var isSymbol = function(it){
		  return typeof it == 'symbol';
		};
		
		var $defineProperty = function defineProperty(it, key, D){
		  if(D && has(AllSymbols, key)){
		    if(!D.enumerable){
		      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
		      it[HIDDEN][key] = true;
		    } else {
		      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
		      D = _create(D, {enumerable: createDesc(0, false)});
		    } return setSymbolDesc(it, key, D);
		  } return setDesc(it, key, D);
		};
		var $defineProperties = function defineProperties(it, P){
		  anObject(it);
		  var keys = enumKeys(P = toIObject(P))
		    , i    = 0
		    , l = keys.length
		    , key;
		  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
		  return it;
		};
		var $create = function create(it, P){
		  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
		};
		var $propertyIsEnumerable = function propertyIsEnumerable(key){
		  var E = isEnum.call(this, key);
		  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
		    ? E : true;
		};
		var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
		  var D = getDesc(it = toIObject(it), key);
		  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
		  return D;
		};
		var $getOwnPropertyNames = function getOwnPropertyNames(it){
		  var names  = getNames(toIObject(it))
		    , result = []
		    , i      = 0
		    , key;
		  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
		  return result;
		};
		var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
		  var names  = getNames(toIObject(it))
		    , result = []
		    , i      = 0
		    , key;
		  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
		  return result;
		};
		var $stringify = function stringify(it){
		  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
		  var args = [it]
		    , i    = 1
		    , $$   = arguments
		    , replacer, $replacer;
		  while($$.length > i)args.push($$[i++]);
		  replacer = args[1];
		  if(typeof replacer == 'function')$replacer = replacer;
		  if($replacer || !isArray(replacer))replacer = function(key, value){
		    if($replacer)value = $replacer.call(this, key, value);
		    if(!isSymbol(value))return value;
		  };
		  args[1] = replacer;
		  return _stringify.apply($JSON, args);
		};
		var buggyJSON = $fails(function(){
		  var S = $Symbol();
		  // MS Edge converts symbol values to JSON as {}
		  // WebKit converts symbol values to JSON as null
		  // V8 throws on boxed symbols
		  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
		});
		
		// 19.4.1.1 Symbol([description])
		if(!useNative){
		  $Symbol = function Symbol(){
		    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
		    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
		  };
		  redefine($Symbol.prototype, 'toString', function toString(){
		    return this._k;
		  });
		
		  isSymbol = function(it){
		    return it instanceof $Symbol;
		  };
		
		  $.create     = $create;
		  $.isEnum     = $propertyIsEnumerable;
		  $.getDesc    = $getOwnPropertyDescriptor;
		  $.setDesc    = $defineProperty;
		  $.setDescs   = $defineProperties;
		  $.getNames   = $names.get = $getOwnPropertyNames;
		  $.getSymbols = $getOwnPropertySymbols;
		
		  if(DESCRIPTORS && !__webpack_require__(54)){
		    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
		  }
		}
		
		var symbolStatics = {
		  // 19.4.2.1 Symbol.for(key)
		  'for': function(key){
		    return has(SymbolRegistry, key += '')
		      ? SymbolRegistry[key]
		      : SymbolRegistry[key] = $Symbol(key);
		  },
		  // 19.4.2.5 Symbol.keyFor(sym)
		  keyFor: function keyFor(key){
		    return keyOf(SymbolRegistry, key);
		  },
		  useSetter: function(){ setter = true; },
		  useSimple: function(){ setter = false; }
		};
		// 19.4.2.2 Symbol.hasInstance
		// 19.4.2.3 Symbol.isConcatSpreadable
		// 19.4.2.4 Symbol.iterator
		// 19.4.2.6 Symbol.match
		// 19.4.2.8 Symbol.replace
		// 19.4.2.9 Symbol.search
		// 19.4.2.10 Symbol.species
		// 19.4.2.11 Symbol.split
		// 19.4.2.12 Symbol.toPrimitive
		// 19.4.2.13 Symbol.toStringTag
		// 19.4.2.14 Symbol.unscopables
		$.each.call((
		  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
		  'species,split,toPrimitive,toStringTag,unscopables'
		).split(','), function(it){
		  var sym = wks(it);
		  symbolStatics[it] = useNative ? sym : wrap(sym);
		});
		
		setter = true;
		
		$export($export.G + $export.W, {Symbol: $Symbol});
		
		$export($export.S, 'Symbol', symbolStatics);
		
		$export($export.S + $export.F * !useNative, 'Object', {
		  // 19.1.2.2 Object.create(O [, Properties])
		  create: $create,
		  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
		  defineProperty: $defineProperty,
		  // 19.1.2.3 Object.defineProperties(O, Properties)
		  defineProperties: $defineProperties,
		  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
		  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
		  // 19.1.2.7 Object.getOwnPropertyNames(O)
		  getOwnPropertyNames: $getOwnPropertyNames,
		  // 19.1.2.8 Object.getOwnPropertySymbols(O)
		  getOwnPropertySymbols: $getOwnPropertySymbols
		});
		
		// 24.3.2 JSON.stringify(value [, replacer [, space]])
		$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
		
		// 19.4.3.5 Symbol.prototype[@@toStringTag]
		setToStringTag($Symbol, 'Symbol');
		// 20.2.1.9 Math[@@toStringTag]
		setToStringTag(Math, 'Math', true);
		// 24.3.3 JSON[@@toStringTag]
		setToStringTag(global.JSON, 'JSON', true);
	
	/***/ },
	/* 28 */
	/***/ function(module, exports) {
	
		var $Object = Object;
		module.exports = {
		  create:     $Object.create,
		  getProto:   $Object.getPrototypeOf,
		  isEnum:     {}.propertyIsEnumerable,
		  getDesc:    $Object.getOwnPropertyDescriptor,
		  setDesc:    $Object.defineProperty,
		  setDescs:   $Object.defineProperties,
		  getKeys:    $Object.keys,
		  getNames:   $Object.getOwnPropertyNames,
		  getSymbols: $Object.getOwnPropertySymbols,
		  each:       [].forEach
		};
	
	/***/ },
	/* 29 */
	/***/ function(module, exports) {
	
		// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		var global = module.exports = typeof window != 'undefined' && window.Math == Math
		  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
		if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
	
	/***/ },
	/* 30 */
	/***/ function(module, exports) {
	
		var hasOwnProperty = {}.hasOwnProperty;
		module.exports = function(it, key){
		  return hasOwnProperty.call(it, key);
		};
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Thank's IE8 for his funny defineProperty
		module.exports = !__webpack_require__(32)(function(){
		  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
		});
	
	/***/ },
	/* 32 */
	/***/ function(module, exports) {
	
		module.exports = function(exec){
		  try {
		    return !!exec();
		  } catch(e){
		    return true;
		  }
		};
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global    = __webpack_require__(29)
		  , core      = __webpack_require__(34)
		  , ctx       = __webpack_require__(35)
		  , PROTOTYPE = 'prototype';
		
		var $export = function(type, name, source){
		  var IS_FORCED = type & $export.F
		    , IS_GLOBAL = type & $export.G
		    , IS_STATIC = type & $export.S
		    , IS_PROTO  = type & $export.P
		    , IS_BIND   = type & $export.B
		    , IS_WRAP   = type & $export.W
		    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
		    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
		    , key, own, out;
		  if(IS_GLOBAL)source = name;
		  for(key in source){
		    // contains in native
		    own = !IS_FORCED && target && key in target;
		    if(own && key in exports)continue;
		    // export native or passed
		    out = own ? target[key] : source[key];
		    // prevent global pollution for namespaces
		    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
		    // bind timers to global for call from export context
		    : IS_BIND && own ? ctx(out, global)
		    // wrap global constructors for prevent change them in library
		    : IS_WRAP && target[key] == out ? (function(C){
		      var F = function(param){
		        return this instanceof C ? new C(param) : C(param);
		      };
		      F[PROTOTYPE] = C[PROTOTYPE];
		      return F;
		    // make static versions for prototype methods
		    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
		    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
		  }
		};
		// type bitmap
		$export.F = 1;  // forced
		$export.G = 2;  // global
		$export.S = 4;  // static
		$export.P = 8;  // proto
		$export.B = 16; // bind
		$export.W = 32; // wrap
		module.exports = $export;
	
	/***/ },
	/* 34 */
	/***/ function(module, exports) {
	
		var core = module.exports = {version: '1.2.6'};
		if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		// optional / simple context binding
		var aFunction = __webpack_require__(36);
		module.exports = function(fn, that, length){
		  aFunction(fn);
		  if(that === undefined)return fn;
		  switch(length){
		    case 1: return function(a){
		      return fn.call(that, a);
		    };
		    case 2: return function(a, b){
		      return fn.call(that, a, b);
		    };
		    case 3: return function(a, b, c){
		      return fn.call(that, a, b, c);
		    };
		  }
		  return function(/* ...args */){
		    return fn.apply(that, arguments);
		  };
		};
	
	/***/ },
	/* 36 */
	/***/ function(module, exports) {
	
		module.exports = function(it){
		  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
		  return it;
		};
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(38);
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $          = __webpack_require__(28)
		  , createDesc = __webpack_require__(39);
		module.exports = __webpack_require__(31) ? function(object, key, value){
		  return $.setDesc(object, key, createDesc(1, value));
		} : function(object, key, value){
		  object[key] = value;
		  return object;
		};
	
	/***/ },
	/* 39 */
	/***/ function(module, exports) {
	
		module.exports = function(bitmap, value){
		  return {
		    enumerable  : !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable    : !(bitmap & 4),
		    value       : value
		  };
		};
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global = __webpack_require__(29)
		  , SHARED = '__core-js_shared__'
		  , store  = global[SHARED] || (global[SHARED] = {});
		module.exports = function(key){
		  return store[key] || (store[key] = {});
		};
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		var def = __webpack_require__(28).setDesc
		  , has = __webpack_require__(30)
		  , TAG = __webpack_require__(42)('toStringTag');
		
		module.exports = function(it, tag, stat){
		  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
		};
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		var store  = __webpack_require__(40)('wks')
		  , uid    = __webpack_require__(43)
		  , Symbol = __webpack_require__(29).Symbol;
		module.exports = function(name){
		  return store[name] || (store[name] =
		    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
		};
	
	/***/ },
	/* 43 */
	/***/ function(module, exports) {
	
		var id = 0
		  , px = Math.random();
		module.exports = function(key){
		  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
		};
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $         = __webpack_require__(28)
		  , toIObject = __webpack_require__(45);
		module.exports = function(object, el){
		  var O      = toIObject(object)
		    , keys   = $.getKeys(O)
		    , length = keys.length
		    , index  = 0
		    , key;
		  while(length > index)if(O[key = keys[index++]] === el)return key;
		};
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		// to indexed object, toObject with fallback for non-array-like ES3 strings
		var IObject = __webpack_require__(46)
		  , defined = __webpack_require__(48);
		module.exports = function(it){
		  return IObject(defined(it));
		};
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		// fallback for non-array-like ES3 and non-enumerable old V8 strings
		var cof = __webpack_require__(47);
		module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
		  return cof(it) == 'String' ? it.split('') : Object(it);
		};
	
	/***/ },
	/* 47 */
	/***/ function(module, exports) {
	
		var toString = {}.toString;
		
		module.exports = function(it){
		  return toString.call(it).slice(8, -1);
		};
	
	/***/ },
	/* 48 */
	/***/ function(module, exports) {
	
		// 7.2.1 RequireObjectCoercible(argument)
		module.exports = function(it){
		  if(it == undefined)throw TypeError("Can't call method on  " + it);
		  return it;
		};
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
		// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
		var toIObject = __webpack_require__(45)
		  , getNames  = __webpack_require__(28).getNames
		  , toString  = {}.toString;
		
		var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
		  ? Object.getOwnPropertyNames(window) : [];
		
		var getWindowNames = function(it){
		  try {
		    return getNames(it);
		  } catch(e){
		    return windowNames.slice();
		  }
		};
		
		module.exports.get = function getOwnPropertyNames(it){
		  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
		  return getNames(toIObject(it));
		};
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		// all enumerable object keys, includes symbols
		var $ = __webpack_require__(28);
		module.exports = function(it){
		  var keys       = $.getKeys(it)
		    , getSymbols = $.getSymbols;
		  if(getSymbols){
		    var symbols = getSymbols(it)
		      , isEnum  = $.isEnum
		      , i       = 0
		      , key;
		    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
		  }
		  return keys;
		};
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 7.2.2 IsArray(argument)
		var cof = __webpack_require__(47);
		module.exports = Array.isArray || function(arg){
		  return cof(arg) == 'Array';
		};
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObject = __webpack_require__(53);
		module.exports = function(it){
		  if(!isObject(it))throw TypeError(it + ' is not an object!');
		  return it;
		};
	
	/***/ },
	/* 53 */
	/***/ function(module, exports) {
	
		module.exports = function(it){
		  return typeof it === 'object' ? it !== null : typeof it === 'function';
		};
	
	/***/ },
	/* 54 */
	/***/ function(module, exports) {
	
		module.exports = true;
	
	/***/ },
	/* 55 */
	/***/ function(module, exports) {
	
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-ripple-ink\"></div>\n";
	
	/***/ },
	/* 57 */
	/***/ function(module, exports) {
	
		module.exports = "\n<a\n    class=\"ui-menu-option\" role=\"menu-item\" :tabindex=\"(isDivider || disabled) ? null : '0'\"\n    :class=\"{ 'divider': isDivider, 'disabled' : disabled }\"\n>\n    <div class=\"ui-menu-option-content\" :class=\"[partial]\">\n        <partial :name=\"partial\"></partial>\n    </div>\n\n    <ui-ripple-ink\n        :trigger=\"$el\" v-if=\"!hideRippleInk && !disabled && !isDivider\"\n    ></ui-ripple-ink>\n</a>\n";
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _tetherDrop = __webpack_require__(59);
		
		var _tetherDrop2 = _interopRequireDefault(_tetherDrop);
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        id: String,
		        trigger: Element,
		        containFocus: {
		            type: Boolean,
		            default: true
		        },
		        dropdownPosition: {
		            type: String,
		            default: 'bottom left'
		        },
		        openOn: {
		            type: String,
		            default: 'click' }
		    },
		
		    data: function data() {
		        return {
		            drop: null,
		            lastFocussedElement: null
		        };
		    },
		    ready: function ready() {
		        if (this.trigger) {
		            this.initializeDropdown();
		        }
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.drop) {
		            this.drop.remove();
		            this.drop.destroy();
		        }
		    },
		
		
		    events: {
		        'ui-dropdown::open': function uiDropdownOpen(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.openDropdown();
		        },
		
		        'ui-dropdown::close': function uiDropdownClose(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.closeDropdown();
		        },
		
		        'ui-dropdown::toggle': function uiDropdownToggle(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.toggleDropdown();
		        }
		    },
		
		    methods: {
		        initializeDropdown: function initializeDropdown() {
		            this.drop = new _tetherDrop2.default({
		                target: this.trigger,
		                content: this.$els.dropdown,
		                position: this.dropdownPosition,
		                constrainToWindow: true,
		                openOn: this.openOn
		            });
		
		            if (this.dropdownPosition !== 'bottom left') {
		                this.drop.open();
		                this.drop.close();
		                this.drop.open();
		                this.drop.close();
		            }
		
		            this.drop.on('open', this.positionDrop);
		            this.drop.on('open', this.dropdownOpened);
		            this.drop.on('close', this.dropdownClosed);
		        },
		        openDropdown: function openDropdown() {
		            if (this.drop) {
		                this.drop.open();
		            }
		        },
		        positionDrop: function positionDrop() {
		            var drop = this.drop;
		            var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		
		            var dropWidth = drop.drop.getBoundingClientRect().width;
		            var left = drop.target.getBoundingClientRect().left;
		            var availableSpace = windowWidth - left;
		
		            if (dropWidth > availableSpace) {
		                var direction = dropWidth > availableSpace ? 'right' : 'left';
		
		                drop.tether.attachment.left = direction;
		                drop.tether.targetAttachment.left = direction;
		
		                drop.position();
		            }
		        },
		        closeDropdown: function closeDropdown() {
		            if (this.drop) {
		                this.drop.close();
		            }
		        },
		        toggleDropdown: function toggleDropdown(e) {
		            if (this.drop) {
		                this.drop.toggle(e);
		            }
		        },
		        dropdownOpened: function dropdownOpened() {
		            _classlist2.default.add(this.trigger, 'dropdown-open');
		
		            this.lastFocussedElement = document.activeElement;
		            this.$els.dropdown.focus();
		
		            this.$dispatch('dropdown-opened');
		        },
		        dropdownClosed: function dropdownClosed() {
		            _classlist2.default.remove(this.trigger, 'dropdown-open');
		
		            if (this.lastFocussedElement) {
		                this.lastFocussedElement.focus();
		            }
		
		            this.$dispatch('dropdown-closed');
		        }
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether-drop 1.4.1 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require('tether'));
		  } else {
		    root.Drop = factory(root.Tether);
		  }
		}(this, function(Tether) {
		
		/* global Tether */
		'use strict';
		
		var _bind = Function.prototype.bind;
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var _Tether$Utils = Tether.Utils;
		var extend = _Tether$Utils.extend;
		var addClass = _Tether$Utils.addClass;
		var removeClass = _Tether$Utils.removeClass;
		var hasClass = _Tether$Utils.hasClass;
		var Evented = _Tether$Utils.Evented;
		
		function sortAttach(str) {
		  var _str$split = str.split(' ');
		
		  var _str$split2 = _slicedToArray(_str$split, 2);
		
		  var first = _str$split2[0];
		  var second = _str$split2[1];
		
		  if (['left', 'right'].indexOf(first) >= 0) {
		    var _ref = [second, first];
		    first = _ref[0];
		    second = _ref[1];
		  }
		  return [first, second].join(' ');
		}
		
		function removeFromArray(arr, item) {
		  var index = undefined;
		  var results = [];
		  while ((index = arr.indexOf(item)) !== -1) {
		    results.push(arr.splice(index, 1));
		  }
		  return results;
		}
		
		var clickEvents = ['click'];
		if ('ontouchstart' in document.documentElement) {
		  clickEvents.push('touchstart');
		}
		
		var transitionEndEvents = {
		  'WebkitTransition': 'webkitTransitionEnd',
		  'MozTransition': 'transitionend',
		  'OTransition': 'otransitionend',
		  'transition': 'transitionend'
		};
		
		var transitionEndEvent = '';
		for (var _name in transitionEndEvents) {
		  if (({}).hasOwnProperty.call(transitionEndEvents, _name)) {
		    var tempEl = document.createElement('p');
		    if (typeof tempEl.style[_name] !== 'undefined') {
		      transitionEndEvent = transitionEndEvents[_name];
		    }
		  }
		}
		
		var MIRROR_ATTACH = {
		  left: 'right',
		  right: 'left',
		  top: 'bottom',
		  bottom: 'top',
		  middle: 'middle',
		  center: 'center'
		};
		
		var allDrops = {};
		
		// Drop can be included in external libraries.  Calling createContext gives you a fresh
		// copy of drop which won't interact with other copies on the page (beyond calling the document events).
		
		function createContext() {
		  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		  var drop = function drop() {
		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }
		
		    return new (_bind.apply(DropInstance, [null].concat(args)))();
		  };
		
		  extend(drop, {
		    createContext: createContext,
		    drops: [],
		    defaults: {}
		  });
		
		  var defaultOptions = {
		    classPrefix: 'drop',
		    defaults: {
		      position: 'bottom left',
		      openOn: 'click',
		      beforeClose: null,
		      constrainToScrollParent: true,
		      constrainToWindow: true,
		      classes: '',
		      remove: false,
		      openDelay: 0,
		      closeDelay: 50,
		      // inherited from openDelay and closeDelay if not explicitly defined
		      focusDelay: null,
		      blurDelay: null,
		      hoverOpenDelay: null,
		      hoverCloseDelay: null,
		      tetherOptions: {}
		    }
		  };
		
		  extend(drop, defaultOptions, options);
		  extend(drop.defaults, defaultOptions.defaults, options.defaults);
		
		  if (typeof allDrops[drop.classPrefix] === 'undefined') {
		    allDrops[drop.classPrefix] = [];
		  }
		
		  drop.updateBodyClasses = function () {
		    // There is only one body, so despite the context concept, we still iterate through all
		    // drops which share our classPrefix.
		
		    var anyOpen = false;
		    var drops = allDrops[drop.classPrefix];
		    var len = drops.length;
		    for (var i = 0; i < len; ++i) {
		      if (drops[i].isOpened()) {
		        anyOpen = true;
		        break;
		      }
		    }
		
		    if (anyOpen) {
		      addClass(document.body, drop.classPrefix + '-open');
		    } else {
		      removeClass(document.body, drop.classPrefix + '-open');
		    }
		  };
		
		  var DropInstance = (function (_Evented) {
		    _inherits(DropInstance, _Evented);
		
		    function DropInstance(opts) {
		      _classCallCheck(this, DropInstance);
		
		      _get(Object.getPrototypeOf(DropInstance.prototype), 'constructor', this).call(this);
		      this.options = extend({}, drop.defaults, opts);
		      this.target = this.options.target;
		
		      if (typeof this.target === 'undefined') {
		        throw new Error('Drop Error: You must provide a target.');
		      }
		
		      var dataPrefix = 'data-' + drop.classPrefix;
		
		      var contentAttr = this.target.getAttribute(dataPrefix);
		      if (contentAttr && this.options.content == null) {
		        this.options.content = contentAttr;
		      }
		
		      var attrsOverride = ['position', 'openOn'];
		      for (var i = 0; i < attrsOverride.length; ++i) {
		
		        var override = this.target.getAttribute(dataPrefix + '-' + attrsOverride[i]);
		        if (override && this.options[attrsOverride[i]] == null) {
		          this.options[attrsOverride[i]] = override;
		        }
		      }
		
		      if (this.options.classes && this.options.addTargetClasses !== false) {
		        addClass(this.target, this.options.classes);
		      }
		
		      drop.drops.push(this);
		      allDrops[drop.classPrefix].push(this);
		
		      this._boundEvents = [];
		      this.bindMethods();
		      this.setupElements();
		      this.setupEvents();
		      this.setupTether();
		    }
		
		    _createClass(DropInstance, [{
		      key: '_on',
		      value: function _on(element, event, handler) {
		        this._boundEvents.push({ element: element, event: event, handler: handler });
		        element.addEventListener(event, handler);
		      }
		    }, {
		      key: 'bindMethods',
		      value: function bindMethods() {
		        this.transitionEndHandler = this._transitionEndHandler.bind(this);
		      }
		    }, {
		      key: 'setupElements',
		      value: function setupElements() {
		        var _this = this;
		
		        this.drop = document.createElement('div');
		        addClass(this.drop, drop.classPrefix);
		
		        if (this.options.classes) {
		          addClass(this.drop, this.options.classes);
		        }
		
		        this.content = document.createElement('div');
		        addClass(this.content, drop.classPrefix + '-content');
		
		        if (typeof this.options.content === 'function') {
		          var generateAndSetContent = function generateAndSetContent() {
		            // content function might return a string or an element
		            var contentElementOrHTML = _this.options.content.call(_this, _this);
		
		            if (typeof contentElementOrHTML === 'string') {
		              _this.content.innerHTML = contentElementOrHTML;
		            } else if (typeof contentElementOrHTML === 'object') {
		              _this.content.innerHTML = '';
		              _this.content.appendChild(contentElementOrHTML);
		            } else {
		              throw new Error('Drop Error: Content function should return a string or HTMLElement.');
		            }
		          };
		
		          generateAndSetContent();
		          this.on('open', generateAndSetContent.bind(this));
		        } else if (typeof this.options.content === 'object') {
		          this.content.appendChild(this.options.content);
		        } else {
		          this.content.innerHTML = this.options.content;
		        }
		
		        this.drop.appendChild(this.content);
		      }
		    }, {
		      key: 'setupTether',
		      value: function setupTether() {
		        // Tether expects two attachment points, one in the target element, one in the
		        // drop.  We use a single one, and use the order as well, to allow us to put
		        // the drop on either side of any of the four corners.  This magic converts between
		        // the two:
		        var dropAttach = this.options.position.split(' ');
		        dropAttach[0] = MIRROR_ATTACH[dropAttach[0]];
		        dropAttach = dropAttach.join(' ');
		
		        var constraints = [];
		        if (this.options.constrainToScrollParent) {
		          constraints.push({
		            to: 'scrollParent',
		            pin: 'top, bottom',
		            attachment: 'together none'
		          });
		        } else {
		          // To get 'out of bounds' classes
		          constraints.push({
		            to: 'scrollParent'
		          });
		        }
		
		        if (this.options.constrainToWindow !== false) {
		          constraints.push({
		            to: 'window',
		            attachment: 'together'
		          });
		        } else {
		          // To get 'out of bounds' classes
		          constraints.push({
		            to: 'window'
		          });
		        }
		
		        var opts = {
		          element: this.drop,
		          target: this.target,
		          attachment: sortAttach(dropAttach),
		          targetAttachment: sortAttach(this.options.position),
		          classPrefix: drop.classPrefix,
		          offset: '0 0',
		          targetOffset: '0 0',
		          enabled: false,
		          constraints: constraints,
		          addTargetClasses: this.options.addTargetClasses
		        };
		
		        if (this.options.tetherOptions !== false) {
		          this.tether = new Tether(extend({}, opts, this.options.tetherOptions));
		        }
		      }
		    }, {
		      key: 'setupEvents',
		      value: function setupEvents() {
		        var _this2 = this;
		
		        if (!this.options.openOn) {
		          return;
		        }
		
		        if (this.options.openOn === 'always') {
		          setTimeout(this.open.bind(this));
		          return;
		        }
		
		        var events = this.options.openOn.split(' ');
		
		        if (events.indexOf('click') >= 0) {
		          var openHandler = function openHandler(event) {
		            _this2.toggle(event);
		            event.preventDefault();
		          };
		
		          var closeHandler = function closeHandler(event) {
		            if (!_this2.isOpened()) {
		              return;
		            }
		
		            // Clicking inside dropdown
		            if (event.target === _this2.drop || _this2.drop.contains(event.target)) {
		              return;
		            }
		
		            // Clicking target
		            if (event.target === _this2.target || _this2.target.contains(event.target)) {
		              return;
		            }
		
		            _this2.close(event);
		          };
		
		          for (var i = 0; i < clickEvents.length; ++i) {
		            var clickEvent = clickEvents[i];
		            this._on(this.target, clickEvent, openHandler);
		            this._on(document, clickEvent, closeHandler);
		          }
		        }
		
		        var inTimeout = null;
		        var outTimeout = null;
		
		        var inHandler = function inHandler(event) {
		          if (outTimeout !== null) {
		            clearTimeout(outTimeout);
		          } else {
		            inTimeout = setTimeout(function () {
		              _this2.open(event);
		              inTimeout = null;
		            }, (event.type === 'focus' ? _this2.options.focusDelay : _this2.options.hoverOpenDelay) || _this2.options.openDelay);
		          }
		        };
		
		        var outHandler = function outHandler(event) {
		          if (inTimeout !== null) {
		            clearTimeout(inTimeout);
		          } else {
		            outTimeout = setTimeout(function () {
		              _this2.close(event);
		              outTimeout = null;
		            }, (event.type === 'blur' ? _this2.options.blurDelay : _this2.options.hoverCloseDelay) || _this2.options.closeDelay);
		          }
		        };
		
		        if (events.indexOf('hover') >= 0) {
		          this._on(this.target, 'mouseover', inHandler);
		          this._on(this.drop, 'mouseover', inHandler);
		          this._on(this.target, 'mouseout', outHandler);
		          this._on(this.drop, 'mouseout', outHandler);
		        }
		
		        if (events.indexOf('focus') >= 0) {
		          this._on(this.target, 'focus', inHandler);
		          this._on(this.drop, 'focus', inHandler);
		          this._on(this.target, 'blur', outHandler);
		          this._on(this.drop, 'blur', outHandler);
		        }
		      }
		    }, {
		      key: 'isOpened',
		      value: function isOpened() {
		        if (this.drop) {
		          return hasClass(this.drop, drop.classPrefix + '-open');
		        }
		      }
		    }, {
		      key: 'toggle',
		      value: function toggle(event) {
		        if (this.isOpened()) {
		          this.close(event);
		        } else {
		          this.open(event);
		        }
		      }
		    }, {
		      key: 'open',
		      value: function open(event) {
		        var _this3 = this;
		
		        /* eslint no-unused-vars: 0 */
		        if (this.isOpened()) {
		          return;
		        }
		
		        if (!this.drop.parentNode) {
		          document.body.appendChild(this.drop);
		        }
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.enable();
		        }
		
		        addClass(this.drop, drop.classPrefix + '-open');
		        addClass(this.drop, drop.classPrefix + '-open-transitionend');
		
		        setTimeout(function () {
		          if (_this3.drop) {
		            addClass(_this3.drop, drop.classPrefix + '-after-open');
		          }
		        });
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.position();
		        }
		
		        this.trigger('open');
		
		        drop.updateBodyClasses();
		      }
		    }, {
		      key: '_transitionEndHandler',
		      value: function _transitionEndHandler(e) {
		        if (e.target !== e.currentTarget) {
		          return;
		        }
		
		        if (!hasClass(this.drop, drop.classPrefix + '-open')) {
		          removeClass(this.drop, drop.classPrefix + '-open-transitionend');
		        }
		        this.drop.removeEventListener(transitionEndEvent, this.transitionEndHandler);
		      }
		    }, {
		      key: 'beforeCloseHandler',
		      value: function beforeCloseHandler(event) {
		        var shouldClose = true;
		
		        if (!this.isClosing && typeof this.options.beforeClose === 'function') {
		          this.isClosing = true;
		          shouldClose = this.options.beforeClose(event, this) !== false;
		        }
		
		        this.isClosing = false;
		
		        return shouldClose;
		      }
		    }, {
		      key: 'close',
		      value: function close(event) {
		        if (!this.isOpened()) {
		          return;
		        }
		
		        if (!this.beforeCloseHandler(event)) {
		          return;
		        }
		
		        removeClass(this.drop, drop.classPrefix + '-open');
		        removeClass(this.drop, drop.classPrefix + '-after-open');
		
		        this.drop.addEventListener(transitionEndEvent, this.transitionEndHandler);
		
		        this.trigger('close');
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.disable();
		        }
		
		        drop.updateBodyClasses();
		
		        if (this.options.remove) {
		          this.remove(event);
		        }
		      }
		    }, {
		      key: 'remove',
		      value: function remove(event) {
		        this.close(event);
		        if (this.drop.parentNode) {
		          this.drop.parentNode.removeChild(this.drop);
		        }
		      }
		    }, {
		      key: 'position',
		      value: function position() {
		        if (this.isOpened() && typeof this.tether !== 'undefined') {
		          this.tether.position();
		        }
		      }
		    }, {
		      key: 'destroy',
		      value: function destroy() {
		        this.remove();
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.destroy();
		        }
		
		        for (var i = 0; i < this._boundEvents.length; ++i) {
		          var _boundEvents$i = this._boundEvents[i];
		          var element = _boundEvents$i.element;
		          var _event = _boundEvents$i.event;
		          var handler = _boundEvents$i.handler;
		
		          element.removeEventListener(_event, handler);
		        }
		
		        this._boundEvents = [];
		
		        this.tether = null;
		        this.drop = null;
		        this.content = null;
		        this.target = null;
		
		        removeFromArray(allDrops[drop.classPrefix], this);
		        removeFromArray(drop.drops, this);
		      }
		    }]);
		
		    return DropInstance;
		  })(Evented);
		
		  return drop;
		}
		
		var Drop = createContext();
		
		document.addEventListener('DOMContentLoaded', function () {
		  Drop.updateBodyClasses();
		});
		return Drop;
		
		}));
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether 1.2.0 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require, exports, module);
		  } else {
		    root.Tether = factory();
		  }
		}(this, function(require, exports, module) {
		
		'use strict';
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		var TetherBase = undefined;
		if (typeof TetherBase === 'undefined') {
		  TetherBase = { modules: [] };
		}
		
		function getScrollParent(el) {
		  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;
		  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397
		  var computedStyle = getComputedStyle(el) || {};
		  var position = computedStyle.position;
		
		  if (position === 'fixed') {
		    return el;
		  }
		
		  var parent = el;
		  while (parent = parent.parentNode) {
		    var style = undefined;
		    try {
		      style = getComputedStyle(parent);
		    } catch (err) {}
		
		    if (typeof style === 'undefined' || style === null) {
		      return parent;
		    }
		
		    var _style = style;
		    var overflow = _style.overflow;
		    var overflowX = _style.overflowX;
		    var overflowY = _style.overflowY;
		
		    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
		      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {
		        return parent;
		      }
		    }
		  }
		
		  return document.body;
		}
		
		var uniqueId = (function () {
		  var id = 0;
		  return function () {
		    return ++id;
		  };
		})();
		
		var zeroPosCache = {};
		var getOrigin = function getOrigin(doc) {
		  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of
		  // jitter as the user scrolls that messes with our ability to detect if two positions
		  // are equivilant or not.  We place an element at the top left of the page that will
		  // get the same jitter, so we can cancel the two out.
		  var node = doc._tetherZeroElement;
		  if (typeof node === 'undefined') {
		    node = doc.createElement('div');
		    node.setAttribute('data-tether-id', uniqueId());
		    extend(node.style, {
		      top: 0,
		      left: 0,
		      position: 'absolute'
		    });
		
		    doc.body.appendChild(node);
		
		    doc._tetherZeroElement = node;
		  }
		
		  var id = node.getAttribute('data-tether-id');
		  if (typeof zeroPosCache[id] === 'undefined') {
		    zeroPosCache[id] = {};
		
		    var rect = node.getBoundingClientRect();
		    for (var k in rect) {
		      // Can't use extend, as on IE9, elements don't resolve to be hasOwnProperty
		      zeroPosCache[id][k] = rect[k];
		    }
		
		    // Clear the cache when this position call is done
		    defer(function () {
		      delete zeroPosCache[id];
		    });
		  }
		
		  return zeroPosCache[id];
		};
		
		function getBounds(el) {
		  var doc = undefined;
		  if (el === document) {
		    doc = document;
		    el = document.documentElement;
		  } else {
		    doc = el.ownerDocument;
		  }
		
		  var docEl = doc.documentElement;
		
		  var box = {};
		  // The original object returned by getBoundingClientRect is immutable, so we clone it
		  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9
		  var rect = el.getBoundingClientRect();
		  for (var k in rect) {
		    box[k] = rect[k];
		  }
		
		  var origin = getOrigin(doc);
		
		  box.top -= origin.top;
		  box.left -= origin.left;
		
		  if (typeof box.width === 'undefined') {
		    box.width = document.body.scrollWidth - box.left - box.right;
		  }
		  if (typeof box.height === 'undefined') {
		    box.height = document.body.scrollHeight - box.top - box.bottom;
		  }
		
		  box.top = box.top - docEl.clientTop;
		  box.left = box.left - docEl.clientLeft;
		  box.right = doc.body.clientWidth - box.width - box.left;
		  box.bottom = doc.body.clientHeight - box.height - box.top;
		
		  return box;
		}
		
		function getOffsetParent(el) {
		  return el.offsetParent || document.documentElement;
		}
		
		function getScrollBarSize() {
		  var inner = document.createElement('div');
		  inner.style.width = '100%';
		  inner.style.height = '200px';
		
		  var outer = document.createElement('div');
		  extend(outer.style, {
		    position: 'absolute',
		    top: 0,
		    left: 0,
		    pointerEvents: 'none',
		    visibility: 'hidden',
		    width: '200px',
		    height: '150px',
		    overflow: 'hidden'
		  });
		
		  outer.appendChild(inner);
		
		  document.body.appendChild(outer);
		
		  var widthContained = inner.offsetWidth;
		  outer.style.overflow = 'scroll';
		  var widthScroll = inner.offsetWidth;
		
		  if (widthContained === widthScroll) {
		    widthScroll = outer.clientWidth;
		  }
		
		  document.body.removeChild(outer);
		
		  var width = widthContained - widthScroll;
		
		  return { width: width, height: width };
		}
		
		function extend() {
		  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		  var args = [];
		
		  Array.prototype.push.apply(args, arguments);
		
		  args.slice(1).forEach(function (obj) {
		    if (obj) {
		      for (var key in obj) {
		        if (({}).hasOwnProperty.call(obj, key)) {
		          out[key] = obj[key];
		        }
		      }
		    }
		  });
		
		  return out;
		}
		
		function removeClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    name.split(' ').forEach(function (cls) {
		      if (cls.trim()) {
		        el.classList.remove(cls);
		      }
		    });
		  } else {
		    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');
		    var className = getClassName(el).replace(regex, ' ');
		    setClassName(el, className);
		  }
		}
		
		function addClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    name.split(' ').forEach(function (cls) {
		      if (cls.trim()) {
		        el.classList.add(cls);
		      }
		    });
		  } else {
		    removeClass(el, name);
		    var cls = getClassName(el) + (' ' + name);
		    setClassName(el, cls);
		  }
		}
		
		function hasClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    return el.classList.contains(name);
		  }
		  var className = getClassName(el);
		  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);
		}
		
		function getClassName(el) {
		  if (el.className instanceof SVGAnimatedString) {
		    return el.className.baseVal;
		  }
		  return el.className;
		}
		
		function setClassName(el, className) {
		  el.setAttribute('class', className);
		}
		
		function updateClasses(el, add, all) {
		  // Of the set of 'all' classes, we need the 'add' classes, and only the
		  // 'add' classes to be set.
		  all.forEach(function (cls) {
		    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
		      removeClass(el, cls);
		    }
		  });
		
		  add.forEach(function (cls) {
		    if (!hasClass(el, cls)) {
		      addClass(el, cls);
		    }
		  });
		}
		
		var deferred = [];
		
		var defer = function defer(fn) {
		  deferred.push(fn);
		};
		
		var flush = function flush() {
		  var fn = undefined;
		  while (fn = deferred.pop()) {
		    fn();
		  }
		};
		
		var Evented = (function () {
		  function Evented() {
		    _classCallCheck(this, Evented);
		  }
		
		  _createClass(Evented, [{
		    key: 'on',
		    value: function on(event, handler, ctx) {
		      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
		
		      if (typeof this.bindings === 'undefined') {
		        this.bindings = {};
		      }
		      if (typeof this.bindings[event] === 'undefined') {
		        this.bindings[event] = [];
		      }
		      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });
		    }
		  }, {
		    key: 'once',
		    value: function once(event, handler, ctx) {
		      this.on(event, handler, ctx, true);
		    }
		  }, {
		    key: 'off',
		    value: function off(event, handler) {
		      if (typeof this.bindings !== 'undefined' && typeof this.bindings[event] !== 'undefined') {
		        return;
		      }
		
		      if (typeof handler === 'undefined') {
		        delete this.bindings[event];
		      } else {
		        var i = 0;
		        while (i < this.bindings[event].length) {
		          if (this.bindings[event][i].handler === handler) {
		            this.bindings[event].splice(i, 1);
		          } else {
		            ++i;
		          }
		        }
		      }
		    }
		  }, {
		    key: 'trigger',
		    value: function trigger(event) {
		      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {
		        var i = 0;
		
		        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		          args[_key - 1] = arguments[_key];
		        }
		
		        while (i < this.bindings[event].length) {
		          var _bindings$event$i = this.bindings[event][i];
		          var handler = _bindings$event$i.handler;
		          var ctx = _bindings$event$i.ctx;
		          var once = _bindings$event$i.once;
		
		          var context = ctx;
		          if (typeof context === 'undefined') {
		            context = this;
		          }
		
		          handler.apply(context, args);
		
		          if (once) {
		            this.bindings[event].splice(i, 1);
		          } else {
		            ++i;
		          }
		        }
		      }
		    }
		  }]);
		
		  return Evented;
		})();
		
		TetherBase.Utils = {
		  getScrollParent: getScrollParent,
		  getBounds: getBounds,
		  getOffsetParent: getOffsetParent,
		  extend: extend,
		  addClass: addClass,
		  removeClass: removeClass,
		  hasClass: hasClass,
		  updateClasses: updateClasses,
		  defer: defer,
		  flush: flush,
		  uniqueId: uniqueId,
		  Evented: Evented,
		  getScrollBarSize: getScrollBarSize
		};
		/* globals TetherBase, performance */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		if (typeof TetherBase === 'undefined') {
		  throw new Error('You must include the utils.js file before tether.js');
		}
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getScrollParent = _TetherBase$Utils.getScrollParent;
		var getBounds = _TetherBase$Utils.getBounds;
		var getOffsetParent = _TetherBase$Utils.getOffsetParent;
		var extend = _TetherBase$Utils.extend;
		var addClass = _TetherBase$Utils.addClass;
		var removeClass = _TetherBase$Utils.removeClass;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		var flush = _TetherBase$Utils.flush;
		var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
		
		function within(a, b) {
		  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
		
		  return a + diff >= b && b >= a - diff;
		}
		
		var transformKey = (function () {
		  if (typeof document === 'undefined') {
		    return '';
		  }
		  var el = document.createElement('div');
		
		  var transforms = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
		  for (var i = 0; i < transforms.length; ++i) {
		    var key = transforms[i];
		    if (el.style[key] !== undefined) {
		      return key;
		    }
		  }
		})();
		
		var tethers = [];
		
		var position = function position() {
		  tethers.forEach(function (tether) {
		    tether.position(false);
		  });
		  flush();
		};
		
		function now() {
		  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {
		    return performance.now();
		  }
		  return +new Date();
		}
		
		(function () {
		  var lastCall = null;
		  var lastDuration = null;
		  var pendingTimeout = null;
		
		  var tick = function tick() {
		    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {
		      // We voluntarily throttle ourselves if we can't manage 60fps
		      lastDuration = Math.min(lastDuration - 16, 250);
		
		      // Just in case this is the last event, remember to position just once more
		      pendingTimeout = setTimeout(tick, 250);
		      return;
		    }
		
		    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {
		      // Some browsers call events a little too frequently, refuse to run more than is reasonable
		      return;
		    }
		
		    if (typeof pendingTimeout !== 'undefined') {
		      clearTimeout(pendingTimeout);
		      pendingTimeout = null;
		    }
		
		    lastCall = now();
		    position();
		    lastDuration = now() - lastCall;
		  };
		
		  if (typeof window !== 'undefined') {
		    ['resize', 'scroll', 'touchmove'].forEach(function (event) {
		      window.addEventListener(event, tick);
		    });
		  }
		})();
		
		var MIRROR_LR = {
		  center: 'center',
		  left: 'right',
		  right: 'left'
		};
		
		var MIRROR_TB = {
		  middle: 'middle',
		  top: 'bottom',
		  bottom: 'top'
		};
		
		var OFFSET_MAP = {
		  top: 0,
		  left: 0,
		  middle: '50%',
		  center: '50%',
		  bottom: '100%',
		  right: '100%'
		};
		
		var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
		  var left = attachment.left;
		  var top = attachment.top;
		
		  if (left === 'auto') {
		    left = MIRROR_LR[relativeToAttachment.left];
		  }
		
		  if (top === 'auto') {
		    top = MIRROR_TB[relativeToAttachment.top];
		  }
		
		  return { left: left, top: top };
		};
		
		var attachmentToOffset = function attachmentToOffset(attachment) {
		  var left = attachment.left;
		  var top = attachment.top;
		
		  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {
		    left = OFFSET_MAP[attachment.left];
		  }
		
		  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {
		    top = OFFSET_MAP[attachment.top];
		  }
		
		  return { left: left, top: top };
		};
		
		function addOffset() {
		  var out = { top: 0, left: 0 };
		
		  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
		    offsets[_key] = arguments[_key];
		  }
		
		  offsets.forEach(function (_ref) {
		    var top = _ref.top;
		    var left = _ref.left;
		
		    if (typeof top === 'string') {
		      top = parseFloat(top, 10);
		    }
		    if (typeof left === 'string') {
		      left = parseFloat(left, 10);
		    }
		
		    out.top += top;
		    out.left += left;
		  });
		
		  return out;
		}
		
		function offsetToPx(offset, size) {
		  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
		    offset.left = parseFloat(offset.left, 10) / 100 * size.width;
		  }
		  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
		    offset.top = parseFloat(offset.top, 10) / 100 * size.height;
		  }
		
		  return offset;
		}
		
		var parseOffset = function parseOffset(value) {
		  var _value$split = value.split(' ');
		
		  var _value$split2 = _slicedToArray(_value$split, 2);
		
		  var top = _value$split2[0];
		  var left = _value$split2[1];
		
		  return { top: top, left: left };
		};
		var parseAttachment = parseOffset;
		
		var TetherClass = (function () {
		  function TetherClass(options) {
		    var _this = this;
		
		    _classCallCheck(this, TetherClass);
		
		    this.position = this.position.bind(this);
		
		    tethers.push(this);
		
		    this.history = [];
		
		    this.setOptions(options, false);
		
		    TetherBase.modules.forEach(function (module) {
		      if (typeof module.initialize !== 'undefined') {
		        module.initialize.call(_this);
		      }
		    });
		
		    this.position();
		  }
		
		  _createClass(TetherClass, [{
		    key: 'getClass',
		    value: function getClass() {
		      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
		      var classes = this.options.classes;
		
		      if (typeof classes !== 'undefined' && classes[key]) {
		        return this.options.classes[key];
		      } else if (this.options.classPrefix) {
		        return this.options.classPrefix + '-' + key;
		      } else {
		        return key;
		      }
		    }
		  }, {
		    key: 'setOptions',
		    value: function setOptions(options) {
		      var _this2 = this;
		
		      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
		
		      var defaults = {
		        offset: '0 0',
		        targetOffset: '0 0',
		        targetAttachment: 'auto auto',
		        classPrefix: 'tether'
		      };
		
		      this.options = extend(defaults, options);
		
		      var _options = this.options;
		      var element = _options.element;
		      var target = _options.target;
		      var targetModifier = _options.targetModifier;
		
		      this.element = element;
		      this.target = target;
		      this.targetModifier = targetModifier;
		
		      if (this.target === 'viewport') {
		        this.target = document.body;
		        this.targetModifier = 'visible';
		      } else if (this.target === 'scroll-handle') {
		        this.target = document.body;
		        this.targetModifier = 'scroll-handle';
		      }
		
		      ['element', 'target'].forEach(function (key) {
		        if (typeof _this2[key] === 'undefined') {
		          throw new Error('Tether Error: Both element and target must be defined');
		        }
		
		        if (typeof _this2[key].jquery !== 'undefined') {
		          _this2[key] = _this2[key][0];
		        } else if (typeof _this2[key] === 'string') {
		          _this2[key] = document.querySelector(_this2[key]);
		        }
		      });
		
		      addClass(this.element, this.getClass('element'));
		      if (!(this.options.addTargetClasses === false)) {
		        addClass(this.target, this.getClass('target'));
		      }
		
		      if (!this.options.attachment) {
		        throw new Error('Tether Error: You must provide an attachment');
		      }
		
		      this.targetAttachment = parseAttachment(this.options.targetAttachment);
		      this.attachment = parseAttachment(this.options.attachment);
		      this.offset = parseOffset(this.options.offset);
		      this.targetOffset = parseOffset(this.options.targetOffset);
		
		      if (typeof this.scrollParent !== 'undefined') {
		        this.disable();
		      }
		
		      if (this.targetModifier === 'scroll-handle') {
		        this.scrollParent = this.target;
		      } else {
		        this.scrollParent = getScrollParent(this.target);
		      }
		
		      if (!(this.options.enabled === false)) {
		        this.enable(pos);
		      }
		    }
		  }, {
		    key: 'getTargetBounds',
		    value: function getTargetBounds() {
		      if (typeof this.targetModifier !== 'undefined') {
		        if (this.targetModifier === 'visible') {
		          if (this.target === document.body) {
		            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };
		          } else {
		            var bounds = getBounds(this.target);
		
		            var out = {
		              height: bounds.height,
		              width: bounds.width,
		              top: bounds.top,
		              left: bounds.left
		            };
		
		            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
		            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
		            out.height = Math.min(innerHeight, out.height);
		            out.height -= 2;
		
		            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
		            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
		            out.width = Math.min(innerWidth, out.width);
		            out.width -= 2;
		
		            if (out.top < pageYOffset) {
		              out.top = pageYOffset;
		            }
		            if (out.left < pageXOffset) {
		              out.left = pageXOffset;
		            }
		
		            return out;
		          }
		        } else if (this.targetModifier === 'scroll-handle') {
		          var bounds = undefined;
		          var target = this.target;
		          if (target === document.body) {
		            target = document.documentElement;
		
		            bounds = {
		              left: pageXOffset,
		              top: pageYOffset,
		              height: innerHeight,
		              width: innerWidth
		            };
		          } else {
		            bounds = getBounds(target);
		          }
		
		          var style = getComputedStyle(target);
		
		          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;
		
		          var scrollBottom = 0;
		          if (hasBottomScroll) {
		            scrollBottom = 15;
		          }
		
		          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;
		
		          var out = {
		            width: 15,
		            height: height * 0.975 * (height / target.scrollHeight),
		            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
		          };
		
		          var fitAdj = 0;
		          if (height < 408 && this.target === document.body) {
		            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
		          }
		
		          if (this.target !== document.body) {
		            out.height = Math.max(out.height, 24);
		          }
		
		          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
		          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);
		
		          if (this.target === document.body) {
		            out.height = Math.max(out.height, 24);
		          }
		
		          return out;
		        }
		      } else {
		        return getBounds(this.target);
		      }
		    }
		  }, {
		    key: 'clearCache',
		    value: function clearCache() {
		      this._cache = {};
		    }
		  }, {
		    key: 'cache',
		    value: function cache(k, getter) {
		      // More than one module will often need the same DOM info, so
		      // we keep a cache which is cleared on each position call
		      if (typeof this._cache === 'undefined') {
		        this._cache = {};
		      }
		
		      if (typeof this._cache[k] === 'undefined') {
		        this._cache[k] = getter.call(this);
		      }
		
		      return this._cache[k];
		    }
		  }, {
		    key: 'enable',
		    value: function enable() {
		      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
		
		      if (!(this.options.addTargetClasses === false)) {
		        addClass(this.target, this.getClass('enabled'));
		      }
		      addClass(this.element, this.getClass('enabled'));
		      this.enabled = true;
		
		      if (this.scrollParent !== document) {
		        this.scrollParent.addEventListener('scroll', this.position);
		      }
		
		      if (pos) {
		        this.position();
		      }
		    }
		  }, {
		    key: 'disable',
		    value: function disable() {
		      removeClass(this.target, this.getClass('enabled'));
		      removeClass(this.element, this.getClass('enabled'));
		      this.enabled = false;
		
		      if (typeof this.scrollParent !== 'undefined') {
		        this.scrollParent.removeEventListener('scroll', this.position);
		      }
		    }
		  }, {
		    key: 'destroy',
		    value: function destroy() {
		      var _this3 = this;
		
		      this.disable();
		
		      tethers.forEach(function (tether, i) {
		        if (tether === _this3) {
		          tethers.splice(i, 1);
		          return;
		        }
		      });
		    }
		  }, {
		    key: 'updateAttachClasses',
		    value: function updateAttachClasses(elementAttach, targetAttach) {
		      var _this4 = this;
		
		      elementAttach = elementAttach || this.attachment;
		      targetAttach = targetAttach || this.targetAttachment;
		      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];
		
		      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {
		        // updateAttachClasses can be called more than once in a position call, so
		        // we need to clean up after ourselves such that when the last defer gets
		        // ran it doesn't add any extra classes from previous calls.
		        this._addAttachClasses.splice(0, this._addAttachClasses.length);
		      }
		
		      if (typeof this._addAttachClasses === 'undefined') {
		        this._addAttachClasses = [];
		      }
		      var add = this._addAttachClasses;
		
		      if (elementAttach.top) {
		        add.push(this.getClass('element-attached') + '-' + elementAttach.top);
		      }
		      if (elementAttach.left) {
		        add.push(this.getClass('element-attached') + '-' + elementAttach.left);
		      }
		      if (targetAttach.top) {
		        add.push(this.getClass('target-attached') + '-' + targetAttach.top);
		      }
		      if (targetAttach.left) {
		        add.push(this.getClass('target-attached') + '-' + targetAttach.left);
		      }
		
		      var all = [];
		      sides.forEach(function (side) {
		        all.push(_this4.getClass('element-attached') + '-' + side);
		        all.push(_this4.getClass('target-attached') + '-' + side);
		      });
		
		      defer(function () {
		        if (!(typeof _this4._addAttachClasses !== 'undefined')) {
		          return;
		        }
		
		        updateClasses(_this4.element, _this4._addAttachClasses, all);
		        if (!(_this4.options.addTargetClasses === false)) {
		          updateClasses(_this4.target, _this4._addAttachClasses, all);
		        }
		
		        delete _this4._addAttachClasses;
		      });
		    }
		  }, {
		    key: 'position',
		    value: function position() {
		      var _this5 = this;
		
		      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
		
		      // flushChanges commits the changes immediately, leave true unless you are positioning multiple
		      // tethers (in which case call Tether.Utils.flush yourself when you're done)
		
		      if (!this.enabled) {
		        return;
		      }
		
		      this.clearCache();
		
		      // Turn 'auto' attachments into the appropriate corner or edge
		      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
		
		      this.updateAttachClasses(this.attachment, targetAttachment);
		
		      var elementPos = this.cache('element-bounds', function () {
		        return getBounds(_this5.element);
		      });
		
		      var width = elementPos.width;
		      var height = elementPos.height;
		
		      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
		        var _lastSize = this.lastSize;
		
		        // We cache the height and width to make it possible to position elements that are
		        // getting hidden.
		        width = _lastSize.width;
		        height = _lastSize.height;
		      } else {
		        this.lastSize = { width: width, height: height };
		      }
		
		      var targetPos = this.cache('target-bounds', function () {
		        return _this5.getTargetBounds();
		      });
		      var targetSize = targetPos;
		
		      // Get an actual px offset from the attachment
		      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });
		      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
		
		      var manualOffset = offsetToPx(this.offset, { width: width, height: height });
		      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
		
		      // Add the manually provided offset
		      offset = addOffset(offset, manualOffset);
		      targetOffset = addOffset(targetOffset, manualTargetOffset);
		
		      // It's now our goal to make (element position + offset) == (target position + target offset)
		      var left = targetPos.left + targetOffset.left - offset.left;
		      var top = targetPos.top + targetOffset.top - offset.top;
		
		      for (var i = 0; i < TetherBase.modules.length; ++i) {
		        var _module2 = TetherBase.modules[i];
		        var ret = _module2.position.call(this, {
		          left: left,
		          top: top,
		          targetAttachment: targetAttachment,
		          targetPos: targetPos,
		          elementPos: elementPos,
		          offset: offset,
		          targetOffset: targetOffset,
		          manualOffset: manualOffset,
		          manualTargetOffset: manualTargetOffset,
		          scrollbarSize: scrollbarSize,
		          attachment: this.attachment
		        });
		
		        if (ret === false) {
		          return false;
		        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {
		          continue;
		        } else {
		          top = ret.top;
		          left = ret.left;
		        }
		      }
		
		      // We describe the position three different ways to give the optimizer
		      // a chance to decide the best possible way to position the element
		      // with the fewest repaints.
		      var next = {
		        // It's position relative to the page (absolute positioning when
		        // the element is a child of the body)
		        page: {
		          top: top,
		          left: left
		        },
		
		        // It's position relative to the viewport (fixed positioning)
		        viewport: {
		          top: top - pageYOffset,
		          bottom: pageYOffset - top - height + innerHeight,
		          left: left - pageXOffset,
		          right: pageXOffset - left - width + innerWidth
		        }
		      };
		
		      var scrollbarSize = undefined;
		      if (document.body.scrollWidth > window.innerWidth) {
		        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
		        next.viewport.bottom -= scrollbarSize.height;
		      }
		
		      if (document.body.scrollHeight > window.innerHeight) {
		        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
		        next.viewport.right -= scrollbarSize.width;
		      }
		
		      if (['', 'static'].indexOf(document.body.style.position) === -1 || ['', 'static'].indexOf(document.body.parentElement.style.position) === -1) {
		        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'
		        next.page.bottom = document.body.scrollHeight - top - height;
		        next.page.right = document.body.scrollWidth - left - width;
		      }
		
		      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {
		        (function () {
		          var offsetParent = _this5.cache('target-offsetparent', function () {
		            return getOffsetParent(_this5.target);
		          });
		          var offsetPosition = _this5.cache('target-offsetparent-bounds', function () {
		            return getBounds(offsetParent);
		          });
		          var offsetParentStyle = getComputedStyle(offsetParent);
		          var offsetParentSize = offsetPosition;
		
		          var offsetBorder = {};
		          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {
		            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
		          });
		
		          offsetPosition.right = document.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
		          offsetPosition.bottom = document.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;
		
		          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
		            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
		              // We're within the visible part of the target's scroll parent
		              var scrollTop = offsetParent.scrollTop;
		              var scrollLeft = offsetParent.scrollLeft;
		
		              // It's position relative to the target's offset parent (absolute positioning when
		              // the element is moved to be a child of the target's offset parent).
		              next.offset = {
		                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
		                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
		              };
		            }
		          }
		        })();
		      }
		
		      // We could also travel up the DOM and try each containing context, rather than only
		      // looking at the body, but we're gonna get diminishing returns.
		
		      this.move(next);
		
		      this.history.unshift(next);
		
		      if (this.history.length > 3) {
		        this.history.pop();
		      }
		
		      if (flushChanges) {
		        flush();
		      }
		
		      return true;
		    }
		
		    // THE ISSUE
		  }, {
		    key: 'move',
		    value: function move(pos) {
		      var _this6 = this;
		
		      if (!(typeof this.element.parentNode !== 'undefined')) {
		        return;
		      }
		
		      var same = {};
		
		      for (var type in pos) {
		        same[type] = {};
		
		        for (var key in pos[type]) {
		          var found = false;
		
		          for (var i = 0; i < this.history.length; ++i) {
		            var point = this.history[i];
		            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {
		              found = true;
		              break;
		            }
		          }
		
		          if (!found) {
		            same[type][key] = true;
		          }
		        }
		      }
		
		      var css = { top: '', left: '', right: '', bottom: '' };
		
		      var transcribe = function transcribe(_same, _pos) {
		        var hasOptimizations = typeof _this6.options.optimizations !== 'undefined';
		        var gpu = hasOptimizations ? _this6.options.optimizations.gpu : null;
		        if (gpu !== false) {
		          var yPos = undefined,
		              xPos = undefined;
		          if (_same.top) {
		            css.top = 0;
		            yPos = _pos.top;
		          } else {
		            css.bottom = 0;
		            yPos = -_pos.bottom;
		          }
		
		          if (_same.left) {
		            css.left = 0;
		            xPos = _pos.left;
		          } else {
		            css.right = 0;
		            xPos = -_pos.right;
		          }
		
		          css[transformKey] = 'translateX(' + Math.round(xPos) + 'px) translateY(' + Math.round(yPos) + 'px)';
		
		          if (transformKey !== 'msTransform') {
		            // The Z transform will keep this in the GPU (faster, and prevents artifacts),
		            // but IE9 doesn't support 3d transforms and will choke.
		            css[transformKey] += " translateZ(0)";
		          }
		        } else {
		          if (_same.top) {
		            css.top = _pos.top + 'px';
		          } else {
		            css.bottom = _pos.bottom + 'px';
		          }
		
		          if (_same.left) {
		            css.left = _pos.left + 'px';
		          } else {
		            css.right = _pos.right + 'px';
		          }
		        }
		      };
		
		      var moved = false;
		      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
		        css.position = 'absolute';
		        transcribe(same.page, pos.page);
		      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
		        css.position = 'fixed';
		        transcribe(same.viewport, pos.viewport);
		      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {
		        (function () {
		          css.position = 'absolute';
		          var offsetParent = _this6.cache('target-offsetparent', function () {
		            return getOffsetParent(_this6.target);
		          });
		
		          if (getOffsetParent(_this6.element) !== offsetParent) {
		            defer(function () {
		              _this6.element.parentNode.removeChild(_this6.element);
		              offsetParent.appendChild(_this6.element);
		            });
		          }
		
		          transcribe(same.offset, pos.offset);
		          moved = true;
		        })();
		      } else {
		        css.position = 'absolute';
		        transcribe({ top: true, left: true }, pos.page);
		      }
		
		      if (!moved) {
		        var offsetParentIsBody = true;
		        var currentNode = this.element.parentNode;
		        while (currentNode && currentNode.tagName !== 'BODY') {
		          if (getComputedStyle(currentNode).position !== 'static') {
		            offsetParentIsBody = false;
		            break;
		          }
		
		          currentNode = currentNode.parentNode;
		        }
		
		        if (!offsetParentIsBody) {
		          this.element.parentNode.removeChild(this.element);
		          document.body.appendChild(this.element);
		        }
		      }
		
		      // Any css change will trigger a repaint, so let's avoid one if nothing changed
		      var writeCSS = {};
		      var write = false;
		      for (var key in css) {
		        var val = css[key];
		        var elVal = this.element.style[key];
		
		        if (elVal !== '' && val !== '' && ['top', 'left', 'bottom', 'right'].indexOf(key) >= 0) {
		          elVal = parseFloat(elVal);
		          val = parseFloat(val);
		        }
		
		        if (elVal !== val) {
		          write = true;
		          writeCSS[key] = val;
		        }
		      }
		
		      if (write) {
		        defer(function () {
		          extend(_this6.element.style, writeCSS);
		        });
		      }
		    }
		  }]);
		
		  return TetherClass;
		})();
		
		TetherClass.modules = [];
		
		TetherBase.position = position;
		
		var Tether = extend(TetherClass, TetherBase);
		/* globals TetherBase */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getBounds = _TetherBase$Utils.getBounds;
		var extend = _TetherBase$Utils.extend;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		
		var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];
		
		function getBoundingRect(tether, to) {
		  if (to === 'scrollParent') {
		    to = tether.scrollParent;
		  } else if (to === 'window') {
		    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
		  }
		
		  if (to === document) {
		    to = to.documentElement;
		  }
		
		  if (typeof to.nodeType !== 'undefined') {
		    (function () {
		      var size = getBounds(to);
		      var pos = size;
		      var style = getComputedStyle(to);
		
		      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];
		
		      BOUNDS_FORMAT.forEach(function (side, i) {
		        side = side[0].toUpperCase() + side.substr(1);
		        if (side === 'Top' || side === 'Left') {
		          to[i] += parseFloat(style['border' + side + 'Width']);
		        } else {
		          to[i] -= parseFloat(style['border' + side + 'Width']);
		        }
		      });
		    })();
		  }
		
		  return to;
		}
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var _this = this;
		
		    var top = _ref.top;
		    var left = _ref.left;
		    var targetAttachment = _ref.targetAttachment;
		
		    if (!this.options.constraints) {
		      return true;
		    }
		
		    var _cache = this.cache('element-bounds', function () {
		      return getBounds(_this.element);
		    });
		
		    var height = _cache.height;
		    var width = _cache.width;
		
		    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
		      var _lastSize = this.lastSize;
		
		      // Handle the item getting hidden as a result of our positioning without glitching
		      // the classes in and out
		      width = _lastSize.width;
		      height = _lastSize.height;
		    }
		
		    var targetSize = this.cache('target-bounds', function () {
		      return _this.getTargetBounds();
		    });
		
		    var targetHeight = targetSize.height;
		    var targetWidth = targetSize.width;
		
		    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];
		
		    this.options.constraints.forEach(function (constraint) {
		      var outOfBoundsClass = constraint.outOfBoundsClass;
		      var pinnedClass = constraint.pinnedClass;
		
		      if (outOfBoundsClass) {
		        allClasses.push(outOfBoundsClass);
		      }
		      if (pinnedClass) {
		        allClasses.push(pinnedClass);
		      }
		    });
		
		    allClasses.forEach(function (cls) {
		      ['left', 'top', 'right', 'bottom'].forEach(function (side) {
		        allClasses.push(cls + '-' + side);
		      });
		    });
		
		    var addClasses = [];
		
		    var tAttachment = extend({}, targetAttachment);
		    var eAttachment = extend({}, this.attachment);
		
		    this.options.constraints.forEach(function (constraint) {
		      var to = constraint.to;
		      var attachment = constraint.attachment;
		      var pin = constraint.pin;
		
		      if (typeof attachment === 'undefined') {
		        attachment = '';
		      }
		
		      var changeAttachX = undefined,
		          changeAttachY = undefined;
		      if (attachment.indexOf(' ') >= 0) {
		        var _attachment$split = attachment.split(' ');
		
		        var _attachment$split2 = _slicedToArray(_attachment$split, 2);
		
		        changeAttachY = _attachment$split2[0];
		        changeAttachX = _attachment$split2[1];
		      } else {
		        changeAttachX = changeAttachY = attachment;
		      }
		
		      var bounds = getBoundingRect(_this, to);
		
		      if (changeAttachY === 'target' || changeAttachY === 'both') {
		        if (top < bounds[1] && tAttachment.top === 'top') {
		          top += targetHeight;
		          tAttachment.top = 'bottom';
		        }
		
		        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
		          top -= targetHeight;
		          tAttachment.top = 'top';
		        }
		      }
		
		      if (changeAttachY === 'together') {
		        if (top < bounds[1] && tAttachment.top === 'top') {
		          if (eAttachment.top === 'bottom') {
		            top += targetHeight;
		            tAttachment.top = 'bottom';
		
		            top += height;
		            eAttachment.top = 'top';
		          } else if (eAttachment.top === 'top') {
		            top += targetHeight;
		            tAttachment.top = 'bottom';
		
		            top -= height;
		            eAttachment.top = 'bottom';
		          }
		        }
		
		        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
		          if (eAttachment.top === 'top') {
		            top -= targetHeight;
		            tAttachment.top = 'top';
		
		            top -= height;
		            eAttachment.top = 'bottom';
		          } else if (eAttachment.top === 'bottom') {
		            top -= targetHeight;
		            tAttachment.top = 'top';
		
		            top += height;
		            eAttachment.top = 'top';
		          }
		        }
		
		        if (tAttachment.top === 'middle') {
		          if (top + height > bounds[3] && eAttachment.top === 'top') {
		            top -= height;
		            eAttachment.top = 'bottom';
		          } else if (top < bounds[1] && eAttachment.top === 'bottom') {
		            top += height;
		            eAttachment.top = 'top';
		          }
		        }
		      }
		
		      if (changeAttachX === 'target' || changeAttachX === 'both') {
		        if (left < bounds[0] && tAttachment.left === 'left') {
		          left += targetWidth;
		          tAttachment.left = 'right';
		        }
		
		        if (left + width > bounds[2] && tAttachment.left === 'right') {
		          left -= targetWidth;
		          tAttachment.left = 'left';
		        }
		      }
		
		      if (changeAttachX === 'together') {
		        if (left < bounds[0] && tAttachment.left === 'left') {
		          if (eAttachment.left === 'right') {
		            left += targetWidth;
		            tAttachment.left = 'right';
		
		            left += width;
		            eAttachment.left = 'left';
		          } else if (eAttachment.left === 'left') {
		            left += targetWidth;
		            tAttachment.left = 'right';
		
		            left -= width;
		            eAttachment.left = 'right';
		          }
		        } else if (left + width > bounds[2] && tAttachment.left === 'right') {
		          if (eAttachment.left === 'left') {
		            left -= targetWidth;
		            tAttachment.left = 'left';
		
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (eAttachment.left === 'right') {
		            left -= targetWidth;
		            tAttachment.left = 'left';
		
		            left += width;
		            eAttachment.left = 'left';
		          }
		        } else if (tAttachment.left === 'center') {
		          if (left + width > bounds[2] && eAttachment.left === 'left') {
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (left < bounds[0] && eAttachment.left === 'right') {
		            left += width;
		            eAttachment.left = 'left';
		          }
		        }
		      }
		
		      if (changeAttachY === 'element' || changeAttachY === 'both') {
		        if (top < bounds[1] && eAttachment.top === 'bottom') {
		          top += height;
		          eAttachment.top = 'top';
		        }
		
		        if (top + height > bounds[3] && eAttachment.top === 'top') {
		          top -= height;
		          eAttachment.top = 'bottom';
		        }
		      }
		
		      if (changeAttachX === 'element' || changeAttachX === 'both') {
		        if (left < bounds[0]) {
		          if (eAttachment.left === 'right') {
		            left += width;
		            eAttachment.left = 'left';
		          } else if (eAttachment.left === 'center') {
		            left += width / 2;
		            eAttachment.left = 'left';
		          }
		        }
		
		        if (left + width > bounds[2]) {
		          if (eAttachment.left === 'left') {
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (eAttachment.left === 'center') {
		            left -= width / 2;
		            eAttachment.left = 'right';
		          }
		        }
		      }
		
		      if (typeof pin === 'string') {
		        pin = pin.split(',').map(function (p) {
		          return p.trim();
		        });
		      } else if (pin === true) {
		        pin = ['top', 'left', 'right', 'bottom'];
		      }
		
		      pin = pin || [];
		
		      var pinned = [];
		      var oob = [];
		
		      if (top < bounds[1]) {
		        if (pin.indexOf('top') >= 0) {
		          top = bounds[1];
		          pinned.push('top');
		        } else {
		          oob.push('top');
		        }
		      }
		
		      if (top + height > bounds[3]) {
		        if (pin.indexOf('bottom') >= 0) {
		          top = bounds[3] - height;
		          pinned.push('bottom');
		        } else {
		          oob.push('bottom');
		        }
		      }
		
		      if (left < bounds[0]) {
		        if (pin.indexOf('left') >= 0) {
		          left = bounds[0];
		          pinned.push('left');
		        } else {
		          oob.push('left');
		        }
		      }
		
		      if (left + width > bounds[2]) {
		        if (pin.indexOf('right') >= 0) {
		          left = bounds[2] - width;
		          pinned.push('right');
		        } else {
		          oob.push('right');
		        }
		      }
		
		      if (pinned.length) {
		        (function () {
		          var pinnedClass = undefined;
		          if (typeof _this.options.pinnedClass !== 'undefined') {
		            pinnedClass = _this.options.pinnedClass;
		          } else {
		            pinnedClass = _this.getClass('pinned');
		          }
		
		          addClasses.push(pinnedClass);
		          pinned.forEach(function (side) {
		            addClasses.push(pinnedClass + '-' + side);
		          });
		        })();
		      }
		
		      if (oob.length) {
		        (function () {
		          var oobClass = undefined;
		          if (typeof _this.options.outOfBoundsClass !== 'undefined') {
		            oobClass = _this.options.outOfBoundsClass;
		          } else {
		            oobClass = _this.getClass('out-of-bounds');
		          }
		
		          addClasses.push(oobClass);
		          oob.forEach(function (side) {
		            addClasses.push(oobClass + '-' + side);
		          });
		        })();
		      }
		
		      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {
		        eAttachment.left = tAttachment.left = false;
		      }
		      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {
		        eAttachment.top = tAttachment.top = false;
		      }
		
		      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
		        _this.updateAttachClasses(eAttachment, tAttachment);
		      }
		    });
		
		    defer(function () {
		      if (!(_this.options.addTargetClasses === false)) {
		        updateClasses(_this.target, addClasses, allClasses);
		      }
		      updateClasses(_this.element, addClasses, allClasses);
		    });
		
		    return { top: top, left: left };
		  }
		});
		/* globals TetherBase */
		
		'use strict';
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getBounds = _TetherBase$Utils.getBounds;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var _this = this;
		
		    var top = _ref.top;
		    var left = _ref.left;
		
		    var _cache = this.cache('element-bounds', function () {
		      return getBounds(_this.element);
		    });
		
		    var height = _cache.height;
		    var width = _cache.width;
		
		    var targetPos = this.getTargetBounds();
		
		    var bottom = top + height;
		    var right = left + width;
		
		    var abutted = [];
		    if (top <= targetPos.bottom && bottom >= targetPos.top) {
		      ['left', 'right'].forEach(function (side) {
		        var targetPosSide = targetPos[side];
		        if (targetPosSide === left || targetPosSide === right) {
		          abutted.push(side);
		        }
		      });
		    }
		
		    if (left <= targetPos.right && right >= targetPos.left) {
		      ['top', 'bottom'].forEach(function (side) {
		        var targetPosSide = targetPos[side];
		        if (targetPosSide === top || targetPosSide === bottom) {
		          abutted.push(side);
		        }
		      });
		    }
		
		    var allClasses = [];
		    var addClasses = [];
		
		    var sides = ['left', 'top', 'right', 'bottom'];
		    allClasses.push(this.getClass('abutted'));
		    sides.forEach(function (side) {
		      allClasses.push(_this.getClass('abutted') + '-' + side);
		    });
		
		    if (abutted.length) {
		      addClasses.push(this.getClass('abutted'));
		    }
		
		    abutted.forEach(function (side) {
		      addClasses.push(_this.getClass('abutted') + '-' + side);
		    });
		
		    defer(function () {
		      if (!(_this.options.addTargetClasses === false)) {
		        updateClasses(_this.target, addClasses, allClasses);
		      }
		      updateClasses(_this.element, addClasses, allClasses);
		    });
		
		    return true;
		  }
		});
		/* globals TetherBase */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var top = _ref.top;
		    var left = _ref.left;
		
		    if (!this.options.shift) {
		      return;
		    }
		
		    var shift = this.options.shift;
		    if (typeof this.options.shift === 'function') {
		      shift = this.options.shift.call(this, { top: top, left: left });
		    }
		
		    var shiftTop = undefined,
		        shiftLeft = undefined;
		    if (typeof shift === 'string') {
		      shift = shift.split(' ');
		      shift[1] = shift[1] || shift[0];
		
		      var _shift = shift;
		
		      var _shift2 = _slicedToArray(_shift, 2);
		
		      shiftTop = _shift2[0];
		      shiftLeft = _shift2[1];
		
		      shiftTop = parseFloat(shiftTop, 10);
		      shiftLeft = parseFloat(shiftLeft, 10);
		    } else {
		      shiftTop = shift.top;
		      shiftLeft = shift.left;
		    }
		
		    top += shiftTop;
		    left += shiftLeft;
		
		    return { top: top, left: left };
		  }
		});
		return Tether;
		
		}));
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    props: {
		        id: String
		    },
		
		    methods: {
		        eventTargetsComponent: function eventTargetsComponent(eventTarget) {
		            if (eventTarget === undefined || this.id === eventTarget) {
		                return true;
		            }
		
		            return false;
		        }
		    }
		};
	
	/***/ },
	/* 62 */
	/***/ function(module, exports) {
	
		module.exports = "\n<ul\n    class=\"ui-menu\" role=\"menu\" tabindex=\"-1\" @keydown.esc=\"closeDropdown\" v-el:dropdown\n    :class=\"{ 'has-icons': showIcons, 'has-secondary-text': showSecondaryText }\"\n>\n    <ui-menu-option\n        :type=\"option.type\" :icon=\"option.icon\" :text=\"option.text\" :disabled=\"option.disabled\"\n        :secondary-text=\"option.secondaryText\" :option=\"option\" :show-icon=\"showIcons\"\n        :show-secondary-text=\"showSecondaryText\" :hide-ripple-ink=\"hideRippleInk\"\n        :partial=\"option.partial || partial\"\n\n        @keydown.enter.prevent=\"optionSelect(option)\" @click=\"optionSelect(option)\"\n\n        v-for=\"option in options\"\n    ></ui-menu-option>\n\n    <div\n        class=\"ui-menu-focus-redirector\" @focus=\"redirectFocus\" tabindex=\"0\"\n    ></div>\n</ul>\n";
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(64)
		__vue_script__ = __webpack_require__(65)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiPopover.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(66)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiPopover.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 64 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _ShowsDropdown = __webpack_require__(58);
		
		var _ShowsDropdown2 = _interopRequireDefault(_ShowsDropdown);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-popover',
		
		    events: {
		        'dropdown-opened': function dropdownOpened() {
		            if (this.containFocus) {
		                document.addEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('opened');
		
		            return true;
		        },
		
		        'dropdown-closed': function dropdownClosed() {
		            if (this.containFocus) {
		                document.removeEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('closed');
		
		            return true;
		        }
		    },
		
		    methods: {
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.dropdown.contains(e.target)) {
		                e.stopPropagation();
		
		                this.$els.dropdown.focus();
		            }
		        }
		    },
		
		    mixins: [_ShowsDropdown2.default]
		};
	
	/***/ },
	/* 66 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-popover\" role=\"dialog\" tabindex=\"-1\" @keydown.esc=\"closeDropdown\" v-el:dropdown\n>\n    <slot></slot>\n</div>\n";
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(68)
		__vue_script__ = __webpack_require__(69)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiProgressCircular.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(70)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiProgressCircular.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 68 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 69 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-progress-circular',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: false
		        },
		        type: {
		            type: String,
		            default: 'indeterminate' },
		        color: {
		            type: String,
		            default: 'primary' },
		        value: {
		            type: Number,
		            default: 0
		        },
		        size: {
		            type: Number,
		            default: 32
		        },
		        stroke: Number,
		        autoStroke: {
		            type: Boolean,
		            default: true
		        },
		        disableTransition: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        strokeDashArray: function strokeDashArray() {
		            var circumference = 2 * Math.PI * this.radius;
		
		            return Math.round(circumference * 1000) / 1000;
		        },
		        strokeDashOffset: function strokeDashOffset() {
		            var value = this.moderateValue(this.value);
		            var circumference = 2 * Math.PI * this.radius;
		
		            return (100 - value) / 100 * circumference;
		        },
		        radius: function radius() {
		            return (this.size - this.stroke) / 2;
		        }
		    },
		
		    created: function created() {
		        if (!this.stroke) {
		            if (this.autoStroke) {
		                this.stroke = parseInt(this.size / 8, 10);
		            } else {
		                this.stroke = 4;
		            }
		        }
		    },
		
		
		    methods: {
		        moderateValue: function moderateValue(value) {
		            if (isNaN(value) || value < 0) {
		                return 0;
		            }
		
		            if (value > 100) {
		                return 100;
		            }
		
		            return value;
		        }
		    }
		};
	
	/***/ },
	/* 70 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-progress-circular\" :style=\"{ 'width': size + 'px', 'height': size + 'px' }\"\n    v-show=\"show\" :transition=\"disableTransition ? null : 'ui-progress-circular-toggle'\"\n>\n    <svg\n        class=\"ui-progress-circular-determinate\" :width=\"size\" :height=\"size\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" :aria-valuenow=\"value\"\n        v-if=\"type === 'determinate'\"\n    >\n        <circle\n            class=\"ui-progress-circular-determinate-path\" :class=\"[color]\" :r=\"radius\"\n            :cx=\"size / 2\" :cy=\"size / 2\" fill=\"transparent\" :stroke-dasharray=\"strokeDashArray\"\n            stroke-dashoffset=\"0\"\n\n            :style=\"{ 'stroke-dashoffset': strokeDashOffset, 'stroke-width': stroke }\"\n        ></circle>\n    </svg>\n\n    <svg\n        class=\"ui-progress-circular-indeterminate\" viewBox=\"25 25 50 50\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" v-else\n    >\n        <circle\n            class=\"ui-progress-circular-indeterminate-path\" :class=\"[color]\" cx=\"50\" cy=\"50\"\n            r=\"20\" fill=\"none\" stroke-miterlimit=\"10\" :stroke-width=\"stroke\"\n        >\n    </svg>\n</div>\n";
	
	/***/ },
	/* 71 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		exports.default = function (value) {
		    this.el.disabled = Boolean(value);
		};
	
	/***/ },
	/* 72 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    props: {
		        openDropdownOn: String,
		        dropdownPosition: String,
		        hasPopover: {
		            type: Boolean,
		            default: false
		        },
		        hasDropdownMenu: {
		            type: Boolean,
		            default: false
		        },
		        menuOptions: {
		            type: Array,
		            default: function _default() {
		                return [];
		            }
		        },
		        showMenuIcons: {
		            type: Boolean,
		            default: false
		        },
		        showMenuSecondaryText: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    methods: {
		        menuOptionSelect: function menuOptionSelect(option) {
		            this.$dispatch('menu-option-selected', option);
		        }
		    }
		};
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiTooltip = __webpack_require__(74);
		
		var _UiTooltip2 = _interopRequireDefault(_UiTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        tooltip: String,
		        openTooltipOn: String,
		        tooltipPosition: String
		    },
		
		    components: {
		        UiTooltip: _UiTooltip2.default
		    }
		};
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(75)
		__vue_script__ = __webpack_require__(76)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTooltip.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(78)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTooltip.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 75 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _tetherTooltip = __webpack_require__(77);
		
		var _tetherTooltip2 = _interopRequireDefault(_tetherTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tooltip',
		
		    props: {
		        content: String,
		        trigger: {
		            type: Element,
		            required: true
		        },
		        position: {
		            type: String,
		            default: 'bottom center'
		        },
		        openOn: {
		            type: String,
		            default: 'hover focus'
		        }
		    },
		
		    data: function data() {
		        return {
		            tooltip: null
		        };
		    },
		
		
		    watch: {
		        trigger: function trigger() {
		            if (!this.tooltip) {
		                this.initialize();
		            }
		        }
		    },
		
		    ready: function ready() {
		        this.initialize();
		    },
		    beforeDestory: function beforeDestory() {
		        if (this.tooltip) {
		            this.tooltip.remove();
		            this.tooltip.destroy();
		        }
		    },
		
		
		    methods: {
		        initialize: function initialize() {
		            if (this.trigger) {
		                this.tooltip = new _tetherTooltip2.default({
		                    target: this.trigger,
		                    content: this.$els.tooltip,
		                    classes: 'ui-tooltip-theme',
		                    position: this.position,
		                    openOn: 'hover focus'
		                });
		            }
		        }
		    }
		};
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether-tooltip 1.1.0 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(59),__webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require('tether-drop'), require('tether'));
		  } else {
		    root.Tooltip = factory(root.Drop, root.Tether);
		  }
		}(this, function(Drop, Tether) {
		
		/* global Tether Drop */
		
		'use strict';
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		var extend = Tether.Utils.extend;
		
		var _Drop = Drop.createContext({
		  classPrefix: 'tooltip'
		});
		
		var defaults = {
		  position: 'top center',
		  openOn: 'hover',
		  classes: 'tooltip-theme-arrows',
		  constrainToWindow: true,
		  constrainToScrollParent: false
		};
		
		var tooltipCount = 0;
		
		var Tooltip = (function () {
		  function Tooltip(options) {
		    _classCallCheck(this, Tooltip);
		
		    this.options = options;
		
		    if (!this.options.target) {
		      throw new Error('Tooltip Error: You must provide a target for Tooltip to attach to');
		    }
		
		    var position = this.options.target.getAttribute('data-tooltip-position');
		    if (position) {
		      if (typeof this.options.position === 'undefined') {
		        this.options.position = position;
		      }
		    }
		
		    var content = this.options.target.getAttribute('data-tooltip');
		
		    if (content) {
		      if (typeof this.options.content === 'undefined') {
		        var contentEl = document.createElement('div');
		        contentEl.innerHTML = content;
		
		        // Add ARIA attributes (see #50)
		        contentEl.setAttribute('role', 'tooltip');
		        contentEl.id = 'drop-tooltip-' + tooltipCount;
		        this.options.target.setAttribute('aria-describedby', contentEl.id);
		        tooltipCount += 1;
		
		        this.options.content = contentEl;
		      }
		    }
		
		    if (!this.options.content) {
		      throw new Error('Tooltip Error: You must provide content for Tooltip to display');
		    }
		
		    this.options = extend({}, defaults, this.options);
		
		    this.drop = new _Drop(this.options);
		  }
		
		  _createClass(Tooltip, [{
		    key: 'close',
		    value: function close() {
		      this.drop.close();
		    }
		  }, {
		    key: 'open',
		    value: function open() {
		      this.drop.open();
		    }
		  }, {
		    key: 'toggle',
		    value: function toggle() {
		      this.drop.toggle();
		    }
		  }, {
		    key: 'remove',
		    value: function remove() {
		      this.drop.remove();
		    }
		  }, {
		    key: 'destroy',
		    value: function destroy() {
		      this.drop.destroy();
		    }
		  }, {
		    key: 'position',
		    value: function position() {
		      this.drop.position();
		    }
		  }]);
		
		  return Tooltip;
		})();
		
		var initialized = [];
		
		Tooltip.init = function () {
		  var tooltipElements = document.querySelectorAll('[data-tooltip]');
		  var len = tooltipElements.length;
		  for (var i = 0; i < len; ++i) {
		    var el = tooltipElements[i];
		    if (initialized.indexOf(el) === -1) {
		      new Tooltip({
		        target: el
		      });
		      initialized.push(el);
		    }
		  }
		};
		
		document.addEventListener('DOMContentLoaded', function () {
		  if (Tooltip.autoinit !== false) {
		    Tooltip.init();
		  }
		});
		return Tooltip;
		
		}));
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-tooltip\" v-text=\"content\" v-el:tooltip></div>\n";
	
	/***/ },
	/* 79 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-icon-button\" :class=\"styleClasses\" :aria-label=\"ariaLabel || tooltip\"\n    :type=\"buttonType\" v-disabled=\"disabled || loading\" v-el:button\n>\n    <ui-icon\n        class=\"ui-icon-button-icon\" :icon=\"icon\" v-show=\"!loading\"\n    ></ui-icon>\n\n    <ui-progress-circular\n        class=\"ui-icon-button-spinner\" :color=\"spinnerColor\" :size=\"24\" :stroke=\"4.5\"\n        disable-transition v-show=\"loading\"\n    ></ui-progress-circular>\n\n    <ui-ripple-ink v-if=\"!hideRippleInk && !disabled\" :trigger=\"$els.button\"></ui-ripple-ink>\n\n    <ui-tooltip\n        :trigger=\"$els.button\" :content=\"tooltip\" :position=\"tooltipPosition\" v-if=\"tooltip\"\n        :open-on=\"openTooltipOn\"\n    ></ui-tooltip>\n\n    <ui-menu\n        class=\"ui-button-dropdown-menu\" :trigger=\"$els.button\" :options=\"menuOptions\"\n        :show-icons=\"showMenuIcons\" :show-secondary-text=\"showMenuSecondaryText\"\n        :open-on=\"openDropdownOn\" @option-selected=\"menuOptionSelect\"\n        :dropdown-position=\"dropdownPosition\" v-if=\"hasDropdownMenu\"\n    ></ui-menu>\n\n    <ui-popover\n        :trigger=\"$els.button\" :open-on=\"openDropdownOn\" :dropdown-position=\"dropdownPosition\"\n        v-if=\"hasPopover\"\n    >\n        <slot name=\"popover\"></slot>\n    </ui-popover>\n</button>\n";
	
	/***/ },
	/* 80 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-alert\">\n    <div\n        class=\"ui-alert-body\" :class=\"[type]\" role=\"alert\" v-show=\"show\"\n        transition=\"ui-alert-toggle\"\n    >\n        <ui-icon class=\"ui-alert-icon\" :icon=\"iconName\" v-if=\"!hideIcon\"></ui-icon>\n\n        <div class=\"ui-alert-text\">\n            <slot>\n                <span v-text=\"text\"></span>\n            </slot>\n        </div>\n\n        <ui-icon-button\n            class=\"ui-alert-close-button\" type=\"clear\" icon=\"&#xE5CD\" aria-label=\"Close\"\n            @click=\"close\" v-if=\"dismissible\"\n        ></ui-icon-button>\n    </div>\n</div>\n";
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(82)
		__vue_script__ = __webpack_require__(83)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAutocomplete.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(108)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAutocomplete.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 82 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _fuzzysearch = __webpack_require__(84);
		
		var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiAutocompleteSuggestion = __webpack_require__(85);
		
		var _UiAutocompleteSuggestion2 = _interopRequireDefault(_UiAutocompleteSuggestion);
		
		var _autofocus = __webpack_require__(90);
		
		var _autofocus2 = _interopRequireDefault(_autofocus);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-autocomplete',
		
		    props: {
		        suggestions: {
		            type: Array,
		            default: []
		        },
		        limit: {
		            type: Number,
		            default: 8
		        },
		        partial: String,
		        append: {
		            type: Boolean,
		            default: false
		        },
		        appendDelimiter: {
		            type: String,
		            default: ', '
		        },
		        minChars: {
		            type: Number,
		            default: 2
		        },
		        showOnUpDown: {
		            type: Boolean,
		            default: true
		        },
		        autofocus: {
		            type: Boolean,
		            default: false
		        },
		        filter: Function,
		        autoHighlightFirstMatch: {
		            type: Boolean,
		            default: true
		        },
		        cycleHighlight: {
		            type: Boolean,
		            default: true
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            showDropdown: false,
		            highlightedItem: -1,
		            ignoreValueChange: false
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            if (document.activeElement === this.$els.input) {
		                document.activeElement.blur();
		            }
		
		            this.value = this.initialValue;
		            this.dirty = false;
		            this.valid = true;
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (!this.ignoreValueChange && this.value.length >= this.minChars) {
		                this.open();
		            }
		
		            this.highlightedItem = this.autoHighlightFirstMatch ? 0 : -1;
		        }
		    },
		
		    ready: function ready() {
		        document.addEventListener('click', this.closeOnExternalClick);
		    },
		    beforeDestroy: function beforeDestroy() {
		        document.removeEventListener('click', this.closeOnExternalClick);
		    },
		
		
		    methods: {
		        search: function search(item) {
		            if (this.filter) {
		                return this.filter(item, this.value);
		            }
		
		            var text = item[this.keys.text] || item;
		            var query = this.value;
		
		            if (typeof query === 'string') {
		                query = query.toLowerCase();
		            }
		
		            return (0, _fuzzysearch2.default)(query, text.toLowerCase());
		        },
		        select: function select(item) {
		            var _this = this;
		
		            if (this.append) {
		                this.value += this.appendDelimiter + (item[this.keys.value] || item);
		            } else {
		                this.value = item[this.keys.value] || item;
		            }
		
		            this.$dispatch('selected', item);
		
		            this.validate();
		
		            this.$nextTick(function () {
		                _this.close();
		                _this.$els.input.focus();
		            });
		        },
		        highlight: function highlight(index) {
		            var firstIndex = 0;
		            var lastIndex = this.$refs.items.length - 1;
		
		            if (index === -2) {
		                index = lastIndex;
		            } else if (index < firstIndex) {
		                index = this.cycleHighlight ? lastIndex : index;
		            } else if (index > lastIndex) {
		                index = this.cycleHighlight ? firstIndex : -1;
		            }
		
		            this.highlightedItem = index;
		
		            if (this.showOnUpDown) {
		                this.open();
		            }
		
		            if (index < firstIndex || index > lastIndex) {
		                this.$dispatch('highlight-overflow', index);
		            } else {
		                this.$dispatch('highlighted', this.$refs.items[index].item, index);
		            }
		        },
		        selectHighlighted: function selectHighlighted(index, e) {
		            if (this.showDropdown && this.$refs.items.length) {
		                e.preventDefault();
		                this.select(this.$refs.items[index].item);
		            }
		        },
		        clearSearch: function clearSearch() {
		            this.value = '';
		        },
		        open: function open() {
		            if (!this.showDropdown) {
		                this.showDropdown = true;
		                this.$dispatch('opened');
		            }
		        },
		        close: function close() {
		            if (this.showDropdown) {
		                this.showDropdown = false;
		                this.highlightedItem = -1;
		
		                this.$dispatch('closed');
		                this.validate();
		            }
		        },
		        closeOnExternalClick: function closeOnExternalClick(e) {
		            if (!this.$els.autocomplete.contains(e.target) && this.showDropdown) {
		                this.close();
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiAutocompleteSuggestion: _UiAutocompleteSuggestion2.default
		    },
		
		    directives: {
		        autofocus: _autofocus2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 84 */
	/***/ function(module, exports) {
	
		'use strict';
		
		function fuzzysearch (needle, haystack) {
		  var tlen = haystack.length;
		  var qlen = needle.length;
		  if (qlen > tlen) {
		    return false;
		  }
		  if (qlen === tlen) {
		    return needle === haystack;
		  }
		  outer: for (var i = 0, j = 0; i < qlen; i++) {
		    var nch = needle.charCodeAt(i);
		    while (j < tlen) {
		      if (haystack.charCodeAt(j++) === nch) {
		        continue outer;
		      }
		    }
		    return false;
		  }
		  return true;
		}
		
		module.exports = fuzzysearch;
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(86)
		__vue_script__ = __webpack_require__(87)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAutocompleteSuggestion.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(89)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAutocompleteSuggestion.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 86 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-autocomplete-suggestion',
		
		    props: {
		        id: {
		            type: String,
		            default: function _default() {
		                return _uuid2.default.short();
		            }
		        },
		        item: {
		            type: [String, Object],
		            required: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-autocomplete-simple' },
		        highlighted: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    partials: {
		        'ui-autocomplete-simple': '\n            <li class="ui-autocomplete-suggestion-item" v-text="item[keys.text] || item"></li>\n        ',
		
		        'ui-autocomplete-image': '\n            <div\n                class="image" :style="{ \'background-image\': \'url(\' + item[keys.image] + \')\' }"\n            ></div>\n            <div class="text" v-text="item[keys.text]"></div>\n        '
		    }
		};
	
	/***/ },
	/* 88 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		/**
		 * Fast UUID generator, RFC4122 version 4 compliant.
		 * @author Jeff Ward (jcward.com).
		 * @license MIT license
		 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
		 **/
		
		var lut = [];
		
		for (var i = 0; i < 256; i++) {
		    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
		}
		
		var generate = function generate() {
		    var d0 = Math.random() * 0xffffffff | 0;
		    var d1 = Math.random() * 0xffffffff | 0;
		    var d2 = Math.random() * 0xffffffff | 0;
		    var d3 = Math.random() * 0xffffffff | 0;
		
		    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
		};
		
		var short = function short(prefix) {
		    prefix = prefix || '';
		
		    var uuid = generate();
		
		    return prefix + uuid.split('-')[0];
		};
		
		exports.default = {
		    generate: generate,
		    short: short
		};
	
	/***/ },
	/* 89 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-autocomplete-suggestion\" :class=\"[partial, { 'highlighted': highlighted }]\"\n    :id=\"id\"\n>\n    <partial :name=\"partial\"></partial>\n</li>\n";
	
	/***/ },
	/* 90 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		exports.default = function (value) {
		    this.el.autofocus = Boolean(value);
		};
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        id: String,
		        name: {
		            type: String,
		            required: true
		        },
		        placeholder: String,
		        value: {
		            type: [String, Number],
		            default: '',
		            twoWay: true
		        },
		        icon: String,
		        iconRight: {
		            type: Boolean,
		            default: false
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        },
		        debounce: {
		            type: Number,
		            default: null
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: ''
		        };
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            var canBeValidated = Boolean(this.validationRules);
		            var hasHelpText = Boolean(this.helpText);
		
		            return canBeValidated || hasHelpText;
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _validatorjs = __webpack_require__(93);
		
		var _validatorjs2 = _interopRequireDefault(_validatorjs);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        valid: {
		            type: Boolean,
		            default: true,
		            twoWay: true
		        },
		        dirty: {
		            type: Boolean,
		            default: false,
		            twoWay: true
		        },
		        hideValidationErrors: {
		            type: Boolean,
		            default: false
		        },
		        validationRules: [String, Array],
		        validationMessages: Object
		    },
		
		    data: function data() {
		        return {
		            validationError: ''
		        };
		    },
		
		
		    events: {
		        'ui-input::set-validity': function uiInputSetValidity(valid, error, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.setValidity(valid, error);
		        }
		    },
		
		    methods: {
		        validate: function validate() {
		            if (!this.validationRules || !this.dirty) {
		                return;
		            }
		
		            var data = {
		                value: this.value
		            };
		
		            var rules = {
		                value: this.validationRules
		            };
		
		            var validation = new _validatorjs2.default(data, rules, this.validationMessages);
		
		            validation.setAttributeNames({ value: this.name.replace(/_/g, ' ') });
		
		            this.setValidity(validation.passes(), validation.errors.first('value'));
		        },
		        setValidity: function setValidity(valid, error) {
		            this.valid = valid;
		
		            if (!valid && error && error.length) {
		                this.validationError = error;
		            }
		        }
		    }
		};
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Rules = __webpack_require__(94);
		var Lang = __webpack_require__(95);
		var Errors = __webpack_require__(106);
		var Attributes = __webpack_require__(97);
		var AsyncResolvers = __webpack_require__(107);
		
		var Validator = function(input, rules, customMessages) {
		  var lang = Validator.getDefaultLang();
		  this.input = input;
		  this.messages = Lang._make(lang);
		  this.messages._setCustom(customMessages);
		  this.setAttributeFormatter(Validator.prototype.attributeFormatter);
		
		  this.errors = new Errors();
		  this.errorCount = 0;
		
		  this.hasAsync = false;
		  this.rules = this._parseRules(rules);
		};
		
		Validator.prototype = {
		
		  constructor: Validator,
		
		  /**
		   * Default language
		   *
		   * @type {string}
		   */
		  lang: 'en',
		
		  /**
		   * Numeric based rules
		   *
		   * @type {array}
		   */
		  numericRules: ['integer', 'numeric'],
		
		  /**
		   * Attribute formatter.
		   *
		   * @type {function}
		   */
		  attributeFormatter: Attributes.formatter,
		
		  /**
		   * Run validator
		   *
		   * @return {boolean} Whether it passes; true = passes, false = fails
		   */
		  check: function() {
		    var self = this;
		
		    for (var attribute in this.rules) {
		      var attributeRules = this.rules[attribute];
		      var inputValue = this.input[attribute]; // if it doesnt exist in input, it will be undefined
		
		      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {
		        ruleOptions = attributeRules[i];
		        rule = this.getRule(ruleOptions.name);
		
		        if (!this._isValidatable(rule, inputValue)) {
		          continue;
		        }
		
		        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);
		        if (!rulePassed) {
		          this._addFailure(rule);
		        }
		
		        if (this._shouldStopValidating(attribute, rulePassed)) {
		          break;
		        }
		      }
		    }
		
		    return this.errorCount === 0;
		  },
		
		  /**
		   * Run async validator
		   *
		   * @param {function} passes
		   * @param {function} fails
		   * @return {void}
		   */
		  checkAsync: function(passes, fails) {
		    var _this = this;
		    passes = passes || function() {};
		    fails = fails || function() {};
		
		    var failsOne = function(rule, message) {
		      _this._addFailure(rule, message);
		    };
		
		    var resolvedAll = function(allPassed) {
		      if (allPassed) {
		        passes();
		      } else {
		        fails();
		      }
		    };
		
		    var validateRule = function(inputValue, ruleOptions, attribute, rule) {
		      return function() {
		        var resolverIndex = asyncResolvers.add(rule);
		        rule.validate(inputValue, ruleOptions.value, attribute, function() {
		          asyncResolvers.resolve(resolverIndex);
		        });
		      };
		    };
		
		    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);
		
		    for (var attribute in this.rules) {
		      var attributeRules = this.rules[attribute];
		      var inputValue = this.input[attribute]; // if it doesnt exist in input, it will be undefined
		
		      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {
		        ruleOptions = attributeRules[i];
		
		        rule = this.getRule(ruleOptions.name);
		
		        if (!this._isValidatable(rule, inputValue)) {
		          continue;
		        }
		
		        validateRule(inputValue, ruleOptions, attribute, rule)();
		      }
		    }
		
		    asyncResolvers.enableFiring();
		    asyncResolvers.fire();
		  },
		
		  /**
		   * Add failure and error message for given rule
		   *
		   * @param {Rule} rule
		   */
		  _addFailure: function(rule) {
		    var msg = this.messages.render(rule);
		    this.errors.add(rule.attribute, msg);
		    this.errorCount++;
		  },
		
		  /**
		   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }
		   *
		   * @param  {object} rules
		   * @return {object}
		   */
		  _parseRules: function(rules) {
		    var parsedRules = {};
		    for (var attribute in rules) {
		      var rulesArray = rules[attribute];
		      var attributeRules = [];
		
		      if (typeof rulesArray === 'string') {
		        rulesArray = rulesArray.split('|');
		      }
		
		      for (var i = 0, len = rulesArray.length, rule; i < len; i++) {
		        rule = this._extractRuleAndRuleValue(rulesArray[i]);
		        if (Rules.isAsync(rule.name)) {
		          this.hasAsync = true;
		        }
		        attributeRules.push(rule);
		      }
		
		      parsedRules[attribute] = attributeRules;
		    }
		    return parsedRules;
		  },
		
		  /**
		   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3
		   *
		   * @param  {string} ruleString min:3
		   * @return {object} object containing the name of the rule and value
		   */
		  _extractRuleAndRuleValue: function(ruleString) {
		    var rule = {},
		      ruleArray;
		
		    rule.name = ruleString;
		
		    if (ruleString.indexOf(':') >= 0) {
		      ruleArray = ruleString.split(':');
		      rule.name = ruleArray[0];
		      rule.value = ruleArray.slice(1).join(":");
		    }
		
		    return rule;
		  },
		
		  /**
		   * Determine if attribute has any of the given rules
		   *
		   * @param  {string}  attribute
		   * @param  {array}   findRules
		   * @return {boolean}
		   */
		  _hasRule: function(attribute, findRules) {
		    var rules = this.rules[attribute] || [];
		    for (var i = 0, len = rules.length; i < len; i++) {
		      if (findRules.indexOf(rules[i].name) > -1) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Determine if attribute has any numeric-based rules.
		   *
		   * @param  {string}  attribute
		   * @return {Boolean}
		   */
		  _hasNumericRule: function(attribute) {
		    return this._hasRule(attribute, this.numericRules);
		  },
		
		  /**
		   * Determine if rule is validatable
		   *
		   * @param  {Rule}   rule
		   * @param  {mixed}  value
		   * @return {boolean}
		   */
		  _isValidatable: function(rule, value) {
		    if (Rules.isImplicit(rule.name)) {
		      return true;
		    }
		
		    return this.getRule('required').validate(value);
		  },
		
		
		  /**
		   * Determine if we should stop validating.
		   *
		   * @param  {string} attribute
		   * @param  {boolean} rulePassed
		   * @return {boolean}
		   */
		  _shouldStopValidating: function(attribute, rulePassed) {
		
		    var stopOnAttributes = this.stopOnAttributes;
		    if (stopOnAttributes === false || rulePassed === true) {
		      return false;
		    }
		
		    if (stopOnAttributes instanceof Array) {
		      return stopOnAttributes.indexOf(attribute) > -1;
		    }
		
		    return true;
		  },
		
		  /**
		   * Set custom attribute names.
		   *
		   * @param {object} attributes
		   * @return {void}
		   */
		  setAttributeNames: function(attributes) {
		    this.messages._setAttributeNames(attributes);
		  },
		
		  /**
		   * Set the attribute formatter.
		   *
		   * @param {fuction} func
		   * @return {void}
		   */
		  setAttributeFormatter: function(func) {
		    this.messages._setAttributeFormatter(func);
		  },
		
		  /**
		   * Get validation rule
		   *
		   * @param  {string} name
		   * @return {Rule}
		   */
		  getRule: function(name) {
		    return Rules.make(name, this);
		  },
		
		  /**
		   * Stop on first error.
		   *
		   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		   * @return {void}
		   */
		  stopOnError: function(attributes) {
		    this.stopOnAttributes = attributes;
		  },
		
		  /**
		   * Determine if validation passes
		   *
		   * @param {function} passes
		   * @return {boolean|undefined}
		   */
		  passes: function(passes) {
		    var async = this._checkAsync('passes', passes);
		    if (async) {
		      return this.checkAsync(passes);
		    }
		    return this.check();
		  },
		
		  /**
		   * Determine if validation fails
		   *
		   * @param {function} fails
		   * @return {boolean|undefined}
		   */
		  fails: function(fails) {
		    var async = this._checkAsync('fails', fails);
		    if (async) {
		      return this.checkAsync(function() {}, fails);
		    }
		    return !this.check();
		  },
		
		  /**
		   * Check if validation should be called asynchronously
		   *
		   * @param  {string}   funcName Name of the caller
		   * @param  {function} callback
		   * @return {boolean}
		   */
		  _checkAsync: function(funcName, callback) {
		    var hasCallback = typeof callback === 'function';
		    if (this.hasAsync && !hasCallback) {
		      throw funcName + ' expects a callback when async rules are being tested.';
		    }
		
		    return this.hasAsync || hasCallback;
		  }
		
		};
		
		/**
		 * Set messages for language
		 *
		 * @param {string} lang
		 * @param {object} messages
		 * @return {this}
		 */
		Validator.setMessages = function(lang, messages) {
		  Lang._set(lang, messages);
		  return this;
		};
		
		/**
		 * Get messages for given language
		 *
		 * @param  {string} lang
		 * @return {Messages}
		 */
		Validator.getMessages = function(lang) {
		  return Lang._get(lang);
		};
		
		/**
		 * Set default language to use
		 *
		 * @param {string} lang
		 * @return {void}
		 */
		Validator.useLang = function(lang) {
		  this.prototype.lang = lang;
		};
		
		/**
		 * Get default language
		 *
		 * @return {string}
		 */
		Validator.getDefaultLang = function() {
		  return this.prototype.lang;
		};
		
		/**
		 * Set the attribute formatter.
		 *
		 * @param {fuction} func
		 * @return {void}
		 */
		Validator.setAttributeFormatter = function(func) {
		  this.prototype.attributeFormatter = func;
		};
		
		/**
		 * Stop on first error.
		 *
		 * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		 * @return {void}
		 */
		Validator.stopOnError = function(attributes) {
		  this.prototype.stopOnAttributes = attributes;
		};
		
		/**
		 * Register custom validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator.register = function(name, fn, message) {
		  var lang = Validator.getDefaultLang();
		  Rules.register(name, fn);
		  Lang._setRuleMessage(lang, name, message);
		};
		
		/**
		 * Register asynchronous validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator.registerAsync = function(name, fn, message) {
		  var lang = Validator.getDefaultLang();
		  Rules.registerAsync(name, fn);
		  Lang._setRuleMessage(lang, name, message);
		};
		
		module.exports = Validator;
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports) {
	
		var rules = {
		
		  required: function(val) {
		    var str;
		
		    if (val === undefined || val === null) {
		      return false;
		    }
		
		    str = String(val).replace(/\s/g, "");
		    return str.length > 0 ? true : false;
		  },
		
		  required_if: function(val, req, attribute) {
		    req = this.getParameters();
		    if (this.validator.input[req[0]] === req[1]) {
		      return this.validator.getRule('required').validate(val);
		    }
		
		    return true;
		  },
		
		  // compares the size of strings
		  // with numbers, compares the value
		  size: function(val, req, attribute) {
		    if (val) {
		      req = parseFloat(req);
		
		      var size = this.getSize();
		
		      return size === req;
		    }
		
		    return true;
		  },
		
		  string: function(val, req, attribute) {
		    return typeof val === 'string';
		  },
		
		  /**
		   * Compares the size of strings or the value of numbers if there is a truthy value
		   */
		  min: function(val, req, attribute) {
		    var size = this.getSize();
		    return size >= req;
		  },
		
		  /**
		   * Compares the size of strings or the value of numbers if there is a truthy value
		   */
		  max: function(val, req, attribute) {
		    var size = this.getSize();
		    return size <= req;
		  },
		
		  between: function(val, req, attribute) {
		    req = this.getParameters();
		    var size = this.getSize();
		    var min = parseFloat(req[0], 10);
		    var max = parseFloat(req[1], 10);
		    return size >= min && size <= max;
		  },
		
		  email: function(val) {
		    var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
		    return re.test(val);
		  },
		
		  numeric: function(val) {
		    var num;
		
		    num = Number(val); // tries to convert value to a number. useful if value is coming from form element
		
		    if (typeof num === 'number' && !isNaN(num) && typeof val !== 'boolean') {
		      return true;
		    } else {
		      return false;
		    }
		  },
		
		  array: function(val) {
		    return val instanceof Array;
		  },
		
		  url: function(url) {
		    return (/^https?:\/\/\S+/).test(url);
		  },
		
		  alpha: function(val) {
		    return (/^[a-zA-Z]+$/).test(val);
		  },
		
		  alpha_dash: function(val) {
		    return (/^[a-zA-Z0-9_\-]+$/).test(val);
		  },
		
		  alpha_num: function(val) {
		    return (/^[a-zA-Z0-9]+$/).test(val);
		  },
		
		  same: function(val, req) {
		    var val1 = this.validator.input[req];
		    var val2 = val;
		
		    if (val1 === val2) {
		      return true;
		    }
		
		    return false;
		  },
		
		  different: function(val, req) {
		    var val1 = this.validator.input[req];
		    var val2 = val;
		
		    if (val1 !== val2) {
		      return true;
		    }
		
		    return false;
		  },
		
		  "in": function(val, req) {
		    var list, i;
		
		    if (val) {
		      list = req.split(',');
		    }
		
		    if (val && !(val instanceof Array)) {
		      val = String(val); // if it is a number
		
		      for (i = 0; i < list.length; i++) {
		        if (val === list[i]) {
		          return true;
		        }
		      }
		
		      return false;
		    }
		
		    if (val && val instanceof Array) {
		      for (i = 0; i < val.length; i++) {
		        if (list.indexOf(val[i]) < 0) {
		          return false;
		        }
		      }
		    }
		
		    return true;
		  },
		
		  not_in: function(val, req) {
		    var list = req.split(',');
		    var len = list.length;
		    var returnVal = true;
		
		    val = String(val); // convert val to a string if it is a number
		
		    for (var i = 0; i < len; i++) {
		      if (val === list[i]) {
		        returnVal = false;
		        break;
		      }
		    }
		
		    return returnVal;
		  },
		
		  accepted: function(val) {
		    if (val === 'on' || val === 'yes' || val === 1 || val === '1' || val === true) {
		      return true;
		    }
		
		    return false;
		  },
		
		  confirmed: function(val, req, key) {
		    var confirmedKey = key + '_confirmation';
		
		    if (this.validator.input[confirmedKey] === val) {
		      return true;
		    }
		
		    return false;
		  },
		
		  integer: function(val) {
		    return String(parseInt(val, 10)) === String(val);
		  },
		
		  digits: function(val, req) {
		    var numericRule = this.validator.getRule('numeric');
		    if (numericRule.validate(val) && String(val).length === parseInt(req)) {
		      return true;
		    }
		
		    return false;
		  },
		
		  regex: function(val, req) {
		    var mod = /[g|i|m]{1,3}$/;
		    var flag = req.match(mod);
		    flag = flag ? flag[0] : "i";
		    req = req.replace(mod, "").slice(1, -1);
		    req = new RegExp(req, flag);
		    return !!val.match(req);
		  }
		
		};
		
		function Rule(name, fn, async) {
		  this.name = name;
		  this.fn = fn;
		  this.passes = null;
		  this.customMessage = undefined;
		  this.async = async;
		}
		
		Rule.prototype = {
		
		  /**
		   * Validate rule
		   *
		   * @param  {mixed} inputValue
		   * @param  {mixed} ruleValue
		   * @param  {string} attribute
		   * @param  {function} callback
		   * @return {boolean|undefined}
		   */
		  validate: function(inputValue, ruleValue, attribute, callback) {
		    var _this = this;
		    this._setValidatingData(attribute, inputValue, ruleValue);
		    if (typeof callback === 'function') {
		      this.callback = callback;
		      var handleResponse = function(passes, message) {
		        _this.response(passes, message);
		      };
		
		      if (this.async) {
		        return this.fn.apply(this, [inputValue, ruleValue, attribute, handleResponse]);
		      } else {
		        return handleResponse(this.fn.apply(this, [inputValue, ruleValue, attribute]));
		      }
		    }
		    return this.fn.apply(this, [inputValue, ruleValue, attribute]);
		  },
		
		  /**
		   * Set validating data
		   *
		   * @param {string} attribute
		   * @param {mixed} inputValue
		   * @param {mixed} ruleValue
		   * @return {void}
		   */
		  _setValidatingData: function(attribute, inputValue, ruleValue) {
		    this.attribute = attribute;
		    this.inputValue = inputValue;
		    this.ruleValue = ruleValue;
		  },
		
		  /**
		   * Get parameters
		   *
		   * @return {array}
		   */
		  getParameters: function() {
		    return this.ruleValue ? this.ruleValue.split(',') : [];
		  },
		
		  /**
		   * Get true size of value
		   *
		   * @return {integer|float}
		   */
		  getSize: function() {
		    var value = this.inputValue;
		
		    if (value instanceof Array) {
		      return value.length;
		    }
		
		    if (typeof value === 'number') {
		      return value;
		    }
		
		    if (this.validator._hasNumericRule(this.attribute)) {
		      return parseFloat(value, 10);
		    }
		
		    return value.length;
		  },
		
		  /**
		   * Get the type of value being checked; numeric or string.
		   *
		   * @return {string}
		   */
		  _getValueType: function() {
		
		    if (typeof this.inputValue === 'number' || this.validator._hasNumericRule(this.attribute)) {
		      return 'numeric';
		    }
		
		    return 'string';
		  },
		
		  /**
		   * Set the async callback response
		   *
		   * @param  {boolean|undefined} passes  Whether validation passed
		   * @param  {string|undefined} message Custom error message
		   * @return {void}
		   */
		  response: function(passes, message) {
		    this.passes = (passes === undefined || passes === true);
		    this.customMessage = message;
		    this.callback(this.passes, message);
		  },
		
		  /**
		   * Set validator instance
		   *
		   * @param {Validator} validator
		   * @return {void}
		   */
		  setValidator: function(validator) {
		    this.validator = validator;
		  }
		
		};
		
		var manager = {
		
		  /**
		   * List of async rule names
		   *
		   * @type {Array}
		   */
		  asyncRules: [],
		
		  /**
		   * Implicit rules (rules to always validate)
		   *
		   * @type {Array}
		   */
		  implicitRules: ['required', 'required_if', 'accepted'],
		
		  /**
		   * Get rule by name
		   *
		   * @param  {string} name
		   * @param {Validator}
		   * @return {Rule}
		   */
		  make: function(name, validator) {
		    var async = this.isAsync(name);
		    var rule = new Rule(name, rules[name], async);
		    rule.setValidator(validator);
		    return rule;
		  },
		
		  /**
		   * Determine if given rule is async
		   *
		   * @param  {string}  name
		   * @return {boolean}
		   */
		  isAsync: function(name) {
		    for (var i = 0, len = this.asyncRules.length; i < len; i++) {
		      if (this.asyncRules[i] === name) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Determine if rule is implicit (should always validate)
		   *
		   * @param {string} name
		   * @return {boolean}
		   */
		  isImplicit: function(name) {
		    return this.implicitRules.indexOf(name) > -1;
		  },
		
		  /**
		   * Register new rule
		   *
		   * @param  {string}   name
		   * @param  {function} fn
		   * @return {void}
		   */
		  register: function(name, fn) {
		    rules[name] = fn;
		  },
		
		  /**
		   * Register async rule
		   *
		   * @param  {string}   name
		   * @param  {function} fn
		   * @return {void}
		   */
		  registerAsync: function(name, fn) {
		    this.register(name, fn);
		    this.asyncRules.push(name);
		  }
		
		};
		
		
		module.exports = manager;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Messages = __webpack_require__(96);
		
		__webpack_require__(98);
		
		var container = {
		
		  messages: {},
		
		  /**
		   * Set messages for language
		   *
		   * @param {string} lang
		   * @param {object} rawMessages
		   * @return {void}
		   */
		  _set: function(lang, rawMessages) {
		    this.messages[lang] = rawMessages;
		  },
		
		  /**
		   * Set message for given language's rule.
		   *
		   * @param {string} lang
		   * @param {string} attribute
		   * @param {string|object} message
		   * @return {void}
		   */
		  _setRuleMessage: function(lang, attribute, message) {
		    this._load(lang);
		    if (message === undefined) {
		      message = this.messages[lang].def;
		    }
		
		    this.messages[lang][attribute] = message;
		  },
		
		  /**
		   * Load messages (if not already loaded)
		   *
		   * @param  {string} lang
		   * @return {void}
		   */
		  _load: function(lang) {
		    if (!this.messages[lang]) {
		      var rawMessages = __webpack_require__(99)("./" + lang);
		      this._set(lang, rawMessages);
		    }
		  },
		
		  /**
		   * Get raw messages for language
		   *
		   * @param  {string} lang
		   * @return {object}
		   */
		  _get: function(lang) {
		    this._load(lang);
		    return this.messages[lang];
		  },
		
		  /**
		   * Make messages for given language
		   *
		   * @param  {string} lang
		   * @return {Messages}
		   */
		  _make: function(lang) {
		    this._load(lang);
		    return new Messages(lang, this.messages[lang]);
		  }
		
		};
		
		module.exports = container;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Attributes = __webpack_require__(97);
		
		var Messages = function(lang, messages) {
		  this.lang = lang;
		  this.messages = messages;
		  this.customMessages = {};
		  this.attributeNames = {};
		};
		
		Messages.prototype = {
		  constructor: Messages,
		
		  /**
		   * Set custom messages
		   *
		   * @param {object} customMessages
		   * @return {void}
		   */
		  _setCustom: function(customMessages) {
		    this.customMessages = customMessages || {};
		  },
		
		  /**
		   * Set custom attribute names.
		   *
		   * @param {object} attributes
		   */
		  _setAttributeNames: function(attributes) {
		    this.attributeNames = attributes;
		  },
		
		  /**
		   * Set the attribute formatter.
		   *
		   * @param {fuction} func
		   * @return {void}
		   */
		  _setAttributeFormatter: function(func) {
		    this.attributeFormatter = func;
		  },
		
		  /**
		   * Get attribute name to display.
		   *
		   * @param  {string} attribute
		   * @return {string}
		   */
		  _getAttributeName: function(attribute) {
		    var name = attribute;
		    if (this.attributeNames.hasOwnProperty(attribute)) {
		      return this.attributeNames[attribute];
		    } else if (this.messages.attributes.hasOwnProperty(attribute)) {
		      name = this.messages.attributes[attribute];
		    }
		
		    if (this.attributeFormatter) {
		      name = this.attributeFormatter(name);
		    }
		
		    return name;
		  },
		
		  /**
		   * Get all messages
		   *
		   * @return {object}
		   */
		  all: function() {
		    return this.messages;
		  },
		
		  /**
		   * Render message
		   *
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  render: function(rule) {
		    if (rule.customMessage) {
		      return rule.customMessage;
		    }
		    var template = this._getTemplate(rule);
		
		    var message;
		    if (Attributes.replacements[rule.name]) {
		      message = Attributes.replacements[rule.name].apply(this, [template, rule]);
		    } else {
		      message = this._replacePlaceholders(rule, template, {});
		    }
		
		    return message;
		  },
		
		  /**
		   * Get the template to use for given rule
		   *
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  _getTemplate: function(rule) {
		
		    var messages = this.messages;
		    var template = messages.def;
		    var customMessages = this.customMessages;
		    var formats = [rule.name + '.' + rule.attribute, rule.name];
		
		    for (var i = 0, format; i < formats.length; i++) {
		      format = formats[i];
		      if (customMessages.hasOwnProperty(format)) {
		        template = customMessages[format];
		        break;
		      } else if (messages.hasOwnProperty(format)) {
		        template = messages[format];
		        break;
		      }
		    }
		
		    if (typeof template === 'object') {
		      template = template[rule._getValueType()];
		    }
		
		    return template;
		  },
		
		  /**
		   * Replace placeholders in the template using the data object
		   *
		   * @param  {Rule} rule
		   * @param  {string} template
		   * @param  {object} data
		   * @return {string}
		   */
		  _replacePlaceholders: function(rule, template, data) {
		    var message, attribute;
		
		    data.attribute = this._getAttributeName(rule.attribute);
		    data[rule.name] = rule.getParameters().join(',');
		
		    if (typeof template === 'string' && typeof data === 'object') {
		      message = template;
		
		      for (attribute in data) {
		        message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);
		      }
		    }
		
		    return message;
		  }
		
		};
		
		module.exports = Messages;
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports) {
	
		var replacements = {
		
		  /**
		   * Between replacement (replaces :min and :max)
		   *
		   * @param  {string} template
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  between: function(template, rule) {
		    var parameters = rule.getParameters();
		    return this._replacePlaceholders(rule, template, {
		      min: parameters[0],
		      max: parameters[1]
		    });
		  },
		
		  /**
		   * Required_if replacement.
		   *
		   * @param  {string} template
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  required_if: function(template, rule) {
		    var parameters = rule.getParameters();
		    return this._replacePlaceholders(rule, template, {
		      other: parameters[0],
		      value: parameters[1]
		    });
		  }
		};
		
		function formatter(attribute) {
		  return attribute.replace(/[_\[]/g, ' ').replace(/]/g, '');
		}
		
		module.exports = {
		  replacements: replacements,
		  formatter: formatter
		};
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'The :attribute must be accepted.',
		  alpha: 'The :attribute field must contain only alphabetic characters.',
		  alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',
		  alpha_num: 'The :attribute field must be alphanumeric.',
		  between: 'The :attribute field must be between :min and :max.',
		  confirmed: 'The :attribute confirmation does not match.',
		  email: 'The :attribute format is invalid.',
		  def: 'The :attribute attribute has errors.',
		  digits: 'The :attribute must be :digits digits.',
		  different: 'The :attribute and :different must be different.',
		  'in': 'The selected :attribute is invalid.',
		  integer: 'The :attribute must be an integer.',
		  min: {
		    numeric: 'The :attribute must be at least :min.',
		    string: 'The :attribute must be at least :min characters.'
		  },
		  max: {
		    numeric: 'The :attribute may not be greater than :max.',
		    string: 'The :attribute may not be greater than :max characters.'
		  },
		  not_in: 'The selected :attribute is invalid.',
		  numeric: 'The :attribute must be a number.',
		  required: 'The :attribute field is required.',
		  required_if: 'The :attribute field is required when :other is :value.',
		  same: 'The :attribute and :same fields must match.',
		  size: {
		    numeric: 'The :attribute must be :size.',
		    string: 'The :attribute must be :size characters.'
		  },
		  string: 'The :attribute must be a string.',
		  url: 'The :attribute format is invalid.',
		  regex: 'The :attribute format is invalid',
		  attributes: {}
		};
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
		var map = {
			"./en": 98,
			"./en.js": 98,
			"./es": 100,
			"./es.js": 100,
			"./fr": 101,
			"./fr.js": 101,
			"./it": 102,
			"./it.js": 102,
			"./ja": 103,
			"./ja.js": 103,
			"./pl": 104,
			"./pl.js": 104,
			"./ru": 105,
			"./ru.js": 105
		};
		function webpackContext(req) {
			return __webpack_require__(webpackContextResolve(req));
		};
		function webpackContextResolve(req) {
			return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
		};
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = 99;
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'El campo :attribute debe ser aceptado.',
		  alpha: 'El campo :attribute solo debe contener letras.',
		  alpha_dash: 'El campo :attribute solo debe contener letras, números y guiones.',
		  alpha_num: 'El campo :attribute solo debe contener letras y números.',
		  attributes: {},
		  between: 'El campo :attribute tiene que estar entre :min - :max.',
		  confirmed: 'La confirmación de :attribute no coincide.',
		  different: 'El campo :attribute y :other deben ser diferentes.',
		  digits: 'El campo :attribute debe tener :digits dígitos.',
		  email: 'El campo :attribute no es un correo válido',
		  'in': 'El campo :attribute es inválido.',
		  integer: 'El campo :attribute debe ser un número entero.',
		  max: {
		    numeric: 'El campo :attribute no debe ser mayor a :max.',
		    string: 'El campo :attribute no debe ser mayor que :max caracteres.'
		  },
		  min: {
		    numeric: 'El tamaño del campo :attribute debe ser de al menos :min.',
		    string: 'El campo :attribute debe contener al menos :min caracteres.'
		  },
		  not_in: 'El campo :attribute es inválido.',
		  numeric: 'El campo :attribute debe ser numérico.',
		  regex: 'El formato del campo :attribute es inválido.',
		  required: 'El campo :attribute es obligatorio.',
		  required_if: 'El campo :attribute es obligatorio cuando :other es :value.',
		  same: 'El campo :attribute y :other deben coincidir.',
		  size: {
		    numeric: 'El tamaño del campo :attribute debe ser :size.',
		    string: 'El campo :attribute debe contener :size caracteres.'
		  },
		  url: 'El formato de :attribute es inválido.'
		};
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Le champs :attribute doit être accepté.',
		  alpha: 'Le champs :attribute ne peut contenir que des caractères alphabétiques.',
		  alpha_dash: 'Le champs :attribute ne peut contenir que des caractères alphanumériques, des tirets et underscores.',
		  alpha_num: 'Le champs :attribute doit être alphanumérique.',
		  between: 'Le champs :attribute doit être compris entre :min and :max.',
		  confirmed: 'Le champs :attribute ne correspond pas.',
		  email: 'Le champs :attribute contient un format invalide.',
		  def: 'Le champs :attribute contient un attribut erroné.',
		  digits: 'Le champs :attribute doit être de :digits chiffres.',
		  different: 'Le champs :attribute et :different doivent être differents.',
		  'in': 'Le champs :attribute est invalide.',
		  integer: 'Le champs :attribute doit être un entier.',
		  min: {
		    numeric: 'Le champs :attribute doit être contenir au moins :min.',
		    string: 'Le champs :attribute doit être contenir au moins :min caractères.'
		  },
		  max: {
		    numeric: 'Le champs :attribute ne doit être supérieur à :max.',
		    string: 'Le champs :attribute ne doit être plus de :max characters.'
		  },
		  not_in: 'Le champs :attribute est invalide.',
		  numeric: 'Le champs :attribute doit être un numéro.',
		  required: 'Le champs :attribute est obligatoire.',
		  required_if: 'Le champs :attribute est obligatoire quand :other est :value.',
		  same: 'Le champs :attribute et :same doivent correspondre.',
		  size: {
		    numeric: 'La taille du champs :attribute doit être :size.',
		    string: 'La taille du champs :attribute doit être de :size caractères.'
		  },
		  url: 'Le format du champs :attribute est invalide.',
		  regex: 'Le format du champs :attribute est invalide.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 102 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Il campo :attribute deve essere accettato.',
		  alpha: 'Il campo :attribute deve contenere sono caratteri alfabetici.',
		  alpha_dash: 'Il campo :attribute può contenere solo caratteri alfanumerici oltre a trattini e trattini bassi.',
		  alpha_num: 'Il campo :attribute deve essere alfanumerico.',
		  between: 'Il campo :attribute deve essere compreso tra :min e :max.',
		  confirmed: 'Il campo conferma :attribute non è uguale.',
		  email: 'Il formato dell\'attributo :attribute non è valido.',
		  def: 'Gli attributi del campo :attribute contengono degli errori.',
		  digits: 'Il campo :attribute deve essere di :digits cifre.',
		  different: 'Il campo :attribute e :different devo essere diversi.',
		  'in': 'Il valore del campo :attribute non è valido.',
		  integer: 'Il campo :attribute deve essere un valore intero.',
		  min: {
		    numeric: 'Il campo :attribute deve essere maggiore o uguale di :min.',
		    string: 'Il campo :attribute deve essere composto da almeno :min caratteri.'
		  },
		  max: {
		    numeric: 'Il campo :attribute deve essere minore o uguale di :max.',
		    string: 'Il campo :attribute deve essere composto da massimo :max caratteri.'
		  },
		  not_in: 'Il campo :attribute non è valido.',
		  numeric: 'Il campo :attribute deve essere un numero.',
		  required: 'Il campo :attribute è richiesto.',
		  required_if: 'Il campo :attribute è richiesto quando il campo :other è uguale a :value.',
		  same: 'I campi :attribute e :same devono essere uguali.',
		  size: {
		    numeric: 'La dimensione del campo :attribute deve essere uguale a :size.',
		    string: 'Il campo :attribute deve essere di :size caratteri.'
		  },
		  string: 'Il campo :attribute deve essere una stringa.',
		  url: 'Il formato del campo :attribute non è valido.',
		  regex: 'Il formato del campo :attribute non è valido.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 103 */
	/***/ function(module, exports) {
	
		module.exports = {
		    accepted: ':attributeを確認してください。',
		    alpha: ':attributeは英字のみで入力してください。',
		    alpha_dash: ':attributeは英字とダッシュと下線のみで入力してください。',
		    alpha_num: ':attributeは英数字のみで入力してください。',
		    between: ':attributeは:min〜:max文字で入力してください。',
		    confirmed: ':attributeは確認が一致しません。',
		    email: ':attributeは正しいメールアドレスを入力してください。',
		    def: ':attributeは検証エラーが含まれています。',
		    digits: ':attributeは:digitsの数字のみで入力してください。',
		    different: ':attributeと:differentは同じであってはなりません。',
		    'in': '選択された:attributeは無効です。',
		    integer: ':attributeは整数で入力してください。',
		    min        : {
		        numeric : ":attributeは:min以上を入力してください。",
		        string  : ":attributeは:min文字以上で入力してください。"
		    },
		    max : {
		        numeric : ":attributeは:max以下を入力してください。",
		        string  : ":attributeは:max文字以上で入力してください。"
		    },
		    not_in      : "選択された:attributeは無効です。",
		    numeric     : ":attributeは数値で入力してください。",
		    required    : ":attributeは必須です。",
		    required_if : ":otherは:valueになったら:attributeは必須です。",
		    same        : ":attributeと:sameは同じでなければなりません。",
		    size        : {
		        numeric : ":attributeは:sizeを入力してください。",
		        string  : ":attributeは:size文字で入力してください。"
		    },
		    url        : ":attributeはURIを入力してください。",
		    regex      : ":attributeの値 \":value\" はパターンにマッチする必要があります。",
		    attributes : {}
		};
	
	
	/***/ },
	/* 104 */
	/***/ function(module, exports) {
	
		module.exports = {
		    accepted: 'Pole :attribute musi być zaakceptowane.',
		    alpha: 'Pole :attribute może zawierać tylko litery.',
		    alpha_dash: 'Pole :attribute moze zawierać tylko litery, myślnik i podrkeślenie.',
		    alpha_num: 'Pole :attribute moze zawierac tylko znaki alfanumeryczne.',
		    between: 'Pole :attribute musi mieć długość od :min do :max.',
		    confirmed: 'Pole :attribute nie spełnia warunku potwierdzenia.',
		    email: 'Pole :attribute ma niepoprawny format adresu email.',
		    def: 'Pole :attribute zawiera błędy.',
		    digits: 'Pole :attribute może zawierać tylko cyfry ze zbioru :digits.',
		    different: 'Pola :attribute i :different muszą się różnić.',
		    'in': 'Pole :attribute musi należeć do zbioru :in.',
		    integer: 'Pole :attribute musi być liczbą całkowitą.',
		    min: {
		        numeric: 'Pole :attribute musi być równe conajmniej :min.',
		        string: 'Pole :attribute musi zawierać conajmniej :min znaków.'
		    },
		    max: {
		        numeric: 'Pole :attribute nie moze być większe :max.',
		        string: 'Pole :attribute nie moze być dłuższe niż :max znaków.'
		    },
		    not_in: 'Pole :attribute nie może należeć do zbioru :not_in.',
		    numeric: 'Pole :attribute musi być liczbą.',
		    required: 'Pole :attribute jest wymagane.',
		    required_if: 'Pole :attribute jest wymagane jeśli pole :other jest równe :value.',
		    same: 'Pola :attribute i :same muszą być takie same.',
		    size: {
		        numeric: 'Pole :attribute musi być równe :size.',
		        string: 'Pole :attribute musi zawierać :size znaków.'
		    },
		    string: 'Pole :attribute musi być ciągiem znaków.',
		    url: 'Pole :attribute musi być poprawnym adresem URL.',
		    regex: 'Pole :attribute nie spełnia warunku.',
		    attributes: {}
		};
	
	
	/***/ },
	/* 105 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Вы должны принять :attribute.',
		  alpha: 'Поле :attribute может содержать только буквы.',
		  alpha_dash: 'Поле :attribute может содержать только буквы, цифры, дефисы и символы подчёркивания.',
		  alpha_num: 'Поле :attribute может содержать только буквы и цифры.',
		  between: 'Поле :attribute должно быть между :min и :max.',
		  confirmed: 'Поле :attribute не совпадает с подтверждением.',
		  email: 'Поле :attribute должно быть действительным электронным адресом.',
		  def: 'Поле :attribute содержит ошибки.',
		  digits: 'Длина цифрового поля :attribute должна быть :digits.',
		  different: 'Поля :attribute и :different должны различаться.',
		  'in': 'Выбранное значение для :attribute ошибочно.',
		  integer: 'Поле :attribute должно быть целым числом.',
		  min: {
		    numeric: 'Значение поля :attribute должно быть больше или равно :min.',
		    string: 'Количество символов в поле :attribute должно быть не менее :min.'
		  },
		  max: {
		    numeric: 'Значение поля :attribute должно быть меньше или равно :max.',
		    string: 'Количество символов в поле :attribute не может превышать :max.'
		  },
		  not_in: 'Выбранное значение для :attribute ошибочно.',
		  numeric: 'Поле :attribute должно быть числом.',
		  required: 'Поле :attribute обязательно для заполнения.',
		  required_if: 'Поле :attribute требуется когда значения поля :other равно :value.',
		  same: 'Значение :attribute должно совпадать с :same.',
		  size: {
		    numeric: 'Значение поля :attribute должно быть равным :size.',
		    string: 'Количество символов в поле :attribute должно быть равно :size.'
		  },
		  url: 'Поле :attribute должно содержать валидный URL.',
		  regex: 'Неверный формат поля :attribute.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 106 */
	/***/ function(module, exports) {
	
		var Errors = function() {
		  this.errors = {};
		};
		
		Errors.prototype = {
		  constructor: Errors,
		
		  /**
		   * Add new error message for given attribute
		   *
		   * @param  {string} attribute
		   * @param  {string} message
		   * @return {void}
		   */
		  add: function(attribute, message) {
		    if (!this.has(attribute)) {
		      this.errors[attribute] = [];
		    }
		
		    if (this.errors[attribute].indexOf(message) === -1) {
		      this.errors[attribute].push(message);
		    }
		  },
		
		  /**
		   * Returns an array of error messages for an attribute, or an empty array
		   *
		   * @param  {string} attribute A key in the data object being validated
		   * @return {array} An array of error messages
		   */
		  get: function(attribute) {
		    if (this.has(attribute)) {
		      return this.errors[attribute];
		    }
		
		    return [];
		  },
		
		  /**
		   * Returns the first error message for an attribute, false otherwise
		   *
		   * @param  {string} attribute A key in the data object being validated
		   * @return {string|false} First error message or false
		   */
		  first: function(attribute) {
		    if (this.has(attribute)) {
		      return this.errors[attribute][0];
		    }
		
		    return false;
		  },
		
		  /**
		   * Get all error messages from all failing attributes
		   *
		   * @return {Object} Failed attribute names for keys and an array of messages for values
		   */
		  all: function() {
		    return this.errors;
		  },
		
		  /**
		   * Determine if there are any error messages for an attribute
		   *
		   * @param  {string}  attribute A key in the data object being validated
		   * @return {boolean}
		   */
		  has: function(attribute) {
		    if (this.errors.hasOwnProperty(attribute)) {
		      return true;
		    }
		
		    return false;
		  }
		};
		
		module.exports = Errors;
	
	
	/***/ },
	/* 107 */
	/***/ function(module, exports) {
	
		function AsyncResolvers(onFailedOne, onResolvedAll) {
		  this.onResolvedAll = onResolvedAll;
		  this.onFailedOne = onFailedOne;
		  this.resolvers = {};
		  this.resolversCount = 0;
		  this.passed = [];
		  this.failed = [];
		  this.firing = false;
		}
		
		AsyncResolvers.prototype = {
		
		  /**
		   * Add resolver
		   *
		   * @param {Rule} rule
		   * @return {integer}
		   */
		  add: function(rule) {
		    var index = this.resolversCount;
		    this.resolvers[index] = rule;
		    this.resolversCount++;
		    return index;
		  },
		
		  /**
		   * Resolve given index
		   *
		   * @param  {integer} index
		   * @return {void}
		   */
		  resolve: function(index) {
		    var rule = this.resolvers[index];
		    if (rule.passes === true) {
		      this.passed.push(rule);
		    } else if (rule.passes === false) {
		      this.failed.push(rule);
		      this.onFailedOne(rule);
		    }
		
		    this.fire();
		  },
		
		  /**
		   * Determine if all have been resolved
		   *
		   * @return {boolean}
		   */
		  isAllResolved: function() {
		    return (this.passed.length + this.failed.length) === this.resolversCount;
		  },
		
		  /**
		   * Attempt to fire final all resolved callback if completed
		   *
		   * @return {void}
		   */
		  fire: function() {
		
		    if (!this.firing) {
		      return;
		    }
		
		    if (this.isAllResolved()) {
		      this.onResolvedAll(this.failed.length === 0);
		    }
		
		  },
		
		  /**
		   * Enable firing
		   *
		   * @return {void}
		   */
		  enableFiring: function() {
		    this.firing = true;
		  }
		
		};
		
		module.exports = AsyncResolvers;
	
	
	/***/ },
	/* 108 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-autocomplete\" v-el:autocomplete\n    :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'icon-right': iconRight\n    }\"\n>\n    <div class=\"ui-autocomplete-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-autocomplete-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-autocomplete-content\">\n        <label class=\"ui-autocomplete-label\">\n            <div class=\"ui-autocomplete-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <ui-icon\n                class=\"ui-autocomplete-clear-button\" icon=\"&#xE5CD\" title=\"Clear\"\n                @click=\"clearSearch\" v-show=\"!disabled && value.length\"\n            ></ui-icon>\n\n            <input\n                class=\"ui-autocomplete-input\" :placeholder=\"placeholder\" :name=\"name\"\n                :id=\"id\" autocomplete=\"off\" v-autofocus=\"autofocus\" :debounce=\"debounce\"\n\n                @focus=\"focus\" @blur=\"blur\" @keydown.up.prevent=\"highlight(highlightedItem - 1)\"\n                @keydown.down.prevent=\"highlight(highlightedItem + 1)\" @keydown.tab=\"close\"\n                @keydown.enter=\"selectHighlighted(highlightedItem, $event)\"\n\n                v-model=\"value\" v-disabled=\"disabled\" v-el:input\n            >\n\n            <ul class=\"ui-autocomplete-suggestions\" v-show=\"showDropdown\">\n                <ui-autocomplete-suggestion\n                    :highlighted=\"highlightedItem === index\" :item=\"item\" :partial=\"partial\"\n                    :keys=\"keys\"\n\n                    v-for=\"(index, item) in suggestions | filterBy search | limitBy limit\"\n                    v-ref:items @click=\"select(item)\"\n                ></ui-autocomplete-suggestion>\n            </ul>\n        </label>\n\n        <div class=\"ui-autocomplete-feedback\" v-if=\"showFeedback\">\n            <div\n                class=\"ui-autocomplete-error-text\" v-text=\"validationError\"\n                transition=\"ui-autocomplete-feedback-toggle\"\n                v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-autocomplete-help-text\" transition=\"ui-autocomplete-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(110)
		__vue_script__ = __webpack_require__(111)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiButton.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(112)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiButton.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 110 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 111 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _HasDropdown = __webpack_require__(72);
		
		var _HasDropdown2 = _interopRequireDefault(_HasDropdown);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-button',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-button-' + type;
		            }
		        },
		        buttonType: {
		            type: String,
		            default: 'submit' },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        raised: {
		            type: Boolean,
		            default: false
		        },
		        text: String,
		        icon: String,
		        iconRight: {
		            type: Boolean,
		            default: false
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        showDropdownIcon: {
		            type: Boolean,
		            default: true
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.color];
		
		            if (this.raised) {
		                classes.push('ui-button-raised');
		            }
		
		            if (this.hasDropdownMenu || this.hasPopover) {
		                classes.push('has-dropdown');
		            }
		
		            return classes;
		        },
		        spinnerColor: function spinnerColor() {
		            if (this.color === 'color-default' || this.type === 'ui-button-flat') {
		                return 'black';
		            }
		
		            return 'white';
		        },
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiMenu: _UiMenu2.default,
		        UiPopover: _UiPopover2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasDropdown2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 112 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-button\" :class=\"styleClasses\" :type=\"buttonType\" v-disabled=\"disabled || loading\"\n    v-el:button\n>\n    <div class=\"ui-button-content\" :class=\"{ 'invisible': loading }\">\n        <ui-icon\n            class=\"ui-button-icon\" :class=\"{ 'position-right': iconRight }\" :icon=\"icon\"\n            v-if=\"showIcon\"\n        ></ui-icon>\n\n        <div class=\"ui-button-text\">\n            <slot>\n                <span v-text=\"text\"></span>\n            </slot>\n        </div>\n\n        <ui-icon\n            class=\"ui-button-dropdown-icon\" icon=\"&#xE5C5;\"\n            v-if=\"!iconRight && showDropdownIcon && (hasDropdownMenu || hasPopover)\"\n        ></ui-icon>\n    </div>\n\n    <ui-progress-circular\n        class=\"ui-button-spinner\" :color=\"spinnerColor\" :size=\"18\" :stroke=\"4.5\"\n        disable-transition v-show=\"loading\"\n    ></ui-progress-circular>\n\n    <ui-ripple-ink v-if=\"!hideRippleInk && !disabled\" :trigger=\"$els.button\"></ui-ripple-ink>\n\n    <ui-menu\n        class=\"ui-button-dropdown-menu\" :trigger=\"$els.button\" :options=\"menuOptions\"\n        :show-icons=\"showMenuIcons\" :show-secondary-text=\"showMenuSecondaryText\"\n        :open-on=\"openDropdownOn\" @option-selected=\"menuOptionSelect\"\n        :dropdown-position=\"dropdownPosition\" v-if=\"hasDropdownMenu\"\n    ></ui-menu>\n\n    <ui-popover\n        :trigger=\"$els.button\" :open-on=\"openDropdownOn\" :dropdown-position=\"dropdownPosition\"\n        v-if=\"hasPopover\"\n    >\n        <slot name=\"popover\"></slot>\n    </ui-popover>\n</button>\n";
	
	/***/ },
	/* 113 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(114)
		__vue_script__ = __webpack_require__(115)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiCheckbox.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(116)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiCheckbox.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 114 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-checkbox',
		
		    props: {
		        name: String,
		        model: {
		            type: [Array, String, Boolean],
		            required: true,
		            twoWay: true
		        },
		        value: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: false
		        };
		    },
		
		
		    computed: {
		        isChecked: function isChecked() {
		            if (this.value) {
		                return this.model.indexOf(this.value) > -1;
		            }
		
		            return this.model;
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.model;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.model = this.initialValue;
		        }
		    },
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 116 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-checkbox\"\n    :class=\"{\n        'disabled': disabled, 'checked': isChecked, 'active': active, 'label-left': labelLeft\n    }\"\n>\n    <input\n        class=\"ui-checkbox-input\" type=\"checkbox\" :name=\"name\" @focus=\"focus\" @blur=\"blur\"\n        :value=\"value ? value : null\" v-model=\"model\" v-disabled=\"disabled\"\n    >\n\n    <div class=\"ui-checkbox-checkmark\">\n        <div class=\"ui-checkbox-focus-ring\"></div>\n    </div>\n\n    <div class=\"ui-checkbox-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 117 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(118)
		__vue_script__ = __webpack_require__(119)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiCollapsible.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(120)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiCollapsible.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 118 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-collapsible',
		
		    props: {
		        id: String,
		        open: {
		            type: Boolean,
		            default: false
		        },
		        header: String,
		        transition: {
		            type: String,
		            default: 'ui-collapsible-toggle'
		        },
		        hideIcon: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            height: 0,
		            isReady: false
		        };
		    },
		
		
		    computed: {
		        icon: function icon() {
		            return this.open ? 'keyboard_arrow_up' : 'keyboard_arrow_down';
		        },
		        calculatedHeight: function calculatedHeight() {
		            if (this.height === 0) {
		                return 'initial';
		            }
		
		            return this.height + 'px';
		        }
		    },
		
		    created: function created() {
		        this.id = this.id || _uuid2.default.short('ui-collapsible-');
		    },
		    ready: function ready() {
		        this.isReady = true;
		        this.setHeight();
		    },
		
		
		    events: {
		        'ui-collapsible::refresh-height': function uiCollapsibleRefreshHeight(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.$nextTick(this.setHeight);
		        }
		    },
		
		    methods: {
		        toggleMenu: function toggleMenu() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.open = !this.open;
		        },
		        setHeight: function setHeight() {
		            var body = this.$els.body;
		
		            body.style.display = 'block';
		            this.height = body.scrollHeight;
		
		            if (!this.open) {
		                body.style.display = 'none';
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ShowsRippleInk2.default, _ReceivesTargetedEvent2.default],
		
		    transitions: {
		        'ui-collapsible-toggle': {
		            afterEnter: function afterEnter() {
		                this.$dispatch('opened');
		                this.setHeight();
		            },
		            afterLeave: function afterLeave() {
		                this.$dispatch('closed');
		            }
		        }
		    }
		};
	
	/***/ },
	/* 120 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-collapsible\">\n    <button\n        class=\"ui-collapsible-header\" :class=\"{ 'disabled': disabled }\" :aria-controls=\"id\"\n        :aria-expanded=\"open ? 'true' : 'false'\" @click=\"toggleMenu\" v-disabled=\"disabled\"\n        v-el:button\n    >\n        <div class=\"ui-collapsible-header-content\">\n            <slot name=\"header\">\n                <div v-text=\"header\"></div>\n            </slot>\n        </div>\n\n        <ui-icon class=\"ui-collapsible-header-icon\" :icon=\"icon\" v-if=\"!hideIcon\"></ui-icon>\n\n        <ui-ripple-ink\n            v-if=\"!hideRippleInk && !disabled && isReady\" :trigger=\"$els.button\"\n        ></ui-ripple-ink>\n    </button>\n\n    <div\n        class=\"ui-collapsible-body-wrapper\" :transition=\"transition\"\n        :style=\"{ 'height': calculatedHeight }\" v-show=\"open\"v-el:body\n    >\n        <div class=\"ui-collapsible-body\" :id=\"id\" :aria-hidden=\"open ? null : 'true'\">\n            <slot></slot>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 121 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(122)
		__vue_script__ = __webpack_require__(123)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiConfirm.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(128)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiConfirm.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 122 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _UiModal = __webpack_require__(124);
		
		var _UiModal2 = _interopRequireDefault(_UiModal);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-confirm',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        type: {
		            type: String,
		            default: 'primary' },
		        header: {
		            type: String,
		            default: 'UiConfirm'
		        },
		        confirmButtonText: {
		            type: String,
		            default: 'OK'
		        },
		        confirmButtonIcon: String,
		        denyButtonText: {
		            type: String,
		            default: 'Cancel'
		        },
		        denyButtonIcon: String,
		        autofocus: {
		            type: String,
		            default: 'deny-button' },
		        closeOnConfirm: {
		            type: Boolean,
		            default: false
		        },
		        backdropDismissible: {
		            type: Boolean,
		            default: true
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    methods: {
		        confirm: function confirm() {
		            this.$dispatch('confirmed');
		
		            if (this.closeOnConfirm) {
		                this.show = false;
		            }
		        },
		        deny: function deny() {
		            this.show = false;
		            this.$dispatch('denied');
		        },
		        opened: function opened() {
		            var button = void 0;
		
		            if (this.autofocus === 'confirm-button') {
		                button = this.$els.confirmButton;
		            } else if (this.autofocus === 'deny-button') {
		                button = this.$els.denyButton;
		            }
		
		            if (button) {
		                _classlist2.default.add(button, 'autofocus');
		                button.addEventListener('blur', this.removeAutoFocus);
		
		                button.focus();
		            }
		
		            return true;
		        },
		        removeAutoFocus: function removeAutoFocus() {
		            var button = void 0;
		
		            if (this.autofocus === 'confirm-button') {
		                button = this.$els.confirmButton;
		            } else if (this.autofocus === 'deny-button') {
		                button = this.$els.denyButton;
		            }
		
		            if (button) {
		                button.removeEventListener('blur', this.removeAutoFocus);
		
		                _classlist2.default.remove(button, 'autofocus');
		            }
		        }
		    },
		
		    components: {
		        UiModal: _UiModal2.default,
		        UiButton: _UiButton2.default
		    }
		};
	
	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(125)
		__vue_script__ = __webpack_require__(126)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiModal.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(127)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiModal.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 125 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 126 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-modal',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-modal-' + type;
		            }
		        },
		        header: {
		            type: String,
		            default: 'UiModal Header'
		        },
		        body: {
		            type: String,
		            default: 'UiModal body'
		        },
		        role: {
		            type: String,
		            default: 'dialog' },
		        transition: {
		            type: String,
		            default: 'ui-modal-scale' },
		        showCloseButton: {
		            type: Boolean,
		            default: true
		        },
		        hideFooter: {
		            type: Boolean,
		            default: false
		        },
		        dismissible: {
		            type: Boolean,
		            default: true
		        },
		        backdropDismissible: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    data: function data() {
		        return {
		            lastFocussedElement: null
		        };
		    },
		
		
		    watch: {
		        show: function show() {
		            var _this = this;
		
		            this.$nextTick(function () {
		                if (_this.show) {
		                    _this.opened();
		                } else {
		                    _this.closed();
		                }
		            });
		        }
		    },
		
		    beforeDestroy: function beforeDestroy() {
		        if (this.show) {
		            this.tearDown();
		        }
		    },
		
		
		    methods: {
		        close: function close(e) {
		            if (!this.dismissible) {
		                return;
		            }
		
		            if (e.currentTarget === this.$els.modalMask && e.target !== e.currentTarget) {
		                return;
		            }
		
		            if (e.currentTarget === this.$els.modalMask && !this.backdropDismissible) {
		                return;
		            }
		
		            this.show = false;
		        },
		        opened: function opened() {
		            this.lastFocussedElement = document.activeElement;
		            this.$els.modalContainer.focus();
		
		            _classlist2.default.add(document.body, 'ui-modal-open');
		
		            document.addEventListener('focus', this.restrictFocus, true);
		
		            this.$dispatch('opened');
		        },
		        closed: function closed() {
		            this.tearDown();
		            this.$dispatch('closed');
		        },
		        redirectFocus: function redirectFocus(e) {
		            e.stopPropagation();
		
		            this.$els.modalContainer.focus();
		        },
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.modalContainer.contains(e.target)) {
		                e.stopPropagation();
		                this.$els.modalContainer.focus();
		            }
		        },
		        tearDown: function tearDown() {
		            _classlist2.default.remove(document.body, 'ui-modal-open');
		
		            document.removeEventListener('focus', this.restrictFocus, true);
		
		            if (this.lastFocussedElement) {
		                this.lastFocussedElement.focus();
		            }
		        },
		        transitionEnd: function transitionEnd() {
		            if (this.show) {
		                this.$dispatch('revealed');
		            } else {
		                this.$dispatch('hidden');
		            }
		        }
		    },
		
		    components: {
		        UiIconButton: _UiIconButton2.default,
		        UiButton: _UiButton2.default
		    }
		};
	
	/***/ },
	/* 127 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-modal ui-modal-mask\" v-show=\"show\" :transition=\"transition\" :class=\"[type]\"\n    :role=\"role\" @transitionend=\"transitionEnd | debounce 100\"\n>\n    <div class=\"ui-modal-wrapper\" @click=\"close\" v-el:modal-mask>\n        <div\n            class=\"ui-modal-container\" tabindex=\"-1\" @keydown.esc=\"close\"\n            v-el:modal-container\n        >\n            <div class=\"ui-modal-header\">\n                <slot name=\"header\">\n                    <h1 v-text=\"header\" class=\"ui-modal-header-text\"></h1>\n                </slot>\n\n                <ui-icon-button\n                    type=\"clear\" icon=\"&#xE5CD\" class=\"ui-modal-close-button\" @click=\"close\"\n                    :disabled=\"!dismissible\" v-if=\"showCloseButton\" v-el:close-button\n                ></ui-icon-button>\n            </div>\n\n            <div class=\"ui-modal-body\">\n                <slot>\n                    <div v-text=\"body\"></div>\n                </slot>\n            </div>\n\n            <div class=\"ui-modal-footer\" v-if=\"!hideFooter\">\n                <slot name=\"footer\">\n                    <ui-button @click=\"close\" v-if=\"dismissible\">Close</ui-button>\n                </slot>\n            </div>\n\n            <div class=\"focus-redirector\" @focus=\"redirectFocus\" tabindex=\"0\"></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 128 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-confirm\">\n    <ui-modal\n        :show.sync=\"show\" role=\"alertdialog\" :header=\"header\" @opened=\"opened\" show-close-button\n        :dismissible=\"!loading\" :backdrop-dismissible=\"backdropDismissible\"\n    >\n        <div class=\"ui-confirm-message\">\n            <slot></slot>\n        </div>\n\n        <div slot=\"footer\">\n            <ui-button\n                :color=\"type\" :text=\"confirmButtonText\" :icon=\"confirmButtonIcon\"\n                @click=\"confirm\" :loading=\"loading\" v-el:confirm-button\n            ></ui-button>\n\n            <ui-button\n                :text=\"denyButtonText\" :icon=\"denyButtonIcon\" @click=\"deny\"\n                :disabled=\"loading\" v-el:deny-button\n            ></ui-button>\n        </div>\n    </ui-modal>\n</div>\n";
	
	/***/ },
	/* 129 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(130)
		__vue_script__ = __webpack_require__(131)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiFab.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(132)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiFab.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 130 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 131 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsTooltip = __webpack_require__(73);
		
		var _ShowsTooltip2 = _interopRequireDefault(_ShowsTooltip);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-fab',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal',
		            coerce: function coerce(type) {
		                return 'ui-fab-' + type;
		            }
		        },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        icon: {
		            type: String,
		            required: true
		        },
		        ariaLabel: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ShowsTooltip2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 132 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-fab\" :class=\"[this.type, this.color]\" :aria-label=\"ariaLabel || tooltip\"\n    v-disabled=\"disabled\" v-el:button\n>\n    <ui-icon class=\"ui-fab-icon\" :icon=\"icon\"></ui-icon>\n\n    <ui-ripple-ink :trigger=\"$els.button\" v-if=\"!hideRippleInk && !disabled\"></ui-ripple-ink>\n\n    <ui-tooltip\n        :trigger=\"$els.button\" :content=\"tooltip\" :position=\"tooltipPosition\" v-if=\"tooltip\"\n        :open-on=\"openTooltipOn\"\n    ></ui-tooltip>\n</button>\n";
	
	/***/ },
	/* 133 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(134)
		__vue_script__ = __webpack_require__(135)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiPreloader.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(136)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiPreloader.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 134 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 135 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-preloader',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true
		        }
		    }
		};
	
	/***/ },
	/* 136 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-preloader\">\n    <div\n        class=\"ui-preloader-progressbar\" :class=\"{ 'loading' : show }\"\n        :aria-busy=\"show ? 'true' : false\" role=\"progressbar\"\n    ></div>\n</div>\n";
	
	/***/ },
	/* 137 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(138)
		__vue_script__ = __webpack_require__(139)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiProgressLinear.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(140)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiProgressLinear.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 138 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 139 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-progress-linear',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: false
		        },
		        type: {
		            type: String,
		            default: 'indeterminate' },
		        color: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        value: {
		            type: Number,
		            coerce: Number,
		            default: 0
		        }
		    },
		
		    computed: {
		        progress: function progress() {
		            if (this.value < 0) {
		                return 0;
		            }
		
		            if (this.value > 100) {
		                return 100;
		            }
		
		            return this.value;
		        }
		    }
		};
	
	/***/ },
	/* 140 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-progress-linear\" :class=\"[color]\" v-show=\"show\"\n    transition=\"ui-progress-linear-toggle\"\n>\n    <div\n        class=\"ui-progress-linear-determinate\" :style=\"{ 'width': progress + '%' }\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" :aria-valuenow=\"value\"\n        v-if=\"type === 'determinate'\"\n    ></div>\n\n    <div\n        class=\"ui-progress-linear-indeterminate\" role=\"progressbar\" :aria-valuemin=\"0\"\n        :aria-valuemax=\"100\" v-else\n    ></div>\n</div>\n";
	
	/***/ },
	/* 141 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(142)
		__vue_script__ = __webpack_require__(143)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRadio.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(144)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRadio.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 142 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 143 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-radio',
		
		    props: {
		        id: String,
		        name: String,
		        model: {
		            type: String,
		            default: '',
		            twoWay: true
		        },
		        checked: {
		            type: Boolean,
		            default: false
		        },
		        value: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false
		        };
		    },
		
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		
		            this.$dispatch('focussed');
		        },
		        blur: function blur() {
		            this.active = false;
		
		            this.$dispatch('blurred');
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 144 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-radio\"\n    :class=\"{ 'disabled': disabled, 'checked': active, 'label-left': labelLeft }\"\n>\n    <div class=\"ui-radio-input-wrapper\">\n        <input\n            class=\"ui-radio-input\" type=\"radio\" :id=\"id\" :name=\"name\" :value=\"value\"\n            :checked=\"checked\" @focus=\"focus\" @blur=\"blur\" v-model=\"model\" v-disabled=\"disabled\"\n        >\n\n        <span class=\"ui-radio-border\"></span>\n        <span class=\"ui-radio-inner-dot\"></span>\n    </div>\n\n    <div class=\"ui-radio-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 145 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(146)
		__vue_script__ = __webpack_require__(147)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRadioGroup.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(148)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRadioGroup.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 146 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 147 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _UiRadio = __webpack_require__(141);
		
		var _UiRadio2 = _interopRequireDefault(_UiRadio);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-radio-group',
		
		    props: {
		        name: {
		            type: String,
		            required: true
		        },
		        value: {
		            type: String,
		            default: '',
		            twoWay: true
		        },
		        options: {
		            type: Array,
		            required: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        vertical: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: ''
		        };
		    },
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            return Boolean(this.helpText);
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        }
		    },
		
		    components: {
		        UiRadio: _UiRadio2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 148 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-radio-group\" :id=\"id\"\n    :class=\"{ 'disabled': disabled, 'active': active, 'vertical': vertical }\"\n>\n    <div class=\"ui-radio-group-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n    <div class=\"ui-radio-group-options-wrapper\">\n        <ui-radio\n            class=\"ui-radio-group-radio\" v-for=\"option in options\" :model.sync=\"value\"\n            :name=\"name\" :label=\"option.text || option\" :value=\"option.value || option\"\n            :disabled=\"disabled || option.disabled\" @focussed=\"focus\" @blurred=\"blur\"\n        ></ui-radio>\n    </div>\n\n    <div\n        class=\"ui-radio-group-feedback\" v-if=\"showFeedback\"\n        transition=\"ui-radio-group-feedback-toggle\"\n    >\n        <div class=\"ui-radio-group-help-text\" v-text=\"helpText\"></div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 149 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(150)
		__vue_script__ = __webpack_require__(151)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRating.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(156)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRating.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 150 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 151 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        value: {
		            type: Number,
		            coerce: Number,
		            required: true,
		            twoWay: true
		        },
		        total: {
		            type: Number,
		            coerce: Number,
		            required: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: 0,
		            previewValue: 0,
		            previewing: false
		        };
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            return Boolean(this.helpText);
		        }
		    },
		
		    watch: {
		        value: function value() {
		            this.previewValue = this.value;
		        },
		        previewValue: function previewValue() {
		            this.$dispatch('preview-value-changed', this.previewValue);
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.value;
		
		        this.previewValue = this.value;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    methods: {
		        startPreview: function startPreview() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewing = true;
		        },
		        endPreview: function endPreview() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewing = false;
		            this.previewValue = this.value;
		        },
		        preview: function preview(n) {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewValue = n + 1;
		        },
		        commitValue: function commitValue(value) {
		            if (this.disabled) {
		                return;
		            }
		
		            if (value > 0 && value <= this.total) {
		                this.value = value;
		            }
		        },
		        incrementPreviewValue: function incrementPreviewValue() {
		            if (this.disabled) {
		                return;
		            }
		
		            var proposedValue = this.previewValue + 1;
		
		            if (proposedValue <= this.total) {
		                this.previewValue = proposedValue;
		            }
		        },
		        decrementPreviewValue: function decrementPreviewValue() {
		            if (this.disabled) {
		                return;
		            }
		
		            var proposedValue = this.previewValue - 1;
		
		            if (proposedValue > 0) {
		                this.previewValue = proposedValue;
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		            this.startPreview();
		        },
		        blur: function blur() {
		            this.active = false;
		
		            this.commitValue(this.previewValue);
		            this.endPreview();
		        }
		    },
		
		    components: {
		        UiRatingIcon: _UiRatingIcon2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 152 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(153)
		__vue_script__ = __webpack_require__(154)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRatingIcon.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(155)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRatingIcon.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 153 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 154 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating-icon',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        selected: {
		            type: Boolean,
		            required: true
		        },
		        filled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        icon: function icon() {
		            if (this.filled || this.selected) {
		                return this.type === 'star' ? 'star' : 'favorite';
		            }
		
		            return this.type === 'star' ? 'star_border' : 'favorite_border';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    }
		};
	
	/***/ },
	/* 155 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-rating-icon\">\n    <ui-icon\n        class=\"ui-rating-icon-icon\" :icon=\"icon\"\n        :class=\"{ 'selected': selected, 'filled' : filled }\"\n    ></ui-icon>\n</div>\n";
	
	/***/ },
	/* 156 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-rating\" :class=\"{ 'disabled': disabled, 'preview': previewing, 'active': active }\"\n\n    :tabindex=\"disabled ? null : 0\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"total\"\n    :aria-valuenow=\"previewValue\"\n\n    @keydown.up.prevent=\"incrementPreviewValue\" @keydown.down.prevent=\"decrementPreviewValue\"\n    @keydown.right.prevent=\"incrementPreviewValue\" @keydown.left.prevent=\"decrementPreviewValue\"\n    @keydown.enter.prevent=\"commitValue(previewValue)\" @focus=\"focus\" @blur=\"blur\"\n>\n    <div class=\"ui-rating-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n    <div\n        class=\"ui-rating-icons-wrapper\" @mouseenter=\"startPreview\" @mouseleave=\"endPreview\"\n    >\n        <ui-rating-icon\n            :type=\"type\" v-for=\"n in total\" :selected=\"(n + 1) <= value\" @mouseover=\"preview(n)\"\n            :filled=\"(n + 1) <= previewValue\" @click=\"commitValue(n + 1)\"\n        ></ui-rating-icon>\n    </div>\n\n    <div\n        class=\"ui-rating-feedback\" v-if=\"showFeedback\" transition=\"ui-rating-feedback-toggle\"\n    >\n        <div class=\"ui-rating-help-text\" v-text=\"helpText\"></div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 157 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(158)
		__vue_script__ = __webpack_require__(159)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRatingPreview.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(160)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRatingPreview.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 158 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 159 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating-preview',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        value: {
		            type: Number,
		            coerce: Number,
		            required: true
		        },
		        total: {
		            type: Number,
		            coerce: Number,
		            required: true
		        }
		    },
		
		    components: {
		        UiRatingIcon: _UiRatingIcon2.default
		    }
		};
	
	/***/ },
	/* 160 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-rating-preview\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"total\"\n    :aria-valuenow=\"value\"\n>\n    <ui-rating-icon\n        :type=\"type\" v-for=\"n in total\" :selected=\"(n + 1) <= value\"\n    ></ui-rating-icon>\n</div>\n";
	
	/***/ },
	/* 161 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(162)
		__vue_script__ = __webpack_require__(163)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSelect.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(171)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSelect.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 162 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 163 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _mergeOptions = __webpack_require__(164);
		
		var _mergeOptions2 = _interopRequireDefault(_mergeOptions);
		
		var _fuzzysearch = __webpack_require__(84);
		
		var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);
		
		var _elementScroll = __webpack_require__(166);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiSelectOption = __webpack_require__(167);
		
		var _UiSelectOption2 = _interopRequireDefault(_UiSelectOption);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-select',
		
		    props: {
		        value: {
		            type: [Object, Array, String, Number],
		            default: null,
		            twoWay: true
		        },
		        default: {
		            type: [Object, Array, String, Number],
		            default: null
		        },
		        options: {
		            type: Array,
		            default: []
		        },
		        partial: String,
		        showSearch: {
		            type: Boolean,
		            default: false
		        },
		        searchPlaceholder: {
		            type: String,
		            default: 'Search'
		        },
		        multiple: {
		            type: Boolean,
		            default: false
		        },
		        multipleDelimiter: {
		            type: String,
		            default: ', '
		        },
		        optionsDynamic: {
		            type: Boolean,
		            default: false
		        },
		        optionsLoaded: {
		            type: Boolean,
		            default: true
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        },
		        filter: Function
		    },
		
		    data: function data() {
		        return {
		            query: '',
		            selectedIndex: -1,
		            highlightedIndex: -1,
		            showDropdown: false,
		            ignoreQueryChange: false
		        };
		    },
		
		
		    computed: {
		        filteredOptions: function filteredOptions() {
		            if (this.optionsDynamic) {
		                return this.options;
		            }
		
		            return this.options.filter(this.search);
		        },
		        displayText: function displayText() {
		            var _this = this;
		
		            if (this.multiple && this.value.length) {
		                var labels = this.value.map(function (value) {
		                    return value[_this.keys.text] || value;
		                });
		
		                return labels.join(this.multipleDelimiter);
		            }
		
		            return this.value ? this.value[this.keys.text] || this.value : '';
		        },
		        hasDisplayText: function hasDisplayText() {
		            return this.displayText && Boolean(this.displayText.length);
		        },
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        nothingFound: function nothingFound() {
		            if (this.optionsDynamic && !this.optionsLoaded) {
		                return false;
		            }
		
		            if (this.query.length && !this.loading) {
		                return !Boolean(this.filteredOptions.length);
		            }
		
		            return false;
		        }
		    },
		
		    watch: {
		        filteredOptions: function filteredOptions() {
		            this.highlightedIndex = 0;
		            (0, _elementScroll.resetScroll)(this.$els.optionsList);
		        },
		        showDropdown: function showDropdown() {
		            if (this.showDropdown) {
		                this.opened();
		                this.$dispatch('opened');
		            } else {
		                this.closed();
		                this.$dispatch('closed');
		            }
		        },
		        query: function query() {
		            if (!this.ignoreQueryChange) {
		                this.$dispatch('query-changed', this.query);
		            }
		        }
		    },
		
		    created: function created() {
		        this.initValue();
		
		        var errorMessages = {
		            min: 'You must select at least :min options.',
		            max: 'You must select no more than :max options.',
		            between: 'You must select at least :min but no more than :max options.'
		        };
		
		        if (this.validationRules) {
		            this.validationMessages = (0, _mergeOptions2.default)(errorMessages, this.validationMessages);
		        }
		    },
		    ready: function ready() {
		        document.addEventListener('click', this.closeOnExternalClick);
		    },
		    beforeDestroy: function beforeDestroy() {
		        document.removeEventListener('click', this.closeOnExternalClick);
		    },
		
		
		    events: {
		        'ui-select::set-selected': function uiSelectSetSelected(value, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.default = value;
		            this.initValue();
		        },
		
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.initValue();
		            this.dirty = false;
		            this.valid = true;
		
		            this.clearQuery();
		            this.selectedIndex = -1;
		            this.highlightedIndex = -1;
		        }
		    },
		
		    methods: {
		        initValue: function initValue() {
		            this.value = this.multiple ? [] : null;
		
		            if (this.default) {
		                var defaults = Array.isArray(this.default) ? this.default : [this.default];
		
		                if (defaults.length) {
		                    this.setDefaultValue(defaults);
		                }
		            }
		        },
		        search: function search(option) {
		            if (this.filter) {
		                return this.filter(option, this.query);
		            }
		
		            var query = this.query.toLowerCase();
		            var text = option[this.keys.text] || option;
		
		            if (typeof text === 'string') {
		                text = text.toLowerCase();
		            }
		
		            return (0, _fuzzysearch2.default)(query, text);
		        },
		        clearQuery: function clearQuery() {
		            var _this2 = this;
		
		            this.ignoreQueryChange = true;
		
		            this.$nextTick(function () {
		                _this2.query = '';
		
		                _this2.$nextTick(function () {
		                    _this2.ignoreQueryChange = false;
		                });
		            });
		        },
		        select: function select(option, index) {
		            var close = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
		
		            if (this.multiple) {
		                if (this.isSelected(option)) {
		                    this.deselect(option);
		                } else {
		                    this.value.push(option);
		                }
		            } else {
		                this.value = option;
		                this.selectedIndex = index;
		            }
		
		            this.$dispatch('selected', option);
		
		            this.highlightedIndex = index;
		            this.clearQuery();
		            this.validate();
		
		            if (!this.multiple && close) {
		                this.close();
		            }
		        },
		        deselect: function deselect(option) {
		            this.value.$remove(option);
		        },
		        isSelected: function isSelected(option) {
		            if (this.multiple) {
		                return this.value.indexOf(option) > -1;
		            }
		
		            return this.value === option;
		        },
		        selectHighlighted: function selectHighlighted(index, e) {
		            if (this.$refs.options.length) {
		                e.preventDefault();
		                this.select(this.$refs.options[index].option, index);
		            }
		        },
		        highlight: function highlight(index, preventScroll) {
		            if (this.highlightedIndex === index || this.$refs.options.length === 0) {
		                return;
		            }
		
		            var firstIndex = 0;
		            var lastIndex = this.$refs.options.length - 1;
		
		            if (index < firstIndex) {
		                index = lastIndex;
		            } else if (index > lastIndex) {
		                index = firstIndex;
		            }
		
		            this.highlightedIndex = index;
		
		            if (!preventScroll) {
		                this.scrollOptionIntoView(this.$refs.options[index].$el);
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		
		            if (this.showDropdown) {
		                this.close();
		            }
		        },
		        toggle: function toggle() {
		            if (this.showDropdown) {
		                this.close();
		            } else {
		                this.open();
		            }
		        },
		        open: function open() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.showDropdown = true;
		        },
		        opened: function opened() {
		            var _this3 = this;
		
		            this.$nextTick(function () {
		                if (_this3.showSearch) {
		                    _this3.$els.searchInput.focus();
		                } else {
		                    _this3.$els.dropdown.focus();
		                }
		
		                _this3.scrollOptionIntoView(_this3.$els.optionsList.querySelector('.selected'));
		            });
		        },
		        close: function close(deactivate) {
		            this.showDropdown = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            if (deactivate) {
		                this.active = false;
		            } else {
		                this.$els.label.focus();
		            }
		        },
		        closeOnExternalClick: function closeOnExternalClick(e) {
		            if (!this.$el.contains(e.target) && (this.showDropdown || this.active)) {
		                this.close(true);
		            }
		        },
		        closed: function closed() {
		            this.validate();
		
		            if (this.multiple) {
		                this.highlightedIndex = -1;
		            } else {
		                this.highlightedIndex = this.selectedIndex;
		            }
		        },
		        setDefaultValue: function setDefaultValue(defaults) {
		            var optionValue = void 0;
		            var defaultOptionValue = void 0;
		
		            for (var i = 0; i < defaults.length; i++) {
		                defaultOptionValue = defaults[i][this.keys.value] || defaults[i];
		
		                for (var j = 0; j < this.options.length; j++) {
		                    optionValue = this.options[j][this.keys.value] || this.options[j];
		
		                    if (optionValue === defaultOptionValue) {
		                        this.select(this.options[j], j, false);
		                        break;
		                    }
		                }
		            }
		        },
		        scrollOptionIntoView: function scrollOptionIntoView(optionEl) {
		            (0, _elementScroll.scrollIntoView)(optionEl, this.$els.optionsList, 80);
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiSelectOption: _UiSelectOption2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 164 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var isOptionObject = __webpack_require__(165);
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.propertyIsEnumerable;
		var globalThis = this;
		var defaultMergeOpts = {
			concatArrays: false
		};
		
		function getEnumerableOwnPropertyKeys(value) {
			var keys = [];
		
			for (var key in value) {
				if (hasOwnProperty.call(value, key)) {
					keys.push(key);
				}
			}
		
			if (Object.getOwnPropertySymbols) {
				var symbols = Object.getOwnPropertySymbols(value);
		
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(value, symbols[i])) {
						keys.push(symbols[i]);
					}
				}
			}
		
			return keys;
		}
		
		function clone(value) {
			if (Array.isArray(value)) {
				return cloneArray(value);
			}
		
			if (isOptionObject(value)) {
				return cloneOptionObject(value);
			}
		
			return value;
		}
		
		function cloneArray(array) {
			var result = array.slice(0, 0);
		
			getEnumerableOwnPropertyKeys(array).forEach(function (key) {
				result[key] = clone(array[key]);
			});
		
			return result;
		}
		
		function cloneOptionObject(obj) {
			var result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};
		
			getEnumerableOwnPropertyKeys(obj).forEach(function (key) {
				result[key] = clone(obj[key]);
			});
		
			return result;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 */
		function mergeKeys(merged, source, keys, mergeOpts) {
			keys.forEach(function (key) {
				if (key in merged) {
					merged[key] = merge(merged[key], source[key], mergeOpts);
				} else {
					merged[key] = clone(source[key]);
				}
			});
		
			return merged;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 *
		 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
		 */
		function concatArrays(merged, source, mergeOpts) {
			var result = merged.slice(0, 0);
			var resultIndex = 0;
		
			[merged, source].forEach(function (array) {
				var indices = [];
		
				// result.concat(array) with cloning
				for (var k = 0; k < array.length; k++) {
					if (!hasOwnProperty.call(array, k)) {
						continue;
					}
		
					indices.push(String(k));
		
					if (array === merged) {
						// already cloned
						result[resultIndex++] = array[k];
					} else {
						result[resultIndex++] = clone(array[k]);
					}
				}
		
				// merge non-index keys
				result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(function (key) {
					return indices.indexOf(key) === -1;
				}), mergeOpts);
			});
		
			return result;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 */
		function merge(merged, source, mergeOpts) {
			if (mergeOpts.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
				return concatArrays(merged, source, mergeOpts);
			}
		
			if (!isOptionObject(source) || !isOptionObject(merged)) {
				return clone(source);
			}
		
			return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), mergeOpts);
		}
		
		module.exports = function () {
			var mergeOpts = merge(clone(defaultMergeOpts), (this !== globalThis && this) || {}, defaultMergeOpts);
			var merged = {};
		
			for (var i = 0; i < arguments.length; i++) {
				var option = arguments[i];
		
				if (option === undefined) {
					continue;
				}
		
				if (!isOptionObject(option)) {
					throw new TypeError('`' + option + '` is not an Option Object');
				}
		
				merged = merge(merged, option, mergeOpts);
			}
		
			return merged;
		};
	
	
	/***/ },
	/* 165 */
	/***/ function(module, exports) {
	
		'use strict';
		var toString = Object.prototype.toString;
		
		module.exports = function (x) {
			var prototype;
			return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
		};
	
	
	/***/ },
	/* 166 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.inView = inView;
		exports.scrollIntoView = scrollIntoView;
		exports.resetScroll = resetScroll;
		function inView(element, container) {
		    if (!element) {
		        return;
		    }
		
		    container = container || element.parentElement;
		
		    var top = element.offsetTop;
		    var parentTop = container.scrollTop;
		    var bottom = top + element.offsetHeight;
		    var parentBottom = container.offsetHeight;
		
		    return top >= parentTop && bottom <= parentBottom;
		}
		
		function scrollIntoView(element, container) {
		    var marginTop = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
		
		    if (!element || inView(element, container)) {
		        return;
		    }
		
		    container = container || element.parentElement;
		
		    container.scrollTop = element.offsetTop - marginTop;
		}
		
		function resetScroll(element) {
		    if (!element) {
		        return;
		    }
		
		    element.scrollTop = 0;
		}
		
		exports.default = {
		    inView: inView,
		    scrollIntoView: scrollIntoView,
		    resetScroll: resetScroll
		};
	
	/***/ },
	/* 167 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(168)
		__vue_script__ = __webpack_require__(169)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSelectOption.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(170)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSelectOption.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 168 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 169 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-select-option',
		
		    props: {
		        option: {
		            type: [String, Object],
		            required: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-select-simple' },
		        showCheckbox: {
		            type: Boolean,
		            default: false
		        },
		        highlighted: {
		            type: Boolean,
		            default: false
		        },
		        selected: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    computed: {
		        icon: function icon() {
		            return this.selected ? 'check_box' : 'check_box_outline_blank';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    partials: {
		        'ui-select-simple': '\n            <li class="ui-select-item-text" v-text="option[keys.text] || option"></li>\n        ',
		
		        'ui-select-image': '\n            <div\n                class="ui-select-item-image"\n                :style="{ \'background-image\': \'url(\' + option[keys.image] + \')\' }"\n            ></div>\n\n            <div class="ui-select-item-text" v-text="option[keys.text]"></div>\n        '
		    }
		};
	
	/***/ },
	/* 170 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-select-option\" :class=\"{ highlighted: highlighted, selected: selected }\"\n>\n    <div class=\"ui-select-option-content\" :class=\"[partial]\">\n        <partial :name=\"partial\"></partial>\n    </div>\n\n    <ui-icon\n        class=\"ui-select-option-checkbox\" :icon=\"icon\" v-if=\"showCheckbox\"\n    ></ui-icon>\n</li>\n";
	
	/***/ },
	/* 171 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-select\" :id=\"id\" :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'icon-right': iconRight\n    }\"\n>\n    <div class=\"ui-select-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-select-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-select-content\">\n        <div\n            class=\"ui-select-label\" :tabindex=\"disabled ? null : '0'\" v-el:label\n            @focus=\"focus\" @keydown.tab=\"blur\" @click=\"toggle\" @keydown.space.prevent=\"open\"\n            @keydown.enter.prevent=\"open\"\n        >\n            <div class=\"ui-select-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <div class=\"ui-select-display\">\n                <div\n                    class=\"ui-select-value\" :class=\"{ placeholder: !hasDisplayText }\"\n                    v-text=\"hasDisplayText ? displayText : placeholder\"\n                ></div>\n\n                <ui-icon icon=\"arrow_drop_down\" class=\"ui-select-dropdown-icon\"></ui-icon>\n            </div>\n\n            <div\n                class=\"ui-select-dropdown\" tabindex=\"-1\" v-show=\"showDropdown\" v-el:dropdown\n                @keydown.esc.prevent=\"close()\" @keydown.tab=\"close()\"\n                @keydown.up.prevent=\"highlight(highlightedIndex - 1)\"\n                @keydown.down.prevent=\"highlight(highlightedIndex + 1)\"\n                @keydown.enter.prevent.stop=\"selectHighlighted(highlightedIndex, $event)\"\n            >\n                <div class=\"ui-select-search\" v-if=\"showSearch\" @click.stop @keydown.space.stop>\n                    <input\n                        class=\"ui-select-search-input\" type=\"text\" v-el:search-input\n                        :placeholder=\"searchPlaceholder\" v-model=\"query\" autocomplete=\"off\"\n                    >\n\n                    <ui-progress-circular\n                        class=\"ui-select-search-spinner\" :size=\"24\" :stroke=\"4\" :show=\"loading\"\n                    ></ui-progress-circular>\n                </div>\n\n                <ul class=\"ui-select-options\" v-el:options-list>\n                    <ui-select-option\n                        :option=\"option\" :partial=\"partial\" :show-checkbox=\"multiple\" :\n                        :keys=\"keys\" @click.stop.prevent=\"select(option, index)\"\n                        @mouseover.stop=\"highlight(index, true)\"\n\n                        :highlighted=\"highlightedIndex === index\"\n                        :selected=\"isSelected(option)\"\n\n                        v-for=\"(index, option) in filteredOptions\" v-ref:options\n                    ></ui-select-option>\n\n                    <li class=\"ui-select-no-results\" v-if=\"nothingFound\">No results found</li>\n                </ul>\n            </div>\n        </div>\n\n        <div class=\"ui-select-feedback\" v-if=\"showFeedback\">\n            <div\n                class=\"ui-select-error-text\" transition=\"ui-select-feedback-toggle\"\n                v-text=\"validationError\" v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-select-help-text\" transition=\"ui-select-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 172 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(173)
		__vue_script__ = __webpack_require__(174)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSlider.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(183)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSlider.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 173 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 174 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _draggabilly = __webpack_require__(175);
		
		var _draggabilly2 = _interopRequireDefault(_draggabilly);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-slider',
		
		    props: {
		        name: String,
		        value: {
		            type: Number,
		            required: true,
		            twoWay: true
		        },
		        step: {
		            type: Number,
		            default: 5
		        },
		        icon: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: 0,
		            dragging: false,
		            draggable: null
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        hasLabel: function hasLabel() {
		            if (this.hideLabel) {
		                return true;
		            }
		
		            return Boolean(this.label);
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (!this.dragging) {
		                this.$els.thumb.style.left = this.value + '%';
		            }
		        },
		        disabled: function disabled() {
		            if (this.disabled) {
		                this.draggable.disable();
		            } else {
		                this.draggable.enable();
		            }
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    ready: function ready() {
		        this.initialValue = this.value;
		
		        this.$els.thumb.style.left = this.value + '%';
		
		        this.draggable = new _draggabilly2.default(this.$els.thumb, {
		            containment: this.$els.containment,
		            axis: 'x'
		        });
		
		        this.draggable.on('dragStart', this.dragStart);
		        this.draggable.on('dragMove', this.dragMove);
		        this.draggable.on('dragEnd', this.dragEnd);
		
		        if (this.disabled) {
		            this.draggable.disable();
		        }
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.draggable) {
		            this.draggable.destroy();
		        }
		    },
		
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        },
		        sliderClick: function sliderClick(e) {
		            if (this.disabled) {
		                return;
		            }
		
		            var sliderPosition = this.$els.slider.getBoundingClientRect();
		
		            var newValue = (e.clientX - sliderPosition.left) / sliderPosition.width * 100;
		
		            this.setValue(newValue);
		
		            if (e.target !== this.$els.thumb) {
		                this.draggable._pointerDown(e, e);
		            }
		
		            this.$el.focus();
		        },
		        dragStart: function dragStart() {
		            this.dragging = true;
		            this.$el.focus();
		        },
		        dragMove: function dragMove() {
		            var x = this.draggable.position.x;
		            var newValue = x / this.$els.slider.getBoundingClientRect().width * 100;
		
		            this.setValue(newValue);
		        },
		        dragEnd: function dragEnd() {
		            this.dragging = false;
		        },
		        increment: function increment() {
		            if (this.value === 100) {
		                return;
		            }
		
		            this.setValue(this.value + this.step);
		        },
		        decrement: function decrement() {
		            if (this.value === 0) {
		                return;
		            }
		
		            this.setValue(this.value - this.step);
		        },
		        setValue: function setValue(value) {
		            if (value === this.value) {
		                return;
		            }
		
		            var moderatedValue = Math.round(value);
		
		            if (moderatedValue >= 100) {
		                moderatedValue = 100;
		            }
		
		            if (moderatedValue <= 0) {
		                moderatedValue = 0;
		            }
		
		            this.value = moderatedValue;
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 175 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Draggabilly v1.2.4
		 * Make that shiz draggable
		 * http://draggabilly.desandro.com
		 * MIT license
		 */
		
		( function( window, factory ) {
		  'use strict';
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		        'classie/classie',
		        'get-style-property/get-style-property',
		        'get-size/get-size',
		        'unidragger/unidragger'
		      ],
		      function( classie, getStyleProperty, getSize, Unidragger ) {
		        return factory( window, classie, getStyleProperty, getSize, Unidragger );
		      });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(176),
		      __webpack_require__(177),
		      __webpack_require__(178),
		      __webpack_require__(179)
		    );
		  } else {
		    // browser global
		    window.Draggabilly = factory(
		      window,
		      window.classie,
		      window.getStyleProperty,
		      window.getSize,
		      window.Unidragger
		    );
		  }
		
		}( window, function factory( window, classie, getStyleProperty, getSize, Unidragger ) {
		
		'use strict';
		
		// vars
		var document = window.document;
		
		function noop() {}
		
		// -------------------------- helpers -------------------------- //
		
		// extend objects
		function extend( a, b ) {
		  for ( var prop in b ) {
		    a[ prop ] = b[ prop ];
		  }
		  return a;
		}
		
		// ----- get style ----- //
		
		var defView = document.defaultView;
		
		var getStyle = defView && defView.getComputedStyle ?
		  function( elem ) {
		    return defView.getComputedStyle( elem, null );
		  } :
		  function( elem ) {
		    return elem.currentStyle;
		  };
		
		
		// http://stackoverflow.com/a/384380/182183
		var isElement = ( typeof HTMLElement == 'object' ) ?
		  function isElementDOM2( obj ) {
		    return obj instanceof HTMLElement;
		  } :
		  function isElementQuirky( obj ) {
		    return obj && typeof obj == 'object' &&
		      obj.nodeType == 1 && typeof obj.nodeName == 'string';
		  };
		
		// -------------------------- requestAnimationFrame -------------------------- //
		
		// https://gist.github.com/1866474
		
		var lastTime = 0;
		var prefixes = 'webkit moz ms o'.split(' ');
		// get unprefixed rAF and cAF, if present
		var requestAnimationFrame = window.requestAnimationFrame;
		var cancelAnimationFrame = window.cancelAnimationFrame;
		// loop through vendor prefixes and get prefixed rAF and cAF
		var prefix;
		for( var i = 0; i < prefixes.length; i++ ) {
		  if ( requestAnimationFrame && cancelAnimationFrame ) {
		    break;
		  }
		  prefix = prefixes[i];
		  requestAnimationFrame = requestAnimationFrame || window[ prefix + 'RequestAnimationFrame' ];
		  cancelAnimationFrame  = cancelAnimationFrame  || window[ prefix + 'CancelAnimationFrame' ] ||
		                            window[ prefix + 'CancelRequestAnimationFrame' ];
		}
		
		// fallback to setTimeout and clearTimeout if either request/cancel is not supported
		if ( !requestAnimationFrame || !cancelAnimationFrame )  {
		  requestAnimationFrame = function( callback ) {
		    var currTime = new Date().getTime();
		    var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
		    var id = window.setTimeout( function() {
		      callback( currTime + timeToCall );
		    }, timeToCall );
		    lastTime = currTime + timeToCall;
		    return id;
		  };
		
		  cancelAnimationFrame = function( id ) {
		    window.clearTimeout( id );
		  };
		}
		
		// -------------------------- support -------------------------- //
		
		var transformProperty = getStyleProperty('transform');
		// TODO fix quick & dirty check for 3D support
		var is3d = !!getStyleProperty('perspective');
		
		var jQuery = window.jQuery;
		
		// --------------------------  -------------------------- //
		
		function Draggabilly( element, options ) {
		  // querySelector if string
		  this.element = typeof element == 'string' ?
		    document.querySelector( element ) : element;
		
		  if ( jQuery ) {
		    this.$element = jQuery( this.element );
		  }
		
		  // options
		  this.options = extend( {}, this.constructor.defaults );
		  this.option( options );
		
		  this._create();
		}
		
		// inherit Unidragger methods
		extend( Draggabilly.prototype, Unidragger.prototype );
		
		Draggabilly.defaults = {
		};
		
		/**
		 * set options
		 * @param {Object} opts
		 */
		Draggabilly.prototype.option = function( opts ) {
		  extend( this.options, opts );
		};
		
		Draggabilly.prototype._create = function() {
		
		  // properties
		  this.position = {};
		  this._getPosition();
		
		  this.startPoint = { x: 0, y: 0 };
		  this.dragPoint = { x: 0, y: 0 };
		
		  this.startPosition = extend( {}, this.position );
		
		  // set relative positioning
		  var style = getStyle( this.element );
		  if ( style.position != 'relative' && style.position != 'absolute' ) {
		    this.element.style.position = 'relative';
		  }
		
		  this.enable();
		  this.setHandles();
		
		};
		
		/**
		 * set this.handles and bind start events to 'em
		 */
		Draggabilly.prototype.setHandles = function() {
		  this.handles = this.options.handle ?
		    this.element.querySelectorAll( this.options.handle ) : [ this.element ];
		
		  this.bindHandles();
		};
		
		/**
		 * emits events via eventEmitter and jQuery events
		 * @param {String} type - name of event
		 * @param {Event} event - original event
		 * @param {Array} args - extra arguments
		 */
		Draggabilly.prototype.dispatchEvent = function( type, event, args ) {
		  var emitArgs = [ event ].concat( args );
		  this.emitEvent( type, emitArgs );
		  var jQuery = window.jQuery;
		  // trigger jQuery event
		  if ( jQuery && this.$element ) {
		    if ( event ) {
		      // create jQuery event
		      var $event = jQuery.Event( event );
		      $event.type = type;
		      this.$element.trigger( $event, args );
		    } else {
		      // just trigger with type if no event available
		      this.$element.trigger( type, args );
		    }
		  }
		};
		
		// -------------------------- position -------------------------- //
		
		// get left/top position from style
		Draggabilly.prototype._getPosition = function() {
		  // properties
		  var style = getStyle( this.element );
		
		  var x = parseInt( style.left, 10 );
		  var y = parseInt( style.top, 10 );
		
		  // clean up 'auto' or other non-integer values
		  this.position.x = isNaN( x ) ? 0 : x;
		  this.position.y = isNaN( y ) ? 0 : y;
		
		  this._addTransformPosition( style );
		};
		
		// add transform: translate( x, y ) to position
		Draggabilly.prototype._addTransformPosition = function( style ) {
		  if ( !transformProperty ) {
		    return;
		  }
		  var transform = style[ transformProperty ];
		  // bail out if value is 'none'
		  if ( transform.indexOf('matrix') !== 0 ) {
		    return;
		  }
		  // split matrix(1, 0, 0, 1, x, y)
		  var matrixValues = transform.split(',');
		  // translate X value is in 12th or 4th position
		  var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;
		  var translateX = parseInt( matrixValues[ xIndex ], 10 );
		  // translate Y value is in 13th or 5th position
		  var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );
		  this.position.x += translateX;
		  this.position.y += translateY;
		};
		
		// -------------------------- events -------------------------- //
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerDown = function( event, pointer ) {
		  this._dragPointerDown( event, pointer );
		  // kludge to blur focused inputs in dragger
		  var focused = document.activeElement;
		  if ( focused && focused.blur ) {
		    focused.blur();
		  }
		  // bind move and end events
		  this._bindPostStartEvents( event );
		  classie.add( this.element, 'is-pointer-down' );
		  this.dispatchEvent( 'pointerDown', event, [ pointer ] );
		};
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerMove = function( event, pointer ) {
		  var moveVector = this._dragPointerMove( event, pointer );
		  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );
		  this._dragMove( event, pointer, moveVector );
		};
		
		/**
		 * drag start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragStart = function( event, pointer ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  this._getPosition();
		  this.measureContainment();
		  // position _when_ drag began
		  this.startPosition.x = this.position.x;
		  this.startPosition.y = this.position.y;
		  // reset left/top style
		  this.setLeftTop();
		
		  this.dragPoint.x = 0;
		  this.dragPoint.y = 0;
		
		  // reset isDragging flag
		  this.isDragging = true;
		  classie.add( this.element, 'is-dragging' );
		  this.dispatchEvent( 'dragStart', event, [ pointer ] );
		  // start animation
		  this.animate();
		};
		
		Draggabilly.prototype.measureContainment = function() {
		  var containment = this.options.containment;
		  if ( !containment ) {
		    return;
		  }
		
		  this.size = getSize( this.element );
		  var elemRect = this.element.getBoundingClientRect();
		
		  // use element if element
		  var container = isElement( containment ) ? containment :
		    // fallback to querySelector if string
		    typeof containment == 'string' ? document.querySelector( containment ) :
		    // otherwise just `true`, use the parent
		    this.element.parentNode;
		
		  this.containerSize = getSize( container );
		  var containerRect = container.getBoundingClientRect();
		
		  this.relativeStartPosition = {
		    x: elemRect.left - containerRect.left,
		    y: elemRect.top  - containerRect.top
		  };
		};
		
		// ----- move event ----- //
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragMove = function( event, pointer, moveVector ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  var dragX = moveVector.x;
		  var dragY = moveVector.y;
		
		  var grid = this.options.grid;
		  var gridX = grid && grid[0];
		  var gridY = grid && grid[1];
		
		  dragX = applyGrid( dragX, gridX );
		  dragY = applyGrid( dragY, gridY );
		
		  dragX = this.containDrag( 'x', dragX, gridX );
		  dragY = this.containDrag( 'y', dragY, gridY );
		
		  // constrain to axis
		  dragX = this.options.axis == 'y' ? 0 : dragX;
		  dragY = this.options.axis == 'x' ? 0 : dragY;
		
		  this.position.x = this.startPosition.x + dragX;
		  this.position.y = this.startPosition.y + dragY;
		  // set dragPoint properties
		  this.dragPoint.x = dragX;
		  this.dragPoint.y = dragY;
		
		  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );
		};
		
		function applyGrid( value, grid, method ) {
		  method = method || 'round';
		  return grid ? Math[ method ]( value / grid ) * grid : value;
		}
		
		Draggabilly.prototype.containDrag = function( axis, drag, grid ) {
		  if ( !this.options.containment ) {
		    return drag;
		  }
		  var measure = axis == 'x' ? 'width' : 'height';
		
		  var rel = this.relativeStartPosition[ axis ];
		  var min = applyGrid( -rel, grid, 'ceil' );
		  var max = this.containerSize[ measure ] - rel - this.size[ measure ];
		  max = applyGrid( max, grid, 'floor' );
		  return  Math.min( max, Math.max( min, drag ) );
		};
		
		// ----- end event ----- //
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerUp = function( event, pointer ) {
		  classie.remove( this.element, 'is-pointer-down' );
		  this.dispatchEvent( 'pointerUp', event, [ pointer ] );
		  this._dragPointerUp( event, pointer );
		};
		
		/**
		 * drag end
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragEnd = function( event, pointer ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  this.isDragging = false;
		  // use top left position when complete
		  if ( transformProperty ) {
		    this.element.style[ transformProperty ] = '';
		    this.setLeftTop();
		  }
		  classie.remove( this.element, 'is-dragging' );
		  this.dispatchEvent( 'dragEnd', event, [ pointer ] );
		};
		
		// -------------------------- animation -------------------------- //
		
		Draggabilly.prototype.animate = function() {
		  // only render and animate if dragging
		  if ( !this.isDragging ) {
		    return;
		  }
		
		  this.positionDrag();
		
		  var _this = this;
		  requestAnimationFrame( function animateFrame() {
		    _this.animate();
		  });
		
		};
		
		// transform translate function
		var translate = is3d ?
		  function( x, y ) {
		    return 'translate3d( ' + x + 'px, ' + y + 'px, 0)';
		  } :
		  function( x, y ) {
		    return 'translate( ' + x + 'px, ' + y + 'px)';
		  };
		
		// left/top positioning
		Draggabilly.prototype.setLeftTop = function() {
		  this.element.style.left = this.position.x + 'px';
		  this.element.style.top  = this.position.y + 'px';
		};
		
		Draggabilly.prototype.positionDrag = transformProperty ?
		  function() {
		    // position with transform
		    this.element.style[ transformProperty ] = translate( this.dragPoint.x, this.dragPoint.y );
		  } : Draggabilly.prototype.setLeftTop;
		
		// ----- staticClick ----- //
		
		Draggabilly.prototype.staticClick = function( event, pointer ) {
		  this.dispatchEvent( 'staticClick', event, [ pointer ] );
		};
		
		// ----- methods ----- //
		
		Draggabilly.prototype.enable = function() {
		  this.isEnabled = true;
		};
		
		Draggabilly.prototype.disable = function() {
		  this.isEnabled = false;
		  if ( this.isDragging ) {
		    this.dragEnd();
		  }
		};
		
		Draggabilly.prototype.destroy = function() {
		  this.disable();
		  // reset styles
		  if ( transformProperty ) {
		    this.element.style[ transformProperty ] = '';
		  }
		  this.element.style.left = '';
		  this.element.style.top = '';
		  this.element.style.position = '';
		  // unbind handles
		  this.unbindHandles();
		  // remove jQuery data
		  if ( this.$element ) {
		    this.$element.removeData('draggabilly');
		  }
		};
		
		// ----- jQuery bridget ----- //
		
		// required for jQuery bridget
		Draggabilly.prototype._init = noop;
		
		if ( jQuery && jQuery.bridget ) {
		  jQuery.bridget( 'draggabilly', Draggabilly );
		}
		
		// -----  ----- //
		
		return Draggabilly;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 176 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * classie v1.0.1
		 * class helper functions
		 * from bonzo https://github.com/ded/bonzo
		 * MIT license
		 * 
		 * classie.has( elem, 'my-class' ) -> true/false
		 * classie.add( elem, 'my-new-class' )
		 * classie.remove( elem, 'my-unwanted-class' )
		 * classie.toggle( elem, 'my-class' )
		 */
		
		/*jshint browser: true, strict: true, undef: true, unused: true */
		/*global define: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		// class helper functions from bonzo https://github.com/ded/bonzo
		
		function classReg( className ) {
		  return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
		}
		
		// classList support for class management
		// altho to be fair, the api sucks because it won't accept multiple classes at once
		var hasClass, addClass, removeClass;
		
		if ( 'classList' in document.documentElement ) {
		  hasClass = function( elem, c ) {
		    return elem.classList.contains( c );
		  };
		  addClass = function( elem, c ) {
		    elem.classList.add( c );
		  };
		  removeClass = function( elem, c ) {
		    elem.classList.remove( c );
		  };
		}
		else {
		  hasClass = function( elem, c ) {
		    return classReg( c ).test( elem.className );
		  };
		  addClass = function( elem, c ) {
		    if ( !hasClass( elem, c ) ) {
		      elem.className = elem.className + ' ' + c;
		    }
		  };
		  removeClass = function( elem, c ) {
		    elem.className = elem.className.replace( classReg( c ), ' ' );
		  };
		}
		
		function toggleClass( elem, c ) {
		  var fn = hasClass( elem, c ) ? removeClass : addClass;
		  fn( elem, c );
		}
		
		var classie = {
		  // full names
		  hasClass: hasClass,
		  addClass: addClass,
		  removeClass: removeClass,
		  toggleClass: toggleClass,
		  // short names
		  has: hasClass,
		  add: addClass,
		  remove: removeClass,
		  toggle: toggleClass
		};
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD
		  define( classie );
		} else if ( true ) {
		  // CommonJS
		  module.exports = classie;
		} else {
		  // browser global
		  window.classie = classie;
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 177 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * getStyleProperty v1.0.4
		 * original by kangax
		 * http://perfectionkills.com/feature-testing-css-properties/
		 * MIT license
		 */
		
		/*jshint browser: true, strict: true, undef: true */
		/*global define: false, exports: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		var prefixes = 'Webkit Moz ms Ms O'.split(' ');
		var docElemStyle = document.documentElement.style;
		
		function getStyleProperty( propName ) {
		  if ( !propName ) {
		    return;
		  }
		
		  // test standard property first
		  if ( typeof docElemStyle[ propName ] === 'string' ) {
		    return propName;
		  }
		
		  // capitalize
		  propName = propName.charAt(0).toUpperCase() + propName.slice(1);
		
		  // test vendor specific properties
		  var prefixed;
		  for ( var i=0, len = prefixes.length; i < len; i++ ) {
		    prefixed = prefixes[i] + propName;
		    if ( typeof docElemStyle[ prefixed ] === 'string' ) {
		      return prefixed;
		    }
		  }
		}
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD
		  define( function() {
		    return getStyleProperty;
		  });
		} else if ( true ) {
		  // CommonJS for Component
		  module.exports = getStyleProperty;
		} else {
		  // browser global
		  window.getStyleProperty = getStyleProperty;
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 178 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * getSize v1.2.2
		 * measure size of elements
		 * MIT license
		 */
		
		/*jshint browser: true, strict: true, undef: true, unused: true */
		/*global define: false, exports: false, require: false, module: false, console: false */
		
		( function( window, undefined ) {
		
		'use strict';
		
		// -------------------------- helpers -------------------------- //
		
		// get a number from a string, not a percentage
		function getStyleSize( value ) {
		  var num = parseFloat( value );
		  // not a percent like '100%', and a number
		  var isValid = value.indexOf('%') === -1 && !isNaN( num );
		  return isValid && num;
		}
		
		function noop() {}
		
		var logError = typeof console === 'undefined' ? noop :
		  function( message ) {
		    console.error( message );
		  };
		
		// -------------------------- measurements -------------------------- //
		
		var measurements = [
		  'paddingLeft',
		  'paddingRight',
		  'paddingTop',
		  'paddingBottom',
		  'marginLeft',
		  'marginRight',
		  'marginTop',
		  'marginBottom',
		  'borderLeftWidth',
		  'borderRightWidth',
		  'borderTopWidth',
		  'borderBottomWidth'
		];
		
		function getZeroSize() {
		  var size = {
		    width: 0,
		    height: 0,
		    innerWidth: 0,
		    innerHeight: 0,
		    outerWidth: 0,
		    outerHeight: 0
		  };
		  for ( var i=0, len = measurements.length; i < len; i++ ) {
		    var measurement = measurements[i];
		    size[ measurement ] = 0;
		  }
		  return size;
		}
		
		
		
		function defineGetSize( getStyleProperty ) {
		
		// -------------------------- setup -------------------------- //
		
		var isSetup = false;
		
		var getStyle, boxSizingProp, isBoxSizeOuter;
		
		/**
		 * setup vars and functions
		 * do it on initial getSize(), rather than on script load
		 * For Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=548397
		 */
		function setup() {
		  // setup once
		  if ( isSetup ) {
		    return;
		  }
		  isSetup = true;
		
		  var getComputedStyle = window.getComputedStyle;
		  getStyle = ( function() {
		    var getStyleFn = getComputedStyle ?
		      function( elem ) {
		        return getComputedStyle( elem, null );
		      } :
		      function( elem ) {
		        return elem.currentStyle;
		      };
		
		      return function getStyle( elem ) {
		        var style = getStyleFn( elem );
		        if ( !style ) {
		          logError( 'Style returned ' + style +
		            '. Are you running this code in a hidden iframe on Firefox? ' +
		            'See http://bit.ly/getsizebug1' );
		        }
		        return style;
		      };
		  })();
		
		  // -------------------------- box sizing -------------------------- //
		
		  boxSizingProp = getStyleProperty('boxSizing');
		
		  /**
		   * WebKit measures the outer-width on style.width on border-box elems
		   * IE & Firefox measures the inner-width
		   */
		  if ( boxSizingProp ) {
		    var div = document.createElement('div');
		    div.style.width = '200px';
		    div.style.padding = '1px 2px 3px 4px';
		    div.style.borderStyle = 'solid';
		    div.style.borderWidth = '1px 2px 3px 4px';
		    div.style[ boxSizingProp ] = 'border-box';
		
		    var body = document.body || document.documentElement;
		    body.appendChild( div );
		    var style = getStyle( div );
		
		    isBoxSizeOuter = getStyleSize( style.width ) === 200;
		    body.removeChild( div );
		  }
		
		}
		
		// -------------------------- getSize -------------------------- //
		
		function getSize( elem ) {
		  setup();
		
		  // use querySeletor if elem is string
		  if ( typeof elem === 'string' ) {
		    elem = document.querySelector( elem );
		  }
		
		  // do not proceed on non-objects
		  if ( !elem || typeof elem !== 'object' || !elem.nodeType ) {
		    return;
		  }
		
		  var style = getStyle( elem );
		
		  // if hidden, everything is 0
		  if ( style.display === 'none' ) {
		    return getZeroSize();
		  }
		
		  var size = {};
		  size.width = elem.offsetWidth;
		  size.height = elem.offsetHeight;
		
		  var isBorderBox = size.isBorderBox = !!( boxSizingProp &&
		    style[ boxSizingProp ] && style[ boxSizingProp ] === 'border-box' );
		
		  // get all measurements
		  for ( var i=0, len = measurements.length; i < len; i++ ) {
		    var measurement = measurements[i];
		    var value = style[ measurement ];
		    value = mungeNonPixel( elem, value );
		    var num = parseFloat( value );
		    // any 'auto', 'medium' value will be 0
		    size[ measurement ] = !isNaN( num ) ? num : 0;
		  }
		
		  var paddingWidth = size.paddingLeft + size.paddingRight;
		  var paddingHeight = size.paddingTop + size.paddingBottom;
		  var marginWidth = size.marginLeft + size.marginRight;
		  var marginHeight = size.marginTop + size.marginBottom;
		  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
		  var borderHeight = size.borderTopWidth + size.borderBottomWidth;
		
		  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
		
		  // overwrite width and height if we can get it from style
		  var styleWidth = getStyleSize( style.width );
		  if ( styleWidth !== false ) {
		    size.width = styleWidth +
		      // add padding and border unless it's already including it
		      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
		  }
		
		  var styleHeight = getStyleSize( style.height );
		  if ( styleHeight !== false ) {
		    size.height = styleHeight +
		      // add padding and border unless it's already including it
		      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
		  }
		
		  size.innerWidth = size.width - ( paddingWidth + borderWidth );
		  size.innerHeight = size.height - ( paddingHeight + borderHeight );
		
		  size.outerWidth = size.width + marginWidth;
		  size.outerHeight = size.height + marginHeight;
		
		  return size;
		}
		
		// IE8 returns percent values, not pixels
		// taken from jQuery's curCSS
		function mungeNonPixel( elem, value ) {
		  // IE8 and has percent value
		  if ( window.getComputedStyle || value.indexOf('%') === -1 ) {
		    return value;
		  }
		  var style = elem.style;
		  // Remember the original values
		  var left = style.left;
		  var rs = elem.runtimeStyle;
		  var rsLeft = rs && rs.left;
		
		  // Put in the new values to get a computed value out
		  if ( rsLeft ) {
		    rs.left = elem.currentStyle.left;
		  }
		  style.left = value;
		  value = style.pixelLeft;
		
		  // Revert the changed values
		  style.left = left;
		  if ( rsLeft ) {
		    rs.left = rsLeft;
		  }
		
		  return value;
		}
		
		return getSize;
		
		}
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD for RequireJS
		  define( [ 'get-style-property/get-style-property' ], defineGetSize );
		} else if ( true ) {
		  // CommonJS for Component
		  module.exports = defineGetSize( __webpack_require__(177) );
		} else {
		  // browser global
		  window.getSize = defineGetSize( window.getStyleProperty );
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 179 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Unidragger v1.1.5
		 * Draggable base class
		 * MIT license
		 */
		
		/*jshint browser: true, unused: true, undef: true, strict: true */
		
		( function( window, factory ) {
		  /*global define: false, module: false, require: false */
		  'use strict';
		  // universal module definition
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		      'eventie/eventie',
		      'unipointer/unipointer'
		    ], function( eventie, Unipointer ) {
		      return factory( window, eventie, Unipointer );
		    });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(180),
		      __webpack_require__(181)
		    );
		  } else {
		    // browser global
		    window.Unidragger = factory(
		      window,
		      window.eventie,
		      window.Unipointer
		    );
		  }
		
		}( window, function factory( window, eventie, Unipointer ) {
		
		'use strict';
		
		// -----  ----- //
		
		function noop() {}
		
		// handle IE8 prevent default
		function preventDefaultEvent( event ) {
		  if ( event.preventDefault ) {
		    event.preventDefault();
		  } else {
		    event.returnValue = false;
		  }
		}
		
		// -------------------------- Unidragger -------------------------- //
		
		function Unidragger() {}
		
		// inherit Unipointer & EventEmitter
		Unidragger.prototype = new Unipointer();
		
		// ----- bind start ----- //
		
		Unidragger.prototype.bindHandles = function() {
		  this._bindHandles( true );
		};
		
		Unidragger.prototype.unbindHandles = function() {
		  this._bindHandles( false );
		};
		
		var navigator = window.navigator;
		/**
		 * works as unbinder, as you can .bindHandles( false ) to unbind
		 * @param {Boolean} isBind - will unbind if falsey
		 */
		Unidragger.prototype._bindHandles = function( isBind ) {
		  // munge isBind, default to true
		  isBind = isBind === undefined ? true : !!isBind;
		  // extra bind logic
		  var binderExtra;
		  if ( navigator.pointerEnabled ) {
		    binderExtra = function( handle ) {
		      // disable scrolling on the element
		      handle.style.touchAction = isBind ? 'none' : '';
		    };
		  } else if ( navigator.msPointerEnabled ) {
		    binderExtra = function( handle ) {
		      // disable scrolling on the element
		      handle.style.msTouchAction = isBind ? 'none' : '';
		    };
		  } else {
		    binderExtra = function() {
		      // TODO re-enable img.ondragstart when unbinding
		      if ( isBind ) {
		        disableImgOndragstart( handle );
		      }
		    };
		  }
		  // bind each handle
		  var bindMethod = isBind ? 'bind' : 'unbind';
		  for ( var i=0, len = this.handles.length; i < len; i++ ) {
		    var handle = this.handles[i];
		    this._bindStartEvent( handle, isBind );
		    binderExtra( handle );
		    eventie[ bindMethod ]( handle, 'click', this );
		  }
		};
		
		// remove default dragging interaction on all images in IE8
		// IE8 does its own drag thing on images, which messes stuff up
		
		function noDragStart() {
		  return false;
		}
		
		// TODO replace this with a IE8 test
		var isIE8 = 'attachEvent' in document.documentElement;
		
		// IE8 only
		var disableImgOndragstart = !isIE8 ? noop : function( handle ) {
		
		  if ( handle.nodeName == 'IMG' ) {
		    handle.ondragstart = noDragStart;
		  }
		
		  var images = handle.querySelectorAll('img');
		  for ( var i=0, len = images.length; i < len; i++ ) {
		    var img = images[i];
		    img.ondragstart = noDragStart;
		  }
		};
		
		// ----- start event ----- //
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerDown = function( event, pointer ) {
		  // dismiss range sliders
		  if ( event.target.nodeName == 'INPUT' && event.target.type == 'range' ) {
		    // reset pointerDown logic
		    this.isPointerDown = false;
		    delete this.pointerIdentifier;
		    return;
		  }
		
		  this._dragPointerDown( event, pointer );
		  // kludge to blur focused inputs in dragger
		  var focused = document.activeElement;
		  if ( focused && focused.blur ) {
		    focused.blur();
		  }
		  // bind move and end events
		  this._bindPostStartEvents( event );
		  // track scrolling
		  this.pointerDownScroll = Unidragger.getScrollPosition();
		  eventie.bind( window, 'scroll', this );
		
		  this.emitEvent( 'pointerDown', [ event, pointer ] );
		};
		
		// base pointer down logic
		Unidragger.prototype._dragPointerDown = function( event, pointer ) {
		  // track to see when dragging starts
		  this.pointerDownPoint = Unipointer.getPointerPoint( pointer );
		
		  // prevent default, unless touchstart or <select>
		  var isTouchstart = event.type == 'touchstart';
		  var targetNodeName = event.target.nodeName;
		  if ( !isTouchstart && targetNodeName != 'SELECT' ) {
		    preventDefaultEvent( event );
		  }
		};
		
		// ----- move event ----- //
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerMove = function( event, pointer ) {
		  var moveVector = this._dragPointerMove( event, pointer );
		  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
		  this._dragMove( event, pointer, moveVector );
		};
		
		// base pointer move logic
		Unidragger.prototype._dragPointerMove = function( event, pointer ) {
		  var movePoint = Unipointer.getPointerPoint( pointer );
		  var moveVector = {
		    x: movePoint.x - this.pointerDownPoint.x,
		    y: movePoint.y - this.pointerDownPoint.y
		  };
		  // start drag if pointer has moved far enough to start drag
		  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {
		    this._dragStart( event, pointer );
		  }
		  return moveVector;
		};
		
		// condition if pointer has moved far enough to start drag
		Unidragger.prototype.hasDragStarted = function( moveVector ) {
		  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;
		};
		
		
		// ----- end event ----- //
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerUp = function( event, pointer ) {
		  this.emitEvent( 'pointerUp', [ event, pointer ] );
		  this._dragPointerUp( event, pointer );
		};
		
		Unidragger.prototype._dragPointerUp = function( event, pointer ) {
		  if ( this.isDragging ) {
		    this._dragEnd( event, pointer );
		  } else {
		    // pointer didn't move enough for drag to start
		    this._staticClick( event, pointer );
		  }
		};
		
		Unipointer.prototype.pointerDone = function() {
		  eventie.unbind( window, 'scroll', this );
		};
		
		// -------------------------- drag -------------------------- //
		
		// dragStart
		Unidragger.prototype._dragStart = function( event, pointer ) {
		  this.isDragging = true;
		  this.dragStartPoint = Unidragger.getPointerPoint( pointer );
		  // prevent clicks
		  this.isPreventingClicks = true;
		
		  this.dragStart( event, pointer );
		};
		
		Unidragger.prototype.dragStart = function( event, pointer ) {
		  this.emitEvent( 'dragStart', [ event, pointer ] );
		};
		
		// dragMove
		Unidragger.prototype._dragMove = function( event, pointer, moveVector ) {
		  // do not drag if not dragging yet
		  if ( !this.isDragging ) {
		    return;
		  }
		
		  this.dragMove( event, pointer, moveVector );
		};
		
		Unidragger.prototype.dragMove = function( event, pointer, moveVector ) {
		  preventDefaultEvent( event );
		  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
		};
		
		// dragEnd
		Unidragger.prototype._dragEnd = function( event, pointer ) {
		  // set flags
		  this.isDragging = false;
		  // re-enable clicking async
		  var _this = this;
		  setTimeout( function() {
		    delete _this.isPreventingClicks;
		  });
		
		  this.dragEnd( event, pointer );
		};
		
		Unidragger.prototype.dragEnd = function( event, pointer ) {
		  this.emitEvent( 'dragEnd', [ event, pointer ] );
		};
		
		Unidragger.prototype.pointerDone = function() {
		  eventie.unbind( window, 'scroll', this );
		  delete this.pointerDownScroll;
		};
		
		// ----- onclick ----- //
		
		// handle all clicks and prevent clicks when dragging
		Unidragger.prototype.onclick = function( event ) {
		  if ( this.isPreventingClicks ) {
		    preventDefaultEvent( event );
		  }
		};
		
		// ----- staticClick ----- //
		
		// triggered after pointer down & up with no/tiny movement
		Unidragger.prototype._staticClick = function( event, pointer ) {
		  // ignore emulated mouse up clicks
		  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {
		    return;
		  }
		
		  // allow click in <input>s and <textarea>s
		  var nodeName = event.target.nodeName;
		  if ( nodeName == 'INPUT' || nodeName == 'TEXTAREA' ) {
		    event.target.focus();
		  }
		  this.staticClick( event, pointer );
		
		  // set flag for emulated clicks 300ms after touchend
		  if ( event.type != 'mouseup' ) {
		    this.isIgnoringMouseUp = true;
		    var _this = this;
		    // reset flag after 300ms
		    setTimeout( function() {
		      delete _this.isIgnoringMouseUp;
		    }, 400 );
		  }
		};
		
		Unidragger.prototype.staticClick = function( event, pointer ) {
		  this.emitEvent( 'staticClick', [ event, pointer ] );
		};
		
		// ----- scroll ----- //
		
		Unidragger.prototype.onscroll = function() {
		  var scroll = Unidragger.getScrollPosition();
		  var scrollMoveX = this.pointerDownScroll.x - scroll.x;
		  var scrollMoveY = this.pointerDownScroll.y - scroll.y;
		  // cancel click/tap if scroll is too much
		  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {
		    this._pointerDone();
		  }
		};
		
		// ----- utils ----- //
		
		Unidragger.getPointerPoint = function( pointer ) {
		  return {
		    x: pointer.pageX !== undefined ? pointer.pageX : pointer.clientX,
		    y: pointer.pageY !== undefined ? pointer.pageY : pointer.clientY
		  };
		};
		
		var isPageOffset = window.pageYOffset !== undefined;
		
		// get scroll in { x, y }
		Unidragger.getScrollPosition = function() {
		  return {
		    x: isPageOffset ? window.pageXOffset : document.body.scrollLeft,
		    y: isPageOffset ? window.pageYOffset : document.body.scrollTop
		  };
		};
		
		// -----  ----- //
		
		Unidragger.getPointerPoint = Unipointer.getPointerPoint;
		
		return Unidragger;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 180 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		 * eventie v1.0.6
		 * event binding helper
		 *   eventie.bind( elem, 'click', myFn )
		 *   eventie.unbind( elem, 'click', myFn )
		 * MIT license
		 */
		
		/*jshint browser: true, undef: true, unused: true */
		/*global define: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		var docElem = document.documentElement;
		
		var bind = function() {};
		
		function getIEEvent( obj ) {
		  var event = window.event;
		  // add event.target
		  event.target = event.target || event.srcElement || obj;
		  return event;
		}
		
		if ( docElem.addEventListener ) {
		  bind = function( obj, type, fn ) {
		    obj.addEventListener( type, fn, false );
		  };
		} else if ( docElem.attachEvent ) {
		  bind = function( obj, type, fn ) {
		    obj[ type + fn ] = fn.handleEvent ?
		      function() {
		        var event = getIEEvent( obj );
		        fn.handleEvent.call( fn, event );
		      } :
		      function() {
		        var event = getIEEvent( obj );
		        fn.call( obj, event );
		      };
		    obj.attachEvent( "on" + type, obj[ type + fn ] );
		  };
		}
		
		var unbind = function() {};
		
		if ( docElem.removeEventListener ) {
		  unbind = function( obj, type, fn ) {
		    obj.removeEventListener( type, fn, false );
		  };
		} else if ( docElem.detachEvent ) {
		  unbind = function( obj, type, fn ) {
		    obj.detachEvent( "on" + type, obj[ type + fn ] );
		    try {
		      delete obj[ type + fn ];
		    } catch ( err ) {
		      // can't delete window object properties
		      obj[ type + fn ] = undefined;
		    }
		  };
		}
		
		var eventie = {
		  bind: bind,
		  unbind: unbind
		};
		
		// ----- module definition ----- //
		
		if ( true ) {
		  // AMD
		  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (eventie), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if ( typeof exports === 'object' ) {
		  // CommonJS
		  module.exports = eventie;
		} else {
		  // browser global
		  window.eventie = eventie;
		}
		
		})( window );
	
	
	/***/ },
	/* 181 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Unipointer v1.1.0
		 * base class for doing one thing with pointer event
		 * MIT license
		 */
		
		/*jshint browser: true, undef: true, unused: true, strict: true */
		/*global define: false, module: false, require: false */
		
		( function( window, factory ) {
		  'use strict';
		  // universal module definition
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		      'eventEmitter/EventEmitter',
		      'eventie/eventie'
		    ], function( EventEmitter, eventie ) {
		      return factory( window, EventEmitter, eventie );
		    });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(182),
		      __webpack_require__(180)
		    );
		  } else {
		    // browser global
		    window.Unipointer = factory(
		      window,
		      window.EventEmitter,
		      window.eventie
		    );
		  }
		
		}( window, function factory( window, EventEmitter, eventie ) {
		
		'use strict';
		
		function noop() {}
		
		function Unipointer() {}
		
		// inherit EventEmitter
		Unipointer.prototype = new EventEmitter();
		
		Unipointer.prototype.bindStartEvent = function( elem ) {
		  this._bindStartEvent( elem, true );
		};
		
		Unipointer.prototype.unbindStartEvent = function( elem ) {
		  this._bindStartEvent( elem, false );
		};
		
		/**
		 * works as unbinder, as you can ._bindStart( false ) to unbind
		 * @param {Boolean} isBind - will unbind if falsey
		 */
		Unipointer.prototype._bindStartEvent = function( elem, isBind ) {
		  // munge isBind, default to true
		  isBind = isBind === undefined ? true : !!isBind;
		  var bindMethod = isBind ? 'bind' : 'unbind';
		
		  if ( window.navigator.pointerEnabled ) {
		    // W3C Pointer Events, IE11. See https://coderwall.com/p/mfreca
		    eventie[ bindMethod ]( elem, 'pointerdown', this );
		  } else if ( window.navigator.msPointerEnabled ) {
		    // IE10 Pointer Events
		    eventie[ bindMethod ]( elem, 'MSPointerDown', this );
		  } else {
		    // listen for both, for devices like Chrome Pixel
		    eventie[ bindMethod ]( elem, 'mousedown', this );
		    eventie[ bindMethod ]( elem, 'touchstart', this );
		  }
		};
		
		// trigger handler methods for events
		Unipointer.prototype.handleEvent = function( event ) {
		  var method = 'on' + event.type;
		  if ( this[ method ] ) {
		    this[ method ]( event );
		  }
		};
		
		// returns the touch that we're keeping track of
		Unipointer.prototype.getTouch = function( touches ) {
		  for ( var i=0, len = touches.length; i < len; i++ ) {
		    var touch = touches[i];
		    if ( touch.identifier == this.pointerIdentifier ) {
		      return touch;
		    }
		  }
		};
		
		// ----- start event ----- //
		
		Unipointer.prototype.onmousedown = function( event ) {
		  // dismiss clicks from right or middle buttons
		  var button = event.button;
		  if ( button && ( button !== 0 && button !== 1 ) ) {
		    return;
		  }
		  this._pointerDown( event, event );
		};
		
		Unipointer.prototype.ontouchstart = function( event ) {
		  this._pointerDown( event, event.changedTouches[0] );
		};
		
		Unipointer.prototype.onMSPointerDown =
		Unipointer.prototype.onpointerdown = function( event ) {
		  this._pointerDown( event, event );
		};
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unipointer.prototype._pointerDown = function( event, pointer ) {
		  // dismiss other pointers
		  if ( this.isPointerDown ) {
		    return;
		  }
		
		  this.isPointerDown = true;
		  // save pointer identifier to match up touch events
		  this.pointerIdentifier = pointer.pointerId !== undefined ?
		    // pointerId for pointer events, touch.indentifier for touch events
		    pointer.pointerId : pointer.identifier;
		
		  this.pointerDown( event, pointer );
		};
		
		Unipointer.prototype.pointerDown = function( event, pointer ) {
		  this._bindPostStartEvents( event );
		  this.emitEvent( 'pointerDown', [ event, pointer ] );
		};
		
		// hash of events to be bound after start event
		var postStartEvents = {
		  mousedown: [ 'mousemove', 'mouseup' ],
		  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],
		  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],
		  MSPointerDown: [ 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel' ]
		};
		
		Unipointer.prototype._bindPostStartEvents = function( event ) {
		  if ( !event ) {
		    return;
		  }
		  // get proper events to match start event
		  var events = postStartEvents[ event.type ];
		  // IE8 needs to be bound to document
		  var node = event.preventDefault ? window : document;
		  // bind events to node
		  for ( var i=0, len = events.length; i < len; i++ ) {
		    var evnt = events[i];
		    eventie.bind( node, evnt, this );
		  }
		  // save these arguments
		  this._boundPointerEvents = {
		    events: events,
		    node: node
		  };
		};
		
		Unipointer.prototype._unbindPostStartEvents = function() {
		  var args = this._boundPointerEvents;
		  // IE8 can trigger dragEnd twice, check for _boundEvents
		  if ( !args || !args.events ) {
		    return;
		  }
		
		  for ( var i=0, len = args.events.length; i < len; i++ ) {
		    var event = args.events[i];
		    eventie.unbind( args.node, event, this );
		  }
		  delete this._boundPointerEvents;
		};
		
		// ----- move event ----- //
		
		Unipointer.prototype.onmousemove = function( event ) {
		  this._pointerMove( event, event );
		};
		
		Unipointer.prototype.onMSPointerMove =
		Unipointer.prototype.onpointermove = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerMove( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchmove = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerMove( event, touch );
		  }
		};
		
		/**
		 * pointer move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerMove = function( event, pointer ) {
		  this.pointerMove( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerMove = function( event, pointer ) {
		  this.emitEvent( 'pointerMove', [ event, pointer ] );
		};
		
		// ----- end event ----- //
		
		
		Unipointer.prototype.onmouseup = function( event ) {
		  this._pointerUp( event, event );
		};
		
		Unipointer.prototype.onMSPointerUp =
		Unipointer.prototype.onpointerup = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerUp( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchend = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerUp( event, touch );
		  }
		};
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerUp = function( event, pointer ) {
		  this._pointerDone();
		  this.pointerUp( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerUp = function( event, pointer ) {
		  this.emitEvent( 'pointerUp', [ event, pointer ] );
		};
		
		// ----- pointer done ----- //
		
		// triggered on pointer up & pointer cancel
		Unipointer.prototype._pointerDone = function() {
		  // reset properties
		  this.isPointerDown = false;
		  delete this.pointerIdentifier;
		  // remove events
		  this._unbindPostStartEvents();
		  this.pointerDone();
		};
		
		Unipointer.prototype.pointerDone = noop;
		
		// ----- pointer cancel ----- //
		
		Unipointer.prototype.onMSPointerCancel =
		Unipointer.prototype.onpointercancel = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerCancel( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchcancel = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerCancel( event, touch );
		  }
		};
		
		/**
		 * pointer cancel
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerCancel = function( event, pointer ) {
		  this._pointerDone();
		  this.pointerCancel( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerCancel = function( event, pointer ) {
		  this.emitEvent( 'pointerCancel', [ event, pointer ] );
		};
		
		// -----  ----- //
		
		// utility function for getting x/y cooridinates from event, because IE8
		Unipointer.getPointerPoint = function( pointer ) {
		  return {
		    x: pointer.pageX !== undefined ? pointer.pageX : pointer.clientX,
		    y: pointer.pageY !== undefined ? pointer.pageY : pointer.clientY
		  };
		};
		
		// -----  ----- //
		
		return Unipointer;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 182 */
	/***/ function(module, exports) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * EventEmitter v4.2.11 - git.io/ee
		 * Unlicense - http://unlicense.org/
		 * Oliver Caldwell - http://oli.me.uk/
		 * @preserve
		 */
		
		;(function () {
		    'use strict';
		
		    /**
		     * Class for managing events.
		     * Can be extended to provide event functionality in other classes.
		     *
		     * @class EventEmitter Manages event registering and emitting.
		     */
		    function EventEmitter() {}
		
		    // Shortcuts to improve speed and size
		    var proto = EventEmitter.prototype;
		    var exports = this;
		    var originalGlobalValue = exports.EventEmitter;
		
		    /**
		     * Finds the index of the listener for the event in its storage array.
		     *
		     * @param {Function[]} listeners Array of listeners to search through.
		     * @param {Function} listener Method to look for.
		     * @return {Number} Index of the specified listener, -1 if not found
		     * @api private
		     */
		    function indexOfListener(listeners, listener) {
		        var i = listeners.length;
		        while (i--) {
		            if (listeners[i].listener === listener) {
		                return i;
		            }
		        }
		
		        return -1;
		    }
		
		    /**
		     * Alias a method while keeping the context correct, to allow for overwriting of target method.
		     *
		     * @param {String} name The name of the target method.
		     * @return {Function} The aliased method
		     * @api private
		     */
		    function alias(name) {
		        return function aliasClosure() {
		            return this[name].apply(this, arguments);
		        };
		    }
		
		    /**
		     * Returns the listener array for the specified event.
		     * Will initialise the event object and listener arrays if required.
		     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
		     * Each property in the object response is an array of listener functions.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Function[]|Object} All listener functions for the event.
		     */
		    proto.getListeners = function getListeners(evt) {
		        var events = this._getEvents();
		        var response;
		        var key;
		
		        // Return a concatenated array of all matching events if
		        // the selector is a regular expression.
		        if (evt instanceof RegExp) {
		            response = {};
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    response[key] = events[key];
		                }
		            }
		        }
		        else {
		            response = events[evt] || (events[evt] = []);
		        }
		
		        return response;
		    };
		
		    /**
		     * Takes a list of listener objects and flattens it into a list of listener functions.
		     *
		     * @param {Object[]} listeners Raw listener objects.
		     * @return {Function[]} Just the listener functions.
		     */
		    proto.flattenListeners = function flattenListeners(listeners) {
		        var flatListeners = [];
		        var i;
		
		        for (i = 0; i < listeners.length; i += 1) {
		            flatListeners.push(listeners[i].listener);
		        }
		
		        return flatListeners;
		    };
		
		    /**
		     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Object} All listener functions for an event in an object.
		     */
		    proto.getListenersAsObject = function getListenersAsObject(evt) {
		        var listeners = this.getListeners(evt);
		        var response;
		
		        if (listeners instanceof Array) {
		            response = {};
		            response[evt] = listeners;
		        }
		
		        return response || listeners;
		    };
		
		    /**
		     * Adds a listener function to the specified event.
		     * The listener will not be added if it is a duplicate.
		     * If the listener returns true then it will be removed after it is called.
		     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListener = function addListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var listenerIsWrapped = typeof listener === 'object';
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
		                listeners[key].push(listenerIsWrapped ? listener : {
		                    listener: listener,
		                    once: false
		                });
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of addListener
		     */
		    proto.on = alias('addListener');
		
		    /**
		     * Semi-alias of addListener. It will add a listener that will be
		     * automatically removed after its first execution.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addOnceListener = function addOnceListener(evt, listener) {
		        return this.addListener(evt, {
		            listener: listener,
		            once: true
		        });
		    };
		
		    /**
		     * Alias of addOnceListener.
		     */
		    proto.once = alias('addOnceListener');
		
		    /**
		     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
		     * You need to tell it what event names should be matched by a regex.
		     *
		     * @param {String} evt Name of the event to create.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvent = function defineEvent(evt) {
		        this.getListeners(evt);
		        return this;
		    };
		
		    /**
		     * Uses defineEvent to define multiple events.
		     *
		     * @param {String[]} evts An array of event names to define.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvents = function defineEvents(evts) {
		        for (var i = 0; i < evts.length; i += 1) {
		            this.defineEvent(evts[i]);
		        }
		        return this;
		    };
		
		    /**
		     * Removes a listener function from the specified event.
		     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to remove the listener from.
		     * @param {Function} listener Method to remove from the event.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListener = function removeListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var index;
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                index = indexOfListener(listeners[key], listener);
		
		                if (index !== -1) {
		                    listeners[key].splice(index, 1);
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeListener
		     */
		    proto.off = alias('removeListener');
		
		    /**
		     * Adds listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
		     * You can also pass it a regular expression to add the array of listeners to all events that match it.
		     * Yeah, this function does quite a bit. That's probably a bad thing.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListeners = function addListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(false, evt, listeners);
		    };
		
		    /**
		     * Removes listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be removed.
		     * You can also pass it a regular expression to remove the listeners from all events that match it.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListeners = function removeListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(true, evt, listeners);
		    };
		
		    /**
		     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
		     * The first argument will determine if the listeners are removed (true) or added (false).
		     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be added/removed.
		     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
		     *
		     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		        var i;
		        var value;
		        var single = remove ? this.removeListener : this.addListener;
		        var multiple = remove ? this.removeListeners : this.addListeners;
		
		        // If evt is an object then pass each of its properties to this method
		        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
		            for (i in evt) {
		                if (evt.hasOwnProperty(i) && (value = evt[i])) {
		                    // Pass the single listener straight through to the singular method
		                    if (typeof value === 'function') {
		                        single.call(this, i, value);
		                    }
		                    else {
		                        // Otherwise pass back to the multiple function
		                        multiple.call(this, i, value);
		                    }
		                }
		            }
		        }
		        else {
		            // So evt must be a string
		            // And listeners must be an array of listeners
		            // Loop over it and pass each one to the multiple method
		            i = listeners.length;
		            while (i--) {
		                single.call(this, evt, listeners[i]);
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Removes all listeners from a specified event.
		     * If you do not specify an event then all listeners will be removed.
		     * That means every event will be emptied.
		     * You can also pass a regex to remove all events that match it.
		     *
		     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeEvent = function removeEvent(evt) {
		        var type = typeof evt;
		        var events = this._getEvents();
		        var key;
		
		        // Remove different things depending on the state of evt
		        if (type === 'string') {
		            // Remove all listeners for the specified event
		            delete events[evt];
		        }
		        else if (evt instanceof RegExp) {
		            // Remove all events matching the regex.
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    delete events[key];
		                }
		            }
		        }
		        else {
		            // Remove all listeners in all events
		            delete this._events;
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeEvent.
		     *
		     * Added to mirror the node API.
		     */
		    proto.removeAllListeners = alias('removeEvent');
		
		    /**
		     * Emits an event of your choice.
		     * When emitted, every listener attached to that event will be executed.
		     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
		     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
		     * So they will not arrive within the array on the other side, they will be separate.
		     * You can also pass a regular expression to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {Array} [args] Optional array of arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emitEvent = function emitEvent(evt, args) {
		        var listeners = this.getListenersAsObject(evt);
		        var listener;
		        var i;
		        var key;
		        var response;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                i = listeners[key].length;
		
		                while (i--) {
		                    // If the listener returns true then it shall be removed from the event
		                    // The function is executed either with a basic call or an apply if there is an args array
		                    listener = listeners[key][i];
		
		                    if (listener.once === true) {
		                        this.removeListener(evt, listener.listener);
		                    }
		
		                    response = listener.listener.apply(this, args || []);
		
		                    if (response === this._getOnceReturnValue()) {
		                        this.removeListener(evt, listener.listener);
		                    }
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of emitEvent
		     */
		    proto.trigger = alias('emitEvent');
		
		    /**
		     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
		     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {...*} Optional additional arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emit = function emit(evt) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return this.emitEvent(evt, args);
		    };
		
		    /**
		     * Sets the current value to check against when executing listeners. If a
		     * listeners return value matches the one set here then it will be removed
		     * after execution. This value defaults to true.
		     *
		     * @param {*} value The new value to check for when executing listeners.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.setOnceReturnValue = function setOnceReturnValue(value) {
		        this._onceReturnValue = value;
		        return this;
		    };
		
		    /**
		     * Fetches the current value to check against when executing listeners. If
		     * the listeners return value matches this one then it should be removed
		     * automatically. It will return true by default.
		     *
		     * @return {*|Boolean} The current value to check for or the default, true.
		     * @api private
		     */
		    proto._getOnceReturnValue = function _getOnceReturnValue() {
		        if (this.hasOwnProperty('_onceReturnValue')) {
		            return this._onceReturnValue;
		        }
		        else {
		            return true;
		        }
		    };
		
		    /**
		     * Fetches the events object and creates one if required.
		     *
		     * @return {Object} The events storage object.
		     * @api private
		     */
		    proto._getEvents = function _getEvents() {
		        return this._events || (this._events = {});
		    };
		
		    /**
		     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
		     *
		     * @return {Function} Non conflicting EventEmitter class.
		     */
		    EventEmitter.noConflict = function noConflict() {
		        exports.EventEmitter = originalGlobalValue;
		        return EventEmitter;
		    };
		
		    // Expose the class either via AMD, CommonJS or the global object
		    if (typeof define === 'function' && define.amd) {
		        define(function () {
		            return EventEmitter;
		        });
		    }
		    else if (typeof module === 'object' && module.exports){
		        module.exports = EventEmitter;
		    }
		    else {
		        exports.EventEmitter = EventEmitter;
		    }
		}.call(this));
		
		}.call(window));
	
	/***/ },
	/* 183 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-slider\" :id=\"id\"\n    :class=\"{\n        min: value === 0, max: value === 100, dragging: dragging, disabled: disabled,\n        active: active, 'has-label': hasLabel\n    }\"\n\n    :tabindex=\"disabled ? null : 0\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"100\"\n    :aria-valuenow=\"value\"\n\n    @keydown.left.prevent=\"decrement\" @keydown.right.prevent=\"increment\"\n    @keydown.down.prevent=\"decrement\" @keydown.up.prevent=\"increment\"\n    @focus=\"focus\" @blur=\"blur\"\n>\n    <input type=\"hidden\" :value=\"value\" :name=\"name\">\n\n    <div class=\"ui-slider-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-slider-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-slider-content\">\n        <div class=\"ui-slider-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n        <div class=\"ui-slider-wrapper\" v-el:slider @mousedown=\"sliderClick\">\n            <div class=\"ui-slider-containment\" v-el:containment></div>\n\n            <div class=\"ui-slider-track\">\n                <div class=\"ui-slider-track-fill\" :style=\"{ width: value + '%'}\"></div>\n            </div>\n\n            <div class=\"ui-slider-thumb-container\" v-el:thumb>\n                <div class=\"ui-slider-focus-ring\"></div>\n                <div class=\"ui-slider-thumb\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 184 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(185)
		__vue_script__ = __webpack_require__(186)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSnackbar.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(187)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSnackbar.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 185 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 186 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-snackbar',
		
		    props: {
		        id: String,
		        show: {
		            type: Boolean,
		            default: false,
		            twoWay: true
		        },
		        message: String,
		        action: String,
		        actionColor: {
		            type: String,
		            default: 'accent' },
		        persistent: {
		            type: Boolean,
		            default: false
		        },
		        duration: {
		            type: Number,
		            default: 5000
		        },
		        autoHide: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    data: function data() {
		        return {
		            height: 0,
		            timeout: null
		        };
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.timeout) {
		            clearTimeout(this.timeout);
		        }
		    },
		
		
		    methods: {
		        click: function click() {
		            this.$dispatch('clicked');
		            this.hide();
		        },
		        actionClick: function actionClick() {
		            this.$dispatch('action-clicked');
		            this.hide();
		        },
		        hide: function hide() {
		            if (!this.persistent) {
		                this.show = false;
		            }
		        }
		    },
		
		    components: {
		        UiButton: _UiButton2.default
		    },
		
		    transitions: {
		        'ui-snackbar-toggle': {
		            afterEnter: function afterEnter() {
		                this.$dispatch('shown');
		
		                if (this.autoHide) {
		                    this.timeout = setTimeout(this.hide, this.duration);
		                }
		            },
		            afterLeave: function afterLeave() {
		                this.$dispatch('hidden');
		
		                if (this.timeout) {
		                    clearTimeout(this.timeout);
		                    this.timeout = null;
		                }
		            }
		        }
		    }
		};
	
	/***/ },
	/* 187 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-snackbar\" :id=\"id\" transition=\"ui-snackbar-toggle\" @click=\"click\" v-show=\"show\"\n>\n    <div class=\"ui-snackbar-text\">\n        <slot>\n            <span v-text=\"message\"></span>\n        </slot>\n    </div>\n\n    <div class=\"ui-snackbar-action\">\n        <ui-button\n            class=\"ui-snackbar-action-button\" type=\"flat\" :color=\"actionColor\"\n            :text=\"action\" @click.stop=\"actionClick\" v-if=\"action\"\n        ></ui-button>\n    </div>\n</div>\n";
	
	/***/ },
	/* 188 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(189)
		__vue_script__ = __webpack_require__(190)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSnackbarContainer.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(191)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSnackbarContainer.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 189 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 190 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _UiSnackbar = __webpack_require__(184);
		
		var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-snackbar-container',
		
		    props: {
		        queueSnackbars: {
		            type: Boolean,
		            default: false
		        },
		        defaultDuration: {
		            type: Number,
		            default: 5000
		        },
		        position: {
		            type: String,
		            default: 'left', coerce: function coerce(position) {
		                return 'position-' + position;
		            }
		        }
		    },
		
		    events: {
		        'ui-snackbar::create': function uiSnackbarCreate(snackbar) {
		            snackbar.show = false;
		            snackbar.id = snackbar.id || _uuid2.default.short('ui-snackbar-');
		            snackbar.duration = snackbar.duration || this.defaultDuration;
		
		            this.queue.push(snackbar);
		
		            if (this.queue.length === 1) {
		                this.showNext();
		            } else {
		                if (!this.queueSnackbars) {
		                    this.queue[0].show = false;
		                }
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            queue: [] };
		    },
		
		
		    methods: {
		        showNext: function showNext() {
		            if (!this.queue.length) {
		                return;
		            }
		
		            this.queue[0].show = true;
		        },
		        shown: function shown(snackbar) {
		            this.$dispatch('snackbar-shown', snackbar);
		            this.callHook('onShow', snackbar);
		        },
		        hidden: function hidden(snackbar) {
		            this.$dispatch('snackbar-hidden', snackbar);
		            this.callHook('onHide', snackbar);
		
		            this.queue.$remove(snackbar);
		            this.showNext();
		        },
		        clicked: function clicked(snackbar) {
		            this.callHook('onClick', snackbar);
		        },
		        actionClicked: function actionClicked(snackbar) {
		            this.callHook('onActionClick', snackbar);
		        },
		        callHook: function callHook(hook, snackbar) {
		            if (typeof snackbar[hook] === 'function') {
		                snackbar[hook].call(undefined, snackbar);
		            }
		        }
		    },
		
		    components: {
		        UiSnackbar: _UiSnackbar2.default
		    }
		};
	
	/***/ },
	/* 191 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-snackbar-container\" :class=\"[position]\">\n    <ui-snackbar\n        :duration=\"s.duration\" :show.sync=\"s.show\" :action=\"s.action\"\n        :action-color=\"s.actionColor\" :persistent=\"s.persistent\" :id=\"s.id\" auto-hide\n\n        @shown=\"shown(s)\" @hidden=\"hidden(s)\" @clicked=\"clicked(s)\"\n        @action-clicked=\"actionClicked(s)\"\n\n        v-for=\"s in queue\"\n    >\n        <div v-html=\"s.message\" v-if=\"s.allowHtml\"></div>\n        <span v-text=\"s.message\" v-else></span>\n    </ui-snackbar>\n</div>\n";
	
	/***/ },
	/* 192 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(193)
		__vue_script__ = __webpack_require__(194)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSwitch.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(195)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSwitch.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 193 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 194 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-switch',
		
		    props: {
		        name: String,
		        value: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            initialValue: false
		        };
		    },
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 195 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-switch\"\n    :class=\"{ 'checked': value, 'disabled': disabled, 'label-left': labelLeft }\"\n>\n    <div class=\"ui-switch-container\">\n        <input\n            class=\"ui-switch-input\" type=\"checkbox\" :name=\"name\" :id=\"id\" v-model=\"value\"\n            v-disabled=\"disabled\"\n        >\n\n        <div class=\"ui-switch-track\"></div>\n        <div class=\"ui-switch-thumb\"></div>\n\n        <div class=\"ui-switch-focus-ring\"></div>\n    </div>\n\n    <div class=\"ui-switch-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 196 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(197)
		__vue_script__ = __webpack_require__(198)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTab.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(199)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTab.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 197 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 198 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-tab',
		
		    props: {
		        id: String,
		        header: String,
		        icon: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        active: function active() {
		            return this.$parent.activeTab === this.id;
		        }
		    },
		
		    watch: {
		        active: function active() {
		            if (this.active) {
		                this.$dispatch('selected', this.id);
		            } else {
		                this.$dispatch('deselected', this.id);
		            }
		        }
		    }
		};
	
	/***/ },
	/* 199 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-tab\" :id=\"id\" role=\"tabpanel\" :tabindex=\"active ? '0' : null\"\n    :aria-hidden=\"!active ? 'true' : null\" v-show=\"active\"\n>\n    <slot></slot>\n</div>\n";
	
	/***/ },
	/* 200 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(201)
		__vue_script__ = __webpack_require__(202)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTabs.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(207)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTabs.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 201 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 202 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _UiTabHeaderItem = __webpack_require__(203);
		
		var _UiTabHeaderItem2 = _interopRequireDefault(_UiTabHeaderItem);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tabs',
		
		    props: {
		        type: {
		            type: String,
		            default: 'text' },
		        activeTab: String,
		        backgroundColor: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'background-color-' + color;
		            }
		        },
		        textColor: {
		            type: String,
		            default: 'black', coerce: function coerce(color) {
		                return 'text-color-' + color;
		            }
		        },
		        textColorActive: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'text-color-active-' + color;
		            }
		        },
		        indicatorColor: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        fullwidth: {
		            type: Boolean,
		            default: false
		        },
		        raised: {
		            type: Boolean,
		            default: false
		        },
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            activeTabElement: null
		        };
		    },
		
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = ['ui-tabs-type-' + this.type];
		
		            if (this.raised) {
		                classes.push('raised');
		            }
		
		            if (this.fullwidth) {
		                classes.push('fullwidth');
		            }
		
		            return classes;
		        },
		        indicatorLeft: function indicatorLeft() {
		            if (this.activeTabElement) {
		                return this.activeTabElement.offsetLeft + 'px';
		            }
		
		            return 0;
		        },
		        indicatorRight: function indicatorRight() {
		            if (this.activeTabElement) {
		                var left = this.activeTabElement.offsetLeft;
		                var width = this.activeTabElement.offsetWidth;
		                var tabContainerWidth = this.$els.tabsContainer.offsetWidth;
		
		                return tabContainerWidth - (left + width) + 'px';
		            }
		        }
		    },
		
		    ready: function ready() {
		        var _this = this;
		
		        for (var i = 0; i < this.$children.length; i++) {
		            this.$children[i].id = this.$children[i].id || _uuid2.default.short('ui-tab-');
		        }
		
		        this.activeTab = this.activeTab || this.$children[0].id;
		
		        this.$nextTick(function () {
		            if (_this.$els.tabsContainer) {
		                _this.activeTabElement = _this.$els.tabsContainer.querySelector('.active');
		            }
		        });
		    },
		
		
		    events: {
		        'ui-tabs::select': function uiTabsSelect(tabId, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            var tab = this.findTabById(tabId);
		
		            if (tab) {
		                this.select(tab.$el, tab);
		            }
		        }
		    },
		
		    methods: {
		        select: function select(e, tab) {
		            var newTabElement = e.currentTarget ? e.currentTarget : e;
		
		            if (tab.disabled || this.activeTabElement === newTabElement) {
		                return;
		            }
		
		            this.activeTabElement = newTabElement;
		            this.activeTab = tab.id;
		
		            this.$dispatch('active-tab-changed', tab.id);
		        },
		        selectPrev: function selectPrev(currentTabIndex) {
		            if (currentTabIndex === 0) {
		                return;
		            }
		
		            var prevTab = this.findTab(currentTabIndex);
		            this.select(prevTab.$el, prevTab);
		
		            this.activeTabElement.focus();
		        },
		        selectNext: function selectNext(currentTabIndex) {
		            if (currentTabIndex === this.$refs.tabElements.length - 1) {
		                return;
		            }
		
		            var nextTab = this.findTab(currentTabIndex, true);
		            this.select(nextTab.$el, nextTab);
		
		            this.activeTabElement.focus();
		        },
		        findTab: function findTab(currentTabIndex, next) {
		            var tab = void 0;
		
		            if (next) {
		                for (var i = currentTabIndex + 1; i < this.$refs.tabElements.length; i++) {
		                    if (!this.$refs.tabElements[i].disabled) {
		                        tab = this.$refs.tabElements[i];
		                        break;
		                    }
		                }
		            } else {
		                for (var _i = currentTabIndex - 1; _i >= 0; _i--) {
		                    if (!this.$refs.tabElements[_i].disabled) {
		                        tab = this.$refs.tabElements[_i];
		                        break;
		                    }
		                }
		            }
		
		            tab = tab || this.$refs.tabElements[currentTabIndex];
		
		            return tab;
		        },
		        findTabById: function findTabById(id) {
		            var tab = null;
		
		            var numOfTabs = this.$refs.tabElements.length;
		
		            for (var i = 0; i <= numOfTabs; i++) {
		                if (id === this.$refs.tabElements[i].id) {
		                    tab = this.$refs.tabElements[i];
		                    break;
		                }
		            }
		
		            return tab;
		        }
		    },
		
		    components: {
		        UiTabHeaderItem: _UiTabHeaderItem2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 203 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(204)
		__vue_script__ = __webpack_require__(205)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTabHeaderItem.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(206)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTabHeaderItem.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 204 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 205 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tab-header-item',
		
		    props: {
		        id: String,
		        type: {
		            type: String,
		            default: 'text' },
		        text: String,
		        icon: String,
		        active: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 206 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-tab-header-item\" role=\"tab\"\n    :class=\"['type-' + type, { 'active': active, 'disabled': disabled }]\"\n\n    :tabindex=\"active ? 0 : -1\" :aria-controls=\"id\" :aria-selected=\"active ? 'true' : null\"\n    v-disabled=\"disabled\" v-el:item\n>\n    <div\n        class=\"ui-tab-header-item-icon\" v-if=\"type === 'icon' || type === 'icon-and-text'\"\n    >\n        <ui-icon :icon=\"icon\"></ui-icon>\n    </div>\n\n    <div\n        class=\"ui-tab-header-item-text\" v-text=\"text\"\n        v-if=\"type === 'text' || type === 'icon-and-text'\"\n    ></div>\n\n    <ui-ripple-ink :trigger=\"$els.item\" v-if=\"!hideRippleInk && !disabled\"></ui-ripple-ink>\n</li>\n";
	
	/***/ },
	/* 207 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-tabs\" :class=\"styleClasses\">\n    <div class=\"ui-tabs-header\" :class=\"[backgroundColor]\">\n        <ul\n            class=\"ui-tabs-header-items\" :class=\"[textColor, textColorActive]\" role=\"tablist\"\n            v-el:tabs-container\n        >\n            <ui-tab-header-item\n                :type=\"type\" :id=\"tab.id\" :icon=\"tab.icon\" :text=\"tab.header\"\n                :active=\"activeTab === tab.id\" :disabled=\"tab.disabled\"\n                :hide-ripple-ink=\"hideRippleInk\"\n\n                @click=\"select($event, tab)\" @keydown.left=\"selectPrev(index)\"\n                @keydown.right=\"selectNext($index)\"\n\n                v-for=\"(index, tab) in $children\" v-ref:tab-elements\n            ></ui-tab-header-item>\n        </ul>\n\n        <div\n            class=\"ui-tabs-active-tab-indicator\" :class=\"[indicatorColor]\"\n            :style=\"{ 'left': indicatorLeft, 'right': indicatorRight }\"\n        ></div>\n    </div>\n\n    <div class=\"ui-tabs-body\">\n        <slot></slot>\n    </div>\n</div>\n";
	
	/***/ },
	/* 208 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(209)
		__vue_script__ = __webpack_require__(210)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTextbox.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(211)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTextbox.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 209 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 210 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _autofocus = __webpack_require__(90);
		
		var _autofocus2 = _interopRequireDefault(_autofocus);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-textbox',
		
		    props: {
		        type: {
		            type: String,
		            default: 'text'
		        },
		        multiLine: {
		            type: Boolean,
		            default: false
		        },
		        rows: {
		            type: Number,
		            default: 2
		        },
		        maxLength: Number,
		        trimValue: {
		            type: Boolean,
		            default: true
		        },
		        validateOnBlur: {
		            type: Boolean,
		            default: false
		        },
		        autocomplete: String,
		        autofocus: {
		            type: Boolean,
		            default: false
		        },
		        min: Number,
		        max: Number,
		        step: {
		            type: String,
		            default: 'any',
		            coerce: String
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (this.ignoreValueChange) {
		                return;
		            }
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            if (!this.validateOnBlur) {
		                this.validate();
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            ignoreValueChange: false
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        minValue: function minValue() {
		            if (this.type !== 'number') {
		                return null;
		            }
		
		            if (this.min || this.min === 0) {
		                return this.min;
		            }
		
		            return null;
		        },
		        maxValue: function maxValue() {
		            if (this.type !== 'number') {
		                return null;
		            }
		
		            if (this.max || this.max === 0) {
		                return this.max;
		            }
		
		            return null;
		        },
		        stepValue: function stepValue() {
		            if (this.type === 'number') {
		                return this.step;
		            }
		
		            return null;
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            var _this = this;
		
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.ignoreValueChange = true;
		
		            if (document.activeElement === this.$el.querySelector('input') || document.activeElement === this.$el.querySelector('textarea')) {
		                document.activeElement.blur();
		            }
		
		            this.validationError = '';
		            this.value = this.initialValue;
		            this.valid = true;
		            this.dirty = false;
		
		            this.$nextTick(function () {
		                _this.ignoreValueChange = false;
		            });
		        }
		    },
		
		    methods: {
		        focussed: function focussed() {
		            this.active = true;
		            this.$dispatch('focussed');
		        },
		        blurred: function blurred() {
		            this.active = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            this.$dispatch('blurred');
		            this.validate();
		        },
		        changed: function changed() {
		            this.$dispatch('changed');
		        },
		        keydown: function keydown(e) {
		            this.$dispatch('keydown', e);
		        },
		        keydownEnter: function keydownEnter(e) {
		            this.$dispatch('keydown-enter', e);
		        }
		    },
		
		    filters: {
		        trim: {
		            write: function write(value) {
		                if (this.type !== 'number' && this.trimValue) {
		                    return value.trim();
		                }
		
		                return value;
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    directives: {
		        autofocus: _autofocus2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 211 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-textbox\"\n    :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'is-multi-line': multiLine, 'icon-right': iconRight,\n        'has-counter': maxLength\n    }\"\n>\n    <div class=\"ui-textbox-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-textbox-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-textbox-content\">\n        <label class=\"ui-textbox-label\">\n            <div class=\"ui-textbox-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <input\n                class=\"ui-textbox-input\" :type=\"type\" :placeholder=\"placeholder\" :name=\"name\"\n                :id=\"id\" :number=\"type === 'number' ? true : null\" :min=\"minValue\"\n                :max=\"maxValue\" :step=\"stepValue\"\n                :autocomplete=\"autocomplete ? autocomplete : null\"\n\n                @focus=\"focussed\" @blur=\"blurred\" @change=\"changed\" @keydown=\"keydown\"\n                @keydown.enter=\"keydownEnter\" :debounce=\"debounce\"\n\n                v-model=\"value | trim\" v-disabled=\"disabled\" v-if=\"!multiLine\"\n                v-autofocus=\"autofocus\"\n            >\n\n            <textarea\n                class=\"ui-textbox-textarea\" :placeholder=\"placeholder\" :name=\"name\" :id=\"id\"\n                :rows=\"rows\"\n\n                @focus=\"focussed\" @blur=\"blurred\" @change=\"changed\" @keydown=\"keydown\"\n                @keydown.enter=\"keydownEnter\" :debounce=\"debounce\"\n\n                v-model=\"value | trim\" v-disabled=\"disabled\" v-else\n            ></textarea>\n        </label>\n\n        <div class=\"ui-textbox-feedback\" v-if=\"showFeedback || maxLength\">\n            <div\n                class=\"ui-textbox-error-text\" transition=\"ui-textbox-feedback-toggle\"\n                v-text=\"validationError\" v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-textbox-help-text\" transition=\"ui-textbox-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n\n            <div\n                class=\"ui-textbox-counter\" v-text=\"value.length + '/' + maxLength\"\n                v-if=\"maxLength\"\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 212 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(213)
		__vue_script__ = __webpack_require__(214)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiToolbar.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(215)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiToolbar.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 213 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 214 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiProgressLinear = __webpack_require__(137);
		
		var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-toolbar',
		
		    props: {
		        type: {
		            type: String,
		            default: 'default', coerce: function coerce(type) {
		                return 'ui-toolbar-' + type;
		            }
		        },
		        textColor: {
		            type: String,
		            default: 'black', coerce: function coerce(color) {
		                return 'text-color-' + color;
		            }
		        },
		        title: String,
		        brand: String,
		        showBrand: {
		            type: Boolean,
		            default: false
		        },
		        showBrandDivider: {
		            type: Boolean,
		            default: null
		        },
		        navIcon: {
		            type: String,
		            default: 'menu'
		        },
		        hideNavIcon: {
		            type: Boolean,
		            default: false
		        },
		        flat: {
		            type: Boolean,
		            default: false
		        },
		        preloaderTop: {
		            type: Boolean,
		            default: false
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.textColor];
		
		            if (!this.flat) {
		                classes.push('ui-toolbar-raised');
		            }
		
		            return classes;
		        },
		        iconColor: function iconColor() {
		            if (this.textColor === 'text-color-black') {
		                return 'black';
		            }
		
		            return 'white';
		        },
		        preloaderColor: function preloaderColor() {
		            if (this.textColor === 'text-color-black') {
		                return 'primary';
		            }
		
		            return 'white';
		        },
		        brandDividerVisible: function brandDividerVisible() {
		            if (this.showBrandDivider !== null) {
		                return this.showBrandDivider;
		            }
		
		            if (!this.showBrand) {
		                return false;
		            }
		
		            return true;
		        }
		    },
		
		    methods: {
		        navIconClick: function navIconClick() {
		            this.$dispatch('nav-icon-clicked');
		        }
		    },
		
		    components: {
		        UiProgressLinear: _UiProgressLinear2.default,
		        UiIconButton: _UiIconButton2.default
		    }
		};
	
	/***/ },
	/* 215 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-toolbar\" :class=\"styleClasses\">\n    <div class=\"ui-toolbar-left\">\n        <ui-icon-button\n            class=\"ui-toolbar-nav-icon\" type=\"clear\" :color=\"iconColor\" :icon=\"navIcon\"\n            @click=\"navIconClick\" v-if=\"!hideNavIcon\"\n        ></ui-icon-button>\n\n        <div class=\"ui-toolbar-brand\" v-if=\"showBrand\">\n            <slot name=\"brand\">\n                <div class=\"ui-toolbar-brand-text\" v-text=\"brand\"></div>\n            </slot>\n        </div>\n    </div>\n\n    <div class=\"ui-toolbar-center\">\n        <div class=\"ui-toolbar-divider\" v-if=\"brandDividerVisible\"></div>\n\n        <slot>\n            <div class=\"ui-toolbar-title\" v-text=\"title\"></div>\n        </slot>\n    </div>\n\n    <div class=\"ui-toolbar-right\">\n        <slot name=\"actions\"></slot>\n    </div>\n\n    <ui-progress-linear\n        :show=\"loading\" class=\"ui-toolbar-preloader\" :class=\"{ 'position-top' : preloaderTop }\"\n        :color=\"preloaderColor\"\n    ></ui-progress-linear>\n</div>\n";
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=keen-ui.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(8)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(135)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7ca1b1bb/App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 6 */,
/* 7 */,
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _uuid = __webpack_require__(139);
	
	var _uuid2 = _interopRequireDefault(_uuid);
	
	var _socket = __webpack_require__(84);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _MapView = __webpack_require__(9);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _ParamsView = __webpack_require__(69);
	
	var _ParamsView2 = _interopRequireDefault(_ParamsView);
	
	var _SettingsView = __webpack_require__(73);
	
	var _SettingsView2 = _interopRequireDefault(_SettingsView);
	
	var _GcsIndicators = __webpack_require__(77);
	
	var _GcsIndicators2 = _interopRequireDefault(_GcsIndicators);
	
	var _actions = __webpack_require__(20);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        actions: {
	            setWamv: _actions.setWamv,
	            setParameters: _actions.setParameters,
	            setMissions: _actions.setMissions,
	            setCurrentMission: _actions.setCurrentMission
	        }
	    },
	
	    data: function data() {
	        return {
	            socket: null,
	            sentMessageIds: [],
	            timedoutMessageIds: [],
	            timeouts: {}
	        };
	    },
	    ready: function ready() {
	        this.setupSocket();
	    },
	
	
	    events: {
	        'send-to-server': function sendToServer(messageType, data) {
	            var _this = this;
	
	            var messageId = _uuid2.default.generate();
	
	            this.socket.emit(messageType, data, messageId);
	            this.sentMessageIds.push(messageId);
	
	            this.timeouts[messageId] = window.setTimeout(function () {
	                _this.timedoutMessageIds.push(messageId);
	                _this.$broadcast('server-message-timeout', messageType);
	
	                console.log('Timeout reached for message', messageType);
	                window.clearTimeout(_this.timeouts[messageId]);
	            }, 1000);
	        },
	        'app::create-snackbar': function appCreateSnackbar(message, snackbar) {
	            this.createSnackbar(message, snackbar);
	        },
	        'map::pan-up': function mapPanUp() {
	            this.$broadcast('map::pan-up');
	        },
	        'map::pan-down': function mapPanDown() {
	            this.$broadcast('map::pan-down');
	        },
	        'map::pan-left': function mapPanLeft() {
	            this.$broadcast('map::pan-left');
	        },
	        'map::pan-right': function mapPanRight() {
	            this.$broadcast('map::pan-right');
	        },
	        'map::pan-center': function mapPanCenter() {
	            this.$broadcast('map::pan-center');
	        },
	        'map::zoom-in': function mapZoomIn() {
	            this.$broadcast('map::zoom-in');
	        },
	        'map::zoom-out': function mapZoomOut() {
	            this.$broadcast('map::zoom-out');
	        },
	        'map::change-type': function mapChangeType(newType) {
	            this.$broadcast('map::change-type', newType);
	        },
	        'map:click': function mapClick(e) {
	            this.$broadcast('map:click', e);
	        },
	        'map:dblclick': function mapDblclick(e) {
	            this.$broadcast('map:dblclick', e);
	        },
	        'map:rightclick': function mapRightclick(e) {
	            this.$broadcast('map:rightclick', e);
	        }
	    },
	
	    methods: {
	        createSnackbar: function createSnackbar(message, snackbar) {
	            snackbar = snackbar || {
	                message: message
	            };
	
	            this.$broadcast('ui-snackbar::create', snackbar);
	        },
	        setupSocket: function setupSocket() {
	            this.socket = (0, _socket2.default)('localhost:3000');
	
	            this.socket.on('connect', this.onConnect);
	            this.socket.on('disconnect', this.onDisconnect);
	            this.socket.on('status', this.onStatus);
	            this.socket.on('get_parameters', this.onParameterReceived);
	            this.socket.on('load_missions', this.onMissionsReceived);
	            this.socket.on('download_mission', this.onCurrentMissionReceived);
	            this.socket.on('success', this.onSuccess);
	            this.socket.on('failure', this.onFailure);
	            this.socket.on('attention', this.onAttention);
	        },
	        onConnect: function onConnect() {
	            console.log('connected to server');
	
	            this.$emit('send-to-server', 'get_parameters');
	
	            this.$emit('send-to-server', 'load_missions');
	        },
	        onDisconnect: function onDisconnect() {
	            console.log('disconnected from server');
	        },
	        onSuccess: function onSuccess(messageType, messageId) {
	            if (this.timedoutMessageIds.indexOf(messageId) !== -1) {
	                this.$broadcast('server-message-success', messageType);
	
	                this.cleanUp(messageId);
	            }
	
	            console.log('received "success" message');
	        },
	        onFailure: function onFailure(messageType, messageId) {
	            if (this.timedoutMessageIds.indexOf(messageId) !== -1) {
	                this.$broadcast('server-message-failure', messageType);
	
	                this.cleanUp(messageId);
	            }
	
	            console.log('received "failure" message');
	        },
	        onStatus: function onStatus(data) {
	            data.loaded = true;
	            this.setWamv(data);
	        },
	        onParameterReceived: function onParameterReceived(data, messageId) {
	            console.log('received "get_parameters" message', messageId);
	            this.setParameters(data);
	
	            this.cleanUp(messageId);
	        },
	        onMissionsReceived: function onMissionsReceived(data, messageId) {
	            console.log('received "load_missions" message');
	            this.setMissions(data);
	
	            this.cleanUp(messageId);
	        },
	        onCurrentMissionReceived: function onCurrentMissionReceived(data, messageId) {
	            console.log('received "download_mission" message:');
	            this.setCurrentMission(data);
	
	            this.cleanUp(messageId);
	        },
	        onAttention: function onAttention(data, messageId) {
	            console.log('Attention: ' + data);
	            this.cleanUp(messageId);
	        },
	        cleanUp: function cleanUp(messageId) {
	            console.log('Timeouts', this.timeouts);
	            console.log('Clearing timeout', this.timeouts[messageId]);
	
	            window.clearTimeout(this.timeouts[messageId]);
	            this.sentMessageIds.$remove(messageId);
	        }
	    },
	
	    components: {
	        MapView: _MapView2.default,
	        ParamsView: _ParamsView2.default,
	        SettingsView: _SettingsView2.default,
	        GcsIndicators: _GcsIndicators2.default
	    }
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(10)
	__vue_script__ = __webpack_require__(11)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\views\\MapView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(68)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-106887fa/MapView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 10 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsMap = __webpack_require__(12);
	
	var _GcsMap2 = _interopRequireDefault(_GcsMap);
	
	var _GcsMapControls = __webpack_require__(25);
	
	var _GcsMapControls2 = _interopRequireDefault(_GcsMapControls);
	
	var _GcsMapSidebar = __webpack_require__(29);
	
	var _GcsMapSidebar2 = _interopRequireDefault(_GcsMapSidebar);
	
	var _GcsSidebarControls = __webpack_require__(56);
	
	var _GcsSidebarControls2 = _interopRequireDefault(_GcsSidebarControls);
	
	var _GcsWamv = __webpack_require__(64);
	
	var _GcsWamv2 = _interopRequireDefault(_GcsWamv);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    data: function data() {
	        return {
	            showSidebar: true
	        };
	    },
	
	
	    methods: {
	        toggleSidebar: function toggleSidebar() {
	            this.showSidebar = !this.showSidebar;
	        }
	    },
	
	    components: {
	        GcsMap: _GcsMap2.default,
	        GcsWamv: _GcsWamv2.default,
	        GcsMapControls: _GcsMapControls2.default,
	        GcsMapSidebar: _GcsMapSidebar2.default,
	        GcsSidebarControls: _GcsSidebarControls2.default
	    }
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(13)
	__vue_script__ = __webpack_require__(14)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsMap.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(24)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-18281c25/GcsMap.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 13 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _copyObject = __webpack_require__(15);
	
	var _copyObject2 = _interopRequireDefault(_copyObject);
	
	var _loadGoogleMapsApi = __webpack_require__(19);
	
	var _loadGoogleMapsApi2 = _interopRequireDefault(_loadGoogleMapsApi);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapEl: _getters.getMapEl,
	            mapLoaded: _getters.getMapLoaded,
	            mapEditing: _getters.getMapEditing,
	            wamv: _getters.getWamv,
	            config: _getters.getConfig,
	            settings: _getters.getSettings
	        },
	
	        actions: {
	            setMap: _actions.setMap,
	            setMapEl: _actions.setMapEl,
	            setMapLoaded: _actions.setMapLoaded
	        }
	    },
	
	    watch: {
	        mapEditing: function mapEditing() {
	            if (this.mapEditing) {
	                this.map.setOptions({ draggableCursor: 'crosshair' });
	            } else {
	                this.map.setOptions({ draggableCursor: 'move' });
	            }
	        }
	    },
	
	    ready: function ready() {
	        this.setMapEl(document.getElementById('map'));
	
	        (0, _loadGoogleMapsApi2.default)(this.config.googleMaps).then(this.initializeMap).catch(function (error) {
	            console.log('Unable to load Google Maps API', error);
	        });
	    },
	
	
	    events: {
	        'map::pan-up': function mapPanUp() {
	            this.map.panBy(0, -1 * (this.mapEl.clientHeight / 4));
	        },
	        'map::pan-down': function mapPanDown() {
	            this.map.panBy(0, this.mapEl.clientHeight / 4);
	        },
	        'map::pan-left': function mapPanLeft() {
	            this.map.panBy(-1 * (this.mapEl.clientWidth / 4), 0);
	        },
	        'map::pan-right': function mapPanRight() {
	            this.map.panBy(this.mapEl.clientWidth / 4, 0);
	        },
	        'map::pan-center': function mapPanCenter() {
	            if (this.wamv.loaded) {
	                this.map.panTo(this.wamv.position);
	            }
	        },
	        'map::zoom-in': function mapZoomIn() {
	            this.map.setZoom(this.map.getZoom() + 1);
	        },
	        'map::zoom-out': function mapZoomOut() {
	            this.map.setZoom(this.map.getZoom() - 1);
	        },
	        'map::change-type': function mapChangeType(newType) {
	            this.map.setMapTypeId(google.maps.MapTypeId[newType]);
	        }
	    },
	
	    methods: {
	        initializeMap: function initializeMap() {
	            var mapConfig = (0, _copyObject2.default)(this.config.map);
	
	            mapConfig.mapTypeId = google.maps.MapTypeId[this.settings.defaultMapType];
	
	            var map = new google.maps.Map(this.mapEl, mapConfig);
	
	            this.setupEvents(map);
	
	            this.setMap(map);
	            this.setMapLoaded(true);
	        },
	        setupEvents: function setupEvents(map) {
	            var _this = this;
	
	            map.addListener('click', function (e) {
	                _this.$dispatch('map:click', e);
	            });
	
	            map.addListener('dblclick', function (e) {
	                _this.$dispatch('map:dblclick', e);
	            });
	
	            map.addListener('rightclick', function (e) {
	                _this.$dispatch('map:rightclick', e);
	            });
	        }
	    }
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(16);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	exports.default = function (object) {
	    return JSON.parse((0, _stringify2.default)(object));
	};
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(17), __esModule: true };

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(18)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 18 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var client = _ref.client;
	  var key = _ref.key;
	  var language = _ref.language;
	  var _ref$libraries = _ref.libraries;
	  var libraries = _ref$libraries === undefined ? [] : _ref$libraries;
	  var _ref$timeout = _ref.timeout;
	  var timeout = _ref$timeout === undefined ? 10000 : _ref$timeout;
	  var v = _ref.v;
	
	  var callbackName = '__googleMapsApiOnLoadCallback';
	
	  return new Promise(function (resolve, reject) {
	
	    // Exit if not running inside a browser.
	    if (typeof window === 'undefined') {
	      return reject(new Error('Can only load the Google Maps API in the browser'));
	    }
	
	    // Prepare the `script` tag to be inserted into the page.
	    var scriptElement = document.createElement('script');
	    var params = ['callback=' + callbackName];
	    if (client) params.push('client=' + client);
	    if (key) params.push('key=' + key);
	    if (language) params.push('language=' + language);
	    libraries = [].concat(libraries); // Ensure that `libraries` is an array
	    if (libraries.length) params.push('libraries=' + libraries.join(','));
	    if (v) params.push('v=' + v);
	    scriptElement.src = 'https://maps.googleapis.com/maps/api/js?' + params.join('&');
	
	    // Timeout if necessary.
	    var timeoutId = null;
	    if (timeout) {
	      timeoutId = setTimeout(function () {
	        window[callbackName] = function () {}; // Set the on load callback to a no-op.
	        reject(new Error('Could not load the Google Maps API'));
	      }, timeout);
	    }
	
	    // Hook up the on load callback.
	    window[callbackName] = function () {
	      if (timeoutId !== null) {
	        clearTimeout(timeoutId);
	      }
	      resolve(window.google.maps);
	      delete window[callbackName];
	    };
	
	    // Insert the `script` tag.
	    document.body.appendChild(scriptElement);
	  });
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.setMap = setMap;
	exports.setMapEl = setMapEl;
	exports.setMapLoaded = setMapLoaded;
	exports.setMapEditing = setMapEditing;
	exports.setWamv = setWamv;
	exports.setWamvArmed = setWamvArmed;
	exports.setWamvMode = setWamvMode;
	exports.initSettings = initSettings;
	exports.updateSetting = updateSetting;
	exports.setMissions = setMissions;
	exports.setCurrentMissionIndex = setCurrentMissionIndex;
	exports.setCurrentMission = setCurrentMission;
	exports.setParameters = setParameters;
	exports.sendGetParameters = sendGetParameters;
	exports.succeedGetParameters = succeedGetParameters;
	exports.failGetParameters = failGetParameters;
	exports.sendSaveMissions = sendSaveMissions;
	exports.succeedSaveMissions = succeedSaveMissions;
	exports.failSaveMissions = failSaveMissions;
	exports.sendLoadMissions = sendLoadMissions;
	exports.succeedLoadMissions = succeedLoadMissions;
	exports.failLoadMissions = failLoadMissions;
	exports.sendUploadMission = sendUploadMission;
	exports.succeedUploadMission = succeedUploadMission;
	exports.failUploadMission = failUploadMission;
	exports.sendDownloadMission = sendDownloadMission;
	exports.succeedDownloadMission = succeedDownloadMission;
	exports.failDownloadMission = failDownloadMission;
	exports.sendStartMission = sendStartMission;
	exports.succeedStartMission = succeedStartMission;
	exports.failStartMission = failStartMission;
	exports.sendStopMission = sendStopMission;
	exports.succeedStopMission = succeedStopMission;
	exports.failStopMission = failStopMission;
	exports.sendResumeMission = sendResumeMission;
	exports.succeedResumeMission = succeedResumeMission;
	exports.failResumeMission = failResumeMission;
	exports.sendArm = sendArm;
	exports.succeedArm = succeedArm;
	exports.failArm = failArm;
	exports.sendDisarm = sendDisarm;
	exports.succeedDisarm = succeedDisarm;
	exports.failDisarm = failDisarm;
	exports.sendKill = sendKill;
	exports.succeedKill = succeedKill;
	exports.failKill = failKill;
	exports.sendUnkill = sendUnkill;
	exports.succeedUnkill = succeedUnkill;
	exports.failUnkill = failUnkill;
	
	var _deepAssign = __webpack_require__(21);
	
	var _deepAssign2 = _interopRequireDefault(_deepAssign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function setMap(_ref, map) {
	    var dispatch = _ref.dispatch;
	    var state = _ref.state;
	
	    dispatch('SET_MAP', map);
	}
	
	function setMapEl(_ref2, mapEl) {
	    var dispatch = _ref2.dispatch;
	    var state = _ref2.state;
	
	    dispatch('SET_MAP_EL', mapEl);
	}
	
	function setMapLoaded(_ref3, loaded) {
	    var dispatch = _ref3.dispatch;
	    var state = _ref3.state;
	
	    dispatch('SET_MAP_LOADED', loaded);
	}
	
	function setMapEditing(_ref4, editing) {
	    var dispatch = _ref4.dispatch;
	    var state = _ref4.state;
	
	    dispatch('SET_MAP_EDITING', editing);
	}
	
	function setWamv(_ref5, wamv) {
	    var dispatch = _ref5.dispatch;
	    var state = _ref5.state;
	
	    dispatch('SET_WAMV', wamv);
	}
	
	function setWamvArmed(_ref6, armed) {
	    var dispatch = _ref6.dispatch;
	    var state = _ref6.state;
	
	    dispatch('SET_WAMV_ARMED', armed);
	}
	
	function setWamvMode(_ref7, mode) {
	    var dispatch = _ref7.dispatch;
	    var state = _ref7.state;
	
	    dispatch('SET_WAMV_MODE', mode);
	}
	
	function initSettings(_ref8) {
	    var dispatch = _ref8.dispatch;
	}
	
	function updateSetting(_ref9, key, value) {
	    var dispatch = _ref9.dispatch;
	    var state = _ref9.state;
	
	    var settings = (0, _deepAssign2.default)({}, state.settings);
	    settings[key] = value;
	
	    dispatch('UPDATE_SETTINGS', settings);
	}
	
	function setMissions(_ref10, missions) {
	    var dispatch = _ref10.dispatch;
	    var state = _ref10.state;
	
	    dispatch('SET_MISSIONS', missions);
	}
	
	function setCurrentMissionIndex(_ref11, index) {
	    var dispatch = _ref11.dispatch;
	    var state = _ref11.state;
	
	    dispatch('SET_CURRENT_MISSION_INDEX', index);
	}
	
	function setCurrentMission(_ref12, mission) {
	    var dispatch = _ref12.dispatch;
	    var state = _ref12.state;
	
	    dispatch('SET_CURRENT_MISSION', mission);
	}
	
	function setParameters(_ref13, parameters) {
	    var dispatch = _ref13.dispatch;
	    var state = _ref13.state;
	
	    dispatch('SET_PARAMETERS', parameters);
	}
	
	function sendGetParameters(_ref14) {
	    var dispatch = _ref14.dispatch;
	    var state = _ref14.state;
	
	    dispatch('SEND_GET_PARAMETERS');
	}
	
	function succeedGetParameters(_ref15, parameters) {
	    var dispatch = _ref15.dispatch;
	    var state = _ref15.state;
	
	    dispatch('SUCCEED_GET_PARAMETERS', parameters);
	}
	
	function failGetParameters(_ref16, msg) {
	    var dispatch = _ref16.dispatch;
	    var state = _ref16.state;
	
	    dispatch('FAIL_GET_PARAMETERS', msg);
	}
	
	function sendSaveMissions(_ref17, missions) {
	    var dispatch = _ref17.dispatch;
	    var state = _ref17.state;
	
	    dispatch('SEND_SAVE_MISSIONS', missions);
	}
	
	function succeedSaveMissions(_ref18) {
	    var dispatch = _ref18.dispatch;
	    var state = _ref18.state;
	
	    dispatch('SUCCEED_SAVE_MISSIONS');
	}
	
	function failSaveMissions(_ref19, msg) {
	    var dispatch = _ref19.dispatch;
	    var state = _ref19.state;
	
	    dispatch('FAIL_SAVE_MISSIONS', msg);
	}
	
	function sendLoadMissions(_ref20) {
	    var dispatch = _ref20.dispatch;
	    var state = _ref20.state;
	
	    dispatch('SEND_LOAD_MISSIONS');
	}
	
	function succeedLoadMissions(_ref21, missions) {
	    var dispatch = _ref21.dispatch;
	    var state = _ref21.state;
	
	    dispatch('SUCCEED_LOAD_MISSIONS', missions);
	}
	
	function failLoadMissions(_ref22, msg) {
	    var dispatch = _ref22.dispatch;
	    var state = _ref22.state;
	
	    dispatch('FAIL_LOAD_MISSIONS', msg);
	}
	
	function sendUploadMission(_ref23, mission) {
	    var dispatch = _ref23.dispatch;
	    var state = _ref23.state;
	
	    dispatch('SEND_UPLOAD_MISSION', mission);
	}
	
	function succeedUploadMission(_ref24) {
	    var dispatch = _ref24.dispatch;
	    var state = _ref24.state;
	
	    dispatch('SUCCEED_UPLOAD_MISSION');
	}
	
	function failUploadMission(_ref25, msg) {
	    var dispatch = _ref25.dispatch;
	    var state = _ref25.state;
	
	    dispatch('FAIL_UPLOAD_MISSION', msg);
	}
	
	function sendDownloadMission(_ref26) {
	    var dispatch = _ref26.dispatch;
	    var state = _ref26.state;
	
	    dispatch('SEND_DOWNLOAD_MISSION');
	}
	
	function succeedDownloadMission(_ref27, mission) {
	    var dispatch = _ref27.dispatch;
	    var state = _ref27.state;
	
	    dispatch('SUCCEED_DOWNLOAD_MISSION', mission);
	}
	
	function failDownloadMission(_ref28, msg) {
	    var dispatch = _ref28.dispatch;
	    var state = _ref28.state;
	
	    dispatch('FAIL_DOWNLOAD_MISSION', msg);
	}
	
	function sendStartMission(_ref29) {
	    var dispatch = _ref29.dispatch;
	    var state = _ref29.state;
	
	    dispatch('SEND_START_MISSION');
	}
	
	function succeedStartMission(_ref30) {
	    var dispatch = _ref30.dispatch;
	    var state = _ref30.state;
	
	    dispatch('SUCCEED_START_MISSION');
	}
	
	function failStartMission(_ref31, msg) {
	    var dispatch = _ref31.dispatch;
	    var state = _ref31.state;
	
	    dispatch('FAIL_START_MISSION', msg);
	}
	
	function sendStopMission(_ref32) {
	    var dispatch = _ref32.dispatch;
	    var state = _ref32.state;
	
	    dispatch('SEND_STOP_MISSION');
	}
	
	function succeedStopMission(_ref33) {
	    var dispatch = _ref33.dispatch;
	    var state = _ref33.state;
	
	    dispatch('SUCCEED_STOP_MISSION');
	}
	
	function failStopMission(_ref34, msg) {
	    var dispatch = _ref34.dispatch;
	    var state = _ref34.state;
	
	    dispatch('FAIL_STOP_MISSION', msg);
	}
	
	function sendResumeMission(_ref35) {
	    var dispatch = _ref35.dispatch;
	    var state = _ref35.state;
	
	    dispatch('SEND_RESUME_MISSION');
	}
	
	function succeedResumeMission(_ref36) {
	    var dispatch = _ref36.dispatch;
	    var state = _ref36.state;
	
	    dispatch('SUCCEED_RESUME_MISSION');
	}
	
	function failResumeMission(_ref37, msg) {
	    var dispatch = _ref37.dispatch;
	    var state = _ref37.state;
	
	    dispatch('FAIL_RESUME_MISSION', msg);
	}
	
	function sendArm(_ref38) {
	    var dispatch = _ref38.dispatch;
	    var state = _ref38.state;
	
	    dispatch('SEND_ARM');
	}
	
	function succeedArm(_ref39) {
	    var dispatch = _ref39.dispatch;
	    var state = _ref39.state;
	
	    dispatch('SUCCEED_ARM');
	}
	
	function failArm(_ref40, msg) {
	    var dispatch = _ref40.dispatch;
	    var state = _ref40.state;
	
	    dispatch('FAIL_ARM', msg);
	}
	
	function sendDisarm(_ref41) {
	    var dispatch = _ref41.dispatch;
	    var state = _ref41.state;
	
	    dispatch('SEND_DISARM');
	}
	
	function succeedDisarm(_ref42) {
	    var dispatch = _ref42.dispatch;
	    var state = _ref42.state;
	
	    dispatch('SUCCEED_DISARM');
	}
	
	function failDisarm(_ref43, msg) {
	    var dispatch = _ref43.dispatch;
	    var state = _ref43.state;
	
	    dispatch('FAIL_DISARM', msg);
	}
	
	function sendKill(_ref44) {
	    var dispatch = _ref44.dispatch;
	    var state = _ref44.state;
	
	    dispatch('SEND_KILL');
	}
	
	function succeedKill(_ref45) {
	    var dispatch = _ref45.dispatch;
	    var state = _ref45.state;
	
	    dispatch('SUCCEED_KILL');
	}
	
	function failKill(_ref46, msg) {
	    var dispatch = _ref46.dispatch;
	    var state = _ref46.state;
	
	    dispatch('FAIL_KILL', msg);
	}
	
	function sendUnkill(_ref47) {
	    var dispatch = _ref47.dispatch;
	    var state = _ref47.state;
	
	    dispatch('SEND_UNKILL');
	}
	
	function succeedUnkill(_ref48) {
	    var dispatch = _ref48.dispatch;
	    var state = _ref48.state;
	
	    dispatch('SUCCEED_UNKILL');
	}
	
	function failUnkill(_ref49, msg) {
	    var dispatch = _ref49.dispatch;
	    var state = _ref49.state;
	
	    dispatch('FAIL_UNKILL', msg);
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObj = __webpack_require__(22);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Sources cannot be null or undefined');
		}
	
		return Object(val);
	}
	
	function assignKey(to, from, key) {
		var val = from[key];
	
		if (val === undefined || val === null) {
			return;
		}
	
		if (hasOwnProperty.call(to, key)) {
			if (to[key] === undefined || to[key] === null) {
				throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
			}
		}
	
		if (!hasOwnProperty.call(to, key) || !isObj(val)) {
			to[key] = val;
		} else {
			to[key] = assign(Object(to[key]), from[key]);
		}
	}
	
	function assign(to, from) {
		if (to === from) {
			return to;
		}
	
		from = Object(from);
	
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				assignKey(to, from, key);
			}
		}
	
		if (Object.getOwnPropertySymbols) {
			var symbols = Object.getOwnPropertySymbols(from);
	
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					assignKey(to, from, symbols[i]);
				}
			}
		}
	
		return to;
	}
	
	module.exports = function deepAssign(target) {
		target = toObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			assign(target, arguments[s]);
		}
	
		return target;
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (x) {
		var type = typeof x;
		return x !== null && (type === 'object' || type === 'function');
	};


/***/ },
/* 23 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getMap = getMap;
	exports.getMapEl = getMapEl;
	exports.getMapLoaded = getMapLoaded;
	exports.getMapEditing = getMapEditing;
	exports.getWamv = getWamv;
	exports.getConfig = getConfig;
	exports.getSettings = getSettings;
	exports.getMissions = getMissions;
	exports.getCurrentMissionIndex = getCurrentMissionIndex;
	exports.getCurrentMission = getCurrentMission;
	exports.getParameters = getParameters;
	exports.getMessageStateWaiting = getMessageStateWaiting;
	exports.getMessageStateSuccess = getMessageStateSuccess;
	exports.getMessageStateFailure = getMessageStateFailure;
	exports.getGetParameterState = getGetParameterState;
	exports.getGetParameterData = getGetParameterData;
	exports.getSaveMissionsState = getSaveMissionsState;
	exports.getSaveMissionsData = getSaveMissionsData;
	exports.getLoadMissionsState = getLoadMissionsState;
	exports.getLoadMissionsData = getLoadMissionsData;
	exports.getUploadMissionState = getUploadMissionState;
	exports.getUploadMissionData = getUploadMissionData;
	exports.getDownloadMissionState = getDownloadMissionState;
	exports.getDownloadMissionData = getDownloadMissionData;
	exports.getStartMissionState = getStartMissionState;
	exports.getStartMissionData = getStartMissionData;
	exports.getStopMissionState = getStopMissionState;
	exports.getStopMissionData = getStopMissionData;
	exports.getResumeMissionState = getResumeMissionState;
	exports.getResumeMissionData = getResumeMissionData;
	exports.getArmState = getArmState;
	exports.getArmData = getArmData;
	exports.getDisarmState = getDisarmState;
	exports.getDisarmData = getDisarmData;
	exports.getKillState = getKillState;
	exports.getKillData = getKillData;
	exports.getUnkillState = getUnkillState;
	exports.getUnkillData = getUnkillData;
	function getMap(state) {
	    return state.map;
	}
	
	function getMapEl(state) {
	    return state.mapEl;
	}
	
	function getMapLoaded(state) {
	    return state.mapLoaded;
	}
	
	function getMapEditing(state) {
	    return state.mapEditing;
	}
	
	function getWamv(state) {
	    return state.wamv;
	}
	
	function getConfig(state) {
	    return state.config;
	}
	
	function getSettings(state) {
	    return state.settings;
	}
	
	function getMissions(state) {
	    return state.missions;
	}
	
	function getCurrentMissionIndex(state) {
	    return state.currentMissionIndex;
	}
	
	function getCurrentMission(state) {
	    return state.missions[state.currentMissionIndex];
	}
	
	function getParameters(state) {
	    return state.parameters;
	}
	
	function getMessageStateWaiting(state) {
	    return state.messageState.WAITING;
	}
	
	function getMessageStateSuccess(state) {
	    return state.messageState.SUCCESS;
	}
	
	function getMessageStateFailure(state) {
	    return state.messageState.FAILURE;
	}
	
	function getGetParameterState(state) {
	    return state.messageState.get_parameters[0];
	}
	
	function getGetParameterData(state) {
	    return state.messageState.get_parameters[1];
	}
	
	function getSaveMissionsState(state) {
	    return state.messageState.save_missions[0];
	}
	
	function getSaveMissionsData(state) {
	    return state.messageState.save_missions[1];
	}
	
	function getLoadMissionsState(state) {
	    return state.messageState.load_missions[0];
	}
	
	function getLoadMissionsData(state) {
	    return state.messageState.load_missions[1];
	}
	
	function getUploadMissionState(state) {
	    return state.messageState.upload_mission[0];
	}
	
	function getUploadMissionData(state) {
	    return state.messageState.upload_mission[1];
	}
	
	function getDownloadMissionState(state) {
	    return state.messageState.download_mission[0];
	}
	
	function getDownloadMissionData(state) {
	    return state.messageState.download_mission[1];
	}
	
	function getStartMissionState(state) {
	    return state.messageState.start_mission[0];
	}
	
	function getStartMissionData(state) {
	    return state.messageState.start_mission[1];
	}
	
	function getStopMissionState(state) {
	    return state.messageState.stop_mission[0];
	}
	
	function getStopMissionData(state) {
	    return state.messageState.stop_mission[1];
	}
	
	function getResumeMissionState(state) {
	    return state.messageState.resume_mission[0];
	}
	
	function getResumeMissionData(state) {
	    return state.messageState.resume_mission[1];
	}
	
	function getArmState(state) {
	    return state.messageState.arm[0];
	}
	
	function getArmData(state) {
	    return state.messageState.arm[1];
	}
	
	function getDisarmState(state) {
	    return state.messageState.disarm[0];
	}
	
	function getDisarmData(state) {
	    return state.messageState.disarm[1];
	}
	
	function getKillState(state) {
	    return state.messageState.kill[0];
	}
	
	function getKillData(state) {
	    return state.messageState.kill[1];
	}
	
	function getUnkillState(state) {
	    return state.messageState.unkill[0];
	}
	
	function getUnkillData(state) {
	    return state.messageState.unkill[1];
	}

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map\" id=\"map\" :class=\"{ 'gcs-map-edit-mode': mapEditing }\"></div>\n";

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(26)
	__vue_script__ = __webpack_require__(27)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsMapControls.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(28)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-475ae20a/GcsMapControls.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 26 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {
	            mapType: 'Satellite',
	            mapTypesMenu: [{ 'value': 'ROADMAP', text: 'Road' }, { 'value': 'TERRAIN', text: 'Terrain' }, { 'value': 'SATELLITE', text: 'Satellite' }, { 'value': 'HYBRID', text: 'Hybrid' }]
	        };
	    },
	
	
	    methods: {
	        pan: function pan(direction) {
	            this.$dispatch('map::pan-' + direction);
	        },
	        zoom: function zoom(type) {
	            this.$dispatch('map::zoom-' + type);
	        },
	        changeMapType: function changeMapType(selected) {
	            this.mapType = selected.text;
	            this.$dispatch('map::change-type', selected.value);
	        }
	    }
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map-controls\">\n    <div class=\"pan-controls\">\n        <ui-icon-button\n            class=\"pan-control up\" icon=\"keyboard_arrow_up\" @click=\"pan('up')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control right\" icon=\"keyboard_arrow_right\" @click=\"pan('right')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control down\" icon=\"keyboard_arrow_down\" @click=\"pan('down')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control left\" icon=\"keyboard_arrow_left\" @click=\"pan('left')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control center\" icon=\"my_location\" @click=\"pan('center')\"\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"zoom-controls\">\n        <ui-icon-button\n            class=\"zoom-control in\" icon=\"add\" @click=\"zoom('in')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"zoom-control out\" icon=\"remove\" @click=\"zoom('out')\"\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"type-control\">\n        <ui-button\n            :menu-options=\"mapTypesMenu\" name=\"map_types\" :text=\"mapType\"\n            @menu-option-selected=\"changeMapType\" has-dropdown-menu raised\n            dropdown-position=\"top right\" :show-dropdown-icon=\"false\"\n        ></ui-button>\n    </div>\n</div>\n";

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(30)
	__vue_script__ = __webpack_require__(31)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsMapSidebar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(55)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7fccf4b2/GcsMapSidebar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 30 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsMissions = __webpack_require__(32);
	
	var _GcsMissions2 = _interopRequireDefault(_GcsMissions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        showSidebar: {
	            type: Boolean,
	            required: true
	        }
	    },
	
	    components: {
	        GcsMissions: _GcsMissions2.default
	    }
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(33)
	__vue_script__ = __webpack_require__(34)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsMissions.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(54)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-009767c4/GcsMissions.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 33 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(16);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _GcsMission = __webpack_require__(35);
	
	var _GcsMission2 = _interopRequireDefault(_GcsMission);
	
	var _GcsMissionRow = __webpack_require__(50);
	
	var _GcsMissionRow2 = _interopRequireDefault(_GcsMissionRow);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            missions: _getters.getMissions,
	            currentMissionIndex: _getters.getCurrentMissionIndex,
	            currentMission: _getters.getCurrentMission,
	            WAITING: _getters.getMessageStateWaiting,
	            SUCCESS: _getters.getMessageStateSuccess,
	            FAILURE: _getters.getMessageStateFailure,
	            saveMissionsState: _getters.getSaveMissionsState,
	            saveMissionsData: _getters.getSaveMissionsData,
	            loadMissionsState: _getters.getLoadMissionsState,
	            loadMissionsData: _getters.getLoadMissionsData
	        },
	
	        actions: {
	            setMissions: _actions.setMissions,
	            setCurrentMissionIndex: _actions.setCurrentMissionIndex,
	            sendSaveMissions: _actions.sendSaveMissions,
	            failSaveMissions: _actions.failSaveMissions,
	            sendLoadMissions: _actions.sendLoadMissions,
	            failLoadMissions: _actions.failLoadMissions
	        }
	    },
	
	    data: function data() {
	        return {
	            currentView: 'listing',
	            overflowMenu: [{ id: 'save', text: 'Save to server' }, { id: 'load', text: 'Load from server' }, { id: 'sep1', text: '', type: 'divider' }, { id: 'export', text: 'Export to file' }, { id: 'import', text: 'Import from file' }, { id: 'sep2', text: '', type: 'divider' }, { id: 'clear', text: 'Clear all' }]
	        };
	    },
	
	
	    methods: {
	        selectMission: function selectMission(index) {
	            this.setCurrentMissionIndex(index);
	            this.currentView = 'gcs-mission';
	        },
	        showListingView: function showListingView() {
	            this.currentView = 'listing';
	            this.setCurrentMissionIndex(-1);
	        },
	        addMission: function addMission() {
	            this.missions.push({
	                title: 'Mission ' + (this.missions.length + 1),
	                description: null,
	                waypoints: []
	            });
	        },
	        menuOptionSelected: function menuOptionSelected(option) {
	            var _this = this;
	
	            switch (option.id) {
	                case 'save':
	                    {
	                        this.sendSaveMissions(this.missions);
	                        setTimeout(function () {
	                            if (_this.saveMissionsState == _this.WAITING) {
	                                _this.failSaveMissions('Timeout reached.');
	                            }
	                        }, 1000);
	                        break;
	                    }
	                case 'load':
	                    {
	                        this.sendLoadMissions(this.missions);
	                        setTimeout(function () {
	                            if (_this.loadMissionsState == _this.WAITING) {
	                                _this.failLoadMissions('Timeout reached.');
	                            }
	                        }, 1000);
	                        break;
	                    }
	                case 'import':
	                    {
	                        document.getElementById('import_missions_input').click();
	                        break;
	                    }
	                case 'export':
	                    {
	                        var uri = 'data:application/json,';
	                        uri += (0, _stringify2.default)(this.missions);
	                        uri = encodeURI(uri);
	
	                        var link = document.getElementById('export_missions_link');
	                        link.href = uri;
	                        link.download = 'missions.json';
	
	                        link.click();
	                        break;
	                    }
	                case 'clear':
	                    {
	                        this.setMissions([]);
	                    }
	            }
	        },
	        importMission: function importMission() {
	            var _this2 = this;
	
	            var files = document.getElementById('import_missions_input').files;
	
	            if (files.length > 0) {
	                var file = files[0];
	                var reader = new FileReader();
	
	                reader.onload = function (e) {
	                    var contents = e.target.result;
	                    try {
	                        var newMissions = JSON.parse(contents);
	
	                        _this2.setMissions(newMissions);
	                    } catch (e) {
	                        console.log('file contents are invalid: ' + e.message);
	                    }
	                };
	
	                reader.readAsText(file);
	            }
	        }
	    },
	
	    watch: {
	        saveMissionsState: function saveMissionsState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Missions saved.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to save missions: ' + this.saveMissionsData);
	                }
	            }
	        },
	        loadMissionsState: function loadMissionsState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    this.setMissions(this.loadMissionsData);
	                    console.log('Missions loaded.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to load missions: ' + this.loadMissionsData);
	                }
	            }
	        }
	    },
	
	    events: {
	        'delete-mission': function deleteMission(index) {
	            this.missions.splice(index, 1);
	        }
	    },
	
	    components: {
	        GcsMission: _GcsMission2.default,
	        GcsMissionRow: _GcsMissionRow2.default
	    }
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(36)
	__vue_script__ = __webpack_require__(37)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsMission.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(49)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-b5eeecb6/GcsMission.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 36 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsWaypoint = __webpack_require__(38);
	
	var _GcsWaypoint2 = _interopRequireDefault(_GcsWaypoint);
	
	var _GcsWaypointLink = __webpack_require__(44);
	
	var _GcsWaypointLink2 = _interopRequireDefault(_GcsWaypointLink);
	
	var _elementScroll = __webpack_require__(42);
	
	var _elementScroll2 = _interopRequireDefault(_elementScroll);
	
	var _numberToLetter = __webpack_require__(48);
	
	var _numberToLetter2 = _interopRequireDefault(_numberToLetter);
	
	var _actions = __webpack_require__(20);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            mapEditing: _getters.getMapEditing
	        },
	
	        actions: {
	            setMapEditing: _actions.setMapEditing
	        }
	    },
	
	    props: {
	        mission: {
	            type: Object,
	            required: true
	        }
	    },
	
	    data: function data() {
	        return {
	            waypointsVisible: true,
	            overflowMenu: [{ id: 'edit', text: 'Edit mission' }, { id: 'delete', text: 'Delete mission' }]
	        };
	    },
	    ready: function ready() {
	        this.setMapEditing(true);
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.setMapEditing(false);
	    },
	
	
	    events: {
	        'map:click': function mapClick(e) {
	            var _this = this;
	
	            if (!this.mapEditing) {
	                return;
	            }
	
	            var lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            var lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	
	            var newWaypoint = {
	                title: null,
	                type: 'normal',
	                visible: true,
	                position: {
	                    lat: lat,
	                    lng: lng
	                }
	            };
	
	            this.mission.waypoints.push(newWaypoint);
	
	            this.$nextTick(function () {
	                _elementScroll2.default.scrollToEnd(_this.$els.pageContent);
	            });
	        },
	        'map:dblclick': function mapDblclick(e) {
	            console.log('Map double clicked', e);
	        },
	        'map:rightclick': function mapRightclick(e) {
	            console.log('Map right-clicked', e);
	        },
	        'waypoint:drag': function waypointDrag(index, lat, lng) {
	            this.mission.waypoints[index].position.lat = lat;
	            this.mission.waypoints[index].position.lng = lng;
	
	            this.$broadcast('waypointLink:drag_start', index, lat, lng);
	            var nextIndex = index > 0 ? index - 1 : this.mission.waypoints.length - 1;
	            this.$broadcast('waypointLink:drag_end', nextIndex, lat, lng);
	        },
	        'waypointLink:click': function waypointLinkClick(index, lat, lng) {
	            if (!this.mapEditing) {
	                return;
	            }
	
	            var newWaypoint = {
	                title: null,
	                type: 'normal',
	                visible: true,
	                position: {
	                    lat: lat,
	                    lng: lng
	                }
	            };
	            this.mission.waypoints.splice(index + 1, 0, newWaypoint);
	        }
	    },
	
	    methods: {
	        goBack: function goBack() {
	            this.$dispatch('go-back');
	        },
	        toLetter: function toLetter(number) {
	            return (0, _numberToLetter2.default)(number);
	        },
	        toggleWaypointVisibility: function toggleWaypointVisibility() {
	            var _this2 = this;
	
	            this.waypointsVisible = !this.waypointsVisible;
	
	            this.mission.waypoints = this.mission.waypoints.map(function (waypoint) {
	                waypoint.visible = _this2.waypointsVisible;
	
	                return waypoint;
	            });
	
	            this.setMapEditing(this.waypointsVisible);
	        },
	        deleteWaypoint: function deleteWaypoint(index) {
	            this.mission.waypoints.splice(index, 1);
	        },
	        clearWaypoints: function clearWaypoints() {
	            this.mission.waypoints = [];
	
	            this.waypointsVisible = true;
	            this.setMapEditing(true);
	        }
	    },
	
	    components: {
	        GcsWaypoint: _GcsWaypoint2.default,
	        GcsWaypointLink: _GcsWaypointLink2.default
	    }
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(39)
	__vue_script__ = __webpack_require__(40)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsWaypoint.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(43)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-00e23ea5/GcsWaypoint.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 39 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(41);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	var _elementScroll = __webpack_require__(42);
	
	var _elementScroll2 = _interopRequireDefault(_elementScroll);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        index: Number,
	        label: {
	            type: String,
	            coerce: String
	        },
	        title: {
	            type: String,
	            coerce: function coerce(value) {
	                return value ? String(value) : '';
	            }
	        },
	        type: {
	            type: String,
	            default: 'normal'
	        }
	    },
	
	    data: function data() {
	        return {
	            dragging: false,
	            highlighted: false,
	            fillColor: { normal: 'yellow', hover: 'lime' }
	        };
	    },
	
	
	    events: {
	        click: function click() {
	            _elementScroll2.default.scrollIntoView(this.$el, null, 56);
	        },
	        rightclick: function rightclick() {
	            this.$dispatch('delete');
	        },
	        drag: function drag(e) {
	            this.lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            this.lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	            this.$dispatch('waypoint:drag', this.index, this.lat, this.lng);
	        },
	        mouseover: function mouseover() {
	            this.highlighted = true;
	            if (this.marker) {
	                this.marker.setIcon(this.getIcon(this.fillColor.hover));
	            }
	        },
	        mouseout: function mouseout() {
	            this.highlighted = false;
	            if (this.marker && !this.dragging) {
	                this.marker.setIcon(this.getIcon(this.fillColor.normal));
	            }
	        },
	        dragstart: function dragstart() {
	            this.dragging = true;
	        },
	        dragend: function dragend() {
	            this.dragging = false;
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var fillColor = arguments.length <= 0 || arguments[0] === undefined ? this.fillColor.normal : arguments[0];
	            var scale = arguments.length <= 1 || arguments[1] === undefined ? this.scale : arguments[1];
	            var rotation = arguments.length <= 2 || arguments[2] === undefined ? this.rotation : arguments[2];
	
	            return {
	                path: google.maps.SymbolPath.CIRCLE,
	                rotation: rotation,
	                scale: scale,
	                fillColor: fillColor,
	                fillOpacity: 1,
	                strokeColor: 'white',
	                strokeWeight: 2
	            };
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapEl: _getters.getMapEl,
	            mapLoaded: _getters.getMapLoaded
	        }
	    },
	
	    props: {
	        title: String,
	        lat: {
	            type: Number,
	            required: true
	        },
	        lng: {
	            type: Number,
	            required: true
	        },
	        rotation: {
	            type: Number,
	            default: 0
	        },
	        scale: {
	            type: Number,
	            default: 6
	        },
	        visible: {
	            type: Boolean,
	            default: true
	        },
	        draggable: {
	            type: Boolean,
	            default: false
	        }
	    },
	
	    data: function data() {
	        return {
	            marker: null
	        };
	    },
	
	
	    computed: {
	        position: function position() {
	            return {
	                lat: this.lat,
	                lng: this.lng
	            };
	        }
	    },
	
	    ready: function ready() {
	        if (this.mapLoaded) {
	            this.initializeMarker();
	        }
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.marker.setMap(null);
	        this.marker = null;
	    },
	
	
	    watch: {
	        mapLoaded: function mapLoaded(newVal, oldVal) {
	            if (!oldVal && newVal && !this.marker) {
	                this.initializeMarker();
	            }
	        },
	        map: function map() {
	            if (this.marker) {
	                this.marker.setMap(this.map);
	            }
	        },
	        title: function title() {
	            if (this.marker) {
	                this.marker.setTitle(this.title);
	            }
	        },
	        label: function label() {
	            if (this.marker) {
	                this.marker.setLabel(this.label);
	            }
	        },
	        position: function position() {
	            if (this.marker) {
	                this.marker.setPosition(this.position);
	            }
	        },
	        visible: function visible() {
	            if (this.marker) {
	                this.marker.setVisible(this.visible);
	            }
	        },
	        draggable: function draggable() {
	            if (this.marker) {
	                this.marker.setDraggable(this.draggable);
	            }
	        },
	        rotation: function rotation() {
	            this.updateIcon();
	        },
	        scale: function scale() {
	            this.updateIcon();
	        }
	    },
	
	    methods: {
	        initializeMarker: function initializeMarker() {
	            this.marker = new google.maps.Marker({
	                position: this.position,
	                icon: this.getIcon(),
	                draggable: this.draggable,
	                visible: this.visible,
	                map: this.map
	            });
	
	            if (this.title) {
	                this.marker.setTitle(this.title);
	            }
	
	            if (this.label) {
	                this.marker.setLabel(this.label);
	            }
	
	            this.$dispatch('initialized', this.marker);
	
	            this.setupEvents();
	        },
	        updateIcon: function updateIcon() {
	            if (this.marker) {
	                this.marker.setIcon(this.getIcon());
	            }
	        },
	        setupEvents: function setupEvents() {
	            var _this = this;
	
	            this.marker.addListener('click', function (e) {
	                _this.$dispatch('click', e);
	            });
	
	            this.marker.addListener('dblclick', function (e) {
	                _this.$dispatch('dblclick', e);
	            });
	
	            this.marker.addListener('rightclick', function (e) {
	                _this.$dispatch('rightclick', e);
	            });
	
	            this.marker.addListener('mouseover', function (e) {
	                _this.$dispatch('mouseover', e);
	            });
	
	            this.marker.addListener('mouseout', function (e) {
	                _this.$dispatch('mouseout', e);
	            });
	
	            this.marker.addListener('dragstart', function (e) {
	                _this.$dispatch('dragstart', e);
	            });
	
	            this.marker.addListener('drag', function (e) {
	                _this.$dispatch('drag', e);
	            });
	
	            this.marker.addListener('dragend', function (e) {
	                _this.$dispatch('dragend', e);
	            });
	
	            this.marker.addListener('position_changed', function (e) {
	                _this.$dispatch('position_changed', e);
	            });
	        }
	    }
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.inView = inView;
	exports.scrollIntoView = scrollIntoView;
	exports.scrollToStart = scrollToStart;
	exports.scrollToEnd = scrollToEnd;
	function inView(element, container) {
	    if (!element) {
	        return;
	    }
	
	    container = container || element.parentElement;
	
	    var top = element.offsetTop;
	    var parentTop = container.scrollTop;
	    var bottom = top + element.offsetHeight;
	    var parentBottom = container.offsetHeight;
	
	    return top >= parentTop && bottom <= parentBottom;
	}
	
	function scrollIntoView(element, container) {
	    var marginTop = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    if (!element || inView(element, container)) {
	        return;
	    }
	
	    container = container || element.parentElement;
	
	    container.scrollTop = element.offsetTop - marginTop;
	}
	
	function scrollToStart(element) {
	    if (!element) {
	        return;
	    }
	
	    element.scrollTop = 0;
	}
	
	function scrollToEnd(element) {
	    if (!element) {
	        return;
	    }
	
	    element.scrollTop = element.scrollHeight;
	}
	
	exports.default = {
	    inView: inView,
	    scrollIntoView: scrollIntoView,
	    scrollToStart: scrollToStart,
	    scrollToEnd: scrollToEnd
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-waypoint\" :class=\"{ 'highlighted': (dragging || highlighted) }\">\n    <div class=\"number\" v-text=\"index + 1\"></div>\n\n    <div class=\"content\">\n        <div class=\"row\">\n            <ui-textbox\n                class=\"column\" label=\"Title\" name=\"title\" :value.sync=\"title\"\n            ></ui-textbox>\n        </div>\n\n        <div class=\"row\">\n            <ui-textbox\n                class=\"column one-half\" label=\"Latitude\" name=\"latitude\" :value.sync=\"lat\"\n                type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n\n            <ui-textbox\n                class=\"column one-half\" label=\"Longitude\" name=\"longitude\" :value.sync=\"lng\"\n                type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n        </div>\n\n        <div class=\"row\">\n            <ui-select\n                class=\"column one-half\" label=\"Type\" name=\"type\" :value.sync=\"type\"\n                :options=\"[{ text: 'Normal', value: 'normal' }]\" :default=\"type\"\n            ></ui-select>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(45)
	__vue_script__ = __webpack_require__(46)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsWaypointLink.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(47)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-b8581182/GcsWaypointLink.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 45 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapLoaded: _getters.getMapLoaded
	        }
	    },
	
	    props: {
	        index: {
	            type: Number,
	            required: true
	        },
	        start: {
	            type: Object,
	            required: true
	        },
	        end: {
	            type: Object,
	            required: true
	        },
	        visible: {
	            type: Boolean,
	            default: true
	        }
	    },
	
	    data: function data() {
	        return {
	            link: null,
	            strokeColor: { normal: 'black', hover: 'green' }
	        };
	    },
	    ready: function ready() {
	        if (this.mapLoaded) {
	            this.initializeLink();
	        }
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.link.setMap(null);
	        this.link = null;
	    },
	
	
	    watch: {
	        mapLoaded: function mapLoaded(newVal, oldVal) {
	            if (!oldVal && newVal && !this.link) {
	                this.initializeLink();
	            }
	        },
	        map: function map() {
	            if (this.link) {
	                this.link.setMap(this.map);
	            }
	        },
	        start: function start() {
	            if (this.link) {
	                this.link.getPath().setAt(0, new google.maps.LatLng(this.start.lat, this.start.lng));
	            }
	        },
	        end: function end() {
	            if (this.link) {
	                this.link.getPath().setAt(1, new google.maps.LatLng(this.end.lat, this.end.lng));
	            }
	        }
	    },
	
	    methods: {
	        initializeLink: function initializeLink() {
	            var _this = this;
	
	            this.link = new google.maps.Polyline({
	                path: [this.start, this.end],
	                strokeColor: this.strokeColor.normal,
	                strokeOpacity: 1,
	                strokeWeight: 3,
	                visible: this.visible,
	                map: this.map
	            });
	            this.link.addListener('click', function (e) {
	                var lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	                var lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	                _this.$dispatch('waypointLink:click', _this.index, lat, lng);
	            });
	            this.link.addListener('mouseover', function () {
	                if (_this.link) {
	                    _this.link.setOptions({ strokeColor: _this.strokeColor.hover });
	                }
	            });
	            this.link.addListener('mouseout', function () {
	                if (_this.link) {
	                    _this.link.setOptions({ strokeColor: _this.strokeColor.normal });
	                }
	            });
	        }
	    },
	
	    events: {
	        'waypointLink:drag_start': function waypointLinkDrag_start(index, lat, lng) {
	            if (this.index == index) {
	                this.start = { lat: lat, lng: lng };
	            } else {
	                return true;
	            }
	        },
	        'waypointLink:drag_end': function waypointLinkDrag_end(index, lat, lng) {
	            if (this.index == index) {
	                this.end = { lat: lat, lng: lng };
	            } else {
	                return true;
	            }
	        }
	    }
	};

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-waypoint-link\"></div>\n";

/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (number) {
	    if (number > 52) {
	        return '0';
	    }
	
	    var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
	
	    return alphabet[number - 1];
	};

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-mission\">\n    <ui-toolbar :title=\"mission.title\" hide-nav-icon show-brand :show-brand-divider=\"false\">\n        <div slot=\"brand\">\n            <ui-icon-button\n                @click=\"goBack\" type=\"clear\" icon=\"arrow_back\" tooltip=\"Back to Missions\"\n                tooltip-position=\"bottom left\"\n            ></ui-icon-button>\n        </div>\n\n        <div slot=\"actions\">\n            <ui-icon-button\n                type=\"clear\" icon=\"file_upload\" tooltip=\"Upload Mission\" @click=\"uploadMission\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" icon=\"clear_all\" tooltip=\"Clear all\" @click=\"clearWaypoints\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" :icon=\"waypointsVisible ? 'visibility' : 'visibility_off'\"\n                @click=\"toggleWaypointVisibility\"\n                :tooltip=\"waypointsVisible ? 'Hide waypoints' : 'Show waypoints'\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" icon=\"more_vert\" has-dropdown-menu dropdown-position=\"bottom right\"\n                :menu-options=\"overflowMenu\"\n            ></ui-icon-button>\n        </div>\n    </ui-toolbar>\n\n    <div class=\"sidebar-page-content\" v-el:page-content>\n        <p\n            class=\"no-waypoints\" v-if=\"!mission.waypoints.length\"\n        >No waypoints for this mission. Click the map to add a waypoint.</p>\n\n        <component v-else>\n            <gcs-waypoint\n                v-for=\"(index, waypoint) in mission.waypoints\" :index=\"index\"\n                :label=\"toLetter(index + 1)\" :title=\"waypoint.title\" :type=\"waypoint.type\"\n                :lat=\"waypoint.position.lat\" :lng=\"waypoint.position.lng\" :visible=\"waypoint.visible\"\n                :rotation=\"waypoint.rotation\" :scale=\"10\" draggable\n                @delete=\"deleteWaypoint(index)\"\n            ></gcs-waypoint>\n            <gcs-waypoint-link\n                v-for=\"(index, waypoint) in mission.waypoints\"\n                :index=\"index\"\n                :start=\"waypoint.position\"\n                :end=\"mission.waypoints[(index+1) % mission.waypoints.length].position;\"\n            ></gcs-waypoint-link>\n        </component>\n    </div>\n</div>\n";

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(51)
	__vue_script__ = __webpack_require__(52)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsMissionRow.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(53)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-fe058db6/GcsMissionRow.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 51 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: {
	        mission: {
	            type: Object,
	            required: true
	        },
	        index: {
	            type: Number,
	            required: true
	        }
	    },
	
	    computed: {
	        hasWaypoints: function hasWaypoints() {
	            return this.mission.waypoints && this.mission.waypoints.length;
	        },
	        firstWaypoint: function firstWaypoint() {
	            return this.mission.waypoints[0];
	        },
	        lastWaypoint: function lastWaypoint() {
	            return this.mission.waypoints[this.mission.waypoints.length - 1];
	        }
	    },
	
	    methods: {
	        deleteMission: function deleteMission() {
	            this.$dispatch('delete-mission', this.index);
	        }
	    }
	};

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-mission-row\">\n    <ui-icon-button\n        type=\"clear\" icon=\"delete\" class=\"delete-button\" tooltip=\"Delete\" @click=\"deleteMission\"\n    ></ui-icon-button>\n\n    <h3 class=\"mission-header\" v-text=\"mission.title\"></h3>\n\n    <div class=\"mission-summary\">\n        <p class=\"description\" v-if=\"mission.description\" v-text=\"mission.description\"></p>\n\n        <p class=\"waypoints\" v-if=\"!mission.description && hasWaypoints\">\n            <span>From: ({{ firstWaypoint.position.lat }}, {{ firstWaypoint.position.lng }})</span>\n            <span>To: ({{ lastWaypoint.position.lat }}, {{ lastWaypoint.position.lng }})</span>\n        </p>\n\n        <p class=\"no-waypoints\" v-if=\"!mission.description && !hasWaypoints\">No waypoints</p>\n    </div>\n</div>\n";

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-missions\">\n    <div class=\"sidebar-page\">\n        <div class=\"missions-list\" v-if=\"currentView === 'listing'\">\n            <ui-toolbar title=\"Missions\" hide-nav-icon>\n                <div slot=\"actions\">\n                    <ui-icon-button\n                        type=\"clear\" icon=\"add\" tooltip=\"Add mission\" @click=\"addMission\"\n                    ></ui-icon-button>\n\n                    <ui-icon-button\n                        type=\"clear\" icon=\"more_vert\" has-dropdown-menu\n                        dropdown-position=\"bottom right\" :menu-options=\"overflowMenu\"\n                        @menu-option-selected=\"menuOptionSelected\"\n                    ></ui-icon-button>\n                </div>\n            </ui-toolbar>\n\n            <div class=\"sidebar-page-content\">\n                <div class=\"blank-state\" v-if=\"!missions.length\">No missions</div>\n\n                <gcs-mission-row\n                    v-for=\"(index, mission) in missions\" :index=\"index\" :mission=\"mission\"\n                    @click=\"selectMission(index)\"\n                ></gcs-mission-row>\n            </div>\n        </div>\n\n        <component\n            v-else :is=\"currentView\" :mission=\"currentMission\" @go-back=\"showListingView\"\n        ></component>\n    </div>\n</div>\n<!-- hidden input element used for selecting a file to import from -->\n<input type=\"file\" id=\"import_missions_input\" @change=\"importMission\">\n<!-- hidden link used for prompting a download -->\n<a id=\"export_missions_link\"></a>\n";

/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map-sidebar\" v-show=\"showSidebar\" transition=\"sidebar-collapse\">\n    <gcs-missions></gcs-missions>\n</div>\n";

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(57)
	__vue_script__ = __webpack_require__(58)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsSidebarControls.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(63)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-aa18170a/GcsSidebarControls.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 57 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsCommands = __webpack_require__(59);
	
	var _GcsCommands2 = _interopRequireDefault(_GcsCommands);
	
	var _getters = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            currentMissionIndex: _getters.getCurrentMissionIndex
	        }
	    },
	
	    props: {
	        showSidebar: {
	            type: Boolean,
	            required: true
	        }
	    },
	
	    methods: {
	        toggleSidebar: function toggleSidebar() {
	            this.$dispatch('toggle-sidebar');
	        }
	    },
	
	    components: {
	        GcsCommands: _GcsCommands2.default
	    }
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(60)
	__vue_script__ = __webpack_require__(61)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsCommands.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(62)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-4c2b1d8f/GcsCommands.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 60 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	var _actions = __webpack_require__(20);
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv,
	            missions: _getters.getMissions,
	            WAITING: _getters.getMessageStateWaiting,
	            SUCCESS: _getters.getMessageStateSuccess,
	            FAILURE: _getters.getMessageStateFailure,
	            currentMissionIndex: _getters.getCurrentMissionIndex,
	            uploadMissionState: _getters.getUploadMissionState,
	            uploadMissionData: _getters.getUploadMissionData,
	            downloadMissionState: _getters.getDownloadMissionState,
	            downloadMissionData: _getters.getDownloadMissionData,
	            startMissionState: _getters.getStartMissionState,
	            startMissionData: _getters.getStartMissionData,
	            stopMissionState: _getters.getStopMissionState,
	            stopMissionData: _getters.getStopMissionData,
	            resumeMissionState: _getters.getResumeMissionState,
	            resumeMissionData: _getters.getResumeMissionData,
	            armState: _getters.getArmState,
	            armData: _getters.getArmData,
	            disarmState: _getters.getDisarmState,
	            disarmData: _getters.getDisarmData,
	            killState: _getters.getKillState,
	            killData: _getters.getKillData,
	            unkillState: _getters.getUnkillState,
	            unkillData: _getters.getUnkillData
	        },
	
	        actions: {
	            setArmed: _actions.setWamvArmed,
	            setCurrentMission: _actions.setCurrentMission,
	            sendUploadMission: _actions.sendUploadMission,
	            failUploadMission: _actions.failUploadMission,
	            sendDownloadMission: _actions.sendDownloadMission,
	            failDownloadMission: _actions.failDownloadMission,
	            sendStartMission: _actions.sendStartMission,
	            failStartMission: _actions.failStartMission,
	            sendStopMission: _actions.sendStopMission,
	            failStopMission: _actions.failStopMission,
	            sendResumeMission: _actions.sendResumeMission,
	            failResumeMission: _actions.failResumeMission,
	            sendArm: _actions.sendArm,
	            failArm: _actions.failArm,
	            sendDisarm: _actions.sendDisarm,
	            failDisarm: _actions.failDisarm,
	            sendKill: _actions.sendKill,
	            failKill: _actions.failKill,
	            sendUnkill: _actions.sendUnkill,
	            failUnkill: _actions.failUnkill
	        }
	    },
	
	    computed: {
	        isArmed: {
	            get: function get() {
	                return this.wamv.armed;
	            },
	            set: function set(arm) {
	                var _this = this;
	
	                if (arm) {
	                    this.sendArm();
	                    setTimeout(function () {
	                        if (_this.armState == _this.WAITING) {
	                            _this.failArm('Timeout reached.');
	                        }
	                    }, 1000);
	                } else {
	                    this.sendDisarm();
	                    setTimeout(function () {
	                        if (_this.disarmState == _this.WAITING) {
	                            _this.failDisarm('Timeout reached.');
	                        }
	                    }, 1000);
	                }
	            }
	        }
	    },
	
	    methods: {
	        uploadMission: function uploadMission() {
	            var _this2 = this;
	
	            var mission = this.missions[this.currentMissionIndex];
	            this.sendUploadMission(mission);
	            setTimeout(function () {
	                if (_this2.uploadMissionState == _this2.WAITING) {
	                    _this2.failUploadMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        downloadMission: function downloadMission() {
	            var _this3 = this;
	
	            this.sendDownloadMission();
	            setTimeout(function () {
	                if (_this3.downloadMissionState == _this3.WAITING) {
	                    _this3.failDownloadMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        startMission: function startMission() {
	            var _this4 = this;
	
	            this.sendStartMission();
	            setTimeout(function () {
	                if (_this4.startMissionState == _this4.WAITING) {
	                    _this4.failStartMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        stopMission: function stopMission() {
	            var _this5 = this;
	
	            this.sendStopMission();
	            setTimeout(function () {
	                if (_this5.stopMissionState == _this5.WAITING) {
	                    _this5.failStopMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        resumeMission: function resumeMission() {
	            var _this6 = this;
	
	            this.sendResumeMission();
	            setTimeout(function () {
	                if (_this6.resumeMissionState == _this6.WAITING) {
	                    _this6.failResumeMission('Timeout reached.');
	                }
	            }, 1000);
	        },
	        kill: function kill() {
	            var _this7 = this;
	
	            this.sendKill();
	            setTimeout(function () {
	                if (_this7.killState == _this7.WAITING) {
	                    _this7.failKill('Timeout reached.');
	                }
	            }, 1000);
	        },
	        unkill: function unkill() {
	            var _this8 = this;
	
	            this.sendUnkill();
	            setTimeout(function () {
	                if (_this8.unkillState == _this8.WAITING) {
	                    _this8.failUnkill('Timeout reached.');
	                }
	            }, 1000);
	        }
	    },
	
	    watch: {
	        uploadMissionState: function uploadMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission uploaded.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to upload mission: ' + this.uploadMissionData);
	                }
	            }
	        },
	        downloadMissionState: function downloadMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission downloaded.');
	                    this.setCurrentMission(this.downloadMissionData);
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to download mission: ' + this.downloadMissionData);
	                }
	            }
	        },
	        startMissionState: function startMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission started.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to start mission: ' + this.startMissionData);
	                }
	            }
	        },
	        stopMissionState: function stopMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission stopped.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to stop mission: ' + this.stopMissionData);
	                }
	            }
	        },
	        resumeMissionState: function resumeMissionState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Mission resumed.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to resume mission: ' + this.resumeMissionData);
	                }
	            }
	        },
	        armState: function armState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Vehicle armed.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to arm vehicle: ' + this.armData);
	                }
	            }
	        },
	        disarmState: function disarmState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Vehicle disarmed.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to disarm vehicle: ' + this.disarmData);
	                }
	            }
	        },
	        killState: function killState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Kill switch activated.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to activate kill switch: ' + this.killData);
	                }
	            }
	        },
	        unkillState: function unkillState(state, oldState) {
	            if (state != oldState) {
	                if (state == this.SUCCESS) {
	                    console.log('Kill switch deactivated.');
	                } else if (state == this.FAILURE) {
	                    console.log('Unable to deactivate kill switch: ' + this.unkillData);
	                }
	            }
	        }
	    }
	};

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-commands\">\n    <div class=\"row\">\n        <ui-button @click=\"uploadMission\">Upload Mission</ui-button>\n    </div>\n\n    <div class=\"row\">\n        <ui-button @click=\"downloadMission\">Download Mission</ui-button>\n    </div>\n\n    <div class=\"row\">\n        <ui-button\n            v-if=\"wamv.mode == 'idle' || wamv.mode == 'paused'\"\n            @click=\"startMission\"\n        >Start</ui-button>\n        <ui-button\n            v-if=\"wamv.mode == 'paused'\"\n            @click=\"resumeMission\"\n        >Resume</ui-button>\n        <ui-button\n            v-if=\"wamv.mode == 'auto'\"\n            @click=\"stopMission\"\n        >Stop</ui-button>\n    </div>\n\n    <div class=\"row\" v-if=\"wamv.loaded\">\n        <div class=\"column one-half\"> {{ isArmed ? 'Armed' : 'Disarmed' }}</div>\n        <div class=\"column one-half\">\n            <ui-switch :value.sync=\"isArmed\"></ui-switch>\n        </div>\n    </div>\n\n    <div class=\"row\">\n        <ui-button color=\"danger\"\n            v-if=\"wamv.mode != 'killed'\" @click=\"kill\"\n        >Kill</ui-button>\n        <ui-button\n            v-if=\"wamv.mode == 'killed'\" @click=\"unkill\"\n        >Unkill</ui-button>\n    </div>\n</div>\n";

/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = "\n<div\n    class=\"gcs-sidebar-controls\"\n    :style=\"{ transform: 'translateX(' + (showSidebar ? '376px' : '16px' + ')') }\"\n>\n    <ui-button\n        :color=\"showSidebar ? 'primary' : 'default'\" @click=\"toggleSidebar\"\n    >Missions</ui-button>\n\n    <ui-button v-if=\"currentMissionIndex != -1\" has-popover text=\"Commands\">\n        <div slot=\"popover\" class=\"gcs-sidebar-controls-popover\">\n            <gcs-commands></gcs-commands>\n        </div>\n    </ui-button>\n</div>\n";

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(65)
	__vue_script__ = __webpack_require__(66)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsWamv.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(67)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-b5bab4d2/GcsWamv.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 65 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(41);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    events: {
	        click: function click(e) {
	            console.log('Wamv clicked', e);
	        },
	        initialized: function initialized() {
	            window.wamv = this;
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var scale = arguments.length <= 0 || arguments[0] === undefined ? this.scale : arguments[0];
	            var rotation = arguments.length <= 1 || arguments[1] === undefined ? this.rotation : arguments[1];
	
	            return {
	                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
	                rotation: rotation,
	                scale: scale,
	                fillColor: 'red',
	                fillOpacity: 0.8,
	                strokeColor: 'white',
	                strokeWeight: 2
	            };
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-wamv\"></div>\n";

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view map-view\">\n    <gcs-map></gcs-map>\n    <gcs-map-controls></gcs-map-controls>\n    <gcs-map-sidebar :show-sidebar=\"showSidebar\"></gcs-map-sidebar>\n\n    <gcs-sidebar-controls\n        :show-sidebar=\"showSidebar\" @toggle-sidebar=\"toggleSidebar\"\n    ></gcs-sidebar-controls>\n\n    <gcs-wamv v-if=\"wamv.loaded\"\n        :lat=\"wamv.position.lat\" :lng=\"wamv.position.lng\"\n        :rotation=\"wamv.heading\"\n    ></gcs-wamv>\n</div>\n";

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(70)
	__vue_script__ = __webpack_require__(71)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\views\\ParamsView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(72)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-04e87b4e/ParamsView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 70 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            parameters: _getters.getParameters
	        }
	    },
	
	    data: function data() {
	        return {};
	    },
	
	
	    methods: {
	        isArray: function isArray(x) {
	            return Array.isArray(x);
	        }
	    }
	};

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view params-view\">\n    <div class=\"page\">\n        <h1 class=\"page-header\">Params</h1>\n        <div class=\"page-content\">\n            <!-- display parameters (up to hierarchy depth 3) -->\n            <div v-for=\"(name, val) in parameters\">\n                <span v-if=\"isArray(val)\"\n                    v-text=\"name + ' (' + val[0] + '): ' + val[1]\"\n                ></span>\n                <div v-else>\n                    <span v-text=\"name\"></span>\n                    <div v-for=\"(name2, val2) in val\">\n                        <span v-if=\"isArray(val2)\"\n                            v-text=\"'> ' + name2 + ' (' + val2[0] + '): ' + val2[1]\"\n                        ></span>\n                        <div v-else>\n                            <span v-text=\"'> ' + name2\"></span>\n                            <div v-for=\"(name3, val3) in val2\">\n                                <span v-if=\"isArray(val3)\"\n                                    v-text=\"'> > ' + name3 + ' (' + val3[0] + '): ' + val3[1]\"\n                                ></span>\n                                <span v-else\n                                    v-text=\"'> > ' + name3 + ': ...'\">\n                                </span>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(74)
	__vue_script__ = __webpack_require__(75)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\views\\SettingsView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(76)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-a6e91b14/SettingsView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 74 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 75 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {};
	    }
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view settings-view\">\n    <div class=\"page\">\n        <h1 class=\"page-header\">Settings</h1>\n        <div class=\"page-content\">\n            Settings here\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(78)
	__vue_script__ = __webpack_require__(79)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\GcsIndicators.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(80)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-6cb0c7ea/GcsIndicators.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 78 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(23);
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    computed: {
	        heading: function heading() {
	            var deg = Math.round(this.wamv.heading);
	            return deg + '&deg; ' + this.degreeToToCardinal(this.wamv.heading);
	        },
	        speed: function speed() {
	            var spd = Math.round(this.wamv.speed * 100) / 100;
	            return this.wamv.speed + ' KMPH';
	        },
	        battery: function battery() {
	            var perc = Math.round(this.wamv.battery * 100) / 100;
	            return perc + '%';
	        },
	        signal: function signal() {
	            var perc = Math.round(this.wamv.signal * 100) / 100;
	            return perc + '%';
	        }
	    },
	
	    methods: {
	        degreeToToCardinal: function degreeToToCardinal(degree) {
	            if (degree < 22.5 || degree >= 337.5) {
	                return 'N';
	            }
	
	            if (degree < 67.5 || degree >= 22.5) {
	                return 'NE';
	            }
	
	            if (degree < 112.5 || degree >= 67.5) {
	                return 'E';
	            }
	
	            if (degree < 157.5 || degree >= 112.5) {
	                return 'SE';
	            }
	
	            if (degree < 202.5 || degree >= 157.5) {
	                return 'S';
	            }
	
	            if (degree < 247.5 || degree >= 202.5) {
	                return 'SW';
	            }
	
	            if (degree < 292.5 || degree >= 247.5) {
	                return 'W';
	            }
	
	            if (degree < 337.5 || degree >= 292.5) {
	                return 'NW';
	            }
	
	            return '';
	        }
	    }
	};

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "\n<ul class=\"gcs-indicators\" v-if=\"wamv.loaded\">\n    <li class=\"indicator heading\">\n        <ui-icon\n            icon=\"navigation\" :style=\"{ transform: 'rotateZ(' + wamv.heading + 'deg)' }\"\n        ></ui-icon>\n        <span class=\"value\" v-html=\"heading\"></span>\n    </li>\n\n    <li class=\"indicator speed\">\n        <ui-icon icon=\"network_check\"></ui-icon>\n        <span class=\"value\" v-text=\"speed\"></span>\n    </li>\n\n    <li class=\"indicator battery\">\n        <ui-icon icon=\"battery_full\"></ui-icon>\n        <span class=\"value\" v-text=\"battery\"></span>\n    </li>\n\n    <li class=\"indicator signal\">\n        <ui-icon icon=\"wifi\"></ui-icon>\n        <span class=\"value\" v-text=\"signal\"></span>\n    </li>\n</ul>\n";

/***/ },
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(85);
	var parser = __webpack_require__(90);
	var Manager = __webpack_require__(98);
	var debug = __webpack_require__(87)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] ||
	                      false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(98);
	exports.Socket = __webpack_require__(126);


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(86);
	var debug = __webpack_require__(87)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc){
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
	
	  return obj;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(88);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(89);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(87)('socket.io-parser');
	var json = __webpack_require__(91);
	var isArray = __webpack_require__(94);
	var Emitter = __webpack_require__(95);
	var binary = __webpack_require__(96);
	var isBuf = __webpack_require__(97);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(93);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)(module), (function() { return this; }())))

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 93 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 95 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(94);
	var isBuf = __webpack_require__(97);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 97 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(99);
	var Socket = __webpack_require__(126);
	var Emitter = __webpack_require__(127);
	var parser = __webpack_require__(90);
	var on = __webpack_require__(129);
	var bind = __webpack_require__(130);
	var debug = __webpack_require__(87)('socket.io-client:manager');
	var indexOf = __webpack_require__(124);
	var Backoff = __webpack_require__(133);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function(){
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function(){
	  this.lastPing = new Date;
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function(){
	  this.emitAll('pong', new Date - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function(){
	  debug('cleanup');
	
	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();
	
	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' == this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function(reason){
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(100);


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(101);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(108);


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(102);
	var Emitter = __webpack_require__(117);
	var debug = __webpack_require__(87)('engine.io-client:socket');
	var index = __webpack_require__(124);
	var parser = __webpack_require__(108);
	var parseuri = __webpack_require__(86);
	var parsejson = __webpack_require__(125);
	var parseqs = __webpack_require__(118);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop(){}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(107);
	Socket.transports = __webpack_require__(102);
	Socket.parser = __webpack_require__(108);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose(){
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function(){
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function() {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(103);
	var XHR = __webpack_require__(105);
	var JSONP = __webpack_require__(121);
	var websocket = __webpack_require__(122);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(104);
	
	module.exports = function(opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }
	
	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 104 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(103);
	var Polling = __webpack_require__(106);
	var Emitter = __webpack_require__(117);
	var inherit = __webpack_require__(119);
	var debug = __webpack_require__(87)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty(){}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts){
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }
	
	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function(){
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(107);
	var parseqs = __webpack_require__(118);
	var parser = __webpack_require__(108);
	var inherit = __webpack_require__(119);
	var yeast = __webpack_require__(120);
	var debug = __webpack_require__(87)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(103);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function(){
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function(){
	  var self = this;
	
	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(108);
	var Emitter = __webpack_require__(117);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(109);
	var hasBinary = __webpack_require__(110);
	var sliceBuffer = __webpack_require__(112);
	var base64encoder = __webpack_require__(113);
	var after = __webpack_require__(114);
	var utf8 = __webpack_require__(115);
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = navigator.userAgent.match(/Android/i);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(116);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if(numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 109 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(111);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 112 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
	
	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 113 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = after
	
	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count
	
	    return (count === 0) ? callback() : proxy
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}
	
	function noop() {}


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)(module), (function() { return this; }())))

/***/ },
/* 116 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      ary[i] = buf;
	    }
	  }
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);
	
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};
	
	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 117 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 119 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 120 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;
	
	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(106);
	var inherit = __webpack_require__(119);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  }
	  else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch(e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(107);
	var parser = __webpack_require__(108);
	var parseqs = __webpack_require__(118);
	var inherit = __webpack_require__(119);
	var yeast = __webpack_require__(120);
	var debug = __webpack_require__(87)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(123);
	  } catch (e) { }
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	
	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function(){
	  var self = this;
	
	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function(packet) {
	      parser.encodePacket(packet, self.supportsBinary, function(data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e){
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done(){
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function(){
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 124 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 125 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(90);
	var Emitter = __webpack_require__(127);
	var toArray = __webpack_require__(128);
	var on = __webpack_require__(129);
	var bind = __webpack_require__(130);
	var debug = __webpack_require__(87)('socket.io-client:socket');
	var hasBin = __webpack_require__(131);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function() {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  delete this.flags;
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function(packet){
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function(compress){
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};


/***/ },
/* 127 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = toArray
	
	function toArray(list, index) {
	    var array = []
	
	    index = index || 0
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }
	
	    return array
	}


/***/ },
/* 129 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(132);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 133 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ },
/* 134 */,
/* 135 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-app\">\n    <ui-tabs\n        class=\"main-tab-container\" background-color=\"dark\" text-color=\"light\"\n        indicator-color=\"transparent\"\n    >\n        <ui-tab header=\"Map\">\n            <map-view></map-view>\n        </ui-tab>\n\n        <ui-tab header=\"Params\">\n            <params-view></params-view>\n        </ui-tab>\n\n        <ui-tab header=\"Settings\">\n            <settings-view></settings-view>\n        </ui-tab>\n    </ui-tabs>\n\n    <gcs-indicators></gcs-indicators>\n\n    <ui-snackbar-container position=\"center\"></ui-snackbar-container>\n</div>\n\n<!-- <socket-io-manager></socket-io-manager> -->\n";

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vuex = __webpack_require__(137);
	
	var _vuex2 = _interopRequireDefault(_vuex);
	
	var _config = __webpack_require__(138);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vuex2.default);
	
	var initialState = {
	    map: null,
	    mapEl: null,
	    mapLoaded: false,
	    mapEditing: false,
	    wamv: {
	        loaded: false,
	        position: { lat: -32.8883338, lng: 151.7075279 },
	        heading: 0,
	        speed: 0,
	        battery: 100,
	        armed: false,
	        mode: 'idle',
	        signal: 100
	    },
	    config: _config2.default,
	    settings: _config2.default.settings,
	    settingsLoaded: false,
	    missions: [],
	    currentMissionIndex: -1,
	    parameters: {},
	    messageState: {
	        INITIAL: 0,
	        WAITING: 1,
	        SUCCESS: 2,
	        FAILURE: 3,
	
	        get_parameters: [0, null],
	        set_parameter: [0, null],
	        save_missions: [0, null],
	        load_missions: [0, null],
	        upload_mission: [0, null],
	        download_mission: [0, null],
	        arm: [0, null],
	        disarm: [0, null],
	        start_mission: [0, null],
	        stop_mission: [0, null],
	        resume_mission: [0, null],
	        kill: [0, null],
	        unkill: [0, null]
	    }
	};
	
	var mutations = {
	    SET_MAP: function SET_MAP(state, map) {
	        state.map = map;
	    },
	    SET_MAP_EL: function SET_MAP_EL(state, mapEl) {
	        state.mapEl = mapEl;
	    },
	    SET_MAP_LOADED: function SET_MAP_LOADED(state, loaded) {
	        state.mapLoaded = loaded;
	    },
	    SET_MAP_EDITING: function SET_MAP_EDITING(state, editing) {
	        state.mapEditing = editing;
	    },
	    UPDATE_WAMV_POSITION: function UPDATE_WAMV_POSITION(state, position) {
	        state.wamv.position = position;
	    },
	    SET_WAMV: function SET_WAMV(state, wamv) {
	        state.wamv = wamv;
	    },
	    SET_WAMV_ARMED: function SET_WAMV_ARMED(state, armed) {
	        state.wamv.armed = armed;
	    },
	    SET_WAMV_MODE: function SET_WAMV_MODE(state, mode) {
	        state.wamv.mode = mode;
	    },
	    INIT_SETTINGS: function INIT_SETTINGS(state, settings) {
	        state.settings = settings;
	        state.settingsLoaded = true;
	    },
	    UPDATE_SETTINGS: function UPDATE_SETTINGS(state, settings) {
	        state.settings = settings;
	    },
	    SET_MISSIONS: function SET_MISSIONS(state, missions) {
	        state.missions = missions;
	    },
	    SET_CURRENT_MISSION_INDEX: function SET_CURRENT_MISSION_INDEX(state, index) {
	        state.currentMissionIndex = index;
	    },
	    SET_CURRENT_MISSION: function SET_CURRENT_MISSION(state, mission) {
	        state.missions.$set(state.currentMissionIndex, mission);
	    },
	    SET_PARAMETERS: function SET_PARAMETERS(state, parameters) {
	        state.parameters = parameters;
	    },
	    SEND_GET_PARAMETERS: function SEND_GET_PARAMETERS(state) {
	        state.messageState.get_parameters.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_GET_PARAMETERS: function SUCCEED_GET_PARAMETERS(state, parameters) {
	        state.messageState.get_parameters.$set(0, state.messageState.SUCCESS);
	        state.messageState.get_parameters.$set(1, parameters);
	    },
	    FAIL_GET_PARAMETERS: function FAIL_GET_PARAMETERS(state, msg) {
	        state.messageState.get_parameters.$set(0, state.messageState.FAILURE);
	        state.messageState.get_parameters.$set(1, msg);
	    },
	    SEND_SAVE_MISSIONS: function SEND_SAVE_MISSIONS(state, missions) {
	        state.messageState.save_missions.$set(0, state.messageState.WAITING);
	        state.messageState.save_missions.$set(1, missions);
	    },
	    SUCCEED_SAVE_MISSIONS: function SUCCEED_SAVE_MISSIONS(state) {
	        state.messageState.save_missions.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_SAVE_MISSIONS: function FAIL_SAVE_MISSIONS(state, msg) {
	        state.messageState.save_missions.$set(0, state.messageState.FAILURE);
	        state.messageState.save_missions.$set(1, msg);
	    },
	    SEND_LOAD_MISSIONS: function SEND_LOAD_MISSIONS(state) {
	        state.messageState.load_missions.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_LOAD_MISSIONS: function SUCCEED_LOAD_MISSIONS(state, missions) {
	        state.messageState.load_missions.$set(0, state.messageState.SUCCESS);
	        state.messageState.load_missions.$set(1, missions);
	    },
	    FAIL_LOAD_MISSIONS: function FAIL_LOAD_MISSIONS(state, msg) {
	        state.messageState.load_missions.$set(0, state.messageState.FAILURE);
	        state.messageState.load_missions.$set(1, msg);
	    },
	    SEND_UPLOAD_MISSION: function SEND_UPLOAD_MISSION(state, mission) {
	        state.messageState.upload_mission.$set(0, state.messageState.WAITING);
	        state.messageState.upload_mission.$set(1, mission);
	    },
	    SUCCEED_UPLOAD_MISSION: function SUCCEED_UPLOAD_MISSION(state) {
	        state.messageState.upload_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_UPLOAD_MISSION: function FAIL_UPLOAD_MISSION(state, msg) {
	        state.messageState.upload_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.upload_mission.$set(1, msg);
	    },
	    SEND_DOWNLOAD_MISSION: function SEND_DOWNLOAD_MISSION(state) {
	        state.messageState.download_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_DOWNLOAD_MISSION: function SUCCEED_DOWNLOAD_MISSION(state, mission) {
	        state.messageState.download_mission.$set(0, state.messageState.SUCCESS);
	        state.messageState.download_mission.$set(1, mission);
	    },
	    FAIL_DOWNLOAD_MISSION: function FAIL_DOWNLOAD_MISSION(state, msg) {
	        state.messageState.download_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.download_mission.$set(1, msg);
	    },
	    SEND_START_MISSION: function SEND_START_MISSION(state) {
	        state.messageState.start_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_START_MISSION: function SUCCEED_START_MISSION(state) {
	        state.messageState.start_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_START_MISSION: function FAIL_START_MISSION(state, msg) {
	        state.messageState.start_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.start_mission.$set(1, msg);
	    },
	    SEND_STOP_MISSION: function SEND_STOP_MISSION(state) {
	        state.messageState.stop_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_STOP_MISSION: function SUCCEED_STOP_MISSION(state) {
	        state.messageState.stop_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_STOP_MISSION: function FAIL_STOP_MISSION(state, msg) {
	        state.messageState.stop_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.stop_mission.$set(1, msg);
	    },
	    SEND_RESUME_MISSION: function SEND_RESUME_MISSION(state) {
	        state.messageState.resume_mission.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_RESUME_MISSION: function SUCCEED_RESUME_MISSION(state) {
	        state.messageState.resume_mission.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_RESUME_MISSION: function FAIL_RESUME_MISSION(state, msg) {
	        state.messageState.resume_mission.$set(0, state.messageState.FAILURE);
	        state.messageState.resume_mission.$set(1, msg);
	    },
	    SEND_ARM: function SEND_ARM(state) {
	        state.messageState.arm.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_ARM: function SUCCEED_ARM(state) {
	        state.messageState.arm.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_ARM: function FAIL_ARM(state, msg) {
	        state.messageState.arm.$set(0, state.messageState.FAILURE);
	        state.messageState.arm.$set(1, msg);
	    },
	    SEND_DISARM: function SEND_DISARM(state) {
	        state.messageState.disarm.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_DISARM: function SUCCEED_DISARM(state) {
	        state.messageState.disarm.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_DISARM: function FAIL_DISARM(state, msg) {
	        state.messageState.disarm.$set(0, state.messageState.FAILURE);
	        state.messageState.disarm.$set(1, msg);
	    },
	    SEND_KILL: function SEND_KILL(state) {
	        state.messageState.kill.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_KILL: function SUCCEED_KILL(state) {
	        state.messageState.kill.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_KILL: function FAIL_KILL(state, msg) {
	        state.messageState.kill.$set(0, state.messageState.FAILURE);
	        state.messageState.kill.$set(1, msg);
	    },
	    SEND_UNKILL: function SEND_UNKILL(state) {
	        state.messageState.unkill.$set(0, state.messageState.WAITING);
	    },
	    SUCCEED_UNKILL: function SUCCEED_UNKILL(state) {
	        state.messageState.unkill.$set(0, state.messageState.SUCCESS);
	    },
	    FAIL_UNKILL: function FAIL_UNKILL(state, msg) {
	        state.messageState.unkill.$set(0, state.messageState.FAILURE);
	        state.messageState.unkill.$set(1, msg);
	    }
	};
	
	exports.default = new _vuex2.default.Store({
	    state: initialState,
	    mutations: mutations
	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Vuex v1.0.0-rc
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Vuex = factory());
	}(this, function () { 'use strict';
	
	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
	  };
	
	  var classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  };
	
	  var createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }
	
	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();
	
	  var toConsumableArray = function (arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
	
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  };
	
	  /**
	   * Merge an array of objects into one.
	   *
	   * @param {Array<Object>} arr
	   * @return {Object}
	   */
	
	  function mergeObjects(arr) {
	    return arr.reduce(function (prev, obj) {
	      Object.keys(obj).forEach(function (key) {
	        var existing = prev[key];
	        if (existing) {
	          // allow multiple mutation objects to contain duplicate
	          // handlers for the same mutation type
	          if (Array.isArray(existing)) {
	            prev[key] = existing.concat(obj[key]);
	          } else {
	            prev[key] = [existing].concat(obj[key]);
	          }
	        } else {
	          prev[key] = obj[key];
	        }
	      });
	      return prev;
	    }, {});
	  }
	
	  /**
	   * Check whether the given value is Object or not
	   *
	   * @param {*} obj
	   * @return {Boolean}
	   */
	
	  function isObject(obj) {
	    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	  }
	
	  /**
	   * Get state sub tree by given keys.
	   *
	   * @param {Object} state
	   * @param {Array<String>} nestedKeys
	   * @return {Object}
	   */
	  function getNestedState(state, nestedKeys) {
	    return nestedKeys.reduce(function (state, key) {
	      return state[key];
	    }, state);
	  }
	
	  /**
	   * Hacks to get access to Vue internals.
	   * Maybe we should expose these...
	   */
	
	  var Watcher = void 0;
	  function getWatcher(vm) {
	    if (!Watcher) {
	      var noop = function noop() {};
	      var unwatch = vm.$watch(noop, noop);
	      Watcher = vm._watchers[0].constructor;
	      unwatch();
	    }
	    return Watcher;
	  }
	
	  var Dep = void 0;
	  function getDep(vm) {
	    if (!Dep) {
	      Dep = vm._data.__ob__.dep.constructor;
	    }
	    return Dep;
	  }
	
	  var hook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	  function devtoolPlugin(store) {
	    if (!hook) return;
	
	    hook.emit('vuex:init', store);
	
	    hook.on('vuex:travel-to-state', function (targetState) {
	      store.replaceState(targetState);
	    });
	
	    store.on('mutation', function (mutation, state) {
	      hook.emit('vuex:mutation', mutation, state);
	    });
	  }
	
	  function override (Vue) {
	    var version = Number(Vue.version.split('.')[0]);
	
	    if (version >= 2) {
	      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
	      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
	    } else {
	      (function () {
	        // override init and inject vuex init procedure
	        // for 1.x backwards compatibility.
	        var _init = Vue.prototype._init;
	        Vue.prototype._init = function () {
	          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	          options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
	          _init.call(this, options);
	        };
	      })();
	    }
	
	    /**
	     * Vuex init hook, injected into each instances init hooks list.
	     */
	
	    function vuexInit() {
	      var options = this.$options;
	      var store = options.store;
	      var vuex = options.vuex;
	      // store injection
	
	      if (store) {
	        this.$store = store;
	      } else if (options.parent && options.parent.$store) {
	        this.$store = options.parent.$store;
	      }
	      // vuex option handling
	      if (vuex) {
	        if (!this.$store) {
	          console.warn('[vuex] store not injected. make sure to ' + 'provide the store option in your root component.');
	        }
	        var state = vuex.state;
	        var actions = vuex.actions;
	        var getters = vuex.getters;
	        // handle deprecated state option
	
	        if (state && !getters) {
	          console.warn('[vuex] vuex.state option will been deprecated in 1.0. ' + 'Use vuex.getters instead.');
	          getters = state;
	        }
	        // getters
	        if (getters) {
	          options.computed = options.computed || {};
	          for (var key in getters) {
	            defineVuexGetter(this, key, getters[key]);
	          }
	        }
	        // actions
	        if (actions) {
	          options.methods = options.methods || {};
	          for (var _key in actions) {
	            options.methods[_key] = makeBoundAction(this.$store, actions[_key], _key);
	          }
	        }
	      }
	    }
	
	    /**
	     * Setter for all getter properties.
	     */
	
	    function setter() {
	      throw new Error('vuex getter properties are read-only.');
	    }
	
	    /**
	     * Define a Vuex getter on an instance.
	     *
	     * @param {Vue} vm
	     * @param {String} key
	     * @param {Function} getter
	     */
	
	    function defineVuexGetter(vm, key, getter) {
	      if (typeof getter !== 'function') {
	        console.warn('[vuex] Getter bound to key \'vuex.getters.' + key + '\' is not a function.');
	      } else {
	        Object.defineProperty(vm, key, {
	          enumerable: true,
	          configurable: true,
	          get: makeComputedGetter(vm.$store, getter),
	          set: setter
	        });
	      }
	    }
	
	    /**
	     * Make a computed getter, using the same caching mechanism of computed
	     * properties. In addition, it is cached on the raw getter function using
	     * the store's unique cache id. This makes the same getter shared
	     * across all components use the same underlying watcher, and makes
	     * the getter evaluated only once during every flush.
	     *
	     * @param {Store} store
	     * @param {Function} getter
	     */
	
	    function makeComputedGetter(store, getter) {
	      var id = store._getterCacheId;
	
	      // cached
	      if (getter[id]) {
	        return getter[id];
	      }
	      var vm = store._vm;
	      var Watcher = getWatcher(vm);
	      var Dep = getDep(vm);
	      var watcher = new Watcher(vm, function (vm) {
	        return getter(vm.state);
	      }, null, { lazy: true });
	      var computedGetter = function computedGetter() {
	        if (watcher.dirty) {
	          watcher.evaluate();
	        }
	        if (Dep.target) {
	          watcher.depend();
	        }
	        return watcher.value;
	      };
	      getter[id] = computedGetter;
	      return computedGetter;
	    }
	
	    /**
	     * Make a bound-to-store version of a raw action function.
	     *
	     * @param {Store} store
	     * @param {Function} action
	     * @param {String} key
	     */
	
	    function makeBoundAction(store, action, key) {
	      if (typeof action !== 'function') {
	        console.warn('[vuex] Action bound to key \'vuex.actions.' + key + '\' is not a function.');
	      }
	      return function vuexBoundAction() {
	        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
	          args[_key2] = arguments[_key2];
	        }
	
	        return action.call.apply(action, [this, store].concat(args));
	      };
	    }
	
	    // option merging
	    var merge = Vue.config.optionMergeStrategies.computed;
	    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
	      if (!toVal) return fromVal;
	      if (!fromVal) return toVal;
	      return {
	        getters: merge(toVal.getters, fromVal.getters),
	        state: merge(toVal.state, fromVal.state),
	        actions: merge(toVal.actions, fromVal.actions)
	      };
	    };
	  }
	
	  var Vue = void 0;
	  var uid = 0;
	
	  var Store = function () {
	
	    /**
	     * @param {Object} options
	     *        - {Object} state
	     *        - {Object} actions
	     *        - {Object} mutations
	     *        - {Array} plugins
	     *        - {Boolean} strict
	     */
	
	    function Store() {
	      var _this = this;
	
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$state = _ref.state;
	      var state = _ref$state === undefined ? {} : _ref$state;
	      var _ref$mutations = _ref.mutations;
	      var mutations = _ref$mutations === undefined ? {} : _ref$mutations;
	      var _ref$modules = _ref.modules;
	      var modules = _ref$modules === undefined ? {} : _ref$modules;
	      var _ref$plugins = _ref.plugins;
	      var plugins = _ref$plugins === undefined ? [] : _ref$plugins;
	      var _ref$strict = _ref.strict;
	      var strict = _ref$strict === undefined ? false : _ref$strict;
	      classCallCheck(this, Store);
	
	      this._getterCacheId = 'vuex_store_' + uid++;
	      this._dispatching = false;
	      this._rootMutations = this._mutations = mutations;
	      this._modules = modules;
	      this._events = Object.create(null);
	      // bind dispatch to self
	      var dispatch = this.dispatch;
	      this.dispatch = function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	
	        dispatch.apply(_this, args);
	      };
	      // use a Vue instance to store the state tree
	      // suppress warnings just in case the user has added
	      // some funky global mixins
	      if (!Vue) {
	        throw new Error('[vuex] must call Vue.use(Vuex) before creating a store instance.');
	      }
	      var silent = Vue.config.silent;
	      Vue.config.silent = true;
	      this._vm = new Vue({
	        data: {
	          state: state
	        }
	      });
	      Vue.config.silent = silent;
	      this._setupModuleState(state, modules);
	      this._setupModuleMutations(modules);
	      // add extra warnings in strict mode
	      if (strict) {
	        this._setupMutationCheck();
	      }
	      // apply plugins
	      devtoolPlugin(this);
	      plugins.forEach(function (plugin) {
	        return plugin(_this);
	      });
	    }
	
	    /**
	     * Getter for the entire state tree.
	     * Read only.
	     *
	     * @return {Object}
	     */
	
	    createClass(Store, [{
	      key: 'replaceState',
	
	
	      /**
	       * Replace root state.
	       *
	       * @param {Object} state
	       */
	
	      value: function replaceState(state) {
	        this._dispatching = true;
	        this._vm.state = state;
	        this._dispatching = false;
	      }
	
	      /**
	       * Dispatch an action.
	       *
	       * @param {String} type
	       */
	
	    }, {
	      key: 'dispatch',
	      value: function dispatch(type) {
	        for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          payload[_key2 - 1] = arguments[_key2];
	        }
	
	        var silent = false;
	        var isObjectStyleDispatch = false;
	        // compatibility for object actions, e.g. FSA
	        if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type.type && arguments.length === 1) {
	          isObjectStyleDispatch = true;
	          payload = type;
	          if (type.silent) silent = true;
	          type = type.type;
	        }
	        var handler = this._mutations[type];
	        var state = this.state;
	        if (handler) {
	          this._dispatching = true;
	          // apply the mutation
	          if (Array.isArray(handler)) {
	            handler.forEach(function (h) {
	              isObjectStyleDispatch ? h(state, payload) : h.apply(undefined, [state].concat(toConsumableArray(payload)));
	            });
	          } else {
	            isObjectStyleDispatch ? handler(state, payload) : handler.apply(undefined, [state].concat(toConsumableArray(payload)));
	          }
	          this._dispatching = false;
	          if (!silent) {
	            var mutation = isObjectStyleDispatch ? payload : { type: type, payload: payload };
	            this.emit('mutation', mutation, state);
	          }
	        } else {
	          console.warn('[vuex] Unknown mutation: ' + type);
	        }
	      }
	
	      /**
	       * Watch state changes on the store.
	       * Same API as Vue's $watch, except when watching a function,
	       * the function gets the state as the first argument.
	       *
	       * @param {Function} fn
	       * @param {Function} cb
	       * @param {Object} [options]
	       */
	
	    }, {
	      key: 'watch',
	      value: function watch(fn, cb, options) {
	        var _this2 = this;
	
	        if (typeof fn !== 'function') {
	          console.error('Vuex store.watch only accepts function.');
	          return;
	        }
	        return this._vm.$watch(function () {
	          return fn(_this2.state);
	        }, cb, options);
	      }
	
	      /**
	       * Hot update mutations & modules.
	       *
	       * @param {Object} options
	       *        - {Object} [mutations]
	       *        - {Object} [modules]
	       */
	
	    }, {
	      key: 'hotUpdate',
	      value: function hotUpdate() {
	        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	        var mutations = _ref2.mutations;
	        var modules = _ref2.modules;
	
	        this._rootMutations = this._mutations = mutations || this._rootMutations;
	        this._setupModuleMutations(modules || this._modules);
	      }
	
	      /**
	       * Attach sub state tree of each module to the root tree.
	       *
	       * @param {Object} state
	       * @param {Object} modules
	       */
	
	    }, {
	      key: '_setupModuleState',
	      value: function _setupModuleState(state, modules) {
	        var _this3 = this;
	
	        if (!isObject(modules)) return;
	
	        Object.keys(modules).forEach(function (key) {
	          var module = modules[key];
	
	          // set this module's state
	          Vue.set(state, key, module.state || {});
	
	          // retrieve nested modules
	          _this3._setupModuleState(state[key], module.modules);
	        });
	      }
	
	      /**
	       * Bind mutations for each module to its sub tree and
	       * merge them all into one final mutations map.
	       *
	       * @param {Object} updatedModules
	       */
	
	    }, {
	      key: '_setupModuleMutations',
	      value: function _setupModuleMutations(updatedModules) {
	        var modules = this._modules;
	        Object.keys(updatedModules).forEach(function (key) {
	          modules[key] = updatedModules[key];
	        });
	        var updatedMutations = this._createModuleMutations(modules, []);
	        this._mutations = mergeObjects([this._rootMutations].concat(toConsumableArray(updatedMutations)));
	      }
	
	      /**
	       * Helper method for _setupModuleMutations.
	       * The method retrieve nested sub modules and
	       * bind each mutations to its sub tree recursively.
	       *
	       * @param {Object} modules
	       * @param {Array<String>} nestedKeys
	       * @return {Array<Object>}
	       */
	
	    }, {
	      key: '_createModuleMutations',
	      value: function _createModuleMutations(modules, nestedKeys) {
	        var _this4 = this;
	
	        if (!isObject(modules)) return [];
	
	        return Object.keys(modules).map(function (key) {
	          var module = modules[key];
	          var newNestedKeys = nestedKeys.concat(key);
	
	          // retrieve nested modules
	          var nestedMutations = _this4._createModuleMutations(module.modules, newNestedKeys);
	
	          if (!module || !module.mutations) {
	            return mergeObjects(nestedMutations);
	          }
	
	          // bind mutations to sub state tree
	          var mutations = {};
	          Object.keys(module.mutations).forEach(function (name) {
	            var original = module.mutations[name];
	            mutations[name] = function (state) {
	              for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	                args[_key3 - 1] = arguments[_key3];
	              }
	
	              original.apply(undefined, [getNestedState(state, newNestedKeys)].concat(args));
	            };
	          });
	
	          // merge mutations of this module and nested modules
	          return mergeObjects([mutations].concat(toConsumableArray(nestedMutations)));
	        });
	      }
	
	      /**
	       * Setup mutation check: if the vuex instance's state is mutated
	       * outside of a mutation handler, we throw en error. This effectively
	       * enforces all mutations to the state to be trackable and hot-reloadble.
	       * However, this comes at a run time cost since we are doing a deep
	       * watch on the entire state tree, so it is only enalbed with the
	       * strict option is set to true.
	       */
	
	    }, {
	      key: '_setupMutationCheck',
	      value: function _setupMutationCheck() {
	        var _this5 = this;
	
	        var Watcher = getWatcher(this._vm);
	        /* eslint-disable no-new */
	        new Watcher(this._vm, 'state', function () {
	          if (!_this5._dispatching) {
	            throw new Error('[vuex] Do not mutate vuex store state outside mutation handlers.');
	          }
	        }, { deep: true, sync: true });
	        /* eslint-enable no-new */
	      }
	    }, {
	      key: 'state',
	      get: function get() {
	        return this._vm.state;
	      },
	      set: function set(v) {
	        throw new Error('[vuex] Use store.replaceState() to explicit replace store state.');
	      }
	    }]);
	    return Store;
	  }();
	
	  function install(_Vue) {
	    if (Vue) {
	      console.warn('[vuex] already installed. Vue.use(Vuex) should be called only once.');
	      return;
	    }
	    Vue = _Vue
	    // reuse Vue's event system
	    ;['on', 'off', 'once', 'emit'].forEach(function (e) {
	      Store.prototype[e] = Store.prototype['$' + e] = Vue.prototype['$' + e];
	    });
	    override(Vue);
	  }
	
	  // auto install in dist mode
	  if (typeof window !== 'undefined' && window.Vue) {
	    install(window.Vue);
	  }
	
	  var index = {
	    Store: Store,
	    install: install
	  };
	
	  return index;
	
	}));

/***/ },
/* 138 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    googleMaps: {
	        key: 'AIzaSyABnCcekyPecGnsA1Rj_NdWjmUafJ1yVqA',
	        v: 3
	    },
	    map: {
	        center: {
	            lat: 21.308731,
	            lng: -157.888815
	        },
	        zoom: 19,
	        disableDefaultUI: true,
	        disableDoubleClickZoom: true,
	        tilt: 0
	    },
	    settings: {
	        defaultMapType: 'SATELLITE'
	    }
	};

/***/ },
/* 139 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Fast UUID generator, RFC4122 version 4 compliant.
	 * @author Jeff Ward (jcward.com).
	 * @license MIT license
	 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	 **/
	
	var lut = [];
	
	for (var i = 0; i < 256; i++) {
	    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}
	
	var generate = function generate() {
	    var d0 = Math.random() * 0xffffffff | 0;
	    var d1 = Math.random() * 0xffffffff | 0;
	    var d2 = Math.random() * 0xffffffff | 0;
	    var d3 = Math.random() * 0xffffffff | 0;
	
	    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
	};
	
	var short = function short(prefix) {
	    prefix = prefix || '';
	
	    var uuid = generate();
	
	    return prefix + uuid.split('-')[0];
	};
	
	exports.default = {
	    generate: generate,
	    short: short
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODUzYjI4MTNiMjQ5Mjg4YmIyNjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUvZGlzdC92dWUuY29tbW9uLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34va2Vlbi11aS9kaXN0L2tlZW4tdWkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/OTYwNSIsIndlYnBhY2s6Ly8vQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZT83OWQ1Iiwid2VicGFjazovLy9NYXBWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZT8zNWM0Iiwid2VicGFjazovLy9HY3NNYXAudnVlIiwid2VicGFjazovLy8uL3NyYy91dGlsL2NvcHktb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2FkLWdvb2dsZS1tYXBzLWFwaS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL2FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWVwLWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLW9iai9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RvcmUvZ2V0dGVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZT8yYzJlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBDb250cm9scy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcENvbnRyb2xzLnZ1ZT8wY2RkIiwid2VicGFjazovLy9HY3NNYXBDb250cm9scy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcENvbnRyb2xzLnZ1ZT8yMjAxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBTaWRlYmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwU2lkZWJhci52dWU/NTkzNyIsIndlYnBhY2s6Ly8vR2NzTWFwU2lkZWJhci52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWU/MmQyOCIsIndlYnBhY2s6Ly8vR2NzTWlzc2lvbnMudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZT9lZDM0Iiwid2VicGFjazovLy9HY3NNaXNzaW9uLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50LnZ1ZT9iMGIyIiwid2VicGFjazovLy9HY3NXYXlwb2ludC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL21peGlucy9pcy1tYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZWxlbWVudC1zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWU/MzJmMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50TGluay52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludExpbmsudnVlPzhlMGQiLCJ3ZWJwYWNrOi8vL0djc1dheXBvaW50TGluay52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludExpbmsudnVlPzQyYTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvbnVtYmVyLXRvLWxldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb24udnVlPzlmZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25Sb3cudnVlPzkxNWMiLCJ3ZWJwYWNrOi8vL0djc01pc3Npb25Sb3cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWU/NWEwYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25zLnZ1ZT80YWVmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBTaWRlYmFyLnZ1ZT82OWYzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlPzdmY2YiLCJ3ZWJwYWNrOi8vL0djc1NpZGViYXJDb250cm9scy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc0NvbW1hbmRzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlP2ZjMTMiLCJ3ZWJwYWNrOi8vL0djc0NvbW1hbmRzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlPzI2ZjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc1NpZGViYXJDb250cm9scy52dWU/NzNkYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dhbXYudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2Ftdi52dWU/ZDBiMCIsIndlYnBhY2s6Ly8vR2NzV2Ftdi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZT82NjU5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3ZpZXdzL01hcFZpZXcudnVlPzA0MTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWU/ZjU2NiIsIndlYnBhY2s6Ly8vUGFyYW1zVmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWU/YmFjOSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9TZXR0aW5nc1ZpZXcudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWU/ZTgxOSIsIndlYnBhY2s6Ly8vU2V0dGluZ3NWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9TZXR0aW5nc1ZpZXcudnVlPzY2NjAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvR2NzSW5kaWNhdG9ycy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvR2NzSW5kaWNhdG9ycy52dWU/OWRhNSIsIndlYnBhY2s6Ly8vR2NzSW5kaWNhdG9ycy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvR2NzSW5kaWNhdG9ycy52dWU/OGJmMiIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwid2VicGFjazovLy8uL34vcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9qc29uMy9saWIvanNvbjMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vaGFzLWNvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tcGFyc2VyL34vaGFzLWJpbmFyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1wYXJzZXIvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXRmOC91dGY4LmpzIiwid2VicGFjazovLy8uL34vYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlcXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vL3dzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZWpzb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3RvLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhcy1iaW5hcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9kODE4Iiwid2VicGFjazovLy8uL3NyYy9zdG9yZS9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZXgvZGlzdC92dWV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvdXVpZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxhQUFhO0FBQ3hCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxJQUFJO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGFBQVksRUFBRTtBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxtQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCOztBQUVBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLElBQUk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLElBQUk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0EsbUNBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsSUFBSTtBQUNmLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLHVCQUF1QixFQUFFO0FBQ2pELDZCQUE0QiwyQkFBMkIsRUFBRTtBQUN6RCx3QkFBdUIsc0JBQXNCLEVBQUU7QUFDL0MsNEJBQTJCLDBCQUEwQixFQUFFO0FBQ3ZEO0FBQ0EsZUFBYyxhQUFhLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsYUFBYTtBQUMzQixFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLG9CQUFtQjtBQUNuQix5QkFBd0I7QUFDeEIsMkJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0I7QUFDdEIsNEJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CLHFDQUFvQztBQUNwQyw4QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixhQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQiwyRUFBMkUsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkI7QUFDQSxTQUFRLE9BQU87QUFDZixTQUFRLFNBQVM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxJQUFJO0FBQ2YsWUFBVyxnQkFBZ0I7QUFDM0IsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQix1QkFBc0IsTUFBTTtBQUM1Qix1QkFBc0IsUUFBUTtBQUM5Qix1QkFBc0IsUUFBUTtBQUM5Qix1QkFBc0IsUUFBUTtBQUM5Qix1QkFBc0IsUUFBUTtBQUM5Qix1QkFBc0IsUUFBUTtBQUM5Qix1QkFBc0IsU0FBUztBQUMvQix1QkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLElBQUk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGNBQWM7QUFDekIsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxnREFBK0M7QUFDL0MsTUFBSztBQUNMLG9DQUFtQztBQUNuQztBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxvQ0FBbUM7QUFDbkM7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUMvSnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFNOztBQUVOO0FBQ0EsMkRBQTBELGVBQWUsRUFBRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9B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LE9BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUFBVztBQUNYOztBQUVBO0FBQ0Esc0VBQXFFOztBQUVyRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVE7QUFDUjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsMkJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7O0FBRUE7QUFDQSxzRUFBcUUsK0JBQStCO0FBQ3BHOztBQUVBLG9EQUFtRCwrQkFBK0I7QUFDbEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsU0FBUTtBQUNSO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQW9DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsbUNBQW1DLEVBQUUsRUFBRSxjQUFjLFdBQVcsVUFBVSxFQUFFLFVBQVUsTUFBTSx5Q0FBeUMsRUFBRSxVQUFVLGtCQUFrQixFQUFFLEVBQUUsYUFBYSxFQUFFLDJCQUEyQiwwQkFBMEIsWUFBWSxFQUFFLDJDQUEyQyw4QkFBOEIsRUFBRSxPQUFPLDZFQUE2RSxFQUFFLEdBQUcsRUFBRTs7QUFFdnBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNOztBQUVOOztBQUVBLGlDQUFnQztBQUNoQyxpQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWixXQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWixXQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU4sY0FBYTtBQUNiO0FBQ0EsR0FBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtB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LFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWdHO0FBQ2hHO0FBQ0EsY0FBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBLCtGQUE4Riw0REFBNEQ7QUFDMUo7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUEsd0ZBQXVGLDZCQUE2Qjs7QUFFcEgsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHdDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTJDLHNDQUFzQzs7QUFFakY7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztB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QUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUEsdUVBQXNFLHNHQUFzRzs7QUFFNUssUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxX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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQixlQUFjO0FBQ2QsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2QsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUFzQjtBQUN0QixzQkFBcUI7O0FBRXJCLG1DQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxNQUFNO0FBQ2xCLGFBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUYsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUYsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRixHQUFFOztBQUVGLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUYsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQSxvRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7O0FBR0YsUUFBTztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIs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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM2lCQTs7Ozs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUEyRjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBOEMsV0FBVztBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdnRCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwREE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsWUFBWTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsWUFBWTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxNQUFLLFdBQVc7QUFDaEI7QUFDQTs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQixpREFBaUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDREQUEyRDtBQUMzRDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF1RTtBQUN2RSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM1pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWdDLGlCQUFpQjtBQUNqRDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksVUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN09BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxZQUFZO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsT0FBTztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUVxQixJQUFJLE1BQU0sQ0FBTixHQUFVLElBQWQsQ0FGckIsR0FFMkMsR0FGM0MsR0FFaUQsSUFBSSxNQUFNLEVBQU4sR0FBVyxJQUFmLENBRmpELEdBRXdFLElBQUksTUFBTSxFQUFOLEdBQVcsSUFBZixDQUZ4RSxHQUdILElBQUksS0FBSyxJQUFULENBSEcsR0FHYyxJQUFJLE1BQU0sQ0FBTixHQUFVLElBQWQsQ0FIZCxHQUdvQyxJQUFJLE1BQU0sRUFBTixHQUFXLElBQWYsQ0FIcEMsR0FHMkQsSUFBSSxNQUFNLEVBQU4sR0FBVyxJQUFmLENBSGxFO0FBSUgsRUFWRDs7QUFZQSxLQUFJLFFBQVEsU0FBUixLQUFRLENBQVMsTUFBVCxFQUFpQjtBQUN6QixjQUFTLFVBQVUsRUFBbkI7O0FBRUEsU0FBSSxPQUFPLFVBQVg7O0FBRUEsWUFBTyxTQUFTLEtBQUssS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBaEI7QUFDSCxFQU5EOzttQkFRZTtBQUNYLHVCQURXO0FBRVg7QUFGVyxFIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgODUzYjI4MTNiMjQ5Mjg4YmIyNjJcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBLZWVuVUkgZnJvbSAna2Vlbi11aSc7XHJcbmltcG9ydCBBcHAgZnJvbSAnYXBwL0FwcC52dWUnO1xyXG5pbXBvcnQgc3RvcmUgZnJvbSAnc3RvcmUvc3RvcmUnO1xyXG5cclxuVnVlLnVzZShLZWVuVUkpO1xyXG5cclxudmFyIGFwcCA9IG5ldyBWdWUoe1xyXG4gICAgZWw6ICdib2R5JyxcclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBBcHBcclxuICAgIH0sXHJcbiAgICBzdG9yZVxyXG59KTtcclxuXHJcbndpbmRvdy5hcHAgPSBhcHA7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21haW4uanNcbiAqKi8iLCIvKiFcbiAqIFZ1ZS5qcyB2MS4wLjI2XG4gKiAoYykgMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmouX2lzVnVlKSB7XG4gICAgc2V0KG9iai5fZGF0YSwga2V5LCB2YWwpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmNvbnZlcnQoa2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3Byb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24gZGVsKG9iaiwga2V5KSB7XG4gIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgb2JqW2tleV07XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgICAgZGVsZXRlIG9iai5fZGF0YVtrZXldO1xuICAgICAgb2JqLl9kaWdlc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgaWYgKG9iLnZtcykge1xuICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV07XG4gICAgICB2bS5fdW5wcm94eShrZXkpO1xuICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgbGl0ZXJhbFZhbHVlUkUgPSAvXlxccz8odHJ1ZXxmYWxzZXwtP1tcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvO1xuXG5mdW5jdGlvbiBpc0xpdGVyYWwoZXhwKSB7XG4gIHJldHVybiBsaXRlcmFsVmFsdWVSRS50ZXN0KGV4cCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Rjtcbn1cblxuLyoqXG4gKiBHdWFyZCB0ZXh0IG91dHB1dCwgbWFrZSBzdXJlIHVuZGVmaW5lZCBvdXRwdXRzXG4gKiBlbXB0eSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gX3RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIENoZWNrIGFuZCBjb252ZXJ0IHBvc3NpYmxlIG51bWVyaWMgc3RyaW5ncyB0byBudW1iZXJzXG4gKiBiZWZvcmUgc2V0dGluZyBiYWNrIHRvIGRhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfE51bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG59XG5cbi8qKlxuICogU3RyaXAgcXVvdGVzIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmcgfCBmYWxzZX1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpcFF1b3RlcyhzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBhID09PSBiICYmIChhID09PSAweDIyIHx8IGEgPT09IDB4MjcpID8gc3RyLnNsaWNlKDEsIC0xKSA6IHN0cjtcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbn1cblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgaHlwaGVuYXRlUkUgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcblxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZztcblxuZnVuY3Rpb24gY2xhc3NpZnkoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCB0b1VwcGVyKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGJpbmQoZm4sIGN0eCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGwgPyBsID4gMSA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKSA6IGZuLmNhbGwoY3R4LCBhKSA6IGZuLmNhbGwoY3R4KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LWxpa2V9IGxpc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gc3RhcnQgaW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuZCh0bywgZnJvbSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdG9ba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HO1xufVxuXG4vKipcbiAqIEFycmF5IHR5cGUgY2hlY2suXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZSBhIGZ1bmN0aW9uIHNvIGl0IG9ubHkgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlXG4gKiBpbnB1dCBzdG9wcyBhcnJpdmluZyBhZnRlciB0aGUgZ2l2ZW4gd2FpdCBwZXJpb2QuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtOdW1iZXJ9IHdhaXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBfZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIE1hbnVhbCBpbmRleE9mIGJlY2F1c2UgaXQncyBzbGlnaHRseSBmYXN0ZXIgdGhhblxuICogbmF0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSBvYmpcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgb2JqKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIE1ha2UgYSBjYW5jZWxsYWJsZSB2ZXJzaW9uIG9mIGFuIGFzeW5jIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjYW5jZWxsYWJsZShmbikge1xuICB2YXIgY2IgPSBmdW5jdGlvbiBjYigpIHtcbiAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBjYi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIGNiO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICpcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIGEgPT0gYiB8fCAoaXNPYmplY3QoYSkgJiYgaXNPYmplY3QoYikgPyBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYikgOiBmYWxzZSk7XG4gIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG59XG5cbnZhciBoYXNQcm90byA9ICgnX19wcm90b19fJyBpbiB7fSk7XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vLyBVQSBzbmlmZmluZyBmb3Igd29ya2luZyBhcm91bmQgYnJvd3Nlci1zcGVjaWZpYyBxdWlya3NcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiBVQS5pbmRleE9mKCd0cmlkZW50JykgPiAwO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lvcyA9IFVBICYmIC8oaXBob25lfGlwYWR8aXBvZHxpb3MpL2kudGVzdChVQSk7XG52YXIgaW9zVmVyc2lvbk1hdGNoID0gaXNJb3MgJiYgVUEubWF0Y2goL29zIChbXFxkX10rKS8pO1xudmFyIGlvc1ZlcnNpb24gPSBpb3NWZXJzaW9uTWF0Y2ggJiYgaW9zVmVyc2lvbk1hdGNoWzFdLnNwbGl0KCdfJyk7XG5cbi8vIGRldGVjdGluZyBpT1MgVUlXZWJWaWV3IGJ5IGluZGV4ZWREQlxudmFyIGhhc011dGF0aW9uT2JzZXJ2ZXJCdWcgPSBpb3NWZXJzaW9uICYmIE51bWJlcihpb3NWZXJzaW9uWzBdKSA+PSA5ICYmIE51bWJlcihpb3NWZXJzaW9uWzFdKSA+PSAzICYmICF3aW5kb3cuaW5kZXhlZERCO1xuXG52YXIgdHJhbnNpdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUU5KSB7XG4gIHZhciBpc1dlYmtpdFRyYW5zID0gd2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdmFyIGlzV2Via2l0QW5pbSA9IHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB0cmFuc2l0aW9uUHJvcCA9IGlzV2Via2l0VHJhbnMgPyAnV2Via2l0VHJhbnNpdGlvbicgOiAndHJhbnNpdGlvbic7XG4gIHRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnMgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gIGFuaW1hdGlvblByb3AgPSBpc1dlYmtpdEFuaW0gPyAnV2Via2l0QW5pbWF0aW9uJyA6ICdhbmltYXRpb24nO1xuICBhbmltYXRpb25FbmRFdmVudCA9IGlzV2Via2l0QW5pbSA/ICd3ZWJraXRBbmltYXRpb25FbmQnIDogJ2FuaW1hdGlvbmVuZCc7XG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuIElkZWFsbHkgdGhpc1xuICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICogTXV0YXRpb25PYnNlcnZlciBpZiBpdCdzIGF2YWlsYWJsZSwgYW5kIGZhbGxiYWNrIHRvXG4gKiBzZXRUaW1lb3V0KDApLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKi9cblxudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmICFoYXNNdXRhdGlvbk9ic2VydmVyQnVnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY291bnRlcik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBjb3VudGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gd2VicGFjayBhdHRlbXB0cyB0byBpbmplY3QgYSBzaGltIGZvciBzZXRJbW1lZGlhdGVcbiAgICAvLyBpZiBpdCBpcyB1c2VkIGFzIGEgZ2xvYmFsLCBzbyB3ZSBoYXZlIHRvIHdvcmsgYXJvdW5kIHRoYXQgdG9cbiAgICAvLyBhdm9pZCBidW5kbGluZyB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgIHZhciBjb250ZXh0ID0gaW5Ccm93c2VyID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbiAgICB0aW1lckZ1bmMgPSBjb250ZXh0LnNldEltbWVkaWF0ZSB8fCBzZXRUaW1lb3V0O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY2IsIGN0eCkge1xuICAgIHZhciBmdW5jID0gY3R4ID8gZnVuY3Rpb24gKCkge1xuICAgICAgY2IuY2FsbChjdHgpO1xuICAgIH0gOiBjYjtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jKTtcbiAgICBpZiAocGVuZGluZykgcmV0dXJuO1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYyhuZXh0VGlja0hhbmRsZXIsIDApO1xuICB9O1xufSkoKTtcblxudmFyIF9TZXQgPSB1bmRlZmluZWQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBTZXQudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5zZXRba2V5XSA9IDE7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQ2FjaGUobGltaXQpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2tleW1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlO1xuXG4vKipcbiAqIFB1dCA8dmFsdWU+IGludG8gdGhlIGNhY2hlIGFzc29jaWF0ZWQgd2l0aCA8a2V5Pi5cbiAqIFJldHVybnMgdGhlIGVudHJ5IHdoaWNoIHdhcyByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3JcbiAqIHRoZSBuZXcgZW50cnkuIE90aGVyd2lzZSB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKiAoaS5lLiBpZiB0aGVyZSB3YXMgZW5vdWdoIHJvb20gYWxyZWFkeSkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7RW50cnl8dW5kZWZpbmVkfVxuICovXG5cbnAucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIHJlbW92ZWQ7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGVudHJ5ID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICAgIHRoaXMuX2tleW1hcFtrZXldID0gZW50cnk7XG4gICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7XG4gICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuc2l6ZSsrO1xuICB9XG4gIGVudHJ5LnZhbHVlID0gdmFsdWU7XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiAqIFB1cmdlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIChvbGRlc3QpIGVudHJ5IGZyb20gdGhlXG4gKiBjYWNoZS4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbnRyeSBvciB1bmRlZmluZWQgaWYgdGhlXG4gKiBjYWNoZSB3YXMgZW1wdHkuXG4gKi9cblxucC5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICBpZiAoZW50cnkpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIGVudHJ5Lm5ld2VyID0gZW50cnkub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaXplLS07XG4gIH1cbiAgcmV0dXJuIGVudHJ5O1xufTtcblxuLyoqXG4gKiBHZXQgYW5kIHJlZ2lzdGVyIHJlY2VudCB1c2Ugb2YgPGtleT4uIFJldHVybnMgdGhlIHZhbHVlXG4gKiBhc3NvY2lhdGVkIHdpdGggPGtleT4gb3IgdW5kZWZpbmVkIGlmIG5vdCBpbiBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkVudHJ5XG4gKiBAcmV0dXJuIHtFbnRyeXwqfVxuICovXG5cbnAuZ2V0ID0gZnVuY3Rpb24gKGtleSwgcmV0dXJuRW50cnkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChlbnRyeSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7IC8vIEMgPC0tIEUuXG4gIH1cbiAgaWYgKGVudHJ5Lm9sZGVyKSB7XG4gICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjsgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZDsgLy8gRCAtLXhcbiAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7IC8vIEQuIC0tPiBFXG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTsgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbn07XG5cbnZhciBjYWNoZSQxID0gbmV3IENhY2hlKDEwMDApO1xudmFyIGZpbHRlclRva2VuUkUgPSAvW15cXHMnXCJdK3wnW14nXSonfFwiW15cIl0qXCIvZztcbnZhciByZXNlcnZlZEFyZ1JFID0gL15pbiR8Xi0/XFxkKy87XG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0cjtcbnZhciBkaXI7XG52YXIgYztcbnZhciBwcmV2O1xudmFyIGk7XG52YXIgbDtcbnZhciBsYXN0RmlsdGVySW5kZXg7XG52YXIgaW5TaW5nbGU7XG52YXIgaW5Eb3VibGU7XG52YXIgY3VybHk7XG52YXIgc3F1YXJlO1xudmFyIHBhcmVuO1xuLyoqXG4gKiBQdXNoIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IGRpcmVjdGl2ZSBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpO1xuICB2YXIgZmlsdGVyO1xuICBpZiAoZXhwKSB7XG4gICAgZmlsdGVyID0ge307XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKTtcbiAgICBmaWx0ZXIubmFtZSA9IHRva2Vuc1swXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZpbHRlci5hcmdzID0gdG9rZW5zLnNsaWNlKDEpLm1hcChwcm9jZXNzRmlsdGVyQXJnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcik7XG4gIH1cbiAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXJndW1lbnQgaXMgZHluYW1pYyBhbmQgc3RyaXAgcXVvdGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzRmlsdGVyQXJnKGFyZykge1xuICBpZiAocmVzZXJ2ZWRBcmdSRS50ZXN0KGFyZykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRvTnVtYmVyKGFyZyksXG4gICAgICBkeW5hbWljOiBmYWxzZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMoYXJnKTtcbiAgICB2YXIgZHluYW1pYyA9IHN0cmlwcGVkID09PSBhcmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgZGlyZWN0aXZlIHZhbHVlIGFuZCBleHRyYWN0IHRoZSBleHByZXNzaW9uXG4gKiBhbmQgaXRzIGZpbHRlcnMgaW50byBhIGRlc2NyaXB0b3IuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBcImEgKyAxIHwgdXBwZXJjYXNlXCIgd2lsbCB5aWVsZDpcbiAqIHtcbiAqICAgZXhwcmVzc2lvbjogJ2EgKyAxJyxcbiAqICAgZmlsdGVyczogW1xuICogICAgIHsgbmFtZTogJ3VwcGVyY2FzZScsIGFyZ3M6IG51bGwgfVxuICogICBdXG4gKiB9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZURpcmVjdGl2ZShzKSB7XG4gIHZhciBoaXQgPSBjYWNoZSQxLmdldChzKTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICAvLyByZXNldCBwYXJzZXIgc3RhdGVcbiAgc3RyID0gcztcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlO1xuICBjdXJseSA9IHNxdWFyZSA9IHBhcmVuID0gMDtcbiAgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgZGlyID0ge307XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAvLyBjaGVjayBzaW5nbGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gIWluU2luZ2xlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIC8vIGNoZWNrIGRvdWJsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSAhaW5Eb3VibGU7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICBzdHIuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiYgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbHJlYWR5IGhhcyBmaWx0ZXJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTticmVhazsgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OlxuICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTticmVhazsgLy8gJ1xuICAgICAgICBjYXNlIDB4Mjg6XG4gICAgICAgICAgcGFyZW4rKzticmVhazsgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgcGFyZW4tLTticmVhazsgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6XG4gICAgICAgICAgc3F1YXJlKys7YnJlYWs7IC8vIFtcbiAgICAgICAgY2FzZSAweDVEOlxuICAgICAgICAgIHNxdWFyZS0tO2JyZWFrOyAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjpcbiAgICAgICAgICBjdXJseSsrO2JyZWFrOyAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDpcbiAgICAgICAgICBjdXJseS0tO2JyZWFrOyAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgY2FjaGUkMS5wdXQocywgZGlyKTtcbiAgcmV0dXJuIGRpcjtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZURpcmVjdGl2ZTogcGFyc2VEaXJlY3RpdmVcbn0pO1xuXG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG52YXIgY2FjaGUgPSB1bmRlZmluZWQ7XG52YXIgdGFnUkUgPSB1bmRlZmluZWQ7XG52YXIgaHRtbFJFID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgaW4gYSBSZWdFeHBcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVJlZ2V4KCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIGNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMV0pO1xuICB2YXIgdW5zYWZlT3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pO1xuICB0YWdSRSA9IG5ldyBSZWdFeHAodW5zYWZlT3BlbiArICcoKD86LnxcXFxcbikrPyknICsgdW5zYWZlQ2xvc2UgKyAnfCcgKyBvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKTtcbiAgaHRtbFJFID0gbmV3IFJlZ0V4cCgnXicgKyB1bnNhZmVPcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyB1bnNhZmVDbG9zZSArICckJyk7XG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgdGVtcGxhdGUgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD4gfCBudWxsfVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB2YWx1ZVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaHRtbF1cbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW29uZVRpbWVdXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNvbXBpbGVSZWdleCgpO1xuICB9XG4gIHZhciBoaXQgPSBjYWNoZS5nZXQodGV4dCk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIGh0bWwsIHZhbHVlLCBmaXJzdCwgb25lVGltZTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIGh0bWwgPSBodG1sUkUudGVzdChtYXRjaFswXSk7XG4gICAgdmFsdWUgPSBodG1sID8gbWF0Y2hbMV0gOiBtYXRjaFsyXTtcbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgb25lVGltZSA9IGZpcnN0ID09PSA0MjsgLy8gKlxuICAgIHZhbHVlID0gb25lVGltZSA/IHZhbHVlLnNsaWNlKDEpIDogdmFsdWU7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdGFnOiB0cnVlLFxuICAgICAgdmFsdWU6IHZhbHVlLnRyaW0oKSxcbiAgICAgIGh0bWw6IGh0bWwsXG4gICAgICBvbmVUaW1lOiBvbmVUaW1lXG4gICAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pO1xuICB9XG4gIGNhY2hlLnB1dCh0ZXh0LCB0b2tlbnMpO1xuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHRva2Vuc1RvRXhwKHRva2Vucywgdm0pIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4sIHZtKTtcbiAgICB9KS5qb2luKCcrJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdm0sIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc2luZ2xlIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUb2tlbih0b2tlbiwgdm0sIHNpbmdsZSkge1xuICByZXR1cm4gdG9rZW4udGFnID8gdG9rZW4ub25lVGltZSAmJiB2bSA/ICdcIicgKyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgKyAnXCInIDogaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKSA6ICdcIicgKyB0b2tlbi52YWx1ZSArICdcIic7XG59XG5cbi8qKlxuICogRm9yIGFuIGF0dHJpYnV0ZSB3aXRoIG11bHRpcGxlIGludGVycG9sYXRpb24gdGFncyxcbiAqIGUuZy4gYXR0cj1cInNvbWUte3t0aGluZyB8IGZpbHRlcn19XCIsIGluIG9yZGVyIHRvIGNvbWJpbmVcbiAqIHRoZSB3aG9sZSB0aGluZyBpbnRvIGEgc2luZ2xlIHdhdGNoYWJsZSBleHByZXNzaW9uLCB3ZVxuICogaGF2ZSB0byBpbmxpbmUgdGhvc2UgZmlsdGVycy4gVGhpcyBmdW5jdGlvbiBkb2VzIGV4YWN0bHlcbiAqIHRoYXQuIFRoaXMgaXMgYSBiaXQgaGFja3kgYnV0IGl0IGF2b2lkcyBoZWF2eSBjaGFuZ2VzXG4gKiB0byBkaXJlY3RpdmUgcGFyc2VyIGFuZCB3YXRjaGVyIG1lY2hhbmlzbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNpbmdsZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBmaWx0ZXJSRSA9IC9bXnxdXFx8W158XS87XG5mdW5jdGlvbiBpbmxpbmVGaWx0ZXJzKGV4cCwgc2luZ2xlKSB7XG4gIGlmICghZmlsdGVyUkUudGVzdChleHApKSB7XG4gICAgcmV0dXJuIHNpbmdsZSA/IGV4cCA6ICcoJyArIGV4cCArICcpJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUoZXhwKTtcbiAgICBpZiAoIWRpci5maWx0ZXJzKSB7XG4gICAgICByZXR1cm4gJygnICsgZXhwICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3RoaXMuX2FwcGx5RmlsdGVycygnICsgZGlyLmV4cHJlc3Npb24gKyAvLyB2YWx1ZVxuICAgICAgJyxudWxsLCcgKyAvLyBvbGRWYWx1ZSAobnVsbCBmb3IgcmVhZClcbiAgICAgIEpTT04uc3RyaW5naWZ5KGRpci5maWx0ZXJzKSArIC8vIGZpbHRlciBkZXNjcmlwdG9yc1xuICAgICAgJyxmYWxzZSknOyAvLyB3cml0ZT9cbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHQgPSBPYmplY3QuZnJlZXplKHtcbiAgY29tcGlsZVJlZ2V4OiBjb21waWxlUmVnZXgsXG4gIHBhcnNlVGV4dDogcGFyc2VUZXh0LFxuICB0b2tlbnNUb0V4cDogdG9rZW5zVG9FeHBcbn0pO1xuXG52YXIgZGVsaW1pdGVycyA9IFsne3snLCAnfX0nXTtcbnZhciB1bnNhZmVEZWxpbWl0ZXJzID0gWyd7e3snLCAnfX19J107XG5cbnZhciBjb25maWcgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcHJpbnQgZGVidWcgbWVzc2FnZXMuXG4gICAqIEFsc28gZW5hYmxlcyBzdGFjayB0cmFjZSBmb3Igd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBhc3luYyByZW5kZXJpbmcuXG4gICAqL1xuXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHdhcm4gYWdhaW5zdCBlcnJvcnMgY2F1Z2h0IHdoZW4gZXZhbHVhdGluZ1xuICAgKiBleHByZXNzaW9ucy5cbiAgICovXG5cbiAgd2FybkV4cHJlc3Npb25FcnJvcnM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgZGV2dG9vbHMgaW5zcGVjdGlvbi5cbiAgICogRGlzYWJsZWQgYnkgZGVmYXVsdCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAgICovXG5cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIEludGVybmFsIGZsYWcgdG8gaW5kaWNhdGUgdGhlIGRlbGltaXRlcnMgaGF2ZSBiZWVuXG4gICAqIGNoYW5nZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBfZGVsaW1pdGVyc0NoYW5nZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuXG4gIF9hc3NldFR5cGVzOiBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZWxlbWVudERpcmVjdGl2ZScsICdmaWx0ZXInLCAndHJhbnNpdGlvbicsICdwYXJ0aWFsJ10sXG5cbiAgLyoqXG4gICAqIHByb3AgYmluZGluZyBtb2Rlc1xuICAgKi9cblxuICBfcHJvcEJpbmRpbmdNb2Rlczoge1xuICAgIE9ORV9XQVk6IDAsXG4gICAgVFdPX1dBWTogMSxcbiAgICBPTkVfVElNRTogMlxuICB9LFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgYmF0Y2hlciBmbHVzaCBjeWNsZS5cbiAgICovXG5cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcblxufSwge1xuICBkZWxpbWl0ZXJzOiB7IC8qKlxuICAgICAgICAgICAgICAgICAqIEludGVycG9sYXRpb24gZGVsaW1pdGVycy4gQ2hhbmdpbmcgdGhlc2Ugd291bGQgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAqIHRoZSB0ZXh0IHBhcnNlciB0byByZS1jb21waWxlIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5PFN0cmluZz59XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICBkZWxpbWl0ZXJzID0gdmFsO1xuICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9LFxuICB1bnNhZmVEZWxpbWl0ZXJzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdW5zYWZlRGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfVxufSk7XG5cbnZhciB3YXJuID0gdW5kZWZpbmVkO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSB1bmRlZmluZWQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICFjb25maWcuc2lsZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWdWUgd2Fybl06ICcgKyBtc2cgKyAodm0gPyBmb3JtYXRDb21wb25lbnROYW1lKHZtKSA6ICcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0pIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX2lzVnVlID8gdm0uJG9wdGlvbnMubmFtZSA6IHZtLm5hbWU7XG4gICAgICByZXR1cm4gbmFtZSA/ICcgKGZvdW5kIGluIGNvbXBvbmVudDogPCcgKyBoeXBoZW5hdGUobmFtZSkgKyAnPiknIDogJyc7XG4gICAgfTtcbiAgfSkoKTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmRXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBJbnNlcnRCZWZvcmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmVXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlV2l0aFRyYW5zaXRpb24oZWwsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2l0aW9uKGVsLCBkaXJlY3Rpb24sIG9wLCB2bSwgY2IpIHtcbiAgdmFyIHRyYW5zaXRpb24gPSBlbC5fX3ZfdHJhbnM7XG4gIGlmICghdHJhbnNpdGlvbiB8fFxuICAvLyBza2lwIGlmIHRoZXJlIGFyZSBubyBqcyBob29rcyBhbmQgQ1NTIHRyYW5zaXRpb24gaXNcbiAgLy8gbm90IHN1cHBvcnRlZFxuICAhdHJhbnNpdGlvbi5ob29rcyAmJiAhdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAhdm0uX2lzQ29tcGlsZWQgfHxcbiAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIG1hbmlwdWxhdGVkIGJ5IGEgcGFyZW50IGRpcmVjdGl2ZVxuICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAvLyBhbmltYXRpb24uXG4gIHZtLiRwYXJlbnQgJiYgIXZtLiRwYXJlbnQuX2lzQ29tcGlsZWQpIHtcbiAgICBvcCgpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFjdGlvbiA9IGRpcmVjdGlvbiA+IDAgPyAnZW50ZXInIDogJ2xlYXZlJztcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYik7XG59XG5cbnZhciB0cmFuc2l0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGFwcGVuZFdpdGhUcmFuc2l0aW9uOiBhcHBlbmRXaXRoVHJhbnNpdGlvbixcbiAgYmVmb3JlV2l0aFRyYW5zaXRpb246IGJlZm9yZVdpdGhUcmFuc2l0aW9uLFxuICByZW1vdmVXaXRoVHJhbnNpdGlvbjogcmVtb3ZlV2l0aFRyYW5zaXRpb24sXG4gIGFwcGx5VHJhbnNpdGlvbjogYXBwbHlUcmFuc2l0aW9uXG59KTtcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RvciA9IGVsO1xuICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbkRvYyhub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fCBkb2MgPT09IHBhcmVudCB8fCAhIShwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIGRvYy5jb250YWlucyhwYXJlbnQpKTtcbn1cblxuLyoqXG4gKiBHZXQgYW5kIHJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gX2F0dHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyKG5vZGUsIF9hdHRyKSB7XG4gIHZhciB2YWwgPSBub2RlLmdldEF0dHJpYnV0ZShfYXR0cik7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QmluZEF0dHIobm9kZSwgbmFtZSkge1xuICB2YXIgdmFsID0gZ2V0QXR0cihub2RlLCAnOicgKyBuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGdldEF0dHIobm9kZSwgJ3YtYmluZDonICsgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgcHJlc2VuY2Ugb2YgYSBiaW5kIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCc6JyArIG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2LWJpbmQ6JyArIG5hbWUpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBiZWZvcmUgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmUoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldCk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGFmdGVyIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBlbCBmcm9tIERPTVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbi8qKlxuICogUHJlcGVuZCBlbCB0byB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIHByZXBlbmQoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVwbGFjZSB0YXJnZXQgd2l0aCBlbFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSkge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xufVxuXG4vKipcbiAqIEZvciBJRTkgY29tcGF0OiB3aGVuIGJvdGggY2xhc3MgYW5kIDpjbGFzcyBhcmUgcHJlc2VudFxuICogZ2V0QXR0cmlidXRlKCdjbGFzcycpIHJldHVybnMgd3JvbmcgdmFsdWUuLi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcbiAgdmFyIGNsYXNzbmFtZSA9IGVsLmNsYXNzTmFtZTtcbiAgaWYgKHR5cGVvZiBjbGFzc25hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgY2xhc3NuYW1lID0gY2xhc3NuYW1lLmJhc2VWYWwgfHwgJyc7XG4gIH1cbiAgcmV0dXJuIGNsYXNzbmFtZTtcbn1cblxuLyoqXG4gKiBJbiBJRTksIHNldEF0dHJpYnV0ZSgnY2xhc3MnKSB3aWxsIHJlc3VsdCBpbiBlbXB0eSBjbGFzc1xuICogaWYgdGhlIGVsZW1lbnQgYWxzbyBoYXMgdGhlIDpjbGFzcyBhdHRyaWJ1dGU7IEhvd2V2ZXIgaW5cbiAqIFBoYW50b21KUywgc2V0dGluZyBgY2xhc3NOYW1lYCBkb2VzIG5vdCB3b3JrIG9uIFNWRyBlbGVtZW50cy4uLlxuICogU28gd2UgaGF2ZSB0byBkbyBhIGNvbmRpdGlvbmFsIGNoZWNrIGhlcmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHNldENsYXNzKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiAhL3N2ZyQvLnRlc3QoZWwubmFtZXNwYWNlVVJJKSkge1xuICAgIGVsLmNsYXNzTmFtZSA9IGNscztcbiAgfSBlbHNlIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgc2V0Q2xhc3MoZWwsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBnZXRDbGFzcyhlbCkgKyAnICc7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIHNldENsYXNzKGVsLCBjdXIudHJpbSgpKTtcbiAgfVxuICBpZiAoIWVsLmNsYXNzTmFtZSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcmF3IGNvbnRlbnQgaW5zaWRlIGFuIGVsZW1lbnQgaW50byBhIHRlbXBvcmFyeVxuICogY29udGFpbmVyIGRpdlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNGcmFnbWVudFxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50KGVsLCBhc0ZyYWdtZW50KSB7XG4gIHZhciBjaGlsZDtcbiAgdmFyIHJhd0NvbnRlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNUZW1wbGF0ZShlbCkgJiYgaXNGcmFnbWVudChlbC5jb250ZW50KSkge1xuICAgIGVsID0gZWwuY29udGVudDtcbiAgfVxuICBpZiAoZWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdHJpbU5vZGUoZWwpO1xuICAgIHJhd0NvbnRlbnQgPSBhc0ZyYWdtZW50ID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICByYXdDb250ZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnQ7XG59XG5cbi8qKlxuICogVHJpbSBwb3NzaWJsZSBlbXB0eSBoZWFkL3RhaWwgdGV4dCBhbmQgY29tbWVudFxuICogbm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHRyaW1Ob2RlKG5vZGUpIHtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZXF1ZW5jZXMgKi9cbiAgd2hpbGUgKChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmxhc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VxdWVuY2VzICovXG59XG5cbmZ1bmN0aW9uIGlzVHJpbW1hYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIHRlbXBsYXRlIHRhZy5cbiAqIE5vdGUgaWYgdGhlIHRlbXBsYXRlIGFwcGVhcnMgaW5zaWRlIGFuIFNWRyBpdHMgdGFnTmFtZVxuICogd2lsbCBiZSBpbiBsb3dlcmNhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBcImFuY2hvclwiIGZvciBwZXJmb3JtaW5nIGRvbSBpbnNlcnRpb24vcmVtb3ZhbHMuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2Ygc2NlbmFyaW9zOlxuICogLSBmcmFnbWVudCBpbnN0YW5jZVxuICogLSB2LWh0bWxcbiAqIC0gdi1pZlxuICogLSB2LWZvclxuICogLSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtCb29sZWFufSBwZXJzaXN0IC0gSUUgdHJhc2hlcyBlbXB0eSB0ZXh0Tm9kZXMgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTm9kZSh0cnVlKSwgc28gaW4gY2VydGFpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXMgdGhlIGFuY2hvciBuZWVkcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uLWVtcHR5IHRvIGJlIHBlcnNpc3RlZCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLlxuICogQHJldHVybiB7Q29tbWVudHxUZXh0fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihjb250ZW50LCBwZXJzaXN0KSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuZGVidWcgPyBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGVyc2lzdCA/ICcgJyA6ICcnKTtcbiAgYW5jaG9yLl9fdl9hbmNob3IgPSB0cnVlO1xuICByZXR1cm4gYW5jaG9yO1xufVxuXG4vKipcbiAqIEZpbmQgYSBjb21wb25lbnQgcmVmIGF0dHJpYnV0ZSB0aGF0IHN0YXJ0cyB3aXRoICQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd8dW5kZWZpbmVkfVxuICovXG5cbnZhciByZWZSRSA9IC9edi1yZWY6LztcblxuZnVuY3Rpb24gZmluZFJlZihub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKHJlZlJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgYSBmdW5jdGlvbiB0byBhIHJhbmdlIG9mIG5vZGVzIC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcFxuICovXG5cbmZ1bmN0aW9uIG1hcE5vZGVSYW5nZShub2RlLCBlbmQsIG9wKSB7XG4gIHZhciBuZXh0O1xuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgb3Aobm9kZSk7XG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cbiAgb3AoZW5kKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSByYW5nZSBvZiBub2RlcyB3aXRoIHRyYW5zaXRpb24sIHN0b3JlXG4gKiB0aGUgbm9kZXMgaW4gYSBmcmFnbWVudCB3aXRoIGNvcnJlY3Qgb3JkZXJpbmcsXG4gKiBhbmQgY2FsbCBjYWxsYmFjayB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBzdGFydFxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGVSYW5nZShzdGFydCwgZW5kLCB2bSwgZnJhZywgY2IpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHJlbW92ZWQgPSAwO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgbWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWU7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgICByZW1vdmVXaXRoVHJhbnNpdGlvbihub2RlLCB2bSwgb25SZW1vdmVkKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIG9uUmVtb3ZlZCgpIHtcbiAgICByZW1vdmVkKys7XG4gICAgaWYgKGRvbmUgJiYgcmVtb3ZlZCA+PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gIH1cbn1cblxudmFyIGNvbW1vblRhZ1JFID0gL14oZGl2fHB8c3BhbnxpbWd8YXxifGl8YnJ8dWx8b2x8bGl8aDF8aDJ8aDN8aDR8aDV8aDZ8Y29kZXxwcmV8dGFibGV8dGh8dGR8dHJ8Zm9ybXxsYWJlbHxpbnB1dHxzZWxlY3R8b3B0aW9ufG5hdnxhcnRpY2xlfHNlY3Rpb258aGVhZGVyfGZvb3RlcikkL2k7XG52YXIgcmVzZXJ2ZWRUYWdSRSA9IC9eKHNsb3R8cGFydGlhbHxjb21wb25lbnQpJC9pO1xuXG52YXIgaXNVbmtub3duRWxlbWVudCA9IHVuZGVmaW5lZDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlzVW5rbm93bkVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHRhZykge1xuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICAgIHJldHVybiBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fCBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU0MDUyNlxuICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgdW5rbm93biBmb3Igc29tZSBcIkludGVyYWN0aXZlIGVsZW1lbnRzLlwiXG4gICAgICAgICEvXihkYXRhfHRpbWV8cnRjfHJifGRldGFpbHN8ZGlhbG9nfHN1bW1hcnkpJC8udGVzdCh0YWcpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LCBpZiB5ZXMgcmV0dXJuIGl0c1xuICogY29tcG9uZW50IGlkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucykge1xuICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gIGlmICghY29tbW9uVGFnUkUudGVzdCh0YWcpICYmICFyZXNlcnZlZFRhZ1JFLnRlc3QodGFnKSkge1xuICAgIGlmIChyZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSB7XG4gICAgICByZXR1cm4geyBpZDogdGFnIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpcyA9IGhhc0F0dHJzICYmIGdldElzQmluZGluZyhlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoaXMpIHtcbiAgICAgICAgcmV0dXJuIGlzO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHBlY3RlZFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXAgJiYgb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcFt0YWddO1xuICAgICAgICBpZiAoZXhwZWN0ZWRUYWcpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gJyArICdkaWQgeW91IG1lYW4gPCcgKyBleHBlY3RlZFRhZyArICc+PyAnICsgJ0hUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlIGtlYmFiLWNhc2UgaW4gdGVtcGxhdGVzLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVW5rbm93bkVsZW1lbnQoZWwsIHRhZykpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICsgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgKyAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoYXNBdHRycykge1xuICAgIHJldHVybiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IFwiaXNcIiBiaW5kaW5nIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpIHtcbiAgLy8gZHluYW1pYyBzeW50YXhcbiAgdmFyIGV4cCA9IGVsLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgaWYgKHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIGV4cCkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIHJldHVybiB7IGlkOiBleHAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwID0gZ2V0QmluZEF0dHIoZWwsICdpcycpO1xuICAgIGlmIChleHAgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgaWQ6IGV4cCwgZHluYW1pYzogdHJ1ZSB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBBbGwgc3RyYXRlZ3kgZnVuY3Rpb25zIGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmU6XG4gKlxuICogQHBhcmFtIHsqfSBwYXJlbnRWYWxcbiAqIEBwYXJhbSB7Kn0gY2hpbGRWYWxcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKi9cblxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgZm9yIChrZXkgaW4gZnJvbSkge1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0b1ZhbCkgJiYgaXNPYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShjaGlsZFZhbC5jYWxsKHRoaXMpLCBwYXJlbnRWYWwuY2FsbCh0aGlzKSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4oKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodm0pIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodm0pIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogRWxcbiAqL1xuXG5zdHJhdHMuZWwgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1RoZSBcImVsXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbDtcbiAgLy8gaW52b2tlIHRoZSBlbGVtZW50IGZhY3RvcnkgaWYgdGhpcyBpcyBpbnN0YW5jZSBtZXJnZVxuICByZXR1cm4gdm0gJiYgdHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyA/IHJldC5jYWxsKHZtKSA6IHJldDtcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHBhcmFtIGF0dHJpYnV0ZXMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLmluaXQgPSBzdHJhdHMuY3JlYXRlZCA9IHN0cmF0cy5yZWFkeSA9IHN0cmF0cy5hdHRhY2hlZCA9IHN0cmF0cy5kZXRhY2hlZCA9IHN0cmF0cy5iZWZvcmVDb21waWxlID0gc3RyYXRzLmNvbXBpbGVkID0gc3RyYXRzLmJlZm9yZURlc3Ryb3kgPSBzdHJhdHMuZGVzdHJveWVkID0gc3RyYXRzLmFjdGl2YXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID8gcGFyZW50VmFsID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbCkgOiBpc0FycmF5KGNoaWxkVmFsKSA/IGNoaWxkVmFsIDogW2NoaWxkVmFsXSA6IHBhcmVudFZhbDtcbn07XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbCA/IGV4dGVuZChyZXMsIGd1YXJkQXJyYXlBc3NldHMoY2hpbGRWYWwpKSA6IHJlcztcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBFdmVudHMgJiBXYXRjaGVycy5cbiAqXG4gKiBFdmVudHMgJiB3YXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuXG5zdHJhdHMud2F0Y2ggPSBzdHJhdHMuZXZlbnRzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFpc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5cbnN0cmF0cy5wcm9wcyA9IHN0cmF0cy5tZXRob2RzID0gc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gZGVmYXVsdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWQgPyBwYXJlbnRWYWwgOiBjaGlsZFZhbDtcbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIGNvbXBvbmVudCBvcHRpb25zIGdldCBjb252ZXJ0ZWQgdG8gYWN0dWFsXG4gKiBjb25zdHJ1Y3RvcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBndWFyZENvbXBvbmVudHMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPSBndWFyZEFycmF5QXNzZXRzKG9wdGlvbnMuY29tcG9uZW50cyk7XG4gICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpO1xuICAgIHZhciBkZWY7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYXAgPSBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXTtcbiAgICAgIGlmIChjb21tb25UYWdSRS50ZXN0KGtleSkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGtleSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBhIGFsbCBsb3dlcmNhc2UgPC0+IGtlYmFiLWNhc2UgbWFwcGluZyBmb3JcbiAgICAgIC8vIHBvc3NpYmxlIGN1c3RvbSBlbGVtZW50IGNhc2UgZXJyb3Igd2FybmluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWFwW2tleS5yZXBsYWNlKC8tL2csICcnKS50b0xvd2VyQ2FzZSgpXSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgfVxuICAgICAgZGVmID0gY29tcG9uZW50c1trZXldO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICBjb21wb25lbnRzW2tleV0gPSBWdWUuZXh0ZW5kKGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRQcm9wcyhvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIHZhciBpLCB2YWw7XG4gIGlmIChpc0FycmF5KHByb3BzKSkge1xuICAgIG9wdGlvbnMucHJvcHMgPSB7fTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMucHJvcHNbdmFsXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMucHJvcHNbdmFsLm5hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXlzW2ldXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzW2tleXNbaV1dID0geyB0eXBlOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHdWFyZCBhbiBBcnJheS1mb3JtYXQgYXNzZXRzIG9wdGlvbiBhbmQgY29udmVydGVkIGl0XG4gKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXNzZXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRBcnJheUFzc2V0cyhhc3NldHMpIHtcbiAgaWYgKGlzQXJyYXkoYXNzZXRzKSkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgaSA9IGFzc2V0cy5sZW5ndGg7XG4gICAgdmFyIGFzc2V0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRzW2ldO1xuICAgICAgdmFyIGlkID0gdHlwZW9mIGFzc2V0ID09PSAnZnVuY3Rpb24nID8gYXNzZXQub3B0aW9ucyAmJiBhc3NldC5vcHRpb25zLm5hbWUgfHwgYXNzZXQuaWQgOiBhc3NldC5uYW1lIHx8IGFzc2V0LmlkO1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2lkXSA9IGFzc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiBhc3NldHM7XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgYW4gaW5zdGFudGlhdGlvbiBtZXJnZS5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcbiAgZ3VhcmRDb21wb25lbnRzKGNoaWxkKTtcbiAgZ3VhcmRQcm9wcyhjaGlsZCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNoaWxkLnByb3BzRGF0YSAmJiAhdm0pIHtcbiAgICAgIHdhcm4oJ3Byb3BzRGF0YSBjYW4gb25seSBiZSB1c2VkIGFzIGFuIGluc3RhbnRpYXRpb24gb3B0aW9uLicpO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBpZiAoY2hpbGRbJ2V4dGVuZHMnXSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBjaGlsZFsnZXh0ZW5kcyddID09PSAnZnVuY3Rpb24nID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGRbJ2V4dGVuZHMnXS5vcHRpb25zLCB2bSkgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZFsnZXh0ZW5kcyddLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgdmFyIG1peGluT3B0aW9ucyA9IG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSA/IG1peGluLm9wdGlvbnMgOiBtaXhpbjtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluT3B0aW9ucywgdm0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtCb29sZWFufSB3YXJuTWlzc2luZ1xuICogQHJldHVybiB7T2JqZWN0fEZ1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3NldChvcHRpb25zLCB0eXBlLCBpZCwgd2Fybk1pc3NpbmcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICB2YXIgY2FtZWxpemVkSWQ7XG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8XG4gIC8vIGNhbWVsQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCldIHx8XG4gIC8vIFBhc2NhbCBDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsaXplZElkLnNsaWNlKDEpXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERlcCgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufVxuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuXG4vKipcbiAqIEFkZCBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMuJHJlbW92ZShzdWIpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbn07XG5cbi8qKlxuICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIG5ldyB2YWx1ZS5cbiAqL1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRvQXJyYXkodGhpcy5zdWJzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xuXG47WydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZScsICdzb3J0JywgJ3JldmVyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aCBhIG5ldyB2YWx1ZVxuICogYW5kIGVtaXRzIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Kn0gLSByZXBsYWNlZCBlbGVtZW50XG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckc2V0JywgZnVuY3Rpb24gJHNldChpbmRleCwgdmFsKSB7XG4gIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRoaXMubGVuZ3RoID0gTnVtYmVyKGluZGV4KSArIDE7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxLCB2YWwpWzBdO1xufSk7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleCBvciB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpdGVtXG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckcmVtb3ZlJywgZnVuY3Rpb24gJHJlbW92ZShpdGVtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcywgaXRlbSk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufSk7XG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciBpbiBjZXJ0YWluIGNhc2VzLCBlLmcuXG4gKiB2LWZvciBzY29wZSBhbGlhcyBhbmQgcHJvcHMsIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvblxuICogYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqIFNvIHdoZW5ldmVyIHdlIHdhbnQgdG8gc2V0IGEgcmVhY3RpdmUgcHJvcGVydHkgd2l0aG91dCBmb3JjaW5nXG4gKiBjb252ZXJzaW9uIG9uIHRoZSBuZXcgdmFsdWUsIHdlIHdyYXAgdGhhdCBjYWxsIGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxuICovXG5cbnZhciBzaG91bGRDb252ZXJ0ID0gdHJ1ZTtcblxuZnVuY3Rpb24gd2l0aG91dENvbnZlcnNpb24oZm4pIHtcbiAgc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICBmbigpO1xuICBzaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG8gPyBwcm90b0F1Z21lbnQgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gSW5zdGFuY2UgbWV0aG9kc1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRoaXMuY29udmVydChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIG93bmVyIHZtLCBzbyB0aGF0IHdoZW4gJHNldC8kZGVsZXRlIG11dGF0aW9uc1xuICogaGFwcGVuIHdlIGNhbiBub3RpZnkgb3duZXIgdm1zIHRvIHByb3h5IHRoZSBrZXlzIGFuZFxuICogZGlnZXN0IHRoZSB3YXRjaGVycy4gVGhpcyBpcyBvbmx5IGNhbGxlZCB3aGVuIHRoZSBvYmplY3RcbiAqIGlzIG9ic2VydmVkIGFzIGFuIGluc3RhbmNlJ3Mgcm9vdCAkZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuYWRkVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgKHRoaXMudm1zIHx8ICh0aGlzLnZtcyA9IFtdKSkucHVzaCh2bSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBvd25lciB2bS4gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IGlzXG4gKiBzd2FwcGVkIG91dCBhcyBhbiBpbnN0YW5jZSdzICRkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUucmVtb3ZlVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgdGhpcy52bXMuJHJlbW92ZSh2bSk7XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKi9cblxuZnVuY3Rpb24gcHJvdG9BdWdtZW50KHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50KHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcmV0dXJuIHtPYnNlcnZlcnx1bmRlZmluZWR9XG4gKiBAc3RhdGljXG4gKi9cblxuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSwgdm0pIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoc2hvdWxkQ29udmVydCAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmICF2YWx1ZS5faXNWdWUpIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKG9iICYmIHZtKSB7XG4gICAgb2IuYWRkVm0odm0pO1xuICB9XG4gIHJldHVybiBvYjtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAodmFyIGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsdWVbaV07XG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG52YXIgdXRpbCA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUsXG5cdHNldDogc2V0LFxuXHRkZWw6IGRlbCxcblx0aGFzT3duOiBoYXNPd24sXG5cdGlzTGl0ZXJhbDogaXNMaXRlcmFsLFxuXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuXHRfdG9TdHJpbmc6IF90b1N0cmluZyxcblx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHR0b0Jvb2xlYW46IHRvQm9vbGVhbixcblx0c3RyaXBRdW90ZXM6IHN0cmlwUXVvdGVzLFxuXHRjYW1lbGl6ZTogY2FtZWxpemUsXG5cdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuXHRjbGFzc2lmeTogY2xhc3NpZnksXG5cdGJpbmQ6IGJpbmQsXG5cdHRvQXJyYXk6IHRvQXJyYXksXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdGRlZjogZGVmLFxuXHRkZWJvdW5jZTogX2RlYm91bmNlLFxuXHRpbmRleE9mOiBpbmRleE9mLFxuXHRjYW5jZWxsYWJsZTogY2FuY2VsbGFibGUsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGlzQXJyYXk6IGlzQXJyYXksXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdGRldnRvb2xzOiBkZXZ0b29scyxcblx0aXNJRTogaXNJRSxcblx0aXNJRTk6IGlzSUU5LFxuXHRpc0FuZHJvaWQ6IGlzQW5kcm9pZCxcblx0aXNJb3M6IGlzSW9zLFxuXHRpb3NWZXJzaW9uTWF0Y2g6IGlvc1ZlcnNpb25NYXRjaCxcblx0aW9zVmVyc2lvbjogaW9zVmVyc2lvbixcblx0aGFzTXV0YXRpb25PYnNlcnZlckJ1ZzogaGFzTXV0YXRpb25PYnNlcnZlckJ1Zyxcblx0Z2V0IHRyYW5zaXRpb25Qcm9wICgpIHsgcmV0dXJuIHRyYW5zaXRpb25Qcm9wOyB9LFxuXHRnZXQgdHJhbnNpdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIHRyYW5zaXRpb25FbmRFdmVudDsgfSxcblx0Z2V0IGFuaW1hdGlvblByb3AgKCkgeyByZXR1cm4gYW5pbWF0aW9uUHJvcDsgfSxcblx0Z2V0IGFuaW1hdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIGFuaW1hdGlvbkVuZEV2ZW50OyB9LFxuXHRuZXh0VGljazogbmV4dFRpY2ssXG5cdGdldCBfU2V0ICgpIHsgcmV0dXJuIF9TZXQ7IH0sXG5cdHF1ZXJ5OiBxdWVyeSxcblx0aW5Eb2M6IGluRG9jLFxuXHRnZXRBdHRyOiBnZXRBdHRyLFxuXHRnZXRCaW5kQXR0cjogZ2V0QmluZEF0dHIsXG5cdGhhc0JpbmRBdHRyOiBoYXNCaW5kQXR0cixcblx0YmVmb3JlOiBiZWZvcmUsXG5cdGFmdGVyOiBhZnRlcixcblx0cmVtb3ZlOiByZW1vdmUsXG5cdHByZXBlbmQ6IHByZXBlbmQsXG5cdHJlcGxhY2U6IHJlcGxhY2UsXG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdGV4dHJhY3RDb250ZW50OiBleHRyYWN0Q29udGVudCxcblx0dHJpbU5vZGU6IHRyaW1Ob2RlLFxuXHRpc1RlbXBsYXRlOiBpc1RlbXBsYXRlLFxuXHRjcmVhdGVBbmNob3I6IGNyZWF0ZUFuY2hvcixcblx0ZmluZFJlZjogZmluZFJlZixcblx0bWFwTm9kZVJhbmdlOiBtYXBOb2RlUmFuZ2UsXG5cdHJlbW92ZU5vZGVSYW5nZTogcmVtb3ZlTm9kZVJhbmdlLFxuXHRpc0ZyYWdtZW50OiBpc0ZyYWdtZW50LFxuXHRnZXRPdXRlckhUTUw6IGdldE91dGVySFRNTCxcblx0bWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG5cdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuXHRjaGVja0NvbXBvbmVudEF0dHI6IGNoZWNrQ29tcG9uZW50QXR0cixcblx0Y29tbW9uVGFnUkU6IGNvbW1vblRhZ1JFLFxuXHRyZXNlcnZlZFRhZ1JFOiByZXNlcnZlZFRhZ1JFLFxuXHRnZXQgd2FybiAoKSB7IHJldHVybiB3YXJuOyB9XG59KTtcblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICogaW5zdGFuY2UsIGluY2x1ZGluZyBvbmVzIHRoYXQgYXJlIGNyZWF0ZWQgZnJvbSBleHRlbmRlZFxuICAgKiBjb25zdHJ1Y3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhpcyBvcHRpb25zIG9iamVjdCBzaG91bGQgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVzdWx0IG9mIG1lcmdpbmcgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy4kZWwgPSBudWxsO1xuICAgIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuJHJvb3QgPSB0aGlzLiRwYXJlbnQgPyB0aGlzLiRwYXJlbnQuJHJvb3QgOiB0aGlzO1xuICAgIHRoaXMuJGNoaWxkcmVuID0gW107XG4gICAgdGhpcy4kcmVmcyA9IHt9OyAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gICAgdGhpcy4kZWxzID0ge307IC8vIGVsZW1lbnQgcmVmZXJlbmNlc1xuICAgIHRoaXMuX3dhdGNoZXJzID0gW107IC8vIGFsbCB3YXRjaGVycyBhcyBhbiBhcnJheVxuICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBbXTsgLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAgIC8vIGEgdWlkXG4gICAgdGhpcy5fdWlkID0gdWlkKys7XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHRoaXMuX2lzVnVlID0gdHJ1ZTtcblxuICAgIC8vIGV2ZW50cyBib29ra2VlcGluZ1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9OyAvLyByZWdpc3RlcmVkIGNhbGxiYWNrc1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0ge307IC8vIGZvciAkYnJvYWRjYXN0IG9wdGltaXphdGlvblxuXG4gICAgLy8gZnJhZ21lbnQgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgIHRoaXMuX2lzRnJhZ21lbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9mcmFnbWVudCA9IC8vIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fVxuICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQgPSAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbDsgLy8gQHR5cGUge1RleHR8Q29tbWVudH1cblxuICAgIC8vIGxpZmVjeWNsZSBzdGF0ZVxuICAgIHRoaXMuX2lzQ29tcGlsZWQgPSB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRoaXMuX2lzUmVhZHkgPSB0aGlzLl9pc0F0dGFjaGVkID0gdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRoaXMuX3ZGb3JSZW1vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3VubGlua0ZuID0gbnVsbDtcblxuICAgIC8vIGNvbnRleHQ6XG4gICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICB0aGlzLl9jb250ZXh0ID0gb3B0aW9ucy5fY29udGV4dCB8fCB0aGlzLiRwYXJlbnQ7XG5cbiAgICAvLyBzY29wZTpcbiAgICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgdGhpcy5fc2NvcGUgPSBvcHRpb25zLl9zY29wZTtcblxuICAgIC8vIGZyYWdtZW50OlxuICAgIC8vIGlmIHRoaXMgaW5zdGFuY2UgaXMgY29tcGlsZWQgaW5zaWRlIGEgRnJhZ21lbnQsIGl0XG4gICAgLy8gbmVlZHMgdG8gcmVpZ3N0ZXIgaXRzZWxmIGFzIGEgY2hpbGQgb2YgdGhhdCBmcmFnbWVudFxuICAgIC8vIGZvciBhdHRhY2gvZGV0YWNoIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgdGhpcy5fZnJhZyA9IG9wdGlvbnMuX2ZyYWc7XG4gICAgaWYgKHRoaXMuX2ZyYWcpIHtcbiAgICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIHNlbGYgaW50byBwYXJlbnQgLyB0cmFuc2NsdXNpb24gaG9zdFxuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudC4kY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBvcHRpb25zLlxuICAgIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgb3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBzZXQgcmVmXG4gICAgdGhpcy5fdXBkYXRlUmVmKCk7XG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgYXMgZW1wdHkgb2JqZWN0LlxuICAgIC8vIGl0IHdpbGwgYmUgZmlsbGVkIHVwIGluIF9pbml0RGF0YSgpLlxuICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgIC8vIGNhbGwgaW5pdCBob29rXG4gICAgdGhpcy5fY2FsbEhvb2soJ2luaXQnKTtcblxuICAgIC8vIGluaXRpYWxpemUgZGF0YSBvYnNlcnZhdGlvbiBhbmQgc2NvcGUgaW5oZXJpdGFuY2UuXG4gICAgdGhpcy5faW5pdFN0YXRlKCk7XG5cbiAgICAvLyBzZXR1cCBldmVudCBzeXN0ZW0gYW5kIG9wdGlvbiBldmVudHMuXG4gICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgLy8gY2FsbCBjcmVhdGVkIGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnY3JlYXRlZCcpO1xuXG4gICAgLy8gaWYgYGVsYCBvcHRpb24gaXMgcGFzc2VkLCBzdGFydCBjb21waWxhdGlvbi5cbiAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG4vLyBhY3Rpb25zXG52YXIgQVBQRU5EID0gMDtcbnZhciBQVVNIID0gMTtcbnZhciBJTkNfU1VCX1BBVEhfREVQVEggPSAyO1xudmFyIFBVU0hfU1VCX1BBVEggPSAzO1xuXG4vLyBzdGF0ZXNcbnZhciBCRUZPUkVfUEFUSCA9IDA7XG52YXIgSU5fUEFUSCA9IDE7XG52YXIgQkVGT1JFX0lERU5UID0gMjtcbnZhciBJTl9JREVOVCA9IDM7XG52YXIgSU5fU1VCX1BBVEggPSA0O1xudmFyIElOX1NJTkdMRV9RVU9URSA9IDU7XG52YXIgSU5fRE9VQkxFX1FVT1RFID0gNjtcbnZhciBBRlRFUl9QQVRIID0gNztcbnZhciBFUlJPUiA9IDg7XG5cbnZhciBwYXRoU3RhdGVNYWNoaW5lID0gW107XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX1BBVEhdID0ge1xuICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9QQVRIXSA9IHtcbiAgJ3dzJzogW0lOX1BBVEhdLFxuICAnLic6IFtCRUZPUkVfSURFTlRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX0lERU5UXSA9IHtcbiAgJ3dzJzogW0JFRk9SRV9JREVOVF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJzAnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICd3cyc6IFtJTl9QQVRILCBQVVNIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5ULCBQVVNIXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIFBVU0hdLFxuICAnZW9mJzogW0FGVEVSX1BBVEgsIFBVU0hdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgXCInXCI6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF0sXG4gICdcIic6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF0sXG4gICdbJzogW0lOX1NVQl9QQVRILCBJTkNfU1VCX1BBVEhfREVQVEhdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIX1NVQl9QQVRIXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9TSU5HTEVfUVVPVEVdID0ge1xuICBcIidcIjogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9ET1VCTEVfUVVPVEVdID0ge1xuICAnXCInOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdHlwZSBvZiBhIGNoYXJhY3RlciBpbiBhIGtleXBhdGguXG4gKlxuICogQHBhcmFtIHtDaGFyfSBjaFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aENoYXJUeXBlKGNoKSB7XG4gIGlmIChjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdlb2YnO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHg1QjogLy8gW1xuICAgIGNhc2UgMHg1RDogLy8gXVxuICAgIGNhc2UgMHgyRTogLy8gLlxuICAgIGNhc2UgMHgyMjogLy8gXCJcbiAgICBjYXNlIDB4Mjc6IC8vICdcbiAgICBjYXNlIDB4MzA6XG4gICAgICAvLyAwXG4gICAgICByZXR1cm4gY2g7XG5cbiAgICBjYXNlIDB4NUY6IC8vIF9cbiAgICBjYXNlIDB4MjQ6XG4gICAgICAvLyAkXG4gICAgICByZXR1cm4gJ2lkZW50JztcblxuICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICBjYXNlIDB4MDk6IC8vIFRhYlxuICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgY2FzZSAweEEwOiAvLyBOby1icmVhayBzcGFjZVxuICAgIGNhc2UgMHhGRUZGOiAvLyBCeXRlIE9yZGVyIE1hcmtcbiAgICBjYXNlIDB4MjAyODogLy8gTGluZSBTZXBhcmF0b3JcbiAgICBjYXNlIDB4MjAyOTpcbiAgICAgIC8vIFBhcmFncmFwaCBTZXBhcmF0b3JcbiAgICAgIHJldHVybiAnd3MnO1xuICB9XG5cbiAgLy8gYS16LCBBLVpcbiAgaWYgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EgfHwgY29kZSA+PSAweDQxICYmIGNvZGUgPD0gMHg1QSkge1xuICAgIHJldHVybiAnaWRlbnQnO1xuICB9XG5cbiAgLy8gMS05XG4gIGlmIChjb2RlID49IDB4MzEgJiYgY29kZSA8PSAweDM5KSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgcmV0dXJuICdlbHNlJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzdWJQYXRoLCByZXR1cm4gaXRzIHBsYWluIGZvcm0gaWYgaXQgaXNcbiAqIGEgbGl0ZXJhbCBzdHJpbmcgb3IgbnVtYmVyLiBPdGhlcndpc2UgcHJlcGVuZCB0aGVcbiAqIGR5bmFtaWMgaW5kaWNhdG9yICgqKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFN1YlBhdGgocGF0aCkge1xuICB2YXIgdHJpbW1lZCA9IHBhdGgudHJpbSgpO1xuICAvLyBpbnZhbGlkIGxlYWRpbmcgMFxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcwJyAmJiBpc05hTihwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNMaXRlcmFsKHRyaW1tZWQpID8gc3RyaXBRdW90ZXModHJpbW1lZCkgOiAnKicgKyB0cmltbWVkO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIHBhdGggaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIG1vZGUgPSBCRUZPUkVfUEFUSDtcbiAgdmFyIHN1YlBhdGhEZXB0aCA9IDA7XG4gIHZhciBjLCBuZXdDaGFyLCBrZXksIHR5cGUsIHRyYW5zaXRpb24sIGFjdGlvbiwgdHlwZU1hcDtcblxuICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gIGFjdGlvbnNbUFVTSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tBUFBFTkRdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gbmV3Q2hhcjtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ICs9IG5ld0NoYXI7XG4gICAgfVxuICB9O1xuXG4gIGFjdGlvbnNbSU5DX1NVQl9QQVRIX0RFUFRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICBzdWJQYXRoRGVwdGgrKztcbiAgfTtcblxuICBhY3Rpb25zW1BVU0hfU1VCX1BBVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdWJQYXRoRGVwdGggPiAwKSB7XG4gICAgICBzdWJQYXRoRGVwdGgtLTtcbiAgICAgIG1vZGUgPSBJTl9TVUJfUEFUSDtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJQYXRoRGVwdGggPSAwO1xuICAgICAga2V5ID0gZm9ybWF0U3ViUGF0aChrZXkpO1xuICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uc1tQVVNIXSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXliZVVuZXNjYXBlUXVvdGUoKSB7XG4gICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdO1xuICAgIGlmIChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiIHx8IG1vZGUgPT09IElOX0RPVUJMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgaW5kZXgrKztcbiAgICAgIG5ld0NoYXIgPSAnXFxcXCcgKyBuZXh0Q2hhcjtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKG1vZGUgIT0gbnVsbCkge1xuICAgIGluZGV4Kys7XG4gICAgYyA9IHBhdGhbaW5kZXhdO1xuXG4gICAgaWYgKGMgPT09ICdcXFxcJyAmJiBtYXliZVVuZXNjYXBlUXVvdGUoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IGdldFBhdGhDaGFyVHlwZShjKTtcbiAgICB0eXBlTWFwID0gcGF0aFN0YXRlTWFjaGluZVttb2RlXTtcbiAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1I7XG5cbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gRVJST1IpIHtcbiAgICAgIHJldHVybjsgLy8gcGFyc2UgZXJyb3JcbiAgICB9XG5cbiAgICBtb2RlID0gdHJhbnNpdGlvblswXTtcbiAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dO1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIG5ld0NoYXIgPSB0cmFuc2l0aW9uWzJdO1xuICAgICAgbmV3Q2hhciA9IG5ld0NoYXIgPT09IHVuZGVmaW5lZCA/IGMgOiBuZXdDaGFyO1xuICAgICAgaWYgKGFjdGlvbigpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09IEFGVEVSX1BBVEgpIHtcbiAgICAgIGtleXMucmF3ID0gcGF0aDtcbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4dGVybmFsIHBhcnNlIHRoYXQgY2hlY2sgZm9yIGEgY2FjaGUgaGl0IGZpcnN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgaGl0ID0gcGF0aENhY2hlLmdldChwYXRoKTtcbiAgaWYgKCFoaXQpIHtcbiAgICBoaXQgPSBwYXJzZShwYXRoKTtcbiAgICBpZiAoaGl0KSB7XG4gICAgICBwYXRoQ2FjaGUucHV0KHBhdGgsIGhpdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoaXQ7XG59XG5cbi8qKlxuICogR2V0IGZyb20gYW4gb2JqZWN0IGZyb20gYSBwYXRoIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbihwYXRoKS5nZXQob2JqKTtcbn1cblxuLyoqXG4gKiBXYXJuIGFnYWluc3Qgc2V0dGluZyBub24tZXhpc3RlbnQgcm9vdCBwYXRoIG9uIGEgdm0uXG4gKi9cblxudmFyIHdhcm5Ob25FeGlzdGVudDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5Ob25FeGlzdGVudCA9IGZ1bmN0aW9uIChwYXRoLCB2bSkge1xuICAgIHdhcm4oJ1lvdSBhcmUgc2V0dGluZyBhIG5vbi1leGlzdGVudCBwYXRoIFwiJyArIHBhdGgucmF3ICsgJ1wiICcgKyAnb24gYSB2bSBpbnN0YW5jZS4gQ29uc2lkZXIgcHJlLWluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgJyArICd3aXRoIHRoZSBcImRhdGFcIiBvcHRpb24gZm9yIG1vcmUgcmVsaWFibGUgcmVhY3Rpdml0eSAnICsgJ2FuZCBiZXR0ZXIgcGVyZm9ybWFuY2UuJywgdm0pO1xuICB9O1xufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gb2JqO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhcnNlKHBhdGgpO1xuICB9XG4gIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdCwga2V5O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGFzdCA9IG9iajtcbiAgICBrZXkgPSBwYXRoW2ldO1xuICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnKicpIHtcbiAgICAgIGtleSA9IHBhcnNlRXhwcmVzc2lvbihrZXkuc2xpY2UoMSkpLmdldC5jYWxsKG9yaWdpbmFsLCBvcmlnaW5hbCk7XG4gICAgfVxuICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBsYXN0Ll9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoLCBsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQobGFzdCwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9iai5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQob2JqLCBrZXksIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgcGF0aCA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZVBhdGg6IHBhcnNlUGF0aCxcbiAgZ2V0UGF0aDogZ2V0UGF0aCxcbiAgc2V0UGF0aDogc2V0UGF0aFxufSk7XG5cbnZhciBleHByZXNzaW9uQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBhbGxvd2VkS2V5d29yZHMgPSAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICsgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0JztcbnZhciBhbGxvd2VkS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGFsbG93ZWRLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxuLy8ga2V5d29yZHMgdGhhdCBkb24ndCBtYWtlIHNlbnNlIGluc2lkZSBleHByZXNzaW9uc1xudmFyIGltcHJvcGVyS2V5d29yZHMgPSAnYnJlYWssY2FzZSxjbGFzcyxjYXRjaCxjb25zdCxjb250aW51ZSxkZWJ1Z2dlcixkZWZhdWx0LCcgKyAnZGVsZXRlLGRvLGVsc2UsZXhwb3J0LGV4dGVuZHMsZmluYWxseSxmb3IsZnVuY3Rpb24saWYsJyArICdpbXBvcnQsaW4saW5zdGFuY2VvZixsZXQscmV0dXJuLHN1cGVyLHN3aXRjaCx0aHJvdyx0cnksJyArICd2YXIsd2hpbGUsd2l0aCx5aWVsZCxlbnVtLGF3YWl0LGltcGxlbWVudHMscGFja2FnZSwnICsgJ3Byb3RlY3RlZCxzdGF0aWMsaW50ZXJmYWNlLHByaXZhdGUscHVibGljJztcbnZhciBpbXByb3BlcktleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBpbXByb3BlcktleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpO1xuXG52YXIgd3NSRSA9IC9cXHMvZztcbnZhciBuZXdsaW5lUkUgPSAvXFxuL2c7XG52YXIgc2F2ZVJFID0gL1tcXHssXVxccypbXFx3XFwkX10rXFxzKjp8KCcoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgKXxuZXcgfHR5cGVvZiB8dm9pZCAvZztcbnZhciByZXN0b3JlUkUgPSAvXCIoXFxkKylcIi9nO1xudmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXXxcXFtcXGQrXFxdfFxcW1tBLVphLXpfJF1bXFx3JF0qXFxdKSokLztcbnZhciBpZGVudFJFID0gL1teXFx3JFxcLl0oPzpbQS1aYS16XyRdW1xcdyRdKikvZztcbnZhciBsaXRlcmFsVmFsdWVSRSQxID0gL14oPzp0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkfEluZmluaXR5fE5hTikkLztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogU2F2ZSAvIFJld3JpdGUgLyBSZXN0b3JlXG4gKlxuICogV2hlbiByZXdyaXRpbmcgcGF0aHMgZm91bmQgaW4gYW4gZXhwcmVzc2lvbiwgaXQgaXNcbiAqIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBsZXR0ZXIgc2VxdWVuY2VzIHRvIGJlIGZvdW5kIGluXG4gKiBzdHJpbmdzIGFuZCBPYmplY3QgbGl0ZXJhbCBwcm9wZXJ0eSBrZXlzLiBUaGVyZWZvcmUgd2VcbiAqIHJlbW92ZSBhbmQgc3RvcmUgdGhlc2UgcGFydHMgaW4gYSB0ZW1wb3JhcnkgYXJyYXksIGFuZFxuICogcmVzdG9yZSB0aGVtIGFmdGVyIHRoZSBwYXRoIHJld3JpdGUuXG4gKi9cblxudmFyIHNhdmVkID0gW107XG5cbi8qKlxuICogU2F2ZSByZXBsYWNlclxuICpcbiAqIFRoZSBzYXZlIHJlZ2V4IGNhbiBtYXRjaCB0d28gcG9zc2libGUgY2FzZXM6XG4gKiAxLiBBbiBvcGVuaW5nIG9iamVjdCBsaXRlcmFsXG4gKiAyLiBBIHN0cmluZ1xuICogSWYgbWF0Y2hlZCBhcyBhIHBsYWluIHN0cmluZywgd2UgbmVlZCB0byBlc2NhcGUgaXRzXG4gKiBuZXdsaW5lcywgc2luY2UgdGhlIHN0cmluZyBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgd2hlblxuICogZ2VuZXJhdGluZyB0aGUgZnVuY3Rpb24gYm9keS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaXNTdHJpbmcgLSBzdHIgaWYgbWF0Y2hlZCBhcyBhIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSAtIHBsYWNlaG9sZGVyIHdpdGggaW5kZXhcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKHN0ciwgaXNTdHJpbmcpIHtcbiAgdmFyIGkgPSBzYXZlZC5sZW5ndGg7XG4gIHNhdmVkW2ldID0gaXNTdHJpbmcgPyBzdHIucmVwbGFjZShuZXdsaW5lUkUsICdcXFxcbicpIDogc3RyO1xuICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xufVxuXG4vKipcbiAqIFBhdGggcmV3cml0ZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXdyaXRlKHJhdykge1xuICB2YXIgYyA9IHJhdy5jaGFyQXQoMCk7XG4gIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpO1xuICBpZiAoYWxsb3dlZEtleXdvcmRzUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVybiByYXc7XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignXCInKSA+IC0xID8gcGF0aC5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSkgOiBwYXRoO1xuICAgIHJldHVybiBjICsgJ3Njb3BlLicgKyBwYXRoO1xuICB9XG59XG5cbi8qKlxuICogUmVzdG9yZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpIC0gbWF0Y2hlZCBzYXZlIGluZGV4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZShzdHIsIGkpIHtcbiAgcmV0dXJuIHNhdmVkW2ldO1xufVxuXG4vKipcbiAqIFJld3JpdGUgYW4gZXhwcmVzc2lvbiwgcHJlZml4aW5nIGFsbCBwYXRoIGFjY2Vzc29ycyB3aXRoXG4gKiBgc2NvcGUuYCBhbmQgZ2VuZXJhdGUgZ2V0dGVyL3NldHRlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUdldHRlcihleHApIHtcbiAgaWYgKGltcHJvcGVyS2V5d29yZHNSRS50ZXN0KGV4cCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIHVzaW5nIHJlc2VydmVkIGtleXdvcmRzIGluIGV4cHJlc3Npb246ICcgKyBleHApO1xuICB9XG4gIC8vIHJlc2V0IHN0YXRlXG4gIHNhdmVkLmxlbmd0aCA9IDA7XG4gIC8vIHNhdmUgc3RyaW5ncyBhbmQgb2JqZWN0IGxpdGVyYWwga2V5c1xuICB2YXIgYm9keSA9IGV4cC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSkucmVwbGFjZSh3c1JFLCAnJyk7XG4gIC8vIHJld3JpdGUgYWxsIHBhdGhzXG4gIC8vIHBhZCAxIHNwYWNlIGhlcmUgYmVjYXVzZSB0aGUgcmVnZXggbWF0Y2hlcyAxIGV4dHJhIGNoYXJcbiAgYm9keSA9ICgnICcgKyBib2R5KS5yZXBsYWNlKGlkZW50UkUsIHJld3JpdGUpLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKTtcbiAgcmV0dXJuIG1ha2VHZXR0ZXJGbihib2R5KTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGdldHRlciBmdW5jdGlvbi4gUmVxdWlyZXMgZXZhbC5cbiAqXG4gKiBXZSBpc29sYXRlIHRoZSB0cnkvY2F0Y2ggc28gaXQgZG9lc24ndCBhZmZlY3QgdGhlXG4gKiBvcHRpbWl6YXRpb24gb2YgdGhlIHBhcnNlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgbm90IGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keVxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXJGbihib2R5KSB7XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdzY29wZScsICdyZXR1cm4gJyArIGJvZHkgKyAnOycpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIGRlZmF1bHQgYnVpbGQgb2YgVnVlLmpzIGluIGFuIGVudmlyb25tZW50ICcgKyAnd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArICdVc2UgdGhlIENTUC1jb21wbGlhbnQgYnVpbGQgaW5zdGVhZDogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2luc3RhbGxhdGlvbi5odG1sI0NTUC1jb21wbGlhbnQtYnVpbGQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArICdHZW5lcmF0ZWQgZnVuY3Rpb24gYm9keTogJyArIGJvZHkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9vcDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlU2V0dGVyKGV4cCkge1xuICB2YXIgcGF0aCA9IHBhcnNlUGF0aChleHApO1xuICBpZiAocGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIHZhbCkge1xuICAgICAgc2V0UGF0aChzY29wZSwgcGF0aCwgdmFsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBzZXR0ZXIgZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBleHByZXNzaW9uIGludG8gcmUtd3JpdHRlbiBnZXR0ZXIvc2V0dGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5lZWRTZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihleHAsIG5lZWRTZXQpIHtcbiAgZXhwID0gZXhwLnRyaW0oKTtcbiAgLy8gdHJ5IGNhY2hlXG4gIHZhciBoaXQgPSBleHByZXNzaW9uQ2FjaGUuZ2V0KGV4cCk7XG4gIGlmIChoaXQpIHtcbiAgICBpZiAobmVlZFNldCAmJiAhaGl0LnNldCkge1xuICAgICAgaGl0LnNldCA9IGNvbXBpbGVTZXR0ZXIoaGl0LmV4cCk7XG4gICAgfVxuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgdmFyIHJlcyA9IHsgZXhwOiBleHAgfTtcbiAgcmVzLmdldCA9IGlzU2ltcGxlUGF0aChleHApICYmIGV4cC5pbmRleE9mKCdbJykgPCAwXG4gIC8vIG9wdGltaXplZCBzdXBlciBzaW1wbGUgZ2V0dGVyXG4gID8gbWFrZUdldHRlckZuKCdzY29wZS4nICsgZXhwKVxuICAvLyBkeW5hbWljIGdldHRlclxuICA6IGNvbXBpbGVHZXR0ZXIoZXhwKTtcbiAgaWYgKG5lZWRTZXQpIHtcbiAgICByZXMuc2V0ID0gY29tcGlsZVNldHRlcihleHApO1xuICB9XG4gIGV4cHJlc3Npb25DYWNoZS5wdXQoZXhwLCByZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBzaW1wbGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU2ltcGxlUGF0aChleHApIHtcbiAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gIC8vIGRvbid0IHRyZWF0IGxpdGVyYWwgdmFsdWVzIGFzIHBhdGhzXG4gICFsaXRlcmFsVmFsdWVSRSQxLnRlc3QoZXhwKSAmJlxuICAvLyBNYXRoIGNvbnN0YW50cyBlLmcuIE1hdGguUEksIE1hdGguRSBldGMuXG4gIGV4cC5zbGljZSgwLCA1KSAhPT0gJ01hdGguJztcbn1cblxudmFyIGV4cHJlc3Npb24gPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VFeHByZXNzaW9uOiBwYXJzZUV4cHJlc3Npb24sXG4gIGlzU2ltcGxlUGF0aDogaXNTaW1wbGVQYXRoXG59KTtcblxuLy8gd2UgaGF2ZSB0d28gc2VwYXJhdGUgcXVldWVzOiBvbmUgZm9yIGRpcmVjdGl2ZSB1cGRhdGVzXG4vLyBhbmQgb25lIGZvciB1c2VyIHdhdGNoZXIgcmVnaXN0ZXJlZCB2aWEgJHdhdGNoKCkuXG4vLyB3ZSB3YW50IHRvIGd1YXJhbnRlZSBkaXJlY3RpdmUgdXBkYXRlcyB0byBiZSBjYWxsZWRcbi8vIGJlZm9yZSB1c2VyIHdhdGNoZXJzIHNvIHRoYXQgd2hlbiB1c2VyIHdhdGNoZXJzIGFyZVxuLy8gdHJpZ2dlcmVkLCB0aGUgRE9NIHdvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIGluIHVwZGF0ZWRcbi8vIHN0YXRlLlxuXG52YXIgcXVldWUgPSBbXTtcbnZhciB1c2VyUXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlKCkge1xuICBxdWV1ZS5sZW5ndGggPSAwO1xuICB1c2VyUXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGNpcmN1bGFyID0ge307XG4gIHdhaXRpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaEJhdGNoZXJRdWV1ZSgpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgX2FnYWluID0gZmFsc2U7XG5cbiAgICBydW5CYXRjaGVyUXVldWUocXVldWUpO1xuICAgIHJ1bkJhdGNoZXJRdWV1ZSh1c2VyUXVldWUpO1xuICAgIC8vIHVzZXIgd2F0Y2hlcnMgdHJpZ2dlcmVkIG1vcmUgd2F0Y2hlcnMsXG4gICAgLy8ga2VlcCBmbHVzaGluZyB1bnRpbCBpdCBkZXBsZXRlc1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICBjb250aW51ZSBfZnVuY3Rpb247XG4gICAgfVxuICAgIC8vIGRldiB0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgICByZXNldEJhdGNoZXJTdGF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogUnVuIHRoZSB3YXRjaGVycyBpbiBhIHNpbmdsZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICovXG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCBmb3Igd2F0Y2hlciAnICsgJ3dpdGggZXhwcmVzc2lvbiBcIicgKyB3YXRjaGVyLmV4cHJlc3Npb24gKyAnXCInLCB3YXRjaGVyLnZtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmZ1bmN0aW9uIHB1c2hXYXRjaGVyKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIHB1c2ggd2F0Y2hlciBpbnRvIGFwcHJvcHJpYXRlIHF1ZXVlXG4gICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZTtcbiAgICBoYXNbaWRdID0gcS5sZW5ndGg7XG4gICAgcS5wdXNoKHdhdGNoZXIpO1xuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaEJhdGNoZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZXhwT3JGblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGlzRm4gPSB0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJztcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbjtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMucHJldkVycm9yID0gbnVsbDsgLy8gZm9yIGFzeW5jIGVycm9yIHN0YWNrc1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXIvc2V0dGVyXG4gIGlmIChpc0ZuKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwT3JGbiwgdGhpcy50d29XYXkpO1xuICAgIHRoaXMuZ2V0dGVyID0gcmVzLmdldDtcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXQ7XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG4gIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgLy8gd2F0Y2hlcnMgZHVyaW5nIHZtLl9kaWdlc3QoKVxuICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmVmb3JlR2V0KCk7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgdmFyIHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgZXhwcmVzc2lvbiAnICsgJ1wiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIjogJyArIGUudG9TdHJpbmcoKSwgdGhpcy52bSk7XG4gICAgfVxuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIG51bGwsIHRoaXMuZmlsdGVycywgZmFsc2UpO1xuICB9XG4gIGlmICh0aGlzLnBvc3RQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnBvc3RQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICB0aGlzLmFmdGVyR2V0KCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy5maWx0ZXJzLCB0cnVlKTtcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBzZXR0ZXIgJyArICdcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCI6ICcgKyBlLnRvU3RyaW5nKCksIHRoaXMudm0pO1xuICAgIH1cbiAgfVxuICAvLyB0d28td2F5IHN5bmMgZm9yIHYtZm9yIGFsaWFzXG4gIHZhciBmb3JDb250ZXh0ID0gc2NvcGUuJGZvckNvbnRleHQ7XG4gIGlmIChmb3JDb250ZXh0ICYmIGZvckNvbnRleHQuYWxpYXMgPT09IHRoaXMuZXhwcmVzc2lvbikge1xuICAgIGlmIChmb3JDb250ZXh0LmZpbHRlcnMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0d28td2F5IGJpbmRpbmcgb24gJyArICdhIHYtZm9yIGFsaWFzICgnICsgdGhpcy5leHByZXNzaW9uICsgJyksIGFuZCB0aGUgJyArICd2LWZvciBoYXMgZmlsdGVycy4gVGhpcyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5LiAnICsgJ0VpdGhlciByZW1vdmUgdGhlIGZpbHRlcnMgb3IgdXNlIGFuIGFycmF5IG9mICcgKyAnb2JqZWN0cyBhbmQgYmluZCB0byBvYmplY3QgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3JDb250ZXh0Ll93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgICAvLyBvcmlnaW5hbCBpcyBhbiBvYmplY3RcbiAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZVtzY29wZS4ka2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZS4kc2V0KHNjb3BlLiRpbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFByZXBhcmUgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5iZWZvcmVHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGw7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2hhbGxvdykge1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jIHx8ICFjb25maWcuYXN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIHF1ZXVlZCwgb25seSBvdmVyd3JpdGUgc2hhbGxvdyB3aXRoIG5vbi1zaGFsbG93LFxuICAgIC8vIGJ1dCBub3QgdGhlIG90aGVyIHdheSBhcm91bmQuXG4gICAgdGhpcy5zaGFsbG93ID0gdGhpcy5xdWV1ZWQgPyBzaGFsbG93ID8gdGhpcy5zaGFsbG93IDogZmFsc2UgOiAhIXNoYWxsb3c7XG4gICAgdGhpcy5xdWV1ZWQgPSB0cnVlO1xuICAgIC8vIHJlY29yZCBiZWZvcmUtcHVzaCBlcnJvciBzdGFjayBpbiBkZWJ1ZyBtb2RlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnKSB7XG4gICAgICB0aGlzLnByZXZFcnJvciA9IG5ldyBFcnJvcignW3Z1ZV0gYXN5bmMgc3RhY2sgdHJhY2UnKTtcbiAgICB9XG4gICAgcHVzaFdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmF0Y2hlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIGJhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAvLyBoYXZlIG11dGF0ZWQ7IGJ1dCBvbmx5IGRvIHNvIGlmIHRoaXMgaXMgYVxuICAgIC8vIG5vbi1zaGFsbG93IHVwZGF0ZSAoY2F1c2VkIGJ5IGEgdm0gZGlnZXN0KS5cbiAgICAoaXNPYmplY3QodmFsdWUpIHx8IHRoaXMuZGVlcCkgJiYgIXRoaXMuc2hhbGxvdykge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIGluIGRlYnVnICsgYXN5bmMgbW9kZSwgd2hlbiBhIHdhdGNoZXIgY2FsbGJhY2tzXG4gICAgICAvLyB0aHJvd3MsIHdlIGFsc28gdGhyb3cgdGhlIHNhdmVkIGJlZm9yZS1wdXNoIGVycm9yXG4gICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgIHZhciBwcmV2RXJyb3IgPSB0aGlzLnByZXZFcnJvcjtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnICYmIHByZXZFcnJvcikge1xuICAgICAgICB0aGlzLnByZXZFcnJvciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBwcmV2RXJyb3I7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBhdm9pZCBvdmVyd3JpdGluZyBhbm90aGVyIHdhdGNoZXIgdGhhdCBpcyBiZWluZ1xuICAvLyBjb2xsZWN0ZWQuXG4gIHZhciBjdXJyZW50ID0gRGVwLnRhcmdldDtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgRGVwLnRhcmdldCA9IGN1cnJlbnQ7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3ViY3JpYmVyIGxpc3QuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZCBvciBpcyBwZXJmb3JtaW5nIGEgdi1mb3JcbiAgICAvLyByZS1yZW5kZXIgKHRoZSB3YXRjaGVyIGxpc3QgaXMgdGhlbiBmaWx0ZXJlZCBieSB2LWZvcikuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkICYmICF0aGlzLnZtLl92Rm9yUmVtb3ZpbmcpIHtcbiAgICAgIHRoaXMudm0uX3dhdGNoZXJzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMudm0gPSB0aGlzLmNiID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjcnVzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCwgc2Vlbikge1xuICB2YXIgaSA9IHVuZGVmaW5lZCxcbiAgICAgIGtleXMgPSB1bmRlZmluZWQ7XG4gIGlmICghc2Vlbikge1xuICAgIHNlZW4gPSBzZWVuT2JqZWN0cztcbiAgICBzZWVuLmNsZWFyKCk7XG4gIH1cbiAgdmFyIGlzQSA9IGlzQXJyYXkodmFsKTtcbiAgdmFyIGlzTyA9IGlzT2JqZWN0KHZhbCk7XG4gIGlmICgoaXNBIHx8IGlzTykgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgaWYgKHZhbC5fX29iX18pIHtcbiAgICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldLCBzZWVuKTtcbiAgICB9IGVsc2UgaWYgKGlzTykge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dCQxID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gMyA/ICdkYXRhJyA6ICd0ZXh0Q29udGVudCc7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsW3RoaXMuYXR0cl0gPSBfdG9TdHJpbmcodmFsdWUpO1xuICB9XG59O1xuXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBpZFNlbGVjdG9yQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBtYXAgPSB7XG4gIGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXVxufTtcblxubWFwLnRkID0gbWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPSBtYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwLnRoZWFkID0gbWFwLnRib2R5ID0gbWFwLmNvbGdyb3VwID0gbWFwLmNhcHRpb24gPSBtYXAudGZvb3QgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcblxubWFwLmcgPSBtYXAuZGVmcyA9IG1hcC5zeW1ib2wgPSBtYXAudXNlID0gbWFwLmltYWdlID0gbWFwLnRleHQgPSBtYXAuY2lyY2xlID0gbWFwLmVsbGlwc2UgPSBtYXAubGluZSA9IG1hcC5wYXRoID0gbWFwLnBvbHlnb24gPSBtYXAucG9seWxpbmUgPSBtYXAucmVjdCA9IFsxLCAnPHN2ZyAnICsgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICsgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgKyAneG1sbnM6ZXY9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHNcIicgKyAndmVyc2lvbj1cIjEuMVwiPicsICc8L3N2Zz4nXTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBzdXBwb3J0ZWQgdGVtcGxhdGUgbm9kZSB3aXRoIGFcbiAqIERvY3VtZW50RnJhZ21lbnQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZWFsVGVtcGxhdGUobm9kZSkge1xuICByZXR1cm4gaXNUZW1wbGF0ZShub2RlKSAmJiBpc0ZyYWdtZW50KG5vZGUuY29udGVudCk7XG59XG5cbnZhciB0YWdSRSQxID0gLzwoW1xcdzotXSspLztcbnZhciBlbnRpdHlSRSA9IC8mIz9cXHcrPzsvO1xudmFyIGNvbW1lbnRSRSA9IC88IS0tLztcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRlbXBsYXRlIHRvIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqIERldGVybWluZXMgY29ycmVjdCB3cmFwcGluZyBieSB0YWcgdHlwZXMuIFdyYXBwaW5nXG4gKiBzdHJhdGVneSBmb3VuZCBpbiBqUXVlcnkgJiBjb21wb25lbnQvZG9taWZ5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZVN0cmluZywgcmF3KSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgY2FjaGVLZXkgPSByYXcgPyB0ZW1wbGF0ZVN0cmluZyA6IHRlbXBsYXRlU3RyaW5nLnRyaW0oKTtcbiAgdmFyIGhpdCA9IHRlbXBsYXRlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIHRhZ01hdGNoID0gdGVtcGxhdGVTdHJpbmcubWF0Y2godGFnUkUkMSk7XG4gIHZhciBlbnRpdHlNYXRjaCA9IGVudGl0eVJFLnRlc3QodGVtcGxhdGVTdHJpbmcpO1xuICB2YXIgY29tbWVudE1hdGNoID0gY29tbWVudFJFLnRlc3QodGVtcGxhdGVTdHJpbmcpO1xuXG4gIGlmICghdGFnTWF0Y2ggJiYgIWVudGl0eU1hdGNoICYmICFjb21tZW50TWF0Y2gpIHtcbiAgICAvLyB0ZXh0IG9ubHksIHJldHVybiBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZW1wbGF0ZVN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSB0YWdNYXRjaCAmJiB0YWdNYXRjaFsxXTtcbiAgICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5lZmF1bHQ7XG4gICAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgICB2YXIgcHJlZml4ID0gd3JhcFsxXTtcbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgbm9kZS5pbm5lckhUTUwgPSBwcmVmaXggKyB0ZW1wbGF0ZVN0cmluZyArIHN1ZmZpeDtcbiAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cblxuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3KSB7XG4gICAgdHJpbU5vZGUoZnJhZyk7XG4gIH1cbiAgdGVtcGxhdGVDYWNoZS5wdXQoY2FjaGVLZXksIGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50KG5vZGUpIHtcbiAgLy8gaWYgaXRzIGEgdGVtcGxhdGUgdGFnIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdCxcbiAgLy8gaXRzIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LiBIb3dldmVyLCBpT1MgU2FmYXJpIGhhc1xuICAvLyBidWcgd2hlbiB1c2luZyBkaXJlY3RseSBjbG9uZWQgdGVtcGxhdGUgY29udGVudCB3aXRoIHRvdWNoXG4gIC8vIGV2ZW50cyBhbmQgY2FuIGNhdXNlIGNyYXNoZXMgd2hlbiB0aGUgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSBET00sIHNvIHdlXG4gIC8vIGhhdmUgdG8gdHJlYXQgdGVtcGxhdGUgZWxlbWVudHMgYXMgc3RyaW5nIHRlbXBsYXRlcy4gKCMyODA1KVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS5pbm5lckhUTUwpO1xuICB9XG4gIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUudGV4dENvbnRlbnQpO1xuICB9XG4gIC8vIG5vcm1hbCBub2RlLCBjbG9uZSBpdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWxcbiAgdmFyIGNsb25lZE5vZGUgPSBjbG9uZU5vZGUobm9kZSk7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgY2hpbGQ7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIHdoaWxlIChjaGlsZCA9IGNsb25lZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuICB0cmltTm9kZShmcmFnKTtcbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8vIFRlc3QgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgU2FmYXJpIHRlbXBsYXRlIGNsb25pbmcgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93dWcuY2dpP2lkPTEzNzc1NVxudmFyIGhhc0Jyb2tlblRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYS5pbm5lckhUTUwgPSAnPHRlbXBsYXRlPjE8L3RlbXBsYXRlPic7XG4gICAgcmV0dXJuICFhLmNsb25lTm9kZSh0cnVlKS5maXJzdENoaWxkLmlubmVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8vIFRlc3QgZm9yIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgY2xvbmUgYnVnXG52YXIgaGFzVGV4dGFyZWFDbG9uZUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdC5wbGFjZWhvbGRlciA9ICd0JztcbiAgICByZXR1cm4gdC5jbG9uZU5vZGUodHJ1ZSkudmFsdWUgPT09ICd0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogMS4gRGVhbCB3aXRoIFNhZmFyaSBjbG9uaW5nIG5lc3RlZCA8dGVtcGxhdGU+IGJ1ZyBieVxuICogICAgbWFudWFsbHkgY2xvbmluZyBhbGwgdGVtcGxhdGUgaW5zdGFuY2VzLlxuICogMi4gRGVhbCB3aXRoIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnIGJ5IHNldHRpbmdcbiAqICAgIHRoZSBjb3JyZWN0IHZhbHVlIGFmdGVyIGNsb25pbmcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5vZGVcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUoKTtcbiAgfVxuICB2YXIgcmVzID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gIHZhciBpLCBvcmlnaW5hbCwgY2xvbmVkO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc0Jyb2tlblRlbXBsYXRlKSB7XG4gICAgdmFyIHRlbXBDbG9uZSA9IHJlcztcbiAgICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICB0ZW1wQ2xvbmUgPSByZXMuY29udGVudDtcbiAgICB9XG4gICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgY2xvbmVkID0gdGVtcENsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJyk7XG4gICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY2xvbmVkW2ldLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNsb25lTm9kZShvcmlnaW5hbFtpXSksIGNsb25lZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaGFzVGV4dGFyZWFDbG9uZUJ1Zykge1xuICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHJlcy52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpO1xuICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgICBjbG9uZWQgPSByZXMucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbiBhbmQgbm9ybWFsaXplcyBpdCBpbnRvIGFcbiAqIGEgRG9jdW1lbnRGcmFnbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcGFydGlhbCBvciBhXG4gKiBpbnN0YW5jZSB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0geyp9IHRlbXBsYXRlXG4gKiAgICAgICAgUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gKiAgICAgICAgLSBEb2N1bWVudEZyYWdtZW50IG9iamVjdFxuICogICAgICAgIC0gTm9kZSBvYmplY3Qgb2YgdHlwZSBUZW1wbGF0ZVxuICogICAgICAgIC0gaWQgc2VsZWN0b3I6ICcjc29tZS10ZW1wbGF0ZS1pZCdcbiAqICAgICAgICAtIHRlbXBsYXRlIHN0cmluZzogJzxkaXY+PHNwYW4+e3ttc2d9fTwvc3Bhbj48L2Rpdj4nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICogICAgICAgIGlubGluZSBIVE1MIGludGVycG9sYXRpb24uIERvIG5vdCBjaGVjayBmb3IgaWRcbiAqICAgICAgICBzZWxlY3RvciBhbmQga2VlcCB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzaG91bGRDbG9uZSwgcmF3KSB7XG4gIHZhciBub2RlLCBmcmFnO1xuXG4gIC8vIGlmIHRoZSB0ZW1wbGF0ZSBpcyBhbHJlYWR5IGEgZG9jdW1lbnQgZnJhZ21lbnQsXG4gIC8vIGRvIG5vdGhpbmdcbiAgaWYgKGlzRnJhZ21lbnQodGVtcGxhdGUpKSB7XG4gICAgdHJpbU5vZGUodGVtcGxhdGUpO1xuICAgIHJldHVybiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZSh0ZW1wbGF0ZSkgOiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gaWQgc2VsZWN0b3JcbiAgICBpZiAoIXJhdyAmJiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3IgY2FuIGJlIGNhY2hlZCB0b29cbiAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKTtcbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGVtcGxhdGUuc2xpY2UoMSkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudChub2RlKTtcbiAgICAgICAgICAvLyBzYXZlIHNlbGVjdG9yIHRvIGNhY2hlXG4gICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIHN0cmluZyB0ZW1wbGF0ZVxuICAgICAgZnJhZyA9IHN0cmluZ1RvRnJhZ21lbnQodGVtcGxhdGUsIHJhdyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgLy8gYSBkaXJlY3Qgbm9kZVxuICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudCh0ZW1wbGF0ZSk7XG4gIH1cblxuICByZXR1cm4gZnJhZyAmJiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZShmcmFnKSA6IGZyYWc7XG59XG5cbnZhciB0ZW1wbGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICBjbG9uZU5vZGU6IGNsb25lTm9kZSxcbiAgcGFyc2VUZW1wbGF0ZTogcGFyc2VUZW1wbGF0ZVxufSk7XG5cbnZhciBodG1sID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgLy8ge3t7IGlubGluZSB1bmVzY2FwZWQgaHRtbCB9fX1cbiAgICBpZiAodGhpcy5lbC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCBwcm9wZXIgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1odG1sJyk7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMuc3dhcCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHN3YXA6IGZ1bmN0aW9uIHN3YXAodmFsdWUpIHtcbiAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgdmFyIGkgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZW1vdmUodGhpcy5ub2Rlc1tpXSk7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgbmV3IHZhbHVlIHRvIGEgZnJhZ21lbnRcbiAgICAvLyBkbyBub3QgYXR0ZW1wdCB0byByZXRyaWV2ZSBmcm9tIGlkIHNlbGVjdG9yXG4gICAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAvLyBzYXZlIGEgcmVmZXJlbmNlIHRvIHRoZXNlIG5vZGVzIHNvIHdlIGNhbiByZW1vdmUgbGF0ZXJcbiAgICB0aGlzLm5vZGVzID0gdG9BcnJheShmcmFnLmNoaWxkTm9kZXMpO1xuICAgIGJlZm9yZShmcmFnLCB0aGlzLmFuY2hvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIGEgcGFydGlhbGx5LWNvbXBpbGVkIGZyYWdtZW50LlxuICogQ2FuIG9wdGlvbmFsbHkgY29tcGlsZSBjb250ZW50IHdpdGggYSBjaGlsZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHBhcmFtIHtGcmFnbWVudH0gW3BhcmVudEZyYWddXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50KGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5jaGlsZEZyYWdzID0gW107XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50RnJhZyA9IHBhcmVudEZyYWc7XG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcyk7XG4gIH1cbiAgdGhpcy51bmxpbmsgPSBsaW5rZXIodm0sIGZyYWcsIGhvc3QsIHNjb3BlLCB0aGlzKTtcbiAgdmFyIHNpbmdsZSA9IHRoaXMuc2luZ2xlID0gZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAvLyBkbyBub3QgZ28gc2luZ2xlIG1vZGUgaWYgdGhlIG9ubHkgbm9kZSBpcyBhbiBhbmNob3JcbiAgIWZyYWcuY2hpbGROb2Rlc1swXS5fX3ZfYW5jaG9yO1xuICBpZiAoc2luZ2xlKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZy5jaGlsZE5vZGVzWzBdO1xuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gc2luZ2xlUmVtb3ZlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZSA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtZW5kJyk7XG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICBwcmVwZW5kKHRoaXMubm9kZSwgZnJhZyk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgdGhpcy5iZWZvcmUgPSBtdWx0aUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IG11bHRpUmVtb3ZlO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IHRoaXM7XG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGhvb2sodGhpcy5jaGlsZHJlbltpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1ldGhvZCh0aGlzLm5vZGUsIHRhcmdldCwgdGhpcy52bSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVXaXRoVHJhbnNpdGlvbih0aGlzLm5vZGUsIHRoaXMudm0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWFwTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbWV0aG9kKG5vZGUsIHRhcmdldCwgdm0pO1xuICB9KTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIHRoaXMudm0sIHRoaXMuZnJhZywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBmcmFnbWVudCBmb3IgcmVtb3ZhbC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBjYWxsIHRoZSBzYW1lIG1ldGhvZCByZWN1cnNpdmVseSBvbiBjaGlsZFxuICAgIC8vIGZyYWdtZW50cywgZGVwdGgtZmlyc3RcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uYmVmb3JlUmVtb3ZlKGZhbHNlKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBDYWxsIGRlc3Ryb3kgZm9yIGFsbCBjb250YWluZWQgaW5zdGFuY2VzLFxuICAgIC8vIHdpdGggcmVtb3ZlOmZhbHNlIGFuZCBkZWZlcjp0cnVlLlxuICAgIC8vIERlZmVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAvLyBrZWVwIHRoZSBjaGlsZHJlbiB0byBjYWxsIGRldGFjaCBob29rc1xuICAgIC8vIG9uIHRoZW0uXG4gICAgdGhpcy5jaGlsZHJlbltpXS4kZGVzdHJveShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIGRpcnMgPSB0aGlzLnVubGluay5kaXJzO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBkaXNhYmxlIHRoZSB3YXRjaGVycyBvbiBhbGwgdGhlIGRpcmVjdGl2ZXNcbiAgICAvLyBzbyB0aGF0IHRoZSByZW5kZXJlZCBjb250ZW50IHN0YXlzIHRoZSBzYW1lXG4gICAgLy8gZHVyaW5nIHJlbW92YWwuXG4gICAgZGlyc1tpXS5fd2F0Y2hlciAmJiBkaXJzW2ldLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgZnJhZ21lbnQuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhcmVudEZyYWcpIHtcbiAgICB0aGlzLnBhcmVudEZyYWcuY2hpbGRGcmFncy4kcmVtb3ZlKHRoaXMpO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IG51bGw7XG4gIHRoaXMudW5saW5rKCk7XG59O1xuXG4vKipcbiAqIENhbGwgYXR0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGF0dGFjaChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2goY2hpbGQpIHtcbiAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICB9XG59XG5cbnZhciBsaW5rZXJDYWNoZSA9IG5ldyBDYWNoZSg1MDAwKTtcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50RmFjdG9yeSh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2YXIgdGVtcGxhdGU7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbCA9PT0gJ3N0cmluZyc7XG4gIGlmIChpc1N0cmluZyB8fCBpc1RlbXBsYXRlKGVsKSAmJiAhZWwuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICB0ZW1wbGF0ZSA9IHBhcnNlVGVtcGxhdGUoZWwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkLCBidXQgb25seSBmb3IgY29tcG9uZW50c1xuICB2YXIgbGlua2VyO1xuICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkO1xuICBpZiAoY2lkID4gMCkge1xuICAgIHZhciBjYWNoZUlkID0gY2lkICsgKGlzU3RyaW5nID8gZWwgOiBnZXRPdXRlckhUTUwoZWwpKTtcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZCk7XG4gICAgaWYgKCFsaW5rZXIpIHtcbiAgICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgICAgIGxpbmtlckNhY2hlLnB1dChjYWNoZUlkLCBsaW5rZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5saW5rZXIgPSBsaW5rZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnJhZ21lbnQgaW5zdGFuY2Ugd2l0aCBnaXZlbiBob3N0IGFuZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gaG9zdFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBwYXJlbnRGcmFnXG4gKi9cblxuRnJhZ21lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpIHtcbiAgdmFyIGZyYWcgPSBjbG9uZU5vZGUodGhpcy50ZW1wbGF0ZSk7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5saW5rZXIsIHRoaXMudm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKTtcbn07XG5cbnZhciBPTiA9IDcwMDtcbnZhciBNT0RFTCA9IDgwMDtcbnZhciBCSU5EID0gODUwO1xudmFyIFRSQU5TSVRJT04gPSAxMTAwO1xudmFyIEVMID0gMTUwMDtcbnZhciBDT01QT05FTlQgPSAxNTAwO1xudmFyIFBBUlRJQUwgPSAxNzUwO1xudmFyIElGID0gMjEwMDtcbnZhciBGT1IgPSAyMjAwO1xudmFyIFNMT1QgPSAyMzAwO1xuXG52YXIgdWlkJDMgPSAwO1xuXG52YXIgdkZvciA9IHtcblxuICBwcmlvcml0eTogRk9SLFxuICB0ZXJtaW5hbDogdHJ1ZSxcblxuICBwYXJhbXM6IFsndHJhY2stYnknLCAnc3RhZ2dlcicsICdlbnRlci1zdGFnZ2VyJywgJ2xlYXZlLXN0YWdnZXInXSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIHN1cHBvcnQgXCJpdGVtIGluL29mIGl0ZW1zXCIgc3ludGF4XG4gICAgdmFyIGluTWF0Y2ggPSB0aGlzLmV4cHJlc3Npb24ubWF0Y2goLyguKikgKD86aW58b2YpICguKikvKTtcbiAgICBpZiAoaW5NYXRjaCkge1xuICAgICAgdmFyIGl0TWF0Y2ggPSBpbk1hdGNoWzFdLm1hdGNoKC9cXCgoLiopLCguKilcXCkvKTtcbiAgICAgIGlmIChpdE1hdGNoKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdE1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGl0TWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5leHByZXNzaW9uID0gaW5NYXRjaFsyXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWxpYXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB2LWZvciBleHByZXNzaW9uIFwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYWxpYXMgaXMgcmVxdWlyZWQuJywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgIHRoaXMuaWQgPSAnX192LWZvcl9fJyArICsrdWlkJDM7XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGFuIG9wdGlvbiBsaXN0LFxuICAgIC8vIHNvIHRoYXQgd2Uga25vdyBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgPHNlbGVjdD4nc1xuICAgIC8vIHYtbW9kZWwgd2hlbiB0aGUgb3B0aW9uIGxpc3QgaGFzIGNoYW5nZWQuXG4gICAgLy8gYmVjYXVzZSB2LW1vZGVsIGhhcyBhIGxvd2VyIHByaW9yaXR5IHRoYW4gdi1mb3IsXG4gICAgLy8gdGhlIHYtbW9kZWwgaXMgbm90IGJvdW5kIGhlcmUgeWV0LCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gcmV0cml2ZSBpdCBpbiB0aGUgYWN0dWFsIHVwZGF0ZU1vZGVsKCkgZnVuY3Rpb24uXG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICB0aGlzLmlzT3B0aW9uID0gKHRhZyA9PT0gJ09QVElPTicgfHwgdGFnID09PSAnT1BUR1JPVVAnKSAmJiB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCc7XG5cbiAgICAvLyBzZXR1cCBhbmNob3Igbm9kZXNcbiAgICB0aGlzLnN0YXJ0ID0gY3JlYXRlQW5jaG9yKCd2LWZvci1zdGFydCcpO1xuICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCd2LWZvci1lbmQnKTtcbiAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuZW5kKTtcbiAgICBiZWZvcmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuXG4gICAgLy8gY2FjaGVcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIGZyYWdtZW50IGZhY3RvcnlcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgICB0aGlzLmRpZmYoZGF0YSk7XG4gICAgdGhpcy51cGRhdGVSZWYoKTtcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpZmYsIGJhc2VkIG9uIG5ldyBkYXRhIGFuZCBvbGQgZGF0YSwgZGV0ZXJtaW5lIHRoZVxuICAgKiBtaW5pbXVtIGFtb3VudCBvZiBET00gbWFuaXB1bGF0aW9ucyBuZWVkZWQgdG8gbWFrZSB0aGVcbiAgICogRE9NIHJlZmxlY3QgdGhlIG5ldyBkYXRhIEFycmF5LlxuICAgKlxuICAgKiBUaGUgYWxnb3JpdGhtIGRpZmZzIHRoZSBuZXcgZGF0YSBBcnJheSBieSBzdG9yaW5nIGFcbiAgICogaGlkZGVuIHJlZmVyZW5jZSB0byBhbiBvd25lciB2bSBpbnN0YW5jZSBvbiBwcmV2aW91c2x5XG4gICAqIHNlZW4gZGF0YS4gVGhpcyBhbGxvd3MgdXMgdG8gYWNoaWV2ZSBPKG4pIHdoaWNoIGlzXG4gICAqIGJldHRlciB0aGFuIGEgbGV2ZW5zaHRlaW4gZGlzdGFuY2UgYmFzZWQgYWxnb3JpdGhtLFxuICAgKiB3aGljaCBpcyBPKG0gKiBuKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgKi9cblxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKGRhdGEpIHtcbiAgICAvLyBjaGVjayBpZiB0aGUgQXJyYXkgd2FzIGNvbnZlcnRlZCBmcm9tIGFuIE9iamVjdFxuICAgIHZhciBpdGVtID0gZGF0YVswXTtcbiAgICB2YXIgY29udmVydGVkRnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdCA9IGlzT2JqZWN0KGl0ZW0pICYmIGhhc093bihpdGVtLCAnJGtleScpICYmIGhhc093bihpdGVtLCAnJHZhbHVlJyk7XG5cbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIG9sZEZyYWdzID0gdGhpcy5mcmFncztcbiAgICB2YXIgZnJhZ3MgPSB0aGlzLmZyYWdzID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICB2YXIgYWxpYXMgPSB0aGlzLmFsaWFzO1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgdmFyIGluRG9jdW1lbnQgPSBpbkRvYyhzdGFydCk7XG4gICAgdmFyIGluaXQgPSAhb2xkRnJhZ3M7XG4gICAgdmFyIGksIGwsIGZyYWcsIGtleSwgdmFsdWUsIHByaW1pdGl2ZTtcblxuICAgIC8vIEZpcnN0IHBhc3MsIGdvIHRocm91Z2ggdGhlIG5ldyBBcnJheSBhbmQgZmlsbCB1cFxuICAgIC8vIHRoZSBuZXcgZnJhZ3MgYXJyYXkuIElmIGEgcGllY2Ugb2YgZGF0YSBoYXMgYSBjYWNoZWRcbiAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuICAgICAga2V5ID0gY29udmVydGVkRnJvbU9iamVjdCA/IGl0ZW0uJGtleSA6IG51bGw7XG4gICAgICB2YWx1ZSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiR2YWx1ZSA6IGl0ZW07XG4gICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgICAgZnJhZyA9ICFpbml0ICYmIHRoaXMuZ2V0Q2FjaGVkRnJhZyh2YWx1ZSwgaSwga2V5KTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIC8vIHJldXNhYmxlIGZyYWdtZW50XG4gICAgICAgIGZyYWcucmV1c2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gdXBkYXRlICRpbmRleFxuICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGk7XG4gICAgICAgIC8vIHVwZGF0ZSAka2V5XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlLiRrZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGl0ZXJhdG9yXG4gICAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAgIGZyYWcuc2NvcGVbaXRlcmF0b3JdID0ga2V5ICE9PSBudWxsID8ga2V5IDogaTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICBpZiAodHJhY2tCeUtleSB8fCBjb252ZXJ0ZWRGcm9tT2JqZWN0IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5ldyBpc250YW5jZVxuICAgICAgICBmcmFnID0gdGhpcy5jcmVhdGUodmFsdWUsIGFsaWFzLCBpLCBrZXkpO1xuICAgICAgICBmcmFnLmZyZXNoID0gIWluaXQ7XG4gICAgICB9XG4gICAgICBmcmFnc1tpXSA9IGZyYWc7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBmcmFnLmJlZm9yZShlbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlJ3JlIGRvbmUgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAoaW5pdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBvbGQgZnJhZ21lbnRzIGFuZFxuICAgIC8vIGRlc3Ryb3kgdGhvc2Ugd2hvIGFyZSBub3QgcmV1c2VkIChhbmQgcmVtb3ZlIHRoZW1cbiAgICAvLyBmcm9tIGNhY2hlKVxuICAgIHZhciByZW1vdmFsSW5kZXggPSAwO1xuICAgIHZhciB0b3RhbFJlbW92ZWQgPSBvbGRGcmFncy5sZW5ndGggLSBmcmFncy5sZW5ndGg7XG4gICAgLy8gd2hlbiByZW1vdmluZyBhIGxhcmdlIG51bWJlciBvZiBmcmFnbWVudHMsIHdhdGNoZXIgcmVtb3ZhbFxuICAgIC8vIHR1cm5zIG91dCB0byBiZSBhIHBlcmYgYm90dGxlbmVjaywgc28gd2UgYmF0Y2ggdGhlIHdhdGNoZXJcbiAgICAvLyByZW1vdmFscyBpbnRvIGEgc2luZ2xlIGZpbHRlciBjYWxsIVxuICAgIHRoaXMudm0uX3ZGb3JSZW1vdmluZyA9IHRydWU7XG4gICAgZm9yIChpID0gMCwgbCA9IG9sZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IG9sZEZyYWdzW2ldO1xuICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKGZyYWcsIHJlbW92YWxJbmRleCsrLCB0b3RhbFJlbW92ZWQsIGluRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICBpZiAocmVtb3ZhbEluZGV4KSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycyA9IHRoaXMudm0uX3dhdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAodykge1xuICAgICAgICByZXR1cm4gdy5hY3RpdmU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBwYXNzLCBtb3ZlL2luc2VydCBuZXcgZnJhZ21lbnRzIGludG8gdGhlXG4gICAgLy8gcmlnaHQgcGxhY2UuXG4gICAgdmFyIHRhcmdldFByZXYsIHByZXZFbCwgY3VycmVudFByZXY7XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gZnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmcmFnID0gZnJhZ3NbaV07XG4gICAgICAvLyB0aGlzIGlzIHRoZSBmcmFnIHRoYXQgd2Ugc2hvdWxkIGJlIGFmdGVyXG4gICAgICB0YXJnZXRQcmV2ID0gZnJhZ3NbaSAtIDFdO1xuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldiA/IHRhcmdldFByZXYuc3RhZ2dlckNiID8gdGFyZ2V0UHJldi5zdGFnZ2VyQW5jaG9yIDogdGFyZ2V0UHJldi5lbmQgfHwgdGFyZ2V0UHJldi5ub2RlIDogc3RhcnQ7XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmV2ICE9PSB0YXJnZXRQcmV2ICYmICghY3VycmVudFByZXYgfHxcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciBtb3ZpbmcgYSBzaW5nbGUgaXRlbS5cbiAgICAgICAgLy8gdGhhbmtzIHRvIHN1Z2dlc3Rpb25zIGJ5IEBsaXZvcmFzIGluICMxODA3XG4gICAgICAgIGZpbmRQcmV2RnJhZyhjdXJyZW50UHJldiwgc3RhcnQsIHRoaXMuaWQpICE9PSB0YXJnZXRQcmV2KSkge1xuICAgICAgICAgIHRoaXMubW92ZShmcmFnLCBwcmV2RWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuX2hvc3Q7XG4gICAgLy8gY3JlYXRlIGl0ZXJhdGlvbiBzY29wZVxuICAgIHZhciBwYXJlbnRTY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSk7XG4gICAgLy8gcmVmIGhvbGRlciBmb3IgdGhlIHNjb3BlXG4gICAgc2NvcGUuJHJlZnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRyZWZzKTtcbiAgICBzY29wZS4kZWxzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kZWxzKTtcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGU7XG4gICAgLy8gZm9yIHR3by13YXkgYmluZGluZyBvbiBhbGlhc1xuICAgIHNjb3BlLiRmb3JDb250ZXh0ID0gdGhpcztcbiAgICAvLyBkZWZpbmUgc2NvcGUgcHJvcGVydGllc1xuICAgIC8vIGltcG9ydGFudDogZGVmaW5lIHRoZSBzY29wZSBhbGlhcyB3aXRob3V0IGZvcmNlZCBjb252ZXJzaW9uXG4gICAgLy8gc28gdGhhdCBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmVzIHJlbWFpbiBub24tcmVhY3RpdmUuXG4gICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIGFsaWFzLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICckaW5kZXgnLCBpbmRleCk7XG4gICAgaWYgKGtleSkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLiRrZXkpIHtcbiAgICAgIC8vIGF2b2lkIGFjY2lkZW50YWwgZmFsbGJhY2tcbiAgICAgIGRlZihzY29wZSwgJyRrZXknLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlcmF0b3IpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCB0aGlzLml0ZXJhdG9yLCBrZXkgIT09IG51bGwgPyBrZXkgOiBpbmRleCk7XG4gICAgfVxuICAgIHZhciBmcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZShob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgZnJhZy5mb3JJZCA9IHRoaXMuaWQ7XG4gICAgdGhpcy5jYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpO1xuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHYtcmVmIG9uIG93bmVyIHZtLlxuICAgKi9cblxuICB1cGRhdGVSZWY6IGZ1bmN0aW9uIHVwZGF0ZVJlZigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5kZXNjcmlwdG9yLnJlZjtcbiAgICBpZiAoIXJlZikgcmV0dXJuO1xuICAgIHZhciBoYXNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzO1xuICAgIHZhciByZWZzO1xuICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICByZWZzID0gdGhpcy5mcmFncy5tYXAoZmluZFZtRnJvbUZyYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZzID0ge307XG4gICAgICB0aGlzLmZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgcmVmc1tmcmFnLnNjb3BlLiRrZXldID0gZmluZFZtRnJvbUZyYWcoZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGFzaFtyZWZdID0gcmVmcztcbiAgfSxcblxuICAvKipcbiAgICogRm9yIG9wdGlvbiBsaXN0cywgdXBkYXRlIHRoZSBjb250YWluaW5nIHYtbW9kZWwgb25cbiAgICogcGFyZW50IDxzZWxlY3Q+LlxuICAgKi9cblxuICB1cGRhdGVNb2RlbDogZnVuY3Rpb24gdXBkYXRlTW9kZWwoKSB7XG4gICAgaWYgKHRoaXMuaXNPcHRpb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgbW9kZWwgPSBwYXJlbnQgJiYgcGFyZW50Ll9fdl9tb2RlbDtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY3VtZW50XG4gICAqL1xuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGZyYWcsIGluZGV4LCBwcmV2RWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgbnVsbCwgJ2VudGVyJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgLy8gY3JlYXRlIGFuIGFuY2hvciBhbmQgaW5zZXJ0IGl0IHN5bmNocm9ub3VzbHksXG4gICAgICAvLyBzbyB0aGF0IHdlIGNhbiByZXNvbHZlIHRoZSBjb3JyZWN0IG9yZGVyIHdpdGhvdXRcbiAgICAgIC8vIHdvcnJ5aW5nIGFib3V0IHNvbWUgZWxlbWVudHMgbm90IGluc2VydGVkIHlldFxuICAgICAgdmFyIGFuY2hvciA9IGZyYWcuc3RhZ2dlckFuY2hvcjtcbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGFuY2hvciA9IGZyYWcuc3RhZ2dlckFuY2hvciA9IGNyZWF0ZUFuY2hvcignc3RhZ2dlci1hbmNob3InKTtcbiAgICAgICAgYW5jaG9yLl9fdl9mcmFnID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGFmdGVyKGFuY2hvciwgcHJldkVsKTtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgIGZyYWcuYmVmb3JlKGFuY2hvcik7XG4gICAgICAgIHJlbW92ZShhbmNob3IpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldCA9IHByZXZFbC5uZXh0U2libGluZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgLy8gcmVzZXQgZW5kIGFuY2hvciBwb3NpdGlvbiBpbiBjYXNlIHRoZSBwb3NpdGlvbiB3YXMgbWVzc2VkIHVwXG4gICAgICAgIC8vIGJ5IGFuIGV4dGVybmFsIGRyYWctbi1kcm9wIGxpYnJhcnkuXG4gICAgICAgIGFmdGVyKHRoaXMuZW5kLCBwcmV2RWwpO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGZyYWcuYmVmb3JlKHRhcmdldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY3VtZW50XG4gICAqL1xuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGZyYWcsIGluZGV4LCB0b3RhbCwgaW5Eb2N1bWVudCkge1xuICAgIGlmIChmcmFnLnN0YWdnZXJDYikge1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IuY2FuY2VsKCk7XG4gICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAvLyBpdCdzIG5vdCBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgZnJhZyB0byBiZSByZW1vdmVkXG4gICAgICAvLyB0d2ljZSwgc28gaWYgd2UgaGF2ZSBhIHBlbmRpbmcgc3RhZ2dlciBjYWxsYmFjayxcbiAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAvLyBiZWZvcmUgaXRzIHRyYW5zaXRpb24gc3RhcnRlZC4gU2luY2UgaXQgaXMgYWxyZWFkeVxuICAgICAgLy8gZGVzdHJveWVkLCB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBpbiBkZXRhY2hlZCBzdGF0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCAnbGVhdmUnKTtcbiAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgICBmcmFnLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmUgYSBmcmFnbWVudCB0byBhIG5ldyBwb3NpdGlvbi5cbiAgICogRm9yY2Ugbm8gdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKi9cblxuICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKGZyYWcsIHByZXZFbCkge1xuICAgIC8vIGZpeCBhIGNvbW1vbiBpc3N1ZSB3aXRoIFNvcnRhYmxlOlxuICAgIC8vIGlmIHByZXZFbCBkb2Vzbid0IGhhdmUgbmV4dFNpYmxpbmcsIHRoaXMgbWVhbnMgaXQnc1xuICAgIC8vIGJlZW4gZHJhZ2dlZCBhZnRlciB0aGUgZW5kIGFuY2hvci4gSnVzdCByZS1wb3NpdGlvblxuICAgIC8vIHRoZSBlbmQgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXByZXZFbC5uZXh0U2libGluZykge1xuICAgICAgdGhpcy5lbmQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgfVxuICAgIGZyYWcuYmVmb3JlKHByZXZFbC5uZXh0U2libGluZywgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWNoZSBhIGZyYWdtZW50IHVzaW5nIHRyYWNrLWJ5IG9yIHRoZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKi9cblxuICBjYWNoZUZyYWc6IGZ1bmN0aW9uIGNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSkge1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBpZDtcbiAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgY2FjaGVbaWRdID0gZnJhZztcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tCeUtleSAhPT0gJyRpbmRleCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoaGFzT3duKHZhbHVlLCBpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgICAgIGRlZih2YWx1ZSwgaWQsIGZyYWcpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ0Zyb3plbiB2LWZvciBvYmplY3RzIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IHRyYWNrZWQsIG1ha2Ugc3VyZSB0byAnICsgJ3Byb3ZpZGUgYSB0cmFjay1ieSBrZXkuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcucmF3ID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIGNhY2hlZCBmcmFnbWVudCBmcm9tIHRoZSB2YWx1ZS9pbmRleC9rZXlcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkRnJhZzogZnVuY3Rpb24gZ2V0Q2FjaGVkRnJhZyh2YWx1ZSwgaW5kZXgsIGtleSkge1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgZnJhZztcbiAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIGZyYWcgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZyA9IHZhbHVlW3RoaXMuaWRdO1xuICAgIH1cbiAgICBpZiAoZnJhZyAmJiAoZnJhZy5yZXVzZWQgfHwgZnJhZy5mcmVzaCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZyYWdtZW50IGZyb20gY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICovXG5cbiAgZGVsZXRlQ2FjaGVkRnJhZzogZnVuY3Rpb24gZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKSB7XG4gICAgdmFyIHZhbHVlID0gZnJhZy5yYXc7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBzY29wZSA9IGZyYWcuc2NvcGU7XG4gICAgdmFyIGluZGV4ID0gc2NvcGUuJGluZGV4O1xuICAgIC8vIGZpeCAjOTQ4OiBhdm9pZCBhY2NpZGVudGFsbHkgZmFsbCB0aHJvdWdoIHRvXG4gICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgdmFyIGtleSA9IGhhc093bihzY29wZSwgJyRrZXknKSAmJiBzY29wZS4ka2V5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIGlmICh0cmFja0J5S2V5IHx8IGtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVt0aGlzLmlkXSA9IG51bGw7XG4gICAgICBmcmFnLnJhdyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIGdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgKyAnU3RhZ2dlcic7XG4gICAgdmFyIHRyYW5zID0gZnJhZy5ub2RlLl9fdl90cmFucztcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rcztcbiAgICB2YXIgaG9vayA9IGhvb2tzICYmIChob29rc1t0eXBlXSB8fCBob29rcy5zdGFnZ2VyKTtcbiAgICByZXR1cm4gaG9vayA/IGhvb2suY2FsbChmcmFnLCBpbmRleCwgdG90YWwpIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZS1wcm9jZXNzIHRoZSB2YWx1ZSBiZWZvcmUgcGlwaW5nIGl0IHRocm91Z2ggdGhlXG4gICAqIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqL1xuXG4gIF9wcmVQcm9jZXNzOiBmdW5jdGlvbiBfcHJlUHJvY2Vzcyh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgdGhlIHZhbHVlIGFmdGVyIGl0IGhhcyBiZWVuIHBpcGVkIHRocm91Z2hcbiAgICogdGhlIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqXG4gICAqIEl0IGlzIG5lY2Vzc2FyeSBmb3IgdGhpcyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZVxuICAgKiB3YXRjaGVyJ3MgZGVwZW5kZW5jeSBjb2xsZWN0aW9uIHBoYXNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgKiB0aGUgdi1mb3IgdG8gdXBkYXRlIHdoZW4gdGhlIHNvdXJjZSBPYmplY3QgaXMgbXV0YXRlZC5cbiAgICovXG5cbiAgX3Bvc3RQcm9jZXNzOiBmdW5jdGlvbiBfcG9zdFByb2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAvLyBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBhcnJheS5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB2YXIga2V5O1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXNbaV0gPSB7XG4gICAgICAgICAgJGtleToga2V5LFxuICAgICAgICAgICR2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLmRlc2NyaXB0b3IucmVmXSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoO1xuICAgICAgdmFyIGZyYWc7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmZyYWdzW2ldO1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIGZyYWcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcoZnJhZywgYW5jaG9yLCBpZCkge1xuICB2YXIgZWwgPSBmcmFnLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBmcmFnID0gZWwuX192X2ZyYWc7XG4gIHdoaWxlICgoIWZyYWcgfHwgZnJhZy5mb3JJZCAhPT0gaWQgfHwgIWZyYWcuaW5zZXJ0ZWQpICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIEZpbmQgYSB2bSBmcm9tIGEgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kVm1Gcm9tRnJhZyhmcmFnKSB7XG4gIHZhciBub2RlID0gZnJhZy5ub2RlO1xuICAvLyBoYW5kbGUgbXVsdGktbm9kZSBmcmFnXG4gIGlmIChmcmFnLmVuZCkge1xuICAgIHdoaWxlICghbm9kZS5fX3Z1ZV9fICYmIG5vZGUgIT09IGZyYWcuZW5kICYmIG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZS5fX3Z1ZV9fO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoTWF0aC5mbG9vcihuKSk7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmV0W2ldID0gaTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHJhY2sgYnkga2V5IGZvciBhbiBpdGVtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFt0cmFja0J5S2V5XVxuICovXG5cbmZ1bmN0aW9uIGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpIHtcbiAgcmV0dXJuIHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdHJhY2tCeUtleS5jaGFyQXQoMCkubWF0Y2goL1xcdy8pID8gZ2V0UGF0aCh2YWx1ZSwgdHJhY2tCeUtleSkgOiB2YWx1ZVt0cmFja0J5S2V5XSA6IGtleSB8fCB2YWx1ZTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdkZvci53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgd2FybignRHVwbGljYXRlIHZhbHVlIGZvdW5kIGluIHYtZm9yPVwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnLiBVc2UgdHJhY2stYnk9XCIkaW5kZXhcIiBpZiAnICsgJ3lvdSBhcmUgZXhwZWN0aW5nIGR1cGxpY2F0ZSB2YWx1ZXMuJywgdGhpcy52bSk7XG4gIH07XG59XG5cbnZhciB2SWYgPSB7XG5cbiAgcHJpb3JpdHk6IElGLFxuICB0ZXJtaW5hbDogdHJ1ZSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZShuZXh0KTtcbiAgICAgICAgdGhpcy5lbHNlRWwgPSBuZXh0O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgbWFpbiBibG9ja1xuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtaWYnKTtcbiAgICAgIHJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nLCB0aGlzLnZtKTtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmZyYWcpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKCk7XG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbDtcbiAgICB9XG4gICAgLy8gbGF6eSBpbml0IGZhY3RvcnlcbiAgICBpZiAoIXRoaXMuZmFjdG9yeSkge1xuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgdGhpcy5mcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUVsICYmICF0aGlzLmVsc2VGcmFnKSB7XG4gICAgICBpZiAoIXRoaXMuZWxzZUZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5lbHNlRmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy5lbHNlRWwuX2NvbnRleHQgfHwgdGhpcy52bSwgdGhpcy5lbHNlRWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbHNlRnJhZyA9IHRoaXMuZWxzZUZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKTtcbiAgICAgIHRoaXMuZWxzZUZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNob3cgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZztcbiAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5lbHNlRWwgPSBuZXh0O1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXBwbHkodGhpcy5lbCwgdmFsdWUpO1xuICAgIGlmICh0aGlzLmVsc2VFbCkge1xuICAgICAgdGhpcy5hcHBseSh0aGlzLmVsc2VFbCwgIXZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KGVsLCB2YWx1ZSkge1xuICAgIGlmIChpbkRvYyhlbCkpIHtcbiAgICAgIGFwcGx5VHJhbnNpdGlvbihlbCwgdmFsdWUgPyAxIDogLTEsIHRvZ2dsZSwgdGhpcy52bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvZ2dsZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0ZXh0JDIgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaXNSYW5nZSA9IGVsLnR5cGUgPT09ICdyYW5nZSc7XG4gICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5O1xuICAgIHZhciBudW1iZXIgPSB0aGlzLnBhcmFtcy5udW1iZXI7XG4gICAgdmFyIGRlYm91bmNlID0gdGhpcy5wYXJhbXMuZGVib3VuY2U7XG5cbiAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgIC8vICAgaHR0cDovL2Jsb2cuZXZhbnlvdS5tZS8yMDE0LzAxLzAzL2NvbXBvc2l0aW9uLWV2ZW50L1xuICAgIC8vIHNraXAgdGhpcyBmb3IgQW5kcm9pZCBiZWNhdXNlIGl0IGhhbmRsZXMgY29tcG9zaXRpb25cbiAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIGZvciBsYW5ndWFnZSBpbnB1dCBtZXRob2RzIGUuZy5cbiAgICAvLyBDaGluZXNlLCBidXQgaW5zdGVhZCB0cmlnZ2VycyB0aGVtIGZvciBzcGVsbGluZ1xuICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgIHZhciBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICBpZiAoIWlzQW5kcm9pZCAmJiAhaXNSYW5nZSkge1xuICAgICAgdGhpcy5vbignY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBpbiBJRTExIHRoZSBcImNvbXBvc2l0aW9uZW5kXCIgZXZlbnQgZmlyZXMgQUZURVJcbiAgICAgICAgLy8gdGhlIFwiaW5wdXRcIiBldmVudCwgc28gdGhlIGlucHV0IGhhbmRsZXIgaXMgYmxvY2tlZFxuICAgICAgICAvLyBhdCB0aGUgZW5kLi4uIGhhdmUgdG8gY2FsbCBpdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAjMTMyNzogaW4gbGF6eSBtb2RlIHRoaXMgaXMgdW5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IG1lc3Npbmcgd2l0aCB0aGUgaW5wdXQgd2hlbiB1c2VyIGlzIHR5cGluZyxcbiAgICAvLyBhbmQgZm9yY2UgdXBkYXRlIG9uIGJsdXIuXG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgaWYgKCFpc1JhbmdlICYmICFsYXp5KSB7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGRvIG5vdCBzeW5jIHZhbHVlIGFmdGVyIGZyYWdtZW50IHJlbW92YWwgKCMyMDE3KVxuICAgICAgICBpZiAoIXNlbGYuX2ZyYWcgfHwgc2VsZi5fZnJhZy5pbnNlcnRlZCkge1xuICAgICAgICAgIHNlbGYucmF3TGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSB0aGlzLnJhd0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbXBvc2luZyB8fCAhc2VsZi5fYm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbCA9IG51bWJlciB8fCBpc1JhbmdlID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWwpO1xuICAgICAgLy8gZm9yY2UgdXBkYXRlIG9uIG5leHQgdGljayB0byBhdm9pZCBsb2NrICYgc2FtZSB2YWx1ZVxuICAgICAgLy8gYWxzbyBvbmx5IHVwZGF0ZSB3aGVuIHVzZXIgaXMgbm90IHR5cGluZ1xuICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYm91bmQgJiYgIXNlbGYuZm9jdXNlZCkge1xuICAgICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBfZGVib3VuY2UodGhpcy5saXN0ZW5lciwgZGVib3VuY2UpO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgalF1ZXJ5IGV2ZW50cywgc2luY2UgalF1ZXJ5LnRyaWdnZXIoKSBkb2Vzbid0XG4gICAgLy8gdHJpZ2dlciBuYXRpdmUgZXZlbnRzIGluIHNvbWUgY2FzZXMgYW5kIHNvbWUgcGx1Z2luc1xuICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAvL1xuICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIGlmIGEgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdXNpbmdcbiAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgIC8vIHdlIGRvIHRoZSBjaGVjayBmb3IgZWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgYW5kXG4gICAgLy8gc3RvcmUgdGhhdCBjaGVjayByZXN1bHQgb24gaXRzZWxmLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgIC8vIGpRdWVyeSB2YXJpYWJsZSBpbiB0ZXN0cy5cbiAgICB0aGlzLmhhc2pRdWVyeSA9IHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICB2YXIgbWV0aG9kID0galF1ZXJ5LmZuLm9uID8gJ29uJyA6ICdiaW5kJztcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnJhd0xpc3RlbmVyKTtcbiAgICAgIGlmICghbGF6eSkge1xuICAgICAgICB0aGlzLm9uKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElFOSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnQgb24gYmFja3NwYWNlL2RlbC9jdXRcbiAgICBpZiAoIWxhenkgJiYgaXNJRTkpIHtcbiAgICAgIHRoaXMub24oJ2N1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soc2VsZi5saXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZSBpZiBwcmVzZW50XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fCBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmIGVsLnZhbHVlLnRyaW0oKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIC8vICMzMDI5IG9ubHkgdXBkYXRlIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIFRoaXMgcHJldmVudFxuICAgIC8vIGJyb3dzZXJzIGZyb20gb3ZlcndyaXRpbmcgdmFsdWVzIGxpa2Ugc2VsZWN0aW9uU3RhcnRcbiAgICB2YWx1ZSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB0aGlzLmVsLnZhbHVlID0gdmFsdWU7XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub2ZmID8gJ29mZicgOiAndW5iaW5kJztcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmFkaW8gPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB2YWx1ZSBvdmVyd3JpdGUgdmlhIHYtYmluZDp2YWx1ZVxuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHNlbGYucGFyYW1zLm51bWJlcikge1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2V0KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gIH1cbn07XG5cbnZhciBzZWxlY3QgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAvLyBtZXRob2QgdG8gZm9yY2UgdXBkYXRlIERPTSB1c2luZyBsYXRlc3QgdmFsdWUuXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLl93YXRjaGVyKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIuZ2V0KCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0XG4gICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcblxuICAgIC8vIGF0dGFjaCBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShlbCwgbXVsdGlwbGUpO1xuICAgICAgdmFsdWUgPSBzZWxmLnBhcmFtcy5udW1iZXIgPyBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh0b051bWJlcikgOiB0b051bWJlcih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIHNlbGYuc2V0KHZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuXG4gICAgLy8gaWYgaGFzIGluaXRpYWwgdmFsdWUsIHNldCBhZnRlckJpbmRcbiAgICB2YXIgaW5pdFZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlLCB0cnVlKTtcbiAgICBpZiAobXVsdGlwbGUgJiYgaW5pdFZhbHVlLmxlbmd0aCB8fCAhbXVsdGlwbGUgJiYgaW5pdFZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuXG4gICAgLy8gQWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBGaXJlZm94IHJlc2V0c1xuICAgIC8vIHNlbGVjdGVkSW5kZXggd2l0aCB2YWx1ZSAtMSB0byAwIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgLy8gZm9yY2UgYSBET00gdXBkYXRlIHdoZW5ldmVyIHRoYXQgaGFwcGVucy4uLlxuICAgIHRoaXMudm0uJG9uKCdob29rOmF0dGFjaGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgbmV4dFRpY2soX3RoaXMuZm9yY2VVcGRhdGUpO1xuICAgIH0pO1xuICAgIGlmICghaW5Eb2MoZWwpKSB7XG4gICAgICBuZXh0VGljayh0aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB2YXIgbXVsdGkgPSB0aGlzLm11bHRpcGxlICYmIGlzQXJyYXkodmFsdWUpO1xuICAgIHZhciBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoO1xuICAgIHZhciBvcCwgdmFsO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG9wID0gb3B0aW9uc1tpXTtcbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgICBvcC5zZWxlY3RlZCA9IG11bHRpID8gaW5kZXhPZiQxKHZhbHVlLCB2YWwpID4gLTEgOiBsb29zZUVxdWFsKHZhbHVlLCB2YWwpO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aGlzLnZtLiRvZmYoJ2hvb2s6YXR0YWNoZWQnLCB0aGlzLmZvcmNlVXBkYXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgc2VsZWN0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtTZWxlY3RFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBtdWx0aVxuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcmV0dXJuIHtBcnJheXwqfVxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlKGVsLCBtdWx0aSwgaW5pdCkge1xuICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGw7XG4gIHZhciBvcCwgdmFsLCBzZWxlY3RlZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wID0gZWwub3B0aW9uc1tpXTtcbiAgICBzZWxlY3RlZCA9IGluaXQgPyBvcC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgOiBvcC5zZWxlY3RlZDtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIE5hdGl2ZSBBcnJheS5pbmRleE9mIHVzZXMgc3RyaWN0IGVxdWFsLCBidXQgaW4gdGhpc1xuICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mJDEoYXJyLCB2YWwpIHtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgY2hlY2tib3ggPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gZWwuX3ZhbHVlIDogc2VsZi5wYXJhbXMubnVtYmVyID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEJvb2xlYW5WYWx1ZSgpIHtcbiAgICAgIHZhciB2YWwgPSBlbC5jaGVja2VkO1xuICAgICAgaWYgKHZhbCAmJiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdHJ1ZVZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1vZGVsID0gc2VsZi5fd2F0Y2hlci52YWx1ZTtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsKSkge1xuICAgICAgICB2YXIgdmFsID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoZWwuY2hlY2tlZCkge1xuICAgICAgICAgIGlmIChpbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbC4kcmVtb3ZlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2V0KGdldEJvb2xlYW5WYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBpbmRleE9mKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpID4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICB0ZXh0OiB0ZXh0JDIsXG4gIHJhZGlvOiByYWRpbyxcbiAgc2VsZWN0OiBzZWxlY3QsXG4gIGNoZWNrYm94OiBjaGVja2JveFxufTtcblxudmFyIG1vZGVsID0ge1xuXG4gIHByaW9yaXR5OiBNT0RFTCxcbiAgdHdvV2F5OiB0cnVlLFxuICBoYW5kbGVyczogaGFuZGxlcnMsXG4gIHBhcmFtczogWydsYXp5JywgJ251bWJlcicsICdkZWJvdW5jZSddLFxuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBlbGVtZW50czpcbiAgICogICA8c2VsZWN0PlxuICAgKiAgIDx0ZXh0YXJlYT5cbiAgICogICA8aW5wdXQgdHlwZT1cIipcIj5cbiAgICogICAgIC0gdGV4dFxuICAgKiAgICAgLSBjaGVja2JveFxuICAgKiAgICAgLSByYWRpb1xuICAgKiAgICAgLSBudW1iZXJcbiAgICovXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBmcmllbmRseSB3YXJuaW5nLi4uXG4gICAgdGhpcy5jaGVja0ZpbHRlcnMoKTtcbiAgICBpZiAodGhpcy5oYXNSZWFkICYmICF0aGlzLmhhc1dyaXRlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArICd2LW1vZGVsPVwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCIuICcgKyAnWW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgdHdvLXdheSBmaWx0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuJywgdGhpcy52bSk7XG4gICAgfVxuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKHRhZyA9PT0gJ0lOUFVUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2VsLnR5cGVdIHx8IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMuc2VsZWN0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudCB0eXBlOiAnICsgdGFnLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwuX192X21vZGVsID0gdGhpcztcbiAgICBoYW5kbGVyLmJpbmQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlO1xuICAgIHRoaXMuX3VuYmluZCA9IGhhbmRsZXIudW5iaW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayByZWFkL3dyaXRlIGZpbHRlciBzdGF0cy5cbiAgICovXG5cbiAgY2hlY2tGaWx0ZXJzOiBmdW5jdGlvbiBjaGVja0ZpbHRlcnMoKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm47XG4gICAgdmFyIGkgPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZmlsdGVyID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKTtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGZpbHRlci5yZWFkKSB7XG4gICAgICAgIHRoaXMuaGFzUmVhZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLndyaXRlKSB7XG4gICAgICAgIHRoaXMuaGFzV3JpdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGw7XG4gICAgdGhpcy5fdW5iaW5kICYmIHRoaXMuX3VuYmluZCgpO1xuICB9XG59O1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl0sXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDBcbn07XG5cbmZ1bmN0aW9uIGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKSB7XG4gIHZhciBjb2RlcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBrZXkuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoY2hhckNvZGUgPiA0NyAmJiBjaGFyQ29kZSA8IDU4KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICBjaGFyQ29kZSA9IGtleS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY2hhckNvZGUgPiA2NCAmJiBjaGFyQ29kZSA8IDkxKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleUNvZGVzW2tleV07XG4gIH0pO1xuICBjb2RlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgY29kZXMpO1xuICByZXR1cm4gZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgaWYgKGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RvcEZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdG9wSGFuZGxlcihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRIYW5kbGVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZkZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmSGFuZGxlcihlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgb24kMSA9IHtcblxuICBwcmlvcml0eTogT04sXG4gIGFjY2VwdFN0YXRlbWVudDogdHJ1ZSxcbiAga2V5Q29kZXM6IGtleUNvZGVzLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZGVhbCB3aXRoIGlmcmFtZXNcbiAgICBpZiAodGhpcy5lbC50YWdOYW1lID09PSAnSUZSQU1FJyAmJiB0aGlzLmFyZyAhPT0gJ2xvYWQnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uKHNlbGYuZWwuY29udGVudFdpbmRvdywgc2VsZi5hcmcsIHNlbGYuaGFuZGxlciwgc2VsZi5tb2RpZmllcnMuY2FwdHVyZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZCk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGhhbmRsZXIpIHtcbiAgICAvLyBzdHViIGEgbm9vcCBmb3Igdi1vbiB3aXRoIG5vIHZhbHVlLFxuICAgIC8vIGUuZy4gQG1vdXNlZG93bi5wcmV2ZW50XG4gICAgaWYgKCF0aGlzLmRlc2NyaXB0b3IucmF3KSB7XG4gICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3Ytb246JyArIHRoaXMuYXJnICsgJz1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgZXhwZWN0cyBhIGZ1bmN0aW9uIHZhbHVlLCAnICsgJ2dvdCAnICsgaGFuZGxlciwgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgbW9kaWZpZXJzXG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnN0b3ApIHtcbiAgICAgIGhhbmRsZXIgPSBzdG9wRmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgaGFuZGxlciA9IHByZXZlbnRGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zZWxmKSB7XG4gICAgICBoYW5kbGVyID0gc2VsZkZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8ga2V5IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RpZmllcnMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9PSAnc3RvcCcgJiYga2V5ICE9PSAncHJldmVudCcgJiYga2V5ICE9PSAnc2VsZicgJiYga2V5ICE9PSAnY2FwdHVyZSc7XG4gICAgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgdGhpcy5pZnJhbWVCaW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKHRoaXMuZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIsIHRoaXMubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5pZnJhbWVCaW5kID8gdGhpcy5lbC5jb250ZW50V2luZG93IDogdGhpcy5lbDtcbiAgICBpZiAodGhpcy5oYW5kbGVyKSB7XG4gICAgICBvZmYoZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW1zLSddO1xudmFyIGNhbWVsUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kLztcbnZhciBwcm9wQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgdGVzdEVsID0gbnVsbDtcblxudmFyIHN0eWxlID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5lbC5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUucmVkdWNlKGV4dGVuZCwge30pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVPYmplY3Q6IGZ1bmN0aW9uIGhhbmRsZU9iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNhY2hlIG9iamVjdCBzdHlsZXMgc28gdGhhdCBvbmx5IGNoYW5nZWQgcHJvcHNcbiAgICAvLyBhcmUgYWN0dWFsbHkgdXBkYXRlZC5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlIHx8ICh0aGlzLmNhY2hlID0ge30pO1xuICAgIHZhciBuYW1lLCB2YWw7XG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKTtcbiAgICAgICAgZGVsZXRlIGNhY2hlW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIHZhbCA9IHZhbHVlW25hbWVdO1xuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWw7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHByb3AsIHZhbHVlKSB7XG4gICAgcHJvcCA9IG5vcm1hbGl6ZShwcm9wKTtcbiAgICBpZiAoIXByb3ApIHJldHVybjsgLy8gdW5zdXBwb3J0ZWQgcHJvcFxuICAgIC8vIGNhc3QgcG9zc2libGUgbnVtYmVycy9ib29sZWFucyBpbnRvIHN0cmluZ3NcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWUgKz0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YXIgaXNJbXBvcnRhbnQgPSBpbXBvcnRhbnRSRS50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJyc7XG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignSXRcXCdzIHByb2JhYmx5IGEgYmFkIGlkZWEgdG8gdXNlICFpbXBvcnRhbnQgd2l0aCBpbmxpbmUgcnVsZXMuICcgKyAnVGhpcyBmZWF0dXJlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFZ1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKS50cmltKCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcC5rZWJhYiwgdmFsdWUsIGlzSW1wb3J0YW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcC5jYW1lbF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZVtwcm9wLmNhbWVsXSA9ICcnO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIENTUyBwcm9wZXJ0eSBuYW1lLlxuICogLSBjYWNoZSByZXN1bHRcbiAqIC0gYXV0byBwcmVmaXhcbiAqIC0gY2FtZWxDYXNlIC0+IGRhc2gtY2FzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF07XG4gIH1cbiAgdmFyIHJlcyA9IHByZWZpeChwcm9wKTtcbiAgcHJvcENhY2hlW3Byb3BdID0gcHJvcENhY2hlW3Jlc10gPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQXV0byBkZXRlY3QgdGhlIGFwcHJvcHJpYXRlIHByZWZpeCBmb3IgYSBDU1MgcHJvcGVydHkuXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNTIzNjkyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXgocHJvcCkge1xuICBwcm9wID0gaHlwaGVuYXRlKHByb3ApO1xuICB2YXIgY2FtZWwgPSBjYW1lbGl6ZShwcm9wKTtcbiAgdmFyIHVwcGVyID0gY2FtZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbC5zbGljZSgxKTtcbiAgaWYgKCF0ZXN0RWwpIHtcbiAgICB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfVxuICB2YXIgaSA9IHByZWZpeGVzLmxlbmd0aDtcbiAgdmFyIHByZWZpeGVkO1xuICBpZiAoY2FtZWwgIT09ICdmaWx0ZXInICYmIGNhbWVsIGluIHRlc3RFbC5zdHlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWJhYjogcHJvcCxcbiAgICAgIGNhbWVsOiBjYW1lbFxuICAgIH07XG4gIH1cbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtlYmFiOiBwcmVmaXhlc1tpXSArIHByb3AsXG4gICAgICAgIGNhbWVsOiBwcmVmaXhlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8geGxpbmtcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhsaW5rUkUgPSAvXnhsaW5rOi87XG5cbi8vIGNoZWNrIGZvciBhdHRyaWJ1dGVzIHRoYXQgcHJvaGliaXQgaW50ZXJwb2xhdGlvbnNcbnZhciBkaXNhbGxvd2VkSW50ZXJwQXR0clJFID0gL152LXxeOnxeQHxeKD86aXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBhbHNvIHNldCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbi8vIGJlY2F1c2UgdGhleSBvbmx5IGFmZmVjdCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxudmFyIGF0dHJXaXRoUHJvcHNSRSA9IC9eKD86dmFsdWV8Y2hlY2tlZHxzZWxlY3RlZHxtdXRlZCkkLztcbi8vIHRoZXNlIGF0dHJpYnV0ZXMgZXhwZWN0IGVudW1yYXRlZCB2YWx1ZXMgb2YgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4vLyBidXQgYXJlIG5vdCBib29sZWFuIGF0dHJpYnV0ZXNcbnZhciBlbnVtZXJhdGVkQXR0clJFID0gL14oPzpkcmFnZ2FibGV8Y29udGVudGVkaXRhYmxlfHNwZWxsY2hlY2spJC87XG5cbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIHNldCBhIGhpZGRlbiBwcm9wZXJ0eSBmb3Jcbi8vIGJpbmRpbmcgdi1tb2RlbCB0byBvYmplY3QgdmFsdWVzXG52YXIgbW9kZWxQcm9wcyA9IHtcbiAgdmFsdWU6ICdfdmFsdWUnLFxuICAndHJ1ZS12YWx1ZSc6ICdfdHJ1ZVZhbHVlJyxcbiAgJ2ZhbHNlLXZhbHVlJzogJ19mYWxzZVZhbHVlJ1xufTtcblxudmFyIGJpbmQkMSA9IHtcblxuICBwcmlvcml0eTogQklORCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGludGVycG9sYXRpb24gYmluZGluZ3NcbiAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICB2YXIgdG9rZW5zID0gZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgLy8gaGFuZGxlIGludGVycG9sYXRpb25zIHdpdGggb25lLXRpbWUgdG9rZW5zXG4gICAgICBpZiAoZGVzY3JpcHRvci5oYXNPbmVUaW1lKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHRva2Vuc1RvRXhwKHRva2VucywgdGhpcy5fc2NvcGUgfHwgdGhpcy52bSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgYWxsb3cgYmluZGluZyBvbiBuYXRpdmUgYXR0cmlidXRlc1xuICAgICAgaWYgKGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUudGVzdChhdHRyKSB8fCBhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgKyAnZGlyZWN0aXZlcyBhbmQgc3BlY2lhbCBhdHRyaWJ1dGVzLicsIHRoaXMudm0pO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICc7XG4gICAgICAgIC8vIHdhcm4gc3JjXG4gICAgICAgIGlmIChhdHRyID09PSAnc3JjJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzcmNcIiBhdHRyaWJ1dGUgd2lsbCBjYXVzZSAnICsgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3YXJuIHN0eWxlXG4gICAgICAgIGlmIChhdHRyID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICd0aGUgYXR0cmlidXRlIHRvIGJlIGRpc2NhcmRlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci4gJyArICdVc2Ugdi1iaW5kOnN0eWxlIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgaWYgKHRoaXMuYXJnKSB7XG4gICAgICB0aGlzLmhhbmRsZVNpbmdsZShhdHRyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiBzdHlsZS5oYW5kbGVPYmplY3QsXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpbnRlcnAgPSB0aGlzLmRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgYXR0ciA9IGNhbWVsaXplKGF0dHIpO1xuICAgIH1cbiAgICBpZiAoIWludGVycCAmJiBhdHRyV2l0aFByb3BzUkUudGVzdChhdHRyKSAmJiBhdHRyIGluIGVsKSB7XG4gICAgICB2YXIgYXR0clZhbHVlID0gYXR0ciA9PT0gJ3ZhbHVlJyA/IHZhbHVlID09IG51bGwgLy8gSUU5IHdpbGwgc2V0IGlucHV0LnZhbHVlIHRvIFwibnVsbFwiIGZvciBudWxsLi4uXG4gICAgICA/ICcnIDogdmFsdWUgOiB2YWx1ZTtcblxuICAgICAgaWYgKGVsW2F0dHJdICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgZWxbYXR0cl0gPSBhdHRyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdO1xuICAgIGlmICghaW50ZXJwICYmIG1vZGVsUHJvcCkge1xuICAgICAgZWxbbW9kZWxQcm9wXSA9IHZhbHVlO1xuICAgICAgLy8gdXBkYXRlIHYtbW9kZWwgaWYgcHJlc2VudFxuICAgICAgdmFyIG1vZGVsID0gZWwuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRvIG5vdCBzZXQgdmFsdWUgYXR0cmlidXRlIGZvciB0ZXh0YXJlYVxuICAgIGlmIChhdHRyID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmIChlbnVtZXJhdGVkQXR0clJFLnRlc3QoYXR0cikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChhdHRyID09PSAnY2xhc3MnKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlZGdlIGNhc2UgIzE5NjA6XG4gICAgICAgIC8vIGNsYXNzIGludGVycG9sYXRpb24gc2hvdWxkIG5vdCBvdmVyd3JpdGUgVnVlIHRyYW5zaXRpb24gY2xhc3NcbiAgICAgICAgaWYgKGVsLl9fdl90cmFucykge1xuICAgICAgICAgIHZhbHVlICs9ICcgJyArIGVsLl9fdl90cmFucy5pZCArICctdHJhbnNpdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2xhc3MoZWwsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoeGxpbmtSRS50ZXN0KGF0dHIpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsID0ge1xuXG4gIHByaW9yaXR5OiBFTCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5hcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5pZCA9IGNhbWVsaXplKHRoaXMuYXJnKTtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChoYXNPd24ocmVmcywgaWQpKSB7XG4gICAgICByZWZzW2lkXSA9IHRoaXMuZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAocmVmc1t0aGlzLmlkXSA9PT0gdGhpcy5lbCkge1xuICAgICAgcmVmc1t0aGlzLmlkXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVmID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1yZWY6JyArIHRoaXMuYXJnICsgJyBtdXN0IGJlIHVzZWQgb24gYSBjaGlsZCAnICsgJ2NvbXBvbmVudC4gRm91bmQgb24gPCcgKyB0aGlzLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+LicsIHRoaXMudm0pO1xuICB9XG59O1xuXG52YXIgY2xvYWsgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnZtLiRvbmNlKCdwcmUtaG9vazpjb21waWxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBtdXN0IGV4cG9ydCBwbGFpbiBvYmplY3RcbnZhciBkaXJlY3RpdmVzID0ge1xuICB0ZXh0OiB0ZXh0JDEsXG4gIGh0bWw6IGh0bWwsXG4gICdmb3InOiB2Rm9yLFxuICAnaWYnOiB2SWYsXG4gIHNob3c6IHNob3csXG4gIG1vZGVsOiBtb2RlbCxcbiAgb246IG9uJDEsXG4gIGJpbmQ6IGJpbmQkMSxcbiAgZWw6IGVsLFxuICByZWY6IHJlZixcbiAgY2xvYWs6IGNsb2FrXG59O1xuXG52YXIgdkNsYXNzID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3ModmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENsYXNzKG5vcm1hbGl6ZSQxKHZhbHVlKSk7XG4gICAgfVxuICB9LFxuXG4gIHNldENsYXNzOiBmdW5jdGlvbiBzZXRDbGFzcyh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSB2YWx1ZVtpXTtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgYXBwbHkodGhpcy5lbCwgdmFsLCBhZGRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJldktleXMgPSB2YWx1ZTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiBjbGVhbnVwKHZhbHVlKSB7XG4gICAgdmFyIHByZXZLZXlzID0gdGhpcy5wcmV2S2V5cztcbiAgICBpZiAoIXByZXZLZXlzKSByZXR1cm47XG4gICAgdmFyIGkgPSBwcmV2S2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGtleSA9IHByZXZLZXlzW2ldO1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIGFwcGx5KHRoaXMuZWwsIGtleSwgcmVtb3ZlQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzIChwb3RlbnRpYWxseSBjb250YWluaW5nIG9iamVjdHMpXG4gKiBpbnRvIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXk8U3RyaW5nfE9iamVjdD59IHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheTxTdHJpbmc+fVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSQxKHZhbHVlKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBfa2V5ID0gdmFsdWVbaV07XG4gICAgICBpZiAoX2tleSkge1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzLnB1c2goX2tleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBfa2V5KSB7XG4gICAgICAgICAgICBpZiAoX2tleVtrXSkgcmVzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBhIGNsYXNzL2NsYXNzZXMgb24gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGNsYXNzIG5hbWUuIFRoaXMgbWF5IG9yIG1heSBub3RcbiAqICAgICAgICAgICAgICAgICAgICAgY29udGFpbiBhIHNwYWNlIGNoYXJhY3RlciwgaW4gc3VjaCBhXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2UnbGwgZGVhbCB3aXRoIG11bHRpcGxlIGNsYXNzXG4gKiAgICAgICAgICAgICAgICAgICAgIG5hbWVzIGF0IG9uY2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmZ1bmN0aW9uIGFwcGx5KGVsLCBrZXksIGZuKSB7XG4gIGtleSA9IGtleS50cmltKCk7XG4gIGlmIChrZXkuaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIGZuKGVsLCBrZXkpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUga2V5IGNvbnRhaW5zIG9uZSBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnMuXG4gIC8vIFNpbmNlIGEgY2xhc3MgbmFtZSBkb2Vzbid0IGFjY2VwdCBzdWNoIGNoYXJhY3RlcnMsIHdlXG4gIC8vIHRyZWF0IGl0IGFzIG11bHRpcGxlIGNsYXNzZXMuXG4gIHZhciBrZXlzID0ga2V5LnNwbGl0KC9cXHMrLyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmbihlbCwga2V5c1tpXSk7XG4gIH1cbn1cblxudmFyIGNvbXBvbmVudCA9IHtcblxuICBwcmlvcml0eTogQ09NUE9ORU5ULFxuXG4gIHBhcmFtczogWydrZWVwLWFsaXZlJywgJ3RyYW5zaXRpb24tbW9kZScsICdpbmxpbmUtdGVtcGxhdGUnXSxcblxuICAvKipcbiAgICogU2V0dXAuIFR3byBwb3NzaWJsZSB1c2FnZXM6XG4gICAqXG4gICAqIC0gc3RhdGljOlxuICAgKiAgIDxjb21wPiBvciA8ZGl2IHYtY29tcG9uZW50PVwiY29tcFwiPlxuICAgKlxuICAgKiAtIGR5bmFtaWM6XG4gICAqICAgPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgaWYgKCF0aGlzLmVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGtlZXAtYWxpdmUgY2FjaGVcbiAgICAgIHRoaXMua2VlcEFsaXZlID0gdGhpcy5wYXJhbXMua2VlcEFsaXZlO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZVxuICAgICAgaWYgKHRoaXMucGFyYW1zLmlubGluZVRlbXBsYXRlKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgaW5saW5lIHRlbXBsYXRlIGFzIGEgRG9jdW1lbnRGcmFnbWVudFxuICAgICAgICB0aGlzLmlubGluZVRlbXBsYXRlID0gZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyBjb21wb25lbnQgcmVzb2x1dGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IHRoaXMuQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMgPSAwO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgIC8vIGNyZWF0ZSBhIHJlZiBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWNvbXBvbmVudCcpO1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgICAvLyByZW1vdmUgaXMgYXR0cmlidXRlLlxuICAgICAgLy8gdGhpcyBpcyByZW1vdmVkIGR1cmluZyBjb21waWxhdGlvbiwgYnV0IGJlY2F1c2UgY29tcGlsYXRpb24gaXNcbiAgICAgIC8vIGNhY2hlZCwgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVzZWQgZWxzZXdoZXJlIHRoaXMgYXR0cmlidXRlXG4gICAgICAvLyB3aWxsIHJlbWFpbiBhdCBsaW5rIHRpbWUuXG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCc6aXMnKTtcbiAgICAgIC8vIHJlbW92ZSByZWYsIHNhbWUgYXMgYWJvdmVcbiAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCd2LXJlZjonICsgaHlwaGVuYXRlKHRoaXMuZGVzY3JpcHRvci5yZWYpKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXRpYywgYnVpbGQgcmlnaHQgbm93LlxuICAgICAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudCh0aGlzLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2Nhbm5vdCBtb3VudCBjb21wb25lbnQgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiICcgKyAnb24gYWxyZWFkeSBtb3VudGVkIGVsZW1lbnQ6ICcgKyB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1YmxpYyB1cGRhdGUsIGNhbGxlZCBieSB0aGUgd2F0Y2hlciBpbiB0aGUgZHluYW1pY1xuICAgKiBsaXRlcmFsIHNjZW5hcmlvLCBlLmcuIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5saXRlcmFsKSB7XG4gICAgICB0aGlzLnNldENvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggZHluYW1pYyBjb21wb25lbnRzLiBNYXkgcmVzb2x2ZSB0aGUgY29tcG9uZW50XG4gICAqIGFzeW5jaHJvbm91c2x5LCBhbmQgcGVyZm9ybSB0cmFuc2l0aW9uIGJhc2VkIG9uXG4gICAqIHNwZWNpZmllZCB0cmFuc2l0aW9uIG1vZGUuIEFjY2VwdHMgYSBmZXcgYWRkaXRpb25hbFxuICAgKiBhcmd1bWVudHMgc3BlY2lmaWNhbGx5IGZvciB2dWUtcm91dGVyLlxuICAgKlxuICAgKiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGZ1bGwgdHJhbnNpdGlvbiBpc1xuICAgKiBmaW5pc2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlUGVuZGluZygpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgIHRoaXMudW5idWlsZCh0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuY2hpbGRWTSwgY2IpO1xuICAgICAgdGhpcy5jaGlsZFZNID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYubW91bnRDb21wb25lbnQoY2IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICogdGhlIGNoaWxkIHZtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVzb2x2ZUNvbXBvbmVudDogZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICBzZWxmLkNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQub3B0aW9ucy5uYW1lIHx8ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBudWxsKTtcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgY3VycmVudCBjb25zdHJ1Y3RvciBhbmRcbiAgICogcmVwbGFjZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGRvZXNuJ3QgY2FyZVxuICAgKiB3aGV0aGVyIHRoZSBuZXcgY29tcG9uZW50IGFuZCB0aGUgb2xkIG9uZSBhcmUgYWN0dWFsbHlcbiAgICogdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWN0aXZhdGVIb29rcyA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGU7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgdmFyIG5ld0NvbXBvbmVudCA9IHRoaXMuYnVpbGQoKTtcbiAgICBpZiAoYWN0aXZhdGVIb29rcyAmJiAhY2FjaGVkKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBuZXdDb21wb25lbnQ7XG4gICAgICBjYWxsQWN0aXZhdGVIb29rcyhhY3RpdmF0ZUhvb2tzLCBuZXdDb21wb25lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYud2FpdGluZ0ZvciAhPT0gbmV3Q29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHNlbGYudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgcmVmIGZvciBrZXB0LWFsaXZlIGNvbXBvbmVudFxuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBuZXdDb21wb25lbnQuX3VwZGF0ZVJlZigpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZXMgb3IgdW5iaW5kcyBiZWZvcmUgYW4gYXN5bmNcbiAgICogY29uc3RydWN0b3IgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBpdHNcbiAgICogcGVuZGluZyBjYWxsYmFjay5cbiAgICovXG5cbiAgaW52YWxpZGF0ZVBlbmRpbmc6IGZ1bmN0aW9uIGludmFsaWRhdGVQZW5kaW5nKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb21wb25lbnRDYikge1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IuY2FuY2VsKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZXh0cmFPcHRpb25zKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQ29tcG9uZW50KSB7XG4gICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiB0aGlzLkNvbXBvbmVudE5hbWUsXG4gICAgICAgIGVsOiBjbG9uZU5vZGUodGhpcy5lbCksXG4gICAgICAgIHRlbXBsYXRlOiB0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYWRkIHRoZSBjaGlsZCB3aXRoIGNvcnJlY3QgcGFyZW50XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGl0cyBwYXJlbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSB0cmFuc2NsdXNpb24gaG9zdC5cbiAgICAgICAgcGFyZW50OiB0aGlzLl9ob3N0IHx8IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIG5vIGlubGluZS10ZW1wbGF0ZSwgdGhlbiB0aGUgY29tcGlsZWRcbiAgICAgICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgX2xpbmtlckNhY2hhYmxlOiAhdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgX3JlZjogdGhpcy5kZXNjcmlwdG9yLnJlZixcbiAgICAgICAgX2FzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfaXNSb3V0ZXJWaWV3OiB0aGlzLl9pc1JvdXRlclZpZXcsXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICAgICAgX2NvbnRleHQ6IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgX3Njb3BlOiB0aGlzLl9zY29wZSxcbiAgICAgICAgLy8gcGFzcyBpbiB0aGUgb3duZXIgZnJhZ21lbnQgb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgdGhlIGZyYWdtZW50IGNhbiBrZWVwXG4gICAgICAgIC8vIHRyYWNrIG9mIGl0cyBjb250YWluZWQgY29tcG9uZW50cyBpbiBvcmRlciB0b1xuICAgICAgICAvLyBjYWxsIGF0dGFjaC9kZXRhY2ggaG9va3MgZm9yIHRoZW0uXG4gICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICB9O1xuICAgICAgLy8gZXh0cmEgb3B0aW9uc1xuICAgICAgLy8gaW4gMS4wLjAgdGhpcyBpcyB1c2VkIGJ5IHZ1ZS1yb3V0ZXIgb25seVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuQ29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXSA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgndHJhbnNpdGlvbicpICYmIGNoaWxkLl9pc0ZyYWdtZW50KSB7XG4gICAgICAgIHdhcm4oJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArICdUZW1wbGF0ZTogJyArIGNoaWxkLiRvcHRpb25zLnRlbXBsYXRlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ2V0IGEgY2FjaGVkIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkOiBmdW5jdGlvbiBnZXRDYWNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogVGVhcmRvd24gdGhlIGN1cnJlbnQgY2hpbGQsIGJ1dCBkZWZlcnMgY2xlYW51cCBzb1xuICAgKiB0aGF0IHdlIGNhbiBzZXBhcmF0ZSB0aGUgZGVzdHJveSBhbmQgcmVtb3ZhbCBzdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlclxuICAgKi9cblxuICB1bmJ1aWxkOiBmdW5jdGlvbiB1bmJ1aWxkKGRlZmVyKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0Zvcikge1xuICAgICAgaWYgKCF0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLndhaXRpbmdGb3IuJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTTtcbiAgICBpZiAoIWNoaWxkIHx8IHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZlxuICAgICAgICBjaGlsZC5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBjaGlsZC5fdXBkYXRlUmVmKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjdXJyZW50IGRlc3Ryb3llZCBjaGlsZCBhbmQgbWFudWFsbHkgZG9cbiAgICogdGhlIGNsZWFudXAgYWZ0ZXIgcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY2hpbGQsIGNiKSB7XG4gICAgdmFyIGtlZXBBbGl2ZSA9IHRoaXMua2VlcEFsaXZlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgLy8gd2UgbWF5IGhhdmUgYSBjb21wb25lbnQgc3dpdGNoIHdoZW4gYSBwcmV2aW91c1xuICAgICAgLy8gY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIHRyYW5zaXRpb25lZCBvdXQuXG4gICAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgb25seSBvbmUgbGFzdGVzdCBpbnNlcnRpb24gY2JcbiAgICAgIC8vIHdoZW4gdGhlIGV4aXN0aW5nIHRyYW5zaXRpb24gZmluaXNoZXMuICgjMTExOSlcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKys7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFscy0tO1xuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKCFzZWxmLnBlbmRpbmdSZW1vdmFscyAmJiBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IpIHtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IoKTtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0dWFsbHkgc3dhcCB0aGUgY29tcG9uZW50cywgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiB0cmFuc2l0aW9uIG1vZGUuIERlZmF1bHRzIHRvIHNpbXVsdGFuZW91cy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24odGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hpbGRWTTtcbiAgICAvLyBmb3IgZGV2dG9vbCBpbnNwZWN0aW9uXG4gICAgaWYgKGN1cnJlbnQpIGN1cnJlbnQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0O1xuICAgIHN3aXRjaCAoc2VsZi5wYXJhbXMudHJhbnNpdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgJ2luLW91dCc6XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvdXQtaW4nOlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCk7XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICAvLyBEbyBub3QgZGVmZXIgY2xlYW51cCB3aGVuIHVuYmluZGluZ1xuICAgIHRoaXMudW5idWlsZCgpO1xuICAgIC8vIGRlc3Ryb3kgYWxsIGtlZXAtYWxpdmUgY2FjaGVkIGluc3RhbmNlc1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0uJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFjdGl2YXRlIGhvb2tzIGluIG9yZGVyIChhc3luY2hyb25vdXMpXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVIb29rcyhob29rcywgdm0sIGNiKSB7XG4gIHZhciB0b3RhbCA9IGhvb2tzLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIGhvb2tzWzBdLmNhbGwodm0sIG5leHQpO1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmICgrK2NhbGxlZCA+PSB0b3RhbCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3NbY2FsbGVkXS5jYWxsKHZtLCBuZXh0KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BCaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG52YXIgZW1wdHkgPSB7fTtcblxuLy8gcmVnZXhlc1xudmFyIGlkZW50UkUkMSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC87XG52YXIgc2V0dGFibGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKFxcLltBLVphLXpfJF1bXFx3JF0qfFxcW1teXFxbXFxdXStcXF0pKiQvO1xuXG4vKipcbiAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICogYSBwcm9wcyBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gcHJvcE9wdGlvbnNcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHJldHVybiB7RnVuY3Rpb259IHByb3BzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVByb3BzKGVsLCBwcm9wT3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BPcHRpb25zKTtcbiAgdmFyIGkgPSBuYW1lcy5sZW5ndGg7XG4gIHZhciBvcHRpb25zLCBuYW1lLCBhdHRyLCB2YWx1ZSwgcGF0aCwgcGFyc2VkLCBwcm9wO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgIG9wdGlvbnMgPSBwcm9wT3B0aW9uc1tuYW1lXSB8fCBlbXB0eTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICckZGF0YScpIHtcbiAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgJGRhdGEgYXMgcHJvcC4nLCB2bSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IGNhbWVsaXplKG5hbWUpO1xuICAgIGlmICghaWRlbnRSRSQxLnRlc3QocGF0aCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wIGtleTogXCInICsgbmFtZSArICdcIi4gUHJvcCBrZXlzICcgKyAnbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVycy4nLCB2bSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9wID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgbW9kZTogcHJvcEJpbmRpbmdNb2Rlcy5PTkVfV0FZLFxuICAgICAgcmF3OiBudWxsXG4gICAgfTtcblxuICAgIGF0dHIgPSBoeXBoZW5hdGUobmFtZSk7XG4gICAgLy8gZmlyc3QgY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyKSkgPT09IG51bGwpIHtcbiAgICAgIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0ciArICcuc3luYycpKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVk7XG4gICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5vbmNlJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gaGFzIGR5bmFtaWMgYmluZGluZyFcbiAgICAgIHByb3AucmF3ID0gdmFsdWU7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHBhcnNlZC5leHByZXNzaW9uO1xuICAgICAgcHJvcC5maWx0ZXJzID0gcGFyc2VkLmZpbHRlcnM7XG4gICAgICAvLyBjaGVjayBiaW5kaW5nIHR5cGVcbiAgICAgIGlmIChpc0xpdGVyYWwodmFsdWUpICYmICFwYXJzZWQuZmlsdGVycykge1xuICAgICAgICAvLyBmb3IgZXhwcmVzc2lvbnMgY29udGFpbmluZyBsaXRlcmFsIG51bWJlcnMgYW5kXG4gICAgICAgIC8vIGJvb2xlYW5zLCB0aGVyZSdzIG5vIG5lZWQgdG8gc2V0dXAgYSBwcm9wIGJpbmRpbmcsXG4gICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICBwcm9wLm9wdGltaXplZExpdGVyYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgLy8gY2hlY2sgbm9uLXNldHRhYmxlIHBhdGggZm9yIHR3by13YXkgYmluZGluZ3NcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkgJiYgIXNldHRhYmxlUGF0aFJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfV0FZO1xuICAgICAgICAgIHdhcm4oJ0Nhbm5vdCBiaW5kIHR3by13YXkgcHJvcCB3aXRoIG5vbi1zZXR0YWJsZSAnICsgJ3BhcmVudCBwYXRoOiAnICsgdmFsdWUsIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5wYXJlbnRQYXRoID0gdmFsdWU7XG5cbiAgICAgIC8vIHdhcm4gcmVxdWlyZWQgdHdvLXdheVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy50d29XYXkgJiYgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkpIHtcbiAgICAgICAgd2FybignUHJvcCBcIicgKyBuYW1lICsgJ1wiIGV4cGVjdHMgYSB0d28td2F5IGJpbmRpbmcgdHlwZS4nLCB2bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRBdHRyKGVsLCBhdHRyKSkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBsaXRlcmFsIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gY2hlY2sgcG9zc2libGUgY2FtZWxDYXNlIHByb3AgdXNhZ2VcbiAgICAgIHZhciBsb3dlckNhc2VOYW1lID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAvW0EtWlxcLV0vLnRlc3QobmFtZSkgJiYgKGVsLmdldEF0dHJpYnV0ZShsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLm9uY2UnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5zeW5jJykpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3NpYmxlIHVzYWdlIGVycm9yIGZvciBwcm9wIGAnICsgbG93ZXJDYXNlTmFtZSArICdgIC0gJyArICdkaWQgeW91IG1lYW4gYCcgKyBhdHRyICsgJ2A/IEhUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlICcgKyAna2ViYWItY2FzZSBmb3IgcHJvcHMgaW4gdGVtcGxhdGVzLicsIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlZCkge1xuICAgICAgICAvLyB3YXJuIG1pc3NpbmcgcmVxdWlyZWRcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiAnICsgbmFtZSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHByb3BzIHRvIGEgdm0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VQcm9wc0xpbmtGbihwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJvcHNMaW5rRm4odm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9O1xuICAgIHZhciBpbmxpbmVQcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzRGF0YTtcbiAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhdztcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICByYXcgPSBwcm9wLnJhdztcbiAgICAgIHBhdGggPSBwcm9wLnBhdGg7XG4gICAgICBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICAgICAgdm0uX3Byb3BzW3BhdGhdID0gcHJvcDtcbiAgICAgIGlmIChpbmxpbmVQcm9wcyAmJiBoYXNPd24oaW5saW5lUHJvcHMsIHBhdGgpKSB7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCBpbmxpbmVQcm9wc1twYXRoXSk7XG4gICAgICB9aWYgKHJhdyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIGFic2VudCBwcm9wXG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgLy8gZHluYW1pYyBwcm9wXG4gICAgICAgIGlmIChwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUUpIHtcbiAgICAgICAgICAvLyBvbmUgdGltZSBiaW5kaW5nXG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0uX2NvbnRleHQgfHwgdm0pLiRnZXQocHJvcC5wYXJlbnRQYXRoKTtcbiAgICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2bS5fY29udGV4dCkge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBiaW5kaW5nXG4gICAgICAgICAgICB2bS5fYmluZERpcih7XG4gICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgZGVmOiBwcm9wRGVmLFxuICAgICAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSk7IC8vIGVsLCBob3N0LCBzY29wZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2VcbiAgICAgICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZtLiRnZXQocHJvcC5wYXJlbnRQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcC5vcHRpbWl6ZWRMaXRlcmFsKSB7XG4gICAgICAgIC8vIG9wdGltaXplZCBsaXRlcmFsLCBjYXN0IGl0IGFuZCBqdXN0IHNldCBvbmNlXG4gICAgICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwUXVvdGVzKHJhdyk7XG4gICAgICAgIHZhbHVlID0gc3RyaXBwZWQgPT09IHJhdyA/IHRvQm9vbGVhbih0b051bWJlcihyYXcpKSA6IHN0cmlwcGVkO1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAvLyBCb29sZWFuIHByb3BzIHdpdGggbm8gdmFsdWUsIG9yIHdpdGggc2FtZVxuICAgICAgICAvLyBsaXRlcmFsIHZhbHVlIChlLmcuIGRpc2FibGVkPVwiZGlzYWJsZWRcIilcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtbG9hZGVyL2lzc3Vlcy8xODJcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gJiYgKHJhdyA9PT0gJycgfHwgcmF3ID09PSBoeXBoZW5hdGUocHJvcC5uYW1lKSkgPyB0cnVlIDogcmF3O1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgcHJvcCB3aXRoIGEgcmF3VmFsdWUsIGFwcGx5aW5nIG5lY2Vzc2FyeSBjb2Vyc2lvbnMsXG4gKiBkZWZhdWx0IHZhbHVlcyAmIGFzc2VydGlvbnMgYW5kIGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIHdpdGhcbiAqIHByb2Nlc3NlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHJhd1ZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHJhd1ZhbHVlLCBmbikge1xuICB2YXIgaXNTaW1wbGUgPSBwcm9wLmR5bmFtaWMgJiYgaXNTaW1wbGVQYXRoKHByb3AucGFyZW50UGF0aCk7XG4gIHZhciB2YWx1ZSA9IHJhd1ZhbHVlO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCk7XG4gIH1cbiAgdmFsdWUgPSBjb2VyY2VQcm9wKHByb3AsIHZhbHVlLCB2bSk7XG4gIHZhciBjb2VyY2VkID0gdmFsdWUgIT09IHJhd1ZhbHVlO1xuICBpZiAoIWFzc2VydFByb3AocHJvcCwgdmFsdWUsIHZtKSkge1xuICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1NpbXBsZSAmJiAhY29lcmNlZCkge1xuICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmbih2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wJ3MgaW5pdGlhbCB2YWx1ZSBvbiBhIHZtIGFuZCBpdHMgZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCB2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sIHByb3AucGF0aCwgdmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBwcm9wJ3MgdmFsdWUgb24gYSB2bS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlUHJvcCh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgdmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZtW3Byb3AucGF0aF0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3ApIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgaWYgKCFoYXNPd24ob3B0aW9ucywgJ2RlZmF1bHQnKSkge1xuICAgIC8vIGFic2VudCBib29sZWFuIHZhbHVlIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgcmV0dXJuIG9wdGlvbnMudHlwZSA9PT0gQm9vbGVhbiA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBkZWYgPSBvcHRpb25zWydkZWZhdWx0J107XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCI6ICcgKyAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJywgdm0pO1xuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMudHlwZSAhPT0gRnVuY3Rpb24gPyBkZWYuY2FsbCh2bSkgOiBkZWY7XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIHZhbHVlLCB2bSkge1xuICBpZiAoIXByb3Aub3B0aW9ucy5yZXF1aXJlZCAmJiAoIC8vIG5vbi1yZXF1aXJlZFxuICBwcm9wLnJhdyA9PT0gbnVsbCB8fCAvLyBhYnNjZW50XG4gIHZhbHVlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCIuJyArICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGZvcm1hdFR5cGUpLmpvaW4oJywgJykgKyAnLCBnb3QgJyArIGZvcm1hdFZhbHVlKHZhbHVlKSArICcuJywgdm0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IG9wdGlvbnMudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiLicsIHZtKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRm9yY2UgcGFyc2luZyB2YWx1ZSB3aXRoIGNvZXJjZSBvcHRpb24uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSwgdm0pIHtcbiAgdmFyIGNvZXJjZSA9IHByb3Aub3B0aW9ucy5jb2VyY2U7XG4gIGlmICghY29lcmNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGNvZXJjZSBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCI6IGV4cGVjdGVkIGZ1bmN0aW9uLCBnb3QgJyArIHR5cGVvZiBjb2VyY2UgKyAnLicsIHZtKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZTtcbiAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBCb29sZWFuKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRnVuY3Rpb24pIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gT2JqZWN0KSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCc7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBcnJheSkge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSc7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9O1xufVxuXG4vKipcbiAqIEZvcm1hdCB0eXBlIGZvciBvdXRwdXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpIDogJ2N1c3RvbSB0eXBlJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59XG5cbnZhciBiaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG5cbnZhciBwcm9wRGVmID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy52bTtcbiAgICB2YXIgcGFyZW50ID0gY2hpbGQuX2NvbnRleHQ7XG4gICAgLy8gcGFzc2VkIGluIGZyb20gY29tcGlsZXIgZGlyZWN0bHlcbiAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wO1xuICAgIHZhciBjaGlsZEtleSA9IHByb3AucGF0aDtcbiAgICB2YXIgcGFyZW50S2V5ID0gcHJvcC5wYXJlbnRQYXRoO1xuICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuXG4gICAgdmFyIHBhcmVudFdhdGNoZXIgPSB0aGlzLnBhcmVudFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihwYXJlbnQsIHBhcmVudEtleSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdXBkYXRlUHJvcChjaGlsZCwgcHJvcCwgdmFsKTtcbiAgICB9LCB7XG4gICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgIGZpbHRlcnM6IHByb3AuZmlsdGVycyxcbiAgICAgIC8vIGltcG9ydGFudDogcHJvcHMgbmVlZCB0byBiZSBvYnNlcnZlZCBvbiB0aGVcbiAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIGluaXRQcm9wKGNoaWxkLCBwcm9wLCBwYXJlbnRXYXRjaGVyLnZhbHVlKTtcblxuICAgIC8vIHNldHVwIHR3by13YXkgYmluZGluZ1xuICAgIGlmICh0d29XYXkpIHtcbiAgICAgIC8vIGltcG9ydGFudDogZGVmZXIgdGhlIGNoaWxkIHdhdGNoZXIgY3JlYXRpb24gdW50aWxcbiAgICAgIC8vIHRoZSBjcmVhdGVkIGhvb2sgKGFmdGVyIGRhdGEgb2JzZXJ2YXRpb24pXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kb25jZSgncHJlLWhvb2s6Y3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jaGlsZFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjaGlsZCwgY2hpbGRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBwYXJlbnRXYXRjaGVyLnNldCh2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN5bmMgdXB3YXJkIGJlZm9yZSBwYXJlbnQgc3luYyBkb3duLlxuICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIGNhc2VzIGUuZy4gdGhlIGNoaWxkXG4gICAgICAgICAgLy8gbXV0YXRlcyBhIHByb3AgYXJyYXksIHRoZW4gcmVwbGFjZXMgaXQuICgjMTY4MylcbiAgICAgICAgICBzeW5jOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpO1xuICAgIGlmICh0aGlzLmNoaWxkV2F0Y2hlcikge1xuICAgICAgdGhpcy5jaGlsZFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSQxID0gW107XG52YXIgcXVldWVkID0gZmFsc2U7XG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5mdW5jdGlvbiBwdXNoSm9iKGpvYikge1xuICBxdWV1ZSQxLnB1c2goam9iKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIHRoZSBxdWV1ZSwgYW5kIGRvIG9uZSBmb3JjZWQgcmVmbG93IGJlZm9yZVxuICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZSQxLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWUkMVtpXSgpO1xuICB9XG4gIHF1ZXVlJDEgPSBbXTtcbiAgcXVldWVkID0gZmFsc2U7XG4gIC8vIGR1bW15IHJldHVybiwgc28ganMgbGludGVycyBkb24ndCBjb21wbGFpbiBhYm91dFxuICAvLyB1bnVzZWQgdmFyaWFibGUgZlxuICByZXR1cm4gZjtcbn1cblxudmFyIFRZUEVfVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBUWVBFX0FOSU1BVElPTiA9ICdhbmltYXRpb24nO1xudmFyIHRyYW5zRHVyYXRpb25Qcm9wID0gdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nO1xudmFyIGFuaW1EdXJhdGlvblByb3AgPSBhbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcblxuLyoqXG4gKiBJZiBhIGp1c3QtZW50ZXJlZCBlbGVtZW50IGlzIGFwcGxpZWQgdGhlXG4gKiBsZWF2ZSBjbGFzcyB3aGlsZSBpdHMgZW50ZXIgdHJhbnNpdGlvbiBoYXNuJ3Qgc3RhcnRlZCB5ZXQsXG4gKiBhbmQgdGhlIHRyYW5zaXRpb25lZCBwcm9wZXJ0eSBoYXMgdGhlIHNhbWUgdmFsdWUgZm9yIGJvdGhcbiAqIGVudGVyL2xlYXZlLCB0aGVuIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZCBhbmRcbiAqIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiBUaGlzIGZ1bmN0aW9uIGVuc3VyZXNcbiAqIGl0cyBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGhhcyBzdGFydGVkXG4gKiBieSB3YWl0aW5nIGZvciBkb3VibGUgcmFmLlxuICpcbiAqIEl0IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCBvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCBDU1NcbiAqIHRyYW5zaXRpb25zIGJ1dCBub3QgcmFmIChlLmcuIEFuZHJvaWQgNC4yIGJyb3dzZXIpIC0gc2luY2VcbiAqIHRoZXNlIGVudmlyb25tZW50cyBhcmUgdXN1YWxseSBzbG93LCB3ZSBhcmUgZ2l2aW5nIGl0IGFcbiAqIHJlbGF0aXZlbHkgbGFyZ2UgdGltZW91dC5cbiAqL1xuXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgd2FpdEZvclRyYW5zaXRpb25TdGFydCA9IHJhZlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbj8gZnVuY3Rpb24gKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHNldFRpbWVvdXQoZm4sIDUwKTtcbn07XG5cbi8qKlxuICogQSBUcmFuc2l0aW9uIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB0aGUgc3RhdGUgYW5kIGxvZ2ljXG4gKiBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBob29rc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdm0pIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMuZW50ZXJDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmVudGVyQ2xhc3MgfHwgaWQgKyAnLWVudGVyJztcbiAgdGhpcy5sZWF2ZUNsYXNzID0gaG9va3MgJiYgaG9va3MubGVhdmVDbGFzcyB8fCBpZCArICctbGVhdmUnO1xuICB0aGlzLmhvb2tzID0gaG9va3M7XG4gIHRoaXMudm0gPSB2bTtcbiAgLy8gYXN5bmMgc3RhdGVcbiAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICB0aGlzLmVudGVyZWQgPSB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy50eXBlQ2FjaGUgPSB7fTtcbiAgLy8gY2hlY2sgY3NzIHRyYW5zaXRpb24gdHlwZVxuICB0aGlzLnR5cGUgPSBob29rcyAmJiBob29rcy50eXBlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gVFlQRV9UUkFOU0lUSU9OICYmIHRoaXMudHlwZSAhPT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHdhcm4oJ2ludmFsaWQgQ1NTIHRyYW5zaXRpb24gdHlwZSBmb3IgdHJhbnNpdGlvbj1cIicgKyB0aGlzLmlkICsgJ1wiOiAnICsgdGhpcy50eXBlLCB2bSk7XG4gICAgfVxuICB9XG4gIC8vIGJpbmRcbiAgdmFyIHNlbGYgPSB0aGlzO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgc2VsZlttXSA9IGJpbmQoc2VsZlttXSwgc2VsZik7XG4gIH0pO1xufVxuXG52YXIgcCQxID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbi8qKlxuICogU3RhcnQgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBlbnRlciB0cmFuc2l0aW9uIHRyaWdnZXJlZFxuICogMi4gY2FsbCBiZWZvcmVFbnRlciBob29rXG4gKiAzLiBhZGQgZW50ZXIgY2xhc3NcbiAqIDQuIGluc2VydC9zaG93IGVsZW1lbnRcbiAqIDUuIGNhbGwgZW50ZXIgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDYuIHJlZmxvd1xuICogNy4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uOlxuICogICAgICAgIHJlbW92ZSBjbGFzcyBub3csIHdhaXQgZm9yIHRyYW5zaXRpb25lbmQsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBhbmltYXRpb25lbmQsIHJlbW92ZSBjbGFzcyxcbiAqICAgICAgICB0aGVuIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBub3cgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDguIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyRW50ZXIgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIGluc2VydC9zaG93IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmVudGVyID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlRW50ZXInKTtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICBvcCgpO1xuICB0aGlzLmVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignZW50ZXInKTtcbiAgaWYgKHRoaXMuZW50ZXJlZCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkO1xuICBwdXNoSm9iKHRoaXMuZW50ZXJOZXh0VGljayk7XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlck5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIC8vIHByZXZlbnQgdHJhbnNpdGlvbiBza2lwcGluZ1xuICB0aGlzLmp1c3RFbnRlcmVkID0gdHJ1ZTtcbiAgd2FpdEZvclRyYW5zaXRpb25TdGFydChmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgfSk7XG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZTtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMuZW50ZXJDbGFzcyk7XG4gIGlmICghdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICAgIC8vIHRyaWdnZXIgdHJhbnNpdGlvbiBieSByZW1vdmluZyBlbnRlciBjbGFzcyBub3dcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYihhbmltYXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJEb25lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmVudGVyRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRlcmVkID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJFbnRlcicpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xufTtcblxuLyoqXG4gKiBTdGFydCBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBsZWF2ZSB0cmFuc2l0aW9uIHRyaWdnZXJlZC5cbiAqIDIuIGNhbGwgYmVmb3JlTGVhdmUgaG9va1xuICogMy4gYWRkIGxlYXZlIGNsYXNzICh0cmlnZ2VyIGNzcyB0cmFuc2l0aW9uKVxuICogNC4gY2FsbCBsZWF2ZSBob29rICh3aXRoIHBvc3NpYmxlIGV4cGxpY2l0IGpzIGNhbGxiYWNrKVxuICogNS4gcmVmbG93IGlmIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKiA2LiBiYXNlZCBvbiB0cmFuc2l0aW9uIHR5cGU6XG4gKiAgICAtIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uOlxuICogICAgICAgIHdhaXQgZm9yIGVuZCBldmVudCwgcmVtb3ZlIGNsYXNzLCB0aGVuIGRvbmUgaWZcbiAqICAgICAgICB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBubyBjc3MgdHJhbnNpdGlvbjpcbiAqICAgICAgICBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA3LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckxlYXZlIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSByZW1vdmUvaGlkZSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUxlYXZlJyk7XG4gIHRoaXMub3AgPSBvcDtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKTtcbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmxlYXZlQ2FuY2VsbGVkO1xuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEpvYih0aGlzLmxlYXZlTmV4dFRpY2spO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZU5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5sZWF2ZUNsYXNzKTtcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICB0aGlzLnNldHVwQ3NzQ2IoZXZlbnQsIHRoaXMubGVhdmVEb25lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlZnQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB0aGlzLm9wKCk7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyTGVhdmUnKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbiAgdGhpcy5vcCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5jYW5jZWxQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdDc3NDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIG9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpO1xuICAgIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgfVxuICBpZiAoaGFzUGVuZGluZykge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgfVxuICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICB0aGlzLmNhbmNlbC5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCBzeW5jaHJvbm91cyBob29rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCwgcG90ZW50aWFsbHktYXN5bmMgaG9vayBmdW5jdGlvbi5cbiAqIFdlIGNoZWNrIGZvciB0aGUgbGVuZ3RoIG9mIGFyZ3VtZW50cyB0byBzZWUgaWYgdGhlIGhvb2tcbiAqIGV4cGVjdHMgYSBgZG9uZWAgY2FsbGJhY2suIElmIHRydWUsIHRoZSB0cmFuc2l0aW9uJ3MgZW5kXG4gKiB3aWxsIGJlIGRldGVybWluZWQgYnkgd2hlbiB0aGUgdXNlciBjYWxscyB0aGF0IGNhbGxiYWNrO1xuICogb3RoZXJ3aXNlLCB0aGUgZW5kIGlzIGRldGVybWluZWQgYnkgdGhlIENTUyB0cmFuc2l0aW9uIG9yXG4gKiBhbmltYXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2tXaXRoQ2IgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgaG9vayA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXTtcbiAgaWYgKGhvb2spIHtcbiAgICBpZiAoaG9vay5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBlbmRpbmdKc0NiID0gY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSk7XG4gICAgfVxuICAgIGhvb2suY2FsbCh0aGlzLnZtLCB0aGlzLmVsLCB0aGlzLnBlbmRpbmdKc0NiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wJDEuZ2V0Q3NzVHJhbnNpdGlvblR5cGUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgLy8gdGhpcyBzb2x2ZXMgdGhlIGlzc3VlIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzIG5vdFxuICAvLyBmaXJpbmcgdW50aWwgdGhlIHBhZ2UgaXMgdmlzaWJsZSBhZ2Fpbi5cbiAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAvLyBDU1MgdHJhbnNpdGlvbnMuXG4gIGRvY3VtZW50LmhpZGRlbiB8fFxuICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UgfHxcbiAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgaXNIaWRkZW4odGhpcy5lbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgfHwgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlO1xuICB2YXIgaW5saW5lU3R5bGVzID0gdGhpcy5lbC5zdHlsZTtcbiAgdmFyIGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG4gIHZhciB0cmFuc0R1cmF0aW9uID0gaW5saW5lU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF07XG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmltRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF07XG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTjtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdID0gdHlwZTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogU2V0dXAgYSBDU1MgdHJhbnNpdGlvbmVuZC9hbmltYXRpb25lbmQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbnAkMS5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbCA9IHRoaXMuZWw7XG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBvZmYoZWwsIGV2ZW50LCBvbkVuZCk7XG4gICAgICBzZWxmLnBlbmRpbmdDc3NFdmVudCA9IHNlbGYucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgb24oZWwsIGV2ZW50LCBvbkVuZCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgaGlkZGVuIC0gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0XG4gKiBza2lwIHRoZSB0cmFuc2l0aW9uIGFsbHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNIaWRkZW4oZWwpIHtcbiAgaWYgKC9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICAvLyBTVkcgZWxlbWVudHMgZG8gbm90IGhhdmUgb2Zmc2V0KFdpZHRofEhlaWdodClcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjbGllbnQgcmVjdFxuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuICEocmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiQxID0ge1xuXG4gIHByaW9yaXR5OiBUUkFOU0lUSU9OLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGlkLCBvbGRJZCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgLy8gcmVzb2x2ZSBvbiBvd25lciB2bVxuICAgIHZhciBob29rcyA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAndHJhbnNpdGlvbnMnLCBpZCk7XG4gICAgaWQgPSBpZCB8fCAndic7XG4gICAgb2xkSWQgPSBvbGRJZCB8fCAndic7XG4gICAgZWwuX192X3RyYW5zID0gbmV3IFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdGhpcy52bSk7XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJyk7XG4gICAgYWRkQ2xhc3MoZWwsIGlkICsgJy10cmFuc2l0aW9uJyk7XG4gIH1cbn07XG5cbnZhciBpbnRlcm5hbERpcmVjdGl2ZXMgPSB7XG4gIHN0eWxlOiBzdHlsZSxcbiAgJ2NsYXNzJzogdkNsYXNzLFxuICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgcHJvcDogcHJvcERlZixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxXG59O1xuXG4vLyBzcGVjaWFsIGJpbmRpbmcgcHJlZml4ZXNcbnZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovO1xudmFyIG9uUkUgPSAvXnYtb246fF5ALztcbnZhciBkaXJBdHRyUkUgPSAvXnYtKFteOl0rKSg/OiR8OiguKikkKS87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXlxcLl0rL2c7XG52YXIgdHJhbnNpdGlvblJFID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC87XG5cbi8vIGRlZmF1bHQgZGlyZWN0aXZlIHByaW9yaXR5XG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG52YXIgREVGQVVMVF9URVJNSU5BTF9QUklPUklUWSA9IDIwMDA7XG5cbi8qKlxuICogQ29tcGlsZSBhIHRlbXBsYXRlIGFuZCByZXR1cm4gYSByZXVzYWJsZSBjb21wb3NpdGUgbGlua1xuICogZnVuY3Rpb24sIHdoaWNoIHJlY3Vyc2l2ZWx5IGNvbnRhaW5zIG1vcmUgbGluayBmdW5jdGlvbnNcbiAqIGluc2lkZS4gVGhpcyB0b3AgbGV2ZWwgY29tcGlsZSBmdW5jdGlvbiB3b3VsZCBub3JtYWxseVxuICogYmUgY2FsbGVkIG9uIGluc3RhbmNlIHJvb3Qgbm9kZXMsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkXG4gKiBmb3IgcGFydGlhbCBjb21waWxhdGlvbiBpZiB0aGUgcGFydGlhbCBhcmd1bWVudCBpcyB0cnVlLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjb21wb3NpdGUgbGluayBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGxcbiAqIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXNcbiAqIGNyZWF0ZWQgZHVyaW5nIHRoZSBsaW5raW5nIHBoYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFydGlhbFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZShlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnQgPyBjb21waWxlTm9kZShlbCwgb3B0aW9ucykgOiBudWxsO1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgIWlzU2NyaXB0KGVsKSAmJiBlbC5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3QoZWwuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBvc2l0ZSBsaW5rZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGEgYWxyZWFkeVxuICAgKiBjb21waWxlZCBwaWVjZSBvZiBET00sIHdoaWNoIGluc3RhbnRpYXRlcyBhbGwgZGlyZWN0aXZlXG4gICAqIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gaG9zdCB2bSBvZiB0cmFuc2NsdWRlZCBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gbGluayBjb250ZXh0IGZyYWdtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGVsLmNoaWxkTm9kZXMpO1xuICAgIC8vIGxpbmtcbiAgICB2YXIgZGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtDYXB0dXJlcigpIHtcbiAgICAgIGlmIChub2RlTGlua0ZuKSBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgaWYgKGNoaWxkTGlua0ZuKSBjaGlsZExpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH0sIHZtKTtcbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBkaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZShsaW5rZXIsIHZtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHJlc2V0IGRpcmVjdGl2ZXMgYmVmb3JlIGV2ZXJ5IGNhcHR1cmUgaW4gcHJvZHVjdGlvblxuICAgIC8vIG1vZGUsIHNvIHRoYXQgd2hlbiB1bmxpbmtpbmcgd2UgZG9uJ3QgbmVlZCB0byBzcGxpY2VcbiAgICAvLyB0aGVtIG91dCAod2hpY2ggdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBoaXQpLlxuICAgIC8vIHRoZXkgYXJlIGtlcHQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIHRoZXkgYXJlXG4gICAgLy8gdXNlZnVsIGZvciBWdWUncyBvd24gdGVzdHMuXG4gICAgdm0uX2RpcmVjdGl2ZXMgPSBbXTtcbiAgfVxuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aDtcbiAgbGlua2VyKCk7XG4gIHZhciBkaXJzID0gdm0uX2RpcmVjdGl2ZXMuc2xpY2Uob3JpZ2luYWxEaXJDb3VudCk7XG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpcnNbaV0uX2JpbmQoKTtcbiAgfVxuICByZXR1cm4gZGlycztcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvcihhLCBiKSB7XG4gIGEgPSBhLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG4vKipcbiAqIExpbmtlciBmdW5jdGlvbnMgcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0XG4gKiB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXMgaW5zdGFuY2VzIGdlbmVyYXRlZCBkdXJpbmdcbiAqIHRoZSBwcm9jZXNzLlxuICpcbiAqIFdlIGNyZWF0ZSB1bmxpbmsgZnVuY3Rpb25zIHdpdGggb25seSB0aGUgbmVjZXNzYXJ5XG4gKiBpbmZvcm1hdGlvbiB0byBhdm9pZCByZXRhaW5pbmcgYWRkaXRpb25hbCBjbG9zdXJlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7VnVlfSBbY29udGV4dF1cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb250ZXh0RGlyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIG1ha2VVbmxpbmtGbih2bSwgZGlycywgY29udGV4dCwgY29udGV4dERpcnMpIHtcbiAgZnVuY3Rpb24gdW5saW5rKGRlc3Ryb3lpbmcpIHtcbiAgICB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpO1xuICAgIH1cbiAgfVxuICAvLyBleHBvc2UgbGlua2VkIGRpcmVjdGl2ZXNcbiAgdW5saW5rLmRpcnMgPSBkaXJzO1xuICByZXR1cm4gdW5saW5rO1xufVxuXG4vKipcbiAqIFRlYXJkb3duIHBhcnRpYWwgbGlua2VkIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lpbmdcbiAqL1xuXG5mdW5jdGlvbiB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGRpcnNbaV0uX3RlYXJkb3duKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRlc3Ryb3lpbmcpIHtcbiAgICAgIHZtLl9kaXJlY3RpdmVzLiRyZW1vdmUoZGlyc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBsaW5rIHByb3BzIG9uIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUFuZExpbmtQcm9wcyh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzLCB2bSk7XG4gIHZhciBwcm9wRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9wc0xpbmtGbih2bSwgc2NvcGUpO1xuICB9LCB2bSk7XG4gIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHByb3BEaXJzKTtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSByb290IGVsZW1lbnQgb2YgYW4gaW5zdGFuY2UuXG4gKlxuICogMS4gYXR0cnMgb24gY29udGV4dCBjb250YWluZXIgKGNvbnRleHQgc2NvcGUpXG4gKiAyLiBhdHRycyBvbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlIHJvb3Qgbm9kZSwgaWZcbiAqICAgIHJlcGxhY2U6dHJ1ZSAoY2hpbGQgc2NvcGUpXG4gKlxuICogSWYgdGhpcyBpcyBhIGZyYWdtZW50IGluc3RhbmNlLCB3ZSBvbmx5IG5lZWQgdG8gY29tcGlsZSAxLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVSb290KGVsLCBvcHRpb25zLCBjb250ZXh0T3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyQXR0cnMgPSBvcHRpb25zLl9jb250YWluZXJBdHRycztcbiAgdmFyIHJlcGxhY2VyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzO1xuICB2YXIgY29udGV4dExpbmtGbiwgcmVwbGFjZXJMaW5rRm47XG5cbiAgLy8gb25seSBuZWVkIHRvIGNvbXBpbGUgb3RoZXIgYXR0cmlidXRlcyBmb3JcbiAgLy8gbm9uLWZyYWdtZW50IGluc3RhbmNlc1xuICBpZiAoZWwubm9kZVR5cGUgIT09IDExKSB7XG4gICAgLy8gZm9yIGNvbXBvbmVudHMsIGNvbnRhaW5lciBhbmQgcmVwbGFjZXIgbmVlZCB0byBiZVxuICAgIC8vIGNvbXBpbGVkIHNlcGFyYXRlbHkgYW5kIGxpbmtlZCBpbiBkaWZmZXJlbnQgc2NvcGVzLlxuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgLy8gMi4gY29udGFpbmVyIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChjb250YWluZXJBdHRycyAmJiBjb250ZXh0T3B0aW9ucykge1xuICAgICAgICBjb250ZXh0TGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoY29udGFpbmVyQXR0cnMsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsYWNlckF0dHJzKSB7XG4gICAgICAgIC8vIDMuIHJlcGxhY2VyIGF0dHJpYnV0ZXNcbiAgICAgICAgcmVwbGFjZXJMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhyZXBsYWNlckF0dHJzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWNvbXBvbmVudCwganVzdCBjb21waWxlIGFzIGEgbm9ybWFsIGVsZW1lbnQuXG4gICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbnRhaW5lckF0dHJzKSB7XG4gICAgLy8gd2FybiBjb250YWluZXIgZGlyZWN0aXZlcyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VzXG4gICAgdmFyIG5hbWVzID0gY29udGFpbmVyQXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAvLyBhbGxvdyB2dWUtbG9hZGVyL3Z1ZWlmeSBzY29wZWQgY3NzIGF0dHJpYnV0ZXNcbiAgICAgIHJldHVybiBhdHRyLm5hbWUuaW5kZXhPZignX3YtJykgPCAwICYmXG4gICAgICAvLyBhbGxvdyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICFvblJFLnRlc3QoYXR0ci5uYW1lKSAmJlxuICAgICAgLy8gYWxsb3cgc2xvdHNcbiAgICAgIGF0dHIubmFtZSAhPT0gJ3Nsb3QnO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgcmV0dXJuICdcIicgKyBhdHRyLm5hbWUgKyAnXCInO1xuICAgIH0pO1xuICAgIGlmIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwbHVyYWwgPSBuYW1lcy5sZW5ndGggPiAxO1xuICAgICAgd2FybignQXR0cmlidXRlJyArIChwbHVyYWwgPyAncyAnIDogJyAnKSArIG5hbWVzLmpvaW4oJywgJykgKyAocGx1cmFsID8gJyBhcmUnIDogJyBpcycpICsgJyBpZ25vcmVkIG9uIGNvbXBvbmVudCAnICsgJzwnICsgb3B0aW9ucy5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPiBiZWNhdXNlICcgKyAndGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50IGluc3RhbmNlOiAnICsgJ2h0dHA6Ly92dWVqcy5vcmcvZ3VpZGUvY29tcG9uZW50cy5odG1sI0ZyYWdtZW50LUluc3RhbmNlJyk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvb3RMaW5rRm4odm0sIGVsLCBzY29wZSkge1xuICAgIC8vIGxpbmsgY29udGV4dCBzY29wZSBkaXJzXG4gICAgdmFyIGNvbnRleHQgPSB2bS5fY29udGV4dDtcbiAgICB2YXIgY29udGV4dERpcnM7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dExpbmtGbikge1xuICAgICAgY29udGV4dERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4oY29udGV4dCwgZWwsIG51bGwsIHNjb3BlKTtcbiAgICAgIH0sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIGxpbmsgc2VsZlxuICAgIHZhciBzZWxmRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXBsYWNlckxpbmtGbikgcmVwbGFjZXJMaW5rRm4odm0sIGVsKTtcbiAgICB9LCB2bSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBjb250ZXh0XG4gICAgLy8gY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbiBiYXNlZCBvbiB0aGVcbiAqIG5vZGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICBpZiAodHlwZSA9PT0gMSAmJiAhaXNTY3JpcHQobm9kZSkpIHtcbiAgICByZXR1cm4gY29tcGlsZUVsZW1lbnQobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyAmJiBub2RlLmRhdGEudHJpbSgpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChlbC52YWx1ZSk7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0b2tlbnNUb0V4cCh0b2tlbnMpKTtcbiAgICAgIGVsLnZhbHVlID0gJyc7XG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm47XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgdmFyIGF0dHJzID0gaGFzQXR0cnMgJiYgdG9BcnJheShlbC5hdHRyaWJ1dGVzKTtcbiAgLy8gY2hlY2sgdGVybWluYWwgZGlyZWN0aXZlcyAoZm9yICYgaWYpXG4gIGlmIChoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBhdHRycywgb3B0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgZWxlbWVudCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuKSB7XG4gICAgbGlua0ZuID0gY2hlY2tFbGVtZW50RGlyZWN0aXZlcyhlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgY29tcG9uZW50XG4gIGlmICghbGlua0ZuKSB7XG4gICAgbGlua0ZuID0gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoYXR0cnMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBsaW5rRm47XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHRleHROb2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0ZXh0Tm9kZUxpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgbWFya2VkIHRleHQgbm9kZXNcbiAgaWYgKG5vZGUuX3NraXApIHtcbiAgICByZXR1cm4gcmVtb3ZlVGV4dDtcbiAgfVxuXG4gIHZhciB0b2tlbnMgPSBwYXJzZVRleHQobm9kZS53aG9sZVRleHQpO1xuICBpZiAoIXRva2Vucykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbWFyayBhZGphY2VudCB0ZXh0IG5vZGVzIGFzIHNraXBwZWQsXG4gIC8vIGJlY2F1c2Ugd2UgYXJlIHVzaW5nIG5vZGUud2hvbGVUZXh0IHRvIGNvbXBpbGVcbiAgLy8gYWxsIGFkamFjZW50IHRleHQgbm9kZXMgdG9nZXRoZXIuIFRoaXMgZml4ZXNcbiAgLy8gaXNzdWVzIGluIElFIHdoZXJlIHNvbWV0aW1lcyBpdCBzcGxpdHMgdXAgYSBzaW5nbGVcbiAgLy8gdGV4dCBub2RlIGludG8gbXVsdGlwbGUgb25lcy5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgbmV4dC5fc2tpcCA9IHRydWU7XG4gICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIGVsLCB0b2tlbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgZWwgPSB0b2tlbi50YWcgPyBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTGlua2VyIGZvciBhbiBza2lwcGVkIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVRleHQodm0sIG5vZGUpIHtcbiAgcmVtb3ZlKG5vZGUpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBzaW5nbGUgdGV4dCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NUZXh0VG9rZW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgdmFyIGVsO1xuICBpZiAodG9rZW4ub25lVGltZSkge1xuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpO1xuICAgICAgc2V0VG9rZW5UeXBlKCdodG1sJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIHdpbGwgY2xlYW4gdXAgZW1wdHkgdGV4dE5vZGVzIGR1cmluZ1xuICAgICAgLy8gZnJhZy5jbG9uZU5vZGUodHJ1ZSksIHNvIHdlIGhhdmUgdG8gZ2l2ZSBpdFxuICAgICAgLy8gc29tZXRoaW5nIGhlcmUuLi5cbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKTtcbiAgICAgIHNldFRva2VuVHlwZSgndGV4dCcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRUb2tlblR5cGUodHlwZSkge1xuICAgIGlmICh0b2tlbi5kZXNjcmlwdG9yKSByZXR1cm47XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHRva2VuLnZhbHVlKTtcbiAgICB0b2tlbi5kZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogdHlwZSxcbiAgICAgIGRlZjogZGlyZWN0aXZlc1t0eXBlXSxcbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnNcbiAgICB9O1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgdGV4dE5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRleHROb2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUpIHtcbiAgICB2YXIgZnJhZ0Nsb25lID0gZnJhZy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGZyYWdDbG9uZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgdG9rZW4sIHZhbHVlLCBub2RlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgaWYgKHRva2VuLnRhZykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bSkuJGV2YWwodmFsdWUpO1xuICAgICAgICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICAgICAgICByZXBsYWNlKG5vZGUsIHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm0uX2JpbmREaXIodG9rZW4uZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZWwsIGZyYWdDbG9uZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgbGlzdCBhbmQgcmV0dXJuIGEgY2hpbGRMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZUxpc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGVMaXN0KG5vZGVMaXN0LCBvcHRpb25zKSB7XG4gIHZhciBsaW5rRm5zID0gW107XG4gIHZhciBub2RlTGlua0ZuLCBjaGlsZExpbmtGbiwgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgbm9kZUxpbmtGbiA9IGNvbXBpbGVOb2RlKG5vZGUsIG9wdGlvbnMpO1xuICAgIGNoaWxkTGlua0ZuID0gIShub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwpICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiYgbm9kZS5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3Qobm9kZS5jaGlsZE5vZGVzLCBvcHRpb25zKSA6IG51bGw7XG4gICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKTtcbiAgfVxuICByZXR1cm4gbGlua0Zucy5sZW5ndGggPyBtYWtlQ2hpbGRMaW5rRm4obGlua0ZucykgOiBudWxsO1xufVxuXG4vKipcbiAqIE1ha2UgYSBjaGlsZCBsaW5rIGZ1bmN0aW9uIGZvciBhIG5vZGUncyBjaGlsZE5vZGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSBsaW5rRm5zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gY2hpbGRMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlQ2hpbGRMaW5rRm4obGlua0Zucykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hpbGRMaW5rRm4odm0sIG5vZGVzLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHZhciBub2RlLCBub2RlTGlua0ZuLCBjaGlsZHJlbkxpbmtGbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGwgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGw7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dO1xuICAgICAgbm9kZUxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgIGNoaWxkcmVuTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgIGlmIChub2RlTGlua0ZuKSB7XG4gICAgICAgIG5vZGVMaW5rRm4odm0sIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbkxpbmtGbikge1xuICAgICAgICBjaGlsZHJlbkxpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgZWxlbWVudCBkaXJlY3RpdmVzIChjdXN0b20gZWxlbWVudHMgdGhhdCBzaG91bGRcbiAqIGJlIHJlc292bGVkIGFzIHRlcm1pbmFsIGRpcmVjdGl2ZXMpLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tFbGVtZW50RGlyZWN0aXZlcyhlbCwgb3B0aW9ucykge1xuICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY29tbW9uVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKTtcbiAgaWYgKGRlZikge1xuICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCB0YWcsICcnLCBvcHRpb25zLCBkZWYpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudC4gSWYgeWVzLCByZXR1cm5cbiAqIGEgY29tcG9uZW50IGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucykge1xuICB2YXIgY29tcG9uZW50ID0gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKTtcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIHZhciByZWYgPSBmaW5kUmVmKGVsKTtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgcmVmOiByZWYsXG4gICAgICBleHByZXNzaW9uOiBjb21wb25lbnQuaWQsXG4gICAgICBkZWY6IGludGVybmFsRGlyZWN0aXZlcy5jb21wb25lbnQsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgbGl0ZXJhbDogIWNvbXBvbmVudC5keW5hbWljXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gY29tcG9uZW50TGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUoKHNjb3BlIHx8IHZtKS4kcmVmcywgcmVmLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfTtcbiAgICBjb21wb25lbnRMaW5rRm4udGVybWluYWwgPSB0cnVlO1xuICAgIHJldHVybiBjb21wb25lbnRMaW5rRm47XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBhbiBlbGVtZW50IGZvciB0ZXJtaW5hbCBkaXJlY3RpdmVzIGluIGZpeGVkIG9yZGVyLlxuICogSWYgaXQgZmluZHMgb25lLCByZXR1cm4gYSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IGF0dHJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbERpcmVjdGl2ZXMoZWwsIGF0dHJzLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgdi1wcmVcbiAgaWYgKGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXA7XG4gIH1cbiAgLy8gc2tpcCB2LWVsc2UgYmxvY2ssIGJ1dCBvbmx5IGlmIGZvbGxvd2luZyB2LWlmXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3YtZWxzZScpKSB7XG4gICAgdmFyIHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChwcmV2ICYmIHByZXYuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgIHJldHVybiBza2lwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBtYXRjaGVkLCBkaXJOYW1lLCByYXdOYW1lLCBhcmcsIGRlZiwgdGVybURlZjtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBhdHRycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgbWF0Y2hlZFsxXSk7XG4gICAgICBpZiAoZGVmICYmIGRlZi50ZXJtaW5hbCkge1xuICAgICAgICBpZiAoIXRlcm1EZWYgfHwgKGRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1RFUk1JTkFMX1BSSU9SSVRZKSA+IHRlcm1EZWYucHJpb3JpdHkpIHtcbiAgICAgICAgICB0ZXJtRGVmID0gZGVmO1xuICAgICAgICAgIHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMoYXR0ci5uYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgZGlyTmFtZSA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgYXJnID0gbWF0Y2hlZFsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXJtRGVmKSB7XG4gICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCB0ZXJtRGVmLCByYXdOYW1lLCBhcmcsIG1vZGlmaWVycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcCgpIHt9XG5za2lwLnRlcm1pbmFsID0gdHJ1ZTtcblxuLyoqXG4gKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gKiBBIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24gdGVybWluYXRlcyB0aGUgY3VycmVudFxuICogY29tcGlsYXRpb24gcmVjdXJzaW9uIGFuZCBoYW5kbGVzIGNvbXBpbGF0aW9uIG9mIHRoZVxuICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Jhd05hbWVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2FyZ11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbW9kaWZpZXJzXVxuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMsIGRlZiwgcmF3TmFtZSwgYXJnLCBtb2RpZmllcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgbmFtZTogZGlyTmFtZSxcbiAgICBhcmc6IGFyZyxcbiAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVycyxcbiAgICByYXc6IHZhbHVlLFxuICAgIGF0dHI6IHJhd05hbWUsXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgZGVmOiBkZWZcbiAgfTtcbiAgLy8gY2hlY2sgcmVmIGZvciB2LWZvciBhbmQgcm91dGVyLXZpZXdcbiAgaWYgKGRpck5hbWUgPT09ICdmb3InIHx8IGRpck5hbWUgPT09ICdyb3V0ZXItdmlldycpIHtcbiAgICBkZXNjcmlwdG9yLnJlZiA9IGZpbmRSZWYoZWwpO1xuICB9XG4gIHZhciBmbiA9IGZ1bmN0aW9uIHRlcm1pbmFsTm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IucmVmKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCBkZXNjcmlwdG9yLnJlZiwgbnVsbCk7XG4gICAgfVxuICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG4gIGZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKSB7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgZGlycyA9IFtdO1xuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIHJhd05hbWUsIHJhd1ZhbHVlLCBkaXJOYW1lLCBhcmcsIG1vZGlmaWVycywgZGlyRGVmLCB0b2tlbnMsIG1hdGNoZWQ7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFsdWUgPSByYXdWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgdG9rZW5zID0gcGFyc2VUZXh0KHZhbHVlKTtcbiAgICAvLyByZXNldCBhcmdcbiAgICBhcmcgPSBudWxsO1xuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuXG4gICAgLy8gYXR0cmlidXRlIGludGVycG9sYXRpb25zXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgdmFsdWUgPSB0b2tlbnNUb0V4cCh0b2tlbnMpO1xuICAgICAgYXJnID0gbmFtZTtcbiAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQsIHRva2Vucyk7XG4gICAgICAvLyB3YXJuIGFnYWluc3QgbWl4aW5nIG11c3RhY2hlcyB3aXRoIHYtYmluZFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5uYW1lID09PSAnOmNsYXNzJyB8fCBhdHRyLm5hbWUgPT09ICd2LWJpbmQ6Y2xhc3MnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdhcm4oJ2NsYXNzPVwiJyArIHJhd1ZhbHVlICsgJ1wiOiBEbyBub3QgbWl4IG11c3RhY2hlIGludGVycG9sYXRpb24gJyArICdhbmQgdi1iaW5kIGZvciBcImNsYXNzXCIgb24gdGhlIHNhbWUgZWxlbWVudC4gVXNlIG9uZSBvciB0aGUgb3RoZXIuJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICAgIGlmICh0cmFuc2l0aW9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICBtb2RpZmllcnMubGl0ZXJhbCA9ICFiaW5kUkUudGVzdChuYW1lKTtcbiAgICAgICAgcHVzaERpcigndHJhbnNpdGlvbicsIGludGVybmFsRGlyZWN0aXZlcy50cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBhcmcgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIHB1c2hEaXIoJ29uJywgZGlyZWN0aXZlcy5vbik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGJpbmRpbmdzXG4gICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBkaXJOYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcmcgPSBkaXJOYW1lO1xuICAgICAgICAgICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID0gbmFtZS5tYXRjaChkaXJBdHRyUkUpKSB7XG4gICAgICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgICBhcmcgPSBtYXRjaGVkWzJdO1xuXG4gICAgICAgICAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAoZGlyRGVmKSB7XG4gICAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBkaXJEZWYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGRlZlxuICAgKiBAcGFyYW0ge0FycmF5fSBbaW50ZXJwVG9rZW5zXVxuICAgKi9cblxuICBmdW5jdGlvbiBwdXNoRGlyKGRpck5hbWUsIGRlZiwgaW50ZXJwVG9rZW5zKSB7XG4gICAgdmFyIGhhc09uZVRpbWVUb2tlbiA9IGludGVycFRva2VucyAmJiBoYXNPbmVUaW1lKGludGVycFRva2Vucyk7XG4gICAgdmFyIHBhcnNlZCA9ICFoYXNPbmVUaW1lVG9rZW4gJiYgcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAvLyBjb252ZXJzaW9uIGZyb20gaW50ZXJwb2xhdGlvbiBzdHJpbmdzIHdpdGggb25lLXRpbWUgdG9rZW5cbiAgICAgIC8vIHRvIGV4cHJlc3Npb24gaXMgZGlmZmVyZWQgdW50aWwgZGlyZWN0aXZlIGJpbmQgdGltZSBzbyB0aGF0IHdlXG4gICAgICAvLyBoYXZlIGFjY2VzcyB0byB0aGUgYWN0dWFsIHZtIGNvbnRleHQgZm9yIG9uZS10aW1lIGJpbmRpbmdzLlxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkICYmIHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBUb2tlbnMsXG4gICAgICBoYXNPbmVUaW1lOiBoYXNPbmVUaW1lVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkaXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBtYWtlTm9kZUxpbmtGbihkaXJzKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIG1vZGlmaWVycyBmcm9tIGRpcmVjdGl2ZSBhdHRyaWJ1dGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlc1ttYXRjaFtpXS5zbGljZSgxKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuKGRpcmVjdGl2ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIHJldmVyc2UgYXBwbHkgYmVjYXVzZSBpdCdzIHNvcnRlZCBsb3cgdG8gaGlnaFxuICAgIHZhciBpID0gZGlyZWN0aXZlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX2JpbmREaXIoZGlyZWN0aXZlc1tpXSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gaW50ZXJwb2xhdGlvbiBzdHJpbmcgY29udGFpbnMgb25lLXRpbWUgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPbmVUaW1lKHRva2Vucykge1xuICB2YXIgaSA9IHRva2Vucy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodG9rZW5zW2ldLm9uZVRpbWUpIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2NyaXB0KGVsKSB7XG4gIHJldHVybiBlbC50YWdOYW1lID09PSAnU0NSSVBUJyAmJiAoIWVsLmhhc0F0dHJpYnV0ZSgndHlwZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAndGV4dC9qYXZhc2NyaXB0Jyk7XG59XG5cbnZhciBzcGVjaWFsQ2hhclJFID0gL1teXFx3XFwtOlxcLl0vO1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZShlbCwgb3B0aW9ucykge1xuICAvLyBleHRyYWN0IGNvbnRhaW5lciBhdHRyaWJ1dGVzIHRvIHBhc3MgdGhlbSBkb3duXG4gIC8vIHRvIGNvbXBpbGVyLCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSBjb21waWxlZCBpblxuICAvLyBwYXJlbnQgc2NvcGUuIHdlIGFyZSBtdXRhdGluZyB0aGUgb3B0aW9ucyBvYmplY3QgaGVyZVxuICAvLyBhc3N1bWluZyB0aGUgc2FtZSBvYmplY3Qgd2lsbCBiZSB1c2VkIGZvciBjb21waWxlXG4gIC8vIHJpZ2h0IGFmdGVyIHRoaXMuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBleHRyYWN0QXR0cnMoZWwpO1xuICB9XG4gIC8vIGZvciB0ZW1wbGF0ZSB0YWdzLCB3aGF0IHdlIHdhbnQgaXMgaXRzIGNvbnRlbnQgYXNcbiAgLy8gYSBkb2N1bWVudEZyYWdtZW50IChmb3IgZnJhZ21lbnQgaW5zdGFuY2VzKVxuICBpZiAoaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHBhcnNlVGVtcGxhdGUoZWwpO1xuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy5fY29udGVudCA9IGV4dHJhY3RDb250ZW50KGVsKTtcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnJhZ21lbnQoZWwpKSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgcHJlcGVuZChjcmVhdGVBbmNob3IoJ3Ytc3RhcnQnLCB0cnVlKSwgZWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZUFuY2hvcigndi1lbmQnLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKTtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHRhZyA9IHJlcGxhY2VyLnRhZ05hbWUgJiYgcmVwbGFjZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArICc8Ym9keT4uIFRoaXMgd2lsbCByZXBsYWNlIDxib2R5PiBlbnRpcmVseS4gWW91ICcgKyAnc2hvdWxkIHByb2JhYmx5IHVzZSBgcmVwbGFjZTogZmFsc2VgIGhlcmUuJyk7XG4gICAgICB9XG4gICAgICAvLyB0aGVyZSBhcmUgbWFueSBjYXNlcyB3aGVyZSB0aGUgaW5zdGFuY2UgbXVzdFxuICAgICAgLy8gYmVjb21lIGEgZnJhZ21lbnQgaW5zdGFuY2U6IGJhc2ljYWxseSBhbnl0aGluZyB0aGF0XG4gICAgICAvLyBjYW4gY3JlYXRlIG1vcmUgdGhhbiAxIHJvb3Qgbm9kZXMuXG4gICAgICBpZiAoXG4gICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgIC8vIG5vbi1lbGVtZW50IHRlbXBsYXRlXG4gICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgLy8gc2luZ2xlIG5lc3RlZCBjb21wb25lbnRcbiAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fCBoYXNCaW5kQXR0cihyZXBsYWNlciwgJ2lzJykgfHxcbiAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKSB8fFxuICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykgfHxcbiAgICAgIC8vIGlmIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBleHRyYWN0QXR0cnMocmVwbGFjZXIpO1xuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcik7XG4gICAgICAgIHJldHVybiByZXBsYWNlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBhIGNvbXBvbmVudCBjb250YWluZXIncyBhdHRyaWJ1dGVzXG4gKiBpbnRvIGEgcGxhaW4gb2JqZWN0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RBdHRycyhlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBvZiB0d28gZWxlbWVudHMsIGFuZCBtYWtlIHN1cmVcbiAqIHRoZSBjbGFzcyBuYW1lcyBhcmUgbWVyZ2VkIHByb3Blcmx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbVxuICogQHBhcmFtIHtFbGVtZW50fSB0b1xuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXR0cnMoZnJvbSwgdG8pIHtcbiAgdmFyIGF0dHJzID0gZnJvbS5hdHRyaWJ1dGVzO1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIG5hbWUsIHZhbHVlO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhcGFyc2VUZXh0KHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZS50cmltKCkpKSB7XG4gICAgICB2YWx1ZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgICBhZGRDbGFzcyh0bywgY2xzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNjYW4gYW5kIGRldGVybWluZSBzbG90IGNvbnRlbnQgZGlzdHJpYnV0aW9uLlxuICogV2UgZG8gdGhpcyBkdXJpbmcgdHJhbnNjbHVzaW9uIGluc3RlYWQgYXQgY29tcGlsZSB0aW1lIHNvIHRoYXRcbiAqIHRoZSBkaXN0cmlidXRpb24gaXMgZGVjb3VwbGVkIGZyb20gdGhlIGNvbXBpbGF0aW9uIG9yZGVyIG9mXG4gKiB0aGUgc2xvdHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRlbnRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyh2bSwgY29udGVudCkge1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbnRlbnRzID0gdm0uX3Nsb3RDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBlbCwgbmFtZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGVsID0gY29udGVudC5jaGlsZHJlbltpXTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGlmIChuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCdzbG90JykpIHtcbiAgICAgIChjb250ZW50c1tuYW1lXSB8fCAoY29udGVudHNbbmFtZV0gPSBbXSkpLnB1c2goZWwpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0QmluZEF0dHIoZWwsICdzbG90JykpIHtcbiAgICAgIHdhcm4oJ1RoZSBcInNsb3RcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzdGF0aWMuJywgdm0uJHBhcmVudCk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBjb250ZW50cykge1xuICAgIGNvbnRlbnRzW25hbWVdID0gZXh0cmFjdEZyYWdtZW50KGNvbnRlbnRzW25hbWVdLCBjb250ZW50KTtcbiAgfVxuICBpZiAoY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB2YXIgbm9kZXMgPSBjb250ZW50LmNoaWxkTm9kZXM7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBub2Rlc1swXS5ub2RlVHlwZSA9PT0gMyAmJiAhbm9kZXNbMF0uZGF0YS50cmltKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGVudHNbJ2RlZmF1bHQnXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50LmNoaWxkTm9kZXMsIGNvbnRlbnQpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudChub2RlcywgcGFyZW50KSB7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBub2RlcyA9IHRvQXJyYXkobm9kZXMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKGlzVGVtcGxhdGUobm9kZSkgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gcGFyc2VUZW1wbGF0ZShub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuXG5cbnZhciBjb21waWxlciA9IE9iamVjdC5mcmVlemUoe1xuXHRjb21waWxlOiBjb21waWxlLFxuXHRjb21waWxlQW5kTGlua1Byb3BzOiBjb21waWxlQW5kTGlua1Byb3BzLFxuXHRjb21waWxlUm9vdDogY29tcGlsZVJvb3QsXG5cdHRyYW5zY2x1ZGU6IHRyYW5zY2x1ZGUsXG5cdHJlc29sdmVTbG90czogcmVzb2x2ZVNsb3RzXG59KTtcblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBY2Nlc3NvciBmb3IgYCRkYXRhYCBwcm9wZXJ0eSwgc2luY2Ugc2V0dGluZyAkZGF0YVxuICAgKiByZXF1aXJlcyBvYnNlcnZpbmcgdGhlIG5ldyBvYmplY3QgYW5kIHVwZGF0aW5nXG4gICAqIHByb3hpZWQgcHJvcGVydGllcy5cbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3RGF0YSkge1xuICAgICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fc2V0RGF0YShuZXdEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICAgKiAtIG9ic2VydmVkIGRhdGFcbiAgICogLSBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAqIC0gdXNlciBtZXRob2RzXG4gICAqIC0gbWV0YSBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0UHJvcHMoKTtcbiAgICB0aGlzLl9pbml0TWV0YSgpO1xuICAgIHRoaXMuX2luaXRNZXRob2RzKCk7XG4gICAgdGhpcy5faW5pdERhdGEoKTtcbiAgICB0aGlzLl9pbml0Q29tcHV0ZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwcm9wcy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICB2YXIgZWwgPSBvcHRpb25zLmVsO1xuICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKHByb3BzICYmICFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdQcm9wcyB3aWxsIG5vdCBiZSBjb21waWxlZCBpZiBubyBgZWxgIG9wdGlvbiBpcyAnICsgJ3Byb3ZpZGVkIGF0IGluc3RhbnRpYXRpb24uJywgdGhpcyk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICAgIGVsID0gb3B0aW9ucy5lbCA9IHF1ZXJ5KGVsKTtcbiAgICB0aGlzLl9wcm9wc1VubGlua0ZuID0gZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgcHJvcHNcbiAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgPyBjb21waWxlQW5kTGlua1Byb3BzKHRoaXMsIGVsLCBwcm9wcywgdGhpcy5fc2NvcGUpIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgZGF0YS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFGbiA9IHRoaXMuJG9wdGlvbnMuZGF0YTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEgPSBkYXRhRm4gPyBkYXRhRm4oKSA6IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4nLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIGksIGtleTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vIHRoZXJlIGFyZSB0d28gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbiBwcm94eSBhIGRhdGEga2V5OlxuICAgICAgLy8gMS4gaXQncyBub3QgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcFxuICAgICAgLy8gMi4gaXQncyBwcm92aWRlZCB2aWEgYSBpbnN0YW50aWF0aW9uIG9wdGlvbiBBTkQgdGhlcmUgYXJlIG5vXG4gICAgICAvLyAgICB0ZW1wbGF0ZSBwcm9wIHByZXNlbnRcbiAgICAgIGlmICghcHJvcHMgfHwgIWhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ0RhdGEgZmllbGQgXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgZGVmaW5lZCAnICsgJ2FzIGEgcHJvcC4gVG8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlIGZvciBhIHByb3AsIHVzZSB0aGUgXCJkZWZhdWx0XCIgJyArICdwcm9wIG9wdGlvbjsgaWYgeW91IHdhbnQgdG8gcGFzcyBwcm9wIHZhbHVlcyB0byBhbiBpbnN0YW50aWF0aW9uICcgKyAnY2FsbCwgdXNlIHRoZSBcInByb3BzRGF0YVwiIG9wdGlvbi4nLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgb2JzZXJ2ZShkYXRhLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogU3dhcCB0aGUgaW5zdGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RGF0YVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9zZXREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICBuZXdEYXRhID0gbmV3RGF0YSB8fCB7fTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdGhpcy5fZGF0YSA9IG5ld0RhdGE7XG4gICAgdmFyIGtleXMsIGtleSwgaTtcbiAgICAvLyB1bnByb3h5IGtleXMgbm90IHByZXNlbnQgaW4gbmV3IGRhdGFcbiAgICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIShrZXkgaW4gbmV3RGF0YSkpIHtcbiAgICAgICAgdGhpcy5fdW5wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm94eSBrZXlzIG5vdCBhbHJlYWR5IHByb3hpZWQsXG4gICAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlIGZvciBjaGFuZ2VkIHZhbHVlc1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIG9ic2VydmUobmV3RGF0YSwgdGhpcyk7XG4gICAgdGhpcy5fZGlnZXN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAgICogdm0ucHJvcCA9PT0gdm0uX2RhdGEucHJvcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgZ2V0dGVyL3NldHRlcnMgbWlnaHRcbiAgICAgIC8vIGJlIGNhbGxlZCBieSBjaGlsZCBzY29wZXMgdmlhXG4gICAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdW5wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIHVwZGF0ZSBvbiBldmVyeSB3YXRjaGVyIGluIHNjb3BlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnVwZGF0ZSh0cnVlKTsgLy8gc2hhbGxvdyB1cGRhdGVzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wdXRlZCBwcm9wZXJ0aWVzLiBUaGV5IGFyZSBlc3NlbnRpYWxseVxuICAgKiBzcGVjaWFsIGdldHRlci9zZXR0ZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBWdWUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB0aGlzKTtcbiAgICAgICAgICBkZWYuc2V0ID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gdXNlckRlZi5nZXQgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZSA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdGhpcykgOiBiaW5kKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IG5vb3A7XG4gICAgICAgICAgZGVmLnNldCA9IHVzZXJEZWYuc2V0ID8gYmluZCh1c2VyRGVmLnNldCwgdGhpcykgOiBub29wO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlcihnZXR0ZXIsIG93bmVyKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgaW5zdGFuY2UgbWV0aG9kcy4gTWV0aG9kcyBtdXN0IGJlIGJvdW5kIHRvIHRoZVxuICAgKiBpbnN0YW5jZSBzaW5jZSB0aGV5IG1pZ2h0IGJlIHBhc3NlZCBkb3duIGFzIGEgcHJvcCB0b1xuICAgKiBjaGlsZCBjb21wb25lbnRzLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kcztcbiAgICBpZiAobWV0aG9kcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgdGhpc1trZXldID0gYmluZChtZXRob2RzW2tleV0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBtZXRhIGluZm9ybWF0aW9uIGxpa2UgJGluZGV4LCAka2V5ICYgJHZhbHVlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0YXMgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgIGlmIChtZXRhcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGFzKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsIGtleSwgbWV0YXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvO1xuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgaW5zdGFuY2UncyBvcHRpb24gZXZlbnRzICYgd2F0Y2hlcnMuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgd2UgcHVsbCBpdCBmcm9tIHRoZVxuICAgKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh0aGlzLCBvcHRpb25zLmVsKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyRvbicsIG9wdGlvbnMuZXZlbnRzKTtcbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJHdhdGNoJywgb3B0aW9ucy53YXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHZtLCBlbCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG4gICAgdmFyIG5hbWUsIHZhbHVlLCBoYW5kbGVyO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGlmIChldmVudFJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShldmVudFJFLCAnJyk7XG4gICAgICAgIC8vIGZvcmNlIHRoZSBleHByZXNzaW9uIGludG8gYSBzdGF0ZW1lbnQgc28gdGhhdFxuICAgICAgICAvLyBpdCBhbHdheXMgZHluYW1pY2FsbHkgcmVzb2x2ZXMgdGhlIG1ldGhvZCB0byBjYWxsICgjMjY3MClcbiAgICAgICAgLy8ga2luZGEgdWdseSBoYWNrLCBidXQgZG9lcyB0aGUgam9iLlxuICAgICAgICB2YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgICAgICBpZiAoaXNTaW1wbGVQYXRoKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlICs9ICcuYXBwbHkodGhpcywgJGFyZ3VtZW50cyknO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXIgPSAodm0uX3Njb3BlIHx8IHZtLl9jb250ZXh0KS4kZXZhbCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGhhbmRsZXIuX2Zyb21QYXJlbnQgPSB0cnVlO1xuICAgICAgICB2bS4kb24obmFtZS5yZXBsYWNlKGV2ZW50UkUpLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2tzIGZvciBvcHRpb24gZXZlbnRzIGFuZCB3YXRjaGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja3Modm0sIGFjdGlvbiwgaGFzaCkge1xuICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgIHZhciBoYW5kbGVycywga2V5LCBpLCBqO1xuICAgIGZvciAoa2V5IGluIGhhc2gpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFzaFtrZXldO1xuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2bVthY3Rpb25dKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgdm1bYWN0aW9uXShrZXksIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Vua25vd24gbWV0aG9kOiBcIicgKyBoYW5kbGVyICsgJ1wiIHdoZW4gJyArICdyZWdpc3RlcmluZyBjYWxsYmFjayBmb3IgJyArIGFjdGlvbiArICc6IFwiJyArIGtleSArICdcIi4nLCB2bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIuaGFuZGxlciwgaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHJlY3Vyc2l2ZSBhdHRhY2hlZC9kZXRhY2hlZCBjYWxsc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RE9NSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kb24oJ2hvb2s6YXR0YWNoZWQnLCBvbkF0dGFjaGVkKTtcbiAgICB0aGlzLiRvbignaG9vazpkZXRhY2hlZCcsIG9uRGV0YWNoZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25BdHRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsQXR0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBhdHRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsQXR0YWNoKGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRldGFjaGVkKCkge1xuICAgIGlmICh0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxEZXRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGRldGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxEZXRhY2goY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaG9va1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgdGhpcy4kZW1pdCgncHJlLWhvb2s6JyArIGhvb2spO1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuJG9wdGlvbnNbaG9va107XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSBsaW5rcyBhIERPTSBlbGVtZW50IHdpdGggYSBwaWVjZSBvZiBkYXRhLFxuICogd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24uXG4gKiBJdCByZWdpc3RlcnMgYSB3YXRjaGVyIHdpdGggdGhlIGV4cHJlc3Npb24gYW5kIGNhbGxzXG4gKiB0aGUgRE9NIHVwZGF0ZSBmdW5jdGlvbiB3aGVuIGEgY2hhbmdlIGlzIHRyaWdnZXJlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvclxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gbmFtZVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gZGVmXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXk8T2JqZWN0Pn0gW2ZpbHRlcnNdXG4gKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBbbW9kaWZpZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGFyZ1xuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gcmF3XG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBbcmVmXVxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtpbnRlcnBdXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2hhc09uZVRpbWVdXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGlyZWN0aXZlKGRlc2NyaXB0b3IsIHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB0aGlzLmVsID0gZWw7XG4gIC8vIGNvcHkgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG4gIHRoaXMubmFtZSA9IGRlc2NyaXB0b3IubmFtZTtcbiAgdGhpcy5leHByZXNzaW9uID0gZGVzY3JpcHRvci5leHByZXNzaW9uO1xuICB0aGlzLmFyZyA9IGRlc2NyaXB0b3IuYXJnO1xuICB0aGlzLm1vZGlmaWVycyA9IGRlc2NyaXB0b3IubW9kaWZpZXJzO1xuICB0aGlzLmZpbHRlcnMgPSBkZXNjcmlwdG9yLmZpbHRlcnM7XG4gIHRoaXMubGl0ZXJhbCA9IHRoaXMubW9kaWZpZXJzICYmIHRoaXMubW9kaWZpZXJzLmxpdGVyYWw7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuX2JvdW5kID0gZmFsc2U7XG4gIHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gIC8vIGxpbmsgY29udGV4dFxuICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5fZnJhZyA9IGZyYWc7XG4gIC8vIHN0b3JlIGRpcmVjdGl2ZXMgb24gbm9kZSBpbiBkZXYgbW9kZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgPSB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyB8fCBbXTtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy5wdXNoKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGlyZWN0aXZlLCBtaXhpbiBkZWZpbml0aW9uIHByb3BlcnRpZXMsXG4gKiBzZXR1cCB0aGUgd2F0Y2hlciwgY2FsbCBkZWZpbml0aW9uIGJpbmQoKSBhbmQgdXBkYXRlKClcbiAqIGlmIHByZXNlbnQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuXG4gIC8vIHJlbW92ZSBhdHRyaWJ1dGVcbiAgaWYgKChuYW1lICE9PSAnY2xvYWsnIHx8IHRoaXMudm0uX2lzQ29tcGlsZWQpICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICB2YXIgYXR0ciA9IGRlc2NyaXB0b3IuYXR0ciB8fCAndi0nICsgbmFtZTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8vIGNvcHkgZGVmIHByb3BlcnRpZXNcbiAgdmFyIGRlZiA9IGRlc2NyaXB0b3IuZGVmO1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMudXBkYXRlID0gZGVmO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZCh0aGlzLCBkZWYpO1xuICB9XG5cbiAgLy8gc2V0dXAgZGlyZWN0aXZlIHBhcmFtc1xuICB0aGlzLl9zZXR1cFBhcmFtcygpO1xuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKCk7XG4gIH1cbiAgdGhpcy5fYm91bmQgPSB0cnVlO1xuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdyk7XG4gIH0gZWxzZSBpZiAoKHRoaXMuZXhwcmVzc2lvbiB8fCB0aGlzLm1vZGlmaWVycykgJiYgKHRoaXMudXBkYXRlIHx8IHRoaXMudHdvV2F5KSAmJiAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKSkge1xuICAgIC8vIHdyYXBwZWQgdXBkYXRlciBmb3IgY29udGV4dFxuICAgIHZhciBkaXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlID0gbm9vcCQxO1xuICAgIH1cbiAgICB2YXIgcHJlUHJvY2VzcyA9IHRoaXMuX3ByZVByb2Nlc3MgPyBiaW5kKHRoaXMuX3ByZVByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgcG9zdFByb2Nlc3MgPSB0aGlzLl9wb3N0UHJvY2VzcyA/IGJpbmQodGhpcy5fcG9zdFByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih0aGlzLnZtLCB0aGlzLmV4cHJlc3Npb24sIHRoaXMuX3VwZGF0ZSwgLy8gY2FsbGJhY2tcbiAgICB7XG4gICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICB0d29XYXk6IHRoaXMudHdvV2F5LFxuICAgICAgZGVlcDogdGhpcy5kZWVwLFxuICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgIHBvc3RQcm9jZXNzOiBwb3N0UHJvY2VzcyxcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuICAgIC8vIHYtbW9kZWwgd2l0aCBpbml0YWwgaW5saW5lIHZhbHVlIG5lZWQgdG8gc3luYyBiYWNrIHRvXG4gICAgLy8gbW9kZWwgaW5zdGVhZCBvZiB1cGRhdGUgdG8gRE9NIG9uIGluaXQuIFRoZXkgd291bGRcbiAgICAvLyBzZXQgdGhlIGFmdGVyQmluZCBob29rIHRvIGluZGljYXRlIHRoYXQuXG4gICAgaWYgKHRoaXMuYWZ0ZXJCaW5kKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlKHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAvLyBzd2FwIHRoZSBwYXJhbXMgYXJyYXkgd2l0aCBhIGZyZXNoIG9iamVjdC5cbiAgdGhpcy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGg7XG4gIHZhciBrZXksIHZhbCwgbWFwcGVkS2V5O1xuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0gaHlwaGVuYXRlKHBhcmFtc1tpXSk7XG4gICAgbWFwcGVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICB2YWwgPSBnZXRCaW5kQXR0cih0aGlzLmVsLCBrZXkpO1xuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGF0aWNcbiAgICAgIHZhbCA9IGdldEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGEgd2F0Y2hlciBmb3IgYSBkeW5hbWljIHBhcmFtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbVdhdGNoZXIgPSBmdW5jdGlvbiAoa2V5LCBleHByZXNzaW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdW53YXRjaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kd2F0Y2goZXhwcmVzc2lvbiwgZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgc2VsZi5wYXJhbXNba2V5XSA9IHZhbDtcbiAgICAvLyBzaW5jZSB3ZSBhcmUgaW4gaW1tZWRpYXRlIG1vZGUsXG4gICAgLy8gb25seSBjYWxsIHRoZSBwYXJhbSBjaGFuZ2UgY2FsbGJhY2tzIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5wYXJhbVdhdGNoZXJzICYmIHNlbGYucGFyYW1XYXRjaGVyc1trZXldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB1c2VyOiBmYWxzZVxuICB9KTsodGhpcy5fcGFyYW1VbndhdGNoRm5zIHx8ICh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgPSBbXSkpLnB1c2godW53YXRjaCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgaWYgKGV4cHJlc3Npb24gJiYgdGhpcy5hY2NlcHRTdGF0ZW1lbnQgJiYgIWlzU2ltcGxlUGF0aChleHByZXNzaW9uKSkge1xuICAgIHZhciBmbiA9IHBhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKS5nZXQ7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5fc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZTtcbiAgICAgIGZuLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICBoYW5kbGVyID0gc2NvcGUuX2FwcGx5RmlsdGVycyhoYW5kbGVyLCBudWxsLCB0aGlzLmZpbHRlcnMpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oJ0RpcmVjdGl2ZS5zZXQoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB0d29XYXknICsgJ2RpcmVjdGl2ZXMuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdoaWxlIHByZXZlbnRpbmcgdGhhdCBmdW5jdGlvbiBmcm9tXG4gKiB0cmlnZ2VyaW5nIHVwZGF0ZXMgb24gdGhpcyBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl93aXRoTG9jayA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX2xvY2tlZCA9IHRydWU7XG4gIGZuLmNhbGwoc2VsZik7XG4gIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICBvbih0aGlzLmVsLCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7KHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0gW10pKS5wdXNoKFtldmVudCwgaGFuZGxlcl0pO1xufTtcblxuLyoqXG4gKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZCkge1xuICAgIHRoaXMuX2JvdW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudW5iaW5kKSB7XG4gICAgICB0aGlzLnVuYmluZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2F0Y2hlcikge1xuICAgICAgdGhpcy5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIHZhciBpO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBvZmYodGhpcy5lbCwgbGlzdGVuZXJzW2ldWzBdLCBsaXN0ZW5lcnNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW53YXRjaEZucyA9IHRoaXMuX3BhcmFtVW53YXRjaEZucztcbiAgICBpZiAodW53YXRjaEZucykge1xuICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1bndhdGNoRm5zW2ldKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFVwZGF0ZSB2LXJlZiBmb3IgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl91cGRhdGVSZWYgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuX3JlZjtcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0KS4kcmVmcztcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgaWYgKHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNbcmVmXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2NsdWRlLCBjb21waWxlIGFuZCBsaW5rIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGEgcHJlLWNvbXBpbGVkIGxpbmtlciBpcyBhdmFpbGFibGUsIHRoYXQgbWVhbnMgdGhlXG4gICAqIHBhc3NlZCBpbiBlbGVtZW50IHdpbGwgYmUgcHJlLXRyYW5zY2x1ZGVkIGFuZCBjb21waWxlZFxuICAgKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICAgKlxuICAgKiBPdGhlcndpc2Ugd2UgbmVlZCB0byBjYWxsIHRyYW5zY2x1ZGUvY29tcGlsZS9saW5rIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcblxuICAgIC8vIHRyYW5zY2x1ZGUgYW5kIGluaXQgZWxlbWVudFxuICAgIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgcmVmZXJlbmNlOyB0aGlzIHN0ZXAgYWxzbyBpbmplY3RzXG4gICAgLy8gdGhlIHRlbXBsYXRlIGFuZCBjYWNoZXMgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsID0gZWw7XG4gICAgZWwgPSB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pbml0RWxlbWVudChlbCk7XG5cbiAgICAvLyBoYW5kbGUgdi1wcmUgb24gcm9vdCBub2RlICgjMjAyNilcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByb290IGlzIGFsd2F5cyBjb21waWxlZCBwZXItaW5zdGFuY2UsIGJlY2F1c2VcbiAgICAvLyBjb250YWluZXIgYXR0cnMgYW5kIHByb3BzIGNhbiBiZSBkaWZmZXJlbnQgZXZlcnkgdGltZS5cbiAgICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnM7XG4gICAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgLy8gcmVzb2x2ZSBzbG90IGRpc3RyaWJ1dGlvblxuICAgIHJlc29sdmVTbG90cyh0aGlzLCBvcHRpb25zLl9jb250ZW50KTtcblxuICAgIC8vIGNvbXBpbGUgYW5kIGxpbmsgdGhlIHJlc3RcbiAgICB2YXIgY29udGVudExpbmtGbjtcbiAgICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgLy8gY29tcG9uZW50IGNvbXBpbGF0aW9uIGNhbiBiZSBjYWNoZWRcbiAgICAvLyBhcyBsb25nIGFzIGl0J3Mgbm90IHVzaW5nIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChvcHRpb25zLl9saW5rZXJDYWNoYWJsZSkge1xuICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyO1xuICAgICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlciA9IGNvbXBpbGUoZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpbmsgcGhhc2VcbiAgICAvLyBtYWtlIHN1cmUgdG8gbGluayByb290IHdpdGggcHJvcCBzY29wZSFcbiAgICB2YXIgcm9vdFVubGlua0ZuID0gcm9vdExpbmtlcih0aGlzLCBlbCwgdGhpcy5fc2NvcGUpO1xuICAgIHZhciBjb250ZW50VW5saW5rRm4gPSBjb250ZW50TGlua0ZuID8gY29udGVudExpbmtGbih0aGlzLCBlbCkgOiBjb21waWxlKGVsLCBvcHRpb25zKSh0aGlzLCBlbCk7XG5cbiAgICAvLyByZWdpc3RlciBjb21wb3NpdGUgdW5saW5rIGZ1bmN0aW9uXG4gICAgLy8gdG8gYmUgY2FsbGVkIGR1cmluZyBpbnN0YW5jZSBkZXN0cnVjdGlvblxuICAgIHRoaXMuX3VubGlua0ZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcm9vdFVubGlua0ZuKCk7XG4gICAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgICAgLy8gc3BsaWNpbmcgdGhlIGRpcmVjdGl2ZXNcbiAgICAgIGNvbnRlbnRVbmxpbmtGbih0cnVlKTtcbiAgICB9O1xuXG4gICAgLy8gZmluYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgcmVwbGFjZShvcmlnaW5hbCwgZWwpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQ29tcGlsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdjb21waWxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gICAqICRtb3VudCgpIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgICAgdGhpcy5faXNGcmFnbWVudCA9IHRydWU7XG4gICAgICB0aGlzLiRlbCA9IHRoaXMuX2ZyYWdtZW50U3RhcnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgdGhpcy5fZnJhZ21lbnRFbmQgPSBlbC5sYXN0Q2hpbGQ7XG4gICAgICAvLyBzZXQgcGVyc2lzdGVkIHRleHQgYW5jaG9ycyB0byBlbXB0eVxuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRTdGFydC5kYXRhID0gdGhpcy5fZnJhZ21lbnRFbmQuZGF0YSA9ICcnO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnJhZ21lbnQgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwgPSBlbDtcbiAgICB9XG4gICAgdGhpcy4kZWwuX192dWVfXyA9IHRoaXM7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZUNvbXBpbGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBiaW5kIGEgZGlyZWN0aXZlIHRvIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gcGFyc2VkIGRpcmVjdGl2ZSBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgIC0gdGFyZ2V0IG5vZGVcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2JpbmREaXIgPSBmdW5jdGlvbiAoZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB0aGlzLl9kaXJlY3RpdmVzLnB1c2gobmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFyZG93biBhbiBpbnN0YW5jZSwgdW5vYnNlcnZlcyB0aGUgZGF0YSwgdW5iaW5kIGFsbCB0aGVcbiAgICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgLSB3aGV0aGVyIHRvIHJlbW92ZSB0aGUgRE9NIG5vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZCBsYXRlclxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVzdHJveVJlYWR5O1xuICAgIHZhciBwZW5kaW5nUmVtb3ZhbDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDbGVhbnVwIHNob3VsZCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3lzbHkgYXNcbiAgICAvLyBjYWxsYmFjayBvZiB0aGlzLiRyZW1vdmUoKSwgb3IgaWYgcmVtb3ZlIGFuZCBkZWZlckNsZWFudXAgYXJlIGZhbHNlLlxuICAgIC8vIEluIGFueSBjYXNlIGl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG90aGVyIHJlbW92aW5nLCB1bmJpbmRpbmcgYW5kXG4gICAgLy8gdHVybmluZyBvZiBpcyBkb25lXG4gICAgdmFyIGNsZWFudXBJZlBvc3NpYmxlID0gZnVuY3Rpb24gY2xlYW51cElmUG9zc2libGUoKSB7XG4gICAgICBpZiAoZGVzdHJveVJlYWR5ICYmICFwZW5kaW5nUmVtb3ZhbCAmJiAhZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIERPTSBlbGVtZW50XG4gICAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgICAgcGVuZGluZ1JlbW92YWwgPSB0cnVlO1xuICAgICAgdGhpcy4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZ1JlbW92YWwgPSBmYWxzZTtcbiAgICAgICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQuIG9ubHkgbmVjZXNzYXJ5XG4gICAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcGFyZW50LiRjaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgLy8gdW5yZWdpc3RlciByZWYgKHJlbW92ZTogdHJ1ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICB9XG4gICAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gICAgaSA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLiRjaGlsZHJlbltpXS4kZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBwcm9wc1xuICAgIGlmICh0aGlzLl9wcm9wc1VubGlua0ZuKSB7XG4gICAgICB0aGlzLl9wcm9wc1VubGlua0ZuKCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAgIC8vIGRpcmVjdGl2ZS1vd25lZCB3YXRjaGVycy5cbiAgICBpZiAodGhpcy5fdW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3VubGlua0ZuKCk7XG4gICAgfVxuICAgIGkgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgdGhpcy4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveVJlYWR5ID0gdHJ1ZTtcbiAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0byBlbnN1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICAgKiBpcyBhbnkuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gb3duZXIgZnJhZ21lbnRcbiAgICAvLyBkbyBpdCBpbiBjbGVhbnVwIHNvIHRoYXQgd2UgY2FuIGNhbGwgJGRlc3Ryb3kgd2l0aFxuICAgIC8vIGRlZmVyIHJpZ2h0IHdoZW4gYSBmcmFnbWVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICAgIHRoaXMuX2RhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCByZWZlcmVuY2VzIHRvIHByaXZhdGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAvLyBpbnN0YW5jZXMuIHByZXNlcnZlIHJlZmVyZW5jZSB0byBfZGF0YSBzbyB0aGF0IHByb3h5XG4gICAgLy8gYWNjZXNzb3JzIHN0aWxsIHdvcmsuIFRoZSBvbmx5IHBvdGVudGlhbCBzaWRlIGVmZmVjdFxuICAgIC8vIGhlcmUgaXMgdGhhdCBtdXRhdGluZyB0aGUgaW5zdGFuY2UgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcbiAgICAvLyBtYXkgYWZmZWN0IHRoZSBzdGF0ZSBvZiBvdGhlciBjb21wb25lbnRzIHRoYXQgYXJlIHN0aWxsXG4gICAgLy8gb2JzZXJ2aW5nIHRoZSBzYW1lIG9iamVjdCwgYnV0IHRoYXQgc2VlbXMgdG8gYmUgYVxuICAgIC8vIHJlYXNvbmFibGUgcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB1c2VyIHJhdGhlciB0aGFuXG4gICAgLy8gYWx3YXlzIHRocm93aW5nIGFuIGVycm9yIG9uIHRoZW0uXG4gICAgdGhpcy4kZWwgPSB0aGlzLiRwYXJlbnQgPSB0aGlzLiRyb290ID0gdGhpcy4kY2hpbGRyZW4gPSB0aGlzLl93YXRjaGVycyA9IHRoaXMuX2NvbnRleHQgPSB0aGlzLl9zY29wZSA9IHRoaXMuX2RpcmVjdGl2ZXMgPSBudWxsO1xuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHRoaXMuX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB0aGlzLiRvZmYoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWlzY01peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIEFwcGx5IGEgbGlzdCBvZiBmaWx0ZXIgKGRlc2NyaXB0b3JzKSB0byBhIHZhbHVlLlxuICAgKiBVc2luZyBwbGFpbiBmb3IgbG9vcHMgaGVyZSBiZWNhdXNlIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW5cbiAgICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICAgKiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBbb2xkVmFsdWVdXG4gICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnNcbiAgICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICAgIHZhciBmaWx0ZXIsIGZuLCBhcmdzLCBhcmcsIG9mZnNldCwgaSwgbCwgaiwgaztcbiAgICBmb3IgKGkgPSAwLCBsID0gZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlcnNbd3JpdGUgPyBsIC0gaSAtIDEgOiBpXTtcbiAgICAgIGZuID0gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyLm5hbWUsIHRydWUpO1xuICAgICAgaWYgKCFmbikgY29udGludWU7XG4gICAgICBmbiA9IHdyaXRlID8gZm4ud3JpdGUgOiBmbi5yZWFkIHx8IGZuO1xuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICBhcmdzID0gd3JpdGUgPyBbdmFsdWUsIG9sZFZhbHVlXSA6IFt2YWx1ZV07XG4gICAgICBvZmZzZXQgPSB3cml0ZSA/IDIgOiAxO1xuICAgICAgaWYgKGZpbHRlci5hcmdzKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGsgPSBmaWx0ZXIuYXJncy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXTtcbiAgICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWMgPyB0aGlzLiRnZXQoYXJnLnZhbHVlKSA6IGFyZy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgY29tcG9uZW50LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgY29tcG9uZW50XG4gICAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICogUmVzb2x2ZXMgc3luY2hyb25vdXNseSBpZiBhbHJlYWR5IHJlc29sdmVkLCBvdGhlcndpc2VcbiAgICogcmVzb2x2ZXMgYXN5bmNocm9ub3VzbHkgYW5kIGNhY2hlcyB0aGUgcmVzb2x2ZWRcbiAgICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9yZXNvbHZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBjYikge1xuICAgIHZhciBmYWN0b3J5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZhY3RvcnkgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFjdG9yeSA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnY29tcG9uZW50cycsIHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5XG4gICAgaWYgKCFmYWN0b3J5Lm9wdGlvbnMpIHtcbiAgICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAgIC8vIGNhY2hlZFxuICAgICAgICBjYihmYWN0b3J5LnJlc29sdmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICAgICAgZmFjdG9yeS5jYWxsKHRoaXMsIGZ1bmN0aW9uIHJlc29sdmUocmVzKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gVnVlLmV4dGVuZChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnOiAnICsgdmFsdWUgOiAnJykgKyAnLiAnICsgKHJlYXNvbiA/ICdcXG5SZWFzb246ICcgKyByZWFzb24gOiAnJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIGNvbXBvbmVudFxuICAgICAgY2IoZmFjdG9yeSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgZmlsdGVyUkUkMSA9IC9bXnxdXFx8W158XS87XG5cbmZ1bmN0aW9uIGRhdGFBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKGV4cCwgYXNTdGF0ZW1lbnQpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKGFzU3RhdGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlbWVudEhhbmRsZXIoKSB7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXMuZ2V0LmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVzLmdldC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICogVGhlIGV4cHJlc3Npb24gbXVzdCBiZSBhIHZhbGlkIGxlZnQtaGFuZFxuICAgKiBleHByZXNzaW9uIGluIGFuIGFzc2lnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gZnVuY3Rpb24gKGV4cCwgdmFsKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHAsIHRydWUpO1xuICAgIGlmIChyZXMgJiYgcmVzLnNldCkge1xuICAgICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBvbiB0aGUgVk1cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsKHRoaXMuX2RhdGEsIGtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhdGNoIGFuIGV4cHJlc3Npb24sIHRyaWdnZXIgY2FsbGJhY2sgd2hlbiBpdHNcbiAgICogdmFsdWUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gaW1tZWRpYXRlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZShleHBPckZuKTtcbiAgICAgIGV4cE9yRm4gPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICAgIGRlZXA6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWVwLFxuICAgICAgc3luYzogb3B0aW9ucyAmJiBvcHRpb25zLnN5bmMsXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICB1c2VyOiAhb3B0aW9ucyB8fCBvcHRpb25zLnVzZXIgIT09IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGEgdGV4dCBkaXJlY3RpdmUsIGluY2x1ZGluZyBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRldmFsID0gZnVuY3Rpb24gKHRleHQsIGFzU3RhdGVtZW50KSB7XG4gICAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gICAgaWYgKGZpbHRlclJFJDEudGVzdCh0ZXh0KSkge1xuICAgICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKHRleHQpO1xuICAgICAgLy8gdGhlIGZpbHRlciByZWdleCBjaGVjayBtaWdodCBnaXZlIGZhbHNlIHBvc2l0aXZlXG4gICAgICAvLyBmb3IgcGlwZXMgaW5zaWRlIHN0cmluZ3MsIHNvIGl0J3MgcG9zc2libGUgdGhhdFxuICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICAgIHZhciB2YWwgPSB0aGlzLiRnZXQoZGlyLmV4cHJlc3Npb24sIGFzU3RhdGVtZW50KTtcbiAgICAgIHJldHVybiBkaXIuZmlsdGVycyA/IHRoaXMuX2FwcGx5RmlsdGVycyh2YWwsIG51bGwsIGRpci5maWx0ZXJzKSA6IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmlsdGVyXG4gICAgICByZXR1cm4gdGhpcy4kZ2V0KHRleHQsIGFzU3RhdGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgcGllY2Ugb2YgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dCh0ZXh0KTtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2bS4kZXZhbCh0b2tlbnNbMF0udmFsdWUpICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4udGFnID8gdm0uJGV2YWwodG9rZW4udmFsdWUpIDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBpbnN0YW5jZSBkYXRhIGFzIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyBjb25zb2xlIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRsb2cgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBkYXRhID0gcGF0aCA/IGdldFBhdGgodGhpcy5fZGF0YSwgcGF0aCkgOiB0aGlzLl9kYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhID0gY2xlYW4oZGF0YSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgY29tcHV0ZWQgZmllbGRzXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Byb3BzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogXCJjbGVhblwiIGEgZ2V0dGVyL3NldHRlciBjb252ZXJ0ZWQgb2JqZWN0IGludG8gYSBwbGFpblxuICAgKiBvYmplY3QgY29weS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IC0gb2JqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAgICogYXV0by1ib3VuZCB0byB0aGUgaW5zdGFuY2UsIGFuZCB0aGlzIGF2b2lkcyBjb21wb25lbnRcbiAgICogbW9kdWxlcyBoYXZpbmcgdG8gcmVseSBvbiB0aGUgZ2xvYmFsIFZ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFwcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYXBwZW5kLCBhcHBlbmRXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0LmZpcnN0Q2hpbGQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBiZWZvcmUgdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRiZWZvcmUgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBiZWZvcmVXaXRoQ2IsIGJlZm9yZVdpdGhUcmFuc2l0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGluc3RhbmNlIGFmdGVyIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYWZ0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldC5wYXJlbnROb2RlLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRyZW1vdmUgPSBmdW5jdGlvbiAoY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICB9XG4gICAgdmFyIGluRG9jdW1lbnQgPSB0aGlzLl9pc0F0dGFjaGVkICYmIGluRG9jKHRoaXMuJGVsKTtcbiAgICAvLyBpZiB3ZSBhcmUgbm90IGluIGRvY3VtZW50LCBubyBuZWVkIHRvIGNoZWNrXG4gICAgLy8gZm9yIHRyYW5zaXRpb25zXG4gICAgaWYgKCFpbkRvY3VtZW50KSB3aXRoVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVhbENiID0gZnVuY3Rpb24gcmVhbENiKCkge1xuICAgICAgaWYgKGluRG9jdW1lbnQpIHNlbGYuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgICAgaWYgKGNiKSBjYigpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2lzRnJhZ21lbnQpIHtcbiAgICAgIHJlbW92ZU5vZGVSYW5nZSh0aGlzLl9mcmFnbWVudFN0YXJ0LCB0aGlzLl9mcmFnbWVudEVuZCwgdGhpcywgdGhpcy5fZnJhZ21lbnQsIHJlYWxDYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSA/IHJlbW92ZVdpdGhDYiA6IHJlbW92ZVdpdGhUcmFuc2l0aW9uO1xuICAgICAgb3AodGhpcy4kZWwsIHRoaXMsIHJlYWxDYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaGFyZWQgRE9NIGluc2VydGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMSAtIG9wIGZvciBub24tdHJhbnNpdGlvbiBpbnNlcnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AyIC0gb3AgZm9yIHRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEByZXR1cm4gdm1cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5zZXJ0KHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIHZhciB0YXJnZXRJc0RldGFjaGVkID0gIWluRG9jKHRhcmdldCk7XG4gICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWQgPyBvcDEgOiBvcDI7XG4gICAgdmFyIHNob3VsZENhbGxIb29rID0gIXRhcmdldElzRGV0YWNoZWQgJiYgIXZtLl9pc0F0dGFjaGVkICYmICFpbkRvYyh2bS4kZWwpO1xuICAgIGlmICh2bS5faXNGcmFnbWVudCkge1xuICAgICAgbWFwTm9kZVJhbmdlKHZtLl9mcmFnbWVudFN0YXJ0LCB2bS5fZnJhZ21lbnRFbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG9wKG5vZGUsIHRhcmdldCwgdm0pO1xuICAgICAgfSk7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZENhbGxIb29rKSB7XG4gICAgICB2bS5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3Igc2VsZWN0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKSA6IGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRCZWZvcmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBiZWZvcmVXaXRoQ2IoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVXaXRoQ2IoZWwsIHZtLCBjYikge1xuICAgIHJlbW92ZShlbCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0FQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgKHRoaXMuX2V2ZW50c1tldmVudF0gfHwgKHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgc2VsZi4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBjYnM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtMSk7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvbiBzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHNob3VsZFByb3BhZ2F0ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIHZhciBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBpc1NvdXJjZSB8fCAhY2JzO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGhhY2t5IHNvbHV0aW9uIHRvIHRoZSBxdWVzdGlvbiByYWlzZWRcbiAgICAgIC8vIGluICMyMTAyOiBmb3IgYW4gaW5saW5lIGNvbXBvbmVudCBsaXN0ZW5lciBsaWtlIDxjb21wIEB0ZXN0PVwiZG9UaGlzXCI+LFxuICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhhbmRsaW5nIGlzIHNvbWV3aGF0IGJyb2tlbi4gVGhlcmVmb3JlIHdlXG4gICAgICAvLyBuZWVkIHRvIHRyZWF0IHRoZXNlIGlubGluZSBjYWxsYmFja3MgZGlmZmVyZW50bHkuXG4gICAgICB2YXIgaGFzUGFyZW50Q2JzID0gaXNTb3VyY2UgJiYgY2JzLnNvbWUoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYi5fZnJvbVBhcmVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc1BhcmVudENicykge1xuICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcbiAgICAgICAgdmFyIHJlcyA9IGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzID09PSB0cnVlICYmICghaGFzUGFyZW50Q2JzIHx8IGNiLl9mcm9tUGFyZW50KSkge1xuICAgICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFByb3BhZ2F0ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYnJvYWRjYXN0IGFuIGV2ZW50IHRvIGFsbCBjaGlsZHJlbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gICAgLy8gdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gYnJvYWRjYXN0LlxuICAgIGlmICghdGhpcy5fZXZlbnRzQ291bnRbZXZlbnRdKSByZXR1cm47XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kY2hpbGRyZW47XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzU291cmNlKSB7XG4gICAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgICAgLy8gb24gY2hpbGRyZW5cbiAgICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGNoaWxkLiRlbWl0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIGlmIChzaG91bGRQcm9wYWdhdGUpIHtcbiAgICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBwcm9wYWdhdGUgYW4gZXZlbnQgdXAgdGhlIHBhcmVudCBjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghc2hvdWxkUHJvcGFnYXRlKSByZXR1cm47XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgIC8vIG9uIHBhcmVudHNcbiAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgc2hvdWxkUHJvcGFnYXRlID0gcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICBwYXJlbnQgPSBzaG91bGRQcm9wYWdhdGUgPyBwYXJlbnQuJHBhcmVudCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpc3RlbmVyIGNvdW50cyBvbiBhbGwgcGFyZW50cy5cbiAgICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICAgKiBubyBjaGlsZCBoYXMgbGlzdGVuZWQgdG8gYSBjZXJ0YWluIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICAgKi9cblxuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIGZ1bmN0aW9uIG1vZGlmeUxpc3RlbmVyQ291bnQodm0sIGV2ZW50LCBjb3VudCkge1xuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAgIC8vIHRvIGRvIGJvb2trZWVwaW5nIGZvciB0aGVtXG4gICAgaWYgKCFwYXJlbnQgfHwgIWNvdW50IHx8IGhvb2tSRS50ZXN0KGV2ZW50KSkgcmV0dXJuO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID0gKHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdIHx8IDApICsgY291bnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFNldCBpbnN0YW5jZSB0YXJnZXQgZWxlbWVudCBhbmQga2ljayBvZmYgdGhlIGNvbXBpbGF0aW9uXG4gICAqIHByb2Nlc3MuIFRoZSBwYXNzZWQgaW4gYGVsYCBjYW4gYmUgYSBzZWxlY3RvciBzdHJpbmcsIGFuXG4gICAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gICAqIGluc3RhbmNlcykuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAgICogQHB1YmxpY1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLicsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbCA9IHF1ZXJ5KGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICB0aGlzLl9jb21waWxlKGVsKTtcbiAgICB0aGlzLl9pbml0RE9NSG9va3MoKTtcbiAgICBpZiAoaW5Eb2ModGhpcy4kZWwpKSB7XG4gICAgICB0aGlzLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgIHJlYWR5LmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrIGFuIGluc3RhbmNlIGFzIHJlYWR5LlxuICAgKi9cblxuICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygncmVhZHknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgaW5zdGFuY2UsIHNpbXBseSBkZWxlZ2F0ZSB0byB0aGUgaW50ZXJuYWxcbiAgICogX2Rlc3Ryb3kuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlLCBkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFydGlhbGx5IGNvbXBpbGUgYSBwaWVjZSBvZiBET00gYW5kIHJldHVybiBhXG4gICAqIGRlY29tcGlsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRjb21waWxlID0gZnVuY3Rpb24gKGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHJldHVybiBjb21waWxlKGVsLCB0aGlzLiRvcHRpb25zLCB0cnVlKSh0aGlzLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBleHBvc2VkIFZ1ZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBBUEkgY29udmVudGlvbnM6XG4gKiAtIHB1YmxpYyBBUEkgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGAkYFxuICogLSBpbnRlcm5hbCBtZXRob2RzL3Byb3BlcnRpZXMgYXJlIHByZWZpeGVkIHdpdGggYF9gXG4gKiAtIG5vbi1wcmVmaXhlZCBwcm9wZXJ0aWVzIGFyZSBhc3N1bWVkIHRvIGJlIHByb3hpZWQgdXNlclxuICogICBkYXRhLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFZ1ZShvcHRpb25zKSB7XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbi8vIGluc3RhbGwgaW50ZXJuYWxzXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xubWlzY01peGluKFZ1ZSk7XG5cbi8vIGluc3RhbGwgaW5zdGFuY2UgQVBJc1xuZGF0YUFQSShWdWUpO1xuZG9tQVBJKFZ1ZSk7XG5ldmVudHNBUEkoVnVlKTtcbmxpZmVjeWNsZUFQSShWdWUpO1xuXG52YXIgc2xvdCA9IHtcblxuICBwcmlvcml0eTogU0xPVCxcbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIHRoaXMgd2FzIHJlc29sdmVkIGR1cmluZyBjb21wb25lbnQgdHJhbnNjbHVzaW9uXG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcmFtcy5uYW1lIHx8ICdkZWZhdWx0JztcbiAgICB2YXIgY29udGVudCA9IHRoaXMudm0uX3Nsb3RDb250ZW50cyAmJiB0aGlzLnZtLl9zbG90Q29udGVudHNbbmFtZV07XG4gICAgaWYgKCFjb250ZW50IHx8ICFjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy5mYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBpbGUoY29udGVudC5jbG9uZU5vZGUodHJ1ZSksIHRoaXMudm0uX2NvbnRleHQsIHRoaXMudm0pO1xuICAgIH1cbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKGNvbnRlbnQsIGNvbnRleHQsIGhvc3QpIHtcbiAgICBpZiAoY29udGVudCAmJiBjb250ZXh0KSB7XG4gICAgICBpZiAodGhpcy5lbC5oYXNDaGlsZE5vZGVzKCkgJiYgY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBjb250ZW50LmNoaWxkTm9kZXNbMF0ubm9kZVR5cGUgPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBpbnNlcnRlZCBzbG90IGhhcyB2LWlmXG4gICAgICAgIC8vIGluamVjdCBmYWxsYmFjayBjb250ZW50IGFzIHRoZSB2LWVsc2VcbiAgICAgICAgdmFyIGVsc2VCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGVsc2VCbG9jay5zZXRBdHRyaWJ1dGUoJ3YtZWxzZScsICcnKTtcbiAgICAgICAgZWxzZUJsb2NrLmlubmVySFRNTCA9IHRoaXMuZWwuaW5uZXJIVE1MO1xuICAgICAgICAvLyB0aGUgZWxzZSBibG9jayBzaG91bGQgYmUgY29tcGlsZWQgaW4gY2hpbGQgc2NvcGVcbiAgICAgICAgZWxzZUJsb2NrLl9jb250ZXh0ID0gdGhpcy52bTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbHNlQmxvY2spO1xuICAgICAgfVxuICAgICAgdmFyIHNjb3BlID0gaG9zdCA/IGhvc3QuX3Njb3BlIDogdGhpcy5fc2NvcGU7XG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoY29udGVudCwgaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIH1cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgdGhpcy5jb21waWxlKGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpLCB0aGlzLnZtKTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy51bmxpbmspIHtcbiAgICAgIHRoaXMudW5saW5rKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFydGlhbCA9IHtcblxuICBwcmlvcml0eTogUEFSVElBTCxcblxuICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gIC8vIHdhdGNoIGNoYW5nZXMgdG8gbmFtZSBmb3IgZHluYW1pYyBwYXJ0aWFsc1xuICBwYXJhbVdhdGNoZXJzOiB7XG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZSh2YWx1ZSkge1xuICAgICAgdklmLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1wYXJ0aWFsJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoaWQpIHtcbiAgICB2YXIgcGFydGlhbCA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAncGFydGlhbHMnLCBpZCwgdHJ1ZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbCk7XG4gICAgICB2SWYuaW5zZXJ0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZWxlbWVudERpcmVjdGl2ZXMgPSB7XG4gIHNsb3Q6IHNsb3QsXG4gIHBhcnRpYWw6IHBhcnRpYWxcbn07XG5cbnZhciBjb252ZXJ0QXJyYXkgPSB2Rm9yLl9wb3N0UHJvY2VzcztcblxuLyoqXG4gKiBMaW1pdCBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IChEZWNpbWFsIGV4cGVjdGVkKVxuICovXG5cbmZ1bmN0aW9uIGxpbWl0QnkoYXJyLCBuLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID8gcGFyc2VJbnQob2Zmc2V0LCAxMCkgOiAwO1xuICBuID0gdG9OdW1iZXIobik7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgPyBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKSA6IGFycjtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSAuLi5kYXRhS2V5c1xuICovXG5cbmZ1bmN0aW9uIGZpbHRlckJ5KGFyciwgc2VhcmNoLCBkZWxpbWl0ZXIpIHtcbiAgYXJyID0gY29udmVydEFycmF5KGFycik7XG4gIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihzZWFyY2gpO1xuICB9XG4gIC8vIGNhc3QgdG8gbG93ZXJjYXNlIHN0cmluZ1xuICBzZWFyY2ggPSAoJycgKyBzZWFyY2gpLnRvTG93ZXJDYXNlKCk7XG4gIC8vIGFsbG93IG9wdGlvbmFsIGBpbmAgZGVsaW1pdGVyXG4gIC8vIGJlY2F1c2Ugd2h5IG5vdFxuICB2YXIgbiA9IGRlbGltaXRlciA9PT0gJ2luJyA/IDMgOiAyO1xuICAvLyBleHRyYWN0IGFuZCBmbGF0dGVuIGtleXNcbiAgdmFyIGtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0b0FycmF5KGFyZ3VtZW50cywgbikpO1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpdGVtLCBrZXksIHZhbCwgajtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaXRlbSA9IGFycltpXTtcbiAgICB2YWwgPSBpdGVtICYmIGl0ZW0uJHZhbHVlIHx8IGl0ZW07XG4gICAgaiA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChqKSB7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbal07XG4gICAgICAgIGlmIChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyhpdGVtLiRrZXksIHNlYXJjaCkgfHwgY29udGFpbnMoZ2V0UGF0aCh2YWwsIGtleSksIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXMucHVzaChpdGVtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGFpbnMoaXRlbSwgc2VhcmNoKSkge1xuICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8U3RyaW5nPnxGdW5jdGlvbn0gLi4uc29ydEtleXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3JkZXJdXG4gKi9cblxuZnVuY3Rpb24gb3JkZXJCeShhcnIpIHtcbiAgdmFyIGNvbXBhcmF0b3IgPSBudWxsO1xuICB2YXIgc29ydEtleXMgPSB1bmRlZmluZWQ7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuXG4gIC8vIGRldGVybWluZSBvcmRlciAobGFzdCBhcmd1bWVudClcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gIHZhciBvcmRlciA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicpIHtcbiAgICBvcmRlciA9IG9yZGVyIDwgMCA/IC0xIDogMTtcbiAgICBhcmdzID0gYXJncy5sZW5ndGggPiAxID8gYXJncy5zbGljZSgwLCAtMSkgOiBhcmdzO1xuICB9IGVsc2Uge1xuICAgIG9yZGVyID0gMTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBzb3J0S2V5cyAmIGNvbXBhcmF0b3JcbiAgdmFyIGZpcnN0QXJnID0gYXJnc1swXTtcbiAgaWYgKCFmaXJzdEFyZykge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gY3VzdG9tIGNvbXBhcmF0b3JcbiAgICBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmaXJzdEFyZyhhLCBiKSAqIG9yZGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyaW5nIGtleXMuIGZsYXR0ZW4gZmlyc3RcbiAgICBzb3J0S2V5cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3MpO1xuICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYiwgaSkge1xuICAgICAgaSA9IGkgfHwgMDtcbiAgICAgIHJldHVybiBpID49IHNvcnRLZXlzLmxlbmd0aCAtIDEgPyBiYXNlQ29tcGFyZShhLCBiLCBpKSA6IGJhc2VDb21wYXJlKGEsIGIsIGkpIHx8IGNvbXBhcmF0b3IoYSwgYiwgaSArIDEpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlQ29tcGFyZShhLCBiLCBzb3J0S2V5SW5kZXgpIHtcbiAgICB2YXIgc29ydEtleSA9IHNvcnRLZXlzW3NvcnRLZXlJbmRleF07XG4gICAgaWYgKHNvcnRLZXkpIHtcbiAgICAgIGlmIChzb3J0S2V5ICE9PSAnJGtleScpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICckdmFsdWUnIGluIGEpIGEgPSBhLiR2YWx1ZTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGIpICYmICckdmFsdWUnIGluIGIpIGIgPSBiLiR2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGEgPSBpc09iamVjdChhKSA/IGdldFBhdGgoYSwgc29ydEtleSkgOiBhO1xuICAgICAgYiA9IGlzT2JqZWN0KGIpID8gZ2V0UGF0aChiLCBzb3J0S2V5KSA6IGI7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXI7XG4gIH1cblxuICAvLyBzb3J0IG9uIGEgY29weSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBhcnJheVxuICByZXR1cm4gYXJyLnNsaWNlKCkuc29ydChjb21wYXJhdG9yKTtcbn1cblxuLyoqXG4gKiBTdHJpbmcgY29udGFpbiBoZWxwZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHZhbCwgc2VhcmNoKSB7XG4gIHZhciBpO1xuICBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2ldLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWwudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSA+IC0xO1xuICB9XG59XG5cbnZhciBkaWdpdHNSRSA9IC8oXFxkezN9KSg/PVxcZCkvZztcblxuLy8gYXNzZXQgY29sbGVjdGlvbnMgbXVzdCBiZSBhIHBsYWluIG9iamVjdC5cbnZhciBmaWx0ZXJzID0ge1xuXG4gIG9yZGVyQnk6IG9yZGVyQnksXG4gIGZpbHRlckJ5OiBmaWx0ZXJCeSxcbiAgbGltaXRCeTogbGltaXRCeSxcblxuICAvKipcbiAgICogU3RyaW5naWZ5IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZW50XG4gICAqL1xuXG4gIGpzb246IHtcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKHZhbHVlLCBpbmRlbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBpbmRlbnQgOiAyKTtcbiAgICB9LFxuICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQWJjJ1xuICAgKi9cblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKTtcbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FCQydcbiAgICovXG5cbiAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogJ0FiQycgPT4gJ2FiYydcbiAgICovXG5cbiAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogMTIzNDUgPT4gJDEyLDM0NS4wMFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnblxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbHMgRGVjaW1hbCBwbGFjZXNcbiAgICovXG5cbiAgY3VycmVuY3k6IGZ1bmN0aW9uIGN1cnJlbmN5KHZhbHVlLCBfY3VycmVuY3ksIGRlY2ltYWxzKSB7XG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCAhdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICBfY3VycmVuY3kgPSBfY3VycmVuY3kgIT0gbnVsbCA/IF9jdXJyZW5jeSA6ICckJztcbiAgICBkZWNpbWFscyA9IGRlY2ltYWxzICE9IG51bGwgPyBkZWNpbWFscyA6IDI7XG4gICAgdmFyIHN0cmluZ2lmaWVkID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoZGVjaW1hbHMpO1xuICAgIHZhciBfaW50ID0gZGVjaW1hbHMgPyBzdHJpbmdpZmllZC5zbGljZSgwLCAtMSAtIGRlY2ltYWxzKSA6IHN0cmluZ2lmaWVkO1xuICAgIHZhciBpID0gX2ludC5sZW5ndGggJSAzO1xuICAgIHZhciBoZWFkID0gaSA+IDAgPyBfaW50LnNsaWNlKDAsIGkpICsgKF9pbnQubGVuZ3RoID4gMyA/ICcsJyA6ICcnKSA6ICcnO1xuICAgIHZhciBfZmxvYXQgPSBkZWNpbWFscyA/IHN0cmluZ2lmaWVkLnNsaWNlKC0xIC0gZGVjaW1hbHMpIDogJyc7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICByZXR1cm4gc2lnbiArIF9jdXJyZW5jeSArIGhlYWQgKyBfaW50LnNsaWNlKGkpLnJlcGxhY2UoZGlnaXRzUkUsICckMSwnKSArIF9mbG9hdDtcbiAgfSxcblxuICAvKipcbiAgICogJ2l0ZW0nID0+ICdpdGVtcydcbiAgICpcbiAgICogQHBhcmFtc1xuICAgKiAgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb3JyZXNwb25kaW5nIHRvXG4gICAqICB0aGUgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSAuLi4gZm9ybXMgb2YgdGhlIHdvcmQgdG9cbiAgICogIGJlIHBsdXJhbGl6ZWQuIFdoZW4gdGhlIG51bWJlciB0byBiZSBwbHVyYWxpemVkXG4gICAqICBleGNlZWRzIHRoZSBsZW5ndGggb2YgdGhlIGFyZ3MsIGl0IHdpbGwgdXNlIHRoZSBsYXN0XG4gICAqICBlbnRyeSBpbiB0aGUgYXJyYXkuXG4gICAqXG4gICAqICBlLmcuIFsnc2luZ2xlJywgJ2RvdWJsZScsICd0cmlwbGUnLCAnbXVsdGlwbGUnXVxuICAgKi9cblxuICBwbHVyYWxpemU6IGZ1bmN0aW9uIHBsdXJhbGl6ZSh2YWx1ZSkge1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluZGV4ID0gdmFsdWUgJSAxMCAtIDE7XG4gICAgICByZXR1cm4gaW5kZXggaW4gYXJncyA/IGFyZ3NbaW5kZXhdIDogYXJnc1tsZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWJvdW5jZSBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5ID0gMzAwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoaGFuZGxlciwgZGVsYXkpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICBpZiAoIWRlbGF5KSB7XG4gICAgICBkZWxheSA9IDMwMDtcbiAgICB9XG4gICAgcmV0dXJuIF9kZWJvdW5jZShoYW5kbGVyLCBkZWxheSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluc3RhbGxHbG9iYWxBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICAgKiBhc3NvY2lhdGVkIG9wdGlvbnMgb2JqZWN0LCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgZHVyaW5nXG4gICAqIGNvbXBpbGF0aW9uIHN0ZXBzIGFzIGB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnNgLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgc2VlbiBhcyB0aGUgZGVmYXVsdCBvcHRpb25zIG9mIGV2ZXJ5XG4gICAqIFZ1ZSBpbnN0YW5jZS5cbiAgICovXG5cbiAgVnVlLm9wdGlvbnMgPSB7XG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICBlbGVtZW50RGlyZWN0aXZlczogZWxlbWVudERpcmVjdGl2ZXMsXG4gICAgZmlsdGVyczogZmlsdGVycyxcbiAgICB0cmFuc2l0aW9uczoge30sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgcGFydGlhbHM6IHt9LFxuICAgIHJlcGxhY2U6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogRXhwb3NlIHVzZWZ1bCBpbnRlcm5hbHNcbiAgICovXG5cbiAgVnVlLnV0aWwgPSB1dGlsO1xuICBWdWUuY29uZmlnID0gY29uZmlnO1xuICBWdWUuc2V0ID0gc2V0O1xuICBWdWVbJ2RlbGV0ZSddID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNhZ2UgLyBwbHVnaW5zXG4gICAqL1xuXG4gIFZ1ZS5jb21waWxlciA9IGNvbXBpbGVyO1xuICBWdWUuRnJhZ21lbnRGYWN0b3J5ID0gRnJhZ21lbnRGYWN0b3J5O1xuICBWdWUuaW50ZXJuYWxEaXJlY3RpdmVzID0gaW50ZXJuYWxEaXJlY3RpdmVzO1xuICBWdWUucGFyc2VycyA9IHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHRleHQ6IHRleHQsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGRpcmVjdGl2ZTogZGlyZWN0aXZlLFxuICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgfTtcblxuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuZE9wdGlvbnNcbiAgICovXG5cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgaXNGaXJzdEV4dGVuZCA9IFN1cGVyLmNpZCA9PT0gMDtcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCAmJiBleHRlbmRPcHRpb25zLl9DdG9yKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvcjtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWNhdGVycyBhbmQgdGhlIGh5cGhlbi4nKTtcbiAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBTdWIgPSBjcmVhdGVDbGFzcyhuYW1lIHx8ICdWdWVDb21wb25lbnQnKTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgaWYgKGlzRmlyc3RFeHRlbmQpIHtcbiAgICAgIGV4dGVuZE9wdGlvbnMuX0N0b3IgPSBTdWI7XG4gICAgfVxuICAgIHJldHVybiBTdWI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3ViLWNsYXNzIGNvbnN0cnVjdG9yIHdpdGggdGhlXG4gICAqIGdpdmVuIG5hbWUuIFRoaXMgZ2l2ZXMgdXMgbXVjaCBuaWNlciBvdXRwdXQgd2hlblxuICAgKiBsb2dnaW5nIGluc3RhbmNlcyBpbiB0aGUgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKG5hbWUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyAqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiAnICsgY2xhc3NpZnkobmFtZSkgKyAnIChvcHRpb25zKSB7IHRoaXMuX2luaXQob3B0aW9ucykgfScpKCk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYyAqL1xuICB9XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBzeXN0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblxuICAgKi9cblxuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIGdsb2JhbCBtaXhpbiBieSBtZXJnaW5nIGl0IGludG8gdGhlIGRlZmF1bHRcbiAgICogb3B0aW9ucy5cbiAgICovXG5cbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgVnVlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBzaWduYXR1cmU6XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcGFyYW0geyp9IGRlZmluaXRpb25cbiAgICovXG5cbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiAoY29tbW9uVGFnUkUudGVzdChpZCkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGlkKSkpIHtcbiAgICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBpZiAoIWRlZmluaXRpb24ubmFtZSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmluaXRpb24gPSBWdWUuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBleHBvc2UgaW50ZXJuYWwgdHJhbnNpdGlvbiBBUElcbiAgZXh0ZW5kKFZ1ZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uKTtcbn1cblxuaW5zdGFsbEdsb2JhbEFQSShWdWUpO1xuXG5WdWUudmVyc2lvbiA9ICcxLjAuMjYnO1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5Ccm93c2VyICYmIC9DaHJvbWVcXC9cXGQrLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gICAgfVxuICB9XG59LCAwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWdWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlL2Rpc3QvdnVlLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXHJcbiAqIEtlZW4gVUkgdjAuOC45IChodHRwczovL2dpdGh1Yi5jb20vSm9zZXBodXNQYXllL2tlZW4tdWkpXHJcbiAqIChjKSAyMDE2IEpvc2VwaHVzIFBheWUgSUlcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiS2VlblwiXSA9IGZhY3RvcnkoKTtcclxuXHRlbHNlXHJcblx0XHRyb290W1wiS2VlblwiXSA9IGZhY3RvcnkoKTtcclxufSkodGhpcywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxyXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxyXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2VcclxuLyoqKioqKi8gXHRcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxyXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblx0XHJcblx0dmFyIF9VaUFsZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHRcclxuXHR2YXIgX1VpQWxlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlBbGVydCk7XHJcblx0XHJcblx0dmFyIF9VaUF1dG9jb21wbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xyXG5cdFxyXG5cdHZhciBfVWlBdXRvY29tcGxldGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlBdXRvY29tcGxldGUpO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUJ1dHRvbik7XHJcblx0XHJcblx0dmFyIF9VaUNoZWNrYm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTMpO1xyXG5cdFxyXG5cdHZhciBfVWlDaGVja2JveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUNoZWNrYm94KTtcclxuXHRcclxuXHR2YXIgX1VpQ29sbGFwc2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XHJcblx0XHJcblx0dmFyIF9VaUNvbGxhcHNpYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQ29sbGFwc2libGUpO1xyXG5cdFxyXG5cdHZhciBfVWlDb25maXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpO1xyXG5cdFxyXG5cdHZhciBfVWlDb25maXJtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQ29uZmlybSk7XHJcblx0XHJcblx0dmFyIF9VaUZhYiA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5KTtcclxuXHRcclxuXHR2YXIgX1VpRmFiMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpRmFiKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaU1lbnUpO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnVPcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNZW51T3B0aW9uKTtcclxuXHRcclxuXHR2YXIgX1VpTW9kYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XHJcblx0XHJcblx0dmFyIF9VaU1vZGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTW9kYWwpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQb3BvdmVyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJlbG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMpO1xyXG5cdFxyXG5cdHZhciBfVWlQcmVsb2FkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcmVsb2FkZXIpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0NpcmN1bGFyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NMaW5lYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzTGluZWFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NMaW5lYXIpO1xyXG5cdFxyXG5cdHZhciBfVWlSYWRpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQxKTtcclxuXHRcclxuXHR2YXIgX1VpUmFkaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYWRpbyk7XHJcblx0XHJcblx0dmFyIF9VaVJhZGlvR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NSk7XHJcblx0XHJcblx0dmFyIF9VaVJhZGlvR3JvdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYWRpb0dyb3VwKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDkpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYXRpbmcpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmdJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTIpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmdJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmF0aW5nSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ1ByZXZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Nyk7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ1ByZXZpZXcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYXRpbmdQcmV2aWV3KTtcclxuXHRcclxuXHR2YXIgX1VpUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblx0XHJcblx0dmFyIF9VaVJpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJpcHBsZUluayk7XHJcblx0XHJcblx0dmFyIF9VaVNlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYxKTtcclxuXHRcclxuXHR2YXIgX1VpU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU2VsZWN0KTtcclxuXHRcclxuXHR2YXIgX1VpU2xpZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzIpO1xyXG5cdFxyXG5cdHZhciBfVWlTbGlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTbGlkZXIpO1xyXG5cdFxyXG5cdHZhciBfVWlTbmFja2JhciA9IF9fd2VicGFja19yZXF1aXJlX18oMTg0KTtcclxuXHRcclxuXHR2YXIgX1VpU25hY2tiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTbmFja2Jhcik7XHJcblx0XHJcblx0dmFyIF9VaVNuYWNrYmFyQ29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODgpO1xyXG5cdFxyXG5cdHZhciBfVWlTbmFja2JhckNvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVNuYWNrYmFyQ29udGFpbmVyKTtcclxuXHRcclxuXHR2YXIgX1VpU3dpdGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTIpO1xyXG5cdFxyXG5cdHZhciBfVWlTd2l0Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTd2l0Y2gpO1xyXG5cdFxyXG5cdHZhciBfVWlUYWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5Nik7XHJcblx0XHJcblx0dmFyIF9VaVRhYjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRhYik7XHJcblx0XHJcblx0dmFyIF9VaVRhYnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMCk7XHJcblx0XHJcblx0dmFyIF9VaVRhYnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUYWJzKTtcclxuXHRcclxuXHR2YXIgX1VpVGV4dGJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA4KTtcclxuXHRcclxuXHR2YXIgX1VpVGV4dGJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRleHRib3gpO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpVG9vbGJhcik7XHJcblx0XHJcblx0dmFyIF9VaVRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcclxuXHRcclxuXHR2YXIgX1VpVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRvb2x0aXApO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0dmFyIEtlZW4gPSB7XHJcblx0ICAgIFVpQWxlcnQ6IF9VaUFsZXJ0Mi5kZWZhdWx0LFxyXG5cdCAgICBVaUF1dG9jb21wbGV0ZTogX1VpQXV0b2NvbXBsZXRlMi5kZWZhdWx0LFxyXG5cdCAgICBVaUJ1dHRvbjogX1VpQnV0dG9uMi5kZWZhdWx0LFxyXG5cdCAgICBVaUNoZWNrYm94OiBfVWlDaGVja2JveDIuZGVmYXVsdCxcclxuXHQgICAgVWlDb2xsYXBzaWJsZTogX1VpQ29sbGFwc2libGUyLmRlZmF1bHQsXHJcblx0ICAgIFVpQ29uZmlybTogX1VpQ29uZmlybTIuZGVmYXVsdCxcclxuXHQgICAgVWlGYWI6IF9VaUZhYjIuZGVmYXVsdCxcclxuXHQgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0LFxyXG5cdCAgICBVaUljb25CdXR0b246IF9VaUljb25CdXR0b24yLmRlZmF1bHQsXHJcblx0ICAgIFVpTWVudTogX1VpTWVudTIuZGVmYXVsdCxcclxuXHQgICAgVWlNZW51T3B0aW9uOiBfVWlNZW51T3B0aW9uMi5kZWZhdWx0LFxyXG5cdCAgICBVaU1vZGFsOiBfVWlNb2RhbDIuZGVmYXVsdCxcclxuXHQgICAgVWlQb3BvdmVyOiBfVWlQb3BvdmVyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVByZWxvYWRlcjogX1VpUHJlbG9hZGVyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHQsXHJcblx0ICAgIFVpUHJvZ3Jlc3NMaW5lYXI6IF9VaVByb2dyZXNzTGluZWFyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhZGlvOiBfVWlSYWRpbzIuZGVmYXVsdCxcclxuXHQgICAgVWlSYWRpb0dyb3VwOiBfVWlSYWRpb0dyb3VwMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhdGluZzogX1VpUmF0aW5nMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhdGluZ0ljb246IF9VaVJhdGluZ0ljb24yLmRlZmF1bHQsXHJcblx0ICAgIFVpUmF0aW5nUHJldmlldzogX1VpUmF0aW5nUHJldmlldzIuZGVmYXVsdCxcclxuXHQgICAgVWlSaXBwbGVJbms6IF9VaVJpcHBsZUluazIuZGVmYXVsdCxcclxuXHQgICAgVWlTZWxlY3Q6IF9VaVNlbGVjdDIuZGVmYXVsdCxcclxuXHQgICAgVWlTbGlkZXI6IF9VaVNsaWRlcjIuZGVmYXVsdCxcclxuXHQgICAgVWlTbmFja2JhcjogX1VpU25hY2tiYXIyLmRlZmF1bHQsXHJcblx0ICAgIFVpU25hY2tiYXJDb250YWluZXI6IF9VaVNuYWNrYmFyQ29udGFpbmVyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVN3aXRjaDogX1VpU3dpdGNoMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRhYjogX1VpVGFiMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRhYnM6IF9VaVRhYnMyLmRlZmF1bHQsXHJcblx0ICAgIFVpVGV4dGJveDogX1VpVGV4dGJveDIuZGVmYXVsdCxcclxuXHQgICAgVWlUb29sYmFyOiBfVWlUb29sYmFyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRvb2x0aXA6IF9VaVRvb2x0aXAyLmRlZmF1bHQsXHJcblx0XHJcblx0ICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1hbGVydCcsIF9VaUFsZXJ0Mi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWF1dG9jb21wbGV0ZScsIF9VaUF1dG9jb21wbGV0ZTIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1idXR0b24nLCBfVWlCdXR0b24yLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktY2hlY2tib3gnLCBfVWlDaGVja2JveDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1jb2xsYXBzaWJsZScsIF9VaUNvbGxhcHNpYmxlMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWNvbmZpcm0nLCBfVWlDb25maXJtMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWZhYicsIF9VaUZhYjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1pY29uJywgX1VpSWNvbjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1pY29uLWJ1dHRvbicsIF9VaUljb25CdXR0b24yLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktbWVudScsIF9VaU1lbnUyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktbWVudS1vcHRpb24nLCBfVWlNZW51T3B0aW9uMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLW1vZGFsJywgX1VpTW9kYWwyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcG9wb3ZlcicsIF9VaVBvcG92ZXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcHJlbG9hZGVyJywgX1VpUHJlbG9hZGVyMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXByb2dyZXNzLWNpcmN1bGFyJywgX1VpUHJvZ3Jlc3NDaXJjdWxhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1wcm9ncmVzcy1saW5lYXInLCBfVWlQcm9ncmVzc0xpbmVhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yYWRpbycsIF9VaVJhZGlvMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXJhZGlvLWdyb3VwJywgX1VpUmFkaW9Hcm91cDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yYXRpbmcnLCBfVWlSYXRpbmcyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcmF0aW5nLWljb24nLCBfVWlSYXRpbmdJY29uMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXJhdGluZy1wcmV2aWV3JywgX1VpUmF0aW5nUHJldmlldzIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yaXBwbGUtaW5rJywgX1VpUmlwcGxlSW5rMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXNlbGVjdCcsIF9VaVNlbGVjdDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zbGlkZXInLCBfVWlTbGlkZXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktc25hY2tiYXInLCBfVWlTbmFja2JhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zbmFja2Jhci1jb250YWluZXInLCBfVWlTbmFja2JhckNvbnRhaW5lcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zd2l0Y2gnLCBfVWlTd2l0Y2gyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktdGFiJywgX1VpVGFiMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRhYnMnLCBfVWlUYWJzMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRleHRib3gnLCBfVWlUZXh0Ym94Mi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRvb2xiYXInLCBfVWlUb29sYmFyMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRvb2x0aXAnLCBfVWlUb29sdGlwMi5kZWZhdWx0KTtcclxuXHQgICAgfVxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBLZWVuO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHZhciBoYWRLZXlib2FyZEV2ZW50ID0gZmFsc2U7XHJcblx0ICAgIHZhciBrZXlib2FyZE1vZGFsaXR5V2hpdGVsaXN0ID0gWydpbnB1dDpub3QoW3R5cGVdKScsICdpbnB1dFt0eXBlPXRleHRdJywgJ2lucHV0W3R5cGU9bnVtYmVyXScsICdpbnB1dFt0eXBlPWRhdGVdJywgJ2lucHV0W3R5cGU9dGltZV0nLCAnaW5wdXRbdHlwZT1kYXRldGltZV0nLCAndGV4dGFyZWEnLCAnW3JvbGU9dGV4dGJveF0nLCAnW3N1cHBvcnRzLW1vZGFsaXR5PWtleWJvYXJkXSddLmpvaW4oJywnKTtcclxuXHRcclxuXHQgICAgdmFyIGlzSGFuZGxpbmdLZXlib2FyZFRocm90dGxlO1xyXG5cdFxyXG5cdCAgICB2YXIgbWF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmJvZHk7XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWwubWF0Y2hlc1NlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXNTZWxlY3RvcjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKGVsLm1vek1hdGNoZXNTZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBlbC5tb3pNYXRjaGVzU2VsZWN0b3I7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3I7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZG5cXCd0IGZpbmQgYW55IG1hdGNoZXNTZWxlY3RvciBtZXRob2Qgb24gZG9jdW1lbnQuYm9keS4nKTtcclxuXHQgICAgfSgpO1xyXG5cdFxyXG5cdCAgICB2YXIgZGlzYWJsZUZvY3VzUmluZ0J5RGVmYXVsdCA9IGZ1bmN0aW9uIGRpc2FibGVGb2N1c1JpbmdCeURlZmF1bHQoKSB7XHJcblx0ICAgICAgICB2YXIgY3NzID0gJ2JvZHk6bm90KFttb2RhbGl0eT1rZXlib2FyZF0pIDpmb2N1cyB7IG91dGxpbmU6IG5vbmU7IH0nO1xyXG5cdCAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XHJcblx0ICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5cdFxyXG5cdCAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcblx0ICAgICAgICBzdHlsZS5pZCA9ICdkaXNhYmxlLWZvY3VzLXJpbmcnO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuXHQgICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIHZhciBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSA9IGZ1bmN0aW9uIGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KGVsKSB7XHJcblx0ICAgICAgICB2YXIgdHJpZ2dlcnMgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICAgIGlmIChtYXRjaGVyKSB7XHJcblx0ICAgICAgICAgICAgdHJpZ2dlcnMgPSBtYXRjaGVyLmNhbGwoZWwsIGtleWJvYXJkTW9kYWxpdHlXaGl0ZWxpc3QpICYmIG1hdGNoZXIuY2FsbChlbCwgJzpub3QoW3JlYWRvbmx5XSknKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiB0cmlnZ2VycztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgZGlzYWJsZUZvY3VzUmluZ0J5RGVmYXVsdCgpO1xyXG5cdFxyXG5cdCAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgIGlmIChpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZSkge1xyXG5cdCAgICAgICAgICAgIGNsZWFyVGltZW91dChpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZSk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIGhhZEtleWJvYXJkRXZlbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH0sIDEwMCk7XHJcblx0ICAgIH0sIHRydWUpO1xyXG5cdFxyXG5cdCAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgIGlmIChoYWRLZXlib2FyZEV2ZW50IHx8IGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KGUudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdtb2RhbGl0eScsICdrZXlib2FyZCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LCB0cnVlKTtcclxuXHRcclxuXHQgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ21vZGFsaXR5Jyk7XHJcblx0ICAgIH0sIHRydWUpO1xyXG5cdH0pO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygzKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQWxlcnQudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaUFsZXJ0LnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogNCAqLyxcclxuLyogNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0XHJcblx0dmFyIF9VaUljb25CdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWFsZXJ0JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdpbmZvJyB9LFxyXG5cdCAgICAgICAgdGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzbWlzc2libGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGljb25OYW1lOiBmdW5jdGlvbiBpY29uTmFtZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5pY29uKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmljb247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy50eXBlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChpY29uID09PSAnc3VjY2VzcycpIHtcclxuXHQgICAgICAgICAgICAgICAgaWNvbiA9ICdjaGVja19jaXJjbGUnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gaWNvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkaXNtaXNzZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlJY29uQnV0dG9uOiBfVWlJY29uQnV0dG9uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpSWNvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlJY29uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWljb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJlbW92ZVRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxpXFxuICAgIGNsYXNzPVxcXCJ1aS1pY29uIG1hdGVyaWFsLWljb25zXFxcIiA6Y2xhc3M9XFxcIltpY29uXVxcXCIgdi10ZXh0PVxcXCJyZW1vdmVUZXh0ID8gbnVsbCA6IGljb25cXFwiXFxuICAgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIlxcbj48L2k+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlJY29uQnV0dG9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlJY29uQnV0dG9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaU1lbnUpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQb3BvdmVyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NDaXJjdWxhciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NDaXJjdWxhcik7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfSGFzRHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcclxuXHRcclxuXHR2YXIgX0hhc0Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc0Ryb3Bkb3duKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NUb29sdGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzVG9vbHRpcCk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluayA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NSaXBwbGVJbmspO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktaWNvbi1idXR0b24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3VpLWljb24tYnV0dG9uLScgKyB0eXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBidXR0b25UeXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGFyaWFMYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgbG9hZGluZzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHN0eWxlQ2xhc3NlczogZnVuY3Rpb24gc3R5bGVDbGFzc2VzKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW3RoaXMudHlwZSwgdGhpcy5jb2xvcl07XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaGFzRHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd1aS1kcm9wZG93bicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzcGlubmVyQ29sb3I6IGZ1bmN0aW9uIHNwaW5uZXJDb2xvcigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb2xvciA9PT0gJ2NvbG9yLWRlZmF1bHQnIHx8IHRoaXMuY29sb3IgPT09ICdjb2xvci1ibGFjaycpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdibGFjayc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaU1lbnU6IF9VaU1lbnUyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVBvcG92ZXI6IF9VaVBvcG92ZXIyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc0Ryb3Bkb3duMi5kZWZhdWx0LCBfU2hvd3NUb29sdGlwMi5kZWZhdWx0LCBfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHRdLFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTQpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpTWVudS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpTWVudS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnVPcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNZW51T3B0aW9uKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzRHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzRHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NEcm9wZG93bik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1tZW51JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG9wdGlvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93SWNvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd1NlY29uZGFyeVRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZVJpcHBsZUluazoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZU9uU2VsZWN0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGFydGlhbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndWktbWVudS1kZWZhdWx0J1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICdkcm9wZG93bi1vcGVuZWQnOiBmdW5jdGlvbiBkcm9wZG93bk9wZW5lZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250YWluRm9jdXMpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgJ2Ryb3Bkb3duLWNsb3NlZCc6IGZ1bmN0aW9uIGRyb3Bkb3duQ2xvc2VkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5Gb2N1cykge1xyXG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMucmVzdHJpY3RGb2N1cywgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgb3B0aW9uU2VsZWN0OiBmdW5jdGlvbiBvcHRpb25TZWxlY3Qob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCEob3B0aW9uLmRpc2FibGVkIHx8IG9wdGlvbi50eXBlID09PSAnZGl2aWRlcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdvcHRpb24tc2VsZWN0ZWQnLCBvcHRpb24pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9zZU9uU2VsZWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZXN0cmljdEZvY3VzOiBmdW5jdGlvbiByZXN0cmljdEZvY3VzKGUpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuJGVscy5kcm9wZG93bi5jb250YWlucyhlLnRhcmdldCkpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZWxzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy51aS1tZW51LW9wdGlvbicpLmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJlZGlyZWN0Rm9jdXM6IGZ1bmN0aW9uIHJlZGlyZWN0Rm9jdXMoZSkge1xyXG5cdCAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZWxzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy51aS1tZW51LW9wdGlvbicpLmZvY3VzKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpTWVudU9wdGlvbjogX1VpTWVudU9wdGlvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfU2hvd3NEcm9wZG93bjIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTcpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpTWVudU9wdGlvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpTWVudU9wdGlvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLW1lbnUtb3B0aW9uJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgIHRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIHNob3dJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlY29uZGFyeVRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIHNob3dTZWNvbmRhcnlUZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLW1lbnUtZGVmYXVsdCdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb246IE9iamVjdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgaXNEaXZpZGVyOiBmdW5jdGlvbiBpc0RpdmlkZXIoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2RpdmlkZXInO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcGFydGlhbHM6IHtcclxuXHQgICAgICAgICd1aS1tZW51LWRlZmF1bHQnOiAnXFxuICAgICAgICAgICAgPHVpLWljb25cXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ1aS1tZW51LW9wdGlvbi1pY29uXCIgOmljb249XCJpY29uXCIgdi1pZj1cInNob3dJY29uICYmICFpc0RpdmlkZXIgJiYgaWNvblwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktbWVudS1vcHRpb24tdGV4dFwiIHYtdGV4dD1cInRleHRcIiB2LWlmPVwiIWlzRGl2aWRlclwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ1aS1tZW51LW9wdGlvbi1zZWNvbmRhcnktdGV4dFwiIHYtdGV4dD1cInNlY29uZGFyeVRleHRcIlxcbiAgICAgICAgICAgICAgICB2LWlmPVwic2hvd1NlY29uZGFyeVRleHQgJiYgIWlzRGl2aWRlciAmJiBzZWNvbmRhcnlUZXh0XCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICAnXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1JpcHBsZUluazIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblx0XHJcblx0dmFyIF9VaVJpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJpcHBsZUluayk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBoaWRlUmlwcGxlSW5rOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVJpcHBsZUluazogX1VpUmlwcGxlSW5rMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjEpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUmlwcGxlSW5rLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlSaXBwbGVJbmsudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbGlzdCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHR2YXIgc3RhcnRSaXBwbGUgPSBmdW5jdGlvbiBzdGFydFJpcHBsZShldmVudFR5cGUsIGV2ZW50KSB7XHJcblx0ICAgIHZhciBob2xkZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cdFxyXG5cdCAgICBpZiAoIV9jbGFzc2xpc3QyLmRlZmF1bHQuaGFzKGhvbGRlciwgJ3VpLXJpcHBsZS1pbmsnKSkge1xyXG5cdCAgICAgICAgaG9sZGVyID0gaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy51aS1yaXBwbGUtaW5rJyk7XHJcblx0XHJcblx0ICAgICAgICBpZiAoIWhvbGRlcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgcHJldiA9IGhvbGRlci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdWktZXZlbnQnKTtcclxuXHRcclxuXHQgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gZXZlbnRUeXBlKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaG9sZGVyLnNldEF0dHJpYnV0ZSgnZGF0YS11aS1ldmVudCcsIGV2ZW50VHlwZSk7XHJcblx0XHJcblx0ICAgIHZhciByZWN0ID0gaG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdCAgICB2YXIgeCA9IGV2ZW50Lm9mZnNldFg7XHJcblx0ICAgIHZhciB5O1xyXG5cdFxyXG5cdCAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICB5ID0gZXZlbnQub2Zmc2V0WTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG5cdCAgICAgICAgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgcmlwcGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgIHZhciBtYXg7XHJcblx0XHJcblx0ICAgIGlmIChyZWN0LndpZHRoID09PSByZWN0LmhlaWdodCkge1xyXG5cdCAgICAgICAgbWF4ID0gcmVjdC53aWR0aCAqIDEuNDEyO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgbWF4ID0gTWF0aC5zcXJ0KHJlY3Qud2lkdGggKiByZWN0LndpZHRoICsgcmVjdC5oZWlnaHQgKiByZWN0LmhlaWdodCk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIGRpbSA9IG1heCAqIDIgKyAncHgnO1xyXG5cdFxyXG5cdCAgICByaXBwbGUuc3R5bGUud2lkdGggPSBkaW07XHJcblx0ICAgIHJpcHBsZS5zdHlsZS5oZWlnaHQgPSBkaW07XHJcblx0ICAgIHJpcHBsZS5zdHlsZS5tYXJnaW5MZWZ0ID0gLW1heCArIHggKyAncHgnO1xyXG5cdCAgICByaXBwbGUuc3R5bGUubWFyZ2luVG9wID0gLW1heCArIHkgKyAncHgnO1xyXG5cdFxyXG5cdCAgICByaXBwbGUuY2xhc3NOYW1lID0gJ3JpcHBsZSc7XHJcblx0ICAgIGhvbGRlci5hcHBlbmRDaGlsZChyaXBwbGUpO1xyXG5cdFxyXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQuYWRkKHJpcHBsZSwgJ2hlbGQnKTtcclxuXHQgICAgfSwgMCk7XHJcblx0XHJcblx0ICAgIHZhciByZWxlYXNlRXZlbnQgPSBldmVudFR5cGUgPT09ICdtb3VzZWRvd24nID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kJztcclxuXHRcclxuXHQgICAgdmFyIHJlbGVhc2UgPSBmdW5jdGlvbiByZWxlYXNlKCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWxlYXNlRXZlbnQsIHJlbGVhc2UpO1xyXG5cdFxyXG5cdCAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5hZGQocmlwcGxlLCAnZG9uZScpO1xyXG5cdFxyXG5cdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgaG9sZGVyLnJlbW92ZUNoaWxkKHJpcHBsZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCFob2xkZXIuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQucmVtb3ZlKGhvbGRlciwgJ2FjdGl2ZScpO1xyXG5cdCAgICAgICAgICAgICAgICBob2xkZXIucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXVpLWV2ZW50Jyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSwgNDUwKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihyZWxlYXNlRXZlbnQsIHJlbGVhc2UpO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihlKSB7XHJcblx0ICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xyXG5cdCAgICAgICAgc3RhcnRSaXBwbGUoZS50eXBlLCBlKTtcclxuXHQgICAgfVxyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcclxuXHQgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIHtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHN0YXJ0UmlwcGxlKGUudHlwZSwgZS5jaGFuZ2VkVG91Y2hlc1tpXSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJpcHBsZS1pbmsnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHJpZ2dlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEVsZW1lbnQsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0b3J5OiBmdW5jdGlvbiBiZWZvcmVEZXN0b3J5KCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoU3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuXHRcclxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdHZhciB0cmltID0gL15cXHMrfFxccyskL2c7XHJcblx0dmFyIHdoaXRlc3BhY2UgPSAvXFxzKy9nO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGludGVycHJldChpbnB1dCkge1xyXG5cdCAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IGlucHV0LnJlcGxhY2UodHJpbSwgJycpLnNwbGl0KHdoaXRlc3BhY2UpIDogaW5wdXQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGNsYXNzZXMoZWwpIHtcclxuXHQgICAgaWYgKGlzRWxlbWVudChlbCkpIHtcclxuXHQgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUucmVwbGFjZSh0cmltLCAnJykuc3BsaXQod2hpdGVzcGFjZSk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIFtdO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBzZXQoZWwsIGlucHV0KSB7XHJcblx0ICAgIGlmIChpc0VsZW1lbnQoZWwpKSB7XHJcblx0ICAgICAgICBlbC5jbGFzc05hbWUgPSBpbnRlcnByZXQoaW5wdXQpLmpvaW4oJyAnKTtcclxuXHQgICAgfVxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBhZGQoZWwsIGlucHV0KSB7XHJcblx0ICAgIHZhciBjdXJyZW50ID0gcmVtb3ZlKGVsLCBpbnB1dCk7XHJcblx0ICAgIHZhciB2YWx1ZXMgPSBpbnRlcnByZXQoaW5wdXQpO1xyXG5cdFxyXG5cdCAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgdmFsdWVzKTtcclxuXHQgICAgc2V0KGVsLCBjdXJyZW50KTtcclxuXHRcclxuXHQgICAgcmV0dXJuIGN1cnJlbnQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHJlbW92ZShlbCwgaW5wdXQpIHtcclxuXHQgICAgdmFyIGN1cnJlbnQgPSBjbGFzc2VzKGVsKTtcclxuXHQgICAgdmFyIHZhbHVlcyA9IGludGVycHJldChpbnB1dCk7XHJcblx0XHJcblx0ICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIGkgPSBjdXJyZW50LmluZGV4T2YodmFsdWUpO1xyXG5cdCAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBzZXQoZWwsIGN1cnJlbnQpO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gY3VycmVudDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gY29udGFpbnMoZWwsIGlucHV0KSB7XHJcblx0ICAgIHZhciBjdXJyZW50ID0gY2xhc3NlcyhlbCk7XHJcblx0ICAgIHZhciB2YWx1ZXMgPSBpbnRlcnByZXQoaW5wdXQpO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gdmFsdWVzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGN1cnJlbnQuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xyXG5cdCAgICB9KTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcclxuXHQgICAgdmFyIGVsZW1lbnRPYmplY3RzID0gKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShIVE1MRWxlbWVudCkpID09PSAnb2JqZWN0JztcclxuXHRcclxuXHQgICAgcmV0dXJuIGVsZW1lbnRPYmplY3RzID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogaXNFbGVtZW50T2JqZWN0KG8pO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBpc0VsZW1lbnRPYmplY3Qobykge1xyXG5cdCAgICByZXR1cm4gbyAmJiAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobykpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgby5ub2RlVHlwZSA9PT0gMTtcclxuXHR9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBhZGQ6IGFkZCxcclxuXHQgICAgcmVtb3ZlOiByZW1vdmUsXHJcblx0ICAgIGNvbnRhaW5zOiBjb250YWlucyxcclxuXHQgICAgaGFzOiBjb250YWlucyxcclxuXHQgICAgc2V0OiBzZXQsXHJcblx0ICAgIGdldDogY2xhc3Nlc1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0dmFyIF9TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KVtcImRlZmF1bHRcIl07XHJcblx0XHJcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICByZXR1cm4gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX1N5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xyXG5cdH07XHJcblx0XHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDI1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMjYpLCBfX2VzTW9kdWxlOiB0cnVlIH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KS5TeW1ib2w7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cclxuXHR2YXIgJCAgICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxyXG5cdCAgLCBnbG9iYWwgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXHJcblx0ICAsIGhhcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcclxuXHQgICwgREVTQ1JJUFRPUlMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKVxyXG5cdCAgLCAkZXhwb3J0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpXHJcblx0ICAsIHJlZGVmaW5lICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNylcclxuXHQgICwgJGZhaWxzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxyXG5cdCAgLCBzaGFyZWQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDApXHJcblx0ICAsIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSlcclxuXHQgICwgdWlkICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxyXG5cdCAgLCB3a3MgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpXHJcblx0ICAsIGtleU9mICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcclxuXHQgICwgJG5hbWVzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KVxyXG5cdCAgLCBlbnVtS2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTApXHJcblx0ICAsIGlzQXJyYXkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSlcclxuXHQgICwgYW5PYmplY3QgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKVxyXG5cdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpXHJcblx0ICAsIGNyZWF0ZURlc2MgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSlcclxuXHQgICwgZ2V0RGVzYyAgICAgICAgPSAkLmdldERlc2NcclxuXHQgICwgc2V0RGVzYyAgICAgICAgPSAkLnNldERlc2NcclxuXHQgICwgX2NyZWF0ZSAgICAgICAgPSAkLmNyZWF0ZVxyXG5cdCAgLCBnZXROYW1lcyAgICAgICA9ICRuYW1lcy5nZXRcclxuXHQgICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXHJcblx0ICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cclxuXHQgICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcclxuXHQgICwgc2V0dGVyICAgICAgICAgPSBmYWxzZVxyXG5cdCAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXHJcblx0ICAsIGlzRW51bSAgICAgICAgID0gJC5pc0VudW1cclxuXHQgICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXHJcblx0ICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcclxuXHQgICwgdXNlTmF0aXZlICAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXHJcblx0ICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHRcclxuXHQvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcclxuXHR2YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xyXG5cdCAgcmV0dXJuIF9jcmVhdGUoc2V0RGVzYyh7fSwgJ2EnLCB7XHJcblx0ICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHNldERlc2ModGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XHJcblx0ICB9KSkuYSAhPSA3O1xyXG5cdH0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XHJcblx0ICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcclxuXHQgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcclxuXHQgIHNldERlc2MoaXQsIGtleSwgRCk7XHJcblx0ICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcclxuXHR9IDogc2V0RGVzYztcclxuXHRcclxuXHR2YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XHJcblx0ICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSk7XHJcblx0ICBzeW0uX2sgPSB0YWc7XHJcblx0ICBERVNDUklQVE9SUyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XHJcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XHJcblx0ICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xyXG5cdCAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdCAgcmV0dXJuIHN5bTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XHJcblx0ICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcclxuXHQgICAgaWYoIUQuZW51bWVyYWJsZSl7XHJcblx0ICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlzZXREZXNjKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcclxuXHQgICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XHJcblx0ICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XHJcblx0ICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XHJcblx0ICB9IHJldHVybiBzZXREZXNjKGl0LCBrZXksIEQpO1xyXG5cdH07XHJcblx0dmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XHJcblx0ICBhbk9iamVjdChpdCk7XHJcblx0ICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXHJcblx0ICAgICwgaSAgICA9IDBcclxuXHQgICAgLCBsID0ga2V5cy5sZW5ndGhcclxuXHQgICAgLCBrZXk7XHJcblx0ICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcclxuXHQgIHJldHVybiBpdDtcclxuXHR9O1xyXG5cdHZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcclxuXHQgIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcclxuXHR9O1xyXG5cdHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xyXG5cdCAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkpO1xyXG5cdCAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XVxyXG5cdCAgICA/IEUgOiB0cnVlO1xyXG5cdH07XHJcblx0dmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XHJcblx0ICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xyXG5cdCAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XHJcblx0ICByZXR1cm4gRDtcclxuXHR9O1xyXG5cdHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xyXG5cdCAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXHJcblx0ICAgICwgcmVzdWx0ID0gW11cclxuXHQgICAgLCBpICAgICAgPSAwXHJcblx0ICAgICwga2V5O1xyXG5cdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcclxuXHQgIHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHR2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XHJcblx0ICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcclxuXHQgICAgLCByZXN1bHQgPSBbXVxyXG5cdCAgICAsIGkgICAgICA9IDBcclxuXHQgICAgLCBrZXk7XHJcblx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xyXG5cdCAgcmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cdHZhciAkc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcclxuXHQgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxyXG5cdCAgdmFyIGFyZ3MgPSBbaXRdXHJcblx0ICAgICwgaSAgICA9IDFcclxuXHQgICAgLCAkJCAgID0gYXJndW1lbnRzXHJcblx0ICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcclxuXHQgIHdoaWxlKCQkLmxlbmd0aCA+IGkpYXJncy5wdXNoKCQkW2krK10pO1xyXG5cdCAgcmVwbGFjZXIgPSBhcmdzWzFdO1xyXG5cdCAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XHJcblx0ICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XHJcblx0ICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG5cdCAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcclxuXHQgIH07XHJcblx0ICBhcmdzWzFdID0gcmVwbGFjZXI7XHJcblx0ICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XHJcblx0fTtcclxuXHR2YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XHJcblx0ICB2YXIgUyA9ICRTeW1ib2woKTtcclxuXHQgIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XHJcblx0ICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcclxuXHQgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXHJcblx0ICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xyXG5cdH0pO1xyXG5cdFxyXG5cdC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxyXG5cdGlmKCF1c2VOYXRpdmUpe1xyXG5cdCAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xyXG5cdCAgICBpZihpc1N5bWJvbCh0aGlzKSl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xyXG5cdCAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpKTtcclxuXHQgIH07XHJcblx0ICByZWRlZmluZSgkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcclxuXHQgICAgcmV0dXJuIHRoaXMuX2s7XHJcblx0ICB9KTtcclxuXHRcclxuXHQgIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xyXG5cdCAgfTtcclxuXHRcclxuXHQgICQuY3JlYXRlICAgICA9ICRjcmVhdGU7XHJcblx0ICAkLmlzRW51bSAgICAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XHJcblx0ICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cdCAgJC5zZXREZXNjICAgID0gJGRlZmluZVByb3BlcnR5O1xyXG5cdCAgJC5zZXREZXNjcyAgID0gJGRlZmluZVByb3BlcnRpZXM7XHJcblx0ICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XHJcblx0ICAkLmdldFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG5cdFxyXG5cdCAgaWYoREVTQ1JJUFRPUlMgJiYgIV9fd2VicGFja19yZXF1aXJlX18oNTQpKXtcclxuXHQgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdHZhciBzeW1ib2xTdGF0aWNzID0ge1xyXG5cdCAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXHJcblx0ICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcclxuXHQgICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxyXG5cdCAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxyXG5cdCAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcclxuXHQgIH0sXHJcblx0ICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcclxuXHQgIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XHJcblx0ICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcclxuXHQgIH0sXHJcblx0ICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXHJcblx0ICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XHJcblx0fTtcclxuXHQvLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2VcclxuXHQvLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXHJcblx0Ly8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXHJcblx0Ly8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXHJcblx0Ly8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2VcclxuXHQvLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXHJcblx0Ly8gMTkuNC4yLjEwIFN5bWJvbC5zcGVjaWVzXHJcblx0Ly8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxyXG5cdC8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcclxuXHQvLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXHJcblx0Ly8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xyXG5cdCQuZWFjaC5jYWxsKChcclxuXHQgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXHJcblx0ICAnc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcclxuXHQpLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcclxuXHQgIHZhciBzeW0gPSB3a3MoaXQpO1xyXG5cdCAgc3ltYm9sU3RhdGljc1tpdF0gPSB1c2VOYXRpdmUgPyBzeW0gOiB3cmFwKHN5bSk7XHJcblx0fSk7XHJcblx0XHJcblx0c2V0dGVyID0gdHJ1ZTtcclxuXHRcclxuXHQkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVywge1N5bWJvbDogJFN5bWJvbH0pO1xyXG5cdFxyXG5cdCRleHBvcnQoJGV4cG9ydC5TLCAnU3ltYm9sJywgc3ltYm9sU3RhdGljcyk7XHJcblx0XHJcblx0JGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xyXG5cdCAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG5cdCAgY3JlYXRlOiAkY3JlYXRlLFxyXG5cdCAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXHJcblx0ICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxyXG5cdCAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcclxuXHQgIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxyXG5cdCAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxyXG5cdCAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxyXG5cdCAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxuXHQgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG5cdCAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxyXG5cdCAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXHJcblx0fSk7XHJcblx0XHJcblx0Ly8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXHJcblx0JEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIXVzZU5hdGl2ZSB8fCBidWdneUpTT04pLCAnSlNPTicsIHtzdHJpbmdpZnk6ICRzdHJpbmdpZnl9KTtcclxuXHRcclxuXHQvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXHJcblx0c2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xyXG5cdC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuXHRzZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xyXG5cdC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXHJcblx0c2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyICRPYmplY3QgPSBPYmplY3Q7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcclxuXHQgIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXHJcblx0ICBpc0VudW06ICAgICB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcclxuXHQgIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxyXG5cdCAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcclxuXHQgIHNldERlc2NzOiAgICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyxcclxuXHQgIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcclxuXHQgIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcclxuXHQgIGdldFN5bWJvbHM6ICRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxyXG5cdCAgZWFjaDogICAgICAgW10uZm9yRWFjaFxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcclxuXHR2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcclxuXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHRpZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG5cclxuLyoqKi8gfSxcclxuLyogMzAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XHJcblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcclxuXHRtb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKShmdW5jdGlvbigpe1xyXG5cdCAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxuXHR9KTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xyXG5cdCAgdHJ5IHtcclxuXHQgICAgcmV0dXJuICEhZXhlYygpO1xyXG5cdCAgfSBjYXRjaChlKXtcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgZ2xvYmFsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcclxuXHQgICwgY29yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNClcclxuXHQgICwgY3R4ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlcclxuXHQgICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XHJcblx0XHJcblx0dmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG5cdCAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcclxuXHQgICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXHJcblx0ICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xyXG5cdCAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcclxuXHQgICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXHJcblx0ICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xyXG5cdCAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXHJcblx0ICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxyXG5cdCAgICAsIGtleSwgb3duLCBvdXQ7XHJcblx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcclxuXHQgIGZvcihrZXkgaW4gc291cmNlKXtcclxuXHQgICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXHJcblx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XHJcblx0ICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcclxuXHQgICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcclxuXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcclxuXHQgICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXHJcblx0ICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXHJcblx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XHJcblx0ICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXHJcblx0ICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcblx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XHJcblx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbihwYXJhbSl7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcclxuXHQgICAgICB9O1xyXG5cdCAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcclxuXHQgICAgICByZXR1cm4gRjtcclxuXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXHJcblx0ICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcclxuXHQgICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xyXG5cdCAgfVxyXG5cdH07XHJcblx0Ly8gdHlwZSBiaXRtYXBcclxuXHQkZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXHJcblx0JGV4cG9ydC5HID0gMjsgIC8vIGdsb2JhbFxyXG5cdCRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcclxuXHQkZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cclxuXHQkZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxyXG5cdCRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXHJcblx0bW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMzQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi42J307XHJcblx0aWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXHJcblxyXG4vKioqLyB9LFxyXG4vKiAzNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXHJcblx0dmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XHJcblx0ICBhRnVuY3Rpb24oZm4pO1xyXG5cdCAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcclxuXHQgIHN3aXRjaChsZW5ndGgpe1xyXG5cdCAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcclxuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcclxuXHQgICAgfTtcclxuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XHJcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XHJcblx0ICAgIH07XHJcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xyXG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xyXG5cdCAgICB9O1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG5cdCAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcclxuXHQgIH07XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XHJcblx0ICByZXR1cm4gaXQ7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMzggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciAkICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOClcclxuXHQgICwgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSkgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xyXG5cdCAgcmV0dXJuICQuc2V0RGVzYyhvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xyXG5cdH0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xyXG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuXHQgIHJldHVybiBvYmplY3Q7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxyXG5cdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXHJcblx0ICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcclxuXHQgICAgdmFsdWUgICAgICAgOiB2YWx1ZVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxyXG5cdCAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xyXG5cdCAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG5cdCAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCkuc2V0RGVzY1xyXG5cdCAgLCBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxyXG5cdCAgLCBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSgndG9TdHJpbmdUYWcnKTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xyXG5cdCAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIHN0b3JlICA9IF9fd2VicGFja19yZXF1aXJlX18oNDApKCd3a3MnKVxyXG5cdCAgLCB1aWQgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxyXG5cdCAgLCBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KS5TeW1ib2w7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcclxuXHQgIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxyXG5cdCAgICBTeW1ib2wgJiYgU3ltYm9sW25hbWVdIHx8IChTeW1ib2wgfHwgdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgaWQgPSAwXHJcblx0ICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcblx0ICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyICQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXHJcblx0ICAsIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XHJcblx0ICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuXHQgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcclxuXHQgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG5cdCAgICAsIGluZGV4ICA9IDBcclxuXHQgICAgLCBrZXk7XHJcblx0ICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXHJcblx0dmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KVxyXG5cdCAgLCBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQ2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xyXG5cdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xyXG5cdCAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XHJcblx0ICByZXR1cm4gaXQ7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQ5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XHJcblx0dmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpXHJcblx0ICAsIGdldE5hbWVzICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLmdldE5hbWVzXHJcblx0ICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xyXG5cdFxyXG5cdHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcclxuXHQgID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xyXG5cdFxyXG5cdHZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHRyeSB7XHJcblx0ICAgIHJldHVybiBnZXROYW1lcyhpdCk7XHJcblx0ICB9IGNhdGNoKGUpe1xyXG5cdCAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xyXG5cdCAgaWYod2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScpcmV0dXJuIGdldFdpbmRvd05hbWVzKGl0KTtcclxuXHQgIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXHJcblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxyXG5cdCAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHM7XHJcblx0ICBpZihnZXRTeW1ib2xzKXtcclxuXHQgICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxyXG5cdCAgICAgICwgaXNFbnVtICA9ICQuaXNFbnVtXHJcblx0ICAgICAgLCBpICAgICAgID0gMFxyXG5cdCAgICAgICwga2V5O1xyXG5cdCAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpa2V5cy5wdXNoKGtleSk7XHJcblx0ICB9XHJcblx0ICByZXR1cm4ga2V5cztcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXHJcblx0dmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcmcpe1xyXG5cdCAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDUyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xyXG5cdCAgcmV0dXJuIGl0O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDU2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktcmlwcGxlLWlua1xcXCI+PC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxhXFxuICAgIGNsYXNzPVxcXCJ1aS1tZW51LW9wdGlvblxcXCIgcm9sZT1cXFwibWVudS1pdGVtXFxcIiA6dGFiaW5kZXg9XFxcIihpc0RpdmlkZXIgfHwgZGlzYWJsZWQpID8gbnVsbCA6ICcwJ1xcXCJcXG4gICAgOmNsYXNzPVxcXCJ7ICdkaXZpZGVyJzogaXNEaXZpZGVyLCAnZGlzYWJsZWQnIDogZGlzYWJsZWQgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLW1lbnUtb3B0aW9uLWNvbnRlbnRcXFwiIDpjbGFzcz1cXFwiW3BhcnRpYWxdXFxcIj5cXG4gICAgICAgIDxwYXJ0aWFsIDpuYW1lPVxcXCJwYXJ0aWFsXFxcIj48L3BhcnRpYWw+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8dWktcmlwcGxlLWlua1xcbiAgICAgICAgOnRyaWdnZXI9XFxcIiRlbFxcXCIgdi1pZj1cXFwiIWhpZGVSaXBwbGVJbmsgJiYgIWRpc2FibGVkICYmICFpc0RpdmlkZXJcXFwiXFxuICAgID48L3VpLXJpcHBsZS1pbms+XFxuPC9hPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3RldGhlckRyb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxuXHRcclxuXHR2YXIgX3RldGhlckRyb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV0aGVyRHJvcCk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc2xpc3QpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICB0cmlnZ2VyOiBFbGVtZW50LFxyXG5cdCAgICAgICAgY29udGFpbkZvY3VzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHJvcGRvd25Qb3NpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnYm90dG9tIGxlZnQnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3Blbk9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdjbGljaycgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBkcm9wOiBudWxsLFxyXG5cdCAgICAgICAgICAgIGxhc3RGb2N1c3NlZEVsZW1lbnQ6IG51bGxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVEcm9wZG93bigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuZHJvcCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJvcC5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3AuZGVzdHJveSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1kcm9wZG93bjo6b3Blbic6IGZ1bmN0aW9uIHVpRHJvcGRvd25PcGVuKGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLm9wZW5Ecm9wZG93bigpO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICd1aS1kcm9wZG93bjo6Y2xvc2UnOiBmdW5jdGlvbiB1aURyb3Bkb3duQ2xvc2UoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICd1aS1kcm9wZG93bjo6dG9nZ2xlJzogZnVuY3Rpb24gdWlEcm9wZG93blRvZ2dsZShpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy50b2dnbGVEcm9wZG93bigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBpbml0aWFsaXplRHJvcGRvd246IGZ1bmN0aW9uIGluaXRpYWxpemVEcm9wZG93bigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3AgPSBuZXcgX3RldGhlckRyb3AyLmRlZmF1bHQoe1xyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMudHJpZ2dlcixcclxuXHQgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy4kZWxzLmRyb3Bkb3duLFxyXG5cdCAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5kcm9wZG93blBvc2l0aW9uLFxyXG5cdCAgICAgICAgICAgICAgICBjb25zdHJhaW5Ub1dpbmRvdzogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgb3Blbk9uOiB0aGlzLm9wZW5PblxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3Bkb3duUG9zaXRpb24gIT09ICdib3R0b20gbGVmdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLm9wZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5vcGVuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5jbG9zZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3Aub24oJ29wZW4nLCB0aGlzLnBvc2l0aW9uRHJvcCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wLm9uKCdvcGVuJywgdGhpcy5kcm9wZG93bk9wZW5lZCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wLm9uKCdjbG9zZScsIHRoaXMuZHJvcGRvd25DbG9zZWQpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW5Ecm9wZG93bjogZnVuY3Rpb24gb3BlbkRyb3Bkb3duKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcG9zaXRpb25Ecm9wOiBmdW5jdGlvbiBwb3NpdGlvbkRyb3AoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGRyb3AgPSB0aGlzLmRyb3A7XHJcblx0ICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIGRyb3BXaWR0aCA9IGRyb3AuZHJvcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGRyb3AudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XHJcblx0ICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVNwYWNlID0gd2luZG93V2lkdGggLSBsZWZ0O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChkcm9wV2lkdGggPiBhdmFpbGFibGVTcGFjZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZHJvcFdpZHRoID4gYXZhaWxhYmxlU3BhY2UgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBkcm9wLnRldGhlci5hdHRhY2htZW50LmxlZnQgPSBkaXJlY3Rpb247XHJcblx0ICAgICAgICAgICAgICAgIGRyb3AudGV0aGVyLnRhcmdldEF0dGFjaG1lbnQubGVmdCA9IGRpcmVjdGlvbjtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgZHJvcC5wb3NpdGlvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZURyb3Bkb3duOiBmdW5jdGlvbiBjbG9zZURyb3Bkb3duKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRvZ2dsZURyb3Bkb3duOiBmdW5jdGlvbiB0b2dnbGVEcm9wZG93bihlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZHJvcCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyb3AudG9nZ2xlKGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkcm9wZG93bk9wZW5lZDogZnVuY3Rpb24gZHJvcGRvd25PcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5hZGQodGhpcy50cmlnZ2VyLCAnZHJvcGRvd24tb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdEZvY3Vzc2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZWxzLmRyb3Bkb3duLmZvY3VzKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Ryb3Bkb3duLW9wZW5lZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRyb3Bkb3duQ2xvc2VkOiBmdW5jdGlvbiBkcm9wZG93bkNsb3NlZCgpIHtcclxuXHQgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LnJlbW92ZSh0aGlzLnRyaWdnZXIsICdkcm9wZG93bi1vcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubGFzdEZvY3Vzc2VkRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxhc3RGb2N1c3NlZEVsZW1lbnQuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Ryb3Bkb3duLWNsb3NlZCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIHRldGhlci1kcm9wIDEuNC4xICovXHJcblx0XHJcblx0KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHQgIGlmICh0cnVlKSB7XHJcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3RldGhlcicpKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJvb3QuRHJvcCA9IGZhY3Rvcnkocm9vdC5UZXRoZXIpO1xyXG5cdCAgfVxyXG5cdH0odGhpcywgZnVuY3Rpb24oVGV0aGVyKSB7XHJcblx0XHJcblx0LyogZ2xvYmFsIFRldGhlciAqL1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcclxuXHRcclxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcclxuXHRcclxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xyXG5cdFxyXG5cdHZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MiwgX3gzLCBfeDQpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gyLCBwcm9wZXJ0eSA9IF94MywgcmVjZWl2ZXIgPSBfeDQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gyID0gcGFyZW50OyBfeDMgPSBwcm9wZXJ0eTsgX3g0ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxyXG5cdFxyXG5cdHZhciBfVGV0aGVyJFV0aWxzID0gVGV0aGVyLlV0aWxzO1xyXG5cdHZhciBleHRlbmQgPSBfVGV0aGVyJFV0aWxzLmV4dGVuZDtcclxuXHR2YXIgYWRkQ2xhc3MgPSBfVGV0aGVyJFV0aWxzLmFkZENsYXNzO1xyXG5cdHZhciByZW1vdmVDbGFzcyA9IF9UZXRoZXIkVXRpbHMucmVtb3ZlQ2xhc3M7XHJcblx0dmFyIGhhc0NsYXNzID0gX1RldGhlciRVdGlscy5oYXNDbGFzcztcclxuXHR2YXIgRXZlbnRlZCA9IF9UZXRoZXIkVXRpbHMuRXZlbnRlZDtcclxuXHRcclxuXHRmdW5jdGlvbiBzb3J0QXR0YWNoKHN0cikge1xyXG5cdCAgdmFyIF9zdHIkc3BsaXQgPSBzdHIuc3BsaXQoJyAnKTtcclxuXHRcclxuXHQgIHZhciBfc3RyJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9zdHIkc3BsaXQsIDIpO1xyXG5cdFxyXG5cdCAgdmFyIGZpcnN0ID0gX3N0ciRzcGxpdDJbMF07XHJcblx0ICB2YXIgc2Vjb25kID0gX3N0ciRzcGxpdDJbMV07XHJcblx0XHJcblx0ICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihmaXJzdCkgPj0gMCkge1xyXG5cdCAgICB2YXIgX3JlZiA9IFtzZWNvbmQsIGZpcnN0XTtcclxuXHQgICAgZmlyc3QgPSBfcmVmWzBdO1xyXG5cdCAgICBzZWNvbmQgPSBfcmVmWzFdO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIFtmaXJzdCwgc2Vjb25kXS5qb2luKCcgJyk7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIGl0ZW0pIHtcclxuXHQgIHZhciBpbmRleCA9IHVuZGVmaW5lZDtcclxuXHQgIHZhciByZXN1bHRzID0gW107XHJcblx0ICB3aGlsZSAoKGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSkpICE9PSAtMSkge1xyXG5cdCAgICByZXN1bHRzLnB1c2goYXJyLnNwbGljZShpbmRleCwgMSkpO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHJlc3VsdHM7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBjbGlja0V2ZW50cyA9IFsnY2xpY2snXTtcclxuXHRpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcblx0ICBjbGlja0V2ZW50cy5wdXNoKCd0b3VjaHN0YXJ0Jyk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciB0cmFuc2l0aW9uRW5kRXZlbnRzID0ge1xyXG5cdCAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXHJcblx0ICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcclxuXHQgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCcsXHJcblx0ICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICcnO1xyXG5cdGZvciAodmFyIF9uYW1lIGluIHRyYW5zaXRpb25FbmRFdmVudHMpIHtcclxuXHQgIGlmICgoe30pLmhhc093blByb3BlcnR5LmNhbGwodHJhbnNpdGlvbkVuZEV2ZW50cywgX25hbWUpKSB7XHJcblx0ICAgIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcblx0ICAgIGlmICh0eXBlb2YgdGVtcEVsLnN0eWxlW19uYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSB0cmFuc2l0aW9uRW5kRXZlbnRzW19uYW1lXTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHR2YXIgTUlSUk9SX0FUVEFDSCA9IHtcclxuXHQgIGxlZnQ6ICdyaWdodCcsXHJcblx0ICByaWdodDogJ2xlZnQnLFxyXG5cdCAgdG9wOiAnYm90dG9tJyxcclxuXHQgIGJvdHRvbTogJ3RvcCcsXHJcblx0ICBtaWRkbGU6ICdtaWRkbGUnLFxyXG5cdCAgY2VudGVyOiAnY2VudGVyJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGFsbERyb3BzID0ge307XHJcblx0XHJcblx0Ly8gRHJvcCBjYW4gYmUgaW5jbHVkZWQgaW4gZXh0ZXJuYWwgbGlicmFyaWVzLiAgQ2FsbGluZyBjcmVhdGVDb250ZXh0IGdpdmVzIHlvdSBhIGZyZXNoXHJcblx0Ly8gY29weSBvZiBkcm9wIHdoaWNoIHdvbid0IGludGVyYWN0IHdpdGggb3RoZXIgY29waWVzIG9uIHRoZSBwYWdlIChiZXlvbmQgY2FsbGluZyB0aGUgZG9jdW1lbnQgZXZlbnRzKS5cclxuXHRcclxuXHRmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xyXG5cdCAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcclxuXHRcclxuXHQgIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcCgpIHtcclxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBuZXcgKF9iaW5kLmFwcGx5KERyb3BJbnN0YW5jZSwgW251bGxdLmNvbmNhdChhcmdzKSkpKCk7XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgZXh0ZW5kKGRyb3AsIHtcclxuXHQgICAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcclxuXHQgICAgZHJvcHM6IFtdLFxyXG5cdCAgICBkZWZhdWx0czoge31cclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG5cdCAgICBjbGFzc1ByZWZpeDogJ2Ryb3AnLFxyXG5cdCAgICBkZWZhdWx0czoge1xyXG5cdCAgICAgIHBvc2l0aW9uOiAnYm90dG9tIGxlZnQnLFxyXG5cdCAgICAgIG9wZW5PbjogJ2NsaWNrJyxcclxuXHQgICAgICBiZWZvcmVDbG9zZTogbnVsbCxcclxuXHQgICAgICBjb25zdHJhaW5Ub1Njcm9sbFBhcmVudDogdHJ1ZSxcclxuXHQgICAgICBjb25zdHJhaW5Ub1dpbmRvdzogdHJ1ZSxcclxuXHQgICAgICBjbGFzc2VzOiAnJyxcclxuXHQgICAgICByZW1vdmU6IGZhbHNlLFxyXG5cdCAgICAgIG9wZW5EZWxheTogMCxcclxuXHQgICAgICBjbG9zZURlbGF5OiA1MCxcclxuXHQgICAgICAvLyBpbmhlcml0ZWQgZnJvbSBvcGVuRGVsYXkgYW5kIGNsb3NlRGVsYXkgaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG5cdCAgICAgIGZvY3VzRGVsYXk6IG51bGwsXHJcblx0ICAgICAgYmx1ckRlbGF5OiBudWxsLFxyXG5cdCAgICAgIGhvdmVyT3BlbkRlbGF5OiBudWxsLFxyXG5cdCAgICAgIGhvdmVyQ2xvc2VEZWxheTogbnVsbCxcclxuXHQgICAgICB0ZXRoZXJPcHRpb25zOiB7fVxyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgZXh0ZW5kKGRyb3AsIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuXHQgIGV4dGVuZChkcm9wLmRlZmF1bHRzLCBkZWZhdWx0T3B0aW9ucy5kZWZhdWx0cywgb3B0aW9ucy5kZWZhdWx0cyk7XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIGFsbERyb3BzW2Ryb3AuY2xhc3NQcmVmaXhdID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBhbGxEcm9wc1tkcm9wLmNsYXNzUHJlZml4XSA9IFtdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgZHJvcC51cGRhdGVCb2R5Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgYm9keSwgc28gZGVzcGl0ZSB0aGUgY29udGV4dCBjb25jZXB0LCB3ZSBzdGlsbCBpdGVyYXRlIHRocm91Z2ggYWxsXHJcblx0ICAgIC8vIGRyb3BzIHdoaWNoIHNoYXJlIG91ciBjbGFzc1ByZWZpeC5cclxuXHRcclxuXHQgICAgdmFyIGFueU9wZW4gPSBmYWxzZTtcclxuXHQgICAgdmFyIGRyb3BzID0gYWxsRHJvcHNbZHJvcC5jbGFzc1ByZWZpeF07XHJcblx0ICAgIHZhciBsZW4gPSBkcm9wcy5sZW5ndGg7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICBpZiAoZHJvcHNbaV0uaXNPcGVuZWQoKSkge1xyXG5cdCAgICAgICAgYW55T3BlbiA9IHRydWU7XHJcblx0ICAgICAgICBicmVhaztcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKGFueU9wZW4pIHtcclxuXHQgICAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgdmFyIERyb3BJbnN0YW5jZSA9IChmdW5jdGlvbiAoX0V2ZW50ZWQpIHtcclxuXHQgICAgX2luaGVyaXRzKERyb3BJbnN0YW5jZSwgX0V2ZW50ZWQpO1xyXG5cdFxyXG5cdCAgICBmdW5jdGlvbiBEcm9wSW5zdGFuY2Uob3B0cykge1xyXG5cdCAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wSW5zdGFuY2UpO1xyXG5cdFxyXG5cdCAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3BJbnN0YW5jZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZHJvcC5kZWZhdWx0cywgb3B0cyk7XHJcblx0ICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0O1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ryb3AgRXJyb3I6IFlvdSBtdXN0IHByb3ZpZGUgYSB0YXJnZXQuJyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBkYXRhUHJlZml4ID0gJ2RhdGEtJyArIGRyb3AuY2xhc3NQcmVmaXg7XHJcblx0XHJcblx0ICAgICAgdmFyIGNvbnRlbnRBdHRyID0gdGhpcy50YXJnZXQuZ2V0QXR0cmlidXRlKGRhdGFQcmVmaXgpO1xyXG5cdCAgICAgIGlmIChjb250ZW50QXR0ciAmJiB0aGlzLm9wdGlvbnMuY29udGVudCA9PSBudWxsKSB7XHJcblx0ICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudCA9IGNvbnRlbnRBdHRyO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgYXR0cnNPdmVycmlkZSA9IFsncG9zaXRpb24nLCAnb3Blbk9uJ107XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyc092ZXJyaWRlLmxlbmd0aDsgKytpKSB7XHJcblx0XHJcblx0ICAgICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLnRhcmdldC5nZXRBdHRyaWJ1dGUoZGF0YVByZWZpeCArICctJyArIGF0dHJzT3ZlcnJpZGVbaV0pO1xyXG5cdCAgICAgICAgaWYgKG92ZXJyaWRlICYmIHRoaXMub3B0aW9uc1thdHRyc092ZXJyaWRlW2ldXSA9PSBudWxsKSB7XHJcblx0ICAgICAgICAgIHRoaXMub3B0aW9uc1thdHRyc092ZXJyaWRlW2ldXSA9IG92ZXJyaWRlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmNsYXNzZXMgJiYgdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5vcHRpb25zLmNsYXNzZXMpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBkcm9wLmRyb3BzLnB1c2godGhpcyk7XHJcblx0ICAgICAgYWxsRHJvcHNbZHJvcC5jbGFzc1ByZWZpeF0ucHVzaCh0aGlzKTtcclxuXHRcclxuXHQgICAgICB0aGlzLl9ib3VuZEV2ZW50cyA9IFtdO1xyXG5cdCAgICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcclxuXHQgICAgICB0aGlzLnNldHVwRWxlbWVudHMoKTtcclxuXHQgICAgICB0aGlzLnNldHVwRXZlbnRzKCk7XHJcblx0ICAgICAgdGhpcy5zZXR1cFRldGhlcigpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIF9jcmVhdGVDbGFzcyhEcm9wSW5zdGFuY2UsIFt7XHJcblx0ICAgICAga2V5OiAnX29uJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XHJcblx0ICAgICAgICB0aGlzLl9ib3VuZEV2ZW50cy5wdXNoKHsgZWxlbWVudDogZWxlbWVudCwgZXZlbnQ6IGV2ZW50LCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xyXG5cdCAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0sIHtcclxuXHQgICAgICBrZXk6ICdiaW5kTWV0aG9kcycsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRNZXRob2RzKCkge1xyXG5cdCAgICAgICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlciA9IHRoaXMuX3RyYW5zaXRpb25FbmRIYW5kbGVyLmJpbmQodGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnc2V0dXBFbGVtZW50cycsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwRWxlbWVudHMoKSB7XHJcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5kcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXgpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGFzc2VzKSB7XHJcblx0ICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJvcCwgdGhpcy5vcHRpb25zLmNsYXNzZXMpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmNvbnRlbnQsIGRyb3AuY2xhc3NQcmVmaXggKyAnLWNvbnRlbnQnKTtcclxuXHRcclxuXHQgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgdmFyIGdlbmVyYXRlQW5kU2V0Q29udGVudCA9IGZ1bmN0aW9uIGdlbmVyYXRlQW5kU2V0Q29udGVudCgpIHtcclxuXHQgICAgICAgICAgICAvLyBjb250ZW50IGZ1bmN0aW9uIG1pZ2h0IHJldHVybiBhIHN0cmluZyBvciBhbiBlbGVtZW50XHJcblx0ICAgICAgICAgICAgdmFyIGNvbnRlbnRFbGVtZW50T3JIVE1MID0gX3RoaXMub3B0aW9ucy5jb250ZW50LmNhbGwoX3RoaXMsIF90aGlzKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRFbGVtZW50T3JIVE1MID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSBjb250ZW50RWxlbWVudE9ySFRNTDtcclxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZW50RWxlbWVudE9ySFRNTCA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICAgICAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XHJcblx0ICAgICAgICAgICAgICBfdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnRFbGVtZW50T3JIVE1MKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wIEVycm9yOiBDb250ZW50IGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgb3IgSFRNTEVsZW1lbnQuJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICBnZW5lcmF0ZUFuZFNldENvbnRlbnQoKTtcclxuXHQgICAgICAgICAgdGhpcy5vbignb3BlbicsIGdlbmVyYXRlQW5kU2V0Q29udGVudC5iaW5kKHRoaXMpKTtcclxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb250ZW50ID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5vcHRpb25zLmNvbnRlbnQpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5kcm9wLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnc2V0dXBUZXRoZXInLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFRldGhlcigpIHtcclxuXHQgICAgICAgIC8vIFRldGhlciBleHBlY3RzIHR3byBhdHRhY2htZW50IHBvaW50cywgb25lIGluIHRoZSB0YXJnZXQgZWxlbWVudCwgb25lIGluIHRoZVxyXG5cdCAgICAgICAgLy8gZHJvcC4gIFdlIHVzZSBhIHNpbmdsZSBvbmUsIGFuZCB1c2UgdGhlIG9yZGVyIGFzIHdlbGwsIHRvIGFsbG93IHVzIHRvIHB1dFxyXG5cdCAgICAgICAgLy8gdGhlIGRyb3Agb24gZWl0aGVyIHNpZGUgb2YgYW55IG9mIHRoZSBmb3VyIGNvcm5lcnMuICBUaGlzIG1hZ2ljIGNvbnZlcnRzIGJldHdlZW5cclxuXHQgICAgICAgIC8vIHRoZSB0d286XHJcblx0ICAgICAgICB2YXIgZHJvcEF0dGFjaCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbi5zcGxpdCgnICcpO1xyXG5cdCAgICAgICAgZHJvcEF0dGFjaFswXSA9IE1JUlJPUl9BVFRBQ0hbZHJvcEF0dGFjaFswXV07XHJcblx0ICAgICAgICBkcm9wQXR0YWNoID0gZHJvcEF0dGFjaC5qb2luKCcgJyk7XHJcblx0XHJcblx0ICAgICAgICB2YXIgY29uc3RyYWludHMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWluVG9TY3JvbGxQYXJlbnQpIHtcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICdzY3JvbGxQYXJlbnQnLFxyXG5cdCAgICAgICAgICAgIHBpbjogJ3RvcCwgYm90dG9tJyxcclxuXHQgICAgICAgICAgICBhdHRhY2htZW50OiAndG9nZXRoZXIgbm9uZSdcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAvLyBUbyBnZXQgJ291dCBvZiBib3VuZHMnIGNsYXNzZXNcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICdzY3JvbGxQYXJlbnQnXHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW5Ub1dpbmRvdyAhPT0gZmFsc2UpIHtcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICd3aW5kb3cnLFxyXG5cdCAgICAgICAgICAgIGF0dGFjaG1lbnQ6ICd0b2dldGhlcidcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAvLyBUbyBnZXQgJ291dCBvZiBib3VuZHMnIGNsYXNzZXNcclxuXHQgICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XHJcblx0ICAgICAgICAgICAgdG86ICd3aW5kb3cnXHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFyIG9wdHMgPSB7XHJcblx0ICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZHJvcCxcclxuXHQgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcclxuXHQgICAgICAgICAgYXR0YWNobWVudDogc29ydEF0dGFjaChkcm9wQXR0YWNoKSxcclxuXHQgICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogc29ydEF0dGFjaCh0aGlzLm9wdGlvbnMucG9zaXRpb24pLFxyXG5cdCAgICAgICAgICBjbGFzc1ByZWZpeDogZHJvcC5jbGFzc1ByZWZpeCxcclxuXHQgICAgICAgICAgb2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgICAgdGFyZ2V0T2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcblx0ICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyxcclxuXHQgICAgICAgICAgYWRkVGFyZ2V0Q2xhc3NlczogdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXNcclxuXHQgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRldGhlck9wdGlvbnMgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgIHRoaXMudGV0aGVyID0gbmV3IFRldGhlcihleHRlbmQoe30sIG9wdHMsIHRoaXMub3B0aW9ucy50ZXRoZXJPcHRpb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnc2V0dXBFdmVudHMnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEV2ZW50cygpIHtcclxuXHQgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3Blbk9uKSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3Blbk9uID09PSAnYWx3YXlzJykge1xyXG5cdCAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMub3Blbi5iaW5kKHRoaXMpKTtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMub3B0aW9ucy5vcGVuT24uc3BsaXQoJyAnKTtcclxuXHRcclxuXHQgICAgICAgIGlmIChldmVudHMuaW5kZXhPZignY2xpY2snKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHZhciBvcGVuSGFuZGxlciA9IGZ1bmN0aW9uIG9wZW5IYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICAgICAgX3RoaXMyLnRvZ2dsZShldmVudCk7XHJcblx0ICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIGNsb3NlSGFuZGxlciA9IGZ1bmN0aW9uIGNsb3NlSGFuZGxlcihldmVudCkge1xyXG5cdCAgICAgICAgICAgIGlmICghX3RoaXMyLmlzT3BlbmVkKCkpIHtcclxuXHQgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgLy8gQ2xpY2tpbmcgaW5zaWRlIGRyb3Bkb3duXHJcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMyLmRyb3AgfHwgX3RoaXMyLmRyb3AuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICAvLyBDbGlja2luZyB0YXJnZXRcclxuXHQgICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBfdGhpczIudGFyZ2V0IHx8IF90aGlzMi50YXJnZXQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBfdGhpczIuY2xvc2UoZXZlbnQpO1xyXG5cdCAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaWNrRXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBjbGlja0V2ZW50c1tpXTtcclxuXHQgICAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgY2xpY2tFdmVudCwgb3BlbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuX29uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBjbG9zZUhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB2YXIgaW5UaW1lb3V0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBvdXRUaW1lb3V0ID0gbnVsbDtcclxuXHRcclxuXHQgICAgICAgIHZhciBpbkhhbmRsZXIgPSBmdW5jdGlvbiBpbkhhbmRsZXIoZXZlbnQpIHtcclxuXHQgICAgICAgICAgaWYgKG91dFRpbWVvdXQgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQob3V0VGltZW91dCk7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgaW5UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICBfdGhpczIub3BlbihldmVudCk7XHJcblx0ICAgICAgICAgICAgICBpblRpbWVvdXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIH0sIChldmVudC50eXBlID09PSAnZm9jdXMnID8gX3RoaXMyLm9wdGlvbnMuZm9jdXNEZWxheSA6IF90aGlzMi5vcHRpb25zLmhvdmVyT3BlbkRlbGF5KSB8fCBfdGhpczIub3B0aW9ucy5vcGVuRGVsYXkpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIG91dEhhbmRsZXIgPSBmdW5jdGlvbiBvdXRIYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICAgIGlmIChpblRpbWVvdXQgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5UaW1lb3V0KTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBvdXRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICBfdGhpczIuY2xvc2UoZXZlbnQpO1xyXG5cdCAgICAgICAgICAgICAgb3V0VGltZW91dCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgfSwgKGV2ZW50LnR5cGUgPT09ICdibHVyJyA/IF90aGlzMi5vcHRpb25zLmJsdXJEZWxheSA6IF90aGlzMi5vcHRpb25zLmhvdmVyQ2xvc2VEZWxheSkgfHwgX3RoaXMyLm9wdGlvbnMuY2xvc2VEZWxheSk7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICBpZiAoZXZlbnRzLmluZGV4T2YoJ2hvdmVyJykgPj0gMCkge1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgJ21vdXNlb3ZlcicsIGluSGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMuZHJvcCwgJ21vdXNlb3ZlcicsIGluSGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMudGFyZ2V0LCAnbW91c2VvdXQnLCBvdXRIYW5kbGVyKTtcclxuXHQgICAgICAgICAgdGhpcy5fb24odGhpcy5kcm9wLCAnbW91c2VvdXQnLCBvdXRIYW5kbGVyKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChldmVudHMuaW5kZXhPZignZm9jdXMnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMudGFyZ2V0LCAnZm9jdXMnLCBpbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLmRyb3AsICdmb2N1cycsIGluSGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMudGFyZ2V0LCAnYmx1cicsIG91dEhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLmRyb3AsICdibHVyJywgb3V0SGFuZGxlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnaXNPcGVuZWQnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW5lZCgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3RvZ2dsZScsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaXNPcGVuZWQoKSkge1xyXG5cdCAgICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHRoaXMub3BlbihldmVudCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnb3BlbicsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oZXZlbnQpIHtcclxuXHQgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiAwICovXHJcblx0ICAgICAgICBpZiAodGhpcy5pc09wZW5lZCgpKSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5kcm9wLnBhcmVudE5vZGUpIHtcclxuXHQgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyb3ApO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIuZW5hYmxlKCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLW9wZW4nKTtcclxuXHQgICAgICAgIGFkZENsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3Blbi10cmFuc2l0aW9uZW5kJyk7XHJcblx0XHJcblx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgaWYgKF90aGlzMy5kcm9wKSB7XHJcblx0ICAgICAgICAgICAgYWRkQ2xhc3MoX3RoaXMzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLWFmdGVyLW9wZW4nKTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMudGV0aGVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlci5wb3NpdGlvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdGhpcy50cmlnZ2VyKCdvcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICBkcm9wLnVwZGF0ZUJvZHlDbGFzc2VzKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnX3RyYW5zaXRpb25FbmRIYW5kbGVyJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25FbmRIYW5kbGVyKGUpIHtcclxuXHQgICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICghaGFzQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJykpIHtcclxuXHQgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuLXRyYW5zaXRpb25lbmQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZHJvcC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcik7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnYmVmb3JlQ2xvc2VIYW5kbGVyJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlQ2xvc2VIYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICB2YXIgc2hvdWxkQ2xvc2UgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2luZyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmJlZm9yZUNsb3NlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgIHRoaXMuaXNDbG9zaW5nID0gdHJ1ZTtcclxuXHQgICAgICAgICAgc2hvdWxkQ2xvc2UgPSB0aGlzLm9wdGlvbnMuYmVmb3JlQ2xvc2UoZXZlbnQsIHRoaXMpICE9PSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuaXNDbG9zaW5nID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gc2hvdWxkQ2xvc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnY2xvc2UnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShldmVudCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzT3BlbmVkKCkpIHtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmJlZm9yZUNsb3NlSGFuZGxlcihldmVudCkpIHtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJyk7XHJcblx0ICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLWFmdGVyLW9wZW4nKTtcclxuXHRcclxuXHQgICAgICAgIHRoaXMuZHJvcC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcik7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLnRyaWdnZXIoJ2Nsb3NlJyk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMudGV0aGVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlci5kaXNhYmxlKCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBkcm9wLnVwZGF0ZUJvZHlDbGFzc2VzKCk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZSkge1xyXG5cdCAgICAgICAgICB0aGlzLnJlbW92ZShldmVudCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAncmVtb3ZlJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50KSB7XHJcblx0ICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyb3AucGFyZW50Tm9kZSkge1xyXG5cdCAgICAgICAgICB0aGlzLmRyb3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRyb3ApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3Bvc2l0aW9uJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5pc09wZW5lZCgpICYmIHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIucG9zaXRpb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH0sIHtcclxuXHQgICAgICBrZXk6ICdkZXN0cm95JyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuXHQgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMudGV0aGVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlci5kZXN0cm95KCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2JvdW5kRXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgIHZhciBfYm91bmRFdmVudHMkaSA9IHRoaXMuX2JvdW5kRXZlbnRzW2ldO1xyXG5cdCAgICAgICAgICB2YXIgZWxlbWVudCA9IF9ib3VuZEV2ZW50cyRpLmVsZW1lbnQ7XHJcblx0ICAgICAgICAgIHZhciBfZXZlbnQgPSBfYm91bmRFdmVudHMkaS5ldmVudDtcclxuXHQgICAgICAgICAgdmFyIGhhbmRsZXIgPSBfYm91bmRFdmVudHMkaS5oYW5kbGVyO1xyXG5cdFxyXG5cdCAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoX2V2ZW50LCBoYW5kbGVyKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuX2JvdW5kRXZlbnRzID0gW107XHJcblx0XHJcblx0ICAgICAgICB0aGlzLnRldGhlciA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmRyb3AgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuXHRcclxuXHQgICAgICAgIHJlbW92ZUZyb21BcnJheShhbGxEcm9wc1tkcm9wLmNsYXNzUHJlZml4XSwgdGhpcyk7XHJcblx0ICAgICAgICByZW1vdmVGcm9tQXJyYXkoZHJvcC5kcm9wcywgdGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XSk7XHJcblx0XHJcblx0ICAgIHJldHVybiBEcm9wSW5zdGFuY2U7XHJcblx0ICB9KShFdmVudGVkKTtcclxuXHRcclxuXHQgIHJldHVybiBkcm9wO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgRHJvcCA9IGNyZWF0ZUNvbnRleHQoKTtcclxuXHRcclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgRHJvcC51cGRhdGVCb2R5Q2xhc3NlcygpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBEcm9wO1xyXG5cdFxyXG5cdH0pKTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIHRldGhlciAxLjIuMCAqL1xyXG5cdFxyXG5cdChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0ICBpZiAodHJ1ZSkge1xyXG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcm9vdC5UZXRoZXIgPSBmYWN0b3J5KCk7XHJcblx0ICB9XHJcblx0fSh0aGlzLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHR2YXIgVGV0aGVyQmFzZSA9IHVuZGVmaW5lZDtcclxuXHRpZiAodHlwZW9mIFRldGhlckJhc2UgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICBUZXRoZXJCYXNlID0geyBtb2R1bGVzOiBbXSB9O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWwpIHtcclxuXHQgIC8vIEluIGZpcmVmb3ggaWYgdGhlIGVsIGlzIGluc2lkZSBhbiBpZnJhbWUgd2l0aCBkaXNwbGF5OiBub25lOyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgpIHdpbGwgcmV0dXJuIG51bGw7XHJcblx0ICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcclxuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkgfHwge307XHJcblx0ICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xyXG5cdFxyXG5cdCAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnKSB7XHJcblx0ICAgIHJldHVybiBlbDtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBwYXJlbnQgPSBlbDtcclxuXHQgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xyXG5cdCAgICB2YXIgc3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0ICAgIHRyeSB7XHJcblx0ICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XHJcblx0ICAgIH0gY2F0Y2ggKGVycikge31cclxuXHRcclxuXHQgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGUgPT09IG51bGwpIHtcclxuXHQgICAgICByZXR1cm4gcGFyZW50O1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBfc3R5bGUgPSBzdHlsZTtcclxuXHQgICAgdmFyIG92ZXJmbG93ID0gX3N0eWxlLm92ZXJmbG93O1xyXG5cdCAgICB2YXIgb3ZlcmZsb3dYID0gX3N0eWxlLm92ZXJmbG93WDtcclxuXHQgICAgdmFyIG92ZXJmbG93WSA9IF9zdHlsZS5vdmVyZmxvd1k7XHJcblx0XHJcblx0ICAgIGlmICgvKGF1dG98c2Nyb2xsKS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcclxuXHQgICAgICBpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgfHwgWydyZWxhdGl2ZScsICdhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2Yoc3R5bGUucG9zaXRpb24pID49IDApIHtcclxuXHQgICAgICAgIHJldHVybiBwYXJlbnQ7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gZG9jdW1lbnQuYm9keTtcclxuXHR9XHJcblx0XHJcblx0dmFyIHVuaXF1ZUlkID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIHZhciBpZCA9IDA7XHJcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdCAgICByZXR1cm4gKytpZDtcclxuXHQgIH07XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgemVyb1Bvc0NhY2hlID0ge307XHJcblx0dmFyIGdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbihkb2MpIHtcclxuXHQgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB1bmZvcnR1bmF0ZWx5IHRvbyBhY2N1cmF0ZS4gIEl0IGludHJvZHVjZXMgYSBwaXhlbCBvciB0d28gb2ZcclxuXHQgIC8vIGppdHRlciBhcyB0aGUgdXNlciBzY3JvbGxzIHRoYXQgbWVzc2VzIHdpdGggb3VyIGFiaWxpdHkgdG8gZGV0ZWN0IGlmIHR3byBwb3NpdGlvbnNcclxuXHQgIC8vIGFyZSBlcXVpdmlsYW50IG9yIG5vdC4gIFdlIHBsYWNlIGFuIGVsZW1lbnQgYXQgdGhlIHRvcCBsZWZ0IG9mIHRoZSBwYWdlIHRoYXQgd2lsbFxyXG5cdCAgLy8gZ2V0IHRoZSBzYW1lIGppdHRlciwgc28gd2UgY2FuIGNhbmNlbCB0aGUgdHdvIG91dC5cclxuXHQgIHZhciBub2RlID0gZG9jLl90ZXRoZXJaZXJvRWxlbWVudDtcclxuXHQgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgbm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHQgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGV0aGVyLWlkJywgdW5pcXVlSWQoKSk7XHJcblx0ICAgIGV4dGVuZChub2RlLnN0eWxlLCB7XHJcblx0ICAgICAgdG9wOiAwLFxyXG5cdCAgICAgIGxlZnQ6IDAsXHJcblx0ICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xyXG5cdFxyXG5cdCAgICBkb2MuX3RldGhlclplcm9FbGVtZW50ID0gbm9kZTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRldGhlci1pZCcpO1xyXG5cdCAgaWYgKHR5cGVvZiB6ZXJvUG9zQ2FjaGVbaWRdID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICB6ZXJvUG9zQ2FjaGVbaWRdID0ge307XHJcblx0XHJcblx0ICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHQgICAgZm9yICh2YXIgayBpbiByZWN0KSB7XHJcblx0ICAgICAgLy8gQ2FuJ3QgdXNlIGV4dGVuZCwgYXMgb24gSUU5LCBlbGVtZW50cyBkb24ndCByZXNvbHZlIHRvIGJlIGhhc093blByb3BlcnR5XHJcblx0ICAgICAgemVyb1Bvc0NhY2hlW2lkXVtrXSA9IHJlY3Rba107XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgLy8gQ2xlYXIgdGhlIGNhY2hlIHdoZW4gdGhpcyBwb3NpdGlvbiBjYWxsIGlzIGRvbmVcclxuXHQgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIGRlbGV0ZSB6ZXJvUG9zQ2FjaGVbaWRdO1xyXG5cdCAgICB9KTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB6ZXJvUG9zQ2FjaGVbaWRdO1xyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0Qm91bmRzKGVsKSB7XHJcblx0ICB2YXIgZG9jID0gdW5kZWZpbmVkO1xyXG5cdCAgaWYgKGVsID09PSBkb2N1bWVudCkge1xyXG5cdCAgICBkb2MgPSBkb2N1bWVudDtcclxuXHQgICAgZWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcclxuXHQgIHZhciBib3ggPSB7fTtcclxuXHQgIC8vIFRoZSBvcmlnaW5hbCBvYmplY3QgcmV0dXJuZWQgYnkgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGltbXV0YWJsZSwgc28gd2UgY2xvbmUgaXRcclxuXHQgIC8vIFdlIGNhbid0IHVzZSBleHRlbmQgYmVjYXVzZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgb2JqZWN0IGJ5IGhhc093blByb3BlcnR5IGluIElFOVxyXG5cdCAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHQgIGZvciAodmFyIGsgaW4gcmVjdCkge1xyXG5cdCAgICBib3hba10gPSByZWN0W2tdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbihkb2MpO1xyXG5cdFxyXG5cdCAgYm94LnRvcCAtPSBvcmlnaW4udG9wO1xyXG5cdCAgYm94LmxlZnQgLT0gb3JpZ2luLmxlZnQ7XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIGJveC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgYm94LndpZHRoID0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCAtIGJveC5sZWZ0IC0gYm94LnJpZ2h0O1xyXG5cdCAgfVxyXG5cdCAgaWYgKHR5cGVvZiBib3guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBib3guaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSBib3gudG9wIC0gYm94LmJvdHRvbTtcclxuXHQgIH1cclxuXHRcclxuXHQgIGJveC50b3AgPSBib3gudG9wIC0gZG9jRWwuY2xpZW50VG9wO1xyXG5cdCAgYm94LmxlZnQgPSBib3gubGVmdCAtIGRvY0VsLmNsaWVudExlZnQ7XHJcblx0ICBib3gucmlnaHQgPSBkb2MuYm9keS5jbGllbnRXaWR0aCAtIGJveC53aWR0aCAtIGJveC5sZWZ0O1xyXG5cdCAgYm94LmJvdHRvbSA9IGRvYy5ib2R5LmNsaWVudEhlaWdodCAtIGJveC5oZWlnaHQgLSBib3gudG9wO1xyXG5cdFxyXG5cdCAgcmV0dXJuIGJveDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsKSB7XHJcblx0ICByZXR1cm4gZWwub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0U2Nyb2xsQmFyU2l6ZSgpIHtcclxuXHQgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblx0ICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xyXG5cdFxyXG5cdCAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICBleHRlbmQob3V0ZXIuc3R5bGUsIHtcclxuXHQgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcblx0ICAgIHRvcDogMCxcclxuXHQgICAgbGVmdDogMCxcclxuXHQgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxyXG5cdCAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcclxuXHQgICAgd2lkdGg6ICcyMDBweCcsXHJcblx0ICAgIGhlaWdodDogJzE1MHB4JyxcclxuXHQgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcblx0ICB9KTtcclxuXHRcclxuXHQgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcclxuXHRcclxuXHQgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xyXG5cdFxyXG5cdCAgdmFyIHdpZHRoQ29udGFpbmVkID0gaW5uZXIub2Zmc2V0V2lkdGg7XHJcblx0ICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xyXG5cdCAgdmFyIHdpZHRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XHJcblx0XHJcblx0ICBpZiAod2lkdGhDb250YWluZWQgPT09IHdpZHRoU2Nyb2xsKSB7XHJcblx0ICAgIHdpZHRoU2Nyb2xsID0gb3V0ZXIuY2xpZW50V2lkdGg7XHJcblx0ICB9XHJcblx0XHJcblx0ICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcclxuXHRcclxuXHQgIHZhciB3aWR0aCA9IHdpZHRoQ29udGFpbmVkIC0gd2lkdGhTY3JvbGw7XHJcblx0XHJcblx0ICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogd2lkdGggfTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG5cdCAgdmFyIG91dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xyXG5cdFxyXG5cdCAgdmFyIGFyZ3MgPSBbXTtcclxuXHRcclxuXHQgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XHJcblx0XHJcblx0ICBhcmdzLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG5cdCAgICBpZiAob2JqKSB7XHJcblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG5cdCAgICAgICAgaWYgKCh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuXHQgICAgICAgICAgb3V0W2tleV0gPSBvYmpba2V5XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIG91dDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHQgIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcblx0ICAgICAgaWYgKGNscy50cmltKCkpIHtcclxuXHQgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoIHwkKScsICdnaScpO1xyXG5cdCAgICB2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKGVsKS5yZXBsYWNlKHJlZ2V4LCAnICcpO1xyXG5cdCAgICBzZXRDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSk7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0ICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICAgIGlmIChjbHMudHJpbSgpKSB7XHJcblx0ICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcclxuXHQgICAgdmFyIGNscyA9IGdldENsYXNzTmFtZShlbCkgKyAoJyAnICsgbmFtZSk7XHJcblx0ICAgIHNldENsYXNzTmFtZShlbCwgY2xzKTtcclxuXHQgIH1cclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHQgIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdCAgfVxyXG5cdCAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCk7XHJcblx0ICByZXR1cm4gbmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZSArICcoIHwkKScsICdnaScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGVsKSB7XHJcblx0ICBpZiAoZWwuY2xhc3NOYW1lIGluc3RhbmNlb2YgU1ZHQW5pbWF0ZWRTdHJpbmcpIHtcclxuXHQgICAgcmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpIHtcclxuXHQgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKGVsLCBhZGQsIGFsbCkge1xyXG5cdCAgLy8gT2YgdGhlIHNldCBvZiAnYWxsJyBjbGFzc2VzLCB3ZSBuZWVkIHRoZSAnYWRkJyBjbGFzc2VzLCBhbmQgb25seSB0aGVcclxuXHQgIC8vICdhZGQnIGNsYXNzZXMgdG8gYmUgc2V0LlxyXG5cdCAgYWxsLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICBpZiAoYWRkLmluZGV4T2YoY2xzKSA9PT0gLTEgJiYgaGFzQ2xhc3MoZWwsIGNscykpIHtcclxuXHQgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0XHJcblx0ICBhZGQuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcblx0ICAgIGlmICghaGFzQ2xhc3MoZWwsIGNscykpIHtcclxuXHQgICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBkZWZlcnJlZCA9IFtdO1xyXG5cdFxyXG5cdHZhciBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGZuKSB7XHJcblx0ICBkZWZlcnJlZC5wdXNoKGZuKTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xyXG5cdCAgdmFyIGZuID0gdW5kZWZpbmVkO1xyXG5cdCAgd2hpbGUgKGZuID0gZGVmZXJyZWQucG9wKCkpIHtcclxuXHQgICAgZm4oKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdHZhciBFdmVudGVkID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIGZ1bmN0aW9uIEV2ZW50ZWQoKSB7XHJcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudGVkKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIF9jcmVhdGVDbGFzcyhFdmVudGVkLCBbe1xyXG5cdCAgICBrZXk6ICdvbicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgY3R4KSB7XHJcblx0ICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5nc1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlcjogaGFuZGxlciwgY3R4OiBjdHgsIG9uY2U6IG9uY2UgfSk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnb25jZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcclxuXHQgICAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIHRydWUpO1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ29mZicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLmJpbmRpbmdzW2V2ZW50XSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHJldHVybjtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbZXZlbnRdO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB2YXIgaSA9IDA7XHJcblx0ICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYmluZGluZ3NbZXZlbnRdLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tldmVudF1baV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICArK2k7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAndHJpZ2dlcicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50KSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmJpbmRpbmdzW2V2ZW50XSkge1xyXG5cdCAgICAgICAgdmFyIGkgPSAwO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcblx0ICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgdmFyIF9iaW5kaW5ncyRldmVudCRpID0gdGhpcy5iaW5kaW5nc1tldmVudF1baV07XHJcblx0ICAgICAgICAgIHZhciBoYW5kbGVyID0gX2JpbmRpbmdzJGV2ZW50JGkuaGFuZGxlcjtcclxuXHQgICAgICAgICAgdmFyIGN0eCA9IF9iaW5kaW5ncyRldmVudCRpLmN0eDtcclxuXHQgICAgICAgICAgdmFyIG9uY2UgPSBfYmluZGluZ3MkZXZlbnQkaS5vbmNlO1xyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgY29udGV4dCA9IGN0eDtcclxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHJcblx0ICAgICAgICAgIGlmIChvbmNlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICsraTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfV0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIEV2ZW50ZWQ7XHJcblx0fSkoKTtcclxuXHRcclxuXHRUZXRoZXJCYXNlLlV0aWxzID0ge1xyXG5cdCAgZ2V0U2Nyb2xsUGFyZW50OiBnZXRTY3JvbGxQYXJlbnQsXHJcblx0ICBnZXRCb3VuZHM6IGdldEJvdW5kcyxcclxuXHQgIGdldE9mZnNldFBhcmVudDogZ2V0T2Zmc2V0UGFyZW50LFxyXG5cdCAgZXh0ZW5kOiBleHRlbmQsXHJcblx0ICBhZGRDbGFzczogYWRkQ2xhc3MsXHJcblx0ICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXHJcblx0ICBoYXNDbGFzczogaGFzQ2xhc3MsXHJcblx0ICB1cGRhdGVDbGFzc2VzOiB1cGRhdGVDbGFzc2VzLFxyXG5cdCAgZGVmZXI6IGRlZmVyLFxyXG5cdCAgZmx1c2g6IGZsdXNoLFxyXG5cdCAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxyXG5cdCAgRXZlbnRlZDogRXZlbnRlZCxcclxuXHQgIGdldFNjcm9sbEJhclNpemU6IGdldFNjcm9sbEJhclNpemVcclxuXHR9O1xyXG5cdC8qIGdsb2JhbHMgVGV0aGVyQmFzZSwgcGVyZm9ybWFuY2UgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XHJcblx0XHJcblx0dmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHRpZiAodHlwZW9mIFRldGhlckJhc2UgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGluY2x1ZGUgdGhlIHV0aWxzLmpzIGZpbGUgYmVmb3JlIHRldGhlci5qcycpO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xyXG5cdHZhciBnZXRTY3JvbGxQYXJlbnQgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRTY3JvbGxQYXJlbnQ7XHJcblx0dmFyIGdldEJvdW5kcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldEJvdW5kcztcclxuXHR2YXIgZ2V0T2Zmc2V0UGFyZW50ID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0T2Zmc2V0UGFyZW50O1xyXG5cdHZhciBleHRlbmQgPSBfVGV0aGVyQmFzZSRVdGlscy5leHRlbmQ7XHJcblx0dmFyIGFkZENsYXNzID0gX1RldGhlckJhc2UkVXRpbHMuYWRkQ2xhc3M7XHJcblx0dmFyIHJlbW92ZUNsYXNzID0gX1RldGhlckJhc2UkVXRpbHMucmVtb3ZlQ2xhc3M7XHJcblx0dmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xyXG5cdHZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xyXG5cdHZhciBmbHVzaCA9IF9UZXRoZXJCYXNlJFV0aWxzLmZsdXNoO1xyXG5cdHZhciBnZXRTY3JvbGxCYXJTaXplID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0U2Nyb2xsQmFyU2l6ZTtcclxuXHRcclxuXHRmdW5jdGlvbiB3aXRoaW4oYSwgYikge1xyXG5cdCAgdmFyIGRpZmYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAxIDogYXJndW1lbnRzWzJdO1xyXG5cdFxyXG5cdCAgcmV0dXJuIGEgKyBkaWZmID49IGIgJiYgYiA+PSBhIC0gZGlmZjtcclxuXHR9XHJcblx0XHJcblx0dmFyIHRyYW5zZm9ybUtleSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICByZXR1cm4gJyc7XHJcblx0ICB9XHJcblx0ICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcclxuXHQgIHZhciB0cmFuc2Zvcm1zID0gWyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ107XHJcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgdmFyIGtleSA9IHRyYW5zZm9ybXNbaV07XHJcblx0ICAgIGlmIChlbC5zdHlsZVtrZXldICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICByZXR1cm4ga2V5O1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgdGV0aGVycyA9IFtdO1xyXG5cdFxyXG5cdHZhciBwb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG5cdCAgdGV0aGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXRoZXIpIHtcclxuXHQgICAgdGV0aGVyLnBvc2l0aW9uKGZhbHNlKTtcclxuXHQgIH0pO1xyXG5cdCAgZmx1c2goKTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG5vdygpIHtcclxuXHQgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHQgIH1cclxuXHQgIHJldHVybiArbmV3IERhdGUoKTtcclxuXHR9XHJcblx0XHJcblx0KGZ1bmN0aW9uICgpIHtcclxuXHQgIHZhciBsYXN0Q2FsbCA9IG51bGw7XHJcblx0ICB2YXIgbGFzdER1cmF0aW9uID0gbnVsbDtcclxuXHQgIHZhciBwZW5kaW5nVGltZW91dCA9IG51bGw7XHJcblx0XHJcblx0ICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgbGFzdER1cmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsYXN0RHVyYXRpb24gPiAxNikge1xyXG5cdCAgICAgIC8vIFdlIHZvbHVudGFyaWx5IHRocm90dGxlIG91cnNlbHZlcyBpZiB3ZSBjYW4ndCBtYW5hZ2UgNjBmcHNcclxuXHQgICAgICBsYXN0RHVyYXRpb24gPSBNYXRoLm1pbihsYXN0RHVyYXRpb24gLSAxNiwgMjUwKTtcclxuXHRcclxuXHQgICAgICAvLyBKdXN0IGluIGNhc2UgdGhpcyBpcyB0aGUgbGFzdCBldmVudCwgcmVtZW1iZXIgdG8gcG9zaXRpb24ganVzdCBvbmNlIG1vcmVcclxuXHQgICAgICBwZW5kaW5nVGltZW91dCA9IHNldFRpbWVvdXQodGljaywgMjUwKTtcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHR5cGVvZiBsYXN0Q2FsbCAhPT0gJ3VuZGVmaW5lZCcgJiYgbm93KCkgLSBsYXN0Q2FsbCA8IDEwKSB7XHJcblx0ICAgICAgLy8gU29tZSBicm93c2VycyBjYWxsIGV2ZW50cyBhIGxpdHRsZSB0b28gZnJlcXVlbnRseSwgcmVmdXNlIHRvIHJ1biBtb3JlIHRoYW4gaXMgcmVhc29uYWJsZVxyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHBlbmRpbmdUaW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nVGltZW91dCk7XHJcblx0ICAgICAgcGVuZGluZ1RpbWVvdXQgPSBudWxsO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGxhc3RDYWxsID0gbm93KCk7XHJcblx0ICAgIHBvc2l0aW9uKCk7XHJcblx0ICAgIGxhc3REdXJhdGlvbiA9IG5vdygpIC0gbGFzdENhbGw7XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIFsncmVzaXplJywgJ3Njcm9sbCcsICd0b3VjaG1vdmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aWNrKTtcclxuXHQgICAgfSk7XHJcblx0ICB9XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgTUlSUk9SX0xSID0ge1xyXG5cdCAgY2VudGVyOiAnY2VudGVyJyxcclxuXHQgIGxlZnQ6ICdyaWdodCcsXHJcblx0ICByaWdodDogJ2xlZnQnXHJcblx0fTtcclxuXHRcclxuXHR2YXIgTUlSUk9SX1RCID0ge1xyXG5cdCAgbWlkZGxlOiAnbWlkZGxlJyxcclxuXHQgIHRvcDogJ2JvdHRvbScsXHJcblx0ICBib3R0b206ICd0b3AnXHJcblx0fTtcclxuXHRcclxuXHR2YXIgT0ZGU0VUX01BUCA9IHtcclxuXHQgIHRvcDogMCxcclxuXHQgIGxlZnQ6IDAsXHJcblx0ICBtaWRkbGU6ICc1MCUnLFxyXG5cdCAgY2VudGVyOiAnNTAlJyxcclxuXHQgIGJvdHRvbTogJzEwMCUnLFxyXG5cdCAgcmlnaHQ6ICcxMDAlJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGF1dG9Ub0ZpeGVkQXR0YWNobWVudCA9IGZ1bmN0aW9uIGF1dG9Ub0ZpeGVkQXR0YWNobWVudChhdHRhY2htZW50LCByZWxhdGl2ZVRvQXR0YWNobWVudCkge1xyXG5cdCAgdmFyIGxlZnQgPSBhdHRhY2htZW50LmxlZnQ7XHJcblx0ICB2YXIgdG9wID0gYXR0YWNobWVudC50b3A7XHJcblx0XHJcblx0ICBpZiAobGVmdCA9PT0gJ2F1dG8nKSB7XHJcblx0ICAgIGxlZnQgPSBNSVJST1JfTFJbcmVsYXRpdmVUb0F0dGFjaG1lbnQubGVmdF07XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAodG9wID09PSAnYXV0bycpIHtcclxuXHQgICAgdG9wID0gTUlSUk9SX1RCW3JlbGF0aXZlVG9BdHRhY2htZW50LnRvcF07XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGF0dGFjaG1lbnRUb09mZnNldCA9IGZ1bmN0aW9uIGF0dGFjaG1lbnRUb09mZnNldChhdHRhY2htZW50KSB7XHJcblx0ICB2YXIgbGVmdCA9IGF0dGFjaG1lbnQubGVmdDtcclxuXHQgIHZhciB0b3AgPSBhdHRhY2htZW50LnRvcDtcclxuXHRcclxuXHQgIGlmICh0eXBlb2YgT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBsZWZ0ID0gT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiBPRkZTRVRfTUFQW2F0dGFjaG1lbnQudG9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgdG9wID0gT0ZGU0VUX01BUFthdHRhY2htZW50LnRvcF07XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gYWRkT2Zmc2V0KCkge1xyXG5cdCAgdmFyIG91dCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcblx0XHJcblx0ICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb2Zmc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG5cdCAgICBvZmZzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XHJcblx0ICAgIHZhciB0b3AgPSBfcmVmLnRvcDtcclxuXHQgICAgdmFyIGxlZnQgPSBfcmVmLmxlZnQ7XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdG9wID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgIHRvcCA9IHBhcnNlRmxvYXQodG9wLCAxMCk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgIGxlZnQgPSBwYXJzZUZsb2F0KGxlZnQsIDEwKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBvdXQudG9wICs9IHRvcDtcclxuXHQgICAgb3V0LmxlZnQgKz0gbGVmdDtcclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIG91dDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gb2Zmc2V0VG9QeChvZmZzZXQsIHNpemUpIHtcclxuXHQgIGlmICh0eXBlb2Ygb2Zmc2V0LmxlZnQgPT09ICdzdHJpbmcnICYmIG9mZnNldC5sZWZ0LmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcclxuXHQgICAgb2Zmc2V0LmxlZnQgPSBwYXJzZUZsb2F0KG9mZnNldC5sZWZ0LCAxMCkgLyAxMDAgKiBzaXplLndpZHRoO1xyXG5cdCAgfVxyXG5cdCAgaWYgKHR5cGVvZiBvZmZzZXQudG9wID09PSAnc3RyaW5nJyAmJiBvZmZzZXQudG9wLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcclxuXHQgICAgb2Zmc2V0LnRvcCA9IHBhcnNlRmxvYXQob2Zmc2V0LnRvcCwgMTApIC8gMTAwICogc2l6ZS5oZWlnaHQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gb2Zmc2V0O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgcGFyc2VPZmZzZXQgPSBmdW5jdGlvbiBwYXJzZU9mZnNldCh2YWx1ZSkge1xyXG5cdCAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCcgJyk7XHJcblx0XHJcblx0ICB2YXIgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMik7XHJcblx0XHJcblx0ICB2YXIgdG9wID0gX3ZhbHVlJHNwbGl0MlswXTtcclxuXHQgIHZhciBsZWZ0ID0gX3ZhbHVlJHNwbGl0MlsxXTtcclxuXHRcclxuXHQgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XHJcblx0fTtcclxuXHR2YXIgcGFyc2VBdHRhY2htZW50ID0gcGFyc2VPZmZzZXQ7XHJcblx0XHJcblx0dmFyIFRldGhlckNsYXNzID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIGZ1bmN0aW9uIFRldGhlckNsYXNzKG9wdGlvbnMpIHtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRldGhlckNsYXNzKTtcclxuXHRcclxuXHQgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYmluZCh0aGlzKTtcclxuXHRcclxuXHQgICAgdGV0aGVycy5wdXNoKHRoaXMpO1xyXG5cdFxyXG5cdCAgICB0aGlzLmhpc3RvcnkgPSBbXTtcclxuXHRcclxuXHQgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIGZhbHNlKTtcclxuXHRcclxuXHQgICAgVGV0aGVyQmFzZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xyXG5cdCAgICAgIGlmICh0eXBlb2YgbW9kdWxlLmluaXRpYWxpemUgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZS5jYWxsKF90aGlzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB0aGlzLnBvc2l0aW9uKCk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBfY3JlYXRlQ2xhc3MoVGV0aGVyQ2xhc3MsIFt7XHJcblx0ICAgIGtleTogJ2dldENsYXNzJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsYXNzKCkge1xyXG5cdCAgICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnJyA6IGFyZ3VtZW50c1swXTtcclxuXHQgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5jbGFzc2VzO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgY2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2xhc3Nlc1trZXldKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsYXNzZXNba2V5XTtcclxuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCArICctJyArIGtleTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgcmV0dXJuIGtleTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnc2V0T3B0aW9ucycsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuXHQgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHRcclxuXHQgICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcclxuXHRcclxuXHQgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcblx0ICAgICAgICBvZmZzZXQ6ICcwIDAnLFxyXG5cdCAgICAgICAgdGFyZ2V0T2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6ICdhdXRvIGF1dG8nLFxyXG5cdCAgICAgICAgY2xhc3NQcmVmaXg6ICd0ZXRoZXInXHJcblx0ICAgICAgfTtcclxuXHRcclxuXHQgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cdFxyXG5cdCAgICAgIHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHQgICAgICB2YXIgZWxlbWVudCA9IF9vcHRpb25zLmVsZW1lbnQ7XHJcblx0ICAgICAgdmFyIHRhcmdldCA9IF9vcHRpb25zLnRhcmdldDtcclxuXHQgICAgICB2YXIgdGFyZ2V0TW9kaWZpZXIgPSBfb3B0aW9ucy50YXJnZXRNb2RpZmllcjtcclxuXHRcclxuXHQgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSB0YXJnZXRNb2RpZmllcjtcclxuXHRcclxuXHQgICAgICBpZiAodGhpcy50YXJnZXQgPT09ICd2aWV3cG9ydCcpIHtcclxuXHQgICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcclxuXHQgICAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSAndmlzaWJsZSc7XHJcblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LmJvZHk7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Njcm9sbC1oYW5kbGUnO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBbJ2VsZW1lbnQnLCAndGFyZ2V0J10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcblx0ICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RldGhlciBFcnJvcjogQm90aCBlbGVtZW50IGFuZCB0YXJnZXQgbXVzdCBiZSBkZWZpbmVkJyk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldLmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgX3RoaXMyW2tleV0gPSBfdGhpczJba2V5XVswXTtcclxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICBfdGhpczJba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMyW2tleV0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZWxlbWVudCcpKTtcclxuXHQgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygndGFyZ2V0JykpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hdHRhY2htZW50KSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RldGhlciBFcnJvcjogWW91IG11c3QgcHJvdmlkZSBhbiBhdHRhY2htZW50Jyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHRoaXMudGFyZ2V0QXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudCh0aGlzLm9wdGlvbnMudGFyZ2V0QXR0YWNobWVudCk7XHJcblx0ICAgICAgdGhpcy5hdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHRoaXMub3B0aW9ucy5hdHRhY2htZW50KTtcclxuXHQgICAgICB0aGlzLm9mZnNldCA9IHBhcnNlT2Zmc2V0KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0T2Zmc2V0ID0gcGFyc2VPZmZzZXQodGhpcy5vcHRpb25zLnRhcmdldE9mZnNldCk7XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLnNjcm9sbFBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodGhpcy50YXJnZXRNb2RpZmllciA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0O1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLnRhcmdldCk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICghKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIHRoaXMuZW5hYmxlKHBvcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2dldFRhcmdldEJvdW5kcycsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYXJnZXRCb3VuZHMoKSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhcmdldE1vZGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICd2aXNpYmxlJykge1xyXG5cdCAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4geyB0b3A6IHBhZ2VZT2Zmc2V0LCBsZWZ0OiBwYWdlWE9mZnNldCwgaGVpZ2h0OiBpbm5lckhlaWdodCwgd2lkdGg6IGlubmVyV2lkdGggfTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRzKHRoaXMudGFyZ2V0KTtcclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgb3V0ID0ge1xyXG5cdCAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxyXG5cdCAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcclxuXHQgICAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCxcclxuXHQgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCAtIGJvdW5kcy50b3ApKTtcclxuXHQgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCArIGlubmVySGVpZ2h0KSkpO1xyXG5cdCAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihpbm5lckhlaWdodCwgb3V0LmhlaWdodCk7XHJcblx0ICAgICAgICAgICAgb3V0LmhlaWdodCAtPSAyO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIG91dC53aWR0aCA9IE1hdGgubWluKG91dC53aWR0aCwgYm91bmRzLndpZHRoIC0gKHBhZ2VYT2Zmc2V0IC0gYm91bmRzLmxlZnQpKTtcclxuXHQgICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihvdXQud2lkdGgsIGJvdW5kcy53aWR0aCAtIChib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIChwYWdlWE9mZnNldCArIGlubmVyV2lkdGgpKSk7XHJcblx0ICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4oaW5uZXJXaWR0aCwgb3V0LndpZHRoKTtcclxuXHQgICAgICAgICAgICBvdXQud2lkdGggLT0gMjtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAob3V0LnRvcCA8IHBhZ2VZT2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICBvdXQudG9wID0gcGFnZVlPZmZzZXQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChvdXQubGVmdCA8IHBhZ2VYT2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICBvdXQubGVmdCA9IHBhZ2VYT2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xyXG5cdCAgICAgICAgICB2YXIgYm91bmRzID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcblx0ICAgICAgICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHJcblx0ICAgICAgICAgICAgYm91bmRzID0ge1xyXG5cdCAgICAgICAgICAgICAgbGVmdDogcGFnZVhPZmZzZXQsXHJcblx0ICAgICAgICAgICAgICB0b3A6IHBhZ2VZT2Zmc2V0LFxyXG5cdCAgICAgICAgICAgICAgaGVpZ2h0OiBpbm5lckhlaWdodCxcclxuXHQgICAgICAgICAgICAgIHdpZHRoOiBpbm5lcldpZHRoXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBib3VuZHMgPSBnZXRCb3VuZHModGFyZ2V0KTtcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBoYXNCb3R0b21TY3JvbGwgPSB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGggfHwgW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1hdLmluZGV4T2YoJ3Njcm9sbCcpID49IDAgfHwgdGhpcy50YXJnZXQgIT09IGRvY3VtZW50LmJvZHk7XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBzY3JvbGxCb3R0b20gPSAwO1xyXG5cdCAgICAgICAgICBpZiAoaGFzQm90dG9tU2Nyb2xsKSB7XHJcblx0ICAgICAgICAgICAgc2Nyb2xsQm90dG9tID0gMTU7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKSAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIC0gc2Nyb2xsQm90dG9tO1xyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgb3V0ID0ge1xyXG5cdCAgICAgICAgICAgIHdpZHRoOiAxNSxcclxuXHQgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIDAuOTc1ICogKGhlaWdodCAvIHRhcmdldC5zY3JvbGxIZWlnaHQpLFxyXG5cdCAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIC0gMTVcclxuXHQgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIGZpdEFkaiA9IDA7XHJcblx0ICAgICAgICAgIGlmIChoZWlnaHQgPCA0MDggJiYgdGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICBmaXRBZGogPSAtMC4wMDAxMSAqIE1hdGgucG93KGhlaWdodCwgMikgLSAwLjAwNzI3ICogaGVpZ2h0ICsgMjIuNTg7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0ICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgc2Nyb2xsUGVyY2VudGFnZSA9IHRoaXMudGFyZ2V0LnNjcm9sbFRvcCAvICh0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0KTtcclxuXHQgICAgICAgICAgb3V0LnRvcCA9IHNjcm9sbFBlcmNlbnRhZ2UgKiAoaGVpZ2h0IC0gb3V0LmhlaWdodCAtIGZpdEFkaikgKyBib3VuZHMudG9wICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCk7XHJcblx0XHJcblx0ICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xyXG5cdCAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1heChvdXQuaGVpZ2h0LCAyNCk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgcmV0dXJuIGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2NsZWFyQ2FjaGUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuXHQgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2NhY2hlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNhY2hlKGssIGdldHRlcikge1xyXG5cdCAgICAgIC8vIE1vcmUgdGhhbiBvbmUgbW9kdWxlIHdpbGwgb2Z0ZW4gbmVlZCB0aGUgc2FtZSBET00gaW5mbywgc29cclxuXHQgICAgICAvLyB3ZSBrZWVwIGEgY2FjaGUgd2hpY2ggaXMgY2xlYXJlZCBvbiBlYWNoIHBvc2l0aW9uIGNhbGxcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuX2NhY2hlID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZVtrXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHRoaXMuX2NhY2hlW2tdID0gZ2V0dGVyLmNhbGwodGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtrXTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdlbmFibGUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xyXG5cdCAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xyXG5cdFxyXG5cdCAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIGFkZENsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XHJcblx0ICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQgIT09IGRvY3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnBvc2l0aW9uKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHBvcykge1xyXG5cdCAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdkaXNhYmxlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xyXG5cdCAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5zY3JvbGxQYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnBvc2l0aW9uKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnZGVzdHJveScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG5cdCAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG5cdFxyXG5cdCAgICAgIHRldGhlcnMuZm9yRWFjaChmdW5jdGlvbiAodGV0aGVyLCBpKSB7XHJcblx0ICAgICAgICBpZiAodGV0aGVyID09PSBfdGhpczMpIHtcclxuXHQgICAgICAgICAgdGV0aGVycy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICd1cGRhdGVBdHRhY2hDbGFzc2VzJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUF0dGFjaENsYXNzZXMoZWxlbWVudEF0dGFjaCwgdGFyZ2V0QXR0YWNoKSB7XHJcblx0ICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XHJcblx0XHJcblx0ICAgICAgZWxlbWVudEF0dGFjaCA9IGVsZW1lbnRBdHRhY2ggfHwgdGhpcy5hdHRhY2htZW50O1xyXG5cdCAgICAgIHRhcmdldEF0dGFjaCA9IHRhcmdldEF0dGFjaCB8fCB0aGlzLnRhcmdldEF0dGFjaG1lbnQ7XHJcblx0ICAgICAgdmFyIHNpZGVzID0gWydsZWZ0JywgJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbWlkZGxlJywgJ2NlbnRlciddO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5sZW5ndGgpIHtcclxuXHQgICAgICAgIC8vIHVwZGF0ZUF0dGFjaENsYXNzZXMgY2FuIGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBpbiBhIHBvc2l0aW9uIGNhbGwsIHNvXHJcblx0ICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlcyBzdWNoIHRoYXQgd2hlbiB0aGUgbGFzdCBkZWZlciBnZXRzXHJcblx0ICAgICAgICAvLyByYW4gaXQgZG9lc24ndCBhZGQgYW55IGV4dHJhIGNsYXNzZXMgZnJvbSBwcmV2aW91cyBjYWxscy5cclxuXHQgICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMuc3BsaWNlKDAsIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMubGVuZ3RoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA9IFtdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB2YXIgYWRkID0gdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcztcclxuXHRcclxuXHQgICAgICBpZiAoZWxlbWVudEF0dGFjaC50b3ApIHtcclxuXHQgICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIGVsZW1lbnRBdHRhY2gudG9wKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKGVsZW1lbnRBdHRhY2gubGVmdCkge1xyXG5cdCAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpICsgJy0nICsgZWxlbWVudEF0dGFjaC5sZWZ0KTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRhcmdldEF0dGFjaC50b3ApIHtcclxuXHQgICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgdGFyZ2V0QXR0YWNoLnRvcCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0YXJnZXRBdHRhY2gubGVmdCkge1xyXG5cdCAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyB0YXJnZXRBdHRhY2gubGVmdCk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBhbGwgPSBbXTtcclxuXHQgICAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICBhbGwucHVzaChfdGhpczQuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xyXG5cdCAgICAgICAgYWxsLnB1c2goX3RoaXM0LmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xyXG5cdCAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghKHR5cGVvZiBfdGhpczQuX2FkZEF0dGFjaENsYXNzZXMgIT09ICd1bmRlZmluZWQnKSkge1xyXG5cdCAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzNC5lbGVtZW50LCBfdGhpczQuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XHJcblx0ICAgICAgICBpZiAoIShfdGhpczQub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpczQudGFyZ2V0LCBfdGhpczQuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBkZWxldGUgX3RoaXM0Ll9hZGRBdHRhY2hDbGFzc2VzO1xyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ3Bvc2l0aW9uJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG5cdCAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIHZhciBmbHVzaENoYW5nZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xyXG5cdFxyXG5cdCAgICAgIC8vIGZsdXNoQ2hhbmdlcyBjb21taXRzIHRoZSBjaGFuZ2VzIGltbWVkaWF0ZWx5LCBsZWF2ZSB0cnVlIHVubGVzcyB5b3UgYXJlIHBvc2l0aW9uaW5nIG11bHRpcGxlXHJcblx0ICAgICAgLy8gdGV0aGVycyAoaW4gd2hpY2ggY2FzZSBjYWxsIFRldGhlci5VdGlscy5mbHVzaCB5b3Vyc2VsZiB3aGVuIHlvdSdyZSBkb25lKVxyXG5cdFxyXG5cdCAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG5cdFxyXG5cdCAgICAgIC8vIFR1cm4gJ2F1dG8nIGF0dGFjaG1lbnRzIGludG8gdGhlIGFwcHJvcHJpYXRlIGNvcm5lciBvciBlZGdlXHJcblx0ICAgICAgdmFyIHRhcmdldEF0dGFjaG1lbnQgPSBhdXRvVG9GaXhlZEF0dGFjaG1lbnQodGhpcy50YXJnZXRBdHRhY2htZW50LCB0aGlzLmF0dGFjaG1lbnQpO1xyXG5cdFxyXG5cdCAgICAgIHRoaXMudXBkYXRlQXR0YWNoQ2xhc3Nlcyh0aGlzLmF0dGFjaG1lbnQsIHRhcmdldEF0dGFjaG1lbnQpO1xyXG5cdFxyXG5cdCAgICAgIHZhciBlbGVtZW50UG9zID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzNS5lbGVtZW50KTtcclxuXHQgICAgICB9KTtcclxuXHRcclxuXHQgICAgICB2YXIgd2lkdGggPSBlbGVtZW50UG9zLndpZHRoO1xyXG5cdCAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50UG9zLmhlaWdodDtcclxuXHRcclxuXHQgICAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XHJcblx0XHJcblx0ICAgICAgICAvLyBXZSBjYWNoZSB0aGUgaGVpZ2h0IGFuZCB3aWR0aCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHBvc2l0aW9uIGVsZW1lbnRzIHRoYXQgYXJlXHJcblx0ICAgICAgICAvLyBnZXR0aW5nIGhpZGRlbi5cclxuXHQgICAgICAgIHdpZHRoID0gX2xhc3RTaXplLndpZHRoO1xyXG5cdCAgICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5sYXN0U2l6ZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgdGFyZ2V0UG9zID0gdGhpcy5jYWNoZSgndGFyZ2V0LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiBfdGhpczUuZ2V0VGFyZ2V0Qm91bmRzKCk7XHJcblx0ICAgICAgfSk7XHJcblx0ICAgICAgdmFyIHRhcmdldFNpemUgPSB0YXJnZXRQb3M7XHJcblx0XHJcblx0ICAgICAgLy8gR2V0IGFuIGFjdHVhbCBweCBvZmZzZXQgZnJvbSB0aGUgYXR0YWNobWVudFxyXG5cdCAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0aGlzLmF0dGFjaG1lbnQpLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcblx0ICAgICAgdmFyIHRhcmdldE9mZnNldCA9IG9mZnNldFRvUHgoYXR0YWNobWVudFRvT2Zmc2V0KHRhcmdldEF0dGFjaG1lbnQpLCB0YXJnZXRTaXplKTtcclxuXHRcclxuXHQgICAgICB2YXIgbWFudWFsT2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLm9mZnNldCwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG5cdCAgICAgIHZhciBtYW51YWxUYXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KHRoaXMudGFyZ2V0T2Zmc2V0LCB0YXJnZXRTaXplKTtcclxuXHRcclxuXHQgICAgICAvLyBBZGQgdGhlIG1hbnVhbGx5IHByb3ZpZGVkIG9mZnNldFxyXG5cdCAgICAgIG9mZnNldCA9IGFkZE9mZnNldChvZmZzZXQsIG1hbnVhbE9mZnNldCk7XHJcblx0ICAgICAgdGFyZ2V0T2Zmc2V0ID0gYWRkT2Zmc2V0KHRhcmdldE9mZnNldCwgbWFudWFsVGFyZ2V0T2Zmc2V0KTtcclxuXHRcclxuXHQgICAgICAvLyBJdCdzIG5vdyBvdXIgZ29hbCB0byBtYWtlIChlbGVtZW50IHBvc2l0aW9uICsgb2Zmc2V0KSA9PSAodGFyZ2V0IHBvc2l0aW9uICsgdGFyZ2V0IG9mZnNldClcclxuXHQgICAgICB2YXIgbGVmdCA9IHRhcmdldFBvcy5sZWZ0ICsgdGFyZ2V0T2Zmc2V0LmxlZnQgLSBvZmZzZXQubGVmdDtcclxuXHQgICAgICB2YXIgdG9wID0gdGFyZ2V0UG9zLnRvcCArIHRhcmdldE9mZnNldC50b3AgLSBvZmZzZXQudG9wO1xyXG5cdFxyXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGV0aGVyQmFzZS5tb2R1bGVzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICB2YXIgX21vZHVsZTIgPSBUZXRoZXJCYXNlLm1vZHVsZXNbaV07XHJcblx0ICAgICAgICB2YXIgcmV0ID0gX21vZHVsZTIucG9zaXRpb24uY2FsbCh0aGlzLCB7XHJcblx0ICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcblx0ICAgICAgICAgIHRvcDogdG9wLFxyXG5cdCAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0YXJnZXRBdHRhY2htZW50LFxyXG5cdCAgICAgICAgICB0YXJnZXRQb3M6IHRhcmdldFBvcyxcclxuXHQgICAgICAgICAgZWxlbWVudFBvczogZWxlbWVudFBvcyxcclxuXHQgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcblx0ICAgICAgICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0LFxyXG5cdCAgICAgICAgICBtYW51YWxPZmZzZXQ6IG1hbnVhbE9mZnNldCxcclxuXHQgICAgICAgICAgbWFudWFsVGFyZ2V0T2Zmc2V0OiBtYW51YWxUYXJnZXRPZmZzZXQsXHJcblx0ICAgICAgICAgIHNjcm9sbGJhclNpemU6IHNjcm9sbGJhclNpemUsXHJcblx0ICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudFxyXG5cdCAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByZXQgIT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgdG9wID0gcmV0LnRvcDtcclxuXHQgICAgICAgICAgbGVmdCA9IHJldC5sZWZ0O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICAvLyBXZSBkZXNjcmliZSB0aGUgcG9zaXRpb24gdGhyZWUgZGlmZmVyZW50IHdheXMgdG8gZ2l2ZSB0aGUgb3B0aW1pemVyXHJcblx0ICAgICAgLy8gYSBjaGFuY2UgdG8gZGVjaWRlIHRoZSBiZXN0IHBvc3NpYmxlIHdheSB0byBwb3NpdGlvbiB0aGUgZWxlbWVudFxyXG5cdCAgICAgIC8vIHdpdGggdGhlIGZld2VzdCByZXBhaW50cy5cclxuXHQgICAgICB2YXIgbmV4dCA9IHtcclxuXHQgICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhZ2UgKGFic29sdXRlIHBvc2l0aW9uaW5nIHdoZW5cclxuXHQgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIGJvZHkpXHJcblx0ICAgICAgICBwYWdlOiB7XHJcblx0ICAgICAgICAgIHRvcDogdG9wLFxyXG5cdCAgICAgICAgICBsZWZ0OiBsZWZ0XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgKGZpeGVkIHBvc2l0aW9uaW5nKVxyXG5cdCAgICAgICAgdmlld3BvcnQ6IHtcclxuXHQgICAgICAgICAgdG9wOiB0b3AgLSBwYWdlWU9mZnNldCxcclxuXHQgICAgICAgICAgYm90dG9tOiBwYWdlWU9mZnNldCAtIHRvcCAtIGhlaWdodCArIGlubmVySGVpZ2h0LFxyXG5cdCAgICAgICAgICBsZWZ0OiBsZWZ0IC0gcGFnZVhPZmZzZXQsXHJcblx0ICAgICAgICAgIHJpZ2h0OiBwYWdlWE9mZnNldCAtIGxlZnQgLSB3aWR0aCArIGlubmVyV2lkdGhcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoID4gd2luZG93LmlubmVyV2lkdGgpIHtcclxuXHQgICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xyXG5cdCAgICAgICAgbmV4dC52aWV3cG9ydC5ib3R0b20gLT0gc2Nyb2xsYmFyU2l6ZS5oZWlnaHQ7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG5cdCAgICAgICAgc2Nyb2xsYmFyU2l6ZSA9IHRoaXMuY2FjaGUoJ3Njcm9sbGJhci1zaXplJywgZ2V0U2Nyb2xsQmFyU2l6ZSk7XHJcblx0ICAgICAgICBuZXh0LnZpZXdwb3J0LnJpZ2h0IC09IHNjcm9sbGJhclNpemUud2lkdGg7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChbJycsICdzdGF0aWMnXS5pbmRleE9mKGRvY3VtZW50LmJvZHkuc3R5bGUucG9zaXRpb24pID09PSAtMSB8fCBbJycsICdzdGF0aWMnXS5pbmRleE9mKGRvY3VtZW50LmJvZHkucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbikgPT09IC0xKSB7XHJcblx0ICAgICAgICAvLyBBYnNvbHV0ZSBwb3NpdGlvbmluZyBpbiB0aGUgYm9keSB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBwYWdlLCBub3QgdGhlICdpbml0aWFsIGNvbnRhaW5pbmcgYmxvY2snXHJcblx0ICAgICAgICBuZXh0LnBhZ2UuYm90dG9tID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSB0b3AgLSBoZWlnaHQ7XHJcblx0ICAgICAgICBuZXh0LnBhZ2UucmlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gbGVmdCAtIHdpZHRoO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vcHRpbWl6YXRpb25zICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wdGlvbnMub3B0aW1pemF0aW9ucy5tb3ZlRWxlbWVudCAhPT0gZmFsc2UgJiYgISh0eXBlb2YgdGhpcy50YXJnZXRNb2RpZmllciAhPT0gJ3VuZGVmaW5lZCcpKSB7XHJcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM1LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoX3RoaXM1LnRhcmdldCk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UG9zaXRpb24gPSBfdGhpczUuY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBnZXRCb3VuZHMob2Zmc2V0UGFyZW50KTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcclxuXHQgICAgICAgICAgdmFyIG9mZnNldFBhcmVudFNpemUgPSBvZmZzZXRQb3NpdGlvbjtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIG9mZnNldEJvcmRlciA9IHt9O1xyXG5cdCAgICAgICAgICBbJ1RvcCcsICdMZWZ0JywgJ0JvdHRvbScsICdSaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgICAgICBvZmZzZXRCb3JkZXJbc2lkZS50b0xvd2VyQ2FzZSgpXSA9IHBhcnNlRmxvYXQob2Zmc2V0UGFyZW50U3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xyXG5cdCAgICAgICAgICB9KTtcclxuXHRcclxuXHQgICAgICAgICAgb2Zmc2V0UG9zaXRpb24ucmlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gb2Zmc2V0UG9zaXRpb24ubGVmdCAtIG9mZnNldFBhcmVudFNpemUud2lkdGggKyBvZmZzZXRCb3JkZXIucmlnaHQ7XHJcblx0ICAgICAgICAgIG9mZnNldFBvc2l0aW9uLmJvdHRvbSA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0UG9zaXRpb24udG9wIC0gb2Zmc2V0UGFyZW50U2l6ZS5oZWlnaHQgKyBvZmZzZXRCb3JkZXIuYm90dG9tO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAobmV4dC5wYWdlLnRvcCA+PSBvZmZzZXRQb3NpdGlvbi50b3AgKyBvZmZzZXRCb3JkZXIudG9wICYmIG5leHQucGFnZS5ib3R0b20gPj0gb2Zmc2V0UG9zaXRpb24uYm90dG9tKSB7XHJcblx0ICAgICAgICAgICAgaWYgKG5leHQucGFnZS5sZWZ0ID49IG9mZnNldFBvc2l0aW9uLmxlZnQgKyBvZmZzZXRCb3JkZXIubGVmdCAmJiBuZXh0LnBhZ2UucmlnaHQgPj0gb2Zmc2V0UG9zaXRpb24ucmlnaHQpIHtcclxuXHQgICAgICAgICAgICAgIC8vIFdlJ3JlIHdpdGhpbiB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZSB0YXJnZXQncyBzY3JvbGwgcGFyZW50XHJcblx0ICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcclxuXHQgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQ7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50IChhYnNvbHV0ZSBwb3NpdGlvbmluZyB3aGVuXHJcblx0ICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBtb3ZlZCB0byBiZSBhIGNoaWxkIG9mIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50KS5cclxuXHQgICAgICAgICAgICAgIG5leHQub2Zmc2V0ID0ge1xyXG5cdCAgICAgICAgICAgICAgICB0b3A6IG5leHQucGFnZS50b3AgLSBvZmZzZXRQb3NpdGlvbi50b3AgKyBzY3JvbGxUb3AgLSBvZmZzZXRCb3JkZXIudG9wLFxyXG5cdCAgICAgICAgICAgICAgICBsZWZ0OiBuZXh0LnBhZ2UubGVmdCAtIG9mZnNldFBvc2l0aW9uLmxlZnQgKyBzY3JvbGxMZWZ0IC0gb2Zmc2V0Qm9yZGVyLmxlZnRcclxuXHQgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICAvLyBXZSBjb3VsZCBhbHNvIHRyYXZlbCB1cCB0aGUgRE9NIGFuZCB0cnkgZWFjaCBjb250YWluaW5nIGNvbnRleHQsIHJhdGhlciB0aGFuIG9ubHlcclxuXHQgICAgICAvLyBsb29raW5nIGF0IHRoZSBib2R5LCBidXQgd2UncmUgZ29ubmEgZ2V0IGRpbWluaXNoaW5nIHJldHVybnMuXHJcblx0XHJcblx0ICAgICAgdGhpcy5tb3ZlKG5leHQpO1xyXG5cdFxyXG5cdCAgICAgIHRoaXMuaGlzdG9yeS51bnNoaWZ0KG5leHQpO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0aGlzLmhpc3RvcnkubGVuZ3RoID4gMykge1xyXG5cdCAgICAgICAgdGhpcy5oaXN0b3J5LnBvcCgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoZmx1c2hDaGFuZ2VzKSB7XHJcblx0ICAgICAgICBmbHVzaCgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICAvLyBUSEUgSVNTVUVcclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnbW92ZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHBvcykge1xyXG5cdCAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIGlmICghKHR5cGVvZiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSAhPT0gJ3VuZGVmaW5lZCcpKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBzYW1lID0ge307XHJcblx0XHJcblx0ICAgICAgZm9yICh2YXIgdHlwZSBpbiBwb3MpIHtcclxuXHQgICAgICAgIHNhbWVbdHlwZV0gPSB7fTtcclxuXHRcclxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBwb3NbdHlwZV0pIHtcclxuXHQgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oaXN0b3J5Lmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5oaXN0b3J5W2ldO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRbdHlwZV0gIT09ICd1bmRlZmluZWQnICYmICF3aXRoaW4ocG9pbnRbdHlwZV1ba2V5XSwgcG9zW3R5cGVdW2tleV0pKSB7XHJcblx0ICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG5cdCAgICAgICAgICAgIHNhbWVbdHlwZV1ba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgdmFyIGNzcyA9IHsgdG9wOiAnJywgbGVmdDogJycsIHJpZ2h0OiAnJywgYm90dG9tOiAnJyB9O1xyXG5cdFxyXG5cdCAgICAgIHZhciB0cmFuc2NyaWJlID0gZnVuY3Rpb24gdHJhbnNjcmliZShfc2FtZSwgX3Bvcykge1xyXG5cdCAgICAgICAgdmFyIGhhc09wdGltaXphdGlvbnMgPSB0eXBlb2YgX3RoaXM2Lm9wdGlvbnMub3B0aW1pemF0aW9ucyAhPT0gJ3VuZGVmaW5lZCc7XHJcblx0ICAgICAgICB2YXIgZ3B1ID0gaGFzT3B0aW1pemF0aW9ucyA/IF90aGlzNi5vcHRpb25zLm9wdGltaXphdGlvbnMuZ3B1IDogbnVsbDtcclxuXHQgICAgICAgIGlmIChncHUgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgIHZhciB5UG9zID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgICAgICAgeFBvcyA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgaWYgKF9zYW1lLnRvcCkge1xyXG5cdCAgICAgICAgICAgIGNzcy50b3AgPSAwO1xyXG5cdCAgICAgICAgICAgIHlQb3MgPSBfcG9zLnRvcDtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBjc3MuYm90dG9tID0gMDtcclxuXHQgICAgICAgICAgICB5UG9zID0gLV9wb3MuYm90dG9tO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGlmIChfc2FtZS5sZWZ0KSB7XHJcblx0ICAgICAgICAgICAgY3NzLmxlZnQgPSAwO1xyXG5cdCAgICAgICAgICAgIHhQb3MgPSBfcG9zLmxlZnQ7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgY3NzLnJpZ2h0ID0gMDtcclxuXHQgICAgICAgICAgICB4UG9zID0gLV9wb3MucmlnaHQ7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgY3NzW3RyYW5zZm9ybUtleV0gPSAndHJhbnNsYXRlWCgnICsgTWF0aC5yb3VuZCh4UG9zKSArICdweCkgdHJhbnNsYXRlWSgnICsgTWF0aC5yb3VuZCh5UG9zKSArICdweCknO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAodHJhbnNmb3JtS2V5ICE9PSAnbXNUcmFuc2Zvcm0nKSB7XHJcblx0ICAgICAgICAgICAgLy8gVGhlIFogdHJhbnNmb3JtIHdpbGwga2VlcCB0aGlzIGluIHRoZSBHUFUgKGZhc3RlciwgYW5kIHByZXZlbnRzIGFydGlmYWN0cyksXHJcblx0ICAgICAgICAgICAgLy8gYnV0IElFOSBkb2Vzbid0IHN1cHBvcnQgM2QgdHJhbnNmb3JtcyBhbmQgd2lsbCBjaG9rZS5cclxuXHQgICAgICAgICAgICBjc3NbdHJhbnNmb3JtS2V5XSArPSBcIiB0cmFuc2xhdGVaKDApXCI7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIGlmIChfc2FtZS50b3ApIHtcclxuXHQgICAgICAgICAgICBjc3MudG9wID0gX3Bvcy50b3AgKyAncHgnO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNzcy5ib3R0b20gPSBfcG9zLmJvdHRvbSArICdweCc7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgaWYgKF9zYW1lLmxlZnQpIHtcclxuXHQgICAgICAgICAgICBjc3MubGVmdCA9IF9wb3MubGVmdCArICdweCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgY3NzLnJpZ2h0ID0gX3Bvcy5yaWdodCArICdweCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIHZhciBtb3ZlZCA9IGZhbHNlO1xyXG5cdCAgICAgIGlmICgoc2FtZS5wYWdlLnRvcCB8fCBzYW1lLnBhZ2UuYm90dG9tKSAmJiAoc2FtZS5wYWdlLmxlZnQgfHwgc2FtZS5wYWdlLnJpZ2h0KSkge1xyXG5cdCAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHQgICAgICAgIHRyYW5zY3JpYmUoc2FtZS5wYWdlLCBwb3MucGFnZSk7XHJcblx0ICAgICAgfSBlbHNlIGlmICgoc2FtZS52aWV3cG9ydC50b3AgfHwgc2FtZS52aWV3cG9ydC5ib3R0b20pICYmIChzYW1lLnZpZXdwb3J0LmxlZnQgfHwgc2FtZS52aWV3cG9ydC5yaWdodCkpIHtcclxuXHQgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcblx0ICAgICAgICB0cmFuc2NyaWJlKHNhbWUudmlld3BvcnQsIHBvcy52aWV3cG9ydCk7XHJcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2FtZS5vZmZzZXQgIT09ICd1bmRlZmluZWQnICYmIHNhbWUub2Zmc2V0LnRvcCAmJiBzYW1lLm9mZnNldC5sZWZ0KSB7XHJcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM2LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoX3RoaXM2LnRhcmdldCk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAoZ2V0T2Zmc2V0UGFyZW50KF90aGlzNi5lbGVtZW50KSAhPT0gb2Zmc2V0UGFyZW50KSB7XHJcblx0ICAgICAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgX3RoaXM2LmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpczYuZWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQuYXBwZW5kQ2hpbGQoX3RoaXM2LmVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIHRyYW5zY3JpYmUoc2FtZS5vZmZzZXQsIHBvcy5vZmZzZXQpO1xyXG5cdCAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdCAgICAgICAgdHJhbnNjcmliZSh7IHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZSB9LCBwb3MucGFnZSk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICghbW92ZWQpIHtcclxuXHQgICAgICAgIHZhciBvZmZzZXRQYXJlbnRJc0JvZHkgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XHJcblx0ICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUudGFnTmFtZSAhPT0gJ0JPRFknKSB7XHJcblx0ICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycpIHtcclxuXHQgICAgICAgICAgICBvZmZzZXRQYXJlbnRJc0JvZHkgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoIW9mZnNldFBhcmVudElzQm9keSkge1xyXG5cdCAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG5cdCAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIC8vIEFueSBjc3MgY2hhbmdlIHdpbGwgdHJpZ2dlciBhIHJlcGFpbnQsIHNvIGxldCdzIGF2b2lkIG9uZSBpZiBub3RoaW5nIGNoYW5nZWRcclxuXHQgICAgICB2YXIgd3JpdGVDU1MgPSB7fTtcclxuXHQgICAgICB2YXIgd3JpdGUgPSBmYWxzZTtcclxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gY3NzKSB7XHJcblx0ICAgICAgICB2YXIgdmFsID0gY3NzW2tleV07XHJcblx0ICAgICAgICB2YXIgZWxWYWwgPSB0aGlzLmVsZW1lbnQuc3R5bGVba2V5XTtcclxuXHRcclxuXHQgICAgICAgIGlmIChlbFZhbCAhPT0gJycgJiYgdmFsICE9PSAnJyAmJiBbJ3RvcCcsICdsZWZ0JywgJ2JvdHRvbScsICdyaWdodCddLmluZGV4T2Yoa2V5KSA+PSAwKSB7XHJcblx0ICAgICAgICAgIGVsVmFsID0gcGFyc2VGbG9hdChlbFZhbCk7XHJcblx0ICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChlbFZhbCAhPT0gdmFsKSB7XHJcblx0ICAgICAgICAgIHdyaXRlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgd3JpdGVDU1Nba2V5XSA9IHZhbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHdyaXRlKSB7XHJcblx0ICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgIGV4dGVuZChfdGhpczYuZWxlbWVudC5zdHlsZSwgd3JpdGVDU1MpO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9XSk7XHJcblx0XHJcblx0ICByZXR1cm4gVGV0aGVyQ2xhc3M7XHJcblx0fSkoKTtcclxuXHRcclxuXHRUZXRoZXJDbGFzcy5tb2R1bGVzID0gW107XHJcblx0XHJcblx0VGV0aGVyQmFzZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cdFxyXG5cdHZhciBUZXRoZXIgPSBleHRlbmQoVGV0aGVyQ2xhc3MsIFRldGhlckJhc2UpO1xyXG5cdC8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcclxuXHRcclxuXHR2YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xyXG5cdHZhciBnZXRCb3VuZHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRCb3VuZHM7XHJcblx0dmFyIGV4dGVuZCA9IF9UZXRoZXJCYXNlJFV0aWxzLmV4dGVuZDtcclxuXHR2YXIgdXBkYXRlQ2xhc3NlcyA9IF9UZXRoZXJCYXNlJFV0aWxzLnVwZGF0ZUNsYXNzZXM7XHJcblx0dmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XHJcblx0XHJcblx0dmFyIEJPVU5EU19GT1JNQVQgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXRoZXIsIHRvKSB7XHJcblx0ICBpZiAodG8gPT09ICdzY3JvbGxQYXJlbnQnKSB7XHJcblx0ICAgIHRvID0gdGV0aGVyLnNjcm9sbFBhcmVudDtcclxuXHQgIH0gZWxzZSBpZiAodG8gPT09ICd3aW5kb3cnKSB7XHJcblx0ICAgIHRvID0gW3BhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCwgaW5uZXJXaWR0aCArIHBhZ2VYT2Zmc2V0LCBpbm5lckhlaWdodCArIHBhZ2VZT2Zmc2V0XTtcclxuXHQgIH1cclxuXHRcclxuXHQgIGlmICh0byA9PT0gZG9jdW1lbnQpIHtcclxuXHQgICAgdG8gPSB0by5kb2N1bWVudEVsZW1lbnQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIHRvLm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIHZhciBzaXplID0gZ2V0Qm91bmRzKHRvKTtcclxuXHQgICAgICB2YXIgcG9zID0gc2l6ZTtcclxuXHQgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRvKTtcclxuXHRcclxuXHQgICAgICB0byA9IFtwb3MubGVmdCwgcG9zLnRvcCwgc2l6ZS53aWR0aCArIHBvcy5sZWZ0LCBzaXplLmhlaWdodCArIHBvcy50b3BdO1xyXG5cdFxyXG5cdCAgICAgIEJPVU5EU19GT1JNQVQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSwgaSkge1xyXG5cdCAgICAgICAgc2lkZSA9IHNpZGVbMF0udG9VcHBlckNhc2UoKSArIHNpZGUuc3Vic3RyKDEpO1xyXG5cdCAgICAgICAgaWYgKHNpZGUgPT09ICdUb3AnIHx8IHNpZGUgPT09ICdMZWZ0Jykge1xyXG5cdCAgICAgICAgICB0b1tpXSArPSBwYXJzZUZsb2F0KHN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHRvW2ldIC09IHBhcnNlRmxvYXQoc3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9KSgpO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgcmV0dXJuIHRvO1xyXG5cdH1cclxuXHRcclxuXHRUZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XHJcblx0ICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdCAgICB2YXIgdGFyZ2V0QXR0YWNobWVudCA9IF9yZWYudGFyZ2V0QXR0YWNobWVudDtcclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29uc3RyYWludHMpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgX2NhY2hlID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xyXG5cdCAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XHJcblx0XHJcblx0ICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDAgJiYgdHlwZW9mIHRoaXMubGFzdFNpemUgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XHJcblx0XHJcblx0ICAgICAgLy8gSGFuZGxlIHRoZSBpdGVtIGdldHRpbmcgaGlkZGVuIGFzIGEgcmVzdWx0IG9mIG91ciBwb3NpdGlvbmluZyB3aXRob3V0IGdsaXRjaGluZ1xyXG5cdCAgICAgIC8vIHRoZSBjbGFzc2VzIGluIGFuZCBvdXRcclxuXHQgICAgICB3aWR0aCA9IF9sYXN0U2l6ZS53aWR0aDtcclxuXHQgICAgICBoZWlnaHQgPSBfbGFzdFNpemUuaGVpZ2h0O1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciB0YXJnZXRTaXplID0gdGhpcy5jYWNoZSgndGFyZ2V0LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICByZXR1cm4gX3RoaXMuZ2V0VGFyZ2V0Qm91bmRzKCk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0U2l6ZS5oZWlnaHQ7XHJcblx0ICAgIHZhciB0YXJnZXRXaWR0aCA9IHRhcmdldFNpemUud2lkdGg7XHJcblx0XHJcblx0ICAgIHZhciBhbGxDbGFzc2VzID0gW3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpLCB0aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyldO1xyXG5cdFxyXG5cdCAgICB0aGlzLm9wdGlvbnMuY29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG5cdCAgICAgIHZhciBvdXRPZkJvdW5kc0NsYXNzID0gY29uc3RyYWludC5vdXRPZkJvdW5kc0NsYXNzO1xyXG5cdCAgICAgIHZhciBwaW5uZWRDbGFzcyA9IGNvbnN0cmFpbnQucGlubmVkQ2xhc3M7XHJcblx0XHJcblx0ICAgICAgaWYgKG91dE9mQm91bmRzQ2xhc3MpIHtcclxuXHQgICAgICAgIGFsbENsYXNzZXMucHVzaChvdXRPZkJvdW5kc0NsYXNzKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHBpbm5lZENsYXNzKSB7XHJcblx0ICAgICAgICBhbGxDbGFzc2VzLnB1c2gocGlubmVkQ2xhc3MpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGFsbENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcblx0ICAgICAgWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICBhbGxDbGFzc2VzLnB1c2goY2xzICsgJy0nICsgc2lkZSk7XHJcblx0ICAgICAgfSk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB2YXIgYWRkQ2xhc3NlcyA9IFtdO1xyXG5cdFxyXG5cdCAgICB2YXIgdEF0dGFjaG1lbnQgPSBleHRlbmQoe30sIHRhcmdldEF0dGFjaG1lbnQpO1xyXG5cdCAgICB2YXIgZUF0dGFjaG1lbnQgPSBleHRlbmQoe30sIHRoaXMuYXR0YWNobWVudCk7XHJcblx0XHJcblx0ICAgIHRoaXMub3B0aW9ucy5jb25zdHJhaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XHJcblx0ICAgICAgdmFyIHRvID0gY29uc3RyYWludC50bztcclxuXHQgICAgICB2YXIgYXR0YWNobWVudCA9IGNvbnN0cmFpbnQuYXR0YWNobWVudDtcclxuXHQgICAgICB2YXIgcGluID0gY29uc3RyYWludC5waW47XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgYXR0YWNobWVudCA9ICcnO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgY2hhbmdlQXR0YWNoWCA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgICAgY2hhbmdlQXR0YWNoWSA9IHVuZGVmaW5lZDtcclxuXHQgICAgICBpZiAoYXR0YWNobWVudC5pbmRleE9mKCcgJykgPj0gMCkge1xyXG5cdCAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0ID0gYXR0YWNobWVudC5zcGxpdCgnICcpO1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9hdHRhY2htZW50JHNwbGl0LCAyKTtcclxuXHRcclxuXHQgICAgICAgIGNoYW5nZUF0dGFjaFkgPSBfYXR0YWNobWVudCRzcGxpdDJbMF07XHJcblx0ICAgICAgICBjaGFuZ2VBdHRhY2hYID0gX2F0dGFjaG1lbnQkc3BsaXQyWzFdO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBjaGFuZ2VBdHRhY2hYID0gY2hhbmdlQXR0YWNoWSA9IGF0dGFjaG1lbnQ7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBib3VuZHMgPSBnZXRCb3VuZGluZ1JlY3QoX3RoaXMsIHRvKTtcclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ3RhcmdldCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAndG9nZXRoZXInKSB7XHJcblx0ICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgICB0b3AgKz0gdGFyZ2V0SGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xyXG5cdCAgICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0XHJcblx0ICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XHJcblx0ICAgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcclxuXHRcclxuXHQgICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICdtaWRkbGUnKSB7XHJcblx0ICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xyXG5cdCAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAodG9wIDwgYm91bmRzWzFdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcclxuXHQgICAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICBsZWZ0ICs9IHRhcmdldFdpZHRoO1xyXG5cdCAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xyXG5cdCAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RvZ2V0aGVyJykge1xyXG5cdCAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHRcclxuXHQgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHRcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSBlbHNlIGlmICh0QXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xyXG5cdCAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAnZWxlbWVudCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcclxuXHQgICAgICAgICAgdG9wICs9IGhlaWdodDtcclxuXHQgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgdG9wIC09IGhlaWdodDtcclxuXHQgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAnZWxlbWVudCcgfHwgY2hhbmdlQXR0YWNoWCA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSkge1xyXG5cdCAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHQgICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGggLyAyO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0pIHtcclxuXHQgICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHBpbiA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIHBpbiA9IHBpbi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkge1xyXG5cdCAgICAgICAgICByZXR1cm4gcC50cmltKCk7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICB9IGVsc2UgaWYgKHBpbiA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgICAgcGluID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgcGluID0gcGluIHx8IFtdO1xyXG5cdFxyXG5cdCAgICAgIHZhciBwaW5uZWQgPSBbXTtcclxuXHQgICAgICB2YXIgb29iID0gW107XHJcblx0XHJcblx0ICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSkge1xyXG5cdCAgICAgICAgaWYgKHBpbi5pbmRleE9mKCd0b3AnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHRvcCA9IGJvdW5kc1sxXTtcclxuXHQgICAgICAgICAgcGlubmVkLnB1c2goJ3RvcCcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgb29iLnB1c2goJ3RvcCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XHJcblx0ICAgICAgICBpZiAocGluLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcclxuXHQgICAgICAgICAgdG9wID0gYm91bmRzWzNdIC0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICBwaW5uZWQucHVzaCgnYm90dG9tJyk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICBvb2IucHVzaCgnYm90dG9tJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdKSB7XHJcblx0ICAgICAgICBpZiAocGluLmluZGV4T2YoJ2xlZnQnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIGxlZnQgPSBib3VuZHNbMF07XHJcblx0ICAgICAgICAgIHBpbm5lZC5wdXNoKCdsZWZ0Jyk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICBvb2IucHVzaCgnbGVmdCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XHJcblx0ICAgICAgICBpZiAocGluLmluZGV4T2YoJ3JpZ2h0JykgPj0gMCkge1xyXG5cdCAgICAgICAgICBsZWZ0ID0gYm91bmRzWzJdIC0gd2lkdGg7XHJcblx0ICAgICAgICAgIHBpbm5lZC5wdXNoKCdyaWdodCcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgb29iLnB1c2goJ3JpZ2h0Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChwaW5uZWQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICB2YXIgcGlubmVkQ2xhc3MgPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBwaW5uZWRDbGFzcyA9IF90aGlzLm9wdGlvbnMucGlubmVkQ2xhc3M7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgcGlubmVkQ2xhc3MgPSBfdGhpcy5nZXRDbGFzcygncGlubmVkJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzKTtcclxuXHQgICAgICAgICAgcGlubmVkLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gocGlubmVkQ2xhc3MgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAob29iLmxlbmd0aCkge1xyXG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgdmFyIG9vYkNsYXNzID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMub3V0T2ZCb3VuZHNDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBvb2JDbGFzcyA9IF90aGlzLm9wdGlvbnMub3V0T2ZCb3VuZHNDbGFzcztcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBvb2JDbGFzcyA9IF90aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKG9vYkNsYXNzKTtcclxuXHQgICAgICAgICAgb29iLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9KSgpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAocGlubmVkLmluZGV4T2YoJ2xlZnQnKSA+PSAwIHx8IHBpbm5lZC5pbmRleE9mKCdyaWdodCcpID49IDApIHtcclxuXHQgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSB0QXR0YWNobWVudC5sZWZ0ID0gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChwaW5uZWQuaW5kZXhPZigndG9wJykgPj0gMCB8fCBwaW5uZWQuaW5kZXhPZignYm90dG9tJykgPj0gMCkge1xyXG5cdCAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gdEF0dGFjaG1lbnQudG9wID0gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICh0QXR0YWNobWVudC50b3AgIT09IHRhcmdldEF0dGFjaG1lbnQudG9wIHx8IHRBdHRhY2htZW50LmxlZnQgIT09IHRhcmdldEF0dGFjaG1lbnQubGVmdCB8fCBlQXR0YWNobWVudC50b3AgIT09IF90aGlzLmF0dGFjaG1lbnQudG9wIHx8IGVBdHRhY2htZW50LmxlZnQgIT09IF90aGlzLmF0dGFjaG1lbnQubGVmdCkge1xyXG5cdCAgICAgICAgX3RoaXMudXBkYXRlQXR0YWNoQ2xhc3NlcyhlQXR0YWNobWVudCwgdEF0dGFjaG1lbnQpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICBpZiAoIShfdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xyXG5cdCAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzLmVsZW1lbnQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuXHQgIH1cclxuXHR9KTtcclxuXHQvKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcclxuXHR2YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xyXG5cdHZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcclxuXHR2YXIgZGVmZXIgPSBfVGV0aGVyQmFzZSRVdGlscy5kZWZlcjtcclxuXHRcclxuXHRUZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XHJcblx0ICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdFxyXG5cdCAgICB2YXIgX2NhY2hlID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xyXG5cdCAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XHJcblx0XHJcblx0ICAgIHZhciB0YXJnZXRQb3MgPSB0aGlzLmdldFRhcmdldEJvdW5kcygpO1xyXG5cdFxyXG5cdCAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xyXG5cdCAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XHJcblx0XHJcblx0ICAgIHZhciBhYnV0dGVkID0gW107XHJcblx0ICAgIGlmICh0b3AgPD0gdGFyZ2V0UG9zLmJvdHRvbSAmJiBib3R0b20gPj0gdGFyZ2V0UG9zLnRvcCkge1xyXG5cdCAgICAgIFsnbGVmdCcsICdyaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgIHZhciB0YXJnZXRQb3NTaWRlID0gdGFyZ2V0UG9zW3NpZGVdO1xyXG5cdCAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IGxlZnQgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gcmlnaHQpIHtcclxuXHQgICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmIChsZWZ0IDw9IHRhcmdldFBvcy5yaWdodCAmJiByaWdodCA+PSB0YXJnZXRQb3MubGVmdCkge1xyXG5cdCAgICAgIFsndG9wJywgJ2JvdHRvbSddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICAgIHZhciB0YXJnZXRQb3NTaWRlID0gdGFyZ2V0UG9zW3NpZGVdO1xyXG5cdCAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IHRvcCB8fCB0YXJnZXRQb3NTaWRlID09PSBib3R0b20pIHtcclxuXHQgICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBhbGxDbGFzc2VzID0gW107XHJcblx0ICAgIHZhciBhZGRDbGFzc2VzID0gW107XHJcblx0XHJcblx0ICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XHJcblx0ICAgIGFsbENsYXNzZXMucHVzaCh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpO1xyXG5cdCAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgYWxsQ2xhc3Nlcy5wdXNoKF90aGlzLmdldENsYXNzKCdhYnV0dGVkJykgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIGlmIChhYnV0dGVkLmxlbmd0aCkge1xyXG5cdCAgICAgIGFkZENsYXNzZXMucHVzaCh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGFidXR0ZWQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xyXG5cdCAgICAgIGFkZENsYXNzZXMucHVzaChfdGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpICsgJy0nICsgc2lkZSk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBkZWZlcihmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgaWYgKCEoX3RoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfVxyXG5cdH0pO1xyXG5cdC8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcclxuXHRcclxuXHRUZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XHJcblx0ICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdFxyXG5cdCAgICBpZiAoIXRoaXMub3B0aW9ucy5zaGlmdCkge1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQ7XHJcblx0ICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNoaWZ0ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQuY2FsbCh0aGlzLCB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBzaGlmdFRvcCA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIHNoaWZ0TGVmdCA9IHVuZGVmaW5lZDtcclxuXHQgICAgaWYgKHR5cGVvZiBzaGlmdCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICBzaGlmdCA9IHNoaWZ0LnNwbGl0KCcgJyk7XHJcblx0ICAgICAgc2hpZnRbMV0gPSBzaGlmdFsxXSB8fCBzaGlmdFswXTtcclxuXHRcclxuXHQgICAgICB2YXIgX3NoaWZ0ID0gc2hpZnQ7XHJcblx0XHJcblx0ICAgICAgdmFyIF9zaGlmdDIgPSBfc2xpY2VkVG9BcnJheShfc2hpZnQsIDIpO1xyXG5cdFxyXG5cdCAgICAgIHNoaWZ0VG9wID0gX3NoaWZ0MlswXTtcclxuXHQgICAgICBzaGlmdExlZnQgPSBfc2hpZnQyWzFdO1xyXG5cdFxyXG5cdCAgICAgIHNoaWZ0VG9wID0gcGFyc2VGbG9hdChzaGlmdFRvcCwgMTApO1xyXG5cdCAgICAgIHNoaWZ0TGVmdCA9IHBhcnNlRmxvYXQoc2hpZnRMZWZ0LCAxMCk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgc2hpZnRUb3AgPSBzaGlmdC50b3A7XHJcblx0ICAgICAgc2hpZnRMZWZ0ID0gc2hpZnQubGVmdDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB0b3AgKz0gc2hpZnRUb3A7XHJcblx0ICAgIGxlZnQgKz0gc2hpZnRMZWZ0O1xyXG5cdFxyXG5cdCAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xyXG5cdCAgfVxyXG5cdH0pO1xyXG5cdHJldHVybiBUZXRoZXI7XHJcblx0XHJcblx0fSkpO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDYxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGV2ZW50VGFyZ2V0c0NvbXBvbmVudDogZnVuY3Rpb24gZXZlbnRUYXJnZXRzQ29tcG9uZW50KGV2ZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgaWYgKGV2ZW50VGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5pZCA9PT0gZXZlbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA2MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjx1bFxcbiAgICBjbGFzcz1cXFwidWktbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBAa2V5ZG93bi5lc2M9XFxcImNsb3NlRHJvcGRvd25cXFwiIHYtZWw6ZHJvcGRvd25cXG4gICAgOmNsYXNzPVxcXCJ7ICdoYXMtaWNvbnMnOiBzaG93SWNvbnMsICdoYXMtc2Vjb25kYXJ5LXRleHQnOiBzaG93U2Vjb25kYXJ5VGV4dCB9XFxcIlxcbj5cXG4gICAgPHVpLW1lbnUtb3B0aW9uXFxuICAgICAgICA6dHlwZT1cXFwib3B0aW9uLnR5cGVcXFwiIDppY29uPVxcXCJvcHRpb24uaWNvblxcXCIgOnRleHQ9XFxcIm9wdGlvbi50ZXh0XFxcIiA6ZGlzYWJsZWQ9XFxcIm9wdGlvbi5kaXNhYmxlZFxcXCJcXG4gICAgICAgIDpzZWNvbmRhcnktdGV4dD1cXFwib3B0aW9uLnNlY29uZGFyeVRleHRcXFwiIDpvcHRpb249XFxcIm9wdGlvblxcXCIgOnNob3ctaWNvbj1cXFwic2hvd0ljb25zXFxcIlxcbiAgICAgICAgOnNob3ctc2Vjb25kYXJ5LXRleHQ9XFxcInNob3dTZWNvbmRhcnlUZXh0XFxcIiA6aGlkZS1yaXBwbGUtaW5rPVxcXCJoaWRlUmlwcGxlSW5rXFxcIlxcbiAgICAgICAgOnBhcnRpYWw9XFxcIm9wdGlvbi5wYXJ0aWFsIHx8IHBhcnRpYWxcXFwiXFxuXFxuICAgICAgICBAa2V5ZG93bi5lbnRlci5wcmV2ZW50PVxcXCJvcHRpb25TZWxlY3Qob3B0aW9uKVxcXCIgQGNsaWNrPVxcXCJvcHRpb25TZWxlY3Qob3B0aW9uKVxcXCJcXG5cXG4gICAgICAgIHYtZm9yPVxcXCJvcHRpb24gaW4gb3B0aW9uc1xcXCJcXG4gICAgPjwvdWktbWVudS1vcHRpb24+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1tZW51LWZvY3VzLXJlZGlyZWN0b3JcXFwiIEBmb2N1cz1cXFwicmVkaXJlY3RGb2N1c1xcXCIgdGFiaW5kZXg9XFxcIjBcXFwiXFxuICAgID48L2Rpdj5cXG48L3VsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNjMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjQpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUG9wb3Zlci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUG9wb3Zlci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogNjQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NEcm9wZG93biA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NEcm9wZG93bjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c0Ryb3Bkb3duKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXBvcG92ZXInLFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICdkcm9wZG93bi1vcGVuZWQnOiBmdW5jdGlvbiBkcm9wZG93bk9wZW5lZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250YWluRm9jdXMpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgJ2Ryb3Bkb3duLWNsb3NlZCc6IGZ1bmN0aW9uIGRyb3Bkb3duQ2xvc2VkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5Gb2N1cykge1xyXG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMucmVzdHJpY3RGb2N1cywgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgcmVzdHJpY3RGb2N1czogZnVuY3Rpb24gcmVzdHJpY3RGb2N1cyhlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRlbHMuZHJvcGRvd24uY29udGFpbnMoZS50YXJnZXQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGVscy5kcm9wZG93bi5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1Nob3dzRHJvcGRvd24yLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDY2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcG9wb3ZlclxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIEBrZXlkb3duLmVzYz1cXFwiY2xvc2VEcm9wZG93blxcXCIgdi1lbDpkcm9wZG93blxcbj5cXG4gICAgPHNsb3Q+PC9zbG90PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNjcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjgpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUHJvZ3Jlc3NDaXJjdWxhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUHJvZ3Jlc3NDaXJjdWxhci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogNjggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXByb2dyZXNzLWNpcmN1bGFyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnaW5kZXRlcm1pbmF0ZScgfSxcclxuXHQgICAgICAgIGNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5JyB9LFxyXG5cdCAgICAgICAgdmFsdWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNpemU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMzJcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdHJva2U6IE51bWJlcixcclxuXHQgICAgICAgIGF1dG9TdHJva2U6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlVHJhbnNpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHN0cm9rZURhc2hBcnJheTogZnVuY3Rpb24gc3Ryb2tlRGFzaEFycmF5KCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cztcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjaXJjdW1mZXJlbmNlICogMTAwMCkgLyAxMDAwO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIHN0cm9rZURhc2hPZmZzZXQoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlcmF0ZVZhbHVlKHRoaXMudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIHZhciBjaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cztcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gKDEwMCAtIHZhbHVlKSAvIDEwMCAqIGNpcmN1bWZlcmVuY2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcmFkaXVzOiBmdW5jdGlvbiByYWRpdXMoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNpemUgLSB0aGlzLnN0cm9rZSkgLyAyO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLnN0cm9rZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmF1dG9TdHJva2UpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBwYXJzZUludCh0aGlzLnNpemUgLyA4LCAxMCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSA0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgbW9kZXJhdGVWYWx1ZTogZnVuY3Rpb24gbW9kZXJhdGVWYWx1ZSh2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPiAxMDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDcwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtY2lyY3VsYXJcXFwiIDpzdHlsZT1cXFwieyAnd2lkdGgnOiBzaXplICsgJ3B4JywgJ2hlaWdodCc6IHNpemUgKyAncHgnIH1cXFwiXFxuICAgIHYtc2hvdz1cXFwic2hvd1xcXCIgOnRyYW5zaXRpb249XFxcImRpc2FibGVUcmFuc2l0aW9uID8gbnVsbCA6ICd1aS1wcm9ncmVzcy1jaXJjdWxhci10b2dnbGUnXFxcIlxcbj5cXG4gICAgPHN2Z1xcbiAgICAgICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyLWRldGVybWluYXRlXFxcIiA6d2lkdGg9XFxcInNpemVcXFwiIDpoZWlnaHQ9XFxcInNpemVcXFwiXFxuICAgICAgICByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgOmFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIDphcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIDphcmlhLXZhbHVlbm93PVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgIHYtaWY9XFxcInR5cGUgPT09ICdkZXRlcm1pbmF0ZSdcXFwiXFxuICAgID5cXG4gICAgICAgIDxjaXJjbGVcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtY2lyY3VsYXItZGV0ZXJtaW5hdGUtcGF0aFxcXCIgOmNsYXNzPVxcXCJbY29sb3JdXFxcIiA6cj1cXFwicmFkaXVzXFxcIlxcbiAgICAgICAgICAgIDpjeD1cXFwic2l6ZSAvIDJcXFwiIDpjeT1cXFwic2l6ZSAvIDJcXFwiIGZpbGw9XFxcInRyYW5zcGFyZW50XFxcIiA6c3Ryb2tlLWRhc2hhcnJheT1cXFwic3Ryb2tlRGFzaEFycmF5XFxcIlxcbiAgICAgICAgICAgIHN0cm9rZS1kYXNob2Zmc2V0PVxcXCIwXFxcIlxcblxcbiAgICAgICAgICAgIDpzdHlsZT1cXFwieyAnc3Ryb2tlLWRhc2hvZmZzZXQnOiBzdHJva2VEYXNoT2Zmc2V0LCAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlIH1cXFwiXFxuICAgICAgICA+PC9jaXJjbGU+XFxuICAgIDwvc3ZnPlxcblxcbiAgICA8c3ZnXFxuICAgICAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtY2lyY3VsYXItaW5kZXRlcm1pbmF0ZVxcXCIgdmlld0JveD1cXFwiMjUgMjUgNTAgNTBcXFwiXFxuICAgICAgICByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgOmFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIDphcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIHYtZWxzZVxcbiAgICA+XFxuICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyLWluZGV0ZXJtaW5hdGUtcGF0aFxcXCIgOmNsYXNzPVxcXCJbY29sb3JdXFxcIiBjeD1cXFwiNTBcXFwiIGN5PVxcXCI1MFxcXCJcXG4gICAgICAgICAgICByPVxcXCIyMFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlLW1pdGVybGltaXQ9XFxcIjEwXFxcIiA6c3Ryb2tlLXdpZHRoPVxcXCJzdHJva2VcXFwiXFxuICAgICAgICA+XFxuICAgIDwvc3ZnPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICB0aGlzLmVsLmRpc2FibGVkID0gQm9vbGVhbih2YWx1ZSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDcyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgb3BlbkRyb3Bkb3duT246IFN0cmluZyxcclxuXHQgICAgICAgIGRyb3Bkb3duUG9zaXRpb246IFN0cmluZyxcclxuXHQgICAgICAgIGhhc1BvcG92ZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGFzRHJvcGRvd25NZW51OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1lbnVPcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd01lbnVJY29uczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93TWVudVNlY29uZGFyeVRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIG1lbnVPcHRpb25TZWxlY3Q6IGZ1bmN0aW9uIG1lbnVPcHRpb25TZWxlY3Qob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21lbnUtb3B0aW9uLXNlbGVjdGVkJywgb3B0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XHJcblx0XHJcblx0dmFyIF9VaVRvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUb29sdGlwKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHRvb2x0aXA6IFN0cmluZyxcclxuXHQgICAgICAgIG9wZW5Ub29sdGlwT246IFN0cmluZyxcclxuXHQgICAgICAgIHRvb2x0aXBQb3NpdGlvbjogU3RyaW5nXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpVG9vbHRpcDogX1VpVG9vbHRpcDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDc0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NilcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVRvb2x0aXAudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRvb2x0aXAudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDc1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogNzYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3RldGhlclRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KTtcclxuXHRcclxuXHR2YXIgX3RldGhlclRvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV0aGVyVG9vbHRpcCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10b29sdGlwJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGNvbnRlbnQ6IFN0cmluZyxcclxuXHQgICAgICAgIHRyaWdnZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBFbGVtZW50LFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcG9zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2JvdHRvbSBjZW50ZXInXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3Blbk9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdob3ZlciBmb2N1cydcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdG9vbHRpcDogbnVsbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdG9yeTogZnVuY3Rpb24gYmVmb3JlRGVzdG9yeSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvb2x0aXApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvb2x0aXAucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy50b29sdGlwLmRlc3Ryb3koKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBfdGV0aGVyVG9vbHRpcDIuZGVmYXVsdCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMudHJpZ2dlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuJGVscy50b29sdGlwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogJ3VpLXRvb2x0aXAtdGhlbWUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvcGVuT246ICdob3ZlciBmb2N1cydcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDc3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgdGV0aGVyLXRvb2x0aXAgMS4xLjAgKi9cclxuXHRcclxuXHQoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdCAgaWYgKHRydWUpIHtcclxuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oNTkpLF9fd2VicGFja19yZXF1aXJlX18oNjApXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XHJcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgndGV0aGVyLWRyb3AnKSwgcmVxdWlyZSgndGV0aGVyJykpO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcm9vdC5Ub29sdGlwID0gZmFjdG9yeShyb290LkRyb3AsIHJvb3QuVGV0aGVyKTtcclxuXHQgIH1cclxuXHR9KHRoaXMsIGZ1bmN0aW9uKERyb3AsIFRldGhlcikge1xyXG5cdFxyXG5cdC8qIGdsb2JhbCBUZXRoZXIgRHJvcCAqL1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxyXG5cdFxyXG5cdHZhciBleHRlbmQgPSBUZXRoZXIuVXRpbHMuZXh0ZW5kO1xyXG5cdFxyXG5cdHZhciBfRHJvcCA9IERyb3AuY3JlYXRlQ29udGV4dCh7XHJcblx0ICBjbGFzc1ByZWZpeDogJ3Rvb2x0aXAnXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdCAgcG9zaXRpb246ICd0b3AgY2VudGVyJyxcclxuXHQgIG9wZW5PbjogJ2hvdmVyJyxcclxuXHQgIGNsYXNzZXM6ICd0b29sdGlwLXRoZW1lLWFycm93cycsXHJcblx0ICBjb25zdHJhaW5Ub1dpbmRvdzogdHJ1ZSxcclxuXHQgIGNvbnN0cmFpblRvU2Nyb2xsUGFyZW50OiBmYWxzZVxyXG5cdH07XHJcblx0XHJcblx0dmFyIHRvb2x0aXBDb3VudCA9IDA7XHJcblx0XHJcblx0dmFyIFRvb2x0aXAgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgZnVuY3Rpb24gVG9vbHRpcChvcHRpb25zKSB7XHJcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcclxuXHRcclxuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMudGFyZ2V0KSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sdGlwIEVycm9yOiBZb3UgbXVzdCBwcm92aWRlIGEgdGFyZ2V0IGZvciBUb29sdGlwIHRvIGF0dGFjaCB0bycpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAtcG9zaXRpb24nKTtcclxuXHQgICAgaWYgKHBvc2l0aW9uKSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwJyk7XHJcblx0XHJcblx0ICAgIGlmIChjb250ZW50KSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHZhciBjb250ZW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHQgICAgICAgIGNvbnRlbnRFbC5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFxyXG5cdCAgICAgICAgLy8gQWRkIEFSSUEgYXR0cmlidXRlcyAoc2VlICM1MClcclxuXHQgICAgICAgIGNvbnRlbnRFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xyXG5cdCAgICAgICAgY29udGVudEVsLmlkID0gJ2Ryb3AtdG9vbHRpcC0nICsgdG9vbHRpcENvdW50O1xyXG5cdCAgICAgICAgdGhpcy5vcHRpb25zLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCBjb250ZW50RWwuaWQpO1xyXG5cdCAgICAgICAgdG9vbHRpcENvdW50ICs9IDE7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudCA9IGNvbnRlbnRFbDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29udGVudCkge1xyXG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbHRpcCBFcnJvcjogWW91IG11c3QgcHJvdmlkZSBjb250ZW50IGZvciBUb29sdGlwIHRvIGRpc3BsYXknKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCB0aGlzLm9wdGlvbnMpO1xyXG5cdFxyXG5cdCAgICB0aGlzLmRyb3AgPSBuZXcgX0Ryb3AodGhpcy5vcHRpb25zKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xyXG5cdCAgICBrZXk6ICdjbG9zZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcclxuXHQgICAgICB0aGlzLmRyb3AuY2xvc2UoKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdvcGVuJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XHJcblx0ICAgICAgdGhpcy5kcm9wLm9wZW4oKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICd0b2dnbGUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xyXG5cdCAgICAgIHRoaXMuZHJvcC50b2dnbGUoKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdyZW1vdmUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG5cdCAgICAgIHRoaXMuZHJvcC5yZW1vdmUoKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdkZXN0cm95JyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcblx0ICAgICAgdGhpcy5kcm9wLmRlc3Ryb3koKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdwb3NpdGlvbicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcclxuXHQgICAgICB0aGlzLmRyb3AucG9zaXRpb24oKTtcclxuXHQgICAgfVxyXG5cdCAgfV0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIFRvb2x0aXA7XHJcblx0fSkoKTtcclxuXHRcclxuXHR2YXIgaW5pdGlhbGl6ZWQgPSBbXTtcclxuXHRcclxuXHRUb29sdGlwLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICB2YXIgdG9vbHRpcEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdG9vbHRpcF0nKTtcclxuXHQgIHZhciBsZW4gPSB0b29sdGlwRWxlbWVudHMubGVuZ3RoO1xyXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG5cdCAgICB2YXIgZWwgPSB0b29sdGlwRWxlbWVudHNbaV07XHJcblx0ICAgIGlmIChpbml0aWFsaXplZC5pbmRleE9mKGVsKSA9PT0gLTEpIHtcclxuXHQgICAgICBuZXcgVG9vbHRpcCh7XHJcblx0ICAgICAgICB0YXJnZXQ6IGVsXHJcblx0ICAgICAgfSk7XHJcblx0ICAgICAgaW5pdGlhbGl6ZWQucHVzaChlbCk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICBpZiAoVG9vbHRpcC5hdXRvaW5pdCAhPT0gZmFsc2UpIHtcclxuXHQgICAgVG9vbHRpcC5pbml0KCk7XHJcblx0ICB9XHJcblx0fSk7XHJcblx0cmV0dXJuIFRvb2x0aXA7XHJcblx0XHJcblx0fSkpO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDc4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktdG9vbHRpcFxcXCIgdi10ZXh0PVxcXCJjb250ZW50XFxcIiB2LWVsOnRvb2x0aXA+PC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxidXR0b25cXG4gICAgY2xhc3M9XFxcInVpLWljb24tYnV0dG9uXFxcIiA6Y2xhc3M9XFxcInN0eWxlQ2xhc3Nlc1xcXCIgOmFyaWEtbGFiZWw9XFxcImFyaWFMYWJlbCB8fCB0b29sdGlwXFxcIlxcbiAgICA6dHlwZT1cXFwiYnV0dG9uVHlwZVxcXCIgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWQgfHwgbG9hZGluZ1xcXCIgdi1lbDpidXR0b25cXG4+XFxuICAgIDx1aS1pY29uXFxuICAgICAgICBjbGFzcz1cXFwidWktaWNvbi1idXR0b24taWNvblxcXCIgOmljb249XFxcImljb25cXFwiIHYtc2hvdz1cXFwiIWxvYWRpbmdcXFwiXFxuICAgID48L3VpLWljb24+XFxuXFxuICAgIDx1aS1wcm9ncmVzcy1jaXJjdWxhclxcbiAgICAgICAgY2xhc3M9XFxcInVpLWljb24tYnV0dG9uLXNwaW5uZXJcXFwiIDpjb2xvcj1cXFwic3Bpbm5lckNvbG9yXFxcIiA6c2l6ZT1cXFwiMjRcXFwiIDpzdHJva2U9XFxcIjQuNVxcXCJcXG4gICAgICAgIGRpc2FibGUtdHJhbnNpdGlvbiB2LXNob3c9XFxcImxvYWRpbmdcXFwiXFxuICAgID48L3VpLXByb2dyZXNzLWNpcmN1bGFyPlxcblxcbiAgICA8dWktcmlwcGxlLWluayB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCI+PC91aS1yaXBwbGUtaW5rPlxcblxcbiAgICA8dWktdG9vbHRpcFxcbiAgICAgICAgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiA6Y29udGVudD1cXFwidG9vbHRpcFxcXCIgOnBvc2l0aW9uPVxcXCJ0b29sdGlwUG9zaXRpb25cXFwiIHYtaWY9XFxcInRvb2x0aXBcXFwiXFxuICAgICAgICA6b3Blbi1vbj1cXFwib3BlblRvb2x0aXBPblxcXCJcXG4gICAgPjwvdWktdG9vbHRpcD5cXG5cXG4gICAgPHVpLW1lbnVcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1idXR0b24tZHJvcGRvd24tbWVudVxcXCIgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiA6b3B0aW9ucz1cXFwibWVudU9wdGlvbnNcXFwiXFxuICAgICAgICA6c2hvdy1pY29ucz1cXFwic2hvd01lbnVJY29uc1xcXCIgOnNob3ctc2Vjb25kYXJ5LXRleHQ9XFxcInNob3dNZW51U2Vjb25kYXJ5VGV4dFxcXCJcXG4gICAgICAgIDpvcGVuLW9uPVxcXCJvcGVuRHJvcGRvd25PblxcXCIgQG9wdGlvbi1zZWxlY3RlZD1cXFwibWVudU9wdGlvblNlbGVjdFxcXCJcXG4gICAgICAgIDpkcm9wZG93bi1wb3NpdGlvbj1cXFwiZHJvcGRvd25Qb3NpdGlvblxcXCIgdi1pZj1cXFwiaGFzRHJvcGRvd25NZW51XFxcIlxcbiAgICA+PC91aS1tZW51PlxcblxcbiAgICA8dWktcG9wb3ZlclxcbiAgICAgICAgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiA6b3Blbi1vbj1cXFwib3BlbkRyb3Bkb3duT25cXFwiIDpkcm9wZG93bi1wb3NpdGlvbj1cXFwiZHJvcGRvd25Qb3NpdGlvblxcXCJcXG4gICAgICAgIHYtaWY9XFxcImhhc1BvcG92ZXJcXFwiXFxuICAgID5cXG4gICAgICAgIDxzbG90IG5hbWU9XFxcInBvcG92ZXJcXFwiPjwvc2xvdD5cXG4gICAgPC91aS1wb3BvdmVyPlxcbjwvYnV0dG9uPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogODAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ1aS1hbGVydFxcXCI+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1hbGVydC1ib2R5XFxcIiA6Y2xhc3M9XFxcIlt0eXBlXVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiIHYtc2hvdz1cXFwic2hvd1xcXCJcXG4gICAgICAgIHRyYW5zaXRpb249XFxcInVpLWFsZXJ0LXRvZ2dsZVxcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLWljb24gY2xhc3M9XFxcInVpLWFsZXJ0LWljb25cXFwiIDppY29uPVxcXCJpY29uTmFtZVxcXCIgdi1pZj1cXFwiIWhpZGVJY29uXFxcIj48L3VpLWljb24+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1hbGVydC10ZXh0XFxcIj5cXG4gICAgICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJ0ZXh0XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktYWxlcnQtY2xvc2UtYnV0dG9uXFxcIiB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiJiN4RTVDRFxcXCIgYXJpYS1sYWJlbD1cXFwiQ2xvc2VcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJjbG9zZVxcXCIgdi1pZj1cXFwiZGlzbWlzc2libGVcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg4MilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlBdXRvY29tcGxldGUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlBdXRvY29tcGxldGUudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDgyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogODMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2Z1enp5c2VhcmNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XHJcblx0XHJcblx0dmFyIF9mdXp6eXNlYXJjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mdXp6eXNlYXJjaCk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcclxuXHRcclxuXHR2YXIgX1VpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24pO1xyXG5cdFxyXG5cdHZhciBfYXV0b2ZvY3VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XHJcblx0XHJcblx0dmFyIF9hdXRvZm9jdXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXV0b2ZvY3VzKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc1RleHRJbnB1dCk7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdGVzSW5wdXQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktYXV0b2NvbXBsZXRlJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHN1Z2dlc3Rpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogW11cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsaW1pdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiA4XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGFydGlhbDogU3RyaW5nLFxyXG5cdCAgICAgICAgYXBwZW5kOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGFwcGVuZERlbGltaXRlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnLCAnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbWluQ2hhcnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMlxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dPblVwRG93bjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGF1dG9mb2N1czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmaWx0ZXI6IEZ1bmN0aW9uLFxyXG5cdCAgICAgICAgYXV0b0hpZ2hsaWdodEZpcnN0TWF0Y2g6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjeWNsZUhpZ2hsaWdodDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAndGV4dCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIGltYWdlOiAnaW1hZ2UnXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaG93RHJvcGRvd246IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGhpZ2hsaWdodGVkSXRlbTogLTEsXHJcblx0ICAgICAgICAgICAgaWdub3JlVmFsdWVDaGFuZ2U6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ljb246IGZ1bmN0aW9uIHNob3dJY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaWNvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJGVscy5pbnB1dCkge1xyXG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaWdub3JlVmFsdWVDaGFuZ2UgJiYgdGhpcy52YWx1ZS5sZW5ndGggPj0gdGhpcy5taW5DaGFycykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSB0aGlzLmF1dG9IaWdobGlnaHRGaXJzdE1hdGNoID8gMCA6IC0xO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2spO1xyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2goaXRlbSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaXRlbSwgdGhpcy52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciB0ZXh0ID0gaXRlbVt0aGlzLmtleXMudGV4dF0gfHwgaXRlbTtcclxuXHQgICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnZhbHVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfZnV6enlzZWFyY2gyLmRlZmF1bHQpKHF1ZXJ5LCB0ZXh0LnRvTG93ZXJDYXNlKCkpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGl0ZW0pIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IHRoaXMuYXBwZW5kRGVsaW1pdGVyICsgKGl0ZW1bdGhpcy5rZXlzLnZhbHVlXSB8fCBpdGVtKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gaXRlbVt0aGlzLmtleXMudmFsdWVdIHx8IGl0ZW07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzZWxlY3RlZCcsIGl0ZW0pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzLiRlbHMuaW5wdXQuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChpbmRleCkge1xyXG5cdCAgICAgICAgICAgIHZhciBmaXJzdEluZGV4ID0gMDtcclxuXHQgICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy4kcmVmcy5pdGVtcy5sZW5ndGggLSAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTIpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IGZpcnN0SW5kZXgpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmN5Y2xlSGlnaGxpZ2h0ID8gbGFzdEluZGV4IDogaW5kZXg7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuY3ljbGVIaWdobGlnaHQgPyBmaXJzdEluZGV4IDogLTE7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gaW5kZXg7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd09uVXBEb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoaW5kZXggPCBmaXJzdEluZGV4IHx8IGluZGV4ID4gbGFzdEluZGV4KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdoaWdobGlnaHQtb3ZlcmZsb3cnLCBpbmRleCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2hpZ2hsaWdodGVkJywgdGhpcy4kcmVmcy5pdGVtc1tpbmRleF0uaXRlbSwgaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWxlY3RIaWdobGlnaHRlZDogZnVuY3Rpb24gc2VsZWN0SGlnaGxpZ2h0ZWQoaW5kZXgsIGUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24gJiYgdGhpcy4kcmVmcy5pdGVtcy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLiRyZWZzLml0ZW1zW2luZGV4XS5pdGVtKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xlYXJTZWFyY2g6IGZ1bmN0aW9uIGNsZWFyU2VhcmNoKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSAtMTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Nsb3NlZCcpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsb3NlT25FeHRlcm5hbENsaWNrOiBmdW5jdGlvbiBjbG9zZU9uRXh0ZXJuYWxDbGljayhlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRlbHMuYXV0b2NvbXBsZXRlLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiB0aGlzLnNob3dEcm9wZG93bikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdCxcclxuXHQgICAgICAgIFVpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbjogX1VpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBhdXRvZm9jdXM6IF9hdXRvZm9jdXMyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc1RleHRJbnB1dDIuZGVmYXVsdCwgX1ZhbGlkYXRlc0lucHV0Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGZ1enp5c2VhcmNoIChuZWVkbGUsIGhheXN0YWNrKSB7XHJcblx0ICB2YXIgdGxlbiA9IGhheXN0YWNrLmxlbmd0aDtcclxuXHQgIHZhciBxbGVuID0gbmVlZGxlLmxlbmd0aDtcclxuXHQgIGlmIChxbGVuID4gdGxlbikge1xyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0ICBpZiAocWxlbiA9PT0gdGxlbikge1xyXG5cdCAgICByZXR1cm4gbmVlZGxlID09PSBoYXlzdGFjaztcclxuXHQgIH1cclxuXHQgIG91dGVyOiBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBxbGVuOyBpKyspIHtcclxuXHQgICAgdmFyIG5jaCA9IG5lZWRsZS5jaGFyQ29kZUF0KGkpO1xyXG5cdCAgICB3aGlsZSAoaiA8IHRsZW4pIHtcclxuXHQgICAgICBpZiAoaGF5c3RhY2suY2hhckNvZGVBdChqKyspID09PSBuY2gpIHtcclxuXHQgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdXp6eXNlYXJjaDtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg4NilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODcpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlBdXRvY29tcGxldGVTdWdnZXN0aW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODkpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlBdXRvY29tcGxldGVTdWdnZXN0aW9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDg3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF91dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XHJcblx0XHJcblx0dmFyIF91dWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V1aWQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdXVpZDIuZGVmYXVsdC5zaG9ydCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpdGVtOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLWF1dG9jb21wbGV0ZS1zaW1wbGUnIH0sXHJcblx0ICAgICAgICBoaWdobGlnaHRlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBrZXlzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3RleHQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd2YWx1ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbWFnZTogJ2ltYWdlJ1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcGFydGlhbHM6IHtcclxuXHQgICAgICAgICd1aS1hdXRvY29tcGxldGUtc2ltcGxlJzogJ1xcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uLWl0ZW1cIiB2LXRleHQ9XCJpdGVtW2tleXMudGV4dF0gfHwgaXRlbVwiPjwvbGk+XFxuICAgICAgICAnLFxyXG5cdFxyXG5cdCAgICAgICAgJ3VpLWF1dG9jb21wbGV0ZS1pbWFnZSc6ICdcXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiaW1hZ2VcIiA6c3R5bGU9XCJ7IFxcJ2JhY2tncm91bmQtaW1hZ2VcXCc6IFxcJ3VybChcXCcgKyBpdGVtW2tleXMuaW1hZ2VdICsgXFwnKVxcJyB9XCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHRcIiB2LXRleHQ9XCJpdGVtW2tleXMudGV4dF1cIj48L2Rpdj5cXG4gICAgICAgICdcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdC8qKlxyXG5cdCAqIEZhc3QgVVVJRCBnZW5lcmF0b3IsIFJGQzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudC5cclxuXHQgKiBAYXV0aG9yIEplZmYgV2FyZCAoamN3YXJkLmNvbSkuXHJcblx0ICogQGxpY2Vuc2UgTUlUIGxpY2Vuc2VcclxuXHQgKiBAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcclxuXHQgKiovXHJcblx0XHJcblx0dmFyIGx1dCA9IFtdO1xyXG5cdFxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuXHQgICAgbHV0W2ldID0gKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcclxuXHQgICAgdmFyIGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdCAgICB2YXIgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0ICAgIHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHQgICAgdmFyIGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gbHV0W2QwICYgMHhmZl0gKyBsdXRbZDAgPj4gOCAmIDB4ZmZdICsgbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBsdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArIGx1dFtkMSAmIDB4ZmZdICsgbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIGx1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIGx1dFtkMSA+PiAyNCAmIDB4ZmZdICsgJy0nICsgbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIGx1dFtkMiA+PiAxNiAmIDB4ZmZdICsgbHV0W2QyID4+IDI0ICYgMHhmZl0gKyBsdXRbZDMgJiAweGZmXSArIGx1dFtkMyA+PiA4ICYgMHhmZl0gKyBsdXRbZDMgPj4gMTYgJiAweGZmXSArIGx1dFtkMyA+PiAyNCAmIDB4ZmZdO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIHNob3J0ID0gZnVuY3Rpb24gc2hvcnQocHJlZml4KSB7XHJcblx0ICAgIHByZWZpeCA9IHByZWZpeCB8fCAnJztcclxuXHRcclxuXHQgICAgdmFyIHV1aWQgPSBnZW5lcmF0ZSgpO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gcHJlZml4ICsgdXVpZC5zcGxpdCgnLScpWzBdO1xyXG5cdH07XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBnZW5lcmF0ZTogZ2VuZXJhdGUsXHJcblx0ICAgIHNob3J0OiBzaG9ydFxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsaVxcbiAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb25cXFwiIDpjbGFzcz1cXFwiW3BhcnRpYWwsIHsgJ2hpZ2hsaWdodGVkJzogaGlnaGxpZ2h0ZWQgfV1cXFwiXFxuICAgIDppZD1cXFwiaWRcXFwiXFxuPlxcbiAgICA8cGFydGlhbCA6bmFtZT1cXFwicGFydGlhbFxcXCI+PC9wYXJ0aWFsPlxcbjwvbGk+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiA5MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgIHRoaXMuZWwuYXV0b2ZvY3VzID0gQm9vbGVhbih2YWx1ZSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDkxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBuYW1lOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnJyxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpY29uOiBTdHJpbmcsXHJcblx0ICAgICAgICBpY29uUmlnaHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoZWxwVGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVib3VuY2U6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93RmVlZGJhY2s6IGZ1bmN0aW9uIHNob3dGZWVkYmFjaygpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2FuQmVWYWxpZGF0ZWQgPSBCb29sZWFuKHRoaXMudmFsaWRhdGlvblJ1bGVzKTtcclxuXHQgICAgICAgICAgICB2YXIgaGFzSGVscFRleHQgPSBCb29sZWFuKHRoaXMuaGVscFRleHQpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjYW5CZVZhbGlkYXRlZCB8fCBoYXNIZWxwVGV4dDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA5MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdmFsaWRhdG9yanMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcclxuXHRcclxuXHR2YXIgX3ZhbGlkYXRvcmpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkYXRvcmpzKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHZhbGlkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpcnR5OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlVmFsaWRhdGlvbkVycm9yczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB2YWxpZGF0aW9uUnVsZXM6IFtTdHJpbmcsIEFycmF5XSxcclxuXHQgICAgICAgIHZhbGlkYXRpb25NZXNzYWdlczogT2JqZWN0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcjogJydcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpzZXQtdmFsaWRpdHknOiBmdW5jdGlvbiB1aUlucHV0U2V0VmFsaWRpdHkodmFsaWQsIGVycm9yLCBpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWxpZGl0eSh2YWxpZCwgZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRpb25SdWxlcyB8fCAhdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIHJ1bGVzID0ge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWxpZGF0aW9uUnVsZXNcclxuXHQgICAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uID0gbmV3IF92YWxpZGF0b3JqczIuZGVmYXVsdChkYXRhLCBydWxlcywgdGhpcy52YWxpZGF0aW9uTWVzc2FnZXMpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhbGlkYXRpb24uc2V0QXR0cmlidXRlTmFtZXMoeyB2YWx1ZTogdGhpcy5uYW1lLnJlcGxhY2UoL18vZywgJyAnKSB9KTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbGlkaXR5KHZhbGlkYXRpb24ucGFzc2VzKCksIHZhbGlkYXRpb24uZXJyb3JzLmZpcnN0KCd2YWx1ZScpKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZXRWYWxpZGl0eTogZnVuY3Rpb24gc2V0VmFsaWRpdHkodmFsaWQsIGVycm9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZCA9IHZhbGlkO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdmFsaWQgJiYgZXJyb3IgJiYgZXJyb3IubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yID0gZXJyb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDkzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgUnVsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcclxuXHR2YXIgTGFuZyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xyXG5cdHZhciBFcnJvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNik7XHJcblx0dmFyIEF0dHJpYnV0ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcclxuXHR2YXIgQXN5bmNSZXNvbHZlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XHJcblx0XHJcblx0dmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uKGlucHV0LCBydWxlcywgY3VzdG9tTWVzc2FnZXMpIHtcclxuXHQgIHZhciBsYW5nID0gVmFsaWRhdG9yLmdldERlZmF1bHRMYW5nKCk7XHJcblx0ICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcblx0ICB0aGlzLm1lc3NhZ2VzID0gTGFuZy5fbWFrZShsYW5nKTtcclxuXHQgIHRoaXMubWVzc2FnZXMuX3NldEN1c3RvbShjdXN0b21NZXNzYWdlcyk7XHJcblx0ICB0aGlzLnNldEF0dHJpYnV0ZUZvcm1hdHRlcihWYWxpZGF0b3IucHJvdG90eXBlLmF0dHJpYnV0ZUZvcm1hdHRlcik7XHJcblx0XHJcblx0ICB0aGlzLmVycm9ycyA9IG5ldyBFcnJvcnMoKTtcclxuXHQgIHRoaXMuZXJyb3JDb3VudCA9IDA7XHJcblx0XHJcblx0ICB0aGlzLmhhc0FzeW5jID0gZmFsc2U7XHJcblx0ICB0aGlzLnJ1bGVzID0gdGhpcy5fcGFyc2VSdWxlcyhydWxlcyk7XHJcblx0fTtcclxuXHRcclxuXHRWYWxpZGF0b3IucHJvdG90eXBlID0ge1xyXG5cdFxyXG5cdCAgY29uc3RydWN0b3I6IFZhbGlkYXRvcixcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGVmYXVsdCBsYW5ndWFnZVxyXG5cdCAgICpcclxuXHQgICAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIGxhbmc6ICdlbicsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIE51bWVyaWMgYmFzZWQgcnVsZXNcclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7YXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIG51bWVyaWNSdWxlczogWydpbnRlZ2VyJywgJ251bWVyaWMnXSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQXR0cmlidXRlIGZvcm1hdHRlci5cclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcblx0ICAgKi9cclxuXHQgIGF0dHJpYnV0ZUZvcm1hdHRlcjogQXR0cmlidXRlcy5mb3JtYXR0ZXIsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJ1biB2YWxpZGF0b3JcclxuXHQgICAqXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGl0IHBhc3NlczsgdHJ1ZSA9IHBhc3NlcywgZmFsc2UgPSBmYWlsc1xyXG5cdCAgICovXHJcblx0ICBjaGVjazogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHZhciBzZWxmID0gdGhpcztcclxuXHRcclxuXHQgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIHRoaXMucnVsZXMpIHtcclxuXHQgICAgICB2YXIgYXR0cmlidXRlUnVsZXMgPSB0aGlzLnJ1bGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLmlucHV0W2F0dHJpYnV0ZV07IC8vIGlmIGl0IGRvZXNudCBleGlzdCBpbiBpbnB1dCwgaXQgd2lsbCBiZSB1bmRlZmluZWRcclxuXHRcclxuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXR0cmlidXRlUnVsZXMubGVuZ3RoLCBydWxlLCBydWxlT3B0aW9ucywgcnVsZVBhc3NlZDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgICBydWxlT3B0aW9ucyA9IGF0dHJpYnV0ZVJ1bGVzW2ldO1xyXG5cdCAgICAgICAgcnVsZSA9IHRoaXMuZ2V0UnVsZShydWxlT3B0aW9ucy5uYW1lKTtcclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5faXNWYWxpZGF0YWJsZShydWxlLCBpbnB1dFZhbHVlKSkge1xyXG5cdCAgICAgICAgICBjb250aW51ZTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJ1bGVQYXNzZWQgPSBydWxlLnZhbGlkYXRlKGlucHV0VmFsdWUsIHJ1bGVPcHRpb25zLnZhbHVlLCBhdHRyaWJ1dGUpO1xyXG5cdCAgICAgICAgaWYgKCFydWxlUGFzc2VkKSB7XHJcblx0ICAgICAgICAgIHRoaXMuX2FkZEZhaWx1cmUocnVsZSk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5fc2hvdWxkU3RvcFZhbGlkYXRpbmcoYXR0cmlidXRlLCBydWxlUGFzc2VkKSkge1xyXG5cdCAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3VudCA9PT0gMDtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJ1biBhc3luYyB2YWxpZGF0b3JcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXNzZXNcclxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhaWxzXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBjaGVja0FzeW5jOiBmdW5jdGlvbihwYXNzZXMsIGZhaWxzKSB7XHJcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICAgIHBhc3NlcyA9IHBhc3NlcyB8fCBmdW5jdGlvbigpIHt9O1xyXG5cdCAgICBmYWlscyA9IGZhaWxzIHx8IGZ1bmN0aW9uKCkge307XHJcblx0XHJcblx0ICAgIHZhciBmYWlsc09uZSA9IGZ1bmN0aW9uKHJ1bGUsIG1lc3NhZ2UpIHtcclxuXHQgICAgICBfdGhpcy5fYWRkRmFpbHVyZShydWxlLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgdmFyIHJlc29sdmVkQWxsID0gZnVuY3Rpb24oYWxsUGFzc2VkKSB7XHJcblx0ICAgICAgaWYgKGFsbFBhc3NlZCkge1xyXG5cdCAgICAgICAgcGFzc2VzKCk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIGZhaWxzKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICB2YXIgdmFsaWRhdGVSdWxlID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSwgcnVsZU9wdGlvbnMsIGF0dHJpYnV0ZSwgcnVsZSkge1xyXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgIHZhciByZXNvbHZlckluZGV4ID0gYXN5bmNSZXNvbHZlcnMuYWRkKHJ1bGUpO1xyXG5cdCAgICAgICAgcnVsZS52YWxpZGF0ZShpbnB1dFZhbHVlLCBydWxlT3B0aW9ucy52YWx1ZSwgYXR0cmlidXRlLCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgYXN5bmNSZXNvbHZlcnMucmVzb2x2ZShyZXNvbHZlckluZGV4KTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgIH07XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIHZhciBhc3luY1Jlc29sdmVycyA9IG5ldyBBc3luY1Jlc29sdmVycyhmYWlsc09uZSwgcmVzb2x2ZWRBbGwpO1xyXG5cdFxyXG5cdCAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gdGhpcy5ydWxlcykge1xyXG5cdCAgICAgIHZhciBhdHRyaWJ1dGVSdWxlcyA9IHRoaXMucnVsZXNbYXR0cmlidXRlXTtcclxuXHQgICAgICB2YXIgaW5wdXRWYWx1ZSA9IHRoaXMuaW5wdXRbYXR0cmlidXRlXTsgLy8gaWYgaXQgZG9lc250IGV4aXN0IGluIGlucHV0LCBpdCB3aWxsIGJlIHVuZGVmaW5lZFxyXG5cdFxyXG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhdHRyaWJ1dGVSdWxlcy5sZW5ndGgsIHJ1bGUsIHJ1bGVPcHRpb25zOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAgIHJ1bGVPcHRpb25zID0gYXR0cmlidXRlUnVsZXNbaV07XHJcblx0XHJcblx0ICAgICAgICBydWxlID0gdGhpcy5nZXRSdWxlKHJ1bGVPcHRpb25zLm5hbWUpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkYXRhYmxlKHJ1bGUsIGlucHV0VmFsdWUpKSB7XHJcblx0ICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFsaWRhdGVSdWxlKGlucHV0VmFsdWUsIHJ1bGVPcHRpb25zLCBhdHRyaWJ1dGUsIHJ1bGUpKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGFzeW5jUmVzb2x2ZXJzLmVuYWJsZUZpcmluZygpO1xyXG5cdCAgICBhc3luY1Jlc29sdmVycy5maXJlKCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBBZGQgZmFpbHVyZSBhbmQgZXJyb3IgbWVzc2FnZSBmb3IgZ2l2ZW4gcnVsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7UnVsZX0gcnVsZVxyXG5cdCAgICovXHJcblx0ICBfYWRkRmFpbHVyZTogZnVuY3Rpb24ocnVsZSkge1xyXG5cdCAgICB2YXIgbXNnID0gdGhpcy5tZXNzYWdlcy5yZW5kZXIocnVsZSk7XHJcblx0ICAgIHRoaXMuZXJyb3JzLmFkZChydWxlLmF0dHJpYnV0ZSwgbXNnKTtcclxuXHQgICAgdGhpcy5lcnJvckNvdW50Kys7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBQYXJzZSBydWxlcywgbm9ybWFsaXppbmcgZm9ybWF0IGludG86IHsgYXR0cmlidXRlOiBbeyBuYW1lOiAnYWdlJywgdmFsdWU6IDMgfV0gfVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge29iamVjdH0gcnVsZXNcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH1cclxuXHQgICAqL1xyXG5cdCAgX3BhcnNlUnVsZXM6IGZ1bmN0aW9uKHJ1bGVzKSB7XHJcblx0ICAgIHZhciBwYXJzZWRSdWxlcyA9IHt9O1xyXG5cdCAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gcnVsZXMpIHtcclxuXHQgICAgICB2YXIgcnVsZXNBcnJheSA9IHJ1bGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgICAgdmFyIGF0dHJpYnV0ZVJ1bGVzID0gW107XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBydWxlc0FycmF5ID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgcnVsZXNBcnJheSA9IHJ1bGVzQXJyYXkuc3BsaXQoJ3wnKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJ1bGVzQXJyYXkubGVuZ3RoLCBydWxlOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAgIHJ1bGUgPSB0aGlzLl9leHRyYWN0UnVsZUFuZFJ1bGVWYWx1ZShydWxlc0FycmF5W2ldKTtcclxuXHQgICAgICAgIGlmIChSdWxlcy5pc0FzeW5jKHJ1bGUubmFtZSkpIHtcclxuXHQgICAgICAgICAgdGhpcy5oYXNBc3luYyA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBhdHRyaWJ1dGVSdWxlcy5wdXNoKHJ1bGUpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBwYXJzZWRSdWxlc1thdHRyaWJ1dGVdID0gYXR0cmlidXRlUnVsZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHBhcnNlZFJ1bGVzO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRXh0cmFjdCBhIHJ1bGUgYW5kIGEgdmFsdWUgZnJvbSBhIHJ1bGVTdHJpbmcgKGkuZS4gbWluOjMpLCBydWxlID0gbWluLCB2YWx1ZSA9IDNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJ1bGVTdHJpbmcgbWluOjNcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIHJ1bGUgYW5kIHZhbHVlXHJcblx0ICAgKi9cclxuXHQgIF9leHRyYWN0UnVsZUFuZFJ1bGVWYWx1ZTogZnVuY3Rpb24ocnVsZVN0cmluZykge1xyXG5cdCAgICB2YXIgcnVsZSA9IHt9LFxyXG5cdCAgICAgIHJ1bGVBcnJheTtcclxuXHRcclxuXHQgICAgcnVsZS5uYW1lID0gcnVsZVN0cmluZztcclxuXHRcclxuXHQgICAgaWYgKHJ1bGVTdHJpbmcuaW5kZXhPZignOicpID49IDApIHtcclxuXHQgICAgICBydWxlQXJyYXkgPSBydWxlU3RyaW5nLnNwbGl0KCc6Jyk7XHJcblx0ICAgICAgcnVsZS5uYW1lID0gcnVsZUFycmF5WzBdO1xyXG5cdCAgICAgIHJ1bGUudmFsdWUgPSBydWxlQXJyYXkuc2xpY2UoMSkuam9pbihcIjpcIik7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHJ1bGU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgYXR0cmlidXRlIGhhcyBhbnkgb2YgdGhlIGdpdmVuIHJ1bGVzXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlXHJcblx0ICAgKiBAcGFyYW0gIHthcnJheX0gICBmaW5kUnVsZXNcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIF9oYXNSdWxlOiBmdW5jdGlvbihhdHRyaWJ1dGUsIGZpbmRSdWxlcykge1xyXG5cdCAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzW2F0dHJpYnV0ZV0gfHwgW107XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBydWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmIChmaW5kUnVsZXMuaW5kZXhPZihydWxlc1tpXS5uYW1lKSA+IC0xKSB7XHJcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIGF0dHJpYnV0ZSBoYXMgYW55IG51bWVyaWMtYmFzZWQgcnVsZXMuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlXHJcblx0ICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfaGFzTnVtZXJpY1J1bGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5faGFzUnVsZShhdHRyaWJ1dGUsIHRoaXMubnVtZXJpY1J1bGVzKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiBydWxlIGlzIHZhbGlkYXRhYmxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7UnVsZX0gICBydWxlXHJcblx0ICAgKiBAcGFyYW0gIHttaXhlZH0gIHZhbHVlXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfaXNWYWxpZGF0YWJsZTogZnVuY3Rpb24ocnVsZSwgdmFsdWUpIHtcclxuXHQgICAgaWYgKFJ1bGVzLmlzSW1wbGljaXQocnVsZS5uYW1lKSkge1xyXG5cdCAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0aGlzLmdldFJ1bGUoJ3JlcXVpcmVkJykudmFsaWRhdGUodmFsdWUpO1xyXG5cdCAgfSxcclxuXHRcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBzdG9wIHZhbGlkYXRpbmcuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSAge2Jvb2xlYW59IHJ1bGVQYXNzZWRcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIF9zaG91bGRTdG9wVmFsaWRhdGluZzogZnVuY3Rpb24oYXR0cmlidXRlLCBydWxlUGFzc2VkKSB7XHJcblx0XHJcblx0ICAgIHZhciBzdG9wT25BdHRyaWJ1dGVzID0gdGhpcy5zdG9wT25BdHRyaWJ1dGVzO1xyXG5cdCAgICBpZiAoc3RvcE9uQXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgcnVsZVBhc3NlZCA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAoc3RvcE9uQXR0cmlidXRlcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0ICAgICAgcmV0dXJuIHN0b3BPbkF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGUpID4gLTE7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgY3VzdG9tIGF0dHJpYnV0ZSBuYW1lcy5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgc2V0QXR0cmlidXRlTmFtZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgdGhpcy5tZXNzYWdlcy5fc2V0QXR0cmlidXRlTmFtZXMoYXR0cmlidXRlcyk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdGhlIGF0dHJpYnV0ZSBmb3JtYXR0ZXIuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtmdWN0aW9ufSBmdW5jXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBzZXRBdHRyaWJ1dGVGb3JtYXR0ZXI6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHQgICAgdGhpcy5tZXNzYWdlcy5fc2V0QXR0cmlidXRlRm9ybWF0dGVyKGZ1bmMpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHZhbGlkYXRpb24gcnVsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxyXG5cdCAgICogQHJldHVybiB7UnVsZX1cclxuXHQgICAqL1xyXG5cdCAgZ2V0UnVsZTogZnVuY3Rpb24obmFtZSkge1xyXG5cdCAgICByZXR1cm4gUnVsZXMubWFrZShuYW1lLCB0aGlzKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFN0b3Agb24gZmlyc3QgZXJyb3IuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7Ym9vbGVhbnxhcnJheX0gQW4gYXJyYXkgb2YgYXR0cmlidXRlcyBvciBib29sZWFuIHRydWUvZmFsc2UgZm9yIGFsbCBhdHRyaWJ1dGVzLlxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgc3RvcE9uRXJyb3I6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgdGhpcy5zdG9wT25BdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiB2YWxpZGF0aW9uIHBhc3Nlc1xyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhc3Nlc1xyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcblx0ICAgKi9cclxuXHQgIHBhc3NlczogZnVuY3Rpb24ocGFzc2VzKSB7XHJcblx0ICAgIHZhciBhc3luYyA9IHRoaXMuX2NoZWNrQXN5bmMoJ3Bhc3NlcycsIHBhc3Nlcyk7XHJcblx0ICAgIGlmIChhc3luYykge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmNoZWNrQXN5bmMocGFzc2VzKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIHZhbGlkYXRpb24gZmFpbHNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWlsc1xyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcblx0ICAgKi9cclxuXHQgIGZhaWxzOiBmdW5jdGlvbihmYWlscykge1xyXG5cdCAgICB2YXIgYXN5bmMgPSB0aGlzLl9jaGVja0FzeW5jKCdmYWlscycsIGZhaWxzKTtcclxuXHQgICAgaWYgKGFzeW5jKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuY2hlY2tBc3luYyhmdW5jdGlvbigpIHt9LCBmYWlscyk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuICF0aGlzLmNoZWNrKCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBDaGVjayBpZiB2YWxpZGF0aW9uIHNob3VsZCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHlcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgZnVuY05hbWUgTmFtZSBvZiB0aGUgY2FsbGVyXHJcblx0ICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIF9jaGVja0FzeW5jOiBmdW5jdGlvbihmdW5jTmFtZSwgY2FsbGJhY2spIHtcclxuXHQgICAgdmFyIGhhc0NhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nO1xyXG5cdCAgICBpZiAodGhpcy5oYXNBc3luYyAmJiAhaGFzQ2FsbGJhY2spIHtcclxuXHQgICAgICB0aHJvdyBmdW5jTmFtZSArICcgZXhwZWN0cyBhIGNhbGxiYWNrIHdoZW4gYXN5bmMgcnVsZXMgYXJlIGJlaW5nIHRlc3RlZC4nO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0aGlzLmhhc0FzeW5jIHx8IGhhc0NhbGxiYWNrO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU2V0IG1lc3NhZ2VzIGZvciBsYW5ndWFnZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbWVzc2FnZXNcclxuXHQgKiBAcmV0dXJuIHt0aGlzfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci5zZXRNZXNzYWdlcyA9IGZ1bmN0aW9uKGxhbmcsIG1lc3NhZ2VzKSB7XHJcblx0ICBMYW5nLl9zZXQobGFuZywgbWVzc2FnZXMpO1xyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBHZXQgbWVzc2FnZXMgZm9yIGdpdmVuIGxhbmd1YWdlXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGxhbmdcclxuXHQgKiBAcmV0dXJuIHtNZXNzYWdlc31cclxuXHQgKi9cclxuXHRWYWxpZGF0b3IuZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbihsYW5nKSB7XHJcblx0ICByZXR1cm4gTGFuZy5fZ2V0KGxhbmcpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgbGFuZ3VhZ2UgdG8gdXNlXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ1xyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnVzZUxhbmcgPSBmdW5jdGlvbihsYW5nKSB7XHJcblx0ICB0aGlzLnByb3RvdHlwZS5sYW5nID0gbGFuZztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEdldCBkZWZhdWx0IGxhbmd1YWdlXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLmdldERlZmF1bHRMYW5nID0gZnVuY3Rpb24oKSB7XHJcblx0ICByZXR1cm4gdGhpcy5wcm90b3R5cGUubGFuZztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgYXR0cmlidXRlIGZvcm1hdHRlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7ZnVjdGlvbn0gZnVuY1xyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnNldEF0dHJpYnV0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHQgIHRoaXMucHJvdG90eXBlLmF0dHJpYnV0ZUZvcm1hdHRlciA9IGZ1bmM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBTdG9wIG9uIGZpcnN0IGVycm9yLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7Ym9vbGVhbnxhcnJheX0gQW4gYXJyYXkgb2YgYXR0cmlidXRlcyBvciBib29sZWFuIHRydWUvZmFsc2UgZm9yIGFsbCBhdHRyaWJ1dGVzLlxyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnN0b3BPbkVycm9yID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xyXG5cdCAgdGhpcy5wcm90b3R5cGUuc3RvcE9uQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZWdpc3RlciBjdXN0b20gdmFsaWRhdGlvbiBydWxlXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZVxyXG5cdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmblxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gICBtZXNzYWdlXHJcblx0ICogQHJldHVybiB7dm9pZH1cclxuXHQgKi9cclxuXHRWYWxpZGF0b3IucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lLCBmbiwgbWVzc2FnZSkge1xyXG5cdCAgdmFyIGxhbmcgPSBWYWxpZGF0b3IuZ2V0RGVmYXVsdExhbmcoKTtcclxuXHQgIFJ1bGVzLnJlZ2lzdGVyKG5hbWUsIGZuKTtcclxuXHQgIExhbmcuX3NldFJ1bGVNZXNzYWdlKGxhbmcsIG5hbWUsIG1lc3NhZ2UpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXIgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gcnVsZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm5cclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWVzc2FnZVxyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnJlZ2lzdGVyQXN5bmMgPSBmdW5jdGlvbihuYW1lLCBmbiwgbWVzc2FnZSkge1xyXG5cdCAgdmFyIGxhbmcgPSBWYWxpZGF0b3IuZ2V0RGVmYXVsdExhbmcoKTtcclxuXHQgIFJ1bGVzLnJlZ2lzdGVyQXN5bmMobmFtZSwgZm4pO1xyXG5cdCAgTGFuZy5fc2V0UnVsZU1lc3NhZ2UobGFuZywgbmFtZSwgbWVzc2FnZSk7XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA5NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIHJ1bGVzID0ge1xyXG5cdFxyXG5cdCAgcmVxdWlyZWQ6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICB2YXIgc3RyO1xyXG5cdFxyXG5cdCAgICBpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XHJcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHN0ciA9IFN0cmluZyh2YWwpLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcclxuXHQgICAgcmV0dXJuIHN0ci5sZW5ndGggPiAwID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIHJlcXVpcmVkX2lmOiBmdW5jdGlvbih2YWwsIHJlcSwgYXR0cmlidXRlKSB7XHJcblx0ICAgIHJlcSA9IHRoaXMuZ2V0UGFyYW1ldGVycygpO1xyXG5cdCAgICBpZiAodGhpcy52YWxpZGF0b3IuaW5wdXRbcmVxWzBdXSA9PT0gcmVxWzFdKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yLmdldFJ1bGUoJ3JlcXVpcmVkJykudmFsaWRhdGUodmFsKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvLyBjb21wYXJlcyB0aGUgc2l6ZSBvZiBzdHJpbmdzXHJcblx0ICAvLyB3aXRoIG51bWJlcnMsIGNvbXBhcmVzIHRoZSB2YWx1ZVxyXG5cdCAgc2l6ZTogZnVuY3Rpb24odmFsLCByZXEsIGF0dHJpYnV0ZSkge1xyXG5cdCAgICBpZiAodmFsKSB7XHJcblx0ICAgICAgcmVxID0gcGFyc2VGbG9hdChyZXEpO1xyXG5cdFxyXG5cdCAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHJcblx0ICAgICAgcmV0dXJuIHNpemUgPT09IHJlcTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBzdHJpbmc6IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQ29tcGFyZXMgdGhlIHNpemUgb2Ygc3RyaW5ncyBvciB0aGUgdmFsdWUgb2YgbnVtYmVycyBpZiB0aGVyZSBpcyBhIHRydXRoeSB2YWx1ZVxyXG5cdCAgICovXHJcblx0ICBtaW46IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHQgICAgcmV0dXJuIHNpemUgPj0gcmVxO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQ29tcGFyZXMgdGhlIHNpemUgb2Ygc3RyaW5ncyBvciB0aGUgdmFsdWUgb2YgbnVtYmVycyBpZiB0aGVyZSBpcyBhIHRydXRoeSB2YWx1ZVxyXG5cdCAgICovXHJcblx0ICBtYXg6IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHQgICAgcmV0dXJuIHNpemUgPD0gcmVxO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGJldHdlZW46IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgcmVxID0gdGhpcy5nZXRQYXJhbWV0ZXJzKCk7XHJcblx0ICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0ICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KHJlcVswXSwgMTApO1xyXG5cdCAgICB2YXIgbWF4ID0gcGFyc2VGbG9hdChyZXFbMV0sIDEwKTtcclxuXHQgICAgcmV0dXJuIHNpemUgPj0gbWluICYmIHNpemUgPD0gbWF4O1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGVtYWlsOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgdmFyIHJlID0gL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XHJcblx0ICAgIHJldHVybiByZS50ZXN0KHZhbCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgbnVtZXJpYzogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHZhciBudW07XHJcblx0XHJcblx0ICAgIG51bSA9IE51bWJlcih2YWwpOyAvLyB0cmllcyB0byBjb252ZXJ0IHZhbHVlIHRvIGEgbnVtYmVyLiB1c2VmdWwgaWYgdmFsdWUgaXMgY29taW5nIGZyb20gZm9ybSBlbGVtZW50XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtKSAmJiB0eXBlb2YgdmFsICE9PSAnYm9vbGVhbicpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblx0XHJcblx0ICBhcnJheTogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICB1cmw6IGZ1bmN0aW9uKHVybCkge1xyXG5cdCAgICByZXR1cm4gKC9eaHR0cHM/OlxcL1xcL1xcUysvKS50ZXN0KHVybCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgYWxwaGE6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICByZXR1cm4gKC9eW2EtekEtWl0rJC8pLnRlc3QodmFsKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBhbHBoYV9kYXNoOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgcmV0dXJuICgvXlthLXpBLVowLTlfXFwtXSskLykudGVzdCh2YWwpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGFscGhhX251bTogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiAoL15bYS16QS1aMC05XSskLykudGVzdCh2YWwpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIHNhbWU6IGZ1bmN0aW9uKHZhbCwgcmVxKSB7XHJcblx0ICAgIHZhciB2YWwxID0gdGhpcy52YWxpZGF0b3IuaW5wdXRbcmVxXTtcclxuXHQgICAgdmFyIHZhbDIgPSB2YWw7XHJcblx0XHJcblx0ICAgIGlmICh2YWwxID09PSB2YWwyKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGRpZmZlcmVudDogZnVuY3Rpb24odmFsLCByZXEpIHtcclxuXHQgICAgdmFyIHZhbDEgPSB0aGlzLnZhbGlkYXRvci5pbnB1dFtyZXFdO1xyXG5cdCAgICB2YXIgdmFsMiA9IHZhbDtcclxuXHRcclxuXHQgICAgaWYgKHZhbDEgIT09IHZhbDIpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgXCJpblwiOiBmdW5jdGlvbih2YWwsIHJlcSkge1xyXG5cdCAgICB2YXIgbGlzdCwgaTtcclxuXHRcclxuXHQgICAgaWYgKHZhbCkge1xyXG5cdCAgICAgIGxpc3QgPSByZXEuc3BsaXQoJywnKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodmFsICYmICEodmFsIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcblx0ICAgICAgdmFsID0gU3RyaW5nKHZhbCk7IC8vIGlmIGl0IGlzIGEgbnVtYmVyXHJcblx0XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgIGlmICh2YWwgPT09IGxpc3RbaV0pIHtcclxuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodmFsICYmIHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgaWYgKGxpc3QuaW5kZXhPZih2YWxbaV0pIDwgMCkge1xyXG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIG5vdF9pbjogZnVuY3Rpb24odmFsLCByZXEpIHtcclxuXHQgICAgdmFyIGxpc3QgPSByZXEuc3BsaXQoJywnKTtcclxuXHQgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xyXG5cdCAgICB2YXIgcmV0dXJuVmFsID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgdmFsID0gU3RyaW5nKHZhbCk7IC8vIGNvbnZlcnQgdmFsIHRvIGEgc3RyaW5nIGlmIGl0IGlzIGEgbnVtYmVyXHJcblx0XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICBpZiAodmFsID09PSBsaXN0W2ldKSB7XHJcblx0ICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcclxuXHQgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gcmV0dXJuVmFsO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGFjY2VwdGVkOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgaWYgKHZhbCA9PT0gJ29uJyB8fCB2YWwgPT09ICd5ZXMnIHx8IHZhbCA9PT0gMSB8fCB2YWwgPT09ICcxJyB8fCB2YWwgPT09IHRydWUpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgY29uZmlybWVkOiBmdW5jdGlvbih2YWwsIHJlcSwga2V5KSB7XHJcblx0ICAgIHZhciBjb25maXJtZWRLZXkgPSBrZXkgKyAnX2NvbmZpcm1hdGlvbic7XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLnZhbGlkYXRvci5pbnB1dFtjb25maXJtZWRLZXldID09PSB2YWwpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgaW50ZWdlcjogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiBTdHJpbmcocGFyc2VJbnQodmFsLCAxMCkpID09PSBTdHJpbmcodmFsKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBkaWdpdHM6IGZ1bmN0aW9uKHZhbCwgcmVxKSB7XHJcblx0ICAgIHZhciBudW1lcmljUnVsZSA9IHRoaXMudmFsaWRhdG9yLmdldFJ1bGUoJ251bWVyaWMnKTtcclxuXHQgICAgaWYgKG51bWVyaWNSdWxlLnZhbGlkYXRlKHZhbCkgJiYgU3RyaW5nKHZhbCkubGVuZ3RoID09PSBwYXJzZUludChyZXEpKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIHJlZ2V4OiBmdW5jdGlvbih2YWwsIHJlcSkge1xyXG5cdCAgICB2YXIgbW9kID0gL1tnfGl8bV17MSwzfSQvO1xyXG5cdCAgICB2YXIgZmxhZyA9IHJlcS5tYXRjaChtb2QpO1xyXG5cdCAgICBmbGFnID0gZmxhZyA/IGZsYWdbMF0gOiBcImlcIjtcclxuXHQgICAgcmVxID0gcmVxLnJlcGxhY2UobW9kLCBcIlwiKS5zbGljZSgxLCAtMSk7XHJcblx0ICAgIHJlcSA9IG5ldyBSZWdFeHAocmVxLCBmbGFnKTtcclxuXHQgICAgcmV0dXJuICEhdmFsLm1hdGNoKHJlcSk7XHJcblx0ICB9XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBSdWxlKG5hbWUsIGZuLCBhc3luYykge1xyXG5cdCAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgIHRoaXMuZm4gPSBmbjtcclxuXHQgIHRoaXMucGFzc2VzID0gbnVsbDtcclxuXHQgIHRoaXMuY3VzdG9tTWVzc2FnZSA9IHVuZGVmaW5lZDtcclxuXHQgIHRoaXMuYXN5bmMgPSBhc3luYztcclxuXHR9XHJcblx0XHJcblx0UnVsZS5wcm90b3R5cGUgPSB7XHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFZhbGlkYXRlIHJ1bGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHttaXhlZH0gaW5wdXRWYWx1ZVxyXG5cdCAgICogQHBhcmFtICB7bWl4ZWR9IHJ1bGVWYWx1ZVxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcblx0ICAgKi9cclxuXHQgIHZhbGlkYXRlOiBmdW5jdGlvbihpbnB1dFZhbHVlLCBydWxlVmFsdWUsIGF0dHJpYnV0ZSwgY2FsbGJhY2spIHtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHQgICAgdGhpcy5fc2V0VmFsaWRhdGluZ0RhdGEoYXR0cmlidXRlLCBpbnB1dFZhbHVlLCBydWxlVmFsdWUpO1xyXG5cdCAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdCAgICAgIHZhciBoYW5kbGVSZXNwb25zZSA9IGZ1bmN0aW9uKHBhc3NlcywgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgX3RoaXMucmVzcG9uc2UocGFzc2VzLCBtZXNzYWdlKTtcclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIGlmICh0aGlzLmFzeW5jKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5mbi5hcHBseSh0aGlzLCBbaW5wdXRWYWx1ZSwgcnVsZVZhbHVlLCBhdHRyaWJ1dGUsIGhhbmRsZVJlc3BvbnNlXSk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZSh0aGlzLmZuLmFwcGx5KHRoaXMsIFtpbnB1dFZhbHVlLCBydWxlVmFsdWUsIGF0dHJpYnV0ZV0pKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRoaXMuZm4uYXBwbHkodGhpcywgW2lucHV0VmFsdWUsIHJ1bGVWYWx1ZSwgYXR0cmlidXRlXSk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdmFsaWRhdGluZyBkYXRhXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxyXG5cdCAgICogQHBhcmFtIHttaXhlZH0gaW5wdXRWYWx1ZVxyXG5cdCAgICogQHBhcmFtIHttaXhlZH0gcnVsZVZhbHVlXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfc2V0VmFsaWRhdGluZ0RhdGE6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgaW5wdXRWYWx1ZSwgcnVsZVZhbHVlKSB7XHJcblx0ICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xyXG5cdCAgICB0aGlzLmlucHV0VmFsdWUgPSBpbnB1dFZhbHVlO1xyXG5cdCAgICB0aGlzLnJ1bGVWYWx1ZSA9IHJ1bGVWYWx1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCBwYXJhbWV0ZXJzXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7YXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIGdldFBhcmFtZXRlcnM6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5ydWxlVmFsdWUgPyB0aGlzLnJ1bGVWYWx1ZS5zcGxpdCgnLCcpIDogW107XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgdHJ1ZSBzaXplIG9mIHZhbHVlXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7aW50ZWdlcnxmbG9hdH1cclxuXHQgICAqL1xyXG5cdCAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXRWYWx1ZTtcclxuXHRcclxuXHQgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHQgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLnZhbGlkYXRvci5faGFzTnVtZXJpY1J1bGUodGhpcy5hdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHRoZSB0eXBlIG9mIHZhbHVlIGJlaW5nIGNoZWNrZWQ7IG51bWVyaWMgb3Igc3RyaW5nLlxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgX2dldFZhbHVlVHlwZTogZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdGhpcy5pbnB1dFZhbHVlID09PSAnbnVtYmVyJyB8fCB0aGlzLnZhbGlkYXRvci5faGFzTnVtZXJpY1J1bGUodGhpcy5hdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuICdudW1lcmljJztcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gJ3N0cmluZyc7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdGhlIGFzeW5jIGNhbGxiYWNrIHJlc3BvbnNlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7Ym9vbGVhbnx1bmRlZmluZWR9IHBhc3NlcyAgV2hldGhlciB2YWxpZGF0aW9uIHBhc3NlZFxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfHVuZGVmaW5lZH0gbWVzc2FnZSBDdXN0b20gZXJyb3IgbWVzc2FnZVxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVzcG9uc2U6IGZ1bmN0aW9uKHBhc3NlcywgbWVzc2FnZSkge1xyXG5cdCAgICB0aGlzLnBhc3NlcyA9IChwYXNzZXMgPT09IHVuZGVmaW5lZCB8fCBwYXNzZXMgPT09IHRydWUpO1xyXG5cdCAgICB0aGlzLmN1c3RvbU1lc3NhZ2UgPSBtZXNzYWdlO1xyXG5cdCAgICB0aGlzLmNhbGxiYWNrKHRoaXMucGFzc2VzLCBtZXNzYWdlKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCB2YWxpZGF0b3IgaW5zdGFuY2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1ZhbGlkYXRvcn0gdmFsaWRhdG9yXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBzZXRWYWxpZGF0b3I6IGZ1bmN0aW9uKHZhbGlkYXRvcikge1xyXG5cdCAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcclxuXHQgIH1cclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBtYW5hZ2VyID0ge1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBMaXN0IG9mIGFzeW5jIHJ1bGUgbmFtZXNcclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIGFzeW5jUnVsZXM6IFtdLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBJbXBsaWNpdCBydWxlcyAocnVsZXMgdG8gYWx3YXlzIHZhbGlkYXRlKVxyXG5cdCAgICpcclxuXHQgICAqIEB0eXBlIHtBcnJheX1cclxuXHQgICAqL1xyXG5cdCAgaW1wbGljaXRSdWxlczogWydyZXF1aXJlZCcsICdyZXF1aXJlZF9pZicsICdhY2NlcHRlZCddLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgcnVsZSBieSBuYW1lXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXHJcblx0ICAgKiBAcGFyYW0ge1ZhbGlkYXRvcn1cclxuXHQgICAqIEByZXR1cm4ge1J1bGV9XHJcblx0ICAgKi9cclxuXHQgIG1ha2U6IGZ1bmN0aW9uKG5hbWUsIHZhbGlkYXRvcikge1xyXG5cdCAgICB2YXIgYXN5bmMgPSB0aGlzLmlzQXN5bmMobmFtZSk7XHJcblx0ICAgIHZhciBydWxlID0gbmV3IFJ1bGUobmFtZSwgcnVsZXNbbmFtZV0sIGFzeW5jKTtcclxuXHQgICAgcnVsZS5zZXRWYWxpZGF0b3IodmFsaWRhdG9yKTtcclxuXHQgICAgcmV0dXJuIHJ1bGU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgZ2l2ZW4gcnVsZSBpcyBhc3luY1xyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWVcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIGlzQXN5bmM6IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXN5bmNSdWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmICh0aGlzLmFzeW5jUnVsZXNbaV0gPT09IG5hbWUpIHtcclxuXHQgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgcnVsZSBpcyBpbXBsaWNpdCAoc2hvdWxkIGFsd2F5cyB2YWxpZGF0ZSlcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuXHQgICAqL1xyXG5cdCAgaXNJbXBsaWNpdDogZnVuY3Rpb24obmFtZSkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5pbXBsaWNpdFJ1bGVzLmluZGV4T2YobmFtZSkgPiAtMTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJlZ2lzdGVyIG5ldyBydWxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmblxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XHJcblx0ICAgIHJ1bGVzW25hbWVdID0gZm47XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZWdpc3RlciBhc3luYyBydWxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmblxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVnaXN0ZXJBc3luYzogZnVuY3Rpb24obmFtZSwgZm4pIHtcclxuXHQgICAgdGhpcy5yZWdpc3RlcihuYW1lLCBmbik7XHJcblx0ICAgIHRoaXMuYXN5bmNSdWxlcy5wdXNoKG5hbWUpO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBtYW5hZ2VyO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDk1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgTWVzc2FnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcclxuXHRcclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcclxuXHRcclxuXHR2YXIgY29udGFpbmVyID0ge1xyXG5cdFxyXG5cdCAgbWVzc2FnZXM6IHt9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgbWVzc2FnZXMgZm9yIGxhbmd1YWdlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcclxuXHQgICAqIEBwYXJhbSB7b2JqZWN0fSByYXdNZXNzYWdlc1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgX3NldDogZnVuY3Rpb24obGFuZywgcmF3TWVzc2FnZXMpIHtcclxuXHQgICAgdGhpcy5tZXNzYWdlc1tsYW5nXSA9IHJhd01lc3NhZ2VzO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IG1lc3NhZ2UgZm9yIGdpdmVuIGxhbmd1YWdlJ3MgcnVsZS5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ1xyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBtZXNzYWdlXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfc2V0UnVsZU1lc3NhZ2U6IGZ1bmN0aW9uKGxhbmcsIGF0dHJpYnV0ZSwgbWVzc2FnZSkge1xyXG5cdCAgICB0aGlzLl9sb2FkKGxhbmcpO1xyXG5cdCAgICBpZiAobWVzc2FnZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbbGFuZ10uZGVmO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHRoaXMubWVzc2FnZXNbbGFuZ11bYXR0cmlidXRlXSA9IG1lc3NhZ2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBMb2FkIG1lc3NhZ2VzIChpZiBub3QgYWxyZWFkeSBsb2FkZWQpXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBsYW5nXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfbG9hZDogZnVuY3Rpb24obGFuZykge1xyXG5cdCAgICBpZiAoIXRoaXMubWVzc2FnZXNbbGFuZ10pIHtcclxuXHQgICAgICB2YXIgcmF3TWVzc2FnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KShcIi4vXCIgKyBsYW5nKTtcclxuXHQgICAgICB0aGlzLl9zZXQobGFuZywgcmF3TWVzc2FnZXMpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgcmF3IG1lc3NhZ2VzIGZvciBsYW5ndWFnZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbGFuZ1xyXG5cdCAgICogQHJldHVybiB7b2JqZWN0fVxyXG5cdCAgICovXHJcblx0ICBfZ2V0OiBmdW5jdGlvbihsYW5nKSB7XHJcblx0ICAgIHRoaXMuX2xvYWQobGFuZyk7XHJcblx0ICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzW2xhbmddO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogTWFrZSBtZXNzYWdlcyBmb3IgZ2l2ZW4gbGFuZ3VhZ2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxhbmdcclxuXHQgICAqIEByZXR1cm4ge01lc3NhZ2VzfVxyXG5cdCAgICovXHJcblx0ICBfbWFrZTogZnVuY3Rpb24obGFuZykge1xyXG5cdCAgICB0aGlzLl9sb2FkKGxhbmcpO1xyXG5cdCAgICByZXR1cm4gbmV3IE1lc3NhZ2VzKGxhbmcsIHRoaXMubWVzc2FnZXNbbGFuZ10pO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBjb250YWluZXI7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogOTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBBdHRyaWJ1dGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XHJcblx0XHJcblx0dmFyIE1lc3NhZ2VzID0gZnVuY3Rpb24obGFuZywgbWVzc2FnZXMpIHtcclxuXHQgIHRoaXMubGFuZyA9IGxhbmc7XHJcblx0ICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XHJcblx0ICB0aGlzLmN1c3RvbU1lc3NhZ2VzID0ge307XHJcblx0ICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0ge307XHJcblx0fTtcclxuXHRcclxuXHRNZXNzYWdlcy5wcm90b3R5cGUgPSB7XHJcblx0ICBjb25zdHJ1Y3RvcjogTWVzc2FnZXMsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCBjdXN0b20gbWVzc2FnZXNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tTWVzc2FnZXNcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIF9zZXRDdXN0b206IGZ1bmN0aW9uKGN1c3RvbU1lc3NhZ2VzKSB7XHJcblx0ICAgIHRoaXMuY3VzdG9tTWVzc2FnZXMgPSBjdXN0b21NZXNzYWdlcyB8fCB7fTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCBjdXN0b20gYXR0cmlidXRlIG5hbWVzLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXHJcblx0ICAgKi9cclxuXHQgIF9zZXRBdHRyaWJ1dGVOYW1lczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xyXG5cdCAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0gYXR0cmlidXRlcztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCB0aGUgYXR0cmlidXRlIGZvcm1hdHRlci5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1Y3Rpb259IGZ1bmNcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIF9zZXRBdHRyaWJ1dGVGb3JtYXR0ZXI6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHQgICAgdGhpcy5hdHRyaWJ1dGVGb3JtYXR0ZXIgPSBmdW5jO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IGF0dHJpYnV0ZSBuYW1lIHRvIGRpc3BsYXkuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgX2dldEF0dHJpYnV0ZU5hbWU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZTtcclxuXHQgICAgaWYgKHRoaXMuYXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU5hbWVzW2F0dHJpYnV0ZV07XHJcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5tZXNzYWdlcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcclxuXHQgICAgICBuYW1lID0gdGhpcy5tZXNzYWdlcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHRoaXMuYXR0cmlidXRlRm9ybWF0dGVyKSB7XHJcblx0ICAgICAgbmFtZSA9IHRoaXMuYXR0cmlidXRlRm9ybWF0dGVyKG5hbWUpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBuYW1lO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IGFsbCBtZXNzYWdlc1xyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH1cclxuXHQgICAqL1xyXG5cdCAgYWxsOiBmdW5jdGlvbigpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZW5kZXIgbWVzc2FnZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgcmVuZGVyOiBmdW5jdGlvbihydWxlKSB7XHJcblx0ICAgIGlmIChydWxlLmN1c3RvbU1lc3NhZ2UpIHtcclxuXHQgICAgICByZXR1cm4gcnVsZS5jdXN0b21NZXNzYWdlO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuX2dldFRlbXBsYXRlKHJ1bGUpO1xyXG5cdFxyXG5cdCAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgaWYgKEF0dHJpYnV0ZXMucmVwbGFjZW1lbnRzW3J1bGUubmFtZV0pIHtcclxuXHQgICAgICBtZXNzYWdlID0gQXR0cmlidXRlcy5yZXBsYWNlbWVudHNbcnVsZS5uYW1lXS5hcHBseSh0aGlzLCBbdGVtcGxhdGUsIHJ1bGVdKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBtZXNzYWdlID0gdGhpcy5fcmVwbGFjZVBsYWNlaG9sZGVycyhydWxlLCB0ZW1wbGF0ZSwge30pO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBtZXNzYWdlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHRoZSB0ZW1wbGF0ZSB0byB1c2UgZm9yIGdpdmVuIHJ1bGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtSdWxlfSBydWxlXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIF9nZXRUZW1wbGF0ZTogZnVuY3Rpb24ocnVsZSkge1xyXG5cdFxyXG5cdCAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xyXG5cdCAgICB2YXIgdGVtcGxhdGUgPSBtZXNzYWdlcy5kZWY7XHJcblx0ICAgIHZhciBjdXN0b21NZXNzYWdlcyA9IHRoaXMuY3VzdG9tTWVzc2FnZXM7XHJcblx0ICAgIHZhciBmb3JtYXRzID0gW3J1bGUubmFtZSArICcuJyArIHJ1bGUuYXR0cmlidXRlLCBydWxlLm5hbWVdO1xyXG5cdFxyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgZm9ybWF0OyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgIGZvcm1hdCA9IGZvcm1hdHNbaV07XHJcblx0ICAgICAgaWYgKGN1c3RvbU1lc3NhZ2VzLmhhc093blByb3BlcnR5KGZvcm1hdCkpIHtcclxuXHQgICAgICAgIHRlbXBsYXRlID0gY3VzdG9tTWVzc2FnZXNbZm9ybWF0XTtcclxuXHQgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAobWVzc2FnZXMuaGFzT3duUHJvcGVydHkoZm9ybWF0KSkge1xyXG5cdCAgICAgICAgdGVtcGxhdGUgPSBtZXNzYWdlc1tmb3JtYXRdO1xyXG5cdCAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZVtydWxlLl9nZXRWYWx1ZVR5cGUoKV07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSBkYXRhIG9iamVjdFxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gdGVtcGxhdGVcclxuXHQgICAqIEBwYXJhbSAge29iamVjdH0gZGF0YVxyXG5cdCAgICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAgICovXHJcblx0ICBfcmVwbGFjZVBsYWNlaG9sZGVyczogZnVuY3Rpb24ocnVsZSwgdGVtcGxhdGUsIGRhdGEpIHtcclxuXHQgICAgdmFyIG1lc3NhZ2UsIGF0dHJpYnV0ZTtcclxuXHRcclxuXHQgICAgZGF0YS5hdHRyaWJ1dGUgPSB0aGlzLl9nZXRBdHRyaWJ1dGVOYW1lKHJ1bGUuYXR0cmlidXRlKTtcclxuXHQgICAgZGF0YVtydWxlLm5hbWVdID0gcnVsZS5nZXRQYXJhbWV0ZXJzKCkuam9pbignLCcpO1xyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICBtZXNzYWdlID0gdGVtcGxhdGU7XHJcblx0XHJcblx0ICAgICAgZm9yIChhdHRyaWJ1dGUgaW4gZGF0YSkge1xyXG5cdCAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKCc6JyArIGF0dHJpYnV0ZSwgJ2cnKSwgZGF0YVthdHRyaWJ1dGVdKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIG1lc3NhZ2U7XHJcblx0ICB9XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VzO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDk3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgcmVwbGFjZW1lbnRzID0ge1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBCZXR3ZWVuIHJlcGxhY2VtZW50IChyZXBsYWNlcyA6bWluIGFuZCA6bWF4KVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gdGVtcGxhdGVcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgYmV0d2VlbjogZnVuY3Rpb24odGVtcGxhdGUsIHJ1bGUpIHtcclxuXHQgICAgdmFyIHBhcmFtZXRlcnMgPSBydWxlLmdldFBhcmFtZXRlcnMoKTtcclxuXHQgICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VQbGFjZWhvbGRlcnMocnVsZSwgdGVtcGxhdGUsIHtcclxuXHQgICAgICBtaW46IHBhcmFtZXRlcnNbMF0sXHJcblx0ICAgICAgbWF4OiBwYXJhbWV0ZXJzWzFdXHJcblx0ICAgIH0pO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVxdWlyZWRfaWYgcmVwbGFjZW1lbnQuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSB0ZW1wbGF0ZVxyXG5cdCAgICogQHBhcmFtICB7UnVsZX0gcnVsZVxyXG5cdCAgICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAgICovXHJcblx0ICByZXF1aXJlZF9pZjogZnVuY3Rpb24odGVtcGxhdGUsIHJ1bGUpIHtcclxuXHQgICAgdmFyIHBhcmFtZXRlcnMgPSBydWxlLmdldFBhcmFtZXRlcnMoKTtcclxuXHQgICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VQbGFjZWhvbGRlcnMocnVsZSwgdGVtcGxhdGUsIHtcclxuXHQgICAgICBvdGhlcjogcGFyYW1ldGVyc1swXSxcclxuXHQgICAgICB2YWx1ZTogcGFyYW1ldGVyc1sxXVxyXG5cdCAgICB9KTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGZvcm1hdHRlcihhdHRyaWJ1dGUpIHtcclxuXHQgIHJldHVybiBhdHRyaWJ1dGUucmVwbGFjZSgvW19cXFtdL2csICcgJykucmVwbGFjZSgvXS9nLCAnJyk7XHJcblx0fVxyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgcmVwbGFjZW1lbnRzOiByZXBsYWNlbWVudHMsXHJcblx0ICBmb3JtYXR0ZXI6IGZvcm1hdHRlclxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogOTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgYWNjZXB0ZWQ6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGFjY2VwdGVkLicsXHJcblx0ICBhbHBoYTogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG11c3QgY29udGFpbiBvbmx5IGFscGhhYmV0aWMgY2hhcmFjdGVycy4nLFxyXG5cdCAgYWxwaGFfZGFzaDogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGRhc2hlcyBhbmQgdW5kZXJzY29yZXMuJyxcclxuXHQgIGFscGhhX251bTogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG11c3QgYmUgYWxwaGFudW1lcmljLicsXHJcblx0ICBiZXR3ZWVuOiAnVGhlIDphdHRyaWJ1dGUgZmllbGQgbXVzdCBiZSBiZXR3ZWVuIDptaW4gYW5kIDptYXguJyxcclxuXHQgIGNvbmZpcm1lZDogJ1RoZSA6YXR0cmlidXRlIGNvbmZpcm1hdGlvbiBkb2VzIG5vdCBtYXRjaC4nLFxyXG5cdCAgZW1haWw6ICdUaGUgOmF0dHJpYnV0ZSBmb3JtYXQgaXMgaW52YWxpZC4nLFxyXG5cdCAgZGVmOiAnVGhlIDphdHRyaWJ1dGUgYXR0cmlidXRlIGhhcyBlcnJvcnMuJyxcclxuXHQgIGRpZ2l0czogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgOmRpZ2l0cyBkaWdpdHMuJyxcclxuXHQgIGRpZmZlcmVudDogJ1RoZSA6YXR0cmlidXRlIGFuZCA6ZGlmZmVyZW50IG11c3QgYmUgZGlmZmVyZW50LicsXHJcblx0ICAnaW4nOiAnVGhlIHNlbGVjdGVkIDphdHRyaWJ1dGUgaXMgaW52YWxpZC4nLFxyXG5cdCAgaW50ZWdlcjogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgYW4gaW50ZWdlci4nLFxyXG5cdCAgbWluOiB7XHJcblx0ICAgIG51bWVyaWM6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGF0IGxlYXN0IDptaW4uJyxcclxuXHQgICAgc3RyaW5nOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSBhdCBsZWFzdCA6bWluIGNoYXJhY3RlcnMuJ1xyXG5cdCAgfSxcclxuXHQgIG1heDoge1xyXG5cdCAgICBudW1lcmljOiAnVGhlIDphdHRyaWJ1dGUgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICdUaGUgOmF0dHJpYnV0ZSBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiA6bWF4IGNoYXJhY3RlcnMuJ1xyXG5cdCAgfSxcclxuXHQgIG5vdF9pbjogJ1RoZSBzZWxlY3RlZCA6YXR0cmlidXRlIGlzIGludmFsaWQuJyxcclxuXHQgIG51bWVyaWM6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGEgbnVtYmVyLicsXHJcblx0ICByZXF1aXJlZDogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIGlzIHJlcXVpcmVkLicsXHJcblx0ICByZXF1aXJlZF9pZjogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIGlzIHJlcXVpcmVkIHdoZW4gOm90aGVyIGlzIDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ1RoZSA6YXR0cmlidXRlIGFuZCA6c2FtZSBmaWVsZHMgbXVzdCBtYXRjaC4nLFxyXG5cdCAgc2l6ZToge1xyXG5cdCAgICBudW1lcmljOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIDpzaXplIGNoYXJhY3RlcnMuJ1xyXG5cdCAgfSxcclxuXHQgIHN0cmluZzogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgYSBzdHJpbmcuJyxcclxuXHQgIHVybDogJ1RoZSA6YXR0cmlidXRlIGZvcm1hdCBpcyBpbnZhbGlkLicsXHJcblx0ICByZWdleDogJ1RoZSA6YXR0cmlidXRlIGZvcm1hdCBpcyBpbnZhbGlkJyxcclxuXHQgIGF0dHJpYnV0ZXM6IHt9XHJcblx0fTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA5OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIG1hcCA9IHtcclxuXHRcdFwiLi9lblwiOiA5OCxcclxuXHRcdFwiLi9lbi5qc1wiOiA5OCxcclxuXHRcdFwiLi9lc1wiOiAxMDAsXHJcblx0XHRcIi4vZXMuanNcIjogMTAwLFxyXG5cdFx0XCIuL2ZyXCI6IDEwMSxcclxuXHRcdFwiLi9mci5qc1wiOiAxMDEsXHJcblx0XHRcIi4vaXRcIjogMTAyLFxyXG5cdFx0XCIuL2l0LmpzXCI6IDEwMixcclxuXHRcdFwiLi9qYVwiOiAxMDMsXHJcblx0XHRcIi4vamEuanNcIjogMTAzLFxyXG5cdFx0XCIuL3BsXCI6IDEwNCxcclxuXHRcdFwiLi9wbC5qc1wiOiAxMDQsXHJcblx0XHRcIi4vcnVcIjogMTA1LFxyXG5cdFx0XCIuL3J1LmpzXCI6IDEwNVxyXG5cdH07XHJcblx0ZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XHJcblx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XHJcblx0fTtcclxuXHRmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XHJcblx0XHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xyXG5cdH07XHJcblx0d2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xyXG5cdH07XHJcblx0d2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xyXG5cdHdlYnBhY2tDb250ZXh0LmlkID0gOTk7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciBhY2VwdGFkby4nLFxyXG5cdCAgYWxwaGE6ICdFbCBjYW1wbyA6YXR0cmlidXRlIHNvbG8gZGViZSBjb250ZW5lciBsZXRyYXMuJyxcclxuXHQgIGFscGhhX2Rhc2g6ICdFbCBjYW1wbyA6YXR0cmlidXRlIHNvbG8gZGViZSBjb250ZW5lciBsZXRyYXMsIG7Dum1lcm9zIHkgZ3Vpb25lcy4nLFxyXG5cdCAgYWxwaGFfbnVtOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBzb2xvIGRlYmUgY29udGVuZXIgbGV0cmFzIHkgbsO6bWVyb3MuJyxcclxuXHQgIGF0dHJpYnV0ZXM6IHt9LFxyXG5cdCAgYmV0d2VlbjogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgdGllbmUgcXVlIGVzdGFyIGVudHJlIDptaW4gLSA6bWF4LicsXHJcblx0ICBjb25maXJtZWQ6ICdMYSBjb25maXJtYWNpw7NuIGRlIDphdHRyaWJ1dGUgbm8gY29pbmNpZGUuJyxcclxuXHQgIGRpZmZlcmVudDogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgeSA6b3RoZXIgZGViZW4gc2VyIGRpZmVyZW50ZXMuJyxcclxuXHQgIGRpZ2l0czogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSB0ZW5lciA6ZGlnaXRzIGTDrWdpdG9zLicsXHJcblx0ICBlbWFpbDogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgbm8gZXMgdW4gY29ycmVvIHbDoWxpZG8nLFxyXG5cdCAgJ2luJzogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZXMgaW52w6FsaWRvLicsXHJcblx0ICBpbnRlZ2VyOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciB1biBuw7ptZXJvIGVudGVyby4nLFxyXG5cdCAgbWF4OiB7XHJcblx0ICAgIG51bWVyaWM6ICdFbCBjYW1wbyA6YXR0cmlidXRlIG5vIGRlYmUgc2VyIG1heW9yIGEgOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICdFbCBjYW1wbyA6YXR0cmlidXRlIG5vIGRlYmUgc2VyIG1heW9yIHF1ZSA6bWF4IGNhcmFjdGVyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnRWwgdGFtYcOxbyBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciBkZSBhbCBtZW5vcyA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBjb250ZW5lciBhbCBtZW5vcyA6bWluIGNhcmFjdGVyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIG5vdF9pbjogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZXMgaW52w6FsaWRvLicsXHJcblx0ICBudW1lcmljOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIHNlciBudW3DqXJpY28uJyxcclxuXHQgIHJlZ2V4OiAnRWwgZm9ybWF0byBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBlcyBpbnbDoWxpZG8uJyxcclxuXHQgIHJlcXVpcmVkOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBlcyBvYmxpZ2F0b3Jpby4nLFxyXG5cdCAgcmVxdWlyZWRfaWY6ICdFbCBjYW1wbyA6YXR0cmlidXRlIGVzIG9ibGlnYXRvcmlvIGN1YW5kbyA6b3RoZXIgZXMgOnZhbHVlLicsXHJcblx0ICBzYW1lOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSB5IDpvdGhlciBkZWJlbiBjb2luY2lkaXIuJyxcclxuXHQgIHNpemU6IHtcclxuXHQgICAgbnVtZXJpYzogJ0VsIHRhbWHDsW8gZGVsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBzZXIgOnNpemUuJyxcclxuXHQgICAgc3RyaW5nOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBkZWJlIGNvbnRlbmVyIDpzaXplIGNhcmFjdGVyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIHVybDogJ0VsIGZvcm1hdG8gZGUgOmF0dHJpYnV0ZSBlcyBpbnbDoWxpZG8uJ1xyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBhY2NlcHTDqS4nLFxyXG5cdCAgYWxwaGE6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBwZXV0IGNvbnRlbmlyIHF1ZSBkZXMgY2FyYWN0w6hyZXMgYWxwaGFiw6l0aXF1ZXMuJyxcclxuXHQgIGFscGhhX2Rhc2g6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBwZXV0IGNvbnRlbmlyIHF1ZSBkZXMgY2FyYWN0w6hyZXMgYWxwaGFudW3DqXJpcXVlcywgZGVzIHRpcmV0cyBldCB1bmRlcnNjb3Jlcy4nLFxyXG5cdCAgYWxwaGFfbnVtOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBhbHBoYW51bcOpcmlxdWUuJyxcclxuXHQgIGJldHdlZW46ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIGNvbXByaXMgZW50cmUgOm1pbiBhbmQgOm1heC4nLFxyXG5cdCAgY29uZmlybWVkOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgbmUgY29ycmVzcG9uZCBwYXMuJyxcclxuXHQgIGVtYWlsOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgY29udGllbnQgdW4gZm9ybWF0IGludmFsaWRlLicsXHJcblx0ICBkZWY6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBjb250aWVudCB1biBhdHRyaWJ1dCBlcnJvbsOpLicsXHJcblx0ICBkaWdpdHM6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIGRlIDpkaWdpdHMgY2hpZmZyZXMuJyxcclxuXHQgIGRpZmZlcmVudDogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGV0IDpkaWZmZXJlbnQgZG9pdmVudCDDqnRyZSBkaWZmZXJlbnRzLicsXHJcblx0ICAnaW4nOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IGludmFsaWRlLicsXHJcblx0ICBpbnRlZ2VyOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSB1biBlbnRpZXIuJyxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBjb250ZW5pciBhdSBtb2lucyA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgY29udGVuaXIgYXUgbW9pbnMgOm1pbiBjYXJhY3TDqHJlcy4nXHJcblx0ICB9LFxyXG5cdCAgbWF4OiB7XHJcblx0ICAgIG51bWVyaWM6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBkb2l0IMOqdHJlIHN1cMOpcmlldXIgw6AgOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBuZSBkb2l0IMOqdHJlIHBsdXMgZGUgOm1heCBjaGFyYWN0ZXJzLidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBlc3QgaW52YWxpZGUuJyxcclxuXHQgIG51bWVyaWM6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIHVuIG51bcOpcm8uJyxcclxuXHQgIHJlcXVpcmVkOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IG9ibGlnYXRvaXJlLicsXHJcblx0ICByZXF1aXJlZF9pZjogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGVzdCBvYmxpZ2F0b2lyZSBxdWFuZCA6b3RoZXIgZXN0IDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGV0IDpzYW1lIGRvaXZlbnQgY29ycmVzcG9uZHJlLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICdMYSB0YWlsbGUgZHUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICdMYSB0YWlsbGUgZHUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBkZSA6c2l6ZSBjYXJhY3TDqHJlcy4nXHJcblx0ICB9LFxyXG5cdCAgdXJsOiAnTGUgZm9ybWF0IGR1IGNoYW1wcyA6YXR0cmlidXRlIGVzdCBpbnZhbGlkZS4nLFxyXG5cdCAgcmVnZXg6ICdMZSBmb3JtYXQgZHUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IGludmFsaWRlLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBhY2NldHRhdG8uJyxcclxuXHQgIGFscGhhOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGNvbnRlbmVyZSBzb25vIGNhcmF0dGVyaSBhbGZhYmV0aWNpLicsXHJcblx0ICBhbHBoYV9kYXNoOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBwdcOyIGNvbnRlbmVyZSBzb2xvIGNhcmF0dGVyaSBhbGZhbnVtZXJpY2kgb2x0cmUgYSB0cmF0dGluaSBlIHRyYXR0aW5pIGJhc3NpLicsXHJcblx0ICBhbHBoYV9udW06ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIGFsZmFudW1lcmljby4nLFxyXG5cdCAgYmV0d2VlbjogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgY29tcHJlc28gdHJhIDptaW4gZSA6bWF4LicsXHJcblx0ICBjb25maXJtZWQ6ICdJbCBjYW1wbyBjb25mZXJtYSA6YXR0cmlidXRlIG5vbiDDqCB1Z3VhbGUuJyxcclxuXHQgIGVtYWlsOiAnSWwgZm9ybWF0byBkZWxsXFwnYXR0cmlidXRvIDphdHRyaWJ1dGUgbm9uIMOoIHZhbGlkby4nLFxyXG5cdCAgZGVmOiAnR2xpIGF0dHJpYnV0aSBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBjb250ZW5nb25vIGRlZ2xpIGVycm9yaS4nLFxyXG5cdCAgZGlnaXRzOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBkaSA6ZGlnaXRzIGNpZnJlLicsXHJcblx0ICBkaWZmZXJlbnQ6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGUgOmRpZmZlcmVudCBkZXZvIGVzc2VyZSBkaXZlcnNpLicsXHJcblx0ICAnaW4nOiAnSWwgdmFsb3JlIGRlbCBjYW1wbyA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIGludGVnZXI6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVuIHZhbG9yZSBpbnRlcm8uJyxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBvIHVndWFsZSBkaSA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgY29tcG9zdG8gZGEgYWxtZW5vIDptaW4gY2FyYXR0ZXJpLidcclxuXHQgIH0sXHJcblx0ICBtYXg6IHtcclxuXHQgICAgbnVtZXJpYzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgbWlub3JlIG8gdWd1YWxlIGRpIDptYXguJyxcclxuXHQgICAgc3RyaW5nOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBjb21wb3N0byBkYSBtYXNzaW1vIDptYXggY2FyYXR0ZXJpLidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICdJbCBjYW1wbyA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIG51bWVyaWM6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVuIG51bWVyby4nLFxyXG5cdCAgcmVxdWlyZWQ6ICdJbCBjYW1wbyA6YXR0cmlidXRlIMOoIHJpY2hpZXN0by4nLFxyXG5cdCAgcmVxdWlyZWRfaWY6ICdJbCBjYW1wbyA6YXR0cmlidXRlIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgY2FtcG8gOm90aGVyIMOoIHVndWFsZSBhIDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ0kgY2FtcGkgOmF0dHJpYnV0ZSBlIDpzYW1lIGRldm9ubyBlc3NlcmUgdWd1YWxpLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICdMYSBkaW1lbnNpb25lIGRlbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVndWFsZSBhIDpzaXplLicsXHJcblx0ICAgIHN0cmluZzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgZGkgOnNpemUgY2FyYXR0ZXJpLidcclxuXHQgIH0sXHJcblx0ICBzdHJpbmc6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIHVuYSBzdHJpbmdhLicsXHJcblx0ICB1cmw6ICdJbCBmb3JtYXRvIGRlbCBjYW1wbyA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIHJlZ2V4OiAnSWwgZm9ybWF0byBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBub24gw6ggdmFsaWRvLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTAzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgYWNjZXB0ZWQ6ICc6YXR0cmlidXRl44KS56K66KqN44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYWxwaGE6ICc6YXR0cmlidXRl44Gv6Iux5a2X44Gu44G/44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYWxwaGFfZGFzaDogJzphdHRyaWJ1dGXjga/oi7HlrZfjgajjg4Djg4Pjgrfjg6XjgajkuIvnt5rjga7jgb/jgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBhbHBoYV9udW06ICc6YXR0cmlidXRl44Gv6Iux5pWw5a2X44Gu44G/44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYmV0d2VlbjogJzphdHRyaWJ1dGXjga86bWlu44CcOm1heOaWh+Wtl+OBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAgicsXHJcblx0ICAgIGNvbmZpcm1lZDogJzphdHRyaWJ1dGXjga/norroqo3jgYzkuIDoh7TjgZfjgb7jgZvjgpPjgIInLFxyXG5cdCAgICBlbWFpbDogJzphdHRyaWJ1dGXjga/mraPjgZfjgYTjg6Hjg7zjg6vjgqLjg4njg6zjgrnjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBkZWY6ICc6YXR0cmlidXRl44Gv5qSc6Ki844Ko44Op44O844GM5ZCr44G+44KM44Gm44GE44G+44GZ44CCJyxcclxuXHQgICAgZGlnaXRzOiAnOmF0dHJpYnV0ZeOBrzpkaWdpdHPjga7mlbDlrZfjga7jgb/jgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBkaWZmZXJlbnQ6ICc6YXR0cmlidXRl44GoOmRpZmZlcmVudOOBr+WQjOOBmOOBp+OBguOBo+OBpuOBr+OBquOCiuOBvuOBm+OCk+OAgicsXHJcblx0ICAgICdpbic6ICfpgbjmip7jgZXjgozjgZ86YXR0cmlidXRl44Gv54Sh5Yq544Gn44GZ44CCJyxcclxuXHQgICAgaW50ZWdlcjogJzphdHRyaWJ1dGXjga/mlbTmlbDjgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBtaW4gICAgICAgIDoge1xyXG5cdCAgICAgICAgbnVtZXJpYyA6IFwiOmF0dHJpYnV0ZeOBrzptaW7ku6XkuIrjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgICAgIHN0cmluZyAgOiBcIjphdHRyaWJ1dGXjga86bWlu5paH5a2X5Lul5LiK44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCJcclxuXHQgICAgfSxcclxuXHQgICAgbWF4IDoge1xyXG5cdCAgICAgICAgbnVtZXJpYyA6IFwiOmF0dHJpYnV0ZeOBrzptYXjku6XkuIvjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgICAgIHN0cmluZyAgOiBcIjphdHRyaWJ1dGXjga86bWF45paH5a2X5Lul5LiK44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCJcclxuXHQgICAgfSxcclxuXHQgICAgbm90X2luICAgICAgOiBcIumBuOaKnuOBleOCjOOBnzphdHRyaWJ1dGXjga/nhKHlirnjgafjgZnjgIJcIixcclxuXHQgICAgbnVtZXJpYyAgICAgOiBcIjphdHRyaWJ1dGXjga/mlbDlgKTjgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgcmVxdWlyZWQgICAgOiBcIjphdHRyaWJ1dGXjga/lv4XpoIjjgafjgZnjgIJcIixcclxuXHQgICAgcmVxdWlyZWRfaWYgOiBcIjpvdGhlcuOBrzp2YWx1ZeOBq+OBquOBo+OBn+OCiTphdHRyaWJ1dGXjga/lv4XpoIjjgafjgZnjgIJcIixcclxuXHQgICAgc2FtZSAgICAgICAgOiBcIjphdHRyaWJ1dGXjgag6c2FtZeOBr+WQjOOBmOOBp+OBquOBkeOCjOOBsOOBquOCiuOBvuOBm+OCk+OAglwiLFxyXG5cdCAgICBzaXplICAgICAgICA6IHtcclxuXHQgICAgICAgIG51bWVyaWMgOiBcIjphdHRyaWJ1dGXjga86c2l6ZeOCkuWFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiLFxyXG5cdCAgICAgICAgc3RyaW5nICA6IFwiOmF0dHJpYnV0ZeOBrzpzaXpl5paH5a2X44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCJcclxuXHQgICAgfSxcclxuXHQgICAgdXJsICAgICAgICA6IFwiOmF0dHJpYnV0ZeOBr1VSSeOCkuWFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiLFxyXG5cdCAgICByZWdleCAgICAgIDogXCI6YXR0cmlidXRl44Gu5YCkIFxcXCI6dmFsdWVcXFwiIOOBr+ODkeOCv+ODvOODs+OBq+ODnuODg+ODgeOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglwiLFxyXG5cdCAgICBhdHRyaWJ1dGVzIDoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGFjY2VwdGVkOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyB6YWFrY2VwdG93YW5lLicsXHJcblx0ICAgIGFscGhhOiAnUG9sZSA6YXR0cmlidXRlIG1vxbxlIHphd2llcmHEhyB0eWxrbyBsaXRlcnkuJyxcclxuXHQgICAgYWxwaGFfZGFzaDogJ1BvbGUgOmF0dHJpYnV0ZSBtb3plIHphd2llcmHEhyB0eWxrbyBsaXRlcnksIG15xZtsbmlrIGkgcG9kcmtlxZtsZW5pZS4nLFxyXG5cdCAgICBhbHBoYV9udW06ICdQb2xlIDphdHRyaWJ1dGUgbW96ZSB6YXdpZXJhYyB0eWxrbyB6bmFraSBhbGZhbnVtZXJ5Y3puZS4nLFxyXG5cdCAgICBiZXR3ZWVuOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgbWllxIcgZMWCdWdvxZvEhyBvZCA6bWluIGRvIDptYXguJyxcclxuXHQgICAgY29uZmlybWVkOiAnUG9sZSA6YXR0cmlidXRlIG5pZSBzcGXFgm5pYSB3YXJ1bmt1IHBvdHdpZXJkemVuaWEuJyxcclxuXHQgICAgZW1haWw6ICdQb2xlIDphdHRyaWJ1dGUgbWEgbmllcG9wcmF3bnkgZm9ybWF0IGFkcmVzdSBlbWFpbC4nLFxyXG5cdCAgICBkZWY6ICdQb2xlIDphdHRyaWJ1dGUgemF3aWVyYSBixYLEmWR5LicsXHJcblx0ICAgIGRpZ2l0czogJ1BvbGUgOmF0dHJpYnV0ZSBtb8W8ZSB6YXdpZXJhxIcgdHlsa28gY3lmcnkgemUgemJpb3J1IDpkaWdpdHMuJyxcclxuXHQgICAgZGlmZmVyZW50OiAnUG9sYSA6YXR0cmlidXRlIGkgOmRpZmZlcmVudCBtdXN6xIUgc2nEmSByw7PFvG5pxIcuJyxcclxuXHQgICAgJ2luJzogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIG5hbGXFvGXEhyBkbyB6YmlvcnUgOmluLicsXHJcblx0ICAgIGludGVnZXI6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBiecSHIGxpY3pixIUgY2HFgmtvd2l0xIUuJyxcclxuXHQgICAgbWluOiB7XHJcblx0ICAgICAgICBudW1lcmljOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyByw7N3bmUgY29uYWptbmllaiA6bWluLicsXHJcblx0ICAgICAgICBzdHJpbmc6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSB6YXdpZXJhxIcgY29uYWptbmllaiA6bWluIHpuYWvDs3cuJ1xyXG5cdCAgICB9LFxyXG5cdCAgICBtYXg6IHtcclxuXHQgICAgICAgIG51bWVyaWM6ICdQb2xlIDphdHRyaWJ1dGUgbmllIG1vemUgYnnEhyB3acSZa3N6ZSA6bWF4LicsXHJcblx0ICAgICAgICBzdHJpbmc6ICdQb2xlIDphdHRyaWJ1dGUgbmllIG1vemUgYnnEhyBkxYJ1xbxzemUgbmnFvCA6bWF4IHpuYWvDs3cuJ1xyXG5cdCAgICB9LFxyXG5cdCAgICBub3RfaW46ICdQb2xlIDphdHRyaWJ1dGUgbmllIG1vxbxlIG5hbGXFvGXEhyBkbyB6YmlvcnUgOm5vdF9pbi4nLFxyXG5cdCAgICBudW1lcmljOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyBsaWN6YsSFLicsXHJcblx0ICAgIHJlcXVpcmVkOiAnUG9sZSA6YXR0cmlidXRlIGplc3Qgd3ltYWdhbmUuJyxcclxuXHQgICAgcmVxdWlyZWRfaWY6ICdQb2xlIDphdHRyaWJ1dGUgamVzdCB3eW1hZ2FuZSBqZcWbbGkgcG9sZSA6b3RoZXIgamVzdCByw7N3bmUgOnZhbHVlLicsXHJcblx0ICAgIHNhbWU6ICdQb2xhIDphdHRyaWJ1dGUgaSA6c2FtZSBtdXN6xIUgYnnEhyB0YWtpZSBzYW1lLicsXHJcblx0ICAgIHNpemU6IHtcclxuXHQgICAgICAgIG51bWVyaWM6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBiecSHIHLDs3duZSA6c2l6ZS4nLFxyXG5cdCAgICAgICAgc3RyaW5nOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgemF3aWVyYcSHIDpzaXplIHpuYWvDs3cuJ1xyXG5cdCAgICB9LFxyXG5cdCAgICBzdHJpbmc6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBiecSHIGNpxIVnaWVtIHpuYWvDs3cuJyxcclxuXHQgICAgdXJsOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyBwb3ByYXdueW0gYWRyZXNlbSBVUkwuJyxcclxuXHQgICAgcmVnZXg6ICdQb2xlIDphdHRyaWJ1dGUgbmllIHNwZcWCbmlhIHdhcnVua3UuJyxcclxuXHQgICAgYXR0cmlidXRlczoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBhY2NlcHRlZDogJ9CS0Ysg0LTQvtC70LbQvdGLINC/0YDQuNC90Y/RgtGMIDphdHRyaWJ1dGUuJyxcclxuXHQgIGFscGhhOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjCDRgtC+0LvRjNC60L4g0LHRg9C60LLRiy4nLFxyXG5cdCAgYWxwaGFfZGFzaDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LzQvtC20LXRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCx0YPQutCy0YssINGG0LjRhNGA0YssINC00LXRhNC40YHRiyDQuCDRgdC40LzQstC+0LvRiyDQv9C+0LTRh9GR0YDQutC40LLQsNC90LjRjy4nLFxyXG5cdCAgYWxwaGFfbnVtOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjCDRgtC+0LvRjNC60L4g0LHRg9C60LLRiyDQuCDRhtC40YTRgNGLLicsXHJcblx0ICBiZXR3ZWVuOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LzQtdC20LTRgyA6bWluINC4IDptYXguJyxcclxuXHQgIGNvbmZpcm1lZDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0L3QtSDRgdC+0LLQv9Cw0LTQsNC10YIg0YEg0L/QvtC00YLQstC10YDQttC00LXQvdC40LXQvC4nLFxyXG5cdCAgZW1haWw6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3Ri9C8INGN0LvQtdC60YLRgNC+0L3QvdGL0Lwg0LDQtNGA0LXRgdC+0LwuJyxcclxuXHQgIGRlZjogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0YHQvtC00LXRgNC20LjRgiDQvtGI0LjQsdC60LguJyxcclxuXHQgIGRpZ2l0czogJ9CU0LvQuNC90LAg0YbQuNGE0YDQvtCy0L7Qs9C+INC/0L7Qu9GPIDphdHRyaWJ1dGUg0LTQvtC70LbQvdCwINCx0YvRgtGMIDpkaWdpdHMuJyxcclxuXHQgIGRpZmZlcmVudDogJ9Cf0L7Qu9GPIDphdHRyaWJ1dGUg0LggOmRpZmZlcmVudCDQtNC+0LvQttC90Ysg0YDQsNC30LvQuNGH0LDRgtGM0YHRjy4nLFxyXG5cdCAgJ2luJzogJ9CS0YvQsdGA0LDQvdC90L7QtSDQt9C90LDRh9C10L3QuNC1INC00LvRjyA6YXR0cmlidXRlINC+0YjQuNCx0L7Rh9C90L4uJyxcclxuXHQgIGludGVnZXI6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDRhtC10LvRi9C8INGH0LjRgdC70L7QvC4nLFxyXG5cdCAgbWluOiB7XHJcblx0ICAgIG51bWVyaWM6ICfQl9C90LDRh9C10L3QuNC1INC/0L7Qu9GPIDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINCx0L7Qu9GM0YjQtSDQuNC70Lgg0YDQsNCy0L3QviA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ9Ca0L7Qu9C40YfQtdGB0YLQstC+INGB0LjQvNCy0L7Qu9C+0LIg0LIg0L/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0L3QtSDQvNC10L3QtdC1IDptaW4uJ1xyXG5cdCAgfSxcclxuXHQgIG1heDoge1xyXG5cdCAgICBudW1lcmljOiAn0JfQvdCw0YfQtdC90LjQtSDQv9C+0LvRjyA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDQvNC10L3RjNGI0LUg0LjQu9C4INGA0LDQstC90L4gOm1heC4nLFxyXG5cdCAgICBzdHJpbmc6ICfQmtC+0LvQuNGH0LXRgdGC0LLQviDRgdC40LzQstC+0LvQvtCyINCyINC/0L7Qu9C1IDphdHRyaWJ1dGUg0L3QtSDQvNC+0LbQtdGCINC/0YDQtdCy0YvRiNCw0YLRjCA6bWF4LidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICfQktGL0LHRgNCw0L3QvdC+0LUg0LfQvdCw0YfQtdC90LjQtSDQtNC70Y8gOmF0dHJpYnV0ZSDQvtGI0LjQsdC+0YfQvdC+LicsXHJcblx0ICBudW1lcmljOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YfQuNGB0LvQvtC8LicsXHJcblx0ICByZXF1aXJlZDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviDQtNC70Y8g0LfQsNC/0L7Qu9C90LXQvdC40Y8uJyxcclxuXHQgIHJlcXVpcmVkX2lmOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDRgtGA0LXQsdGD0LXRgtGB0Y8g0LrQvtCz0LTQsCDQt9C90LDRh9C10L3QuNGPINC/0L7Qu9GPIDpvdGhlciDRgNCw0LLQvdC+IDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ9CX0L3QsNGH0LXQvdC40LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0YHQvtCy0L/QsNC00LDRgtGMINGBIDpzYW1lLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICfQl9C90LDRh9C10L3QuNC1INC/0L7Qu9GPIDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINGA0LDQstC90YvQvCA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICfQmtC+0LvQuNGH0LXRgdGC0LLQviDRgdC40LzQstC+0LvQvtCyINCyINC/0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINGA0LDQstC90L4gOnNpemUuJ1xyXG5cdCAgfSxcclxuXHQgIHVybDogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INGB0L7QtNC10YDQttCw0YLRjCDQstCw0LvQuNC00L3Ri9C5IFVSTC4nLFxyXG5cdCAgcmVnZXg6ICfQndC10LLQtdGA0L3Ri9C5INGE0L7RgNC80LDRgiDQv9C+0LvRjyA6YXR0cmlidXRlLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTA2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgRXJyb3JzID0gZnVuY3Rpb24oKSB7XHJcblx0ICB0aGlzLmVycm9ycyA9IHt9O1xyXG5cdH07XHJcblx0XHJcblx0RXJyb3JzLnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbnN0cnVjdG9yOiBFcnJvcnMsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEFkZCBuZXcgZXJyb3IgbWVzc2FnZSBmb3IgZ2l2ZW4gYXR0cmlidXRlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZVxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgYWRkOiBmdW5jdGlvbihhdHRyaWJ1dGUsIG1lc3NhZ2UpIHtcclxuXHQgICAgaWYgKCF0aGlzLmhhcyhhdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgdGhpcy5lcnJvcnNbYXR0cmlidXRlXSA9IFtdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLmVycm9yc1thdHRyaWJ1dGVdLmluZGV4T2YobWVzc2FnZSkgPT09IC0xKSB7XHJcblx0ICAgICAgdGhpcy5lcnJvcnNbYXR0cmlidXRlXS5wdXNoKG1lc3NhZ2UpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzIGZvciBhbiBhdHRyaWJ1dGUsIG9yIGFuIGVtcHR5IGFycmF5XHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGUgQSBrZXkgaW4gdGhlIGRhdGEgb2JqZWN0IGJlaW5nIHZhbGlkYXRlZFxyXG5cdCAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzXHJcblx0ICAgKi9cclxuXHQgIGdldDogZnVuY3Rpb24oYXR0cmlidXRlKSB7XHJcblx0ICAgIGlmICh0aGlzLmhhcyhhdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW2F0dHJpYnV0ZV07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIFtdO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmV0dXJucyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYW4gYXR0cmlidXRlLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IGF0dHJpYnV0ZSBBIGtleSBpbiB0aGUgZGF0YSBvYmplY3QgYmVpbmcgdmFsaWRhdGVkXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd8ZmFsc2V9IEZpcnN0IGVycm9yIG1lc3NhZ2Ugb3IgZmFsc2VcclxuXHQgICAqL1xyXG5cdCAgZmlyc3Q6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICBpZiAodGhpcy5oYXMoYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmVycm9yc1thdHRyaWJ1dGVdWzBdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBmYWxzZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCBhbGwgZXJyb3IgbWVzc2FnZXMgZnJvbSBhbGwgZmFpbGluZyBhdHRyaWJ1dGVzXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSBGYWlsZWQgYXR0cmlidXRlIG5hbWVzIGZvciBrZXlzIGFuZCBhbiBhcnJheSBvZiBtZXNzYWdlcyBmb3IgdmFsdWVzXHJcblx0ICAgKi9cclxuXHQgIGFsbDogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLmVycm9ycztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiB0aGVyZSBhcmUgYW55IGVycm9yIG1lc3NhZ2VzIGZvciBhbiBhdHRyaWJ1dGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBhdHRyaWJ1dGUgQSBrZXkgaW4gdGhlIGRhdGEgb2JqZWN0IGJlaW5nIHZhbGlkYXRlZFxyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuXHQgICAqL1xyXG5cdCAgaGFzOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcclxuXHQgICAgaWYgKHRoaXMuZXJyb3JzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEVycm9ycztcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMDcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdGZ1bmN0aW9uIEFzeW5jUmVzb2x2ZXJzKG9uRmFpbGVkT25lLCBvblJlc29sdmVkQWxsKSB7XHJcblx0ICB0aGlzLm9uUmVzb2x2ZWRBbGwgPSBvblJlc29sdmVkQWxsO1xyXG5cdCAgdGhpcy5vbkZhaWxlZE9uZSA9IG9uRmFpbGVkT25lO1xyXG5cdCAgdGhpcy5yZXNvbHZlcnMgPSB7fTtcclxuXHQgIHRoaXMucmVzb2x2ZXJzQ291bnQgPSAwO1xyXG5cdCAgdGhpcy5wYXNzZWQgPSBbXTtcclxuXHQgIHRoaXMuZmFpbGVkID0gW107XHJcblx0ICB0aGlzLmZpcmluZyA9IGZhbHNlO1xyXG5cdH1cclxuXHRcclxuXHRBc3luY1Jlc29sdmVycy5wcm90b3R5cGUgPSB7XHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEFkZCByZXNvbHZlclxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7UnVsZX0gcnVsZVxyXG5cdCAgICogQHJldHVybiB7aW50ZWdlcn1cclxuXHQgICAqL1xyXG5cdCAgYWRkOiBmdW5jdGlvbihydWxlKSB7XHJcblx0ICAgIHZhciBpbmRleCA9IHRoaXMucmVzb2x2ZXJzQ291bnQ7XHJcblx0ICAgIHRoaXMucmVzb2x2ZXJzW2luZGV4XSA9IHJ1bGU7XHJcblx0ICAgIHRoaXMucmVzb2x2ZXJzQ291bnQrKztcclxuXHQgICAgcmV0dXJuIGluZGV4O1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVzb2x2ZSBnaXZlbiBpbmRleFxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge2ludGVnZXJ9IGluZGV4XHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICByZXNvbHZlOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdCAgICB2YXIgcnVsZSA9IHRoaXMucmVzb2x2ZXJzW2luZGV4XTtcclxuXHQgICAgaWYgKHJ1bGUucGFzc2VzID09PSB0cnVlKSB7XHJcblx0ICAgICAgdGhpcy5wYXNzZWQucHVzaChydWxlKTtcclxuXHQgICAgfSBlbHNlIGlmIChydWxlLnBhc3NlcyA9PT0gZmFsc2UpIHtcclxuXHQgICAgICB0aGlzLmZhaWxlZC5wdXNoKHJ1bGUpO1xyXG5cdCAgICAgIHRoaXMub25GYWlsZWRPbmUocnVsZSk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdGhpcy5maXJlKCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgYWxsIGhhdmUgYmVlbiByZXNvbHZlZFxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIGlzQWxsUmVzb2x2ZWQ6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICByZXR1cm4gKHRoaXMucGFzc2VkLmxlbmd0aCArIHRoaXMuZmFpbGVkLmxlbmd0aCkgPT09IHRoaXMucmVzb2x2ZXJzQ291bnQ7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBBdHRlbXB0IHRvIGZpcmUgZmluYWwgYWxsIHJlc29sdmVkIGNhbGxiYWNrIGlmIGNvbXBsZXRlZFxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIGZpcmU6IGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdCAgICBpZiAoIXRoaXMuZmlyaW5nKSB7XHJcblx0ICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLmlzQWxsUmVzb2x2ZWQoKSkge1xyXG5cdCAgICAgIHRoaXMub25SZXNvbHZlZEFsbCh0aGlzLmZhaWxlZC5sZW5ndGggPT09IDApO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBFbmFibGUgZmlyaW5nXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgZW5hYmxlRmlyaW5nOiBmdW5jdGlvbigpIHtcclxuXHQgICAgdGhpcy5maXJpbmcgPSB0cnVlO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBBc3luY1Jlc29sdmVycztcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGVcXFwiIHYtZWw6YXV0b2NvbXBsZXRlXFxuICAgIDpjbGFzcz1cXFwie1xcbiAgICAgICAgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdpbnZhbGlkJzogIXZhbGlkLCAnZGlydHknOiBkaXJ0eSwgJ2FjdGl2ZSc6IGFjdGl2ZSxcXG4gICAgICAgICdoYXMtbGFiZWwnOiAhaGlkZUxhYmVsLCAnaWNvbi1yaWdodCc6IGljb25SaWdodFxcbiAgICB9XFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWljb24td3JhcHBlclxcXCIgdi1pZj1cXFwic2hvd0ljb25cXFwiPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtaWNvblxcXCI+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtbGFiZWxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1sYWJlbC10ZXh0XFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8dWktaWNvblxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvblxcXCIgaWNvbj1cXFwiJiN4RTVDRFxcXCIgdGl0bGU9XFxcIkNsZWFyXFxcIlxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcImNsZWFyU2VhcmNoXFxcIiB2LXNob3c9XFxcIiFkaXNhYmxlZCAmJiB2YWx1ZS5sZW5ndGhcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbj5cXG5cXG4gICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFxcXCIgOnBsYWNlaG9sZGVyPVxcXCJwbGFjZWhvbGRlclxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgIDppZD1cXFwiaWRcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiB2LWF1dG9mb2N1cz1cXFwiYXV0b2ZvY3VzXFxcIiA6ZGVib3VuY2U9XFxcImRlYm91bmNlXFxcIlxcblxcbiAgICAgICAgICAgICAgICBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCIgQGtleWRvd24udXAucHJldmVudD1cXFwiaGlnaGxpZ2h0KGhpZ2hsaWdodGVkSXRlbSAtIDEpXFxcIlxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi5kb3duLnByZXZlbnQ9XFxcImhpZ2hsaWdodChoaWdobGlnaHRlZEl0ZW0gKyAxKVxcXCIgQGtleWRvd24udGFiPVxcXCJjbG9zZVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24uZW50ZXI9XFxcInNlbGVjdEhpZ2hsaWdodGVkKGhpZ2hsaWdodGVkSXRlbSwgJGV2ZW50KVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgdi1tb2RlbD1cXFwidmFsdWVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB2LWVsOmlucHV0XFxuICAgICAgICAgICAgPlxcblxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb25zXFxcIiB2LXNob3c9XFxcInNob3dEcm9wZG93blxcXCI+XFxuICAgICAgICAgICAgICAgIDx1aS1hdXRvY29tcGxldGUtc3VnZ2VzdGlvblxcbiAgICAgICAgICAgICAgICAgICAgOmhpZ2hsaWdodGVkPVxcXCJoaWdobGlnaHRlZEl0ZW0gPT09IGluZGV4XFxcIiA6aXRlbT1cXFwiaXRlbVxcXCIgOnBhcnRpYWw9XFxcInBhcnRpYWxcXFwiXFxuICAgICAgICAgICAgICAgICAgICA6a2V5cz1cXFwia2V5c1xcXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIGl0ZW0pIGluIHN1Z2dlc3Rpb25zIHwgZmlsdGVyQnkgc2VhcmNoIHwgbGltaXRCeSBsaW1pdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIHYtcmVmOml0ZW1zIEBjbGljaz1cXFwic2VsZWN0KGl0ZW0pXFxcIlxcbiAgICAgICAgICAgICAgICA+PC91aS1hdXRvY29tcGxldGUtc3VnZ2VzdGlvbj5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9sYWJlbD5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1mZWVkYmFja1xcXCIgdi1pZj1cXFwic2hvd0ZlZWRiYWNrXFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtZXJyb3ItdGV4dFxcXCIgdi10ZXh0PVxcXCJ2YWxpZGF0aW9uRXJyb3JcXFwiXFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb249XFxcInVpLWF1dG9jb21wbGV0ZS1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtc2hvdz1cXFwiIWhpZGVWYWxpZGF0aW9uRXJyb3JzICYmICF2YWxpZFxcXCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWhlbHAtdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktYXV0b2NvbXBsZXRlLWZlZWRiYWNrLXRvZ2dsZVxcXCJcXG4gICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCIgdi1lbHNlXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTA5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDExMClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQnV0dG9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQnV0dG9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTWVudSk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcclxuXHRcclxuXHR2YXIgX1VpUG9wb3ZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVBvcG92ZXIpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0NpcmN1bGFyKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9IYXNEcm9wZG93biA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xyXG5cdFxyXG5cdHZhciBfSGFzRHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGFzRHJvcGRvd24pO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWJ1dHRvbicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndWktYnV0dG9uLScgKyB0eXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBidXR0b25UeXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdzdWJtaXQnIH0sXHJcblx0ICAgICAgICBjb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByYWlzZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvblJpZ2h0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxvYWRpbmc6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd0Ryb3Bkb3duSWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc3R5bGVDbGFzc2VzOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbdGhpcy50eXBlLCB0aGlzLmNvbG9yXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5yYWlzZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd1aS1idXR0b24tcmFpc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhhc0Ryb3Bkb3duTWVudSB8fCB0aGlzLmhhc1BvcG92ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdoYXMtZHJvcGRvd24nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3Bpbm5lckNvbG9yOiBmdW5jdGlvbiBzcGlubmVyQ29sb3IoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IgPT09ICdjb2xvci1kZWZhdWx0JyB8fCB0aGlzLnR5cGUgPT09ICd1aS1idXR0b24tZmxhdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdibGFjayc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dJY29uOiBmdW5jdGlvbiBzaG93SWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmljb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaU1lbnU6IF9VaU1lbnUyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVBvcG92ZXI6IF9VaVBvcG92ZXIyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc0Ryb3Bkb3duMi5kZWZhdWx0LCBfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHRdLFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTEyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGJ1dHRvblxcbiAgICBjbGFzcz1cXFwidWktYnV0dG9uXFxcIiA6Y2xhc3M9XFxcInN0eWxlQ2xhc3Nlc1xcXCIgOnR5cGU9XFxcImJ1dHRvblR5cGVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkIHx8IGxvYWRpbmdcXFwiXFxuICAgIHYtZWw6YnV0dG9uXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1idXR0b24tY29udGVudFxcXCIgOmNsYXNzPVxcXCJ7ICdpbnZpc2libGUnOiBsb2FkaW5nIH1cXFwiPlxcbiAgICAgICAgPHVpLWljb25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktYnV0dG9uLWljb25cXFwiIDpjbGFzcz1cXFwieyAncG9zaXRpb24tcmlnaHQnOiBpY29uUmlnaHQgfVxcXCIgOmljb249XFxcImljb25cXFwiXFxuICAgICAgICAgICAgdi1pZj1cXFwic2hvd0ljb25cXFwiXFxuICAgICAgICA+PC91aS1pY29uPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktYnV0dG9uLXRleHRcXFwiPlxcbiAgICAgICAgICAgIDxzbG90PlxcbiAgICAgICAgICAgICAgICA8c3BhbiB2LXRleHQ9XFxcInRleHRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDx1aS1pY29uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLWJ1dHRvbi1kcm9wZG93bi1pY29uXFxcIiBpY29uPVxcXCImI3hFNUM1O1xcXCJcXG4gICAgICAgICAgICB2LWlmPVxcXCIhaWNvblJpZ2h0ICYmIHNob3dEcm9wZG93bkljb24gJiYgKGhhc0Ryb3Bkb3duTWVudSB8fCBoYXNQb3BvdmVyKVxcXCJcXG4gICAgICAgID48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8dWktcHJvZ3Jlc3MtY2lyY3VsYXJcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1idXR0b24tc3Bpbm5lclxcXCIgOmNvbG9yPVxcXCJzcGlubmVyQ29sb3JcXFwiIDpzaXplPVxcXCIxOFxcXCIgOnN0cm9rZT1cXFwiNC41XFxcIlxcbiAgICAgICAgZGlzYWJsZS10cmFuc2l0aW9uIHYtc2hvdz1cXFwibG9hZGluZ1xcXCJcXG4gICAgPjwvdWktcHJvZ3Jlc3MtY2lyY3VsYXI+XFxuXFxuICAgIDx1aS1yaXBwbGUtaW5rIHYtaWY9XFxcIiFoaWRlUmlwcGxlSW5rICYmICFkaXNhYmxlZFxcXCIgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIj48L3VpLXJpcHBsZS1pbms+XFxuXFxuICAgIDx1aS1tZW51XFxuICAgICAgICBjbGFzcz1cXFwidWktYnV0dG9uLWRyb3Bkb3duLW1lbnVcXFwiIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOm9wdGlvbnM9XFxcIm1lbnVPcHRpb25zXFxcIlxcbiAgICAgICAgOnNob3ctaWNvbnM9XFxcInNob3dNZW51SWNvbnNcXFwiIDpzaG93LXNlY29uZGFyeS10ZXh0PVxcXCJzaG93TWVudVNlY29uZGFyeVRleHRcXFwiXFxuICAgICAgICA6b3Blbi1vbj1cXFwib3BlbkRyb3Bkb3duT25cXFwiIEBvcHRpb24tc2VsZWN0ZWQ9XFxcIm1lbnVPcHRpb25TZWxlY3RcXFwiXFxuICAgICAgICA6ZHJvcGRvd24tcG9zaXRpb249XFxcImRyb3Bkb3duUG9zaXRpb25cXFwiIHYtaWY9XFxcImhhc0Ryb3Bkb3duTWVudVxcXCJcXG4gICAgPjwvdWktbWVudT5cXG5cXG4gICAgPHVpLXBvcG92ZXJcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOm9wZW4tb249XFxcIm9wZW5Ecm9wZG93bk9uXFxcIiA6ZHJvcGRvd24tcG9zaXRpb249XFxcImRyb3Bkb3duUG9zaXRpb25cXFwiXFxuICAgICAgICB2LWlmPVxcXCJoYXNQb3BvdmVyXFxcIlxcbiAgICA+XFxuICAgICAgICA8c2xvdCBuYW1lPVxcXCJwb3BvdmVyXFxcIj48L3Nsb3Q+XFxuICAgIDwvdWktcG9wb3Zlcj5cXG48L2J1dHRvbj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDExMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMTQpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUNoZWNrYm94LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQ2hlY2tib3gudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDExNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDExNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1jaGVja2JveCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBuYW1lOiBTdHJpbmcsXHJcblx0ICAgICAgICBtb2RlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFtBcnJheSwgU3RyaW5nLCBCb29sZWFuXSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB2YWx1ZTogU3RyaW5nLFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbExlZnQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGlzQ2hlY2tlZDogZnVuY3Rpb24gaXNDaGVja2VkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmluZGV4T2YodGhpcy52YWx1ZSkgPiAtMTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMubW9kZWw7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGFiZWxcXG4gICAgY2xhc3M9XFxcInVpLWNoZWNrYm94XFxcIlxcbiAgICA6Y2xhc3M9XFxcIntcXG4gICAgICAgICdkaXNhYmxlZCc6IGRpc2FibGVkLCAnY2hlY2tlZCc6IGlzQ2hlY2tlZCwgJ2FjdGl2ZSc6IGFjdGl2ZSwgJ2xhYmVsLWxlZnQnOiBsYWJlbExlZnRcXG4gICAgfVxcXCJcXG4+XFxuICAgIDxpbnB1dFxcbiAgICAgICAgY2xhc3M9XFxcInVpLWNoZWNrYm94LWlucHV0XFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiIEBmb2N1cz1cXFwiZm9jdXNcXFwiIEBibHVyPVxcXCJibHVyXFxcIlxcbiAgICAgICAgOnZhbHVlPVxcXCJ2YWx1ZSA/IHZhbHVlIDogbnVsbFxcXCIgdi1tb2RlbD1cXFwibW9kZWxcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIlxcbiAgICA+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoZWNrYm94LWNoZWNrbWFya1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGVja2JveC1mb2N1cy1yaW5nXFxcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoZWNrYm94LWxhYmVsLXRleHRcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJsYWJlbFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9zbG90PlxcbiAgICA8L2Rpdj5cXG48L2xhYmVsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTE3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDExOClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQ29sbGFwc2libGUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlDb2xsYXBzaWJsZS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTE4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTE5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF91dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XHJcblx0XHJcblx0dmFyIF91dWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V1aWQpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1JpcHBsZUluayk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktY29sbGFwc2libGUnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIG9wZW46IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVhZGVyOiBTdHJpbmcsXHJcblx0ICAgICAgICB0cmFuc2l0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd1aS1jb2xsYXBzaWJsZS10b2dnbGUnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZUljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGhlaWdodDogMCxcclxuXHQgICAgICAgICAgICBpc1JlYWR5OiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGljb246IGZ1bmN0aW9uIGljb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbiA/ICdrZXlib2FyZF9hcnJvd191cCcgOiAna2V5Ym9hcmRfYXJyb3dfZG93bic7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2FsY3VsYXRlZEhlaWdodDogZnVuY3Rpb24gY2FsY3VsYXRlZEhlaWdodCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdpbml0aWFsJztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ICsgJ3B4JztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IF91dWlkMi5kZWZhdWx0LnNob3J0KCd1aS1jb2xsYXBzaWJsZS0nKTtcclxuXHQgICAgfSxcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCk7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWNvbGxhcHNpYmxlOjpyZWZyZXNoLWhlaWdodCc6IGZ1bmN0aW9uIHVpQ29sbGFwc2libGVSZWZyZXNoSGVpZ2h0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnNldEhlaWdodCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIHRvZ2dsZU1lbnU6IGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24gc2V0SGVpZ2h0KCkge1xyXG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gdGhpcy4kZWxzLmJvZHk7XHJcblx0XHJcblx0ICAgICAgICAgICAgYm9keS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGJvZHkuc2Nyb2xsSGVpZ2h0O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5vcGVuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1JpcHBsZUluazIuZGVmYXVsdCwgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF0sXHJcblx0XHJcblx0ICAgIHRyYW5zaXRpb25zOiB7XHJcblx0ICAgICAgICAndWktY29sbGFwc2libGUtdG9nZ2xlJzoge1xyXG5cdCAgICAgICAgICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdvcGVuZWQnKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGFmdGVyTGVhdmU6IGZ1bmN0aW9uIGFmdGVyTGVhdmUoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTIwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktY29sbGFwc2libGVcXFwiPlxcbiAgICA8YnV0dG9uXFxuICAgICAgICBjbGFzcz1cXFwidWktY29sbGFwc2libGUtaGVhZGVyXFxcIiA6Y2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogZGlzYWJsZWQgfVxcXCIgOmFyaWEtY29udHJvbHM9XFxcImlkXFxcIlxcbiAgICAgICAgOmFyaWEtZXhwYW5kZWQ9XFxcIm9wZW4gPyAndHJ1ZScgOiAnZmFsc2UnXFxcIiBAY2xpY2s9XFxcInRvZ2dsZU1lbnVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgdi1lbDpidXR0b25cXG4gICAgPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY29sbGFwc2libGUtaGVhZGVyLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxzbG90IG5hbWU9XFxcImhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgdi10ZXh0PVxcXCJoZWFkZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvc2xvdD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPHVpLWljb24gY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlLWhlYWRlci1pY29uXFxcIiA6aWNvbj1cXFwiaWNvblxcXCIgdi1pZj1cXFwiIWhpZGVJY29uXFxcIj48L3VpLWljb24+XFxuXFxuICAgICAgICA8dWktcmlwcGxlLWlua1xcbiAgICAgICAgICAgIHYtaWY9XFxcIiFoaWRlUmlwcGxlSW5rICYmICFkaXNhYmxlZCAmJiBpc1JlYWR5XFxcIiA6dHJpZ2dlcj1cXFwiJGVscy5idXR0b25cXFwiXFxuICAgICAgICA+PC91aS1yaXBwbGUtaW5rPlxcbiAgICA8L2J1dHRvbj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlLWJvZHktd3JhcHBlclxcXCIgOnRyYW5zaXRpb249XFxcInRyYW5zaXRpb25cXFwiXFxuICAgICAgICA6c3R5bGU9XFxcInsgJ2hlaWdodCc6IGNhbGN1bGF0ZWRIZWlnaHQgfVxcXCIgdi1zaG93PVxcXCJvcGVuXFxcInYtZWw6Ym9keVxcbiAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jb2xsYXBzaWJsZS1ib2R5XFxcIiA6aWQ9XFxcImlkXFxcIiA6YXJpYS1oaWRkZW49XFxcIm9wZW4gPyBudWxsIDogJ3RydWUnXFxcIj5cXG4gICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMjEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTIyKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlDb25maXJtLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQ29uZmlybS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTIyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTIzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc2xpc3QpO1xyXG5cdFxyXG5cdHZhciBfVWlNb2RhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0KTtcclxuXHRcclxuXHR2YXIgX1VpTW9kYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNb2RhbCk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWNvbmZpcm0nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgc2hvdzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeScgfSxcclxuXHQgICAgICAgIGhlYWRlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnVWlDb25maXJtJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNvbmZpcm1CdXR0b25UZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdPSydcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjb25maXJtQnV0dG9uSWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgZGVueUJ1dHRvblRleHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ0NhbmNlbCdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZW55QnV0dG9uSWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgYXV0b2ZvY3VzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdkZW55LWJ1dHRvbicgfSxcclxuXHQgICAgICAgIGNsb3NlT25Db25maXJtOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJhY2tkcm9wRGlzbWlzc2libGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBjb25maXJtOiBmdW5jdGlvbiBjb25maXJtKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjb25maXJtZWQnKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jbG9zZU9uQ29uZmlybSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVueTogZnVuY3Rpb24gZGVueSgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGVuaWVkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbmVkOiBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHZvaWQgMDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5hdXRvZm9jdXMgPT09ICdjb25maXJtLWJ1dHRvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgYnV0dG9uID0gdGhpcy4kZWxzLmNvbmZpcm1CdXR0b247XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9mb2N1cyA9PT0gJ2RlbnktYnV0dG9uJykge1xyXG5cdCAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLiRlbHMuZGVueUJ1dHRvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGJ1dHRvbikge1xyXG5cdCAgICAgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LmFkZChidXR0b24sICdhdXRvZm9jdXMnKTtcclxuXHQgICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnJlbW92ZUF1dG9Gb2N1cyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbi5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZW1vdmVBdXRvRm9jdXM6IGZ1bmN0aW9uIHJlbW92ZUF1dG9Gb2N1cygpIHtcclxuXHQgICAgICAgICAgICB2YXIgYnV0dG9uID0gdm9pZCAwO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmF1dG9mb2N1cyA9PT0gJ2NvbmZpcm0tYnV0dG9uJykge1xyXG5cdCAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLiRlbHMuY29uZmlybUJ1dHRvbjtcclxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b2ZvY3VzID09PSAnZGVueS1idXR0b24nKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbiA9IHRoaXMuJGVscy5kZW55QnV0dG9uO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoYnV0dG9uKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5yZW1vdmVBdXRvRm9jdXMpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LnJlbW92ZShidXR0b24sICdhdXRvZm9jdXMnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpTW9kYWw6IF9VaU1vZGFsMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlCdXR0b246IF9VaUJ1dHRvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMjUpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNilcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaU1vZGFsLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpTW9kYWwudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NsaXN0KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLW1vZGFsJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd1aS1tb2RhbC0nICsgdHlwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVhZGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdVaU1vZGFsIEhlYWRlcidcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBib2R5OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdVaU1vZGFsIGJvZHknXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcm9sZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGlhbG9nJyB9LFxyXG5cdCAgICAgICAgdHJhbnNpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndWktbW9kYWwtc2NhbGUnIH0sXHJcblx0ICAgICAgICBzaG93Q2xvc2VCdXR0b246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlRm9vdGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc21pc3NpYmxlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmFja2Ryb3BEaXNtaXNzaWJsZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBsYXN0Rm9jdXNzZWRFbGVtZW50OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICB3YXRjaDoge1xyXG5cdCAgICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNob3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLm9wZW5lZCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2VkKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnNob3cpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRlYXJEb3duKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmRpc21pc3NpYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PT0gdGhpcy4kZWxzLm1vZGFsTWFzayAmJiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PT0gdGhpcy4kZWxzLm1vZGFsTWFzayAmJiAhdGhpcy5iYWNrZHJvcERpc21pc3NpYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbmVkOiBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0Rm9jdXNzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuXHQgICAgICAgICAgICB0aGlzLiRlbHMubW9kYWxDb250YWluZXIuZm9jdXMoKTtcclxuXHRcclxuXHQgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LmFkZChkb2N1bWVudC5ib2R5LCAndWktbW9kYWwtb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZXN0cmljdEZvY3VzLCB0cnVlKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VkOiBmdW5jdGlvbiBjbG9zZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50ZWFyRG93bigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZWRpcmVjdEZvY3VzOiBmdW5jdGlvbiByZWRpcmVjdEZvY3VzKGUpIHtcclxuXHQgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGVscy5tb2RhbENvbnRhaW5lci5mb2N1cygpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJlc3RyaWN0Rm9jdXM6IGZ1bmN0aW9uIHJlc3RyaWN0Rm9jdXMoZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy4kZWxzLm1vZGFsQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRlbHMubW9kYWxDb250YWluZXIuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGVhckRvd246IGZ1bmN0aW9uIHRlYXJEb3duKCkge1xyXG5cdCAgICAgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQucmVtb3ZlKGRvY3VtZW50LmJvZHksICd1aS1tb2RhbC1vcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxhc3RGb2N1c3NlZEVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5sYXN0Rm9jdXNzZWRFbGVtZW50LmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgncmV2ZWFsZWQnKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnaGlkZGVuJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb25CdXR0b246IF9VaUljb25CdXR0b24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaUJ1dHRvbjogX1VpQnV0dG9uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTI3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktbW9kYWwgdWktbW9kYWwtbWFza1xcXCIgdi1zaG93PVxcXCJzaG93XFxcIiA6dHJhbnNpdGlvbj1cXFwidHJhbnNpdGlvblxcXCIgOmNsYXNzPVxcXCJbdHlwZV1cXFwiXFxuICAgIDpyb2xlPVxcXCJyb2xlXFxcIiBAdHJhbnNpdGlvbmVuZD1cXFwidHJhbnNpdGlvbkVuZCB8IGRlYm91bmNlIDEwMFxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLW1vZGFsLXdyYXBwZXJcXFwiIEBjbGljaz1cXFwiY2xvc2VcXFwiIHYtZWw6bW9kYWwtbWFzaz5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktbW9kYWwtY29udGFpbmVyXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIEBrZXlkb3duLmVzYz1cXFwiY2xvc2VcXFwiXFxuICAgICAgICAgICAgdi1lbDptb2RhbC1jb250YWluZXJcXG4gICAgICAgID5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVxcXCJoZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGgxIHYtdGV4dD1cXFwiaGVhZGVyXFxcIiBjbGFzcz1cXFwidWktbW9kYWwtaGVhZGVyLXRleHRcXFwiPjwvaDE+XFxuICAgICAgICAgICAgICAgIDwvc2xvdD5cXG5cXG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiJiN4RTVDRFxcXCIgY2xhc3M9XFxcInVpLW1vZGFsLWNsb3NlLWJ1dHRvblxcXCIgQGNsaWNrPVxcXCJjbG9zZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cXFwiIWRpc21pc3NpYmxlXFxcIiB2LWlmPVxcXCJzaG93Q2xvc2VCdXR0b25cXFwiIHYtZWw6Y2xvc2UtYnV0dG9uXFxuICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi10ZXh0PVxcXCJib2R5XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW1vZGFsLWZvb3RlclxcXCIgdi1pZj1cXFwiIWhpZGVGb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHVpLWJ1dHRvbiBAY2xpY2s9XFxcImNsb3NlXFxcIiB2LWlmPVxcXCJkaXNtaXNzaWJsZVxcXCI+Q2xvc2U8L3VpLWJ1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvY3VzLXJlZGlyZWN0b3JcXFwiIEBmb2N1cz1cXFwicmVkaXJlY3RGb2N1c1xcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTI4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktY29uZmlybVxcXCI+XFxuICAgIDx1aS1tb2RhbFxcbiAgICAgICAgOnNob3cuc3luYz1cXFwic2hvd1xcXCIgcm9sZT1cXFwiYWxlcnRkaWFsb2dcXFwiIDpoZWFkZXI9XFxcImhlYWRlclxcXCIgQG9wZW5lZD1cXFwib3BlbmVkXFxcIiBzaG93LWNsb3NlLWJ1dHRvblxcbiAgICAgICAgOmRpc21pc3NpYmxlPVxcXCIhbG9hZGluZ1xcXCIgOmJhY2tkcm9wLWRpc21pc3NpYmxlPVxcXCJiYWNrZHJvcERpc21pc3NpYmxlXFxcIlxcbiAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jb25maXJtLW1lc3NhZ2VcXFwiPlxcbiAgICAgICAgICAgIDxzbG90Pjwvc2xvdD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBzbG90PVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgIDx1aS1idXR0b25cXG4gICAgICAgICAgICAgICAgOmNvbG9yPVxcXCJ0eXBlXFxcIiA6dGV4dD1cXFwiY29uZmlybUJ1dHRvblRleHRcXFwiIDppY29uPVxcXCJjb25maXJtQnV0dG9uSWNvblxcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJjb25maXJtXFxcIiA6bG9hZGluZz1cXFwibG9hZGluZ1xcXCIgdi1lbDpjb25maXJtLWJ1dHRvblxcbiAgICAgICAgICAgID48L3VpLWJ1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgICAgIDp0ZXh0PVxcXCJkZW55QnV0dG9uVGV4dFxcXCIgOmljb249XFxcImRlbnlCdXR0b25JY29uXFxcIiBAY2xpY2s9XFxcImRlbnlcXFwiXFxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cXFwibG9hZGluZ1xcXCIgdi1lbDpkZW55LWJ1dHRvblxcbiAgICAgICAgICAgID48L3VpLWJ1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L3VpLW1vZGFsPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTI5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMxKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpRmFiLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMyKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpRmFiLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9TaG93c1Rvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1Rvb2x0aXApO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWZhYicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd1aS1mYWItJyArIHR5cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhcmlhTGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1Nob3dzVG9vbHRpcDIuZGVmYXVsdCwgX1Nob3dzUmlwcGxlSW5rMi5kZWZhdWx0XSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxidXR0b25cXG4gICAgY2xhc3M9XFxcInVpLWZhYlxcXCIgOmNsYXNzPVxcXCJbdGhpcy50eXBlLCB0aGlzLmNvbG9yXVxcXCIgOmFyaWEtbGFiZWw9XFxcImFyaWFMYWJlbCB8fCB0b29sdGlwXFxcIlxcbiAgICB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdi1lbDpidXR0b25cXG4+XFxuICAgIDx1aS1pY29uIGNsYXNzPVxcXCJ1aS1mYWItaWNvblxcXCIgOmljb249XFxcImljb25cXFwiPjwvdWktaWNvbj5cXG5cXG4gICAgPHVpLXJpcHBsZS1pbmsgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIiB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiPjwvdWktcmlwcGxlLWluaz5cXG5cXG4gICAgPHVpLXRvb2x0aXBcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOmNvbnRlbnQ9XFxcInRvb2x0aXBcXFwiIDpwb3NpdGlvbj1cXFwidG9vbHRpcFBvc2l0aW9uXFxcIiB2LWlmPVxcXCJ0b29sdGlwXFxcIlxcbiAgICAgICAgOm9wZW4tb249XFxcIm9wZW5Ub29sdGlwT25cXFwiXFxuICAgID48L3VpLXRvb2x0aXA+XFxuPC9idXR0b24+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTM0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlQcmVsb2FkZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlQcmVsb2FkZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXByZWxvYWRlcicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBzaG93OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXByZWxvYWRlclxcXCI+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcmVsb2FkZXItcHJvZ3Jlc3NiYXJcXFwiIDpjbGFzcz1cXFwieyAnbG9hZGluZycgOiBzaG93IH1cXFwiXFxuICAgICAgICA6YXJpYS1idXN5PVxcXCJzaG93ID8gJ3RydWUnIDogZmFsc2VcXFwiIHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIlxcbiAgICA+PC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTM4KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzkpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlQcm9ncmVzc0xpbmVhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVByb2dyZXNzTGluZWFyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1wcm9ncmVzcy1saW5lYXInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgc2hvdzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdpbmRldGVybWluYXRlJyB9LFxyXG5cdCAgICAgICAgY29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdmFsdWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMFxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPiAxMDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTQwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtbGluZWFyXFxcIiA6Y2xhc3M9XFxcIltjb2xvcl1cXFwiIHYtc2hvdz1cXFwic2hvd1xcXCJcXG4gICAgdHJhbnNpdGlvbj1cXFwidWktcHJvZ3Jlc3MtbGluZWFyLXRvZ2dsZVxcXCJcXG4+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcm9ncmVzcy1saW5lYXItZGV0ZXJtaW5hdGVcXFwiIDpzdHlsZT1cXFwieyAnd2lkdGgnOiBwcm9ncmVzcyArICclJyB9XFxcIlxcbiAgICAgICAgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIiA6YXJpYS12YWx1ZW5vdz1cXFwidmFsdWVcXFwiXFxuICAgICAgICB2LWlmPVxcXCJ0eXBlID09PSAnZGV0ZXJtaW5hdGUnXFxcIlxcbiAgICA+PC9kaXY+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcm9ncmVzcy1saW5lYXItaW5kZXRlcm1pbmF0ZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIlxcbiAgICAgICAgOmFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCIgdi1lbHNlXFxuICAgID48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNDIpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MylcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVJhZGlvLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmFkaW8udnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJhZGlvJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBuYW1lOiBTdHJpbmcsXHJcblx0ICAgICAgICBtb2RlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnJyxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjaGVja2VkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHZhbHVlOiBTdHJpbmcsXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsTGVmdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZm9jdXNzZWQnKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2JsdXJyZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsYWJlbFxcbiAgICBjbGFzcz1cXFwidWktcmFkaW9cXFwiXFxuICAgIDpjbGFzcz1cXFwieyAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2NoZWNrZWQnOiBhY3RpdmUsICdsYWJlbC1sZWZ0JzogbGFiZWxMZWZ0IH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpby1pbnB1dC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1yYWRpby1pbnB1dFxcXCIgdHlwZT1cXFwicmFkaW9cXFwiIDppZD1cXFwiaWRcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIiA6dmFsdWU9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgIDpjaGVja2VkPVxcXCJjaGVja2VkXFxcIiBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCIgdi1tb2RlbD1cXFwibW9kZWxcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgPlxcblxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXJhZGlvLWJvcmRlclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXJhZGlvLWlubmVyLWRvdFxcXCI+PC9zcGFuPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktcmFkaW8tbGFiZWwtdGV4dFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+XFxuICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICA8c3BhbiB2LXRleHQ9XFxcImxhYmVsXFxcIj48L3NwYW4+XFxuICAgICAgICA8L3Nsb3Q+XFxuICAgIDwvZGl2PlxcbjwvbGFiZWw+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTQ2KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDcpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlSYWRpb0dyb3VwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ4KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmFkaW9Hcm91cC52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfVWlSYWRpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQxKTtcclxuXHRcclxuXHR2YXIgX1VpUmFkaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYWRpbyk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktcmFkaW8tZ3JvdXAnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgbmFtZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICcnLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wdGlvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBoaWRlTGFiZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVscFRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIHZlcnRpY2FsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93RmVlZGJhY2s6IGZ1bmN0aW9uIHNob3dGZWVkYmFjaygpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhlbHBUZXh0KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVJhZGlvOiBfVWlSYWRpbzIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19SZWNlaXZlc1RhcmdldGVkRXZlbnQyLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwXFxcIiA6aWQ9XFxcImlkXFxcIlxcbiAgICA6Y2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdhY3RpdmUnOiBhY3RpdmUsICd2ZXJ0aWNhbCc6IHZlcnRpY2FsIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpby1ncm91cC1sYWJlbFxcXCIgdi10ZXh0PVxcXCJsYWJlbFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+PC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLW9wdGlvbnMtd3JhcHBlclxcXCI+XFxuICAgICAgICA8dWktcmFkaW9cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktcmFkaW8tZ3JvdXAtcmFkaW9cXFwiIHYtZm9yPVxcXCJvcHRpb24gaW4gb3B0aW9uc1xcXCIgOm1vZGVsLnN5bmM9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgIDpuYW1lPVxcXCJuYW1lXFxcIiA6bGFiZWw9XFxcIm9wdGlvbi50ZXh0IHx8IG9wdGlvblxcXCIgOnZhbHVlPVxcXCJvcHRpb24udmFsdWUgfHwgb3B0aW9uXFxcIlxcbiAgICAgICAgICAgIDpkaXNhYmxlZD1cXFwiZGlzYWJsZWQgfHwgb3B0aW9uLmRpc2FibGVkXFxcIiBAZm9jdXNzZWQ9XFxcImZvY3VzXFxcIiBAYmx1cnJlZD1cXFwiYmx1clxcXCJcXG4gICAgICAgID48L3VpLXJhZGlvPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2tcXFwiXFxuICAgICAgICB0cmFuc2l0aW9uPVxcXCJ1aS1yYWRpby1ncm91cC1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLWhlbHAtdGV4dFxcXCIgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUmF0aW5nLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTU2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmF0aW5nLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJhdGluZ0ljb24pO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJhdGluZycsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdzdGFyJyB9LFxyXG5cdCAgICAgICAgdmFsdWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG90YWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhlbHBUZXh0OiBTdHJpbmcsXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbml0aWFsVmFsdWU6IDAsXHJcblx0ICAgICAgICAgICAgcHJldmlld1ZhbHVlOiAwLFxyXG5cdCAgICAgICAgICAgIHByZXZpZXdpbmc6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ZlZWRiYWNrOiBmdW5jdGlvbiBzaG93RmVlZGJhY2soKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5oZWxwVGV4dCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5wcmV2aWV3VmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHByZXZpZXdWYWx1ZTogZnVuY3Rpb24gcHJldmlld1ZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdwcmV2aWV3LXZhbHVlLWNoYW5nZWQnLCB0aGlzLnByZXZpZXdWYWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLnByZXZpZXdWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBzdGFydFByZXZpZXc6IGZ1bmN0aW9uIHN0YXJ0UHJldmlldygpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld2luZyA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZW5kUHJldmlldzogZnVuY3Rpb24gZW5kUHJldmlldygpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld2luZyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld1ZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwcmV2aWV3OiBmdW5jdGlvbiBwcmV2aWV3KG4pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld1ZhbHVlID0gbiArIDE7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY29tbWl0VmFsdWU6IGZ1bmN0aW9uIGNvbW1pdFZhbHVlKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPiAwICYmIHZhbHVlIDw9IHRoaXMudG90YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmNyZW1lbnRQcmV2aWV3VmFsdWU6IGZ1bmN0aW9uIGluY3JlbWVudFByZXZpZXdWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBwcm9wb3NlZFZhbHVlID0gdGhpcy5wcmV2aWV3VmFsdWUgKyAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChwcm9wb3NlZFZhbHVlIDw9IHRoaXMudG90YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wcmV2aWV3VmFsdWUgPSBwcm9wb3NlZFZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZWNyZW1lbnRQcmV2aWV3VmFsdWU6IGZ1bmN0aW9uIGRlY3JlbWVudFByZXZpZXdWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBwcm9wb3NlZFZhbHVlID0gdGhpcy5wcmV2aWV3VmFsdWUgLSAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChwcm9wb3NlZFZhbHVlID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnByZXZpZXdWYWx1ZSA9IHByb3Bvc2VkVmFsdWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydFByZXZpZXcoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5jb21taXRWYWx1ZSh0aGlzLnByZXZpZXdWYWx1ZSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5lbmRQcmV2aWV3KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpUmF0aW5nSWNvbjogX1VpUmF0aW5nSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTUzKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTQpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlSYXRpbmdJY29uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTU1KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmF0aW5nSWNvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTUzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTU0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1yYXRpbmctaWNvbicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdzdGFyJyB9LFxyXG5cdCAgICAgICAgc2VsZWN0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZmlsbGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgaWNvbjogZnVuY3Rpb24gaWNvbigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5maWxsZWQgfHwgdGhpcy5zZWxlY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RhcicgPyAnc3RhcicgOiAnZmF2b3JpdGUnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RhcicgPyAnc3Rhcl9ib3JkZXInIDogJ2Zhdm9yaXRlX2JvcmRlcic7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXJhdGluZy1pY29uXFxcIj5cXG4gICAgPHVpLWljb25cXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1yYXRpbmctaWNvbi1pY29uXFxcIiA6aWNvbj1cXFwiaWNvblxcXCJcXG4gICAgICAgIDpjbGFzcz1cXFwieyAnc2VsZWN0ZWQnOiBzZWxlY3RlZCwgJ2ZpbGxlZCcgOiBmaWxsZWQgfVxcXCJcXG4gICAgPjwvdWktaWNvbj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXJhdGluZ1xcXCIgOmNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6IGRpc2FibGVkLCAncHJldmlldyc6IHByZXZpZXdpbmcsICdhY3RpdmUnOiBhY3RpdmUgfVxcXCJcXG5cXG4gICAgOnRhYmluZGV4PVxcXCJkaXNhYmxlZCA/IG51bGwgOiAwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwidG90YWxcXFwiXFxuICAgIDphcmlhLXZhbHVlbm93PVxcXCJwcmV2aWV3VmFsdWVcXFwiXFxuXFxuICAgIEBrZXlkb3duLnVwLnByZXZlbnQ9XFxcImluY3JlbWVudFByZXZpZXdWYWx1ZVxcXCIgQGtleWRvd24uZG93bi5wcmV2ZW50PVxcXCJkZWNyZW1lbnRQcmV2aWV3VmFsdWVcXFwiXFxuICAgIEBrZXlkb3duLnJpZ2h0LnByZXZlbnQ9XFxcImluY3JlbWVudFByZXZpZXdWYWx1ZVxcXCIgQGtleWRvd24ubGVmdC5wcmV2ZW50PVxcXCJkZWNyZW1lbnRQcmV2aWV3VmFsdWVcXFwiXFxuICAgIEBrZXlkb3duLmVudGVyLnByZXZlbnQ9XFxcImNvbW1pdFZhbHVlKHByZXZpZXdWYWx1ZSlcXFwiIEBmb2N1cz1cXFwiZm9jdXNcXFwiIEBibHVyPVxcXCJibHVyXFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktcmF0aW5nLWxhYmVsXFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLXJhdGluZy1pY29ucy13cmFwcGVyXFxcIiBAbW91c2VlbnRlcj1cXFwic3RhcnRQcmV2aWV3XFxcIiBAbW91c2VsZWF2ZT1cXFwiZW5kUHJldmlld1xcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLXJhdGluZy1pY29uXFxuICAgICAgICAgICAgOnR5cGU9XFxcInR5cGVcXFwiIHYtZm9yPVxcXCJuIGluIHRvdGFsXFxcIiA6c2VsZWN0ZWQ9XFxcIihuICsgMSkgPD0gdmFsdWVcXFwiIEBtb3VzZW92ZXI9XFxcInByZXZpZXcobilcXFwiXFxuICAgICAgICAgICAgOmZpbGxlZD1cXFwiKG4gKyAxKSA8PSBwcmV2aWV3VmFsdWVcXFwiIEBjbGljaz1cXFwiY29tbWl0VmFsdWUobiArIDEpXFxcIlxcbiAgICAgICAgPjwvdWktcmF0aW5nLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktcmF0aW5nLWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2tcXFwiIHRyYW5zaXRpb249XFxcInVpLXJhdGluZy1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhdGluZy1oZWxwLXRleHRcXFwiIHYtdGV4dD1cXFwiaGVscFRleHRcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNTgpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVJhdGluZ1ByZXZpZXcudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjApXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlSYXRpbmdQcmV2aWV3LnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJhdGluZ0ljb24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktcmF0aW5nLXByZXZpZXcnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnc3RhcicgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG90YWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlSYXRpbmdJY29uOiBfVWlSYXRpbmdJY29uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTYwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktcmF0aW5nLXByZXZpZXdcXFwiIHJvbGU9XFxcInNsaWRlclxcXCIgOmFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIDphcmlhLXZhbHVlbWF4PVxcXCJ0b3RhbFxcXCJcXG4gICAgOmFyaWEtdmFsdWVub3c9XFxcInZhbHVlXFxcIlxcbj5cXG4gICAgPHVpLXJhdGluZy1pY29uXFxuICAgICAgICA6dHlwZT1cXFwidHlwZVxcXCIgdi1mb3I9XFxcIm4gaW4gdG90YWxcXFwiIDpzZWxlY3RlZD1cXFwiKG4gKyAxKSA8PSB2YWx1ZVxcXCJcXG4gICAgPjwvdWktcmF0aW5nLWljb24+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTYyKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTZWxlY3QudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzEpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlTZWxlY3QudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfbWVyZ2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQpO1xyXG5cdFxyXG5cdHZhciBfbWVyZ2VPcHRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlT3B0aW9ucyk7XHJcblx0XHJcblx0dmFyIF9mdXp6eXNlYXJjaCA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xyXG5cdFxyXG5cdHZhciBfZnV6enlzZWFyY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnV6enlzZWFyY2gpO1xyXG5cdFxyXG5cdHZhciBfZWxlbWVudFNjcm9sbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpU2VsZWN0T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlTZWxlY3RPcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTZWxlY3RPcHRpb24pO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0NpcmN1bGFyKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc1RleHRJbnB1dCk7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdGVzSW5wdXQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc2VsZWN0JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW09iamVjdCwgQXJyYXksIFN0cmluZywgTnVtYmVyXSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlZmF1bHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBBcnJheSwgU3RyaW5nLCBOdW1iZXJdLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogW11cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJ0aWFsOiBTdHJpbmcsXHJcblx0ICAgICAgICBzaG93U2VhcmNoOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlYXJjaFBsYWNlaG9sZGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdTZWFyY2gnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbXVsdGlwbGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbXVsdGlwbGVEZWxpbWl0ZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJywgJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wdGlvbnNEeW5hbWljOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wdGlvbnNMb2FkZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAndGV4dCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIGltYWdlOiAnaW1hZ2UnXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZpbHRlcjogRnVuY3Rpb25cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgcXVlcnk6ICcnLFxyXG5cdCAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IC0xLFxyXG5cdCAgICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXg6IC0xLFxyXG5cdCAgICAgICAgICAgIHNob3dEcm9wZG93bjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaWdub3JlUXVlcnlDaGFuZ2U6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgZmlsdGVyZWRPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJlZE9wdGlvbnMoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0R5bmFtaWMpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWx0ZXIodGhpcy5zZWFyY2gpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc3BsYXlUZXh0OiBmdW5jdGlvbiBkaXNwbGF5VGV4dCgpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMudmFsdWUubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLnZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtfdGhpcy5rZXlzLnRleHRdIHx8IHZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVscy5qb2luKHRoaXMubXVsdGlwbGVEZWxpbWl0ZXIpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWVbdGhpcy5rZXlzLnRleHRdIHx8IHRoaXMudmFsdWUgOiAnJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoYXNEaXNwbGF5VGV4dDogZnVuY3Rpb24gaGFzRGlzcGxheVRleHQoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVRleHQgJiYgQm9vbGVhbih0aGlzLmRpc3BsYXlUZXh0Lmxlbmd0aCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd0ljb246IGZ1bmN0aW9uIHNob3dJY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaWNvbik7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbm90aGluZ0ZvdW5kOiBmdW5jdGlvbiBub3RoaW5nRm91bmQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0R5bmFtaWMgJiYgIXRoaXMub3B0aW9uc0xvYWRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCAmJiAhdGhpcy5sb2FkaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhQm9vbGVhbih0aGlzLmZpbHRlcmVkT3B0aW9ucy5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICBmaWx0ZXJlZE9wdGlvbnM6IGZ1bmN0aW9uIGZpbHRlcmVkT3B0aW9ucygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSAwO1xyXG5cdCAgICAgICAgICAgICgwLCBfZWxlbWVudFNjcm9sbC5yZXNldFNjcm9sbCkodGhpcy4kZWxzLm9wdGlvbnNMaXN0KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93RHJvcGRvd246IGZ1bmN0aW9uIHNob3dEcm9wZG93bigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vcGVuZWQoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ29wZW5lZCcpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VkKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcXVlcnk6IGZ1bmN0aW9uIHF1ZXJ5KCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5pZ25vcmVRdWVyeUNoYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgncXVlcnktY2hhbmdlZCcsIHRoaXMucXVlcnkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdFZhbHVlKCk7XHJcblx0XHJcblx0ICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IHtcclxuXHQgICAgICAgICAgICBtaW46ICdZb3UgbXVzdCBzZWxlY3QgYXQgbGVhc3QgOm1pbiBvcHRpb25zLicsXHJcblx0ICAgICAgICAgICAgbWF4OiAnWW91IG11c3Qgc2VsZWN0IG5vIG1vcmUgdGhhbiA6bWF4IG9wdGlvbnMuJyxcclxuXHQgICAgICAgICAgICBiZXR3ZWVuOiAnWW91IG11c3Qgc2VsZWN0IGF0IGxlYXN0IDptaW4gYnV0IG5vIG1vcmUgdGhhbiA6bWF4IG9wdGlvbnMuJ1xyXG5cdCAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgIGlmICh0aGlzLnZhbGlkYXRpb25SdWxlcykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzID0gKDAsIF9tZXJnZU9wdGlvbnMyLmRlZmF1bHQpKGVycm9yTWVzc2FnZXMsIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayk7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLXNlbGVjdDo6c2V0LXNlbGVjdGVkJzogZnVuY3Rpb24gdWlTZWxlY3RTZXRTZWxlY3RlZCh2YWx1ZSwgaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuZGVmYXVsdCA9IHZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdFxyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5pbml0VmFsdWUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5jbGVhclF1ZXJ5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gLTE7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGluaXRWYWx1ZTogZnVuY3Rpb24gaW5pdFZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm11bHRpcGxlID8gW10gOiBudWxsO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gQXJyYXkuaXNBcnJheSh0aGlzLmRlZmF1bHQpID8gdGhpcy5kZWZhdWx0IDogW3RoaXMuZGVmYXVsdF07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdFZhbHVlKGRlZmF1bHRzKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaChvcHRpb24pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG9wdGlvbiwgdGhpcy5xdWVyeSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkudG9Mb3dlckNhc2UoKTtcclxuXHQgICAgICAgICAgICB2YXIgdGV4dCA9IG9wdGlvblt0aGlzLmtleXMudGV4dF0gfHwgb3B0aW9uO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfZnV6enlzZWFyY2gyLmRlZmF1bHQpKHF1ZXJ5LCB0ZXh0KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbGVhclF1ZXJ5OiBmdW5jdGlvbiBjbGVhclF1ZXJ5KCkge1xyXG5cdCAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaWdub3JlUXVlcnlDaGFuZ2UgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgX3RoaXMyLnF1ZXJ5ID0gJyc7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzMi4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmlnbm9yZVF1ZXJ5Q2hhbmdlID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KG9wdGlvbiwgaW5kZXgpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2xvc2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzJdO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQob3B0aW9uKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdChvcHRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKG9wdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9uO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3NlbGVjdGVkJywgb3B0aW9uKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmNsZWFyUXVlcnkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmIGNsb3NlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KG9wdGlvbikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUuJHJlbW92ZShvcHRpb24pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaW5kZXhPZihvcHRpb24pID4gLTE7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvcHRpb247XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0SGlnaGxpZ2h0ZWQ6IGZ1bmN0aW9uIHNlbGVjdEhpZ2hsaWdodGVkKGluZGV4LCBlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMub3B0aW9ucy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLiRyZWZzLm9wdGlvbnNbaW5kZXhdLm9wdGlvbiwgaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChpbmRleCwgcHJldmVudFNjcm9sbCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkSW5kZXggPT09IGluZGV4IHx8IHRoaXMuJHJlZnMub3B0aW9ucy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IDA7XHJcblx0ICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuJHJlZnMub3B0aW9ucy5sZW5ndGggLSAxO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChpbmRleCA8IGZpcnN0SW5kZXgpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IGZpcnN0SW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IGluZGV4O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghcHJldmVudFNjcm9sbCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE9wdGlvbkludG9WaWV3KHRoaXMuJHJlZnMub3B0aW9uc1tpbmRleF0uJGVsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcGVuZWQ6IGZ1bmN0aW9uIG9wZW5lZCgpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChfdGhpczMuc2hvd1NlYXJjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMzLiRlbHMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMy4kZWxzLmRyb3Bkb3duLmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICAgICAgX3RoaXMzLnNjcm9sbE9wdGlvbkludG9WaWV3KF90aGlzMy4kZWxzLm9wdGlvbnNMaXN0LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3RlZCcpKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoZGVhY3RpdmF0ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmRpcnR5KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoZGVhY3RpdmF0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGVscy5sYWJlbC5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZU9uRXh0ZXJuYWxDbGljazogZnVuY3Rpb24gY2xvc2VPbkV4dGVybmFsQ2xpY2soZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy4kZWwuY29udGFpbnMoZS50YXJnZXQpICYmICh0aGlzLnNob3dEcm9wZG93biB8fCB0aGlzLmFjdGl2ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VkOiBmdW5jdGlvbiBjbG9zZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IC0xO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2V0RGVmYXVsdFZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUoZGVmYXVsdHMpIHtcclxuXHQgICAgICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25WYWx1ZSA9IHZvaWQgMDtcclxuXHRcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25WYWx1ZSA9IGRlZmF1bHRzW2ldW3RoaXMua2V5cy52YWx1ZV0gfHwgZGVmYXVsdHNbaV07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5vcHRpb25zLmxlbmd0aDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9IHRoaXMub3B0aW9uc1tqXVt0aGlzLmtleXMudmFsdWVdIHx8IHRoaXMub3B0aW9uc1tqXTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gZGVmYXVsdE9wdGlvblZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5vcHRpb25zW2pdLCBqLCBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2Nyb2xsT3B0aW9uSW50b1ZpZXc6IGZ1bmN0aW9uIHNjcm9sbE9wdGlvbkludG9WaWV3KG9wdGlvbkVsKSB7XHJcblx0ICAgICAgICAgICAgKDAsIF9lbGVtZW50U2Nyb2xsLnNjcm9sbEludG9WaWV3KShvcHRpb25FbCwgdGhpcy4kZWxzLm9wdGlvbnNMaXN0LCA4MCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdCxcclxuXHQgICAgICAgIFVpU2VsZWN0T3B0aW9uOiBfVWlTZWxlY3RPcHRpb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVByb2dyZXNzQ2lyY3VsYXI6IF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc1RleHRJbnB1dDIuZGVmYXVsdCwgX1ZhbGlkYXRlc0lucHV0Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHR2YXIgaXNPcHRpb25PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NSk7XHJcblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHR2YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxuXHR2YXIgZ2xvYmFsVGhpcyA9IHRoaXM7XHJcblx0dmFyIGRlZmF1bHRNZXJnZU9wdHMgPSB7XHJcblx0XHRjb25jYXRBcnJheXM6IGZhbHNlXHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKHZhbHVlKSB7XHJcblx0XHR2YXIga2V5cyA9IFtdO1xyXG5cdFxyXG5cdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XHJcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcclxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XHJcblx0XHRcdHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XHJcblx0XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbHNbaV0pKSB7XHJcblx0XHRcdFx0XHRrZXlzLnB1c2goc3ltYm9sc1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHJcblx0XHRyZXR1cm4ga2V5cztcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gY2xvbmVBcnJheSh2YWx1ZSk7XHJcblx0XHR9XHJcblx0XHJcblx0XHRpZiAoaXNPcHRpb25PYmplY3QodmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBjbG9uZU9wdGlvbk9iamVjdCh2YWx1ZSk7XHJcblx0XHR9XHJcblx0XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXkpIHtcclxuXHRcdHZhciByZXN1bHQgPSBhcnJheS5zbGljZSgwLCAwKTtcclxuXHRcclxuXHRcdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRyZXN1bHRba2V5XSA9IGNsb25lKGFycmF5W2tleV0pO1xyXG5cdFx0fSk7XHJcblx0XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBjbG9uZU9wdGlvbk9iamVjdChvYmopIHtcclxuXHRcdHZhciByZXN1bHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcclxuXHRcclxuXHRcdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdFx0cmVzdWx0W2tleV0gPSBjbG9uZShvYmpba2V5XSk7XHJcblx0XHR9KTtcclxuXHRcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBtZXJnZWQge2FscmVhZHkgY2xvbmVkfVxyXG5cdCAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gbWVyZ2VLZXlzKG1lcmdlZCwgc291cmNlLCBrZXlzLCBtZXJnZU9wdHMpIHtcclxuXHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHRcdGlmIChrZXkgaW4gbWVyZ2VkKSB7XHJcblx0XHRcdFx0bWVyZ2VkW2tleV0gPSBtZXJnZShtZXJnZWRba2V5XSwgc291cmNlW2tleV0sIG1lcmdlT3B0cyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bWVyZ2VkW2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogQHBhcmFtIG1lcmdlZCB7YWxyZWFkeSBjbG9uZWR9XHJcblx0ICogQHJldHVybiB7Y2xvbmVkIE9iamVjdH1cclxuXHQgKlxyXG5cdCAqIHNlZSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdClcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBjb25jYXRBcnJheXMobWVyZ2VkLCBzb3VyY2UsIG1lcmdlT3B0cykge1xyXG5cdFx0dmFyIHJlc3VsdCA9IG1lcmdlZC5zbGljZSgwLCAwKTtcclxuXHRcdHZhciByZXN1bHRJbmRleCA9IDA7XHJcblx0XHJcblx0XHRbbWVyZ2VkLCBzb3VyY2VdLmZvckVhY2goZnVuY3Rpb24gKGFycmF5KSB7XHJcblx0XHRcdHZhciBpbmRpY2VzID0gW107XHJcblx0XHJcblx0XHRcdC8vIHJlc3VsdC5jb25jYXQoYXJyYXkpIHdpdGggY2xvbmluZ1xyXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGFycmF5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBrKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdGluZGljZXMucHVzaChTdHJpbmcoaykpO1xyXG5cdFxyXG5cdFx0XHRcdGlmIChhcnJheSA9PT0gbWVyZ2VkKSB7XHJcblx0XHRcdFx0XHQvLyBhbHJlYWR5IGNsb25lZFxyXG5cdFx0XHRcdFx0cmVzdWx0W3Jlc3VsdEluZGV4KytdID0gYXJyYXlba107XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJlc3VsdFtyZXN1bHRJbmRleCsrXSA9IGNsb25lKGFycmF5W2tdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcclxuXHRcdFx0Ly8gbWVyZ2Ugbm9uLWluZGV4IGtleXNcclxuXHRcdFx0cmVzdWx0ID0gbWVyZ2VLZXlzKHJlc3VsdCwgYXJyYXksIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHRcdFx0cmV0dXJuIGluZGljZXMuaW5kZXhPZihrZXkpID09PSAtMTtcclxuXHRcdFx0fSksIG1lcmdlT3B0cyk7XHJcblx0XHR9KTtcclxuXHRcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBtZXJnZWQge2FscmVhZHkgY2xvbmVkfVxyXG5cdCAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gbWVyZ2UobWVyZ2VkLCBzb3VyY2UsIG1lcmdlT3B0cykge1xyXG5cdFx0aWYgKG1lcmdlT3B0cy5jb25jYXRBcnJheXMgJiYgQXJyYXkuaXNBcnJheShtZXJnZWQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xyXG5cdFx0XHRyZXR1cm4gY29uY2F0QXJyYXlzKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0aWYgKCFpc09wdGlvbk9iamVjdChzb3VyY2UpIHx8ICFpc09wdGlvbk9iamVjdChtZXJnZWQpKSB7XHJcblx0XHRcdHJldHVybiBjbG9uZShzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0cmV0dXJuIG1lcmdlS2V5cyhtZXJnZWQsIHNvdXJjZSwgZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhzb3VyY2UpLCBtZXJnZU9wdHMpO1xyXG5cdH1cclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtZXJnZU9wdHMgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRzKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdHMpO1xyXG5cdFx0dmFyIG1lcmdlZCA9IHt9O1xyXG5cdFxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIG9wdGlvbiA9IGFyZ3VtZW50c1tpXTtcclxuXHRcclxuXHRcdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcclxuXHRcdFx0aWYgKCFpc09wdGlvbk9iamVjdChvcHRpb24pKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYCcgKyBvcHRpb24gKyAnYCBpcyBub3QgYW4gT3B0aW9uIE9iamVjdCcpO1xyXG5cdFx0XHR9XHJcblx0XHJcblx0XHRcdG1lcmdlZCA9IG1lcmdlKG1lcmdlZCwgb3B0aW9uLCBtZXJnZU9wdHMpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xyXG5cdFx0dmFyIHByb3RvdHlwZTtcclxuXHRcdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAocHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLCBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5pblZpZXcgPSBpblZpZXc7XHJcblx0ZXhwb3J0cy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xyXG5cdGV4cG9ydHMucmVzZXRTY3JvbGwgPSByZXNldFNjcm9sbDtcclxuXHRmdW5jdGlvbiBpblZpZXcoZWxlbWVudCwgY29udGFpbmVyKSB7XHJcblx0ICAgIGlmICghZWxlbWVudCkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblx0XHJcblx0ICAgIHZhciB0b3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuXHQgICAgdmFyIHBhcmVudFRvcCA9IGNvbnRhaW5lci5zY3JvbGxUb3A7XHJcblx0ICAgIHZhciBib3R0b20gPSB0b3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuXHQgICAgdmFyIHBhcmVudEJvdHRvbSA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblx0XHJcblx0ICAgIHJldHVybiB0b3AgPj0gcGFyZW50VG9wICYmIGJvdHRvbSA8PSBwYXJlbnRCb3R0b207XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIGNvbnRhaW5lcikge1xyXG5cdCAgICB2YXIgbWFyZ2luVG9wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcclxuXHRcclxuXHQgICAgaWYgKCFlbGVtZW50IHx8IGluVmlldyhlbGVtZW50LCBjb250YWluZXIpKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHRcclxuXHQgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIC0gbWFyZ2luVG9wO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiByZXNldFNjcm9sbChlbGVtZW50KSB7XHJcblx0ICAgIGlmICghZWxlbWVudCkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcclxuXHR9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBpblZpZXc6IGluVmlldyxcclxuXHQgICAgc2Nyb2xsSW50b1ZpZXc6IHNjcm9sbEludG9WaWV3LFxyXG5cdCAgICByZXNldFNjcm9sbDogcmVzZXRTY3JvbGxcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTY3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU2VsZWN0T3B0aW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcwKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU2VsZWN0T3B0aW9uLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXNlbGVjdC1vcHRpb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgb3B0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLXNlbGVjdC1zaW1wbGUnIH0sXHJcblx0ICAgICAgICBzaG93Q2hlY2tib3g6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlnaGxpZ2h0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAga2V5czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd0ZXh0JyxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndmFsdWUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW1hZ2U6ICdpbWFnZSdcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBpY29uOiBmdW5jdGlvbiBpY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkID8gJ2NoZWNrX2JveCcgOiAnY2hlY2tfYm94X291dGxpbmVfYmxhbmsnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcGFydGlhbHM6IHtcclxuXHQgICAgICAgICd1aS1zZWxlY3Qtc2ltcGxlJzogJ1xcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cInVpLXNlbGVjdC1pdGVtLXRleHRcIiB2LXRleHQ9XCJvcHRpb25ba2V5cy50ZXh0XSB8fCBvcHRpb25cIj48L2xpPlxcbiAgICAgICAgJyxcclxuXHRcclxuXHQgICAgICAgICd1aS1zZWxlY3QtaW1hZ2UnOiAnXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cInVpLXNlbGVjdC1pdGVtLWltYWdlXCJcXG4gICAgICAgICAgICAgICAgOnN0eWxlPVwieyBcXCdiYWNrZ3JvdW5kLWltYWdlXFwnOiBcXCd1cmwoXFwnICsgb3B0aW9uW2tleXMuaW1hZ2VdICsgXFwnKVxcJyB9XCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLXNlbGVjdC1pdGVtLXRleHRcIiB2LXRleHQ9XCJvcHRpb25ba2V5cy50ZXh0XVwiPjwvZGl2PlxcbiAgICAgICAgJ1xyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsaVxcbiAgICBjbGFzcz1cXFwidWktc2VsZWN0LW9wdGlvblxcXCIgOmNsYXNzPVxcXCJ7IGhpZ2hsaWdodGVkOiBoaWdobGlnaHRlZCwgc2VsZWN0ZWQ6IHNlbGVjdGVkIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3Qtb3B0aW9uLWNvbnRlbnRcXFwiIDpjbGFzcz1cXFwiW3BhcnRpYWxdXFxcIj5cXG4gICAgICAgIDxwYXJ0aWFsIDpuYW1lPVxcXCJwYXJ0aWFsXFxcIj48L3BhcnRpYWw+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8dWktaWNvblxcbiAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1vcHRpb24tY2hlY2tib3hcXFwiIDppY29uPVxcXCJpY29uXFxcIiB2LWlmPVxcXCJzaG93Q2hlY2tib3hcXFwiXFxuICAgID48L3VpLWljb24+XFxuPC9saT5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXNlbGVjdFxcXCIgOmlkPVxcXCJpZFxcXCIgOmNsYXNzPVxcXCJ7XFxuICAgICAgICAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2ludmFsaWQnOiAhdmFsaWQsICdkaXJ0eSc6IGRpcnR5LCAnYWN0aXZlJzogYWN0aXZlLFxcbiAgICAgICAgJ2hhcy1sYWJlbCc6ICFoaWRlTGFiZWwsICdpY29uLXJpZ2h0JzogaWNvblJpZ2h0XFxuICAgIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtaWNvbi13cmFwcGVyXFxcIiB2LWlmPVxcXCJzaG93SWNvblxcXCI+XFxuICAgICAgICA8dWktaWNvbiA6aWNvbj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1pY29uXFxcIj48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1sYWJlbFxcXCIgOnRhYmluZGV4PVxcXCJkaXNhYmxlZCA/IG51bGwgOiAnMCdcXFwiIHYtZWw6bGFiZWxcXG4gICAgICAgICAgICBAZm9jdXM9XFxcImZvY3VzXFxcIiBAa2V5ZG93bi50YWI9XFxcImJsdXJcXFwiIEBjbGljaz1cXFwidG9nZ2xlXFxcIiBAa2V5ZG93bi5zcGFjZS5wcmV2ZW50PVxcXCJvcGVuXFxcIlxcbiAgICAgICAgICAgIEBrZXlkb3duLmVudGVyLnByZXZlbnQ9XFxcIm9wZW5cXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWxhYmVsLXRleHRcXFwiIHYtdGV4dD1cXFwibGFiZWxcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1kaXNwbGF5XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC12YWx1ZVxcXCIgOmNsYXNzPVxcXCJ7IHBsYWNlaG9sZGVyOiAhaGFzRGlzcGxheVRleHQgfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiaGFzRGlzcGxheVRleHQgPyBkaXNwbGF5VGV4dCA6IHBsYWNlaG9sZGVyXFxcIlxcbiAgICAgICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDx1aS1pY29uIGljb249XFxcImFycm93X2Ryb3BfZG93blxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1kcm9wZG93bi1pY29uXFxcIj48L3VpLWljb24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktc2VsZWN0LWRyb3Bkb3duXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHYtc2hvdz1cXFwic2hvd0Ryb3Bkb3duXFxcIiB2LWVsOmRyb3Bkb3duXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVzYy5wcmV2ZW50PVxcXCJjbG9zZSgpXFxcIiBAa2V5ZG93bi50YWI9XFxcImNsb3NlKClcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLnVwLnByZXZlbnQ9XFxcImhpZ2hsaWdodChoaWdobGlnaHRlZEluZGV4IC0gMSlcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmRvd24ucHJldmVudD1cXFwiaGlnaGxpZ2h0KGhpZ2hsaWdodGVkSW5kZXggKyAxKVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24uZW50ZXIucHJldmVudC5zdG9wPVxcXCJzZWxlY3RIaWdobGlnaHRlZChoaWdobGlnaHRlZEluZGV4LCAkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LXNlYXJjaFxcXCIgdi1pZj1cXFwic2hvd1NlYXJjaFxcXCIgQGNsaWNrLnN0b3AgQGtleWRvd24uc3BhY2Uuc3RvcD5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoLWlucHV0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LWVsOnNlYXJjaC1pbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cXFwic2VhcmNoUGxhY2Vob2xkZXJcXFwiIHYtbW9kZWw9XFxcInF1ZXJ5XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCJcXG4gICAgICAgICAgICAgICAgICAgID5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDx1aS1wcm9ncmVzcy1jaXJjdWxhclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoLXNwaW5uZXJcXFwiIDpzaXplPVxcXCIyNFxcXCIgOnN0cm9rZT1cXFwiNFxcXCIgOnNob3c9XFxcImxvYWRpbmdcXFwiXFxuICAgICAgICAgICAgICAgICAgICA+PC91aS1wcm9ncmVzcy1jaXJjdWxhcj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktc2VsZWN0LW9wdGlvbnNcXFwiIHYtZWw6b3B0aW9ucy1saXN0PlxcbiAgICAgICAgICAgICAgICAgICAgPHVpLXNlbGVjdC1vcHRpb25cXG4gICAgICAgICAgICAgICAgICAgICAgICA6b3B0aW9uPVxcXCJvcHRpb25cXFwiIDpwYXJ0aWFsPVxcXCJwYXJ0aWFsXFxcIiA6c2hvdy1jaGVja2JveD1cXFwibXVsdGlwbGVcXFwiIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICA6a2V5cz1cXFwia2V5c1xcXCIgQGNsaWNrLnN0b3AucHJldmVudD1cXFwic2VsZWN0KG9wdGlvbiwgaW5kZXgpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIEBtb3VzZW92ZXIuc3RvcD1cXFwiaGlnaGxpZ2h0KGluZGV4LCB0cnVlKVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA6aGlnaGxpZ2h0ZWQ9XFxcImhpZ2hsaWdodGVkSW5kZXggPT09IGluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDpzZWxlY3RlZD1cXFwiaXNTZWxlY3RlZChvcHRpb24pXFxcIlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIG9wdGlvbikgaW4gZmlsdGVyZWRPcHRpb25zXFxcIiB2LXJlZjpvcHRpb25zXFxuICAgICAgICAgICAgICAgICAgICA+PC91aS1zZWxlY3Qtb3B0aW9uPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtbm8tcmVzdWx0c1xcXCIgdi1pZj1cXFwibm90aGluZ0ZvdW5kXFxcIj5ObyByZXN1bHRzIGZvdW5kPC9saT5cXG4gICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2tcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1lcnJvci10ZXh0XFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1zZWxlY3QtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICAgICAgICAgICAgICB2LXRleHQ9XFxcInZhbGlkYXRpb25FcnJvclxcXCIgdi1zaG93PVxcXCIhaGlkZVZhbGlkYXRpb25FcnJvcnMgJiYgIXZhbGlkXFxcIlxcbiAgICAgICAgICAgID48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3QtaGVscC10ZXh0XFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1zZWxlY3QtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICAgICAgICAgICAgICB2LXRleHQ9XFxcImhlbHBUZXh0XFxcIiB2LWVsc2VcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTczKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzQpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTbGlkZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODMpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlTbGlkZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZHJhZ2dhYmlsbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NSk7XHJcblx0XHJcblx0dmFyIF9kcmFnZ2FiaWxseTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kcmFnZ2FiaWxseSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc2xpZGVyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG5hbWU6IFN0cmluZyxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHN0ZXA6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogNVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBoaWRlTGFiZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiAwLFxyXG5cdCAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBkcmFnZ2FibGU6IG51bGxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93SWNvbjogZnVuY3Rpb24gc2hvd0ljb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pY29uKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoYXNMYWJlbDogZnVuY3Rpb24gaGFzTGFiZWwoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaGlkZUxhYmVsKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmxhYmVsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZWxzLnRodW1iLnN0eWxlLmxlZnQgPSB0aGlzLnZhbHVlICsgJyUnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuZGlzYWJsZSgpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHRcclxuXHQgICAgICAgIHRoaXMuJGVscy50aHVtYi5zdHlsZS5sZWZ0ID0gdGhpcy52YWx1ZSArICclJztcclxuXHRcclxuXHQgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gbmV3IF9kcmFnZ2FiaWxseTIuZGVmYXVsdCh0aGlzLiRlbHMudGh1bWIsIHtcclxuXHQgICAgICAgICAgICBjb250YWlubWVudDogdGhpcy4kZWxzLmNvbnRhaW5tZW50LFxyXG5cdCAgICAgICAgICAgIGF4aXM6ICd4J1xyXG5cdCAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ1N0YXJ0JywgdGhpcy5kcmFnU3RhcnQpO1xyXG5cdCAgICAgICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdNb3ZlJywgdGhpcy5kcmFnTW92ZSk7XHJcblx0ICAgICAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ0VuZCcsIHRoaXMuZHJhZ0VuZCk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmRpc2FibGUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmRlc3Ryb3koKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2xpZGVyQ2xpY2s6IGZ1bmN0aW9uIHNsaWRlckNsaWNrKGUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBzbGlkZXJQb3NpdGlvbiA9IHRoaXMuJGVscy5zbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gKGUuY2xpZW50WCAtIHNsaWRlclBvc2l0aW9uLmxlZnQpIC8gc2xpZGVyUG9zaXRpb24ud2lkdGggKiAxMDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLiRlbHMudGh1bWIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuX3BvaW50ZXJEb3duKGUsIGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHJhZ01vdmU6IGZ1bmN0aW9uIGRyYWdNb3ZlKCkge1xyXG5cdCAgICAgICAgICAgIHZhciB4ID0gdGhpcy5kcmFnZ2FibGUucG9zaXRpb24ueDtcclxuXHQgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB4IC8gdGhpcy4kZWxzLnNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAqIDEwMDtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlKG5ld1ZhbHVlKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkcmFnRW5kOiBmdW5jdGlvbiBkcmFnRW5kKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmNyZW1lbnQ6IGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gMTAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlICsgdGhpcy5zdGVwKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZWNyZW1lbnQ6IGZ1bmN0aW9uIGRlY3JlbWVudCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZSAtIHRoaXMuc3RlcCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIG1vZGVyYXRlZFZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG1vZGVyYXRlZFZhbHVlID49IDEwMCkge1xyXG5cdCAgICAgICAgICAgICAgICBtb2RlcmF0ZWRWYWx1ZSA9IDEwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG1vZGVyYXRlZFZhbHVlIDw9IDApIHtcclxuXHQgICAgICAgICAgICAgICAgbW9kZXJhdGVkVmFsdWUgPSAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gbW9kZXJhdGVkVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIERyYWdnYWJpbGx5IHYxLjIuNFxyXG5cdCAqIE1ha2UgdGhhdCBzaGl6IGRyYWdnYWJsZVxyXG5cdCAqIGh0dHA6Ly9kcmFnZ2FiaWxseS5kZXNhbmRyby5jb21cclxuXHQgKiBNSVQgbGljZW5zZVxyXG5cdCAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcclxuXHQgICd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblx0ICAgIC8vIEFNRFxyXG5cdCAgICBkZWZpbmUoIFtcclxuXHQgICAgICAgICdjbGFzc2llL2NsYXNzaWUnLFxyXG5cdCAgICAgICAgJ2dldC1zdHlsZS1wcm9wZXJ0eS9nZXQtc3R5bGUtcHJvcGVydHknLFxyXG5cdCAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcclxuXHQgICAgICAgICd1bmlkcmFnZ2VyL3VuaWRyYWdnZXInXHJcblx0ICAgICAgXSxcclxuXHQgICAgICBmdW5jdGlvbiggY2xhc3NpZSwgZ2V0U3R5bGVQcm9wZXJ0eSwgZ2V0U2l6ZSwgVW5pZHJhZ2dlciApIHtcclxuXHQgICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGNsYXNzaWUsIGdldFN0eWxlUHJvcGVydHksIGdldFNpemUsIFVuaWRyYWdnZXIgKTtcclxuXHQgICAgICB9KTtcclxuXHQgIH0gZWxzZSBpZiAoIHRydWUgKSB7XHJcblx0ICAgIC8vIENvbW1vbkpTXHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxNzYpLFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTc3KSxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OCksXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxNzkpXHJcblx0ICAgICk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgICB3aW5kb3cuRHJhZ2dhYmlsbHkgPSBmYWN0b3J5KFxyXG5cdCAgICAgIHdpbmRvdyxcclxuXHQgICAgICB3aW5kb3cuY2xhc3NpZSxcclxuXHQgICAgICB3aW5kb3cuZ2V0U3R5bGVQcm9wZXJ0eSxcclxuXHQgICAgICB3aW5kb3cuZ2V0U2l6ZSxcclxuXHQgICAgICB3aW5kb3cuVW5pZHJhZ2dlclxyXG5cdCAgICApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBjbGFzc2llLCBnZXRTdHlsZVByb3BlcnR5LCBnZXRTaXplLCBVbmlkcmFnZ2VyICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQvLyB2YXJzXHJcblx0dmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHQvLyBleHRlbmQgb2JqZWN0c1xyXG5cdGZ1bmN0aW9uIGV4dGVuZCggYSwgYiApIHtcclxuXHQgIGZvciAoIHZhciBwcm9wIGluIGIgKSB7XHJcblx0ICAgIGFbIHByb3AgXSA9IGJbIHByb3AgXTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBhO1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLSBnZXQgc3R5bGUgLS0tLS0gLy9cclxuXHRcclxuXHR2YXIgZGVmVmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cdFxyXG5cdHZhciBnZXRTdHlsZSA9IGRlZlZpZXcgJiYgZGVmVmlldy5nZXRDb21wdXRlZFN0eWxlID9cclxuXHQgIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgICByZXR1cm4gZGVmVmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XHJcblx0ICB9IDpcclxuXHQgIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgICByZXR1cm4gZWxlbS5jdXJyZW50U3R5bGU7XHJcblx0ICB9O1xyXG5cdFxyXG5cdFxyXG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4NDM4MC8xODIxODNcclxuXHR2YXIgaXNFbGVtZW50ID0gKCB0eXBlb2YgSFRNTEVsZW1lbnQgPT0gJ29iamVjdCcgKSA/XHJcblx0ICBmdW5jdGlvbiBpc0VsZW1lbnRET00yKCBvYmogKSB7XHJcblx0ICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcclxuXHQgIH0gOlxyXG5cdCAgZnVuY3Rpb24gaXNFbGVtZW50UXVpcmt5KCBvYmogKSB7XHJcblx0ICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyAmJlxyXG5cdCAgICAgIG9iai5ub2RlVHlwZSA9PSAxICYmIHR5cGVvZiBvYmoubm9kZU5hbWUgPT0gJ3N0cmluZyc7XHJcblx0ICB9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHJlcXVlc3RBbmltYXRpb25GcmFtZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE4NjY0NzRcclxuXHRcclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cdHZhciBwcmVmaXhlcyA9ICd3ZWJraXQgbW96IG1zIG8nLnNwbGl0KCcgJyk7XHJcblx0Ly8gZ2V0IHVucHJlZml4ZWQgckFGIGFuZCBjQUYsIGlmIHByZXNlbnRcclxuXHR2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXHR2YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcblx0Ly8gbG9vcCB0aHJvdWdoIHZlbmRvciBwcmVmaXhlcyBhbmQgZ2V0IHByZWZpeGVkIHJBRiBhbmQgY0FGXHJcblx0dmFyIHByZWZpeDtcclxuXHRmb3IoIHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrICkge1xyXG5cdCAgaWYgKCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSB7XHJcblx0ICAgIGJyZWFrO1xyXG5cdCAgfVxyXG5cdCAgcHJlZml4ID0gcHJlZml4ZXNbaV07XHJcblx0ICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93WyBwcmVmaXggKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cdCAgY2FuY2VsQW5pbWF0aW9uRnJhbWUgID0gY2FuY2VsQW5pbWF0aW9uRnJhbWUgIHx8IHdpbmRvd1sgcHJlZml4ICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJyBdIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1sgcHJlZml4ICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcclxuXHR9XHJcblx0XHJcblx0Ly8gZmFsbGJhY2sgdG8gc2V0VGltZW91dCBhbmQgY2xlYXJUaW1lb3V0IGlmIGVpdGhlciByZXF1ZXN0L2NhbmNlbCBpcyBub3Qgc3VwcG9ydGVkXHJcblx0aWYgKCAhcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICFjYW5jZWxBbmltYXRpb25GcmFtZSApICB7XHJcblx0ICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XHJcblx0ICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdCAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XHJcblx0ICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICBjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XHJcblx0ICAgIH0sIHRpbWVUb0NhbGwgKTtcclxuXHQgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcblx0ICAgIHJldHVybiBpZDtcclxuXHQgIH07XHJcblx0XHJcblx0ICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBpZCApIHtcclxuXHQgICAgd2luZG93LmNsZWFyVGltZW91dCggaWQgKTtcclxuXHQgIH07XHJcblx0fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHN1cHBvcnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHR2YXIgdHJhbnNmb3JtUHJvcGVydHkgPSBnZXRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nKTtcclxuXHQvLyBUT0RPIGZpeCBxdWljayAmIGRpcnR5IGNoZWNrIGZvciAzRCBzdXBwb3J0XHJcblx0dmFyIGlzM2QgPSAhIWdldFN0eWxlUHJvcGVydHkoJ3BlcnNwZWN0aXZlJyk7XHJcblx0XHJcblx0dmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0ZnVuY3Rpb24gRHJhZ2dhYmlsbHkoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XHJcblx0ICAvLyBxdWVyeVNlbGVjdG9yIGlmIHN0cmluZ1xyXG5cdCAgdGhpcy5lbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xyXG5cdCAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtZW50ICkgOiBlbGVtZW50O1xyXG5cdFxyXG5cdCAgaWYgKCBqUXVlcnkgKSB7XHJcblx0ICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gb3B0aW9uc1xyXG5cdCAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKCB7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cyApO1xyXG5cdCAgdGhpcy5vcHRpb24oIG9wdGlvbnMgKTtcclxuXHRcclxuXHQgIHRoaXMuX2NyZWF0ZSgpO1xyXG5cdH1cclxuXHRcclxuXHQvLyBpbmhlcml0IFVuaWRyYWdnZXIgbWV0aG9kc1xyXG5cdGV4dGVuZCggRHJhZ2dhYmlsbHkucHJvdG90eXBlLCBVbmlkcmFnZ2VyLnByb3RvdHlwZSApO1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LmRlZmF1bHRzID0ge1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogc2V0IG9wdGlvbnNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiggb3B0cyApIHtcclxuXHQgIGV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRzICk7XHJcblx0fTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdCAgLy8gcHJvcGVydGllc1xyXG5cdCAgdGhpcy5wb3NpdGlvbiA9IHt9O1xyXG5cdCAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcclxuXHRcclxuXHQgIHRoaXMuc3RhcnRQb2ludCA9IHsgeDogMCwgeTogMCB9O1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHRcclxuXHQgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IGV4dGVuZCgge30sIHRoaXMucG9zaXRpb24gKTtcclxuXHRcclxuXHQgIC8vIHNldCByZWxhdGl2ZSBwb3NpdGlvbmluZ1xyXG5cdCAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIHRoaXMuZWxlbWVudCApO1xyXG5cdCAgaWYgKCBzdHlsZS5wb3NpdGlvbiAhPSAncmVsYXRpdmUnICYmIHN0eWxlLnBvc2l0aW9uICE9ICdhYnNvbHV0ZScgKSB7XHJcblx0ICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0ICB9XHJcblx0XHJcblx0ICB0aGlzLmVuYWJsZSgpO1xyXG5cdCAgdGhpcy5zZXRIYW5kbGVzKCk7XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBzZXQgdGhpcy5oYW5kbGVzIGFuZCBiaW5kIHN0YXJ0IGV2ZW50cyB0byAnZW1cclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuc2V0SGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5oYW5kbGVzID0gdGhpcy5vcHRpb25zLmhhbmRsZSA/XHJcblx0ICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCB0aGlzLm9wdGlvbnMuaGFuZGxlICkgOiBbIHRoaXMuZWxlbWVudCBdO1xyXG5cdFxyXG5cdCAgdGhpcy5iaW5kSGFuZGxlcygpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogZW1pdHMgZXZlbnRzIHZpYSBldmVudEVtaXR0ZXIgYW5kIGpRdWVyeSBldmVudHNcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIG5hbWUgb2YgZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIG9yaWdpbmFsIGV2ZW50XHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJncyAtIGV4dHJhIGFyZ3VtZW50c1xyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xyXG5cdCAgdmFyIGVtaXRBcmdzID0gWyBldmVudCBdLmNvbmNhdCggYXJncyApO1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XHJcblx0ICB2YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcclxuXHQgIC8vIHRyaWdnZXIgalF1ZXJ5IGV2ZW50XHJcblx0ICBpZiAoIGpRdWVyeSAmJiB0aGlzLiRlbGVtZW50ICkge1xyXG5cdCAgICBpZiAoIGV2ZW50ICkge1xyXG5cdCAgICAgIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcclxuXHQgICAgICB2YXIgJGV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xyXG5cdCAgICAgICRldmVudC50eXBlID0gdHlwZTtcclxuXHQgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwgYXJncyApO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIC8vIGp1c3QgdHJpZ2dlciB3aXRoIHR5cGUgaWYgbm8gZXZlbnQgYXZhaWxhYmxlXHJcblx0ICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCB0eXBlLCBhcmdzICk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHBvc2l0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZ2V0IGxlZnQvdG9wIHBvc2l0aW9uIGZyb20gc3R5bGVcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0ICAvLyBwcm9wZXJ0aWVzXHJcblx0ICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggdGhpcy5lbGVtZW50ICk7XHJcblx0XHJcblx0ICB2YXIgeCA9IHBhcnNlSW50KCBzdHlsZS5sZWZ0LCAxMCApO1xyXG5cdCAgdmFyIHkgPSBwYXJzZUludCggc3R5bGUudG9wLCAxMCApO1xyXG5cdFxyXG5cdCAgLy8gY2xlYW4gdXAgJ2F1dG8nIG9yIG90aGVyIG5vbi1pbnRlZ2VyIHZhbHVlc1xyXG5cdCAgdGhpcy5wb3NpdGlvbi54ID0gaXNOYU4oIHggKSA/IDAgOiB4O1xyXG5cdCAgdGhpcy5wb3NpdGlvbi55ID0gaXNOYU4oIHkgKSA/IDAgOiB5O1xyXG5cdFxyXG5cdCAgdGhpcy5fYWRkVHJhbnNmb3JtUG9zaXRpb24oIHN0eWxlICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBhZGQgdHJhbnNmb3JtOiB0cmFuc2xhdGUoIHgsIHkgKSB0byBwb3NpdGlvblxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5fYWRkVHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiggc3R5bGUgKSB7XHJcblx0ICBpZiAoICF0cmFuc2Zvcm1Qcm9wZXJ0eSApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlWyB0cmFuc2Zvcm1Qcm9wZXJ0eSBdO1xyXG5cdCAgLy8gYmFpbCBvdXQgaWYgdmFsdWUgaXMgJ25vbmUnXHJcblx0ICBpZiAoIHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgnKSAhPT0gMCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgLy8gc3BsaXQgbWF0cml4KDEsIDAsIDAsIDEsIHgsIHkpXHJcblx0ICB2YXIgbWF0cml4VmFsdWVzID0gdHJhbnNmb3JtLnNwbGl0KCcsJyk7XHJcblx0ICAvLyB0cmFuc2xhdGUgWCB2YWx1ZSBpcyBpbiAxMnRoIG9yIDR0aCBwb3NpdGlvblxyXG5cdCAgdmFyIHhJbmRleCA9IHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgzZCcpID09PSAwID8gMTIgOiA0O1xyXG5cdCAgdmFyIHRyYW5zbGF0ZVggPSBwYXJzZUludCggbWF0cml4VmFsdWVzWyB4SW5kZXggXSwgMTAgKTtcclxuXHQgIC8vIHRyYW5zbGF0ZSBZIHZhbHVlIGlzIGluIDEzdGggb3IgNXRoIHBvc2l0aW9uXHJcblx0ICB2YXIgdHJhbnNsYXRlWSA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCArIDEgXSwgMTAgKTtcclxuXHQgIHRoaXMucG9zaXRpb24ueCArPSB0cmFuc2xhdGVYO1xyXG5cdCAgdGhpcy5wb3NpdGlvbi55ICs9IHRyYW5zbGF0ZVk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBldmVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHQvKipcclxuXHQgKiBwb2ludGVyIHN0YXJ0XHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgLy8ga2x1ZGdlIHRvIGJsdXIgZm9jdXNlZCBpbnB1dHMgaW4gZHJhZ2dlclxyXG5cdCAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdCAgaWYgKCBmb2N1c2VkICYmIGZvY3VzZWQuYmx1ciApIHtcclxuXHQgICAgZm9jdXNlZC5ibHVyKCk7XHJcblx0ICB9XHJcblx0ICAvLyBiaW5kIG1vdmUgYW5kIGVuZCBldmVudHNcclxuXHQgIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XHJcblx0ICBjbGFzc2llLmFkZCggdGhpcy5lbGVtZW50LCAnaXMtcG9pbnRlci1kb3duJyApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAncG9pbnRlckRvd24nLCBldmVudCwgWyBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgbW92ZVxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHZhciBtb3ZlVmVjdG9yID0gdGhpcy5fZHJhZ1BvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAncG9pbnRlck1vdmUnLCBldmVudCwgWyBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHQgIHRoaXMuX2RyYWdNb3ZlKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogZHJhZyBzdGFydFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcclxuXHQgIHRoaXMubWVhc3VyZUNvbnRhaW5tZW50KCk7XHJcblx0ICAvLyBwb3NpdGlvbiBfd2hlbl8gZHJhZyBiZWdhblxyXG5cdCAgdGhpcy5zdGFydFBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLng7XHJcblx0ICB0aGlzLnN0YXJ0UG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ueTtcclxuXHQgIC8vIHJlc2V0IGxlZnQvdG9wIHN0eWxlXHJcblx0ICB0aGlzLnNldExlZnRUb3AoKTtcclxuXHRcclxuXHQgIHRoaXMuZHJhZ1BvaW50LnggPSAwO1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQueSA9IDA7XHJcblx0XHJcblx0ICAvLyByZXNldCBpc0RyYWdnaW5nIGZsYWdcclxuXHQgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcblx0ICBjbGFzc2llLmFkZCggdGhpcy5lbGVtZW50LCAnaXMtZHJhZ2dpbmcnICk7XHJcblx0ICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnU3RhcnQnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcclxuXHQgIC8vIHN0YXJ0IGFuaW1hdGlvblxyXG5cdCAgdGhpcy5hbmltYXRlKCk7XHJcblx0fTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUubWVhc3VyZUNvbnRhaW5tZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0ICB2YXIgY29udGFpbm1lbnQgPSB0aGlzLm9wdGlvbnMuY29udGFpbm1lbnQ7XHJcblx0ICBpZiAoICFjb250YWlubWVudCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5zaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XHJcblx0ICB2YXIgZWxlbVJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHJcblx0ICAvLyB1c2UgZWxlbWVudCBpZiBlbGVtZW50XHJcblx0ICB2YXIgY29udGFpbmVyID0gaXNFbGVtZW50KCBjb250YWlubWVudCApID8gY29udGFpbm1lbnQgOlxyXG5cdCAgICAvLyBmYWxsYmFjayB0byBxdWVyeVNlbGVjdG9yIGlmIHN0cmluZ1xyXG5cdCAgICB0eXBlb2YgY29udGFpbm1lbnQgPT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBjb250YWlubWVudCApIDpcclxuXHQgICAgLy8gb3RoZXJ3aXNlIGp1c3QgYHRydWVgLCB1c2UgdGhlIHBhcmVudFxyXG5cdCAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHRcclxuXHQgIHRoaXMuY29udGFpbmVyU2l6ZSA9IGdldFNpemUoIGNvbnRhaW5lciApO1xyXG5cdCAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHJcblx0ICB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvbiA9IHtcclxuXHQgICAgeDogZWxlbVJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCxcclxuXHQgICAgeTogZWxlbVJlY3QudG9wICAtIGNvbnRhaW5lclJlY3QudG9wXHJcblx0ICB9O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbW92ZSBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgbW92ZVxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcclxuXHQgIGlmICggIXRoaXMuaXNFbmFibGVkICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0ICB2YXIgZHJhZ1ggPSBtb3ZlVmVjdG9yLng7XHJcblx0ICB2YXIgZHJhZ1kgPSBtb3ZlVmVjdG9yLnk7XHJcblx0XHJcblx0ICB2YXIgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xyXG5cdCAgdmFyIGdyaWRYID0gZ3JpZCAmJiBncmlkWzBdO1xyXG5cdCAgdmFyIGdyaWRZID0gZ3JpZCAmJiBncmlkWzFdO1xyXG5cdFxyXG5cdCAgZHJhZ1ggPSBhcHBseUdyaWQoIGRyYWdYLCBncmlkWCApO1xyXG5cdCAgZHJhZ1kgPSBhcHBseUdyaWQoIGRyYWdZLCBncmlkWSApO1xyXG5cdFxyXG5cdCAgZHJhZ1ggPSB0aGlzLmNvbnRhaW5EcmFnKCAneCcsIGRyYWdYLCBncmlkWCApO1xyXG5cdCAgZHJhZ1kgPSB0aGlzLmNvbnRhaW5EcmFnKCAneScsIGRyYWdZLCBncmlkWSApO1xyXG5cdFxyXG5cdCAgLy8gY29uc3RyYWluIHRvIGF4aXNcclxuXHQgIGRyYWdYID0gdGhpcy5vcHRpb25zLmF4aXMgPT0gJ3knID8gMCA6IGRyYWdYO1xyXG5cdCAgZHJhZ1kgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PSAneCcgPyAwIDogZHJhZ1k7XHJcblx0XHJcblx0ICB0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnN0YXJ0UG9zaXRpb24ueCArIGRyYWdYO1xyXG5cdCAgdGhpcy5wb3NpdGlvbi55ID0gdGhpcy5zdGFydFBvc2l0aW9uLnkgKyBkcmFnWTtcclxuXHQgIC8vIHNldCBkcmFnUG9pbnQgcHJvcGVydGllc1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQueCA9IGRyYWdYO1xyXG5cdCAgdGhpcy5kcmFnUG9pbnQueSA9IGRyYWdZO1xyXG5cdFxyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ01vdmUnLCBldmVudCwgWyBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGFwcGx5R3JpZCggdmFsdWUsIGdyaWQsIG1ldGhvZCApIHtcclxuXHQgIG1ldGhvZCA9IG1ldGhvZCB8fCAncm91bmQnO1xyXG5cdCAgcmV0dXJuIGdyaWQgPyBNYXRoWyBtZXRob2QgXSggdmFsdWUgLyBncmlkICkgKiBncmlkIDogdmFsdWU7XHJcblx0fVxyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5jb250YWluRHJhZyA9IGZ1bmN0aW9uKCBheGlzLCBkcmFnLCBncmlkICkge1xyXG5cdCAgaWYgKCAhdGhpcy5vcHRpb25zLmNvbnRhaW5tZW50ICkge1xyXG5cdCAgICByZXR1cm4gZHJhZztcclxuXHQgIH1cclxuXHQgIHZhciBtZWFzdXJlID0gYXhpcyA9PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XHJcblx0XHJcblx0ICB2YXIgcmVsID0gdGhpcy5yZWxhdGl2ZVN0YXJ0UG9zaXRpb25bIGF4aXMgXTtcclxuXHQgIHZhciBtaW4gPSBhcHBseUdyaWQoIC1yZWwsIGdyaWQsICdjZWlsJyApO1xyXG5cdCAgdmFyIG1heCA9IHRoaXMuY29udGFpbmVyU2l6ZVsgbWVhc3VyZSBdIC0gcmVsIC0gdGhpcy5zaXplWyBtZWFzdXJlIF07XHJcblx0ICBtYXggPSBhcHBseUdyaWQoIG1heCwgZ3JpZCwgJ2Zsb29yJyApO1xyXG5cdCAgcmV0dXJuICBNYXRoLm1pbiggbWF4LCBNYXRoLm1heCggbWluLCBkcmFnICkgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgdXBcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUucG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgY2xhc3NpZS5yZW1vdmUoIHRoaXMuZWxlbWVudCwgJ2lzLXBvaW50ZXItZG93bicgKTtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3BvaW50ZXJVcCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgZW5kXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcblx0ICAvLyB1c2UgdG9wIGxlZnQgcG9zaXRpb24gd2hlbiBjb21wbGV0ZVxyXG5cdCAgaWYgKCB0cmFuc2Zvcm1Qcm9wZXJ0eSApIHtcclxuXHQgICAgdGhpcy5lbGVtZW50LnN0eWxlWyB0cmFuc2Zvcm1Qcm9wZXJ0eSBdID0gJyc7XHJcblx0ICAgIHRoaXMuc2V0TGVmdFRvcCgpO1xyXG5cdCAgfVxyXG5cdCAgY2xhc3NpZS5yZW1vdmUoIHRoaXMuZWxlbWVudCwgJ2lzLWRyYWdnaW5nJyApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ0VuZCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYW5pbWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbigpIHtcclxuXHQgIC8vIG9ubHkgcmVuZGVyIGFuZCBhbmltYXRlIGlmIGRyYWdnaW5nXHJcblx0ICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHRcclxuXHQgIHRoaXMucG9zaXRpb25EcmFnKCk7XHJcblx0XHJcblx0ICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdCAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbiBhbmltYXRlRnJhbWUoKSB7XHJcblx0ICAgIF90aGlzLmFuaW1hdGUoKTtcclxuXHQgIH0pO1xyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0Ly8gdHJhbnNmb3JtIHRyYW5zbGF0ZSBmdW5jdGlvblxyXG5cdHZhciB0cmFuc2xhdGUgPSBpczNkID9cclxuXHQgIGZ1bmN0aW9uKCB4LCB5ICkge1xyXG5cdCAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCAnICsgeCArICdweCwgJyArIHkgKyAncHgsIDApJztcclxuXHQgIH0gOlxyXG5cdCAgZnVuY3Rpb24oIHgsIHkgKSB7XHJcblx0ICAgIHJldHVybiAndHJhbnNsYXRlKCAnICsgeCArICdweCwgJyArIHkgKyAncHgpJztcclxuXHQgIH07XHJcblx0XHJcblx0Ly8gbGVmdC90b3AgcG9zaXRpb25pbmdcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuc2V0TGVmdFRvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLnggKyAncHgnO1xyXG5cdCAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCAgPSB0aGlzLnBvc2l0aW9uLnkgKyAncHgnO1xyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnBvc2l0aW9uRHJhZyA9IHRyYW5zZm9ybVByb3BlcnR5ID9cclxuXHQgIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAvLyBwb3NpdGlvbiB3aXRoIHRyYW5zZm9ybVxyXG5cdCAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIHRyYW5zZm9ybVByb3BlcnR5IF0gPSB0cmFuc2xhdGUoIHRoaXMuZHJhZ1BvaW50LngsIHRoaXMuZHJhZ1BvaW50LnkgKTtcclxuXHQgIH0gOiBEcmFnZ2FiaWxseS5wcm90b3R5cGUuc2V0TGVmdFRvcDtcclxuXHRcclxuXHQvLyAtLS0tLSBzdGF0aWNDbGljayAtLS0tLSAvL1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5zdGF0aWNDbGljayA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3N0YXRpY0NsaWNrJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBtZXRob2RzIC0tLS0tIC8vXHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XHJcblx0ICBpZiAoIHRoaXMuaXNEcmFnZ2luZyApIHtcclxuXHQgICAgdGhpcy5kcmFnRW5kKCk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5kaXNhYmxlKCk7XHJcblx0ICAvLyByZXNldCBzdHlsZXNcclxuXHQgIGlmICggdHJhbnNmb3JtUHJvcGVydHkgKSB7XHJcblx0ICAgIHRoaXMuZWxlbWVudC5zdHlsZVsgdHJhbnNmb3JtUHJvcGVydHkgXSA9ICcnO1xyXG5cdCAgfVxyXG5cdCAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAnJztcclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAnJztcclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICcnO1xyXG5cdCAgLy8gdW5iaW5kIGhhbmRsZXNcclxuXHQgIHRoaXMudW5iaW5kSGFuZGxlcygpO1xyXG5cdCAgLy8gcmVtb3ZlIGpRdWVyeSBkYXRhXHJcblx0ICBpZiAoIHRoaXMuJGVsZW1lbnQgKSB7XHJcblx0ICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZHJhZ2dhYmlsbHknKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIGpRdWVyeSBicmlkZ2V0IC0tLS0tIC8vXHJcblx0XHJcblx0Ly8gcmVxdWlyZWQgZm9yIGpRdWVyeSBicmlkZ2V0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLl9pbml0ID0gbm9vcDtcclxuXHRcclxuXHRpZiAoIGpRdWVyeSAmJiBqUXVlcnkuYnJpZGdldCApIHtcclxuXHQgIGpRdWVyeS5icmlkZ2V0KCAnZHJhZ2dhYmlsbHknLCBEcmFnZ2FiaWxseSApO1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLSAgLS0tLS0gLy9cclxuXHRcclxuXHRyZXR1cm4gRHJhZ2dhYmlsbHk7XHJcblx0XHJcblx0fSkpO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogY2xhc3NpZSB2MS4wLjFcclxuXHQgKiBjbGFzcyBoZWxwZXIgZnVuY3Rpb25zXHJcblx0ICogZnJvbSBib256byBodHRwczovL2dpdGh1Yi5jb20vZGVkL2JvbnpvXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKiBcclxuXHQgKiBjbGFzc2llLmhhcyggZWxlbSwgJ215LWNsYXNzJyApIC0+IHRydWUvZmFsc2VcclxuXHQgKiBjbGFzc2llLmFkZCggZWxlbSwgJ215LW5ldy1jbGFzcycgKVxyXG5cdCAqIGNsYXNzaWUucmVtb3ZlKCBlbGVtLCAnbXktdW53YW50ZWQtY2xhc3MnIClcclxuXHQgKiBjbGFzc2llLnRvZ2dsZSggZWxlbSwgJ215LWNsYXNzJyApXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdyApIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0Ly8gY2xhc3MgaGVscGVyIGZ1bmN0aW9ucyBmcm9tIGJvbnpvIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm9uem9cclxuXHRcclxuXHRmdW5jdGlvbiBjbGFzc1JlZyggY2xhc3NOYW1lICkge1xyXG5cdCAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIgKyBjbGFzc05hbWUgKyBcIihcXFxccyt8JClcIik7XHJcblx0fVxyXG5cdFxyXG5cdC8vIGNsYXNzTGlzdCBzdXBwb3J0IGZvciBjbGFzcyBtYW5hZ2VtZW50XHJcblx0Ly8gYWx0aG8gdG8gYmUgZmFpciwgdGhlIGFwaSBzdWNrcyBiZWNhdXNlIGl0IHdvbid0IGFjY2VwdCBtdWx0aXBsZSBjbGFzc2VzIGF0IG9uY2VcclxuXHR2YXIgaGFzQ2xhc3MsIGFkZENsYXNzLCByZW1vdmVDbGFzcztcclxuXHRcclxuXHRpZiAoICdjbGFzc0xpc3QnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcclxuXHQgIGhhc0NsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyggYyApO1xyXG5cdCAgfTtcclxuXHQgIGFkZENsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIGVsZW0uY2xhc3NMaXN0LmFkZCggYyApO1xyXG5cdCAgfTtcclxuXHQgIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSggYyApO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0ICBoYXNDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICByZXR1cm4gY2xhc3NSZWcoIGMgKS50ZXN0KCBlbGVtLmNsYXNzTmFtZSApO1xyXG5cdCAgfTtcclxuXHQgIGFkZENsYXNzID0gZnVuY3Rpb24oIGVsZW0sIGMgKSB7XHJcblx0ICAgIGlmICggIWhhc0NsYXNzKCBlbGVtLCBjICkgKSB7XHJcblx0ICAgICAgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZSArICcgJyArIGM7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblx0ICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICBlbGVtLmNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLnJlcGxhY2UoIGNsYXNzUmVnKCBjICksICcgJyApO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoIGVsZW0sIGMgKSB7XHJcblx0ICB2YXIgZm4gPSBoYXNDbGFzcyggZWxlbSwgYyApID8gcmVtb3ZlQ2xhc3MgOiBhZGRDbGFzcztcclxuXHQgIGZuKCBlbGVtLCBjICk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBjbGFzc2llID0ge1xyXG5cdCAgLy8gZnVsbCBuYW1lc1xyXG5cdCAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxyXG5cdCAgYWRkQ2xhc3M6IGFkZENsYXNzLFxyXG5cdCAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxyXG5cdCAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxyXG5cdCAgLy8gc2hvcnQgbmFtZXNcclxuXHQgIGhhczogaGFzQ2xhc3MsXHJcblx0ICBhZGQ6IGFkZENsYXNzLFxyXG5cdCAgcmVtb3ZlOiByZW1vdmVDbGFzcyxcclxuXHQgIHRvZ2dsZTogdG9nZ2xlQ2xhc3NcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHRyYW5zcG9ydFxyXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgLy8gQU1EXHJcblx0ICBkZWZpbmUoIGNsYXNzaWUgKTtcclxuXHR9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgLy8gQ29tbW9uSlNcclxuXHQgIG1vZHVsZS5leHBvcnRzID0gY2xhc3NpZTtcclxuXHR9IGVsc2Uge1xyXG5cdCAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgIHdpbmRvdy5jbGFzc2llID0gY2xhc3NpZTtcclxuXHR9XHJcblx0XHJcblx0fSkoIHdpbmRvdyApO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogZ2V0U3R5bGVQcm9wZXJ0eSB2MS4wLjRcclxuXHQgKiBvcmlnaW5hbCBieSBrYW5nYXhcclxuXHQgKiBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9mZWF0dXJlLXRlc3RpbmctY3NzLXByb3BlcnRpZXMvXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKi9cclxuXHRcclxuXHQvKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgZXhwb3J0czogZmFsc2UsIG1vZHVsZTogZmFsc2UgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdHZhciBwcmVmaXhlcyA9ICdXZWJraXQgTW96IG1zIE1zIE8nLnNwbGl0KCcgJyk7XHJcblx0dmFyIGRvY0VsZW1TdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcclxuXHRmdW5jdGlvbiBnZXRTdHlsZVByb3BlcnR5KCBwcm9wTmFtZSApIHtcclxuXHQgIGlmICggIXByb3BOYW1lICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyB0ZXN0IHN0YW5kYXJkIHByb3BlcnR5IGZpcnN0XHJcblx0ICBpZiAoIHR5cGVvZiBkb2NFbGVtU3R5bGVbIHByb3BOYW1lIF0gPT09ICdzdHJpbmcnICkge1xyXG5cdCAgICByZXR1cm4gcHJvcE5hbWU7XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyBjYXBpdGFsaXplXHJcblx0ICBwcm9wTmFtZSA9IHByb3BOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcE5hbWUuc2xpY2UoMSk7XHJcblx0XHJcblx0ICAvLyB0ZXN0IHZlbmRvciBzcGVjaWZpYyBwcm9wZXJ0aWVzXHJcblx0ICB2YXIgcHJlZml4ZWQ7XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBwcmVmaXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHByb3BOYW1lO1xyXG5cdCAgICBpZiAoIHR5cGVvZiBkb2NFbGVtU3R5bGVbIHByZWZpeGVkIF0gPT09ICdzdHJpbmcnICkge1xyXG5cdCAgICAgIHJldHVybiBwcmVmaXhlZDtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHQvLyB0cmFuc3BvcnRcclxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHQgIC8vIEFNRFxyXG5cdCAgZGVmaW5lKCBmdW5jdGlvbigpIHtcclxuXHQgICAgcmV0dXJuIGdldFN0eWxlUHJvcGVydHk7XHJcblx0ICB9KTtcclxuXHR9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgLy8gQ29tbW9uSlMgZm9yIENvbXBvbmVudFxyXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBnZXRTdHlsZVByb3BlcnR5O1xyXG5cdH0gZWxzZSB7XHJcblx0ICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgd2luZG93LmdldFN0eWxlUHJvcGVydHkgPSBnZXRTdHlsZVByb3BlcnR5O1xyXG5cdH1cclxuXHRcclxuXHR9KSggd2luZG93ICk7XHJcblx0XHJcblx0fS5jYWxsKHdpbmRvdykpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTc4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXHJcblx0dmFyIGRlZmluZSA9IGZhbHNlO1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvKiFcclxuXHQgKiBnZXRTaXplIHYxLjIuMlxyXG5cdCAqIG1lYXN1cmUgc2l6ZSBvZiBlbGVtZW50c1xyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgZXhwb3J0czogZmFsc2UsIHJlcXVpcmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdywgdW5kZWZpbmVkICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZ2V0IGEgbnVtYmVyIGZyb20gYSBzdHJpbmcsIG5vdCBhIHBlcmNlbnRhZ2VcclxuXHRmdW5jdGlvbiBnZXRTdHlsZVNpemUoIHZhbHVlICkge1xyXG5cdCAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XHJcblx0ICAvLyBub3QgYSBwZXJjZW50IGxpa2UgJzEwMCUnLCBhbmQgYSBudW1iZXJcclxuXHQgIHZhciBpc1ZhbGlkID0gdmFsdWUuaW5kZXhPZignJScpID09PSAtMSAmJiAhaXNOYU4oIG51bSApO1xyXG5cdCAgcmV0dXJuIGlzVmFsaWQgJiYgbnVtO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRcclxuXHR2YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcgPyBub29wIDpcclxuXHQgIGZ1bmN0aW9uKCBtZXNzYWdlICkge1xyXG5cdCAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XHJcblx0ICB9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1lYXN1cmVtZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdHZhciBtZWFzdXJlbWVudHMgPSBbXHJcblx0ICAncGFkZGluZ0xlZnQnLFxyXG5cdCAgJ3BhZGRpbmdSaWdodCcsXHJcblx0ICAncGFkZGluZ1RvcCcsXHJcblx0ICAncGFkZGluZ0JvdHRvbScsXHJcblx0ICAnbWFyZ2luTGVmdCcsXHJcblx0ICAnbWFyZ2luUmlnaHQnLFxyXG5cdCAgJ21hcmdpblRvcCcsXHJcblx0ICAnbWFyZ2luQm90dG9tJyxcclxuXHQgICdib3JkZXJMZWZ0V2lkdGgnLFxyXG5cdCAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxyXG5cdCAgJ2JvcmRlclRvcFdpZHRoJyxcclxuXHQgICdib3JkZXJCb3R0b21XaWR0aCdcclxuXHRdO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldFplcm9TaXplKCkge1xyXG5cdCAgdmFyIHNpemUgPSB7XHJcblx0ICAgIHdpZHRoOiAwLFxyXG5cdCAgICBoZWlnaHQ6IDAsXHJcblx0ICAgIGlubmVyV2lkdGg6IDAsXHJcblx0ICAgIGlubmVySGVpZ2h0OiAwLFxyXG5cdCAgICBvdXRlcldpZHRoOiAwLFxyXG5cdCAgICBvdXRlckhlaWdodDogMFxyXG5cdCAgfTtcclxuXHQgIGZvciAoIHZhciBpPTAsIGxlbiA9IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xyXG5cdCAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gMDtcclxuXHQgIH1cclxuXHQgIHJldHVybiBzaXplO1xyXG5cdH1cclxuXHRcclxuXHRcclxuXHRcclxuXHRmdW5jdGlvbiBkZWZpbmVHZXRTaXplKCBnZXRTdHlsZVByb3BlcnR5ICkge1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0dmFyIGlzU2V0dXAgPSBmYWxzZTtcclxuXHRcclxuXHR2YXIgZ2V0U3R5bGUsIGJveFNpemluZ1Byb3AsIGlzQm94U2l6ZU91dGVyO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHNldHVwIHZhcnMgYW5kIGZ1bmN0aW9uc1xyXG5cdCAqIGRvIGl0IG9uIGluaXRpYWwgZ2V0U2l6ZSgpLCByYXRoZXIgdGhhbiBvbiBzY3JpcHQgbG9hZFxyXG5cdCAqIEZvciBGaXJlZm94IGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBzZXR1cCgpIHtcclxuXHQgIC8vIHNldHVwIG9uY2VcclxuXHQgIGlmICggaXNTZXR1cCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgaXNTZXR1cCA9IHRydWU7XHJcblx0XHJcblx0ICB2YXIgZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlO1xyXG5cdCAgZ2V0U3R5bGUgPSAoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICB2YXIgZ2V0U3R5bGVGbiA9IGdldENvbXB1dGVkU3R5bGUgP1xyXG5cdCAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcclxuXHQgICAgICB9IDpcclxuXHQgICAgICBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgICAgICAgIHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZTtcclxuXHQgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRTdHlsZSggZWxlbSApIHtcclxuXHQgICAgICAgIHZhciBzdHlsZSA9IGdldFN0eWxlRm4oIGVsZW0gKTtcclxuXHQgICAgICAgIGlmICggIXN0eWxlICkge1xyXG5cdCAgICAgICAgICBsb2dFcnJvciggJ1N0eWxlIHJldHVybmVkICcgKyBzdHlsZSArXHJcblx0ICAgICAgICAgICAgJy4gQXJlIHlvdSBydW5uaW5nIHRoaXMgY29kZSBpbiBhIGhpZGRlbiBpZnJhbWUgb24gRmlyZWZveD8gJyArXHJcblx0ICAgICAgICAgICAgJ1NlZSBodHRwOi8vYml0Lmx5L2dldHNpemVidWcxJyApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG5cdCAgICAgIH07XHJcblx0ICB9KSgpO1xyXG5cdFxyXG5cdCAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYm94IHNpemluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdCAgYm94U2l6aW5nUHJvcCA9IGdldFN0eWxlUHJvcGVydHkoJ2JveFNpemluZycpO1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBXZWJLaXQgbWVhc3VyZXMgdGhlIG91dGVyLXdpZHRoIG9uIHN0eWxlLndpZHRoIG9uIGJvcmRlci1ib3ggZWxlbXNcclxuXHQgICAqIElFICYgRmlyZWZveCBtZWFzdXJlcyB0aGUgaW5uZXItd2lkdGhcclxuXHQgICAqL1xyXG5cdCAgaWYgKCBib3hTaXppbmdQcm9wICkge1xyXG5cdCAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgIGRpdi5zdHlsZS53aWR0aCA9ICcyMDBweCc7XHJcblx0ICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gJzFweCAycHggM3B4IDRweCc7XHJcblx0ICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XHJcblx0ICAgIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHggMnB4IDNweCA0cHgnO1xyXG5cdCAgICBkaXYuc3R5bGVbIGJveFNpemluZ1Byb3AgXSA9ICdib3JkZXItYm94JztcclxuXHRcclxuXHQgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHQgICAgYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XHJcblx0ICAgIHZhciBzdHlsZSA9IGdldFN0eWxlKCBkaXYgKTtcclxuXHRcclxuXHQgICAgaXNCb3hTaXplT3V0ZXIgPSBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICkgPT09IDIwMDtcclxuXHQgICAgYm9keS5yZW1vdmVDaGlsZCggZGl2ICk7XHJcblx0ICB9XHJcblx0XHJcblx0fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHRmdW5jdGlvbiBnZXRTaXplKCBlbGVtICkge1xyXG5cdCAgc2V0dXAoKTtcclxuXHRcclxuXHQgIC8vIHVzZSBxdWVyeVNlbGV0b3IgaWYgZWxlbSBpcyBzdHJpbmdcclxuXHQgIGlmICggdHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnICkge1xyXG5cdCAgICBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbSApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gZG8gbm90IHByb2NlZWQgb24gbm9uLW9iamVjdHNcclxuXHQgIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT09ICdvYmplY3QnIHx8ICFlbGVtLm5vZGVUeXBlICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZWxlbSApO1xyXG5cdFxyXG5cdCAgLy8gaWYgaGlkZGVuLCBldmVyeXRoaW5nIGlzIDBcclxuXHQgIGlmICggc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnICkge1xyXG5cdCAgICByZXR1cm4gZ2V0WmVyb1NpemUoKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBzaXplID0ge307XHJcblx0ICBzaXplLndpZHRoID0gZWxlbS5vZmZzZXRXaWR0aDtcclxuXHQgIHNpemUuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XHJcblx0XHJcblx0ICB2YXIgaXNCb3JkZXJCb3ggPSBzaXplLmlzQm9yZGVyQm94ID0gISEoIGJveFNpemluZ1Byb3AgJiZcclxuXHQgICAgc3R5bGVbIGJveFNpemluZ1Byb3AgXSAmJiBzdHlsZVsgYm94U2l6aW5nUHJvcCBdID09PSAnYm9yZGVyLWJveCcgKTtcclxuXHRcclxuXHQgIC8vIGdldCBhbGwgbWVhc3VyZW1lbnRzXHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBtZWFzdXJlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0ICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcclxuXHQgICAgdmFyIHZhbHVlID0gc3R5bGVbIG1lYXN1cmVtZW50IF07XHJcblx0ICAgIHZhbHVlID0gbXVuZ2VOb25QaXhlbCggZWxlbSwgdmFsdWUgKTtcclxuXHQgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XHJcblx0ICAgIC8vIGFueSAnYXV0bycsICdtZWRpdW0nIHZhbHVlIHdpbGwgYmUgMFxyXG5cdCAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gIWlzTmFOKCBudW0gKSA/IG51bSA6IDA7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgcGFkZGluZ1dpZHRoID0gc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUucGFkZGluZ1JpZ2h0O1xyXG5cdCAgdmFyIHBhZGRpbmdIZWlnaHQgPSBzaXplLnBhZGRpbmdUb3AgKyBzaXplLnBhZGRpbmdCb3R0b207XHJcblx0ICB2YXIgbWFyZ2luV2lkdGggPSBzaXplLm1hcmdpbkxlZnQgKyBzaXplLm1hcmdpblJpZ2h0O1xyXG5cdCAgdmFyIG1hcmdpbkhlaWdodCA9IHNpemUubWFyZ2luVG9wICsgc2l6ZS5tYXJnaW5Cb3R0b207XHJcblx0ICB2YXIgYm9yZGVyV2lkdGggPSBzaXplLmJvcmRlckxlZnRXaWR0aCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aDtcclxuXHQgIHZhciBib3JkZXJIZWlnaHQgPSBzaXplLmJvcmRlclRvcFdpZHRoICsgc2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcclxuXHRcclxuXHQgIHZhciBpc0JvcmRlckJveFNpemVPdXRlciA9IGlzQm9yZGVyQm94ICYmIGlzQm94U2l6ZU91dGVyO1xyXG5cdFxyXG5cdCAgLy8gb3ZlcndyaXRlIHdpZHRoIGFuZCBoZWlnaHQgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHN0eWxlXHJcblx0ICB2YXIgc3R5bGVXaWR0aCA9IGdldFN0eWxlU2l6ZSggc3R5bGUud2lkdGggKTtcclxuXHQgIGlmICggc3R5bGVXaWR0aCAhPT0gZmFsc2UgKSB7XHJcblx0ICAgIHNpemUud2lkdGggPSBzdHlsZVdpZHRoICtcclxuXHQgICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XHJcblx0ICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIHN0eWxlSGVpZ2h0ID0gZ2V0U3R5bGVTaXplKCBzdHlsZS5oZWlnaHQgKTtcclxuXHQgIGlmICggc3R5bGVIZWlnaHQgIT09IGZhbHNlICkge1xyXG5cdCAgICBzaXplLmhlaWdodCA9IHN0eWxlSGVpZ2h0ICtcclxuXHQgICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XHJcblx0ICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBzaXplLmlubmVyV2lkdGggPSBzaXplLndpZHRoIC0gKCBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xyXG5cdCAgc2l6ZS5pbm5lckhlaWdodCA9IHNpemUuaGVpZ2h0IC0gKCBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XHJcblx0XHJcblx0ICBzaXplLm91dGVyV2lkdGggPSBzaXplLndpZHRoICsgbWFyZ2luV2lkdGg7XHJcblx0ICBzaXplLm91dGVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyBtYXJnaW5IZWlnaHQ7XHJcblx0XHJcblx0ICByZXR1cm4gc2l6ZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gSUU4IHJldHVybnMgcGVyY2VudCB2YWx1ZXMsIG5vdCBwaXhlbHNcclxuXHQvLyB0YWtlbiBmcm9tIGpRdWVyeSdzIGN1ckNTU1xyXG5cdGZ1bmN0aW9uIG11bmdlTm9uUGl4ZWwoIGVsZW0sIHZhbHVlICkge1xyXG5cdCAgLy8gSUU4IGFuZCBoYXMgcGVyY2VudCB2YWx1ZVxyXG5cdCAgaWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCB2YWx1ZS5pbmRleE9mKCclJykgPT09IC0xICkge1xyXG5cdCAgICByZXR1cm4gdmFsdWU7XHJcblx0ICB9XHJcblx0ICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xyXG5cdCAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xyXG5cdCAgdmFyIGxlZnQgPSBzdHlsZS5sZWZ0O1xyXG5cdCAgdmFyIHJzID0gZWxlbS5ydW50aW1lU3R5bGU7XHJcblx0ICB2YXIgcnNMZWZ0ID0gcnMgJiYgcnMubGVmdDtcclxuXHRcclxuXHQgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcclxuXHQgIGlmICggcnNMZWZ0ICkge1xyXG5cdCAgICBycy5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcclxuXHQgIH1cclxuXHQgIHN0eWxlLmxlZnQgPSB2YWx1ZTtcclxuXHQgIHZhbHVlID0gc3R5bGUucGl4ZWxMZWZ0O1xyXG5cdFxyXG5cdCAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xyXG5cdCAgc3R5bGUubGVmdCA9IGxlZnQ7XHJcblx0ICBpZiAoIHJzTGVmdCApIHtcclxuXHQgICAgcnMubGVmdCA9IHJzTGVmdDtcclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB2YWx1ZTtcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIGdldFNpemU7XHJcblx0XHJcblx0fVxyXG5cdFxyXG5cdC8vIHRyYW5zcG9ydFxyXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgLy8gQU1EIGZvciBSZXF1aXJlSlNcclxuXHQgIGRlZmluZSggWyAnZ2V0LXN0eWxlLXByb3BlcnR5L2dldC1zdHlsZS1wcm9wZXJ0eScgXSwgZGVmaW5lR2V0U2l6ZSApO1xyXG5cdH0gZWxzZSBpZiAoIHRydWUgKSB7XHJcblx0ICAvLyBDb21tb25KUyBmb3IgQ29tcG9uZW50XHJcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluZUdldFNpemUoIF9fd2VicGFja19yZXF1aXJlX18oMTc3KSApO1xyXG5cdH0gZWxzZSB7XHJcblx0ICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgd2luZG93LmdldFNpemUgPSBkZWZpbmVHZXRTaXplKCB3aW5kb3cuZ2V0U3R5bGVQcm9wZXJ0eSApO1xyXG5cdH1cclxuXHRcclxuXHR9KSggd2luZG93ICk7XHJcblx0XHJcblx0fS5jYWxsKHdpbmRvdykpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTc5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXHJcblx0dmFyIGRlZmluZSA9IGZhbHNlO1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvKiFcclxuXHQgKiBVbmlkcmFnZ2VyIHYxLjEuNVxyXG5cdCAqIERyYWdnYWJsZSBiYXNlIGNsYXNzXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKi9cclxuXHRcclxuXHQvKmpzaGludCBicm93c2VyOiB0cnVlLCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XHJcblx0ICAvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZSAqL1xyXG5cdCAgJ3VzZSBzdHJpY3QnO1xyXG5cdCAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXHJcblx0XHJcblx0ICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgICAvLyBBTURcclxuXHQgICAgZGVmaW5lKCBbXHJcblx0ICAgICAgJ2V2ZW50aWUvZXZlbnRpZScsXHJcblx0ICAgICAgJ3VuaXBvaW50ZXIvdW5pcG9pbnRlcidcclxuXHQgICAgXSwgZnVuY3Rpb24oIGV2ZW50aWUsIFVuaXBvaW50ZXIgKSB7XHJcblx0ICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgZXZlbnRpZSwgVW5pcG9pbnRlciApO1xyXG5cdCAgICB9KTtcclxuXHQgIH0gZWxzZSBpZiAoIHRydWUgKSB7XHJcblx0ICAgIC8vIENvbW1vbkpTXHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxODApLFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTgxKVxyXG5cdCAgICApO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgICAgd2luZG93LlVuaWRyYWdnZXIgPSBmYWN0b3J5KFxyXG5cdCAgICAgIHdpbmRvdyxcclxuXHQgICAgICB3aW5kb3cuZXZlbnRpZSxcclxuXHQgICAgICB3aW5kb3cuVW5pcG9pbnRlclxyXG5cdCAgICApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBldmVudGllLCBVbmlwb2ludGVyICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHQvLyAtLS0tLSAgLS0tLS0gLy9cclxuXHRcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRcclxuXHQvLyBoYW5kbGUgSUU4IHByZXZlbnQgZGVmYXVsdFxyXG5cdGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0RXZlbnQoIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wcmV2ZW50RGVmYXVsdCApIHtcclxuXHQgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFVuaWRyYWdnZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHRmdW5jdGlvbiBVbmlkcmFnZ2VyKCkge31cclxuXHRcclxuXHQvLyBpbmhlcml0IFVuaXBvaW50ZXIgJiBFdmVudEVtaXR0ZXJcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZSA9IG5ldyBVbmlwb2ludGVyKCk7XHJcblx0XHJcblx0Ly8gLS0tLS0gYmluZCBzdGFydCAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmJpbmRIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcblx0ICB0aGlzLl9iaW5kSGFuZGxlcyggdHJ1ZSApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUudW5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5fYmluZEhhbmRsZXMoIGZhbHNlICk7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcclxuXHQvKipcclxuXHQgKiB3b3JrcyBhcyB1bmJpbmRlciwgYXMgeW91IGNhbiAuYmluZEhhbmRsZXMoIGZhbHNlICkgdG8gdW5iaW5kXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmQgLSB3aWxsIHVuYmluZCBpZiBmYWxzZXlcclxuXHQgKi9cclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5fYmluZEhhbmRsZXMgPSBmdW5jdGlvbiggaXNCaW5kICkge1xyXG5cdCAgLy8gbXVuZ2UgaXNCaW5kLCBkZWZhdWx0IHRvIHRydWVcclxuXHQgIGlzQmluZCA9IGlzQmluZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhaXNCaW5kO1xyXG5cdCAgLy8gZXh0cmEgYmluZCBsb2dpY1xyXG5cdCAgdmFyIGJpbmRlckV4dHJhO1xyXG5cdCAgaWYgKCBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIGJpbmRlckV4dHJhID0gZnVuY3Rpb24oIGhhbmRsZSApIHtcclxuXHQgICAgICAvLyBkaXNhYmxlIHNjcm9sbGluZyBvbiB0aGUgZWxlbWVudFxyXG5cdCAgICAgIGhhbmRsZS5zdHlsZS50b3VjaEFjdGlvbiA9IGlzQmluZCA/ICdub25lJyA6ICcnO1xyXG5cdCAgICB9O1xyXG5cdCAgfSBlbHNlIGlmICggbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIGJpbmRlckV4dHJhID0gZnVuY3Rpb24oIGhhbmRsZSApIHtcclxuXHQgICAgICAvLyBkaXNhYmxlIHNjcm9sbGluZyBvbiB0aGUgZWxlbWVudFxyXG5cdCAgICAgIGhhbmRsZS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gaXNCaW5kID8gJ25vbmUnIDogJyc7XHJcblx0ICAgIH07XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBiaW5kZXJFeHRyYSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgIC8vIFRPRE8gcmUtZW5hYmxlIGltZy5vbmRyYWdzdGFydCB3aGVuIHVuYmluZGluZ1xyXG5cdCAgICAgIGlmICggaXNCaW5kICkge1xyXG5cdCAgICAgICAgZGlzYWJsZUltZ09uZHJhZ3N0YXJ0KCBoYW5kbGUgKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICB9XHJcblx0ICAvLyBiaW5kIGVhY2ggaGFuZGxlXHJcblx0ICB2YXIgYmluZE1ldGhvZCA9IGlzQmluZCA/ICdiaW5kJyA6ICd1bmJpbmQnO1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgaGFuZGxlID0gdGhpcy5oYW5kbGVzW2ldO1xyXG5cdCAgICB0aGlzLl9iaW5kU3RhcnRFdmVudCggaGFuZGxlLCBpc0JpbmQgKTtcclxuXHQgICAgYmluZGVyRXh0cmEoIGhhbmRsZSApO1xyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGhhbmRsZSwgJ2NsaWNrJywgdGhpcyApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gcmVtb3ZlIGRlZmF1bHQgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb24gYWxsIGltYWdlcyBpbiBJRThcclxuXHQvLyBJRTggZG9lcyBpdHMgb3duIGRyYWcgdGhpbmcgb24gaW1hZ2VzLCB3aGljaCBtZXNzZXMgc3R1ZmYgdXBcclxuXHRcclxuXHRmdW5jdGlvbiBub0RyYWdTdGFydCgpIHtcclxuXHQgIHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gVE9ETyByZXBsYWNlIHRoaXMgd2l0aCBhIElFOCB0ZXN0XHJcblx0dmFyIGlzSUU4ID0gJ2F0dGFjaEV2ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHJcblx0Ly8gSUU4IG9ubHlcclxuXHR2YXIgZGlzYWJsZUltZ09uZHJhZ3N0YXJ0ID0gIWlzSUU4ID8gbm9vcCA6IGZ1bmN0aW9uKCBoYW5kbGUgKSB7XHJcblx0XHJcblx0ICBpZiAoIGhhbmRsZS5ub2RlTmFtZSA9PSAnSU1HJyApIHtcclxuXHQgICAgaGFuZGxlLm9uZHJhZ3N0YXJ0ID0gbm9EcmFnU3RhcnQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgaW1hZ2VzID0gaGFuZGxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpO1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gaW1hZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgaW1nID0gaW1hZ2VzW2ldO1xyXG5cdCAgICBpbWcub25kcmFnc3RhcnQgPSBub0RyYWdTdGFydDtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIHN0YXJ0IGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBzdGFydFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgLy8gZGlzbWlzcyByYW5nZSBzbGlkZXJzXHJcblx0ICBpZiAoIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PSAnSU5QVVQnICYmIGV2ZW50LnRhcmdldC50eXBlID09ICdyYW5nZScgKSB7XHJcblx0ICAgIC8vIHJlc2V0IHBvaW50ZXJEb3duIGxvZ2ljXHJcblx0ICAgIHRoaXMuaXNQb2ludGVyRG93biA9IGZhbHNlO1xyXG5cdCAgICBkZWxldGUgdGhpcy5wb2ludGVySWRlbnRpZmllcjtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgLy8ga2x1ZGdlIHRvIGJsdXIgZm9jdXNlZCBpbnB1dHMgaW4gZHJhZ2dlclxyXG5cdCAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdCAgaWYgKCBmb2N1c2VkICYmIGZvY3VzZWQuYmx1ciApIHtcclxuXHQgICAgZm9jdXNlZC5ibHVyKCk7XHJcblx0ICB9XHJcblx0ICAvLyBiaW5kIG1vdmUgYW5kIGVuZCBldmVudHNcclxuXHQgIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XHJcblx0ICAvLyB0cmFjayBzY3JvbGxpbmdcclxuXHQgIHRoaXMucG9pbnRlckRvd25TY3JvbGwgPSBVbmlkcmFnZ2VyLmdldFNjcm9sbFBvc2l0aW9uKCk7XHJcblx0ICBldmVudGllLmJpbmQoIHdpbmRvdywgJ3Njcm9sbCcsIHRoaXMgKTtcclxuXHRcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGJhc2UgcG9pbnRlciBkb3duIGxvZ2ljXHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdQb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIC8vIHRyYWNrIHRvIHNlZSB3aGVuIGRyYWdnaW5nIHN0YXJ0c1xyXG5cdCAgdGhpcy5wb2ludGVyRG93blBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQoIHBvaW50ZXIgKTtcclxuXHRcclxuXHQgIC8vIHByZXZlbnQgZGVmYXVsdCwgdW5sZXNzIHRvdWNoc3RhcnQgb3IgPHNlbGVjdD5cclxuXHQgIHZhciBpc1RvdWNoc3RhcnQgPSBldmVudC50eXBlID09ICd0b3VjaHN0YXJ0JztcclxuXHQgIHZhciB0YXJnZXROb2RlTmFtZSA9IGV2ZW50LnRhcmdldC5ub2RlTmFtZTtcclxuXHQgIGlmICggIWlzVG91Y2hzdGFydCAmJiB0YXJnZXROb2RlTmFtZSAhPSAnU0VMRUNUJyApIHtcclxuXHQgICAgcHJldmVudERlZmF1bHRFdmVudCggZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHQvKipcclxuXHQgKiBkcmFnIG1vdmVcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHZhciBtb3ZlVmVjdG9yID0gdGhpcy5fZHJhZ1BvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xyXG5cdCAgdGhpcy5fZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBiYXNlIHBvaW50ZXIgbW92ZSBsb2dpY1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnUG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB2YXIgbW92ZVBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQoIHBvaW50ZXIgKTtcclxuXHQgIHZhciBtb3ZlVmVjdG9yID0ge1xyXG5cdCAgICB4OiBtb3ZlUG9pbnQueCAtIHRoaXMucG9pbnRlckRvd25Qb2ludC54LFxyXG5cdCAgICB5OiBtb3ZlUG9pbnQueSAtIHRoaXMucG9pbnRlckRvd25Qb2ludC55XHJcblx0ICB9O1xyXG5cdCAgLy8gc3RhcnQgZHJhZyBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcclxuXHQgIGlmICggIXRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLmhhc0RyYWdTdGFydGVkKCBtb3ZlVmVjdG9yICkgKSB7XHJcblx0ICAgIHRoaXMuX2RyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBtb3ZlVmVjdG9yO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gY29uZGl0aW9uIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XHJcblx0ICByZXR1cm4gTWF0aC5hYnMoIG1vdmVWZWN0b3IueCApID4gMyB8fCBNYXRoLmFicyggbW92ZVZlY3Rvci55ICkgPiAzO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0Ly8gLS0tLS0gZW5kIGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciB1cFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0ICB0aGlzLl9kcmFnUG9pbnRlclVwKCBldmVudCwgcG9pbnRlciApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdQb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICBpZiAoIHRoaXMuaXNEcmFnZ2luZyApIHtcclxuXHQgICAgdGhpcy5fZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIC8vIHBvaW50ZXIgZGlkbid0IG1vdmUgZW5vdWdoIGZvciBkcmFnIHRvIHN0YXJ0XHJcblx0ICAgIHRoaXMuX3N0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUucG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcclxuXHQgIGV2ZW50aWUudW5iaW5kKCB3aW5kb3csICdzY3JvbGwnLCB0aGlzICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZHJhZ1N0YXJ0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcblx0ICB0aGlzLmRyYWdTdGFydFBvaW50ID0gVW5pZHJhZ2dlci5nZXRQb2ludGVyUG9pbnQoIHBvaW50ZXIgKTtcclxuXHQgIC8vIHByZXZlbnQgY2xpY2tzXHJcblx0ICB0aGlzLmlzUHJldmVudGluZ0NsaWNrcyA9IHRydWU7XHJcblx0XHJcblx0ICB0aGlzLmRyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ1N0YXJ0JywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBkcmFnTW92ZVxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcclxuXHQgIC8vIGRvIG5vdCBkcmFnIGlmIG5vdCBkcmFnZ2luZyB5ZXRcclxuXHQgIGlmICggIXRoaXMuaXNEcmFnZ2luZyApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5kcmFnTW92ZSggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmRyYWdNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xyXG5cdCAgcHJldmVudERlZmF1bHRFdmVudCggZXZlbnQgKTtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ01vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGRyYWdFbmRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5fZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIC8vIHNldCBmbGFnc1xyXG5cdCAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcblx0ICAvLyByZS1lbmFibGUgY2xpY2tpbmcgYXN5bmNcclxuXHQgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHQgICAgZGVsZXRlIF90aGlzLmlzUHJldmVudGluZ0NsaWNrcztcclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgdGhpcy5kcmFnRW5kKCBldmVudCwgcG9pbnRlciApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ0VuZCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUucG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcclxuXHQgIGV2ZW50aWUudW5iaW5kKCB3aW5kb3csICdzY3JvbGwnLCB0aGlzICk7XHJcblx0ICBkZWxldGUgdGhpcy5wb2ludGVyRG93blNjcm9sbDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG9uY2xpY2sgLS0tLS0gLy9cclxuXHRcclxuXHQvLyBoYW5kbGUgYWxsIGNsaWNrcyBhbmQgcHJldmVudCBjbGlja3Mgd2hlbiBkcmFnZ2luZ1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICBpZiAoIHRoaXMuaXNQcmV2ZW50aW5nQ2xpY2tzICkge1xyXG5cdCAgICBwcmV2ZW50RGVmYXVsdEV2ZW50KCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cclxuXHRcclxuXHQvLyB0cmlnZ2VyZWQgYWZ0ZXIgcG9pbnRlciBkb3duICYgdXAgd2l0aCBuby90aW55IG1vdmVtZW50XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX3N0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgLy8gaWdub3JlIGVtdWxhdGVkIG1vdXNlIHVwIGNsaWNrc1xyXG5cdCAgaWYgKCB0aGlzLmlzSWdub3JpbmdNb3VzZVVwICYmIGV2ZW50LnR5cGUgPT0gJ21vdXNldXAnICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyBhbGxvdyBjbGljayBpbiA8aW5wdXQ+cyBhbmQgPHRleHRhcmVhPnNcclxuXHQgIHZhciBub2RlTmFtZSA9IGV2ZW50LnRhcmdldC5ub2RlTmFtZTtcclxuXHQgIGlmICggbm9kZU5hbWUgPT0gJ0lOUFVUJyB8fCBub2RlTmFtZSA9PSAnVEVYVEFSRUEnICkge1xyXG5cdCAgICBldmVudC50YXJnZXQuZm9jdXMoKTtcclxuXHQgIH1cclxuXHQgIHRoaXMuc3RhdGljQ2xpY2soIGV2ZW50LCBwb2ludGVyICk7XHJcblx0XHJcblx0ICAvLyBzZXQgZmxhZyBmb3IgZW11bGF0ZWQgY2xpY2tzIDMwMG1zIGFmdGVyIHRvdWNoZW5kXHJcblx0ICBpZiAoIGV2ZW50LnR5cGUgIT0gJ21vdXNldXAnICkge1xyXG5cdCAgICB0aGlzLmlzSWdub3JpbmdNb3VzZVVwID0gdHJ1ZTtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHQgICAgLy8gcmVzZXQgZmxhZyBhZnRlciAzMDBtc1xyXG5cdCAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICBkZWxldGUgX3RoaXMuaXNJZ25vcmluZ01vdXNlVXA7XHJcblx0ICAgIH0sIDQwMCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3N0YXRpY0NsaWNrJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBzY3JvbGwgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5vbnNjcm9sbCA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdmFyIHNjcm9sbCA9IFVuaWRyYWdnZXIuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcclxuXHQgIHZhciBzY3JvbGxNb3ZlWCA9IHRoaXMucG9pbnRlckRvd25TY3JvbGwueCAtIHNjcm9sbC54O1xyXG5cdCAgdmFyIHNjcm9sbE1vdmVZID0gdGhpcy5wb2ludGVyRG93blNjcm9sbC55IC0gc2Nyb2xsLnk7XHJcblx0ICAvLyBjYW5jZWwgY2xpY2svdGFwIGlmIHNjcm9sbCBpcyB0b28gbXVjaFxyXG5cdCAgaWYgKCBNYXRoLmFicyggc2Nyb2xsTW92ZVggKSA+IDMgfHwgTWF0aC5hYnMoIHNjcm9sbE1vdmVZICkgPiAzICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyRG9uZSgpO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gdXRpbHMgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IGZ1bmN0aW9uKCBwb2ludGVyICkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgeDogcG9pbnRlci5wYWdlWCAhPT0gdW5kZWZpbmVkID8gcG9pbnRlci5wYWdlWCA6IHBvaW50ZXIuY2xpZW50WCxcclxuXHQgICAgeTogcG9pbnRlci5wYWdlWSAhPT0gdW5kZWZpbmVkID8gcG9pbnRlci5wYWdlWSA6IHBvaW50ZXIuY2xpZW50WVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBpc1BhZ2VPZmZzZXQgPSB3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZDtcclxuXHRcclxuXHQvLyBnZXQgc2Nyb2xsIGluIHsgeCwgeSB9XHJcblx0VW5pZHJhZ2dlci5nZXRTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgeDogaXNQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxyXG5cdCAgICB5OiBpc1BhZ2VPZmZzZXQgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcFxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tICAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIuZ2V0UG9pbnRlclBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQ7XHJcblx0XHJcblx0cmV0dXJuIFVuaWRyYWdnZXI7XHJcblx0XHJcblx0fSkpO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXHJcblx0ICogZXZlbnRpZSB2MS4wLjZcclxuXHQgKiBldmVudCBiaW5kaW5nIGhlbHBlclxyXG5cdCAqICAgZXZlbnRpZS5iaW5kKCBlbGVtLCAnY2xpY2snLCBteUZuIClcclxuXHQgKiAgIGV2ZW50aWUudW5iaW5kKCBlbGVtLCAnY2xpY2snLCBteUZuIClcclxuXHQgKiBNSVQgbGljZW5zZVxyXG5cdCAqL1xyXG5cdFxyXG5cdC8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuXHQvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlICovXHJcblx0XHJcblx0KCBmdW5jdGlvbiggd2luZG93ICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHRcclxuXHR2YXIgYmluZCA9IGZ1bmN0aW9uKCkge307XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0SUVFdmVudCggb2JqICkge1xyXG5cdCAgdmFyIGV2ZW50ID0gd2luZG93LmV2ZW50O1xyXG5cdCAgLy8gYWRkIGV2ZW50LnRhcmdldFxyXG5cdCAgZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgb2JqO1xyXG5cdCAgcmV0dXJuIGV2ZW50O1xyXG5cdH1cclxuXHRcclxuXHRpZiAoIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcclxuXHQgIGJpbmQgPSBmdW5jdGlvbiggb2JqLCB0eXBlLCBmbiApIHtcclxuXHQgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGZuLCBmYWxzZSApO1xyXG5cdCAgfTtcclxuXHR9IGVsc2UgaWYgKCBkb2NFbGVtLmF0dGFjaEV2ZW50ICkge1xyXG5cdCAgYmluZCA9IGZ1bmN0aW9uKCBvYmosIHR5cGUsIGZuICkge1xyXG5cdCAgICBvYmpbIHR5cGUgKyBmbiBdID0gZm4uaGFuZGxlRXZlbnQgP1xyXG5cdCAgICAgIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgdmFyIGV2ZW50ID0gZ2V0SUVFdmVudCggb2JqICk7XHJcblx0ICAgICAgICBmbi5oYW5kbGVFdmVudC5jYWxsKCBmbiwgZXZlbnQgKTtcclxuXHQgICAgICB9IDpcclxuXHQgICAgICBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgIHZhciBldmVudCA9IGdldElFRXZlbnQoIG9iaiApO1xyXG5cdCAgICAgICAgZm4uY2FsbCggb2JqLCBldmVudCApO1xyXG5cdCAgICAgIH07XHJcblx0ICAgIG9iai5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgb2JqWyB0eXBlICsgZm4gXSApO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0XHJcblx0dmFyIHVuYmluZCA9IGZ1bmN0aW9uKCkge307XHJcblx0XHJcblx0aWYgKCBkb2NFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XHJcblx0ICB1bmJpbmQgPSBmdW5jdGlvbiggb2JqLCB0eXBlLCBmbiApIHtcclxuXHQgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGZuLCBmYWxzZSApO1xyXG5cdCAgfTtcclxuXHR9IGVsc2UgaWYgKCBkb2NFbGVtLmRldGFjaEV2ZW50ICkge1xyXG5cdCAgdW5iaW5kID0gZnVuY3Rpb24oIG9iaiwgdHlwZSwgZm4gKSB7XHJcblx0ICAgIG9iai5kZXRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgb2JqWyB0eXBlICsgZm4gXSApO1xyXG5cdCAgICB0cnkge1xyXG5cdCAgICAgIGRlbGV0ZSBvYmpbIHR5cGUgKyBmbiBdO1xyXG5cdCAgICB9IGNhdGNoICggZXJyICkge1xyXG5cdCAgICAgIC8vIGNhbid0IGRlbGV0ZSB3aW5kb3cgb2JqZWN0IHByb3BlcnRpZXNcclxuXHQgICAgICBvYmpbIHR5cGUgKyBmbiBdID0gdW5kZWZpbmVkO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZXZlbnRpZSA9IHtcclxuXHQgIGJpbmQ6IGJpbmQsXHJcblx0ICB1bmJpbmQ6IHVuYmluZFxyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbW9kdWxlIGRlZmluaXRpb24gLS0tLS0gLy9cclxuXHRcclxuXHRpZiAoIHRydWUgKSB7XHJcblx0ICAvLyBBTURcclxuXHQgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGV2ZW50aWUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcclxuXHQgIC8vIENvbW1vbkpTXHJcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGV2ZW50aWU7XHJcblx0fSBlbHNlIHtcclxuXHQgIC8vIGJyb3dzZXIgZ2xvYmFsXHJcblx0ICB3aW5kb3cuZXZlbnRpZSA9IGV2ZW50aWU7XHJcblx0fVxyXG5cdFxyXG5cdH0pKCB3aW5kb3cgKTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIFVuaXBvaW50ZXIgdjEuMS4wXHJcblx0ICogYmFzZSBjbGFzcyBmb3IgZG9pbmcgb25lIHRoaW5nIHdpdGggcG9pbnRlciBldmVudFxyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSwgcmVxdWlyZTogZmFsc2UgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XHJcblx0ICAndXNlIHN0cmljdCc7XHJcblx0ICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cclxuXHRcclxuXHQgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblx0ICAgIC8vIEFNRFxyXG5cdCAgICBkZWZpbmUoIFtcclxuXHQgICAgICAnZXZlbnRFbWl0dGVyL0V2ZW50RW1pdHRlcicsXHJcblx0ICAgICAgJ2V2ZW50aWUvZXZlbnRpZSdcclxuXHQgICAgXSwgZnVuY3Rpb24oIEV2ZW50RW1pdHRlciwgZXZlbnRpZSApIHtcclxuXHQgICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdmVudEVtaXR0ZXIsIGV2ZW50aWUgKTtcclxuXHQgICAgfSk7XHJcblx0ICB9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgICAvLyBDb21tb25KU1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXHJcblx0ICAgICAgd2luZG93LFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTgyKSxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MClcclxuXHQgICAgKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIC8vIGJyb3dzZXIgZ2xvYmFsXHJcblx0ICAgIHdpbmRvdy5Vbmlwb2ludGVyID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgd2luZG93LkV2ZW50RW1pdHRlcixcclxuXHQgICAgICB3aW5kb3cuZXZlbnRpZVxyXG5cdCAgICApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdmVudEVtaXR0ZXIsIGV2ZW50aWUgKSB7XHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFVuaXBvaW50ZXIoKSB7fVxyXG5cdFxyXG5cdC8vIGluaGVyaXQgRXZlbnRFbWl0dGVyXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuYmluZFN0YXJ0RXZlbnQgPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgIHRoaXMuX2JpbmRTdGFydEV2ZW50KCBlbGVtLCB0cnVlICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS51bmJpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0ICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgZmFsc2UgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHdvcmtzIGFzIHVuYmluZGVyLCBhcyB5b3UgY2FuIC5fYmluZFN0YXJ0KCBmYWxzZSApIHRvIHVuYmluZFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5kIC0gd2lsbCB1bmJpbmQgaWYgZmFsc2V5XHJcblx0ICovXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX2JpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIGlzQmluZCApIHtcclxuXHQgIC8vIG11bmdlIGlzQmluZCwgZGVmYXVsdCB0byB0cnVlXHJcblx0ICBpc0JpbmQgPSBpc0JpbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWlzQmluZDtcclxuXHQgIHZhciBiaW5kTWV0aG9kID0gaXNCaW5kID8gJ2JpbmQnIDogJ3VuYmluZCc7XHJcblx0XHJcblx0ICBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIC8vIFczQyBQb2ludGVyIEV2ZW50cywgSUUxMS4gU2VlIGh0dHBzOi8vY29kZXJ3YWxsLmNvbS9wL21mcmVjYVxyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICdwb2ludGVyZG93bicsIHRoaXMgKTtcclxuXHQgIH0gZWxzZSBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCApIHtcclxuXHQgICAgLy8gSUUxMCBQb2ludGVyIEV2ZW50c1xyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICdNU1BvaW50ZXJEb3duJywgdGhpcyApO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgLy8gbGlzdGVuIGZvciBib3RoLCBmb3IgZGV2aWNlcyBsaWtlIENocm9tZSBQaXhlbFxyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICdtb3VzZWRvd24nLCB0aGlzICk7XHJcblx0ICAgIGV2ZW50aWVbIGJpbmRNZXRob2QgXSggZWxlbSwgJ3RvdWNoc3RhcnQnLCB0aGlzICk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyB0cmlnZ2VyIGhhbmRsZXIgbWV0aG9kcyBmb3IgZXZlbnRzXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XHJcblx0ICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xyXG5cdCAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIHJldHVybnMgdGhlIHRvdWNoIHRoYXQgd2UncmUga2VlcGluZyB0cmFjayBvZlxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLmdldFRvdWNoID0gZnVuY3Rpb24oIHRvdWNoZXMgKSB7XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xyXG5cdCAgICBpZiAoIHRvdWNoLmlkZW50aWZpZXIgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgICByZXR1cm4gdG91Y2g7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIHN0YXJ0IGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25tb3VzZWRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICAvLyBkaXNtaXNzIGNsaWNrcyBmcm9tIHJpZ2h0IG9yIG1pZGRsZSBidXR0b25zXHJcblx0ICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG5cdCAgaWYgKCBidXR0b24gJiYgKCBidXR0b24gIT09IDAgJiYgYnV0dG9uICE9PSAxICkgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9uTVNQb2ludGVyRG93biA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVyZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgc3RhcnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5fcG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICAvLyBkaXNtaXNzIG90aGVyIHBvaW50ZXJzXHJcblx0ICBpZiAoIHRoaXMuaXNQb2ludGVyRG93biApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5pc1BvaW50ZXJEb3duID0gdHJ1ZTtcclxuXHQgIC8vIHNhdmUgcG9pbnRlciBpZGVudGlmaWVyIHRvIG1hdGNoIHVwIHRvdWNoIGV2ZW50c1xyXG5cdCAgdGhpcy5wb2ludGVySWRlbnRpZmllciA9IHBvaW50ZXIucG9pbnRlcklkICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAvLyBwb2ludGVySWQgZm9yIHBvaW50ZXIgZXZlbnRzLCB0b3VjaC5pbmRlbnRpZmllciBmb3IgdG91Y2ggZXZlbnRzXHJcblx0ICAgIHBvaW50ZXIucG9pbnRlcklkIDogcG9pbnRlci5pZGVudGlmaWVyO1xyXG5cdFxyXG5cdCAgdGhpcy5wb2ludGVyRG93biggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5fYmluZFBvc3RTdGFydEV2ZW50cyggZXZlbnQgKTtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGhhc2ggb2YgZXZlbnRzIHRvIGJlIGJvdW5kIGFmdGVyIHN0YXJ0IGV2ZW50XHJcblx0dmFyIHBvc3RTdGFydEV2ZW50cyA9IHtcclxuXHQgIG1vdXNlZG93bjogWyAnbW91c2Vtb3ZlJywgJ21vdXNldXAnIF0sXHJcblx0ICB0b3VjaHN0YXJ0OiBbICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIF0sXHJcblx0ICBwb2ludGVyZG93bjogWyAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJjYW5jZWwnIF0sXHJcblx0ICBNU1BvaW50ZXJEb3duOiBbICdNU1BvaW50ZXJNb3ZlJywgJ01TUG9pbnRlclVwJywgJ01TUG9pbnRlckNhbmNlbCcgXVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX2JpbmRQb3N0U3RhcnRFdmVudHMgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICBpZiAoICFldmVudCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgLy8gZ2V0IHByb3BlciBldmVudHMgdG8gbWF0Y2ggc3RhcnQgZXZlbnRcclxuXHQgIHZhciBldmVudHMgPSBwb3N0U3RhcnRFdmVudHNbIGV2ZW50LnR5cGUgXTtcclxuXHQgIC8vIElFOCBuZWVkcyB0byBiZSBib3VuZCB0byBkb2N1bWVudFxyXG5cdCAgdmFyIG5vZGUgPSBldmVudC5wcmV2ZW50RGVmYXVsdCA/IHdpbmRvdyA6IGRvY3VtZW50O1xyXG5cdCAgLy8gYmluZCBldmVudHMgdG8gbm9kZVxyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgZXZudCA9IGV2ZW50c1tpXTtcclxuXHQgICAgZXZlbnRpZS5iaW5kKCBub2RlLCBldm50LCB0aGlzICk7XHJcblx0ICB9XHJcblx0ICAvLyBzYXZlIHRoZXNlIGFyZ3VtZW50c1xyXG5cdCAgdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzID0ge1xyXG5cdCAgICBldmVudHM6IGV2ZW50cyxcclxuXHQgICAgbm9kZTogbm9kZVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl91bmJpbmRQb3N0U3RhcnRFdmVudHMgPSBmdW5jdGlvbigpIHtcclxuXHQgIHZhciBhcmdzID0gdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzO1xyXG5cdCAgLy8gSUU4IGNhbiB0cmlnZ2VyIGRyYWdFbmQgdHdpY2UsIGNoZWNrIGZvciBfYm91bmRFdmVudHNcclxuXHQgIGlmICggIWFyZ3MgfHwgIWFyZ3MuZXZlbnRzICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBhcmdzLmV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIGV2ZW50ID0gYXJncy5ldmVudHNbaV07XHJcblx0ICAgIGV2ZW50aWUudW5iaW5kKCBhcmdzLm5vZGUsIGV2ZW50LCB0aGlzICk7XHJcblx0ICB9XHJcblx0ICBkZWxldGUgdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbW92ZSBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCBldmVudCApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25NU1BvaW50ZXJNb3ZlID1cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbnBvaW50ZXJtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wb2ludGVySWQgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub250b3VjaG1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB2YXIgdG91Y2ggPSB0aGlzLmdldFRvdWNoKCBldmVudC5jaGFuZ2VkVG91Y2hlcyApO1xyXG5cdCAgaWYgKCB0b3VjaCApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCB0b3VjaCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBtb3ZlXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5fcG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLnBvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gcHVibGljXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJNb3ZlJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbm1vdXNldXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCBldmVudCApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25NU1BvaW50ZXJVcCA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVydXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub250b3VjaGVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XHJcblx0ICBpZiAoIHRvdWNoICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCB0b3VjaCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciB1cFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX3BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb25lKCk7XHJcblx0ICB0aGlzLnBvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHB1YmxpY1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBwb2ludGVyIGRvbmUgLS0tLS0gLy9cclxuXHRcclxuXHQvLyB0cmlnZ2VyZWQgb24gcG9pbnRlciB1cCAmIHBvaW50ZXIgY2FuY2VsXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX3BvaW50ZXJEb25lID0gZnVuY3Rpb24oKSB7XHJcblx0ICAvLyByZXNldCBwcm9wZXJ0aWVzXHJcblx0ICB0aGlzLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcclxuXHQgIGRlbGV0ZSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyO1xyXG5cdCAgLy8gcmVtb3ZlIGV2ZW50c1xyXG5cdCAgdGhpcy5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzKCk7XHJcblx0ICB0aGlzLnBvaW50ZXJEb25lKCk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5wb2ludGVyRG9uZSA9IG5vb3A7XHJcblx0XHJcblx0Ly8gLS0tLS0gcG9pbnRlciBjYW5jZWwgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbk1TUG9pbnRlckNhbmNlbCA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVyY2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wb2ludGVySWQgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIGV2ZW50ICk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbnRvdWNoY2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdmFyIHRvdWNoID0gdGhpcy5nZXRUb3VjaCggZXZlbnQuY2hhbmdlZFRvdWNoZXMgKTtcclxuXHQgIGlmICggdG91Y2ggKSB7XHJcblx0ICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwoIGV2ZW50LCB0b3VjaCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBjYW5jZWxcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl9wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5fcG9pbnRlckRvbmUoKTtcclxuXHQgIHRoaXMucG9pbnRlckNhbmNlbCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHB1YmxpY1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJDYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJDYW5jZWwnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tICAtLS0tLSAvL1xyXG5cdFxyXG5cdC8vIHV0aWxpdHkgZnVuY3Rpb24gZm9yIGdldHRpbmcgeC95IGNvb3JpZGluYXRlcyBmcm9tIGV2ZW50LCBiZWNhdXNlIElFOFxyXG5cdFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50ID0gZnVuY3Rpb24oIHBvaW50ZXIgKSB7XHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB4OiBwb2ludGVyLnBhZ2VYICE9PSB1bmRlZmluZWQgPyBwb2ludGVyLnBhZ2VYIDogcG9pbnRlci5jbGllbnRYLFxyXG5cdCAgICB5OiBwb2ludGVyLnBhZ2VZICE9PSB1bmRlZmluZWQgPyBwb2ludGVyLnBhZ2VZIDogcG9pbnRlci5jbGllbnRZXHJcblx0ICB9O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gIC0tLS0tIC8vXHJcblx0XHJcblx0cmV0dXJuIFVuaXBvaW50ZXI7XHJcblx0XHJcblx0fSkpO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogRXZlbnRFbWl0dGVyIHY0LjIuMTEgLSBnaXQuaW8vZWVcclxuXHQgKiBVbmxpY2Vuc2UgLSBodHRwOi8vdW5saWNlbnNlLm9yZy9cclxuXHQgKiBPbGl2ZXIgQ2FsZHdlbGwgLSBodHRwOi8vb2xpLm1lLnVrL1xyXG5cdCAqIEBwcmVzZXJ2ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdDsoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAndXNlIHN0cmljdCc7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnRzLlxyXG5cdCAgICAgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBjbGFzcyBFdmVudEVtaXR0ZXIgTWFuYWdlcyBldmVudCByZWdpc3RlcmluZyBhbmQgZW1pdHRpbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxyXG5cdFxyXG5cdCAgICAvLyBTaG9ydGN1dHMgdG8gaW1wcm92ZSBzcGVlZCBhbmQgc2l6ZVxyXG5cdCAgICB2YXIgcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xyXG5cdCAgICB2YXIgZXhwb3J0cyA9IHRoaXM7XHJcblx0ICAgIHZhciBvcmlnaW5hbEdsb2JhbFZhbHVlID0gZXhwb3J0cy5FdmVudEVtaXR0ZXI7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgaW4gaXRzIHN0b3JhZ2UgYXJyYXkuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cclxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGxvb2sgZm9yLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIsIC0xIGlmIG5vdCBmb3VuZFxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICB2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XHJcblx0ICAgICAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIC0xO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBhIG1ldGhvZCB3aGlsZSBrZWVwaW5nIHRoZSBjb250ZXh0IGNvcnJlY3QsIHRvIGFsbG93IGZvciBvdmVyd3JpdGluZyBvZiB0YXJnZXQgbWV0aG9kLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IG1ldGhvZC5cclxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBhbGlhc2VkIG1ldGhvZFxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcclxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiBhbGlhc0Nsb3N1cmUoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAgICAgKiBXaWxsIGluaXRpYWxpc2UgdGhlIGV2ZW50IG9iamVjdCBhbmQgbGlzdGVuZXIgYXJyYXlzIGlmIHJlcXVpcmVkLlxyXG5cdCAgICAgKiBXaWxsIHJldHVybiBhbiBvYmplY3QgaWYgeW91IHVzZSBhIHJlZ2V4IHNlYXJjaC4gVGhlIG9iamVjdCBjb250YWlucyBrZXlzIGZvciBlYWNoIG1hdGNoZWQgZXZlbnQuIFNvIC9iYVtyel0vIG1pZ2h0IHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBiYXIgYW5kIGJhei4gQnV0IG9ubHkgaWYgeW91IGhhdmUgZWl0aGVyIGRlZmluZWQgdGhlbSB3aXRoIGRlZmluZUV2ZW50IG9yIGFkZGVkIHNvbWUgbGlzdGVuZXJzIHRvIHRoZW0uXHJcblx0ICAgICAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXHJcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XHJcblx0ICAgICAgICB2YXIgcmVzcG9uc2U7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdFxyXG5cdCAgICAgICAgLy8gUmV0dXJuIGEgY29uY2F0ZW5hdGVkIGFycmF5IG9mIGFsbCBtYXRjaGluZyBldmVudHMgaWZcclxuXHQgICAgICAgIC8vIHRoZSBzZWxlY3RvciBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuXHQgICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuXHQgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xyXG5cdCAgICAgICAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Vba2V5XSA9IGV2ZW50c1trZXldO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgcmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUYWtlcyBhIGxpc3Qgb2YgbGlzdGVuZXIgb2JqZWN0cyBhbmQgZmxhdHRlbnMgaXQgaW50byBhIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBsaXN0ZW5lcnMgUmF3IGxpc3RlbmVyIG9iamVjdHMuXHJcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW119IEp1c3QgdGhlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmZsYXR0ZW5MaXN0ZW5lcnMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuZXJzKGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgdmFyIGZsYXRMaXN0ZW5lcnMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdCAgICAgICAgICAgIGZsYXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIGZsYXRMaXN0ZW5lcnM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBGZXRjaGVzIHRoZSByZXF1ZXN0ZWQgbGlzdGVuZXJzIHZpYSBnZXRMaXN0ZW5lcnMgYnV0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgcmVzdWx0cyBpbnNpZGUgYW4gb2JqZWN0LiBUaGlzIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlIGJ1dCBvdGhlcnMgbWF5IGZpbmQgaXQgdXNlZnVsLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IGluIGFuIG9iamVjdC5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmdldExpc3RlbmVyc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcclxuXHQgICAgICAgIHZhciByZXNwb25zZTtcclxuXHRcclxuXHQgICAgICAgIGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdCAgICAgICAgICAgIHJlc3BvbnNlID0ge307XHJcblx0ICAgICAgICAgICAgcmVzcG9uc2VbZXZ0XSA9IGxpc3RlbmVycztcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiByZXNwb25zZSB8fCBsaXN0ZW5lcnM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgICAgICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxyXG5cdCAgICAgKiBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGl0IGlzIGNhbGxlZC5cclxuXHQgICAgICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUgdGhlbiB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcclxuXHQgICAgICAgIHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdFxyXG5cdCAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpID09PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVySXNXcmFwcGVkID8gbGlzdGVuZXIgOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFsaWFzIG9mIGFkZExpc3RlbmVyXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcclxuXHQgICAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIGl0cyBmaXJzdCBleGVjdXRpb24uXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmFkZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZE9uY2VMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldnQsIHtcclxuXHQgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXHJcblx0ICAgICAgICAgICAgb25jZTogdHJ1ZVxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBvZiBhZGRPbmNlTGlzdGVuZXIuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogRGVmaW5lcyBhbiBldmVudCBuYW1lLiBUaGlzIGlzIHJlcXVpcmVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHJlZ2V4IHRvIGFkZCBhIGxpc3RlbmVyIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBJZiB5b3UgZG9uJ3QgZG8gdGhpcyB0aGVuIGhvdyBkbyB5b3UgZXhwZWN0IGl0IHRvIGtub3cgd2hhdCBldmVudCB0byBhZGQgdG8/IFNob3VsZCBpdCBqdXN0IGFkZCB0byBldmVyeSBwb3NzaWJsZSBtYXRjaCBmb3IgYSByZWdleD8gTm8uIFRoYXQgaXMgc2NhcnkgYW5kIGJhZC5cclxuXHQgICAgICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gY3JlYXRlLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gZGVmaW5lRXZlbnQoZXZ0KSB7XHJcblx0ICAgICAgICB0aGlzLmdldExpc3RlbmVycyhldnQpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBVc2VzIGRlZmluZUV2ZW50IHRvIGRlZmluZSBtdWx0aXBsZSBldmVudHMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGV2dHMgQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGVmaW5lLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmRlZmluZUV2ZW50cyA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50cyhldnRzKSB7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRlZmluZUV2ZW50KGV2dHNbaV0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAgICAgKiBXaGVuIHBhc3NlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSwgaXQgd2lsbCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xyXG5cdCAgICAgICAgdmFyIGluZGV4O1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHRcclxuXHQgICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBvZiByZW1vdmVMaXN0ZW5lclxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ub2ZmID0gYWxpYXMoJ3JlbW92ZUxpc3RlbmVyJyk7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBZGRzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cclxuXHQgICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy4gWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBhZGQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqIFllYWgsIHRoaXMgZnVuY3Rpb24gZG9lcyBxdWl0ZSBhIGJpdC4gVGhhdCdzIHByb2JhYmx5IGEgYmFkIHRoaW5nLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyhmYWxzZSwgZXZ0LCBsaXN0ZW5lcnMpO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogUmVtb3ZlcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXHJcblx0ICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIHJlbW92ZWQuXHJcblx0ICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHJlbW92ZS5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcclxuXHQgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKHRydWUsIGV2dCwgbGlzdGVuZXJzKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEVkaXRzIGxpc3RlbmVycyBpbiBidWxrLiBUaGUgYWRkTGlzdGVuZXJzIGFuZCByZW1vdmVMaXN0ZW5lcnMgbWV0aG9kcyBib3RoIHVzZSB0aGlzIHRvIGRvIHRoZWlyIGpvYi4gWW91IHNob3VsZCByZWFsbHkgdXNlIHRob3NlIGluc3RlYWQsIHRoaXMgaXMgYSBsaXR0bGUgbG93ZXIgbGV2ZWwuXHJcblx0ICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCB3aWxsIGRldGVybWluZSBpZiB0aGUgbGlzdGVuZXJzIGFyZSByZW1vdmVkICh0cnVlKSBvciBhZGRlZCAoZmFsc2UpLlxyXG5cdCAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQvcmVtb3ZlZC5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWFuaXB1bGF0ZSB0aGUgbGlzdGVuZXJzIG9mIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgVHJ1ZSBpZiB5b3Ugd2FudCB0byByZW1vdmUgbGlzdGVuZXJzLCBmYWxzZSBpZiB5b3Ugd2FudCB0byBhZGQuXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC9yZW1vdmUuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIG1hbmlwdWxhdGVMaXN0ZW5lcnMocmVtb3ZlLCBldnQsIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgdmFyIGk7XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICB2YXIgc2luZ2xlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lciA6IHRoaXMuYWRkTGlzdGVuZXI7XHJcblx0ICAgICAgICB2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xyXG5cdFxyXG5cdCAgICAgICAgLy8gSWYgZXZ0IGlzIGFuIG9iamVjdCB0aGVuIHBhc3MgZWFjaCBvZiBpdHMgcHJvcGVydGllcyB0byB0aGlzIG1ldGhvZFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG5cdCAgICAgICAgICAgIGZvciAoaSBpbiBldnQpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAodmFsdWUgPSBldnRbaV0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHBhc3MgYmFjayB0byB0aGUgbXVsdGlwbGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXHJcblx0ICAgICAgICAgICAgLy8gQW5kIGxpc3RlbmVycyBtdXN0IGJlIGFuIGFycmF5IG9mIGxpc3RlbmVyc1xyXG5cdCAgICAgICAgICAgIC8vIExvb3Agb3ZlciBpdCBhbmQgcGFzcyBlYWNoIG9uZSB0byB0aGUgbXVsdGlwbGUgbWV0aG9kXHJcblx0ICAgICAgICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG5cdCAgICAgICAgICAgICAgICBzaW5nbGUuY2FsbCh0aGlzLCBldnQsIGxpc3RlbmVyc1tpXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSBhIHNwZWNpZmllZCBldmVudC5cclxuXHQgICAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGFuIGV2ZW50IHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICAgICAqIFRoYXQgbWVhbnMgZXZlcnkgZXZlbnQgd2lsbCBiZSBlbXB0aWVkLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ2V4IHRvIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gW2V2dF0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLiBXaWxsIHJlbW92ZSBmcm9tIGV2ZXJ5IGV2ZW50IGlmIG5vdCBwYXNzZWQuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChldnQpIHtcclxuXHQgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGV2dDtcclxuXHQgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0XHJcblx0ICAgICAgICAvLyBSZW1vdmUgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIGV2dFxyXG5cdCAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcclxuXHQgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2V2dF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgcmVnZXguXHJcblx0ICAgICAgICAgICAgZm9yIChrZXkgaW4gZXZlbnRzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2tleV07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBhbGwgZXZlbnRzXHJcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBhbGlhcygncmVtb3ZlRXZlbnQnKTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEVtaXRzIGFuIGV2ZW50IG9mIHlvdXIgY2hvaWNlLlxyXG5cdCAgICAgKiBXaGVuIGVtaXR0ZWQsIGV2ZXJ5IGxpc3RlbmVyIGF0dGFjaGVkIHRvIHRoYXQgZXZlbnQgd2lsbCBiZSBleGVjdXRlZC5cclxuXHQgICAgICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxyXG5cdCAgICAgKiBCZWNhdXNlIGl0IHVzZXMgYGFwcGx5YCwgeW91ciBhcnJheSBvZiBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgaWYgeW91IHdyb3RlIHRoZW0gb3V0IHNlcGFyYXRlbHkuXHJcblx0ICAgICAqIFNvIHRoZXkgd2lsbCBub3QgYXJyaXZlIHdpdGhpbiB0aGUgYXJyYXkgb24gdGhlIG90aGVyIHNpZGUsIHRoZXkgd2lsbCBiZSBzZXBhcmF0ZS5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cclxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVyO1xyXG5cdCAgICAgICAgdmFyIGk7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgdmFyIHJlc3BvbnNlO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGkgPSBsaXN0ZW5lcnNba2V5XS5sZW5ndGg7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCBzaGFsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2tleV1baV07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25jZSA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGxpc3RlbmVyLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFsaWFzIG9mIGVtaXRFdmVudFxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8udHJpZ2dlciA9IGFsaWFzKCdlbWl0RXZlbnQnKTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cclxuXHQgICAgICogQXMgd2l0aCBlbWl0RXZlbnQsIHlvdSBjYW4gcGFzcyBhIHJlZ2V4IGluIHBsYWNlIG9mIHRoZSBldmVudCBuYW1lIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXHJcblx0ICAgICAqIEBwYXJhbSB7Li4uKn0gT3B0aW9uYWwgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmIGFcclxuXHQgICAgICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcclxuXHQgICAgICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLnNldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIHNldE9uY2VSZXR1cm5WYWx1ZSh2YWx1ZSkge1xyXG5cdCAgICAgICAgdGhpcy5fb25jZVJldHVyblZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEZldGNoZXMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmXHJcblx0ICAgICAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxyXG5cdCAgICAgKiBhdXRvbWF0aWNhbGx5LiBJdCB3aWxsIHJldHVybiB0cnVlIGJ5IGRlZmF1bHQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLl9nZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBfZ2V0T25jZVJldHVyblZhbHVlKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ19vbmNlUmV0dXJuVmFsdWUnKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmNlUmV0dXJuVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEZldGNoZXMgdGhlIGV2ZW50cyBvYmplY3QgYW5kIGNyZWF0ZXMgb25lIGlmIHJlcXVpcmVkLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXHJcblx0ICAgICAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZXZlcnRzIHRoZSBnbG9iYWwge0BsaW5rIEV2ZW50RW1pdHRlcn0gdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmVyc2lvbi5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259IE5vbiBjb25mbGljdGluZyBFdmVudEVtaXR0ZXIgY2xhc3MuXHJcblx0ICAgICAqL1xyXG5cdCAgICBFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XHJcblx0ICAgICAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IG9yaWdpbmFsR2xvYmFsVmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvLyBFeHBvc2UgdGhlIGNsYXNzIGVpdGhlciB2aWEgQU1ELCBDb21tb25KUyBvciB0aGUgZ2xvYmFsIG9iamVjdFxyXG5cdCAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0ICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyl7XHJcblx0ICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIHtcclxuXHQgICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xyXG5cdCAgICB9XHJcblx0fS5jYWxsKHRoaXMpKTtcclxuXHRcclxuXHR9LmNhbGwod2luZG93KSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1zbGlkZXJcXFwiIDppZD1cXFwiaWRcXFwiXFxuICAgIDpjbGFzcz1cXFwie1xcbiAgICAgICAgbWluOiB2YWx1ZSA9PT0gMCwgbWF4OiB2YWx1ZSA9PT0gMTAwLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRpc2FibGVkOiBkaXNhYmxlZCxcXG4gICAgICAgIGFjdGl2ZTogYWN0aXZlLCAnaGFzLWxhYmVsJzogaGFzTGFiZWxcXG4gICAgfVxcXCJcXG5cXG4gICAgOnRhYmluZGV4PVxcXCJkaXNhYmxlZCA/IG51bGwgOiAwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIlxcbiAgICA6YXJpYS12YWx1ZW5vdz1cXFwidmFsdWVcXFwiXFxuXFxuICAgIEBrZXlkb3duLmxlZnQucHJldmVudD1cXFwiZGVjcmVtZW50XFxcIiBAa2V5ZG93bi5yaWdodC5wcmV2ZW50PVxcXCJpbmNyZW1lbnRcXFwiXFxuICAgIEBrZXlkb3duLmRvd24ucHJldmVudD1cXFwiZGVjcmVtZW50XFxcIiBAa2V5ZG93bi51cC5wcmV2ZW50PVxcXCJpbmNyZW1lbnRcXFwiXFxuICAgIEBmb2N1cz1cXFwiZm9jdXNcXFwiIEBibHVyPVxcXCJibHVyXFxcIlxcbj5cXG4gICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgOnZhbHVlPVxcXCJ2YWx1ZVxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItaWNvbi13cmFwcGVyXFxcIiB2LWlmPVxcXCJzaG93SWNvblxcXCI+XFxuICAgICAgICA8dWktaWNvbiA6aWNvbj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInVpLXNsaWRlci1pY29uXFxcIj48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItbGFiZWxcXFwiIHYtdGV4dD1cXFwibGFiZWxcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXdyYXBwZXJcXFwiIHYtZWw6c2xpZGVyIEBtb3VzZWRvd249XFxcInNsaWRlckNsaWNrXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItY29udGFpbm1lbnRcXFwiIHYtZWw6Y29udGFpbm1lbnQ+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXRyYWNrXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXRyYWNrLWZpbGxcXFwiIDpzdHlsZT1cXFwieyB3aWR0aDogdmFsdWUgKyAnJSd9XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItdGh1bWItY29udGFpbmVyXFxcIiB2LWVsOnRodW1iPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItZm9jdXMtcmluZ1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNsaWRlci10aHVtYlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTg1KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODYpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTbmFja2Jhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NylcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVNuYWNrYmFyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlCdXR0b24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc25hY2tiYXInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1lc3NhZ2U6IFN0cmluZyxcclxuXHQgICAgICAgIGFjdGlvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgYWN0aW9uQ29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2FjY2VudCcgfSxcclxuXHQgICAgICAgIHBlcnNpc3RlbnQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHVyYXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogNTAwMFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGF1dG9IaWRlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGhlaWdodDogMCxcclxuXHQgICAgICAgICAgICB0aW1lb3V0OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xyXG5cdCAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWNrZWQnKTtcclxuXHQgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhY3Rpb25DbGljazogZnVuY3Rpb24gYWN0aW9uQ2xpY2soKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FjdGlvbi1jbGlja2VkJyk7XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMucGVyc2lzdGVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpQnV0dG9uOiBfVWlCdXR0b24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgdHJhbnNpdGlvbnM6IHtcclxuXHQgICAgICAgICd1aS1zbmFja2Jhci10b2dnbGUnOiB7XHJcblx0ICAgICAgICAgICAgYWZ0ZXJFbnRlcjogZnVuY3Rpb24gYWZ0ZXJFbnRlcigpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3duJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9IaWRlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZSwgdGhpcy5kdXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGFmdGVyTGVhdmU6IGZ1bmN0aW9uIGFmdGVyTGVhdmUoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdoaWRkZW4nKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXNuYWNrYmFyXFxcIiA6aWQ9XFxcImlkXFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1zbmFja2Jhci10b2dnbGVcXFwiIEBjbGljaz1cXFwiY2xpY2tcXFwiIHYtc2hvdz1cXFwic2hvd1xcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXNuYWNrYmFyLXRleHRcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJtZXNzYWdlXFxcIj48L3NwYW4+XFxuICAgICAgICA8L3Nsb3Q+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbmFja2Jhci1hY3Rpb25cXFwiPlxcbiAgICAgICAgPHVpLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zbmFja2Jhci1hY3Rpb24tYnV0dG9uXFxcIiB0eXBlPVxcXCJmbGF0XFxcIiA6Y29sb3I9XFxcImFjdGlvbkNvbG9yXFxcIlxcbiAgICAgICAgICAgIDp0ZXh0PVxcXCJhY3Rpb25cXFwiIEBjbGljay5zdG9wPVxcXCJhY3Rpb25DbGlja1xcXCIgdi1pZj1cXFwiYWN0aW9uXFxcIlxcbiAgICAgICAgPjwvdWktYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxODkpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MClcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVNuYWNrYmFyQ29udGFpbmVyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU25hY2tiYXJDb250YWluZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG5cdFxyXG5cdHZhciBfdXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dWlkKTtcclxuXHRcclxuXHR2YXIgX1VpU25hY2tiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NCk7XHJcblx0XHJcblx0dmFyIF9VaVNuYWNrYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU25hY2tiYXIpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc25hY2tiYXItY29udGFpbmVyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHF1ZXVlU25hY2tiYXJzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlZmF1bHREdXJhdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiA1MDAwXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcG9zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2xlZnQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShwb3NpdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3Bvc2l0aW9uLScgKyBwb3NpdGlvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLXNuYWNrYmFyOjpjcmVhdGUnOiBmdW5jdGlvbiB1aVNuYWNrYmFyQ3JlYXRlKHNuYWNrYmFyKSB7XHJcblx0ICAgICAgICAgICAgc25hY2tiYXIuc2hvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHNuYWNrYmFyLmlkID0gc25hY2tiYXIuaWQgfHwgX3V1aWQyLmRlZmF1bHQuc2hvcnQoJ3VpLXNuYWNrYmFyLScpO1xyXG5cdCAgICAgICAgICAgIHNuYWNrYmFyLmR1cmF0aW9uID0gc25hY2tiYXIuZHVyYXRpb24gfHwgdGhpcy5kZWZhdWx0RHVyYXRpb247XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHNuYWNrYmFyKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93TmV4dCgpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5xdWV1ZVNuYWNrYmFycykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVswXS5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHF1ZXVlOiBbXSB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBzaG93TmV4dDogZnVuY3Rpb24gc2hvd05leHQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucXVldWVbMF0uc2hvdyA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd246IGZ1bmN0aW9uIHNob3duKHNuYWNrYmFyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3NuYWNrYmFyLXNob3duJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY2FsbEhvb2soJ29uU2hvdycsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRkZW46IGZ1bmN0aW9uIGhpZGRlbihzbmFja2Jhcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzbmFja2Jhci1oaWRkZW4nLCBzbmFja2Jhcik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jYWxsSG9vaygnb25IaWRlJywgc25hY2tiYXIpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucXVldWUuJHJlbW92ZShzbmFja2Jhcik7XHJcblx0ICAgICAgICAgICAgdGhpcy5zaG93TmV4dCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsaWNrZWQ6IGZ1bmN0aW9uIGNsaWNrZWQoc25hY2tiYXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNhbGxIb29rKCdvbkNsaWNrJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGFjdGlvbkNsaWNrZWQ6IGZ1bmN0aW9uIGFjdGlvbkNsaWNrZWQoc25hY2tiYXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNhbGxIb29rKCdvbkFjdGlvbkNsaWNrJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNhbGxIb29rOiBmdW5jdGlvbiBjYWxsSG9vayhob29rLCBzbmFja2Jhcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygc25hY2tiYXJbaG9va10gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgc25hY2tiYXJbaG9va10uY2FsbCh1bmRlZmluZWQsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpU25hY2tiYXI6IF9VaVNuYWNrYmFyMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTkxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktc25hY2tiYXItY29udGFpbmVyXFxcIiA6Y2xhc3M9XFxcIltwb3NpdGlvbl1cXFwiPlxcbiAgICA8dWktc25hY2tiYXJcXG4gICAgICAgIDpkdXJhdGlvbj1cXFwicy5kdXJhdGlvblxcXCIgOnNob3cuc3luYz1cXFwicy5zaG93XFxcIiA6YWN0aW9uPVxcXCJzLmFjdGlvblxcXCJcXG4gICAgICAgIDphY3Rpb24tY29sb3I9XFxcInMuYWN0aW9uQ29sb3JcXFwiIDpwZXJzaXN0ZW50PVxcXCJzLnBlcnNpc3RlbnRcXFwiIDppZD1cXFwicy5pZFxcXCIgYXV0by1oaWRlXFxuXFxuICAgICAgICBAc2hvd249XFxcInNob3duKHMpXFxcIiBAaGlkZGVuPVxcXCJoaWRkZW4ocylcXFwiIEBjbGlja2VkPVxcXCJjbGlja2VkKHMpXFxcIlxcbiAgICAgICAgQGFjdGlvbi1jbGlja2VkPVxcXCJhY3Rpb25DbGlja2VkKHMpXFxcIlxcblxcbiAgICAgICAgdi1mb3I9XFxcInMgaW4gcXVldWVcXFwiXFxuICAgID5cXG4gICAgICAgIDxkaXYgdi1odG1sPVxcXCJzLm1lc3NhZ2VcXFwiIHYtaWY9XFxcInMuYWxsb3dIdG1sXFxcIj48L2Rpdj5cXG4gICAgICAgIDxzcGFuIHYtdGV4dD1cXFwicy5tZXNzYWdlXFxcIiB2LWVsc2U+PC9zcGFuPlxcbiAgICA8L3VpLXNuYWNrYmFyPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTkyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk0KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU3dpdGNoLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk1KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU3dpdGNoLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktc3dpdGNoJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG5hbWU6IFN0cmluZyxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsTGVmdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTk1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGxhYmVsXFxuICAgIGNsYXNzPVxcXCJ1aS1zd2l0Y2hcXFwiXFxuICAgIDpjbGFzcz1cXFwieyAnY2hlY2tlZCc6IHZhbHVlLCAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2xhYmVsLWxlZnQnOiBsYWJlbExlZnQgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXN3aXRjaC1jb250YWluZXJcXFwiPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXN3aXRjaC1pbnB1dFxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIiA6aWQ9XFxcImlkXFxcIiB2LW1vZGVsPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgID5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXN3aXRjaC10cmFja1xcXCI+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zd2l0Y2gtdGh1bWJcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc3dpdGNoLWZvY3VzLXJpbmdcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc3dpdGNoLWxhYmVsLXRleHRcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJsYWJlbFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9zbG90PlxcbiAgICA8L2Rpdj5cXG48L2xhYmVsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTk2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE5NylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk4KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVGFiLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk5KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVGFiLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10YWInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIGhlYWRlcjogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZSgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy4kcGFyZW50LmFjdGl2ZVRhYiA9PT0gdGhpcy5pZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2VsZWN0ZWQnLCB0aGlzLmlkKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGVzZWxlY3RlZCcsIHRoaXMuaWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS10YWJcXFwiIDppZD1cXFwiaWRcXFwiIHJvbGU9XFxcInRhYnBhbmVsXFxcIiA6dGFiaW5kZXg9XFxcImFjdGl2ZSA/ICcwJyA6IG51bGxcXFwiXFxuICAgIDphcmlhLWhpZGRlbj1cXFwiIWFjdGl2ZSA/ICd0cnVlJyA6IG51bGxcXFwiIHYtc2hvdz1cXFwiYWN0aXZlXFxcIlxcbj5cXG4gICAgPHNsb3Q+PC9zbG90PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjAwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjAyKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVGFicy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNylcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRhYnMudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG5cdFxyXG5cdHZhciBfdXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dWlkKTtcclxuXHRcclxuXHR2YXIgX1VpVGFiSGVhZGVySXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMjAzKTtcclxuXHRcclxuXHR2YXIgX1VpVGFiSGVhZGVySXRlbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRhYkhlYWRlckl0ZW0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10YWJzJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnIH0sXHJcblx0ICAgICAgICBhY3RpdmVUYWI6IFN0cmluZyxcclxuXHQgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnYmFja2dyb3VuZC1jb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRleHRDb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnYmxhY2snLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQtY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0ZXh0Q29sb3JBY3RpdmU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQtY29sb3ItYWN0aXZlLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaW5kaWNhdG9yQ29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZnVsbHdpZHRoOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJhaXNlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlUmlwcGxlSW5rOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmVUYWJFbGVtZW50OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc3R5bGVDbGFzc2VzOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ3VpLXRhYnMtdHlwZS0nICsgdGhpcy50eXBlXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5yYWlzZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdyYWlzZWQnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZnVsbHdpZHRoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZnVsbHdpZHRoJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGluZGljYXRvckxlZnQ6IGZ1bmN0aW9uIGluZGljYXRvckxlZnQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUYWJFbGVtZW50Lm9mZnNldExlZnQgKyAncHgnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gMDtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmRpY2F0b3JSaWdodDogZnVuY3Rpb24gaW5kaWNhdG9yUmlnaHQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuYWN0aXZlVGFiRWxlbWVudC5vZmZzZXRMZWZ0O1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0YWJDb250YWluZXJXaWR0aCA9IHRoaXMuJGVscy50YWJzQ29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGFiQ29udGFpbmVyV2lkdGggLSAobGVmdCArIHdpZHRoKSArICdweCc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuW2ldLmlkID0gdGhpcy4kY2hpbGRyZW5baV0uaWQgfHwgX3V1aWQyLmRlZmF1bHQuc2hvcnQoJ3VpLXRhYi0nKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuYWN0aXZlVGFiID0gdGhpcy5hY3RpdmVUYWIgfHwgdGhpcy4kY2hpbGRyZW5bMF0uaWQ7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKF90aGlzLiRlbHMudGFic0NvbnRhaW5lcikge1xyXG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVUYWJFbGVtZW50ID0gX3RoaXMuJGVscy50YWJzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktdGFiczo6c2VsZWN0JzogZnVuY3Rpb24gdWlUYWJzU2VsZWN0KHRhYklkLCBpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIHRhYiA9IHRoaXMuZmluZFRhYkJ5SWQodGFiSWQpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0YWIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodGFiLiRlbCwgdGFiKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGUsIHRhYikge1xyXG5cdCAgICAgICAgICAgIHZhciBuZXdUYWJFbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0IDogZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGFiLmRpc2FibGVkIHx8IHRoaXMuYWN0aXZlVGFiRWxlbWVudCA9PT0gbmV3VGFiRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiRWxlbWVudCA9IG5ld1RhYkVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWIgPSB0YWIuaWQ7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FjdGl2ZS10YWItY2hhbmdlZCcsIHRhYi5pZCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0UHJldjogZnVuY3Rpb24gc2VsZWN0UHJldihjdXJyZW50VGFiSW5kZXgpIHtcclxuXHQgICAgICAgICAgICBpZiAoY3VycmVudFRhYkluZGV4ID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZUYWIgPSB0aGlzLmZpbmRUYWIoY3VycmVudFRhYkluZGV4KTtcclxuXHQgICAgICAgICAgICB0aGlzLnNlbGVjdChwcmV2VGFiLiRlbCwgcHJldlRhYik7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJFbGVtZW50LmZvY3VzKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0TmV4dDogZnVuY3Rpb24gc2VsZWN0TmV4dChjdXJyZW50VGFiSW5kZXgpIHtcclxuXHQgICAgICAgICAgICBpZiAoY3VycmVudFRhYkluZGV4ID09PSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzLmxlbmd0aCAtIDEpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgbmV4dFRhYiA9IHRoaXMuZmluZFRhYihjdXJyZW50VGFiSW5kZXgsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2VsZWN0KG5leHRUYWIuJGVsLCBuZXh0VGFiKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQuZm9jdXMoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmaW5kVGFiOiBmdW5jdGlvbiBmaW5kVGFiKGN1cnJlbnRUYWJJbmRleCwgbmV4dCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0YWIgPSB2b2lkIDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRUYWJJbmRleCArIDE7IGkgPCB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMudGFiRWxlbWVudHNbaV0uZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWIgPSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSBjdXJyZW50VGFiSW5kZXggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMudGFiRWxlbWVudHNbX2ldLmRpc2FibGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFiID0gdGhpcy4kcmVmcy50YWJFbGVtZW50c1tfaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGFiID0gdGFiIHx8IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbY3VycmVudFRhYkluZGV4XTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGFiO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZpbmRUYWJCeUlkOiBmdW5jdGlvbiBmaW5kVGFiQnlJZChpZCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0YWIgPSBudWxsO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBudW1PZlRhYnMgPSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzLmxlbmd0aDtcclxuXHRcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBudW1PZlRhYnM7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoaWQgPT09IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbaV0uaWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhYiA9IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGFiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVRhYkhlYWRlckl0ZW06IF9VaVRhYkhlYWRlckl0ZW0yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjA0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDUpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUYWJIZWFkZXJJdGVtLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVGFiSGVhZGVySXRlbS52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjA0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjA1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXRhYi1oZWFkZXItaXRlbScsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nLFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndGV4dCcgfSxcclxuXHQgICAgICAgIHRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGFjdGl2ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1JpcHBsZUluazIuZGVmYXVsdF0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGlcXG4gICAgY2xhc3M9XFxcInVpLXRhYi1oZWFkZXItaXRlbVxcXCIgcm9sZT1cXFwidGFiXFxcIlxcbiAgICA6Y2xhc3M9XFxcIlsndHlwZS0nICsgdHlwZSwgeyAnYWN0aXZlJzogYWN0aXZlLCAnZGlzYWJsZWQnOiBkaXNhYmxlZCB9XVxcXCJcXG5cXG4gICAgOnRhYmluZGV4PVxcXCJhY3RpdmUgPyAwIDogLTFcXFwiIDphcmlhLWNvbnRyb2xzPVxcXCJpZFxcXCIgOmFyaWEtc2VsZWN0ZWQ9XFxcImFjdGl2ZSA/ICd0cnVlJyA6IG51bGxcXFwiXFxuICAgIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB2LWVsOml0ZW1cXG4+XFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS10YWItaGVhZGVyLWl0ZW0taWNvblxcXCIgdi1pZj1cXFwidHlwZSA9PT0gJ2ljb24nIHx8IHR5cGUgPT09ICdpY29uLWFuZC10ZXh0J1xcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiPjwvdWktaWNvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS10YWItaGVhZGVyLWl0ZW0tdGV4dFxcXCIgdi10ZXh0PVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgdi1pZj1cXFwidHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdpY29uLWFuZC10ZXh0J1xcXCJcXG4gICAgPjwvZGl2PlxcblxcbiAgICA8dWktcmlwcGxlLWluayA6dHJpZ2dlcj1cXFwiJGVscy5pdGVtXFxcIiB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiPjwvdWktcmlwcGxlLWluaz5cXG48L2xpPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjA3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktdGFic1xcXCIgOmNsYXNzPVxcXCJzdHlsZUNsYXNzZXNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10YWJzLWhlYWRlclxcXCIgOmNsYXNzPVxcXCJbYmFja2dyb3VuZENvbG9yXVxcXCI+XFxuICAgICAgICA8dWxcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktdGFicy1oZWFkZXItaXRlbXNcXFwiIDpjbGFzcz1cXFwiW3RleHRDb2xvciwgdGV4dENvbG9yQWN0aXZlXVxcXCIgcm9sZT1cXFwidGFibGlzdFxcXCJcXG4gICAgICAgICAgICB2LWVsOnRhYnMtY29udGFpbmVyXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPHVpLXRhYi1oZWFkZXItaXRlbVxcbiAgICAgICAgICAgICAgICA6dHlwZT1cXFwidHlwZVxcXCIgOmlkPVxcXCJ0YWIuaWRcXFwiIDppY29uPVxcXCJ0YWIuaWNvblxcXCIgOnRleHQ9XFxcInRhYi5oZWFkZXJcXFwiXFxuICAgICAgICAgICAgICAgIDphY3RpdmU9XFxcImFjdGl2ZVRhYiA9PT0gdGFiLmlkXFxcIiA6ZGlzYWJsZWQ9XFxcInRhYi5kaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgOmhpZGUtcmlwcGxlLWluaz1cXFwiaGlkZVJpcHBsZUlua1xcXCJcXG5cXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJzZWxlY3QoJGV2ZW50LCB0YWIpXFxcIiBAa2V5ZG93bi5sZWZ0PVxcXCJzZWxlY3RQcmV2KGluZGV4KVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24ucmlnaHQ9XFxcInNlbGVjdE5leHQoJGluZGV4KVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgdi1mb3I9XFxcIihpbmRleCwgdGFiKSBpbiAkY2hpbGRyZW5cXFwiIHYtcmVmOnRhYi1lbGVtZW50c1xcbiAgICAgICAgICAgID48L3VpLXRhYi1oZWFkZXItaXRlbT5cXG4gICAgICAgIDwvdWw+XFxuXFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRhYnMtYWN0aXZlLXRhYi1pbmRpY2F0b3JcXFwiIDpjbGFzcz1cXFwiW2luZGljYXRvckNvbG9yXVxcXCJcXG4gICAgICAgICAgICA6c3R5bGU9XFxcInsgJ2xlZnQnOiBpbmRpY2F0b3JMZWZ0LCAncmlnaHQnOiBpbmRpY2F0b3JSaWdodCB9XFxcIlxcbiAgICAgICAgPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktdGFicy1ib2R5XFxcIj5cXG4gICAgICAgIDxzbG90Pjwvc2xvdD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjA5KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTApXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUZXh0Ym94LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjExKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVGV4dGJveC52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjA5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjEwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9hdXRvZm9jdXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcclxuXHRcclxuXHR2YXIgX2F1dG9mb2N1czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hdXRvZm9jdXMpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XHJcblx0XHJcblx0dmFyIF9IYXNUZXh0SW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGFzVGV4dElucHV0KTtcclxuXHRcclxuXHR2YXIgX1ZhbGlkYXRlc0lucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WYWxpZGF0ZXNJbnB1dCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10ZXh0Ym94JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbXVsdGlMaW5lOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJvd3M6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogMlxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1heExlbmd0aDogTnVtYmVyLFxyXG5cdCAgICAgICAgdHJpbVZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdmFsaWRhdGVPbkJsdXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYXV0b2NvbXBsZXRlOiBTdHJpbmcsXHJcblx0ICAgICAgICBhdXRvZm9jdXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbWluOiBOdW1iZXIsXHJcblx0ICAgICAgICBtYXg6IE51bWJlcixcclxuXHQgICAgICAgIHN0ZXA6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2FueScsXHJcblx0ICAgICAgICAgICAgY29lcmNlOiBTdHJpbmdcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5pZ25vcmVWYWx1ZUNoYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlT25CbHVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGlnbm9yZVZhbHVlQ2hhbmdlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHNob3dJY29uOiBmdW5jdGlvbiBzaG93SWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmljb24pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1pblZhbHVlOiBmdW5jdGlvbiBtaW5WYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWluIHx8IHRoaXMubWluID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbWF4VmFsdWU6IGZ1bmN0aW9uIG1heFZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXggfHwgdGhpcy5tYXggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdGVwVmFsdWU6IGZ1bmN0aW9uIHN0ZXBWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktaW5wdXQ6OnJlc2V0JzogZnVuY3Rpb24gdWlJbnB1dFJlc2V0KGlkKSB7XHJcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaWdub3JlVmFsdWVDaGFuZ2UgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJykpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yID0gJyc7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzLmlnbm9yZVZhbHVlQ2hhbmdlID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGZvY3Vzc2VkOiBmdW5jdGlvbiBmb2N1c3NlZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2ZvY3Vzc2VkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cnJlZDogZnVuY3Rpb24gYmx1cnJlZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2JsdXJyZWQnKTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2hhbmdlZDogZnVuY3Rpb24gY2hhbmdlZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2hhbmdlZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdrZXlkb3duJywgZSk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAga2V5ZG93bkVudGVyOiBmdW5jdGlvbiBrZXlkb3duRW50ZXIoZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdrZXlkb3duLWVudGVyJywgZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGZpbHRlcnM6IHtcclxuXHQgICAgICAgIHRyaW06IHtcclxuXHQgICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ251bWJlcicgJiYgdGhpcy50cmltVmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGF1dG9mb2N1czogX2F1dG9mb2N1czIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfSGFzVGV4dElucHV0Mi5kZWZhdWx0LCBfVmFsaWRhdGVzSW5wdXQyLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXRleHRib3hcXFwiXFxuICAgIDpjbGFzcz1cXFwie1xcbiAgICAgICAgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdpbnZhbGlkJzogIXZhbGlkLCAnZGlydHknOiBkaXJ0eSwgJ2FjdGl2ZSc6IGFjdGl2ZSxcXG4gICAgICAgICdoYXMtbGFiZWwnOiAhaGlkZUxhYmVsLCAnaXMtbXVsdGktbGluZSc6IG11bHRpTGluZSwgJ2ljb24tcmlnaHQnOiBpY29uUmlnaHQsXFxuICAgICAgICAnaGFzLWNvdW50ZXInOiBtYXhMZW5ndGhcXG4gICAgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRleHRib3gtaWNvbi13cmFwcGVyXFxcIiB2LWlmPVxcXCJzaG93SWNvblxcXCI+XFxuICAgICAgICA8dWktaWNvbiA6aWNvbj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInVpLXRleHRib3gtaWNvblxcXCI+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktdGV4dGJveC1jb250ZW50XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidWktdGV4dGJveC1sYWJlbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdGV4dGJveC1sYWJlbC10ZXh0XFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtaW5wdXRcXFwiIDp0eXBlPVxcXCJ0eXBlXFxcIiA6cGxhY2Vob2xkZXI9XFxcInBsYWNlaG9sZGVyXFxcIiA6bmFtZT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgOmlkPVxcXCJpZFxcXCIgOm51bWJlcj1cXFwidHlwZSA9PT0gJ251bWJlcicgPyB0cnVlIDogbnVsbFxcXCIgOm1pbj1cXFwibWluVmFsdWVcXFwiXFxuICAgICAgICAgICAgICAgIDptYXg9XFxcIm1heFZhbHVlXFxcIiA6c3RlcD1cXFwic3RlcFZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgICA6YXV0b2NvbXBsZXRlPVxcXCJhdXRvY29tcGxldGUgPyBhdXRvY29tcGxldGUgOiBudWxsXFxcIlxcblxcbiAgICAgICAgICAgICAgICBAZm9jdXM9XFxcImZvY3Vzc2VkXFxcIiBAYmx1cj1cXFwiYmx1cnJlZFxcXCIgQGNoYW5nZT1cXFwiY2hhbmdlZFxcXCIgQGtleWRvd249XFxcImtleWRvd25cXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVudGVyPVxcXCJrZXlkb3duRW50ZXJcXFwiIDpkZWJvdW5jZT1cXFwiZGVib3VuY2VcXFwiXFxuXFxuICAgICAgICAgICAgICAgIHYtbW9kZWw9XFxcInZhbHVlIHwgdHJpbVxcXCIgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHYtaWY9XFxcIiFtdWx0aUxpbmVcXFwiXFxuICAgICAgICAgICAgICAgIHYtYXV0b2ZvY3VzPVxcXCJhdXRvZm9jdXNcXFwiXFxuICAgICAgICAgICAgPlxcblxcbiAgICAgICAgICAgIDx0ZXh0YXJlYVxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktdGV4dGJveC10ZXh0YXJlYVxcXCIgOnBsYWNlaG9sZGVyPVxcXCJwbGFjZWhvbGRlclxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiIDppZD1cXFwiaWRcXFwiXFxuICAgICAgICAgICAgICAgIDpyb3dzPVxcXCJyb3dzXFxcIlxcblxcbiAgICAgICAgICAgICAgICBAZm9jdXM9XFxcImZvY3Vzc2VkXFxcIiBAYmx1cj1cXFwiYmx1cnJlZFxcXCIgQGNoYW5nZT1cXFwiY2hhbmdlZFxcXCIgQGtleWRvd249XFxcImtleWRvd25cXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVudGVyPVxcXCJrZXlkb3duRW50ZXJcXFwiIDpkZWJvdW5jZT1cXFwiZGVib3VuY2VcXFwiXFxuXFxuICAgICAgICAgICAgICAgIHYtbW9kZWw9XFxcInZhbHVlIHwgdHJpbVxcXCIgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHYtZWxzZVxcbiAgICAgICAgICAgID48L3RleHRhcmVhPlxcbiAgICAgICAgPC9sYWJlbD5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRleHRib3gtZmVlZGJhY2tcXFwiIHYtaWY9XFxcInNob3dGZWVkYmFjayB8fCBtYXhMZW5ndGhcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtZXJyb3ItdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktdGV4dGJveC1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwidmFsaWRhdGlvbkVycm9yXFxcIiB2LXNob3c9XFxcIiFoaWRlVmFsaWRhdGlvbkVycm9ycyAmJiAhdmFsaWRcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtaGVscC10ZXh0XFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS10ZXh0Ym94LWZlZWRiYWNrLXRvZ2dsZVxcXCJcXG4gICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCIgdi1lbHNlXFxuICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtY291bnRlclxcXCIgdi10ZXh0PVxcXCJ2YWx1ZS5sZW5ndGggKyAnLycgKyBtYXhMZW5ndGhcXFwiXFxuICAgICAgICAgICAgICAgIHYtaWY9XFxcIm1heExlbmd0aFxcXCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMTIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjEzKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUb29sYmFyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjE1KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpVG9vbGJhci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjEzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMjE0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzTGluZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0xpbmVhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVByb2dyZXNzTGluZWFyKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10b29sYmFyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndWktdG9vbGJhci0nICsgdHlwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGV4dENvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdibGFjaycsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndGV4dC1jb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRpdGxlOiBTdHJpbmcsXHJcblx0ICAgICAgICBicmFuZDogU3RyaW5nLFxyXG5cdCAgICAgICAgc2hvd0JyYW5kOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dCcmFuZERpdmlkZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBuYXZJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdtZW51J1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhpZGVOYXZJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZsYXQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcHJlbG9hZGVyVG9wOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxvYWRpbmc6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzdHlsZUNsYXNzZXM6IGZ1bmN0aW9uIHN0eWxlQ2xhc3NlcygpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFt0aGlzLnR5cGUsIHRoaXMudGV4dENvbG9yXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZmxhdCkge1xyXG5cdCAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ3VpLXRvb2xiYXItcmFpc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb25Db2xvcjogZnVuY3Rpb24gaWNvbkNvbG9yKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnRleHRDb2xvciA9PT0gJ3RleHQtY29sb3ItYmxhY2snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnYmxhY2snO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gJ3doaXRlJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwcmVsb2FkZXJDb2xvcjogZnVuY3Rpb24gcHJlbG9hZGVyQ29sb3IoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudGV4dENvbG9yID09PSAndGV4dC1jb2xvci1ibGFjaycpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdwcmltYXJ5JztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICd3aGl0ZSc7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYnJhbmREaXZpZGVyVmlzaWJsZTogZnVuY3Rpb24gYnJhbmREaXZpZGVyVmlzaWJsZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93QnJhbmREaXZpZGVyICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dCcmFuZERpdmlkZXI7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zaG93QnJhbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgbmF2SWNvbkNsaWNrOiBmdW5jdGlvbiBuYXZJY29uQ2xpY2soKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ25hdi1pY29uLWNsaWNrZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlQcm9ncmVzc0xpbmVhcjogX1VpUHJvZ3Jlc3NMaW5lYXIyLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaUljb25CdXR0b246IF9VaUljb25CdXR0b24yLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyXFxcIiA6Y2xhc3M9XFxcInN0eWxlQ2xhc3Nlc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItbGVmdFxcXCI+XFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktdG9vbGJhci1uYXYtaWNvblxcXCIgdHlwZT1cXFwiY2xlYXJcXFwiIDpjb2xvcj1cXFwiaWNvbkNvbG9yXFxcIiA6aWNvbj1cXFwibmF2SWNvblxcXCJcXG4gICAgICAgICAgICBAY2xpY2s9XFxcIm5hdkljb25DbGlja1xcXCIgdi1pZj1cXFwiIWhpZGVOYXZJY29uXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLWJyYW5kXFxcIiB2LWlmPVxcXCJzaG93QnJhbmRcXFwiPlxcbiAgICAgICAgICAgIDxzbG90IG5hbWU9XFxcImJyYW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdG9vbGJhci1icmFuZC10ZXh0XFxcIiB2LXRleHQ9XFxcImJyYW5kXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItY2VudGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItZGl2aWRlclxcXCIgdi1pZj1cXFwiYnJhbmREaXZpZGVyVmlzaWJsZVxcXCI+PC9kaXY+XFxuXFxuICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLXRpdGxlXFxcIiB2LXRleHQ9XFxcInRpdGxlXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvc2xvdD5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItcmlnaHRcXFwiPlxcbiAgICAgICAgPHNsb3QgbmFtZT1cXFwiYWN0aW9uc1xcXCI+PC9zbG90PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPHVpLXByb2dyZXNzLWxpbmVhclxcbiAgICAgICAgOnNob3c9XFxcImxvYWRpbmdcXFwiIGNsYXNzPVxcXCJ1aS10b29sYmFyLXByZWxvYWRlclxcXCIgOmNsYXNzPVxcXCJ7ICdwb3NpdGlvbi10b3AnIDogcHJlbG9hZGVyVG9wIH1cXFwiXFxuICAgICAgICA6Y29sb3I9XFxcInByZWxvYWRlckNvbG9yXFxcIlxcbiAgICA+PC91aS1wcm9ncmVzcy1saW5lYXI+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9XHJcbi8qKioqKiovIF0pXHJcbn0pO1xyXG47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlZW4tdWkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34va2Vlbi11aS9kaXN0L2tlZW4tdWkuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXEFwcC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BcHAudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtN2NhMWIxYmIvQXBwLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9BcHAudnVlXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLWFwcFwiPlxyXG4gICAgICAgIDx1aS10YWJzXHJcbiAgICAgICAgICAgIGNsYXNzPVwibWFpbi10YWItY29udGFpbmVyXCIgYmFja2dyb3VuZC1jb2xvcj1cImRhcmtcIiB0ZXh0LWNvbG9yPVwibGlnaHRcIlxyXG4gICAgICAgICAgICBpbmRpY2F0b3ItY29sb3I9XCJ0cmFuc3BhcmVudFwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8dWktdGFiIGhlYWRlcj1cIk1hcFwiPlxyXG4gICAgICAgICAgICAgICAgPG1hcC12aWV3PjwvbWFwLXZpZXc+XHJcbiAgICAgICAgICAgIDwvdWktdGFiPlxyXG5cclxuICAgICAgICAgICAgPHVpLXRhYiBoZWFkZXI9XCJQYXJhbXNcIj5cclxuICAgICAgICAgICAgICAgIDxwYXJhbXMtdmlldz48L3BhcmFtcy12aWV3PlxyXG4gICAgICAgICAgICA8L3VpLXRhYj5cclxuXHJcbiAgICAgICAgICAgIDx1aS10YWIgaGVhZGVyPVwiU2V0dGluZ3NcIj5cclxuICAgICAgICAgICAgICAgIDxzZXR0aW5ncy12aWV3Pjwvc2V0dGluZ3Mtdmlldz5cclxuICAgICAgICAgICAgPC91aS10YWI+XHJcbiAgICAgICAgPC91aS10YWJzPlxyXG5cclxuICAgICAgICA8Z2NzLWluZGljYXRvcnM+PC9nY3MtaW5kaWNhdG9ycz5cclxuXHJcbiAgICAgICAgPHVpLXNuYWNrYmFyLWNvbnRhaW5lciBwb3NpdGlvbj1cImNlbnRlclwiPjwvdWktc25hY2tiYXItY29udGFpbmVyPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLSA8c29ja2V0LWlvLW1hbmFnZXI+PC9zb2NrZXQtaW8tbWFuYWdlcj4gLS0+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgdXVpZCBmcm9tICd1dGlsL3V1aWQnO1xyXG5pbXBvcnQgc29ja2V0X2lvX2NsaWVudCBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcclxuXHJcbmltcG9ydCBNYXBWaWV3IGZyb20gJ3ZpZXdzL01hcFZpZXcudnVlJztcclxuaW1wb3J0IFBhcmFtc1ZpZXcgZnJvbSAndmlld3MvUGFyYW1zVmlldy52dWUnO1xyXG5pbXBvcnQgU2V0dGluZ3NWaWV3IGZyb20gJ3ZpZXdzL1NldHRpbmdzVmlldy52dWUnO1xyXG5pbXBvcnQgR2NzSW5kaWNhdG9ycyBmcm9tICdjb21wb25lbnRzL0djc0luZGljYXRvcnMudnVlJztcclxuLy8gaW1wb3J0IFNvY2tldElvTWFuYWdlciBmcm9tICdjb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWUnO1xyXG5cclxuaW1wb3J0IHsgc2V0V2Ftdiwgc2V0UGFyYW1ldGVycywgc2V0TWlzc2lvbnMsIHNldEN1cnJlbnRNaXNzaW9uIH0gZnJvbSAnc3RvcmUvYWN0aW9ucyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgYWN0aW9uczoge1xyXG4gICAgICAgICAgICBzZXRXYW12LFxyXG4gICAgICAgICAgICBzZXRQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICBzZXRNaXNzaW9ucyxcclxuICAgICAgICAgICAgc2V0Q3VycmVudE1pc3Npb25cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc29ja2V0OiBudWxsLFxyXG4gICAgICAgICAgICBzZW50TWVzc2FnZUlkczogW10sXHJcbiAgICAgICAgICAgIHRpbWVkb3V0TWVzc2FnZUlkczogW10sXHJcbiAgICAgICAgICAgIHRpbWVvdXRzOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgIHRoaXMuc2V0dXBTb2NrZXQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICAgJ3NlbmQtdG8tc2VydmVyJyhtZXNzYWdlVHlwZSwgZGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgbWVzc2FnZUlkID0gdXVpZC5nZW5lcmF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdChtZXNzYWdlVHlwZSwgZGF0YSwgbWVzc2FnZUlkKTtcclxuICAgICAgICAgICAgdGhpcy5zZW50TWVzc2FnZUlkcy5wdXNoKG1lc3NhZ2VJZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRzW21lc3NhZ2VJZF0gPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVkb3V0TWVzc2FnZUlkcy5wdXNoKG1lc3NhZ2VJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3NlcnZlci1tZXNzYWdlLXRpbWVvdXQnLCBtZXNzYWdlVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RpbWVvdXQgcmVhY2hlZCBmb3IgbWVzc2FnZScsIG1lc3NhZ2VUeXBlKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0c1ttZXNzYWdlSWRdKTtcclxuICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJyhtZXNzYWdlLCBzbmFja2Jhcikge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNuYWNrYmFyKG1lc3NhZ2UsIHNuYWNrYmFyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tdXAnKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6cGFuLXVwJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6cGFuLWRvd24nKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6cGFuLWRvd24nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tbGVmdCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpwYW4tbGVmdCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OnBhbi1yaWdodCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpwYW4tcmlnaHQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tY2VudGVyJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6OnBhbi1jZW50ZXInKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjp6b29tLWluJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6Onpvb20taW4nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjp6b29tLW91dCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjp6b29tLW91dCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OmNoYW5nZS10eXBlJyhuZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpjaGFuZ2UtdHlwZScsIG5ld1R5cGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6Y2xpY2snKGUpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6Y2xpY2snLCBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOmRibGNsaWNrJyhlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOmRibGNsaWNrJywgZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDpyaWdodGNsaWNrJyhlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOnJpZ2h0Y2xpY2snLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBjcmVhdGVTbmFja2JhcihtZXNzYWdlLCBzbmFja2Jhcikge1xyXG4gICAgICAgICAgICBzbmFja2JhciA9IHNuYWNrYmFyIHx8IHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgndWktc25hY2tiYXI6OmNyZWF0ZScsIHNuYWNrYmFyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXR1cFNvY2tldCgpIHtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSBzb2NrZXRcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRfaW9fY2xpZW50KCdsb2NhbGhvc3Q6MzAwMCcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ2Nvbm5lY3QnLCB0aGlzLm9uQ29ubmVjdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgdGhpcy5vbkRpc2Nvbm5lY3QpO1xyXG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbignc3RhdHVzJyx0aGlzLm9uU3RhdHVzKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ2dldF9wYXJhbWV0ZXJzJywgdGhpcy5vblBhcmFtZXRlclJlY2VpdmVkKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ2xvYWRfbWlzc2lvbnMnLCB0aGlzLm9uTWlzc2lvbnNSZWNlaXZlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdkb3dubG9hZF9taXNzaW9uJywgdGhpcy5vbkN1cnJlbnRNaXNzaW9uUmVjZWl2ZWQpO1xyXG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbignc3VjY2VzcycsIHRoaXMub25TdWNjZXNzKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ2ZhaWx1cmUnLCB0aGlzLm9uRmFpbHVyZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdhdHRlbnRpb24nLCB0aGlzLm9uQXR0ZW50aW9uKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvbkNvbm5lY3QoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQgdG8gc2VydmVyJyk7XHJcblxyXG4gICAgICAgICAgICAvL2dldCBwYXJhbWV0ZXJzIG9uY2UgYXQgc3RhcnR1cFxyXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdzZW5kLXRvLXNlcnZlcicsICdnZXRfcGFyYW1ldGVycycpO1xyXG5cclxuICAgICAgICAgICAgLy9sb2FkIG1pc3Npb25zIG9uY2UgYXQgc3RhcnR1cFxyXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdzZW5kLXRvLXNlcnZlcicsICdsb2FkX21pc3Npb25zJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25EaXNjb25uZWN0KCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdGVkIGZyb20gc2VydmVyJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25TdWNjZXNzKG1lc3NhZ2VUeXBlLCBtZXNzYWdlSWQpIHtcclxuICAgICAgICAgICAgLy8gY2xlYXIgdGltZW91dCBmb3IgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgLy8gYnJvYWRjYXN0IHRvIGNvbXBvbmVudHNcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gc2VudE1lc3NhZ2VzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVkb3V0TWVzc2FnZUlkcy5pbmRleE9mKG1lc3NhZ2VJZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3NlcnZlci1tZXNzYWdlLXN1Y2Nlc3MnLCBtZXNzYWdlVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhblVwKG1lc3NhZ2VJZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNlaXZlZCBcInN1Y2Nlc3NcIiBtZXNzYWdlJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25GYWlsdXJlKG1lc3NhZ2VUeXBlLCBtZXNzYWdlSWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZWRvdXRNZXNzYWdlSWRzLmluZGV4T2YobWVzc2FnZUlkKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2VydmVyLW1lc3NhZ2UtZmFpbHVyZScsIG1lc3NhZ2VUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXAobWVzc2FnZUlkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmVkIFwiZmFpbHVyZVwiIG1lc3NhZ2UnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvblN0YXR1cyhkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlY2VpdmVkIFwic3RhdHVzXCIgbWVzc2FnZScpO1xyXG4gICAgICAgICAgICBkYXRhLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V2FtdihkYXRhKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvblBhcmFtZXRlclJlY2VpdmVkKGRhdGEsIG1lc3NhZ2VJZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncmVjZWl2ZWQgXCJnZXRfcGFyYW1ldGVyc1wiIG1lc3NhZ2UnLCBtZXNzYWdlSWQpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnMoZGF0YSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAobWVzc2FnZUlkKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvbk1pc3Npb25zUmVjZWl2ZWQoZGF0YSwgbWVzc2FnZUlkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNlaXZlZCBcImxvYWRfbWlzc2lvbnNcIiBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnMoZGF0YSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAobWVzc2FnZUlkKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvbkN1cnJlbnRNaXNzaW9uUmVjZWl2ZWQoZGF0YSwgbWVzc2FnZUlkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNlaXZlZCBcImRvd25sb2FkX21pc3Npb25cIiBtZXNzYWdlOicpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaXNzaW9uKGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKG1lc3NhZ2VJZCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25BdHRlbnRpb24oZGF0YSwgbWVzc2FnZUlkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbnRpb246ICcgKyBkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKG1lc3NhZ2VJZCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xlYW5VcChtZXNzYWdlSWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RpbWVvdXRzJywgdGhpcy50aW1lb3V0cyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmluZyB0aW1lb3V0Jyx0aGlzLnRpbWVvdXRzW21lc3NhZ2VJZF0pO1xyXG5cclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRzW21lc3NhZ2VJZF0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlbnRNZXNzYWdlSWRzLiRyZW1vdmUobWVzc2FnZUlkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBNYXBWaWV3LFxyXG4gICAgICAgIFBhcmFtc1ZpZXcsXHJcbiAgICAgICAgU2V0dGluZ3NWaWV3LFxyXG4gICAgICAgIEdjc0luZGljYXRvcnNcclxuICAgICAgICAvLyBTb2NrZXRJb01hbmFnZXJcclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL21haW4nO1xyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBBcHAudnVlPzc5YmY5NjI0XG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01hcFZpZXcudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWFwVmlldy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcdmlld3NcXFxcTWFwVmlldy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9NYXBWaWV3LnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTEwNjg4N2ZhL01hcFZpZXcudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwidmlldyBtYXAtdmlld1wiPlxyXG4gICAgICAgIDxnY3MtbWFwPjwvZ2NzLW1hcD5cclxuICAgICAgICA8Z2NzLW1hcC1jb250cm9scz48L2djcy1tYXAtY29udHJvbHM+XHJcbiAgICAgICAgPGdjcy1tYXAtc2lkZWJhciA6c2hvdy1zaWRlYmFyPVwic2hvd1NpZGViYXJcIj48L2djcy1tYXAtc2lkZWJhcj5cclxuXHJcbiAgICAgICAgPGdjcy1zaWRlYmFyLWNvbnRyb2xzXHJcbiAgICAgICAgICAgIDpzaG93LXNpZGViYXI9XCJzaG93U2lkZWJhclwiIEB0b2dnbGUtc2lkZWJhcj1cInRvZ2dsZVNpZGViYXJcIlxyXG4gICAgICAgID48L2djcy1zaWRlYmFyLWNvbnRyb2xzPlxyXG5cclxuICAgICAgICA8Z2NzLXdhbXYgdi1pZj1cIndhbXYubG9hZGVkXCJcclxuICAgICAgICAgICAgOmxhdD1cIndhbXYucG9zaXRpb24ubGF0XCIgOmxuZz1cIndhbXYucG9zaXRpb24ubG5nXCJcclxuICAgICAgICAgICAgOnJvdGF0aW9uPVwid2Ftdi5oZWFkaW5nXCJcclxuICAgICAgICA+PC9nY3Mtd2Ftdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEdjc01hcCBmcm9tICdtYXAvR2NzTWFwLnZ1ZSc7XHJcbmltcG9ydCBHY3NNYXBDb250cm9scyBmcm9tICdtYXAvR2NzTWFwQ29udHJvbHMudnVlJztcclxuaW1wb3J0IEdjc01hcFNpZGViYXIgZnJvbSAnbWFwL0djc01hcFNpZGViYXIudnVlJztcclxuaW1wb3J0IEdjc1NpZGViYXJDb250cm9scyBmcm9tICdtYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZSc7XHJcbmltcG9ydCBHY3NXYW12IGZyb20gJ21hcmtlcnMvR2NzV2Ftdi52dWUnO1xyXG5cclxuaW1wb3J0IHsgZ2V0V2FtdiB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgd2FtdjogZ2V0V2FtdlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzaG93U2lkZWJhcjogdHJ1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICB0b2dnbGVTaWRlYmFyKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dTaWRlYmFyID0gIXRoaXMuc2hvd1NpZGViYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgR2NzTWFwLFxyXG4gICAgICAgIEdjc1dhbXYsXHJcbiAgICAgICAgR2NzTWFwQ29udHJvbHMsXHJcbiAgICAgICAgR2NzTWFwU2lkZWJhcixcclxuICAgICAgICBHY3NTaWRlYmFyQ29udHJvbHNcclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLnZpZXcubWFwLXZpZXcge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIE1hcFZpZXcudnVlPzcyMWU4NTUyXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01hcC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NNYXAudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcFxcXFxHY3NNYXAudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzTWFwLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTE4MjgxYzI1L0djc01hcC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLW1hcFwiIGlkPVwibWFwXCIgOmNsYXNzPVwieyAnZ2NzLW1hcC1lZGl0LW1vZGUnOiBtYXBFZGl0aW5nIH1cIj48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBjb3B5IGZyb20gJ3V0aWwvY29weS1vYmplY3QnO1xyXG5pbXBvcnQgbG9hZEdvb2dsZU1hcHNBUEkgZnJvbSAnbG9hZC1nb29nbGUtbWFwcy1hcGknO1xyXG5cclxuaW1wb3J0IHsgc2V0TWFwLCBzZXRNYXBFbCwgc2V0TWFwTG9hZGVkIH0gZnJvbSAnc3RvcmUvYWN0aW9ucyc7XHJcbmltcG9ydCB7IGdldFdhbXYsIGdldFNldHRpbmdzLCBnZXRDb25maWcsIGdldE1hcCwgZ2V0TWFwRWwsIGdldE1hcExvYWRlZCwgZ2V0TWFwRWRpdGluZyB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgbWFwOiBnZXRNYXAsXHJcbiAgICAgICAgICAgIG1hcEVsOiBnZXRNYXBFbCxcclxuICAgICAgICAgICAgbWFwTG9hZGVkOiBnZXRNYXBMb2FkZWQsXHJcbiAgICAgICAgICAgIG1hcEVkaXRpbmc6IGdldE1hcEVkaXRpbmcsXHJcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXYsXHJcbiAgICAgICAgICAgIGNvbmZpZzogZ2V0Q29uZmlnLFxyXG4gICAgICAgICAgICBzZXR0aW5nczogZ2V0U2V0dGluZ3NcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIHNldE1hcCxcclxuICAgICAgICAgICAgc2V0TWFwRWwsXHJcbiAgICAgICAgICAgIHNldE1hcExvYWRlZFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgd2F0Y2g6IHtcclxuICAgICAgICBtYXBFZGl0aW5nKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFZGl0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRPcHRpb25zKHsgZHJhZ2dhYmxlQ3Vyc29yOiAnY3Jvc3NoYWlyJyB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldE9wdGlvbnMoeyBkcmFnZ2FibGVDdXJzb3I6ICdtb3ZlJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRNYXBFbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwJykpO1xyXG5cclxuICAgICAgICBsb2FkR29vZ2xlTWFwc0FQSSh0aGlzLmNvbmZpZy5nb29nbGVNYXBzKVxyXG4gICAgICAgICAgICAudGhlbih0aGlzLmluaXRpYWxpemVNYXApXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gbG9hZCBHb29nbGUgTWFwcyBBUEknLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICAgJ21hcDo6cGFuLXVwJygpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAucGFuQnkoMCwgLTEgKiAodGhpcy5tYXBFbC5jbGllbnRIZWlnaHQgLyA0KSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6cGFuLWRvd24nKCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5wYW5CeSgwLCB0aGlzLm1hcEVsLmNsaWVudEhlaWdodCAvIDQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OnBhbi1sZWZ0JygpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAucGFuQnkoLTEgKiAodGhpcy5tYXBFbC5jbGllbnRXaWR0aCAvIDQpLCAwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tcmlnaHQnKCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5wYW5CeSh0aGlzLm1hcEVsLmNsaWVudFdpZHRoIC8gNCwgMCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6cGFuLWNlbnRlcicoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndhbXYubG9hZGVkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLnBhblRvKHRoaXMud2Ftdi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjp6b29tLWluJygpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbSh0aGlzLm1hcC5nZXRab29tKCkgKyAxKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjp6b29tLW91dCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFpvb20odGhpcy5tYXAuZ2V0Wm9vbSgpIC0gMSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6Y2hhbmdlLXR5cGUnKG5ld1R5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0TWFwVHlwZUlkKGdvb2dsZS5tYXBzLk1hcFR5cGVJZFtuZXdUeXBlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZU1hcCgpIHtcclxuICAgICAgICAgICAgbGV0IG1hcENvbmZpZyA9IGNvcHkodGhpcy5jb25maWcubWFwKTtcclxuXHJcbiAgICAgICAgICAgIG1hcENvbmZpZy5tYXBUeXBlSWQgPSBnb29nbGUubWFwcy5NYXBUeXBlSWRbdGhpcy5zZXR0aW5ncy5kZWZhdWx0TWFwVHlwZV07XHJcblxyXG4gICAgICAgICAgICBsZXQgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcCh0aGlzLm1hcEVsLCBtYXBDb25maWcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXR1cEV2ZW50cyhtYXApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRNYXAobWFwKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRNYXBMb2FkZWQodHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0dXBFdmVudHMobWFwKSB7XHJcbiAgICAgICAgICAgIG1hcC5hZGRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21hcDpjbGljaycsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG1hcC5hZGRMaXN0ZW5lcignZGJsY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21hcDpkYmxjbGljaycsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG1hcC5hZGRMaXN0ZW5lcigncmlnaHRjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOnJpZ2h0Y2xpY2snLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLW1hcCB7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIHotaW5kZXg6IDE7XHJcblxyXG4gICAgJi5nY3MtbWFwLWVkaXQtbW9kZSB7XHJcbiAgICAgICAgY3Vyc29yOiBjcm9zc2hhaXI7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWFwLnZ1ZT9iZTVkMDA3YVxuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdXRpbC9jb3B5LW9iamVjdC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBjbGllbnQgPSBfcmVmLmNsaWVudDtcbiAgdmFyIGtleSA9IF9yZWYua2V5O1xuICB2YXIgbGFuZ3VhZ2UgPSBfcmVmLmxhbmd1YWdlO1xuICB2YXIgX3JlZiRsaWJyYXJpZXMgPSBfcmVmLmxpYnJhcmllcztcbiAgdmFyIGxpYnJhcmllcyA9IF9yZWYkbGlicmFyaWVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYkbGlicmFyaWVzO1xuICB2YXIgX3JlZiR0aW1lb3V0ID0gX3JlZi50aW1lb3V0O1xuICB2YXIgdGltZW91dCA9IF9yZWYkdGltZW91dCA9PT0gdW5kZWZpbmVkID8gMTAwMDAgOiBfcmVmJHRpbWVvdXQ7XG4gIHZhciB2ID0gX3JlZi52O1xuXG4gIHZhciBjYWxsYmFja05hbWUgPSAnX19nb29nbGVNYXBzQXBpT25Mb2FkQ2FsbGJhY2snO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAvLyBFeGl0IGlmIG5vdCBydW5uaW5nIGluc2lkZSBhIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignQ2FuIG9ubHkgbG9hZCB0aGUgR29vZ2xlIE1hcHMgQVBJIGluIHRoZSBicm93c2VyJykpO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmUgdGhlIGBzY3JpcHRgIHRhZyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBwYWdlLlxuICAgIHZhciBzY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgdmFyIHBhcmFtcyA9IFsnY2FsbGJhY2s9JyArIGNhbGxiYWNrTmFtZV07XG4gICAgaWYgKGNsaWVudCkgcGFyYW1zLnB1c2goJ2NsaWVudD0nICsgY2xpZW50KTtcbiAgICBpZiAoa2V5KSBwYXJhbXMucHVzaCgna2V5PScgKyBrZXkpO1xuICAgIGlmIChsYW5ndWFnZSkgcGFyYW1zLnB1c2goJ2xhbmd1YWdlPScgKyBsYW5ndWFnZSk7XG4gICAgbGlicmFyaWVzID0gW10uY29uY2F0KGxpYnJhcmllcyk7IC8vIEVuc3VyZSB0aGF0IGBsaWJyYXJpZXNgIGlzIGFuIGFycmF5XG4gICAgaWYgKGxpYnJhcmllcy5sZW5ndGgpIHBhcmFtcy5wdXNoKCdsaWJyYXJpZXM9JyArIGxpYnJhcmllcy5qb2luKCcsJykpO1xuICAgIGlmICh2KSBwYXJhbXMucHVzaCgndj0nICsgdik7XG4gICAgc2NyaXB0RWxlbWVudC5zcmMgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzPycgKyBwYXJhbXMuam9pbignJicpO1xuXG4gICAgLy8gVGltZW91dCBpZiBuZWNlc3NhcnkuXG4gICAgdmFyIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uICgpIHt9OyAvLyBTZXQgdGhlIG9uIGxvYWQgY2FsbGJhY2sgdG8gYSBuby1vcC5cbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgdGhlIEdvb2dsZSBNYXBzIEFQSScpKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIEhvb2sgdXAgdGhlIG9uIGxvYWQgY2FsbGJhY2suXG4gICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh3aW5kb3cuZ29vZ2xlLm1hcHMpO1xuICAgICAgZGVsZXRlIHdpbmRvd1tjYWxsYmFja05hbWVdO1xuICAgIH07XG5cbiAgICAvLyBJbnNlcnQgdGhlIGBzY3JpcHRgIHRhZy5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdEVsZW1lbnQpO1xuICB9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9hZC1nb29nbGUtbWFwcy1hcGkvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBhc3NpZ24gZnJvbSAnZGVlcC1hc3NpZ24nO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgR29vZ2xlIE1hcHMgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXAoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWFwKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX01BUCcsIG1hcCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGVsZW1lbnQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbnRvXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0TWFwRWwoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWFwRWwpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfTUFQX0VMJywgbWFwRWwpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBtYXAgbG9hZGVkIGZsYWdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXBMb2FkZWQoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbG9hZGVkKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX01BUF9MT0FERUQnLCBsb2FkZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBlZGl0aW5nIGZsYWdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXBFZGl0aW5nKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIGVkaXRpbmcpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfTUFQX0VESVRJTkcnLCBlZGl0aW5nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgV2FtVlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFdhbXYoeyBkaXNwYXRjaCwgc3RhdGUgfSwgd2Ftdikge1xyXG4gICAgZGlzcGF0Y2goJ1NFVF9XQU1WJywgd2Ftdik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIFdhbVYgYXJtZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRXYW12QXJtZWQoeyBkaXNwYXRjaCwgc3RhdGUgfSwgYXJtZWQpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfV0FNVl9BUk1FRCcsIGFybWVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgV2FtViBtb3ZpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRXYW12TW9kZSh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtb2RlKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX1dBTVZfTU9ERScsIG1vZGUpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSB0aGUgYXBwIHNldHRpbmdzIGFuZCBzZXQgaXQgb24gdGhlIGdsb2JhbFxyXG4gKiBzdGF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRTZXR0aW5ncyh7IGRpc3BhdGNoIH0pIHtcclxuICAgIC8vIFRPRE86IGZldGNoIHNldHRpbmdzIGZvciBzZXJ2ZXJcclxuICAgIC8vXHJcbiAgICAvLyBhcGkuc2V0dGluZ3MuaW5pdCgpXHJcbiAgICAvLyAgICAgLnRoZW4oZnVuY3Rpb24oc2V0dGluZ3MpIHtcclxuICAgIC8vICAgICAgICAgZGlzcGF0Y2goJ0lOSVRfU0VUVElOR1MnLCBjbGVhbihzZXR0aW5ncykpO1xyXG4gICAgLy8gICAgIH0pXHJcbiAgICAvLyAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAvLyAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tzdG9yZS9hY3Rpb25zXTogRXJyb3IgZmV0Y2hpbmcgc2V0dGluZ3MnLCBlcnJvcik7XHJcbiAgICAvLyAgICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgYSBzZXR0aW5nIG9uIHRoZSBzZXJ2ZXIgYW5kIG9uIHRoZSBnbG9iYWwgc3RhdGVcclxuICpcclxuICogQHBhcmFtICB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBzZXR0aW5nIHRvIHVwZGF0ZVxyXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZSAgICAtIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU2V0dGluZyh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBrZXksIHZhbHVlKSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSBhc3NpZ24oe30sIHN0YXRlLnNldHRpbmdzKTtcclxuICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZTtcclxuXHJcbiAgICBkaXNwYXRjaCgnVVBEQVRFX1NFVFRJTkdTJywgc2V0dGluZ3MpO1xyXG5cclxuICAgIC8vIHNlbmQgdG8gc2VydmVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1pc3Npb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0TWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbnMpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfTUlTU0lPTlMnLCBtaXNzaW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGN1cnJlbnQgbWlzc2lvbiBpbmRleFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldEN1cnJlbnRNaXNzaW9uSW5kZXgoeyBkaXNwYXRjaCwgc3RhdGUgfSwgaW5kZXgpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfQ1VSUkVOVF9NSVNTSU9OX0lOREVYJywgaW5kZXgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBjdXJyZW50IG1pc3Npb25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXJyZW50TWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtaXNzaW9uKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX0NVUlJFTlRfTUlTU0lPTicsIG1pc3Npb24pO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBwYXJhbWV0ZXJzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0UGFyYW1ldGVycyh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX1BBUkFNRVRFUlMnLCBwYXJhbWV0ZXJzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbmQgZ2V0X3BhcmFtZXRlcnMgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRHZXRQYXJhbWV0ZXJzKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX0dFVF9QQVJBTUVURVJTJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSBnZXRfcGFyYW1ldGVycyBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZEdldFBhcmFtZXRlcnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgcGFyYW1ldGVycykge1xyXG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfR0VUX1BBUkFNRVRFUlMnLCBwYXJhbWV0ZXJzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBnZXRfcGFyYW1ldGVycyBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmFpbEdldFBhcmFtZXRlcnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XHJcbiAgICBkaXNwYXRjaCgnRkFJTF9HRVRfUEFSQU1FVEVSUycsIG1zZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIHNhdmVfbWlzc2lvbnMgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRTYXZlTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbnMpIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX1NBVkVfTUlTU0lPTlMnLCBtaXNzaW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSBzYXZlX21pc3Npb25zIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkU2F2ZU1pc3Npb25zKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTVUNDRUVEX1NBVkVfTUlTU0lPTlMnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBzYXZlX21pc3Npb25zIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsU2F2ZU1pc3Npb25zKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xyXG4gICAgZGlzcGF0Y2goJ0ZBSUxfU0FWRV9NSVNTSU9OUycsIG1zZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIGxvYWRfbWlzc2lvbnMgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRMb2FkTWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xyXG4gICAgZGlzcGF0Y2goJ1NFTkRfTE9BRF9NSVNTSU9OUycpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEgbG9hZF9taXNzaW9ucyBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZExvYWRNaXNzaW9ucyh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtaXNzaW9ucykge1xyXG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfTE9BRF9NSVNTSU9OUycsIG1pc3Npb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBsb2FkX21pc3Npb25zIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsTG9hZE1pc3Npb25zKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xyXG4gICAgZGlzcGF0Y2goJ0ZBSUxfTE9BRF9NSVNTSU9OUycsIG1zZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIHVwbG9hZF9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZW5kVXBsb2FkTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtaXNzaW9uKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VORF9VUExPQURfTUlTU0lPTicsIG1pc3Npb24pO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEgdXBsb2FkX21pc3Npb24gbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWRVcGxvYWRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTVUNDRUVEX1VQTE9BRF9NSVNTSU9OJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBmYWlsdXJlIG9mIGEgdXBsb2FkX21pc3Npb24gbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZhaWxVcGxvYWRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xyXG4gICAgZGlzcGF0Y2goJ0ZBSUxfVVBMT0FEX01JU1NJT04nLCBtc2cpO1xyXG59XHJcblxyXG4vKipcclxuICogU2VuZCBkb3dubG9hZF9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZW5kRG93bmxvYWRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX0RPV05MT0FEX01JU1NJT04nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIGRvd25sb2FkX21pc3Npb24gbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWREb3dubG9hZE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbikge1xyXG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfRE9XTkxPQURfTUlTU0lPTicsIG1pc3Npb24pO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgZmFpbHVyZSBvZiBhIGRvd25sb2FkX21pc3Npb24gbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZhaWxEb3dubG9hZE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XHJcbiAgICBkaXNwYXRjaCgnRkFJTF9ET1dOTE9BRF9NSVNTSU9OJywgbXNnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbmQgc3RhcnRfbWlzc2lvbiBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VuZFN0YXJ0TWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XHJcbiAgICBkaXNwYXRjaCgnU0VORF9TVEFSVF9NSVNTSU9OJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSBzdGFydF9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkU3RhcnRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTVUNDRUVEX1NUQVJUX01JU1NJT04nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBzdGFydF9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsU3RhcnRNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xyXG4gICAgZGlzcGF0Y2goJ0ZBSUxfU1RBUlRfTUlTU0lPTicsIG1zZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIHN0b3BfbWlzc2lvbiBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VuZFN0b3BNaXNzaW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX1NUT1BfTUlTU0lPTicpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEgc3RvcF9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkU3RvcE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xyXG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfU1RPUF9NSVNTSU9OJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBmYWlsdXJlIG9mIGEgc3RvcF9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsU3RvcE1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgbXNnKSB7XHJcbiAgICBkaXNwYXRjaCgnRkFJTF9TVE9QX01JU1NJT04nLCBtc2cpO1xyXG59XHJcblxyXG4vKipcclxuICogU2VuZCByZXN1bWVfbWlzc2lvbiBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VuZFJlc3VtZU1pc3Npb24oeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xyXG4gICAgZGlzcGF0Y2goJ1NFTkRfUkVTVU1FX01JU1NJT04nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIHJlc3VtZV9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkUmVzdW1lTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XHJcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9SRVNVTUVfTUlTU0lPTicpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgZmFpbHVyZSBvZiBhIHJlc3VtZV9taXNzaW9uIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsUmVzdW1lTWlzc2lvbih7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtc2cpIHtcclxuICAgIGRpc3BhdGNoKCdGQUlMX1JFU1VNRV9NSVNTSU9OJywgbXNnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbmQgYXJtIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZW5kQXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX0FSTScpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGFuIGFybSBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3VjY2VlZEFybSh7IGRpc3BhdGNoLCBzdGF0ZSB9KSB7XHJcbiAgICBkaXNwYXRjaCgnU1VDQ0VFRF9BUk0nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYW4gYXJtIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsQXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xyXG4gICAgZGlzcGF0Y2goJ0ZBSUxfQVJNJywgbXNnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbmQgZGlzYXJtIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZW5kRGlzYXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX0RJU0FSTScpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRvIGEgZGlzYXJtIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZWVkRGlzYXJtKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTVUNDRUVEX0RJU0FSTScpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kaWNhdGUgZmFpbHVyZSBvZiBhIGRpc2FybSBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmFpbERpc2FybSh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtc2cpIHtcclxuICAgIGRpc3BhdGNoKCdGQUlMX0RJU0FSTScsIG1zZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIGtpbGwgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRLaWxsKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTRU5EX0tJTEwnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhIGtpbGwgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWRLaWxsKHsgZGlzcGF0Y2gsIHN0YXRlIH0pIHtcclxuICAgIGRpc3BhdGNoKCdTVUNDRUVEX0tJTEwnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlIGZhaWx1cmUgb2YgYSBraWxsIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsS2lsbCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtc2cpIHtcclxuICAgIGRpc3BhdGNoKCdGQUlMX0tJTEwnLCBtc2cpO1xyXG59XHJcblxyXG4vKipcclxuICogU2VuZCB1bmtpbGwgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRVbmtpbGwoeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xyXG4gICAgZGlzcGF0Y2goJ1NFTkRfVU5LSUxMJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYSB1bmtpbGwgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1Y2NlZWRVbmtpbGwoeyBkaXNwYXRjaCwgc3RhdGUgfSkge1xyXG4gICAgZGlzcGF0Y2goJ1NVQ0NFRURfVU5LSUxMJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZSBmYWlsdXJlIG9mIGEgdW5raWxsIG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsVW5raWxsKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1zZykge1xyXG4gICAgZGlzcGF0Y2goJ0ZBSUxfVU5LSUxMJywgbXNnKTtcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zdG9yZS9hY3Rpb25zLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqID0gcmVxdWlyZSgnaXMtb2JqJyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1NvdXJjZXMgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbktleSh0bywgZnJvbSwga2V5KSB7XG5cdHZhciB2YWwgPSBmcm9tW2tleV07XG5cblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpKSB7XG5cdFx0aWYgKHRvW2tleV0gPT09IHVuZGVmaW5lZCB8fCB0b1trZXldID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QgKCcgKyBrZXkgKyAnKScpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSB8fCAhaXNPYmoodmFsKSkge1xuXHRcdHRvW2tleV0gPSB2YWw7XG5cdH0gZWxzZSB7XG5cdFx0dG9ba2V5XSA9IGFzc2lnbihPYmplY3QodG9ba2V5XSksIGZyb21ba2V5XSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzaWduKHRvLCBmcm9tKSB7XG5cdGlmICh0byA9PT0gZnJvbSkge1xuXHRcdHJldHVybiB0bztcblx0fVxuXG5cdGZyb20gPSBPYmplY3QoZnJvbSk7XG5cblx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRhc3NpZ25LZXkodG8sIGZyb20sIGtleSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHR2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0YXNzaWduS2V5KHRvLCBmcm9tLCBzeW1ib2xzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQpIHtcblx0dGFyZ2V0ID0gdG9PYmplY3QodGFyZ2V0KTtcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGFzc2lnbih0YXJnZXQsIGFyZ3VtZW50c1tzXSk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2RlZXAtYXNzaWduL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0dmFyIHR5cGUgPSB0eXBlb2YgeDtcblx0cmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzLW9iai9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZnVuY3Rpb24gZ2V0TWFwKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWFwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwRWwoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tYXBFbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcExvYWRlZChzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1hcExvYWRlZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcEVkaXRpbmcoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tYXBFZGl0aW5nO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2FtdihzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLndhbXY7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWcoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5jb25maWc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXR0aW5ncyhzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLnNldHRpbmdzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlzc2lvbnMoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5taXNzaW9ucztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5jdXJyZW50TWlzc2lvbkluZGV4O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudE1pc3Npb24oc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5taXNzaW9uc1tzdGF0ZS5jdXJyZW50TWlzc2lvbkluZGV4XTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5wYXJhbWV0ZXJzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZVN0YXRlV2FpdGluZyhzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZVN0YXRlU3VjY2VzcyhzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZVN0YXRlRmFpbHVyZShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2V0UGFyYW1ldGVyU3RhdGUoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuZ2V0X3BhcmFtZXRlcnNbMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHZXRQYXJhbWV0ZXJEYXRhKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmdldF9wYXJhbWV0ZXJzWzFdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2F2ZU1pc3Npb25zU3RhdGUoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9uc1swXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNhdmVNaXNzaW9uc0RhdGEoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9uc1sxXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRNaXNzaW9uc1N0YXRlKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmxvYWRfbWlzc2lvbnNbMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2FkTWlzc2lvbnNEYXRhKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmxvYWRfbWlzc2lvbnNbMV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcGxvYWRNaXNzaW9uU3RhdGUoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUudXBsb2FkX21pc3Npb25bMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcGxvYWRNaXNzaW9uRGF0YShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS51cGxvYWRfbWlzc2lvblsxXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERvd25sb2FkTWlzc2lvblN0YXRlKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmRvd25sb2FkX21pc3Npb25bMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREb3dubG9hZE1pc3Npb25EYXRhKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmRvd25sb2FkX21pc3Npb25bMV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFydE1pc3Npb25TdGF0ZShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uWzBdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnRNaXNzaW9uRGF0YShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uWzFdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcE1pc3Npb25TdGF0ZShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdG9wX21pc3Npb25bMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9wTWlzc2lvbkRhdGEoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuc3RvcF9taXNzaW9uWzFdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzdW1lTWlzc2lvblN0YXRlKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uWzBdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzdW1lTWlzc2lvbkRhdGEoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUucmVzdW1lX21pc3Npb25bMV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcm1TdGF0ZShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5hcm1bMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcm1EYXRhKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmFybVsxXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc2FybVN0YXRlKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmRpc2FybVswXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc2FybURhdGEoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUuZGlzYXJtWzFdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2lsbFN0YXRlKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWVzc2FnZVN0YXRlLmtpbGxbMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRLaWxsRGF0YShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS5raWxsWzFdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5raWxsU3RhdGUoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tZXNzYWdlU3RhdGUudW5raWxsWzBdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5raWxsRGF0YShzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VTdGF0ZS51bmtpbGxbMV07XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvc3RvcmUvZ2V0dGVycy5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3MtbWFwXFxcIiBpZD1cXFwibWFwXFxcIiA6Y2xhc3M9XFxcInsgJ2djcy1tYXAtZWRpdC1tb2RlJzogbWFwRWRpdGluZyB9XFxcIj48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXAudnVlXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNYXBDb250cm9scy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NNYXBDb250cm9scy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWFwXFxcXEdjc01hcENvbnRyb2xzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01hcENvbnRyb2xzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTQ3NWFlMjBhL0djc01hcENvbnRyb2xzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBDb250cm9scy52dWVcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcENvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLW1hcC1jb250cm9sc1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW4tY29udHJvbHNcIj5cclxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInBhbi1jb250cm9sIHVwXCIgaWNvbj1cImtleWJvYXJkX2Fycm93X3VwXCIgQGNsaWNrPVwicGFuKCd1cCcpXCJcclxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgcmlnaHRcIiBpY29uPVwia2V5Ym9hcmRfYXJyb3dfcmlnaHRcIiBAY2xpY2s9XCJwYW4oJ3JpZ2h0JylcIlxyXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJwYW4tY29udHJvbCBkb3duXCIgaWNvbj1cImtleWJvYXJkX2Fycm93X2Rvd25cIiBAY2xpY2s9XCJwYW4oJ2Rvd24nKVwiXHJcbiAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG5cclxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInBhbi1jb250cm9sIGxlZnRcIiBpY29uPVwia2V5Ym9hcmRfYXJyb3dfbGVmdFwiIEBjbGljaz1cInBhbignbGVmdCcpXCJcclxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgY2VudGVyXCIgaWNvbj1cIm15X2xvY2F0aW9uXCIgQGNsaWNrPVwicGFuKCdjZW50ZXInKVwiXHJcbiAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiem9vbS1jb250cm9sc1wiPlxyXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgIGNsYXNzPVwiem9vbS1jb250cm9sIGluXCIgaWNvbj1cImFkZFwiIEBjbGljaz1cInpvb20oJ2luJylcIlxyXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ6b29tLWNvbnRyb2wgb3V0XCIgaWNvbj1cInJlbW92ZVwiIEBjbGljaz1cInpvb20oJ291dCcpXCJcclxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0eXBlLWNvbnRyb2xcIj5cclxuICAgICAgICAgICAgPHVpLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgOm1lbnUtb3B0aW9ucz1cIm1hcFR5cGVzTWVudVwiIG5hbWU9XCJtYXBfdHlwZXNcIiA6dGV4dD1cIm1hcFR5cGVcIlxyXG4gICAgICAgICAgICAgICAgQG1lbnUtb3B0aW9uLXNlbGVjdGVkPVwiY2hhbmdlTWFwVHlwZVwiIGhhcy1kcm9wZG93bi1tZW51IHJhaXNlZFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd24tcG9zaXRpb249XCJ0b3AgcmlnaHRcIiA6c2hvdy1kcm9wZG93bi1pY29uPVwiZmFsc2VcIlxyXG4gICAgICAgICAgICA+PC91aS1idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWFwVHlwZTogJ1NhdGVsbGl0ZScsXHJcbiAgICAgICAgICAgIG1hcFR5cGVzTWVudTogW1xyXG4gICAgICAgICAgICAgICAgeyAndmFsdWUnOiAnUk9BRE1BUCcsIHRleHQ6ICdSb2FkJyB9LFxyXG4gICAgICAgICAgICAgICAgeyAndmFsdWUnOiAnVEVSUkFJTicsIHRleHQ6ICdUZXJyYWluJyB9LFxyXG4gICAgICAgICAgICAgICAgeyAndmFsdWUnOiAnU0FURUxMSVRFJywgdGV4dDogJ1NhdGVsbGl0ZScgfSxcclxuICAgICAgICAgICAgICAgIHsgJ3ZhbHVlJzogJ0hZQlJJRCcsIHRleHQ6ICdIeWJyaWQnIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBwYW4oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtYXA6OnBhbi0nICsgZGlyZWN0aW9uKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB6b29tKHR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21hcDo6em9vbS0nICsgdHlwZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2hhbmdlTWFwVHlwZShzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcFR5cGUgPSBzZWxlY3RlZC50ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOjpjaGFuZ2UtdHlwZScsIHNlbGVjdGVkLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3MtbWFwLWNvbnRyb2xzIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJvdHRvbTogMjRweDtcclxuICAgIHJpZ2h0OiAxMnB4O1xyXG4gICAgei1pbmRleDogMTtcclxuXHJcbiAgICAucGFuLWNvbnRyb2xzIHtcclxuICAgICAgICB3aWR0aDogMTAwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiAxMDBweDtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLnBhbi1jb250cm9sIHtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgd2lkdGg6IDMycHg7XHJcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcclxuICAgICAgICBib3gtc2hhZG93OiAwIDJweCA1cHggMCBhbHBoYShibGFjaywgMC4yKSwgMCAycHggMTBweCAwIGFscGhhKGJsYWNrLCAwLjE2KTtcclxuICAgICAgICAtd2Via2l0LW1hc2staW1hZ2U6IG5vbmU7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGUhaW1wb3J0YW50O1xyXG5cclxuICAgICAgICAmLnVwIHtcclxuICAgICAgICAgICAgdG9wOiAwO1xyXG4gICAgICAgICAgICBsZWZ0OiAzNHB4O1xyXG4gICAgICAgICAgICByaWdodDogYXV0bztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYuZG93biB7XHJcbiAgICAgICAgICAgIGJvdHRvbTogMDtcclxuICAgICAgICAgICAgbGVmdDogMzRweDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYubGVmdCB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgICAgIHRvcDogMzRweDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYucmlnaHQge1xyXG4gICAgICAgICAgICByaWdodDogMDtcclxuICAgICAgICAgICAgdG9wOiAzNHB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJi5jZW50ZXIge1xyXG4gICAgICAgICAgICB0b3A6IDM0cHg7XHJcbiAgICAgICAgICAgIGxlZnQ6IDM0cHg7XHJcblxyXG4gICAgICAgICAgICAudWktaWNvbiB7XHJcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLnpvb20tY29udHJvbHMge1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogOHB4O1xyXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCAwIGFscGhhKGJsYWNrLCAwLjIpLCAwIDJweCAxMHB4IDAgYWxwaGEoYmxhY2ssIDAuMTYpO1xyXG5cclxuICAgICAgICAuem9vbS1jb250cm9sIHtcclxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcclxuICAgICAgICAgICAgd2lkdGg6IDUwcHg7XHJcbiAgICAgICAgICAgIGhlaWdodDogMjhweDtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGUhaW1wb3J0YW50XHJcblxyXG4gICAgICAgICAgICAmLmluIHtcclxuICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNDQ0M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLnR5cGUtY29udHJvbCB7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogOHB4O1xyXG5cclxuICAgICAgICAudWktYnV0dG9uIHtcclxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcclxuICAgICAgICAgICAgd2lkdGg6IDEwMHB4O1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDMycHg7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNYXBDb250cm9scy52dWU/ZDg0ZDM0MTBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLW1hcC1jb250cm9sc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbi1jb250cm9sc1xcXCI+XFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwicGFuLWNvbnRyb2wgdXBcXFwiIGljb249XFxcImtleWJvYXJkX2Fycm93X3VwXFxcIiBAY2xpY2s9XFxcInBhbigndXAnKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInBhbi1jb250cm9sIHJpZ2h0XFxcIiBpY29uPVxcXCJrZXlib2FyZF9hcnJvd19yaWdodFxcXCIgQGNsaWNrPVxcXCJwYW4oJ3JpZ2h0JylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJwYW4tY29udHJvbCBkb3duXFxcIiBpY29uPVxcXCJrZXlib2FyZF9hcnJvd19kb3duXFxcIiBAY2xpY2s9XFxcInBhbignZG93bicpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwicGFuLWNvbnRyb2wgbGVmdFxcXCIgaWNvbj1cXFwia2V5Ym9hcmRfYXJyb3dfbGVmdFxcXCIgQGNsaWNrPVxcXCJwYW4oJ2xlZnQnKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInBhbi1jb250cm9sIGNlbnRlclxcXCIgaWNvbj1cXFwibXlfbG9jYXRpb25cXFwiIEBjbGljaz1cXFwicGFuKCdjZW50ZXInKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiem9vbS1jb250cm9sc1xcXCI+XFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwiem9vbS1jb250cm9sIGluXFxcIiBpY29uPVxcXCJhZGRcXFwiIEBjbGljaz1cXFwiem9vbSgnaW4nKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInpvb20tY29udHJvbCBvdXRcXFwiIGljb249XFxcInJlbW92ZVxcXCIgQGNsaWNrPVxcXCJ6b29tKCdvdXQnKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidHlwZS1jb250cm9sXFxcIj5cXG4gICAgICAgIDx1aS1idXR0b25cXG4gICAgICAgICAgICA6bWVudS1vcHRpb25zPVxcXCJtYXBUeXBlc01lbnVcXFwiIG5hbWU9XFxcIm1hcF90eXBlc1xcXCIgOnRleHQ9XFxcIm1hcFR5cGVcXFwiXFxuICAgICAgICAgICAgQG1lbnUtb3B0aW9uLXNlbGVjdGVkPVxcXCJjaGFuZ2VNYXBUeXBlXFxcIiBoYXMtZHJvcGRvd24tbWVudSByYWlzZWRcXG4gICAgICAgICAgICBkcm9wZG93bi1wb3NpdGlvbj1cXFwidG9wIHJpZ2h0XFxcIiA6c2hvdy1kcm9wZG93bi1pY29uPVxcXCJmYWxzZVxcXCJcXG4gICAgICAgID48L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNYXBTaWRlYmFyLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0djc01hcFNpZGViYXIudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcFxcXFxHY3NNYXBTaWRlYmFyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01hcFNpZGViYXIudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtN2ZjY2Y0YjIvR2NzTWFwU2lkZWJhci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwU2lkZWJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3MtbWFwLXNpZGViYXJcIiB2LXNob3c9XCJzaG93U2lkZWJhclwiIHRyYW5zaXRpb249XCJzaWRlYmFyLWNvbGxhcHNlXCI+XHJcbiAgICAgICAgPGdjcy1taXNzaW9ucz48L2djcy1taXNzaW9ucz5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEdjc01pc3Npb25zIGZyb20gJ21pc3Npb24vR2NzTWlzc2lvbnMudnVlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgc2hvd1NpZGViYXI6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBHY3NNaXNzaW9uc1xyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLW1hcC1zaWRlYmFyIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHdpZHRoOiAzNjBweDtcclxuICAgIGhlaWdodDogMTAwJTtcclxuXHJcbiAgICB0b3A6IDA7XHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgei1pbmRleDogMTtcclxuXHJcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xyXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xyXG5cclxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDRweCBhbHBoYShibGFjaywgMC4zNSksIDAgMnB4IDNweCBhbHBoYShibGFjaywgMC4yKTtcclxufVxyXG5cclxuLnNpZGViYXItY29sbGFwc2UtdHJhbnNpdGlvbiB7XHJcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xyXG59XHJcblxyXG4uc2lkZWJhci1jb2xsYXBzZS1lbnRlcixcclxuLnNpZGViYXItY29sbGFwc2UtbGVhdmUge1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0zNjBweCk7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWFwU2lkZWJhci52dWU/Nzc0N2EzNGFcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzTWlzc2lvbnMudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWlzc2lvbnMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1pc3Npb25cXFxcR2NzTWlzc2lvbnMudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzTWlzc2lvbnMudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtMDA5NzY3YzQvR2NzTWlzc2lvbnMudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWVcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWVcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImdjcy1taXNzaW9uc1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaWRlYmFyLXBhZ2VcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1pc3Npb25zLWxpc3RcIiB2LWlmPVwiY3VycmVudFZpZXcgPT09ICdsaXN0aW5nJ1wiPlxyXG4gICAgICAgICAgICAgICAgPHVpLXRvb2xiYXIgdGl0bGU9XCJNaXNzaW9uc1wiIGhpZGUtbmF2LWljb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzbG90PVwiYWN0aW9uc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJhZGRcIiB0b29sdGlwPVwiQWRkIG1pc3Npb25cIiBAY2xpY2s9XCJhZGRNaXNzaW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJtb3JlX3ZlcnRcIiBoYXMtZHJvcGRvd24tbWVudVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24tcG9zaXRpb249XCJib3R0b20gcmlnaHRcIiA6bWVudS1vcHRpb25zPVwib3ZlcmZsb3dNZW51XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtZW51LW9wdGlvbi1zZWxlY3RlZD1cIm1lbnVPcHRpb25TZWxlY3RlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC91aS10b29sYmFyPlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzaWRlYmFyLXBhZ2UtY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJibGFuay1zdGF0ZVwiIHYtaWY9XCIhbWlzc2lvbnMubGVuZ3RoXCI+Tm8gbWlzc2lvbnM8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGdjcy1taXNzaW9uLXJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LWZvcj1cIihpbmRleCwgbWlzc2lvbikgaW4gbWlzc2lvbnNcIiA6aW5kZXg9XCJpbmRleFwiIDptaXNzaW9uPVwibWlzc2lvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInNlbGVjdE1pc3Npb24oaW5kZXgpXCJcclxuICAgICAgICAgICAgICAgICAgICA+PC9nY3MtbWlzc2lvbi1yb3c+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8Y29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICB2LWVsc2UgOmlzPVwiY3VycmVudFZpZXdcIiA6bWlzc2lvbj1cImN1cnJlbnRNaXNzaW9uXCIgQGdvLWJhY2s9XCJzaG93TGlzdGluZ1ZpZXdcIlxyXG4gICAgICAgICAgICA+PC9jb21wb25lbnQ+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDwhLS0gaGlkZGVuIGlucHV0IGVsZW1lbnQgdXNlZCBmb3Igc2VsZWN0aW5nIGEgZmlsZSB0byBpbXBvcnQgZnJvbSAtLT5cclxuICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGlkPVwiaW1wb3J0X21pc3Npb25zX2lucHV0XCIgQGNoYW5nZT1cImltcG9ydE1pc3Npb25cIj5cclxuICAgIDwhLS0gaGlkZGVuIGxpbmsgdXNlZCBmb3IgcHJvbXB0aW5nIGEgZG93bmxvYWQgLS0+XHJcbiAgICA8YSBpZD1cImV4cG9ydF9taXNzaW9uc19saW5rXCI+PC9hPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEdjc01pc3Npb24gZnJvbSAnbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZSc7XHJcbmltcG9ydCBHY3NNaXNzaW9uUm93IGZyb20gJ21pc3Npb24vR2NzTWlzc2lvblJvdy52dWUnO1xyXG5cclxuaW1wb3J0IHtcclxuICAgIHNldE1pc3Npb25zLCBzZXRDdXJyZW50TWlzc2lvbkluZGV4LFxyXG4gICAgc2VuZFNhdmVNaXNzaW9ucywgZmFpbFNhdmVNaXNzaW9ucyxcclxuICAgIHNlbmRMb2FkTWlzc2lvbnMsIGZhaWxMb2FkTWlzc2lvbnNcclxufSBmcm9tICdzdG9yZS9hY3Rpb25zJztcclxuaW1wb3J0IHtcclxuICAgIGdldE1pc3Npb25zLCBnZXRDdXJyZW50TWlzc2lvbkluZGV4LCBnZXRDdXJyZW50TWlzc2lvbixcclxuICAgIGdldE1lc3NhZ2VTdGF0ZVdhaXRpbmcsIGdldE1lc3NhZ2VTdGF0ZVN1Y2Nlc3MsIGdldE1lc3NhZ2VTdGF0ZUZhaWx1cmUsXHJcbiAgICBnZXRTYXZlTWlzc2lvbnNTdGF0ZSwgZ2V0U2F2ZU1pc3Npb25zRGF0YSxcclxuICAgIGdldExvYWRNaXNzaW9uc1N0YXRlLCBnZXRMb2FkTWlzc2lvbnNEYXRhLFxyXG59IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgbWlzc2lvbnM6ICAgICAgICAgICAgZ2V0TWlzc2lvbnMsXHJcbiAgICAgICAgICAgIGN1cnJlbnRNaXNzaW9uSW5kZXg6IGdldEN1cnJlbnRNaXNzaW9uSW5kZXgsXHJcbiAgICAgICAgICAgIGN1cnJlbnRNaXNzaW9uOiAgICAgIGdldEN1cnJlbnRNaXNzaW9uLFxyXG4gICAgICAgICAgICBXQUlUSU5HOiAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVXYWl0aW5nLFxyXG4gICAgICAgICAgICBTVUNDRVNTOiAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVTdWNjZXNzLFxyXG4gICAgICAgICAgICBGQUlMVVJFOiAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVGYWlsdXJlLFxyXG4gICAgICAgICAgICBzYXZlTWlzc2lvbnNTdGF0ZTogICBnZXRTYXZlTWlzc2lvbnNTdGF0ZSxcclxuICAgICAgICAgICAgc2F2ZU1pc3Npb25zRGF0YTogICAgZ2V0U2F2ZU1pc3Npb25zRGF0YSxcclxuICAgICAgICAgICAgbG9hZE1pc3Npb25zU3RhdGU6ICAgZ2V0TG9hZE1pc3Npb25zU3RhdGUsXHJcbiAgICAgICAgICAgIGxvYWRNaXNzaW9uc0RhdGE6ICAgIGdldExvYWRNaXNzaW9uc0RhdGFcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIHNldE1pc3Npb25zLFxyXG4gICAgICAgICAgICBzZXRDdXJyZW50TWlzc2lvbkluZGV4LFxyXG4gICAgICAgICAgICBzZW5kU2F2ZU1pc3Npb25zLFxyXG4gICAgICAgICAgICBmYWlsU2F2ZU1pc3Npb25zLFxyXG4gICAgICAgICAgICBzZW5kTG9hZE1pc3Npb25zLFxyXG4gICAgICAgICAgICBmYWlsTG9hZE1pc3Npb25zXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3OiAnbGlzdGluZycsXHJcbiAgICAgICAgICAgIG92ZXJmbG93TWVudTogW1xyXG4gICAgICAgICAgICAgICAgeyBpZDogJ3NhdmUnLCB0ZXh0OiAnU2F2ZSB0byBzZXJ2ZXInIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnbG9hZCcsIHRleHQ6ICdMb2FkIGZyb20gc2VydmVyJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ3NlcDEnLCB0ZXh0OiAnJywgdHlwZTogJ2RpdmlkZXInIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnZXhwb3J0JywgdGV4dDogJ0V4cG9ydCB0byBmaWxlJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2ltcG9ydCcsIHRleHQ6ICdJbXBvcnQgZnJvbSBmaWxlJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ3NlcDInLCB0ZXh0OiAnJywgdHlwZTogJ2RpdmlkZXInIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnY2xlYXInLCB0ZXh0OiAnQ2xlYXIgYWxsJyB9LFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHNlbGVjdE1pc3Npb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlzc2lvbkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICdnY3MtbWlzc2lvbic7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2hvd0xpc3RpbmdWaWV3KCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ2xpc3RpbmcnO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaXNzaW9uSW5kZXgoLTEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZE1pc3Npb24oKXtcclxuICAgICAgICAgICAgdGhpcy5taXNzaW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnTWlzc2lvbiAnICsgKHRoaXMubWlzc2lvbnMubGVuZ3RoICsgMSksXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcclxuICAgICAgICAgICAgICAgIHdheXBvaW50czogW11cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZW51T3B0aW9uU2VsZWN0ZWQob3B0aW9uKXtcclxuICAgICAgICAgICAgc3dpdGNoIChvcHRpb24uaWQpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2F2ZSc6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRTYXZlTWlzc2lvbnModGhpcy5taXNzaW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNhdmVNaXNzaW9uc1N0YXRlID09IHRoaXMuV0FJVElORyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxTYXZlTWlzc2lvbnMoJ1RpbWVvdXQgcmVhY2hlZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbG9hZCc6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRMb2FkTWlzc2lvbnModGhpcy5taXNzaW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRNaXNzaW9uc1N0YXRlID09IHRoaXMuV0FJVElORyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxMb2FkTWlzc2lvbnMoJ1RpbWVvdXQgcmVhY2hlZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlciBmaWxlIHNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbXBvcnRfbWlzc2lvbnNfaW5wdXQnKS5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwb3J0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGRhdGEgVVJJXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVyaSA9ICdkYXRhOmFwcGxpY2F0aW9uL2pzb24sJztcclxuICAgICAgICAgICAgICAgICAgICB1cmkgKz0gSlNPTi5zdHJpbmdpZnkodGhpcy5taXNzaW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJpID0gZW5jb2RlVVJJKHVyaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgbGluayB0byB1c2UgZm9yIGRvd25sb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhwb3J0X21pc3Npb25zX2xpbmsnKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay5kb3dubG9hZCA9ICdtaXNzaW9ucy5qc29uJztcclxuICAgICAgICAgICAgICAgICAgICAvL3RyaWdnZXIgZG93bmxvYWRcclxuICAgICAgICAgICAgICAgICAgICBsaW5rLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjbGVhcic6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE1pc3Npb25zKFtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGltcG9ydE1pc3Npb24oKXtcclxuICAgICAgICAgICAgbGV0IGZpbGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltcG9ydF9taXNzaW9uc19pbnB1dCcpLmZpbGVzO1xyXG4gICAgICAgICAgICAvL2dldCBmaWxlIGNvbnRlbnRzXHJcbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgIC8vc3BlY2lmeSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZmlsZSBoYXMgYmVlbiByZWFkXHJcbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudHMgPSBlLnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld01pc3Npb25zID0gSlNPTi5wYXJzZShjb250ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHZlcmlmeSBtaXNzaW9ucyBvYmplY3QgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnMobmV3TWlzc2lvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZmlsZSBjb250ZW50cyBhcmUgaW52YWxpZDogJyArIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vc3RhcnQgZmlsZSByZWFkXHJcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgd2F0Y2g6IHtcclxuICAgICAgICBzYXZlTWlzc2lvbnNTdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7IC8vc3VjY2Vzc2Z1bCByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW9ucyBzYXZlZC4nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXsgLy9mYWlsdXJlIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBzYXZlIG1pc3Npb25zOiAnICsgdGhpcy5zYXZlTWlzc2lvbnNEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZE1pc3Npb25zU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLlNVQ0NFU1Mpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnModGhpcy5sb2FkTWlzc2lvbnNEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2lvbnMgbG9hZGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLkZBSUxVUkUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gbG9hZCBtaXNzaW9uczogJyArIHRoaXMubG9hZE1pc3Npb25zRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgICdkZWxldGUtbWlzc2lvbicoaW5kZXgpe1xyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgR2NzTWlzc2lvbixcclxuICAgICAgICBHY3NNaXNzaW9uUm93XHJcbiAgICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3MtbWlzc2lvbnMsXHJcbi5taXNzaW9ucy1saXN0IHtcclxuICAgIGhlaWdodDogMTAwJVxyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxufVxyXG5cclxuI2ltcG9ydF9taXNzaW9uc19pbnB1dCxcclxuI2V4cG9ydF9taXNzaW9uc19saW5rIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWlzc2lvbnMudnVlP2I3OTVhODZlXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01pc3Npb24udnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWlzc2lvbi52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWlzc2lvblxcXFxHY3NNaXNzaW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01pc3Npb24udnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYjVlZWVjYjYvR2NzTWlzc2lvbi52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb24udnVlXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWVcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImdjcy1taXNzaW9uXCI+XHJcbiAgICAgICAgPHVpLXRvb2xiYXIgOnRpdGxlPVwibWlzc2lvbi50aXRsZVwiIGhpZGUtbmF2LWljb24gc2hvdy1icmFuZCA6c2hvdy1icmFuZC1kaXZpZGVyPVwiZmFsc2VcIj5cclxuICAgICAgICAgICAgPGRpdiBzbG90PVwiYnJhbmRcIj5cclxuICAgICAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIEBjbGljaz1cImdvQmFja1wiIHR5cGU9XCJjbGVhclwiIGljb249XCJhcnJvd19iYWNrXCIgdG9vbHRpcD1cIkJhY2sgdG8gTWlzc2lvbnNcIlxyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAtcG9zaXRpb249XCJib3R0b20gbGVmdFwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IHNsb3Q9XCJhY3Rpb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2xlYXJcIiBpY29uPVwiZmlsZV91cGxvYWRcIiB0b29sdGlwPVwiVXBsb2FkIE1pc3Npb25cIiBAY2xpY2s9XCJ1cGxvYWRNaXNzaW9uXCJcclxuICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG5cclxuICAgICAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJjbGVhcl9hbGxcIiB0b29sdGlwPVwiQ2xlYXIgYWxsXCIgQGNsaWNrPVwiY2xlYXJXYXlwb2ludHNcIlxyXG4gICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNsZWFyXCIgOmljb249XCJ3YXlwb2ludHNWaXNpYmxlID8gJ3Zpc2liaWxpdHknIDogJ3Zpc2liaWxpdHlfb2ZmJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwidG9nZ2xlV2F5cG9pbnRWaXNpYmlsaXR5XCJcclxuICAgICAgICAgICAgICAgICAgICA6dG9vbHRpcD1cIndheXBvaW50c1Zpc2libGUgPyAnSGlkZSB3YXlwb2ludHMnIDogJ1Nob3cgd2F5cG9pbnRzJ1wiXHJcbiAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2xlYXJcIiBpY29uPVwibW9yZV92ZXJ0XCIgaGFzLWRyb3Bkb3duLW1lbnUgZHJvcGRvd24tcG9zaXRpb249XCJib3R0b20gcmlnaHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIDptZW51LW9wdGlvbnM9XCJvdmVyZmxvd01lbnVcIlxyXG4gICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvdWktdG9vbGJhcj5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInNpZGViYXItcGFnZS1jb250ZW50XCIgdi1lbDpwYWdlLWNvbnRlbnQ+XHJcbiAgICAgICAgICAgIDxwXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cIm5vLXdheXBvaW50c1wiIHYtaWY9XCIhbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXCJcclxuICAgICAgICAgICAgPk5vIHdheXBvaW50cyBmb3IgdGhpcyBtaXNzaW9uLiBDbGljayB0aGUgbWFwIHRvIGFkZCBhIHdheXBvaW50LjwvcD5cclxuXHJcbiAgICAgICAgICAgIDxjb21wb25lbnQgdi1lbHNlPlxyXG4gICAgICAgICAgICAgICAgPGdjcy13YXlwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKGluZGV4LCB3YXlwb2ludCkgaW4gbWlzc2lvbi53YXlwb2ludHNcIiA6aW5kZXg9XCJpbmRleFwiXHJcbiAgICAgICAgICAgICAgICAgICAgOmxhYmVsPVwidG9MZXR0ZXIoaW5kZXggKyAxKVwiIDp0aXRsZT1cIndheXBvaW50LnRpdGxlXCIgOnR5cGU9XCJ3YXlwb2ludC50eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICA6bGF0PVwid2F5cG9pbnQucG9zaXRpb24ubGF0XCIgOmxuZz1cIndheXBvaW50LnBvc2l0aW9uLmxuZ1wiIDp2aXNpYmxlPVwid2F5cG9pbnQudmlzaWJsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOnJvdGF0aW9uPVwid2F5cG9pbnQucm90YXRpb25cIiA6c2NhbGU9XCIxMFwiIGRyYWdnYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIEBkZWxldGU9XCJkZWxldGVXYXlwb2ludChpbmRleClcIlxyXG4gICAgICAgICAgICAgICAgPjwvZ2NzLXdheXBvaW50PlxyXG4gICAgICAgICAgICAgICAgPGdjcy13YXlwb2ludC1saW5rXHJcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XCIoaW5kZXgsIHdheXBvaW50KSBpbiBtaXNzaW9uLndheXBvaW50c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgOmluZGV4PVwiaW5kZXhcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpzdGFydD1cIndheXBvaW50LnBvc2l0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICA6ZW5kPVwibWlzc2lvbi53YXlwb2ludHNbKGluZGV4KzEpICUgbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXS5wb3NpdGlvbjtcIlxyXG4gICAgICAgICAgICAgICAgPjwvZ2NzLXdheXBvaW50LWxpbms+XHJcbiAgICAgICAgICAgIDwvY29tcG9uZW50PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgR2NzV2F5cG9pbnQgZnJvbSAnbWFya2Vycy9HY3NXYXlwb2ludC52dWUnO1xyXG5pbXBvcnQgR2NzV2F5cG9pbnRMaW5rIGZyb20gJ21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZSc7XHJcblxyXG5pbXBvcnQgZWxlbWVudCBmcm9tICd1dGlsL2VsZW1lbnQtc2Nyb2xsJztcclxuaW1wb3J0IG51bWJlclRvTGV0dGVyIGZyb20gJ3V0aWwvbnVtYmVyLXRvLWxldHRlcic7XHJcblxyXG5pbXBvcnQgeyBzZXRNYXBFZGl0aW5nIH0gZnJvbSAnc3RvcmUvYWN0aW9ucyc7XHJcbmltcG9ydCB7IGdldE1hcEVkaXRpbmcgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHZ1ZXg6IHtcclxuICAgICAgICBnZXR0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1hcEVkaXRpbmc6IGdldE1hcEVkaXRpbmdcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIHNldE1hcEVkaXRpbmdcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbWlzc2lvbjoge1xyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdheXBvaW50c1Zpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG92ZXJmbG93TWVudTogW1xyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2VkaXQnLCB0ZXh0OiAnRWRpdCBtaXNzaW9uJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2RlbGV0ZScsIHRleHQ6ICdEZWxldGUgbWlzc2lvbicgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRNYXBFZGl0aW5nKHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc2V0TWFwRWRpdGluZyhmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgICdtYXA6Y2xpY2snKGUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm1hcEVkaXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGxhdCA9IE51bWJlciggcGFyc2VGbG9hdChlLmxhdExuZy5sYXQoKSkudG9GaXhlZCg3KSApO1xyXG4gICAgICAgICAgICBsZXQgbG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV3V2F5cG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdub3JtYWwnLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxuZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5taXNzaW9uLndheXBvaW50cy5wdXNoKG5ld1dheXBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byBib3R0b21cclxuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb0VuZCh0aGlzLiRlbHMucGFnZUNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOmRibGNsaWNrJyhlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNYXAgZG91YmxlIGNsaWNrZWQnLCBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOnJpZ2h0Y2xpY2snKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ01hcCByaWdodC1jbGlja2VkJywgZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ3dheXBvaW50OmRyYWcnKGluZGV4LCBsYXQsIGxuZyl7XHJcbiAgICAgICAgICAgIC8vdXBkYXRlIHdheXBvaW50IHBvc2l0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzW2luZGV4XS5wb3NpdGlvbi5sYXQgPSBsYXQ7XHJcbiAgICAgICAgICAgIHRoaXMubWlzc2lvbi53YXlwb2ludHNbaW5kZXhdLnBvc2l0aW9uLmxuZyA9IGxuZztcclxuICAgICAgICAgICAgLy91cGRhdGUgd2F5cG9pbnQgbGlua3NcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd3YXlwb2ludExpbms6ZHJhZ19zdGFydCcsIGluZGV4LCBsYXQsIGxuZyk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSAoaW5kZXggPiAwID8gaW5kZXggLSAxIDogdGhpcy5taXNzaW9uLndheXBvaW50cy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd3YXlwb2ludExpbms6ZHJhZ19lbmQnLCBuZXh0SW5kZXgsIGxhdCwgbG5nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnd2F5cG9pbnRMaW5rOmNsaWNrJyhpbmRleCwgbGF0LCBsbmcpe1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWFwRWRpdGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaW5zZXJ0IG5ldyB3YXlwb2ludFxyXG4gICAgICAgICAgICBsZXQgbmV3V2F5cG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdub3JtYWwnLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxuZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzLnNwbGljZShpbmRleCsxLCAwLCBuZXdXYXlwb2ludCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHNjcm9sbCB0byBuZXcgd2F5cG9pbnQ/XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgZ29CYWNrKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZ28tYmFjaycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvTGV0dGVyKG51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyVG9MZXR0ZXIobnVtYmVyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b2dnbGVXYXlwb2ludFZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2F5cG9pbnRzVmlzaWJsZSA9ICF0aGlzLndheXBvaW50c1Zpc2libGU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzID0gdGhpcy5taXNzaW9uLndheXBvaW50cy5tYXAoKHdheXBvaW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3YXlwb2ludC52aXNpYmxlID0gdGhpcy53YXlwb2ludHNWaXNpYmxlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB3YXlwb2ludDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldE1hcEVkaXRpbmcodGhpcy53YXlwb2ludHNWaXNpYmxlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZWxldGVXYXlwb2ludChpbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xlYXJXYXlwb2ludHMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlzc2lvbi53YXlwb2ludHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMud2F5cG9pbnRzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWFwRWRpdGluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBHY3NXYXlwb2ludCxcclxuICAgICAgICBHY3NXYXlwb2ludExpbmtcclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1taXNzaW9uIHtcclxuICAgIGhlaWdodDogMTAwJTtcclxuXHJcbiAgICAucm93IHtcclxuICAgICAgICBtYXJnaW4tYm90dG9tOiA0cHg7XHJcblxyXG4gICAgICAgICY6bGFzdC1jaGlsZCB7XHJcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC51aS10b29sYmFyLWJyYW5kIHtcclxuICAgICAgICBtaW4td2lkdGg6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLm5vLXdheXBvaW50cyB7XHJcbiAgICAgICAgZm9udC1zaXplOiAwLjllbTtcclxuICAgICAgICBjb2xvcjogIzc3NztcclxuICAgICAgICBwYWRkaW5nOiAxNnB4O1xyXG4gICAgICAgIG1hcmdpbjogMDtcclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNaXNzaW9uLnZ1ZT9iYzY3OWYxZVxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NXYXlwb2ludC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NXYXlwb2ludC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWFya2Vyc1xcXFxHY3NXYXlwb2ludC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HY3NXYXlwb2ludC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wMGUyM2VhNS9HY3NXYXlwb2ludC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLXdheXBvaW50XCIgOmNsYXNzPVwieyAnaGlnaGxpZ2h0ZWQnOiAoZHJhZ2dpbmcgfHwgaGlnaGxpZ2h0ZWQpIH1cIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibnVtYmVyXCIgdi10ZXh0PVwiaW5kZXggKyAxXCI+PC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDx1aS10ZXh0Ym94XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW5cIiBsYWJlbD1cIlRpdGxlXCIgbmFtZT1cInRpdGxlXCIgOnZhbHVlLnN5bmM9XCJ0aXRsZVwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDx1aS10ZXh0Ym94XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4gb25lLWhhbGZcIiBsYWJlbD1cIkxhdGl0dWRlXCIgbmFtZT1cImxhdGl0dWRlXCIgOnZhbHVlLnN5bmM9XCJsYXRcIlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIiA6c3RlcD1cIjAuMDAwMDFcIlxyXG4gICAgICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cclxuXHJcbiAgICAgICAgICAgICAgICA8dWktdGV4dGJveFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiY29sdW1uIG9uZS1oYWxmXCIgbGFiZWw9XCJMb25naXR1ZGVcIiBuYW1lPVwibG9uZ2l0dWRlXCIgOnZhbHVlLnN5bmM9XCJsbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIiA6c3RlcD1cIjAuMDAwMDFcIlxyXG4gICAgICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICA8dWktc2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4gb25lLWhhbGZcIiBsYWJlbD1cIlR5cGVcIiBuYW1lPVwidHlwZVwiIDp2YWx1ZS5zeW5jPVwidHlwZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOm9wdGlvbnM9XCJbeyB0ZXh0OiAnTm9ybWFsJywgdmFsdWU6ICdub3JtYWwnIH1dXCIgOmRlZmF1bHQ9XCJ0eXBlXCJcclxuICAgICAgICAgICAgICAgID48L3VpLXNlbGVjdD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBpc01hcmtlciBmcm9tICdtaXhpbnMvaXMtbWFya2VyJztcclxuaW1wb3J0IGVsZW1lbnQgZnJvbSAndXRpbC9lbGVtZW50LXNjcm9sbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluZGV4OiBOdW1iZXIsXHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBjb2VyY2U6IFN0cmluZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBjb2VyY2UodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IFN0cmluZyh2YWx1ZSkgOiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHlwZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHtub3JtYWw6ICd5ZWxsb3cnLCBob3ZlcjogJ2xpbWUnfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICBjbGljaygpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyh0aGlzLiRlbCwgbnVsbCwgNTYpOyAvLyA1NnB4IG1hcmdpbiBmb3IgVWlUb29sYmFyXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmlnaHRjbGljaygpIHtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RlbGV0ZScpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRyYWcoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxhdCA9IE51bWJlciggcGFyc2VGbG9hdChlLmxhdExuZy5sYXQoKSkudG9GaXhlZCg3KSApO1xyXG4gICAgICAgICAgICB0aGlzLmxuZyA9IE51bWJlciggcGFyc2VGbG9hdChlLmxhdExuZy5sbmcoKSkudG9GaXhlZCg3KSApO1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnd2F5cG9pbnQ6ZHJhZycsIHRoaXMuaW5kZXgsIHRoaXMubGF0LCB0aGlzLmxuZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbW91c2VvdmVyKCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldEljb24odGhpcy5nZXRJY29uKHRoaXMuZmlsbENvbG9yLmhvdmVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtb3VzZW91dCgpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgJiYgIXRoaXMuZHJhZ2dpbmcpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0SWNvbih0aGlzLmdldEljb24odGhpcy5maWxsQ29sb3Iubm9ybWFsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkcmFnc3RhcnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRyYWdlbmQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBnZXRJY29uKGZpbGxDb2xvciA9IHRoaXMuZmlsbENvbG9yLm5vcm1hbCwgc2NhbGUgPSB0aGlzLnNjYWxlLCByb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IGdvb2dsZS5tYXBzLlN5bWJvbFBhdGguQ0lSQ0xFLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBmaWxsQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtaXhpbnM6IFtcclxuICAgICAgICBpc01hcmtlclxyXG4gICAgXVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLXdheXBvaW50IHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBwYWRkaW5nOiA4cHggMTJweDtcclxuICAgIHBhZGRpbmctdG9wOiAxMnB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMXMgZWFzZTtcclxuXHJcbiAgICAmOm5vdCg6Zmlyc3QtY2hpbGQpIHtcclxuICAgICAgICBwYWRkaW5nLXRvcDogMThweDtcclxuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgI0RERDtcclxuICAgIH1cclxuXHJcbiAgICAmLmhpZ2hsaWdodGVkIHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDMzLCAxNTAsIDI0MywgMC4xNSk7XHJcbiAgICB9XHJcblxyXG4gICAgLm51bWJlciB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgICAgIG1hcmdpbi1yaWdodDogMTZweDtcclxuICAgICAgICBsaW5lLWhlaWdodDogMTtcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgICBtaW4td2lkdGg6IDI0cHg7XHJcbiAgICB9XHJcblxyXG4gICAgLmNvbnRlbnQge1xyXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NXYXlwb2ludC52dWU/ZmJhMzk4OThcbiAqKi8iLCJpbXBvcnQgeyBnZXRNYXAsIGdldE1hcEVsLCBnZXRNYXBMb2FkZWQgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHZ1ZXg6IHtcclxuICAgICAgICBnZXR0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1hcDogZ2V0TWFwLFxyXG4gICAgICAgICAgICBtYXBFbDogZ2V0TWFwRWwsXHJcbiAgICAgICAgICAgIG1hcExvYWRlZDogZ2V0TWFwTG9hZGVkXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXHJcbiAgICAgICAgbGF0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxuZzogIHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm90YXRpb246IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2FsZToge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDZcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2libGU6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhZ2dhYmxlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1hcmtlcjogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgcG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsYXQ6IHRoaXMubGF0LFxyXG4gICAgICAgICAgICAgICAgbG5nOiB0aGlzLmxuZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZU1hcmtlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLm1hcmtlci5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIG1hcExvYWRlZChuZXdWYWwsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICBpZiAoIW9sZFZhbCAmJiBuZXdWYWwgJiYgIXRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVNYXJrZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1hcCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRNYXAodGhpcy5tYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdGl0bGUoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0VGl0bGUodGhpcy50aXRsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsYWJlbCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRMYWJlbCh0aGlzLmxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBvc2l0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdmlzaWJsZSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRWaXNpYmxlKHRoaXMudmlzaWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkcmFnZ2FibGUoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0RHJhZ2dhYmxlKHRoaXMuZHJhZ2dhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdGF0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUljb24oKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzY2FsZSgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVJY29uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZU1hcmtlcigpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogdGhpcy5nZXRJY29uKCksXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRoaXMuZHJhZ2dhYmxlLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgbWFwOiB0aGlzLm1hcFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRUaXRsZSh0aGlzLnRpdGxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldExhYmVsKHRoaXMubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnaW5pdGlhbGl6ZWQnLCB0aGlzLm1hcmtlcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlSWNvbigpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldEljb24odGhpcy5nZXRJY29uKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0dXBFdmVudHMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpY2snLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignZGJsY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RibGNsaWNrJywgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ3JpZ2h0Y2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3JpZ2h0Y2xpY2snLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignbW91c2VvdmVyJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtb3VzZW92ZXInLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignbW91c2VvdXQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21vdXNlb3V0JywgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ2RyYWdzdGFydCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZHJhZ3N0YXJ0JywgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ2RyYWcnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RyYWcnLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignZHJhZ2VuZCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZHJhZ2VuZCcsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdwb3NpdGlvbl9jaGFuZ2VkJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdwb3NpdGlvbl9jaGFuZ2VkJywgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbWl4aW5zL2lzLW1hcmtlci5qc1xuICoqLyIsImV4cG9ydCBmdW5jdGlvbiBpblZpZXcoZWxlbWVudCwgY29udGFpbmVyKSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHJcbiAgICBsZXQgdG9wID0gZWxlbWVudC5vZmZzZXRUb3A7XHJcbiAgICBsZXQgcGFyZW50VG9wID0gY29udGFpbmVyLnNjcm9sbFRvcDtcclxuICAgIGxldCBib3R0b20gPSB0b3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICAgIGxldCBwYXJlbnRCb3R0b20gPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiB0b3AgPj0gcGFyZW50VG9wICYmIGJvdHRvbSA8PSBwYXJlbnRCb3R0b207XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtZW50LCBjb250YWluZXIsIG1hcmdpblRvcCA9IDApIHtcclxuICAgIGlmICghZWxlbWVudCB8fCBpblZpZXcoZWxlbWVudCwgY29udGFpbmVyKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG5cclxuICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcCAtIG1hcmdpblRvcDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvU3RhcnQoZWxlbWVudCkge1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvRW5kKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBpblZpZXcsXHJcbiAgICBzY3JvbGxJbnRvVmlldyxcclxuICAgIHNjcm9sbFRvU3RhcnQsXHJcbiAgICBzY3JvbGxUb0VuZFxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy91dGlsL2VsZW1lbnQtc2Nyb2xsLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy13YXlwb2ludFxcXCIgOmNsYXNzPVxcXCJ7ICdoaWdobGlnaHRlZCc6IChkcmFnZ2luZyB8fCBoaWdobGlnaHRlZCkgfVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm51bWJlclxcXCIgdi10ZXh0PVxcXCJpbmRleCArIDFcXFwiPjwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPHVpLXRleHRib3hcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNvbHVtblxcXCIgbGFiZWw9XFxcIlRpdGxlXFxcIiBuYW1lPVxcXCJ0aXRsZVxcXCIgOnZhbHVlLnN5bmM9XFxcInRpdGxlXFxcIlxcbiAgICAgICAgICAgID48L3VpLXRleHRib3g+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPHVpLXRleHRib3hcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNvbHVtbiBvbmUtaGFsZlxcXCIgbGFiZWw9XFxcIkxhdGl0dWRlXFxcIiBuYW1lPVxcXCJsYXRpdHVkZVxcXCIgOnZhbHVlLnN5bmM9XFxcImxhdFxcXCJcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwibnVtYmVyXFxcIiA6c3RlcD1cXFwiMC4wMDAwMVxcXCJcXG4gICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxcblxcbiAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2x1bW4gb25lLWhhbGZcXFwiIGxhYmVsPVxcXCJMb25naXR1ZGVcXFwiIG5hbWU9XFxcImxvbmdpdHVkZVxcXCIgOnZhbHVlLnN5bmM9XFxcImxuZ1xcXCJcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwibnVtYmVyXFxcIiA6c3RlcD1cXFwiMC4wMDAwMVxcXCJcXG4gICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDx1aS1zZWxlY3RcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNvbHVtbiBvbmUtaGFsZlxcXCIgbGFiZWw9XFxcIlR5cGVcXFwiIG5hbWU9XFxcInR5cGVcXFwiIDp2YWx1ZS5zeW5jPVxcXCJ0eXBlXFxcIlxcbiAgICAgICAgICAgICAgICA6b3B0aW9ucz1cXFwiW3sgdGV4dDogJ05vcm1hbCcsIHZhbHVlOiAnbm9ybWFsJyB9XVxcXCIgOmRlZmF1bHQ9XFxcInR5cGVcXFwiXFxuICAgICAgICAgICAgPjwvdWktc2VsZWN0PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc1dheXBvaW50TGluay52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NXYXlwb2ludExpbmsudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcmtlcnNcXFxcR2NzV2F5cG9pbnRMaW5rLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc1dheXBvaW50TGluay52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1iODU4MTE4Mi9HY3NXYXlwb2ludExpbmsudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludExpbmsudnVlXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLXdheXBvaW50LWxpbmtcIj48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IGdldE1hcCwgZ2V0TWFwTG9hZGVkIH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgZ2V0dGVyczoge1xyXG4gICAgICAgICAgICBtYXA6IGdldE1hcCxcclxuICAgICAgICAgICAgbWFwTG9hZGVkOiBnZXRNYXBMb2FkZWRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5kZXg6IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhcnQ6IHtcclxuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2libGU6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW5rOiBudWxsLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjoge25vcm1hbDogJ2JsYWNrJywgaG92ZXI6ICdncmVlbid9XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxpbmsoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5saW5rLnNldE1hcChudWxsKTtcclxuICAgICAgICB0aGlzLmxpbmsgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIG1hcExvYWRlZChuZXdWYWwsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICBpZiAoIW9sZFZhbCAmJiBuZXdWYWwgJiYgIXRoaXMubGluaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGluaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbWFwKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0TWFwKHRoaXMubWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0YXJ0KCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmspe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmdldFBhdGgoKS5zZXRBdCgwLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHRoaXMuc3RhcnQubGF0LCB0aGlzLnN0YXJ0LmxuZykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW5kKCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmspe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmdldFBhdGgoKS5zZXRBdCgxLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHRoaXMuZW5kLmxhdCwgdGhpcy5lbmQubG5nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBpbml0aWFsaXplTGluaygpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IFt0aGlzLnN0YXJ0LCB0aGlzLmVuZF0sXHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5zdHJva2VDb2xvci5ub3JtYWwsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAzLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgbWFwOiB0aGlzLm1hcFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5saW5rLmFkZExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF0ID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxhdCgpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnd2F5cG9pbnRMaW5rOmNsaWNrJywgdGhpcy5pbmRleCwgbGF0LCBsbmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5saW5rLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0T3B0aW9ucyh7c3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3IuaG92ZXJ9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubGluay5hZGRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0T3B0aW9ucyh7c3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3Iubm9ybWFsfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICAgJ3dheXBvaW50TGluazpkcmFnX3N0YXJ0JyhpbmRleCwgbGF0LCBsbmcpe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBpbmRleCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0ge2xhdDogbGF0LCBsbmc6IGxuZ307XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3dheXBvaW50TGluazpkcmFnX2VuZCcoaW5kZXgsIGxhdCwgbG5nKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gaW5kZXgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmQgPSB7bGF0OiBsYXQsIGxuZzogbG5nfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLXdheXBvaW50LWxpbmsge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NXYXlwb2ludExpbmsudnVlPzg0Yzg3ZDE0XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy13YXlwb2ludC1saW5rXFxcIj48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgIGlmIChudW1iZXIgPiA1Mikge1xyXG4gICAgICAgIHJldHVybiAnMCc7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFscGhhYmV0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCcnKTtcclxuXHJcbiAgICByZXR1cm4gYWxwaGFiZXRbbnVtYmVyIC0gMV07XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdXRpbC9udW1iZXItdG8tbGV0dGVyLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1taXNzaW9uXFxcIj5cXG4gICAgPHVpLXRvb2xiYXIgOnRpdGxlPVxcXCJtaXNzaW9uLnRpdGxlXFxcIiBoaWRlLW5hdi1pY29uIHNob3ctYnJhbmQgOnNob3ctYnJhbmQtZGl2aWRlcj1cXFwiZmFsc2VcXFwiPlxcbiAgICAgICAgPGRpdiBzbG90PVxcXCJicmFuZFxcXCI+XFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwiZ29CYWNrXFxcIiB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiYXJyb3dfYmFja1xcXCIgdG9vbHRpcD1cXFwiQmFjayB0byBNaXNzaW9uc1xcXCJcXG4gICAgICAgICAgICAgICAgdG9vbHRpcC1wb3NpdGlvbj1cXFwiYm90dG9tIGxlZnRcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgc2xvdD1cXFwiYWN0aW9uc1xcXCI+XFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNsZWFyXFxcIiBpY29uPVxcXCJmaWxlX3VwbG9hZFxcXCIgdG9vbHRpcD1cXFwiVXBsb2FkIE1pc3Npb25cXFwiIEBjbGljaz1cXFwidXBsb2FkTWlzc2lvblxcXCJcXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIGljb249XFxcImNsZWFyX2FsbFxcXCIgdG9vbHRpcD1cXFwiQ2xlYXIgYWxsXFxcIiBAY2xpY2s9XFxcImNsZWFyV2F5cG9pbnRzXFxcIlxcbiAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgOmljb249XFxcIndheXBvaW50c1Zpc2libGUgPyAndmlzaWJpbGl0eScgOiAndmlzaWJpbGl0eV9vZmYnXFxcIlxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcInRvZ2dsZVdheXBvaW50VmlzaWJpbGl0eVxcXCJcXG4gICAgICAgICAgICAgICAgOnRvb2x0aXA9XFxcIndheXBvaW50c1Zpc2libGUgPyAnSGlkZSB3YXlwb2ludHMnIDogJ1Nob3cgd2F5cG9pbnRzJ1xcXCJcXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIGljb249XFxcIm1vcmVfdmVydFxcXCIgaGFzLWRyb3Bkb3duLW1lbnUgZHJvcGRvd24tcG9zaXRpb249XFxcImJvdHRvbSByaWdodFxcXCJcXG4gICAgICAgICAgICAgICAgOm1lbnUtb3B0aW9ucz1cXFwib3ZlcmZsb3dNZW51XFxcIlxcbiAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvdWktdG9vbGJhcj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2lkZWJhci1wYWdlLWNvbnRlbnRcXFwiIHYtZWw6cGFnZS1jb250ZW50PlxcbiAgICAgICAgPHBcXG4gICAgICAgICAgICBjbGFzcz1cXFwibm8td2F5cG9pbnRzXFxcIiB2LWlmPVxcXCIhbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXFxcIlxcbiAgICAgICAgPk5vIHdheXBvaW50cyBmb3IgdGhpcyBtaXNzaW9uLiBDbGljayB0aGUgbWFwIHRvIGFkZCBhIHdheXBvaW50LjwvcD5cXG5cXG4gICAgICAgIDxjb21wb25lbnQgdi1lbHNlPlxcbiAgICAgICAgICAgIDxnY3Mtd2F5cG9pbnRcXG4gICAgICAgICAgICAgICAgdi1mb3I9XFxcIihpbmRleCwgd2F5cG9pbnQpIGluIG1pc3Npb24ud2F5cG9pbnRzXFxcIiA6aW5kZXg9XFxcImluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICA6bGFiZWw9XFxcInRvTGV0dGVyKGluZGV4ICsgMSlcXFwiIDp0aXRsZT1cXFwid2F5cG9pbnQudGl0bGVcXFwiIDp0eXBlPVxcXCJ3YXlwb2ludC50eXBlXFxcIlxcbiAgICAgICAgICAgICAgICA6bGF0PVxcXCJ3YXlwb2ludC5wb3NpdGlvbi5sYXRcXFwiIDpsbmc9XFxcIndheXBvaW50LnBvc2l0aW9uLmxuZ1xcXCIgOnZpc2libGU9XFxcIndheXBvaW50LnZpc2libGVcXFwiXFxuICAgICAgICAgICAgICAgIDpyb3RhdGlvbj1cXFwid2F5cG9pbnQucm90YXRpb25cXFwiIDpzY2FsZT1cXFwiMTBcXFwiIGRyYWdnYWJsZVxcbiAgICAgICAgICAgICAgICBAZGVsZXRlPVxcXCJkZWxldGVXYXlwb2ludChpbmRleClcXFwiXFxuICAgICAgICAgICAgPjwvZ2NzLXdheXBvaW50PlxcbiAgICAgICAgICAgIDxnY3Mtd2F5cG9pbnQtbGlua1xcbiAgICAgICAgICAgICAgICB2LWZvcj1cXFwiKGluZGV4LCB3YXlwb2ludCkgaW4gbWlzc2lvbi53YXlwb2ludHNcXFwiXFxuICAgICAgICAgICAgICAgIDppbmRleD1cXFwiaW5kZXhcXFwiXFxuICAgICAgICAgICAgICAgIDpzdGFydD1cXFwid2F5cG9pbnQucG9zaXRpb25cXFwiXFxuICAgICAgICAgICAgICAgIDplbmQ9XFxcIm1pc3Npb24ud2F5cG9pbnRzWyhpbmRleCsxKSAlIG1pc3Npb24ud2F5cG9pbnRzLmxlbmd0aF0ucG9zaXRpb247XFxcIlxcbiAgICAgICAgICAgID48L2djcy13YXlwb2ludC1saW5rPlxcbiAgICAgICAgPC9jb21wb25lbnQ+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzTWlzc2lvblJvdy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NNaXNzaW9uUm93LnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtaXNzaW9uXFxcXEdjc01pc3Npb25Sb3cudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzTWlzc2lvblJvdy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1mZTA1OGRiNi9HY3NNaXNzaW9uUm93LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLW1pc3Npb24tcm93XCI+XHJcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJkZWxldGVcIiBjbGFzcz1cImRlbGV0ZS1idXR0b25cIiB0b29sdGlwPVwiRGVsZXRlXCIgQGNsaWNrPVwiZGVsZXRlTWlzc2lvblwiXHJcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgIDxoMyBjbGFzcz1cIm1pc3Npb24taGVhZGVyXCIgdi10ZXh0PVwibWlzc2lvbi50aXRsZVwiPjwvaDM+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJtaXNzaW9uLXN1bW1hcnlcIj5cclxuICAgICAgICAgICAgPHAgY2xhc3M9XCJkZXNjcmlwdGlvblwiIHYtaWY9XCJtaXNzaW9uLmRlc2NyaXB0aW9uXCIgdi10ZXh0PVwibWlzc2lvbi5kZXNjcmlwdGlvblwiPjwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwIGNsYXNzPVwid2F5cG9pbnRzXCIgdi1pZj1cIiFtaXNzaW9uLmRlc2NyaXB0aW9uICYmIGhhc1dheXBvaW50c1wiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4+RnJvbTogKHt7IGZpcnN0V2F5cG9pbnQucG9zaXRpb24ubGF0IH19LCB7eyBmaXJzdFdheXBvaW50LnBvc2l0aW9uLmxuZyB9fSk8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj5UbzogKHt7IGxhc3RXYXlwb2ludC5wb3NpdGlvbi5sYXQgfX0sIHt7IGxhc3RXYXlwb2ludC5wb3NpdGlvbi5sbmcgfX0pPC9zcGFuPlxyXG4gICAgICAgICAgICA8L3A+XHJcblxyXG4gICAgICAgICAgICA8cCBjbGFzcz1cIm5vLXdheXBvaW50c1wiIHYtaWY9XCIhbWlzc2lvbi5kZXNjcmlwdGlvbiAmJiAhaGFzV2F5cG9pbnRzXCI+Tm8gd2F5cG9pbnRzPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIG1pc3Npb246IHtcclxuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5kZXg6IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBoYXNXYXlwb2ludHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pc3Npb24ud2F5cG9pbnRzICYmIHRoaXMubWlzc2lvbi53YXlwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpcnN0V2F5cG9pbnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pc3Npb24ud2F5cG9pbnRzWzBdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGxhc3RXYXlwb2ludCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlzc2lvbi53YXlwb2ludHNbdGhpcy5taXNzaW9uLndheXBvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBkZWxldGVNaXNzaW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkZWxldGUtbWlzc2lvbicsIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1taXNzaW9uLXJvdyB7XHJcbiAgICBwYWRkaW5nOiAxMnB4O1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNFRUU7XHJcblxyXG4gICAgJjpob3ZlcixcclxuICAgICY6Zm9jdXMge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNFRUU7XHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDQ4cHg7XHJcblxyXG4gICAgICAgIC5taXNzaW9uLWhlYWRlciB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAkcHJpbWFyeS1kYXJrZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAuZGVsZXRlLWJ1dHRvbiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAubWlzc2lvbi1oZWFkZXIge1xyXG4gICAgICAgIG1hcmdpbjogMDtcclxuICAgICAgICBmb250LXdlaWdodDogbm9ybWFsO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMS4xZW07XHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgQGV4dGVuZHMgJHRydW5jYXRlLXRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLm1pc3Npb24tc3VtbWFyeSB7XHJcbiAgICAgICAgcGFkZGluZy10b3A6IDhweDtcclxuICAgICAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMC45ZW07XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE7XHJcbiAgICAgICAgY29sb3I6ICM3Nzc7XHJcblxyXG4gICAgICAgIHAge1xyXG4gICAgICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgICAgIEBleHRlbmRzICR0cnVuY2F0ZS10ZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAubm8td2F5cG9pbnRzIHtcclxuICAgICAgICBwYWRkaW5nOiAwO1xyXG4gICAgICAgIG1hcmdpbjogMDtcclxuICAgICAgICBjb2xvcjogI0FBQTtcclxuICAgIH1cclxuXHJcbiAgICAuZGVsZXRlLWJ1dHRvbiB7XHJcbiAgICAgICAgcmlnaHQ6IDZweDtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgZGlzcGxheTogbm9uZTtcclxuICAgICAgICBjb2xvcjogJGRhcmstc2Vjb25kYXJ5O1xyXG5cclxuICAgICAgICAmOmhvdmVyIHtcclxuICAgICAgICAgICAgY29sb3I6ICRkYXJrLXByaW1hcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAudWktaWNvbiB7XHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWlzc2lvblJvdy52dWU/NjFmODE2MjRcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLW1pc3Npb24tcm93XFxcIj5cXG4gICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiZGVsZXRlXFxcIiBjbGFzcz1cXFwiZGVsZXRlLWJ1dHRvblxcXCIgdG9vbHRpcD1cXFwiRGVsZXRlXFxcIiBAY2xpY2s9XFxcImRlbGV0ZU1pc3Npb25cXFwiXFxuICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICA8aDMgY2xhc3M9XFxcIm1pc3Npb24taGVhZGVyXFxcIiB2LXRleHQ9XFxcIm1pc3Npb24udGl0bGVcXFwiPjwvaDM+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcIm1pc3Npb24tc3VtbWFyeVxcXCI+XFxuICAgICAgICA8cCBjbGFzcz1cXFwiZGVzY3JpcHRpb25cXFwiIHYtaWY9XFxcIm1pc3Npb24uZGVzY3JpcHRpb25cXFwiIHYtdGV4dD1cXFwibWlzc2lvbi5kZXNjcmlwdGlvblxcXCI+PC9wPlxcblxcbiAgICAgICAgPHAgY2xhc3M9XFxcIndheXBvaW50c1xcXCIgdi1pZj1cXFwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgaGFzV2F5cG9pbnRzXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5Gcm9tOiAoe3sgZmlyc3RXYXlwb2ludC5wb3NpdGlvbi5sYXQgfX0sIHt7IGZpcnN0V2F5cG9pbnQucG9zaXRpb24ubG5nIH19KTwvc3Bhbj5cXG4gICAgICAgICAgICA8c3Bhbj5UbzogKHt7IGxhc3RXYXlwb2ludC5wb3NpdGlvbi5sYXQgfX0sIHt7IGxhc3RXYXlwb2ludC5wb3NpdGlvbi5sbmcgfX0pPC9zcGFuPlxcbiAgICAgICAgPC9wPlxcblxcbiAgICAgICAgPHAgY2xhc3M9XFxcIm5vLXdheXBvaW50c1xcXCIgdi1pZj1cXFwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgIWhhc1dheXBvaW50c1xcXCI+Tm8gd2F5cG9pbnRzPC9wPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1taXNzaW9uc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItcGFnZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtaXNzaW9ucy1saXN0XFxcIiB2LWlmPVxcXCJjdXJyZW50VmlldyA9PT0gJ2xpc3RpbmcnXFxcIj5cXG4gICAgICAgICAgICA8dWktdG9vbGJhciB0aXRsZT1cXFwiTWlzc2lvbnNcXFwiIGhpZGUtbmF2LWljb24+XFxuICAgICAgICAgICAgICAgIDxkaXYgc2xvdD1cXFwiYWN0aW9uc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiYWRkXFxcIiB0b29sdGlwPVxcXCJBZGQgbWlzc2lvblxcXCIgQGNsaWNrPVxcXCJhZGRNaXNzaW9uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwibW9yZV92ZXJ0XFxcIiBoYXMtZHJvcGRvd24tbWVudVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLXBvc2l0aW9uPVxcXCJib3R0b20gcmlnaHRcXFwiIDptZW51LW9wdGlvbnM9XFxcIm92ZXJmbG93TWVudVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XFxcIm1lbnVPcHRpb25TZWxlY3RlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L3VpLXRvb2xiYXI+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2lkZWJhci1wYWdlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibGFuay1zdGF0ZVxcXCIgdi1pZj1cXFwiIW1pc3Npb25zLmxlbmd0aFxcXCI+Tm8gbWlzc2lvbnM8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGdjcy1taXNzaW9uLXJvd1xcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XFxcIihpbmRleCwgbWlzc2lvbikgaW4gbWlzc2lvbnNcXFwiIDppbmRleD1cXFwiaW5kZXhcXFwiIDptaXNzaW9uPVxcXCJtaXNzaW9uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJzZWxlY3RNaXNzaW9uKGluZGV4KVxcXCJcXG4gICAgICAgICAgICAgICAgPjwvZ2NzLW1pc3Npb24tcm93PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8Y29tcG9uZW50XFxuICAgICAgICAgICAgdi1lbHNlIDppcz1cXFwiY3VycmVudFZpZXdcXFwiIDptaXNzaW9uPVxcXCJjdXJyZW50TWlzc2lvblxcXCIgQGdvLWJhY2s9XFxcInNob3dMaXN0aW5nVmlld1xcXCJcXG4gICAgICAgID48L2NvbXBvbmVudD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuPCEtLSBoaWRkZW4gaW5wdXQgZWxlbWVudCB1c2VkIGZvciBzZWxlY3RpbmcgYSBmaWxlIHRvIGltcG9ydCBmcm9tIC0tPlxcbjxpbnB1dCB0eXBlPVxcXCJmaWxlXFxcIiBpZD1cXFwiaW1wb3J0X21pc3Npb25zX2lucHV0XFxcIiBAY2hhbmdlPVxcXCJpbXBvcnRNaXNzaW9uXFxcIj5cXG48IS0tIGhpZGRlbiBsaW5rIHVzZWQgZm9yIHByb21wdGluZyBhIGRvd25sb2FkIC0tPlxcbjxhIGlkPVxcXCJleHBvcnRfbWlzc2lvbnNfbGlua1xcXCI+PC9hPlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1tYXAtc2lkZWJhclxcXCIgdi1zaG93PVxcXCJzaG93U2lkZWJhclxcXCIgdHJhbnNpdGlvbj1cXFwic2lkZWJhci1jb2xsYXBzZVxcXCI+XFxuICAgIDxnY3MtbWlzc2lvbnM+PC9nY3MtbWlzc2lvbnM+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwU2lkZWJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc1NpZGViYXJDb250cm9scy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NTaWRlYmFyQ29udHJvbHMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcFxcXFxHY3NTaWRlYmFyQ29udHJvbHMudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWFhMTgxNzBhL0djc1NpZGViYXJDb250cm9scy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2XHJcbiAgICAgICAgY2xhc3M9XCJnY3Mtc2lkZWJhci1jb250cm9sc1wiXHJcbiAgICAgICAgOnN0eWxlPVwieyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKCcgKyAoc2hvd1NpZGViYXIgPyAnMzc2cHgnIDogJzE2cHgnICsgJyknKSB9XCJcclxuICAgID5cclxuICAgICAgICA8dWktYnV0dG9uXHJcbiAgICAgICAgICAgIDpjb2xvcj1cInNob3dTaWRlYmFyID8gJ3ByaW1hcnknIDogJ2RlZmF1bHQnXCIgQGNsaWNrPVwidG9nZ2xlU2lkZWJhclwiXHJcbiAgICAgICAgPk1pc3Npb25zPC91aS1idXR0b24+XHJcblxyXG4gICAgICAgIDx1aS1idXR0b24gdi1pZj1cImN1cnJlbnRNaXNzaW9uSW5kZXggIT0gLTFcIiBoYXMtcG9wb3ZlciB0ZXh0PVwiQ29tbWFuZHNcIj5cclxuICAgICAgICAgICAgPGRpdiBzbG90PVwicG9wb3ZlclwiIGNsYXNzPVwiZ2NzLXNpZGViYXItY29udHJvbHMtcG9wb3ZlclwiPlxyXG4gICAgICAgICAgICAgICAgPGdjcy1jb21tYW5kcz48L2djcy1jb21tYW5kcz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC91aS1idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBHY3NDb21tYW5kcyBmcm9tICdtYXAvR2NzQ29tbWFuZHMudnVlJztcclxuaW1wb3J0IHsgZ2V0Q3VycmVudE1pc3Npb25JbmRleCB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgY3VycmVudE1pc3Npb25JbmRleDogZ2V0Q3VycmVudE1pc3Npb25JbmRleFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBzaG93U2lkZWJhcjoge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHRvZ2dsZVNpZGViYXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCd0b2dnbGUtc2lkZWJhcicpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY29tcG9uZW50czoge1xyXG4gICAgICAgIEdjc0NvbW1hbmRzXHJcbiAgICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3Mtc2lkZWJhci1jb250cm9scyB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAxNnB4O1xyXG4gICAgbGVmdDogMDtcclxuICAgIHotaW5kZXg6IDE7XHJcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDE2cHgpO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCAwIGFscGhhKGJsYWNrLCAwLjIpLCAwIDJweCAxMHB4IDAgYWxwaGEoYmxhY2ssIDAuMTYpO1xyXG5cclxuICAgIC51aS1idXR0b24ge1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XHJcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI0NDQztcclxuICAgICAgICBoZWlnaHQ6IDMycHg7XHJcblxyXG4gICAgICAgIC51aS1idXR0b24tZHJvcGRvd24taWNvbiB7XHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcclxuICAgICAgICAgICAgbWFyZ2luLXRvcDogLTJweDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYuY29sb3ItZGVmYXVsdDpub3QoLmRyb3Bkb3duLW9wZW4pIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYuY29sb3ItcHJpbWFyeSB7XHJcbiAgICAgICAgICAgIGJvcmRlci1yaWdodDogbm9uZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICY6bGFzdC1jaGlsZCB7XHJcbiAgICAgICAgICAgIGJvcmRlci1yaWdodDogbm9uZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZT9mMzM2ZTMxYVxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NDb21tYW5kcy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NDb21tYW5kcy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWFwXFxcXEdjc0NvbW1hbmRzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc0NvbW1hbmRzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTRjMmIxZDhmL0djc0NvbW1hbmRzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWVcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFwL0djc0NvbW1hbmRzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLWNvbW1hbmRzXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICA8dWktYnV0dG9uIEBjbGljaz1cInVwbG9hZE1pc3Npb25cIj5VcGxvYWQgTWlzc2lvbjwvdWktYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVwiZG93bmxvYWRNaXNzaW9uXCI+RG93bmxvYWQgTWlzc2lvbjwvdWktYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDx1aS1idXR0b25cclxuICAgICAgICAgICAgICAgIHYtaWY9XCJ3YW12Lm1vZGUgPT0gJ2lkbGUnIHx8IHdhbXYubW9kZSA9PSAncGF1c2VkJ1wiXHJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCJzdGFydE1pc3Npb25cIlxyXG4gICAgICAgICAgICA+U3RhcnQ8L3VpLWJ1dHRvbj5cclxuICAgICAgICAgICAgPHVpLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgdi1pZj1cIndhbXYubW9kZSA9PSAncGF1c2VkJ1wiXHJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCJyZXN1bWVNaXNzaW9uXCJcclxuICAgICAgICAgICAgPlJlc3VtZTwvdWktYnV0dG9uPlxyXG4gICAgICAgICAgICA8dWktYnV0dG9uXHJcbiAgICAgICAgICAgICAgICB2LWlmPVwid2Ftdi5tb2RlID09ICdhdXRvJ1wiXHJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCJzdG9wTWlzc2lvblwiXHJcbiAgICAgICAgICAgID5TdG9wPC91aS1idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIiB2LWlmPVwid2Ftdi5sb2FkZWRcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtaGFsZlwiPiB7eyBpc0FybWVkID8gJ0FybWVkJyA6ICdEaXNhcm1lZCcgfX08L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtaGFsZlwiPlxyXG4gICAgICAgICAgICAgICAgPHVpLXN3aXRjaCA6dmFsdWUuc3luYz1cImlzQXJtZWRcIj48L3VpLXN3aXRjaD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgPHVpLWJ1dHRvbiBjb2xvcj1cImRhbmdlclwiXHJcbiAgICAgICAgICAgICAgICB2LWlmPVwid2Ftdi5tb2RlICE9ICdraWxsZWQnXCIgQGNsaWNrPVwia2lsbFwiXHJcbiAgICAgICAgICAgID5LaWxsPC91aS1idXR0b24+XHJcbiAgICAgICAgICAgIDx1aS1idXR0b25cclxuICAgICAgICAgICAgICAgIHYtaWY9XCJ3YW12Lm1vZGUgPT0gJ2tpbGxlZCdcIiBAY2xpY2s9XCJ1bmtpbGxcIlxyXG4gICAgICAgICAgICA+VW5raWxsPC91aS1idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7XHJcbiAgICBnZXRXYW12LCBnZXRNaXNzaW9ucywgZ2V0Q3VycmVudE1pc3Npb25JbmRleCxcclxuICAgIGdldE1lc3NhZ2VTdGF0ZVdhaXRpbmcsIGdldE1lc3NhZ2VTdGF0ZVN1Y2Nlc3MsIGdldE1lc3NhZ2VTdGF0ZUZhaWx1cmUsXHJcbiAgICBnZXRVcGxvYWRNaXNzaW9uU3RhdGUsIGdldFVwbG9hZE1pc3Npb25EYXRhLFxyXG4gICAgZ2V0RG93bmxvYWRNaXNzaW9uU3RhdGUsIGdldERvd25sb2FkTWlzc2lvbkRhdGEsXHJcbiAgICBnZXRTdGFydE1pc3Npb25TdGF0ZSwgZ2V0U3RhcnRNaXNzaW9uRGF0YSxcclxuICAgIGdldFN0b3BNaXNzaW9uU3RhdGUsIGdldFN0b3BNaXNzaW9uRGF0YSxcclxuICAgIGdldFJlc3VtZU1pc3Npb25TdGF0ZSwgZ2V0UmVzdW1lTWlzc2lvbkRhdGEsXHJcbiAgICBnZXRBcm1TdGF0ZSwgZ2V0QXJtRGF0YSxcclxuICAgIGdldERpc2FybVN0YXRlLCBnZXREaXNhcm1EYXRhLFxyXG4gICAgZ2V0S2lsbFN0YXRlLCBnZXRLaWxsRGF0YSxcclxuICAgIGdldFVua2lsbFN0YXRlLCBnZXRVbmtpbGxEYXRhXHJcbn0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XHJcbmltcG9ydCB7XHJcbiAgICBzZXRXYW12QXJtZWQsIHNldEN1cnJlbnRNaXNzaW9uLFxyXG4gICAgc2VuZFVwbG9hZE1pc3Npb24sIGZhaWxVcGxvYWRNaXNzaW9uLFxyXG4gICAgc2VuZERvd25sb2FkTWlzc2lvbiwgZmFpbERvd25sb2FkTWlzc2lvbixcclxuICAgIHNlbmRTdGFydE1pc3Npb24sIGZhaWxTdGFydE1pc3Npb24sXHJcbiAgICBzZW5kU3RvcE1pc3Npb24sIGZhaWxTdG9wTWlzc2lvbixcclxuICAgIHNlbmRSZXN1bWVNaXNzaW9uLCBmYWlsUmVzdW1lTWlzc2lvbixcclxuICAgIHNlbmRBcm0sIGZhaWxBcm0sXHJcbiAgICBzZW5kRGlzYXJtLCBmYWlsRGlzYXJtLFxyXG4gICAgc2VuZEtpbGwsIGZhaWxLaWxsLFxyXG4gICAgc2VuZFVua2lsbCwgZmFpbFVua2lsbFxyXG59IGZyb20gJ3N0b3JlL2FjdGlvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgd2FtdjogICAgICAgICAgICAgICAgIGdldFdhbXYsXHJcbiAgICAgICAgICAgIG1pc3Npb25zOiAgICAgICAgICAgICBnZXRNaXNzaW9ucyxcclxuICAgICAgICAgICAgV0FJVElORzogICAgICAgICAgICAgIGdldE1lc3NhZ2VTdGF0ZVdhaXRpbmcsXHJcbiAgICAgICAgICAgIFNVQ0NFU1M6ICAgICAgICAgICAgICBnZXRNZXNzYWdlU3RhdGVTdWNjZXNzLFxyXG4gICAgICAgICAgICBGQUlMVVJFOiAgICAgICAgICAgICAgZ2V0TWVzc2FnZVN0YXRlRmFpbHVyZSxcclxuICAgICAgICAgICAgY3VycmVudE1pc3Npb25JbmRleDogIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgsXHJcbiAgICAgICAgICAgIHVwbG9hZE1pc3Npb25TdGF0ZTogICBnZXRVcGxvYWRNaXNzaW9uU3RhdGUsXHJcbiAgICAgICAgICAgIHVwbG9hZE1pc3Npb25EYXRhOiAgICBnZXRVcGxvYWRNaXNzaW9uRGF0YSxcclxuICAgICAgICAgICAgZG93bmxvYWRNaXNzaW9uU3RhdGU6IGdldERvd25sb2FkTWlzc2lvblN0YXRlLFxyXG4gICAgICAgICAgICBkb3dubG9hZE1pc3Npb25EYXRhOiAgZ2V0RG93bmxvYWRNaXNzaW9uRGF0YSxcclxuICAgICAgICAgICAgc3RhcnRNaXNzaW9uU3RhdGU6ICAgIGdldFN0YXJ0TWlzc2lvblN0YXRlLFxyXG4gICAgICAgICAgICBzdGFydE1pc3Npb25EYXRhOiAgICAgZ2V0U3RhcnRNaXNzaW9uRGF0YSxcclxuICAgICAgICAgICAgc3RvcE1pc3Npb25TdGF0ZTogICAgIGdldFN0b3BNaXNzaW9uU3RhdGUsXHJcbiAgICAgICAgICAgIHN0b3BNaXNzaW9uRGF0YTogICAgICBnZXRTdG9wTWlzc2lvbkRhdGEsXHJcbiAgICAgICAgICAgIHJlc3VtZU1pc3Npb25TdGF0ZTogICBnZXRSZXN1bWVNaXNzaW9uU3RhdGUsXHJcbiAgICAgICAgICAgIHJlc3VtZU1pc3Npb25EYXRhOiAgICBnZXRSZXN1bWVNaXNzaW9uRGF0YSxcclxuICAgICAgICAgICAgYXJtU3RhdGU6ICAgICAgICAgICAgIGdldEFybVN0YXRlLFxyXG4gICAgICAgICAgICBhcm1EYXRhOiAgICAgICAgICAgICAgZ2V0QXJtRGF0YSxcclxuICAgICAgICAgICAgZGlzYXJtU3RhdGU6ICAgICAgICAgIGdldERpc2FybVN0YXRlLFxyXG4gICAgICAgICAgICBkaXNhcm1EYXRhOiAgICAgICAgICAgZ2V0RGlzYXJtRGF0YSxcclxuICAgICAgICAgICAga2lsbFN0YXRlOiAgICAgICAgICAgIGdldEtpbGxTdGF0ZSxcclxuICAgICAgICAgICAga2lsbERhdGE6ICAgICAgICAgICAgIGdldEtpbGxEYXRhLFxyXG4gICAgICAgICAgICB1bmtpbGxTdGF0ZTogICAgICAgICAgZ2V0VW5raWxsU3RhdGUsXHJcbiAgICAgICAgICAgIHVua2lsbERhdGE6ICAgICAgICAgICBnZXRVbmtpbGxEYXRhLFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgc2V0QXJtZWQ6IHNldFdhbXZBcm1lZCxcclxuICAgICAgICAgICAgc2V0Q3VycmVudE1pc3Npb24sXHJcbiAgICAgICAgICAgIHNlbmRVcGxvYWRNaXNzaW9uLFxyXG4gICAgICAgICAgICBmYWlsVXBsb2FkTWlzc2lvbixcclxuICAgICAgICAgICAgc2VuZERvd25sb2FkTWlzc2lvbixcclxuICAgICAgICAgICAgZmFpbERvd25sb2FkTWlzc2lvbixcclxuICAgICAgICAgICAgc2VuZFN0YXJ0TWlzc2lvbixcclxuICAgICAgICAgICAgZmFpbFN0YXJ0TWlzc2lvbixcclxuICAgICAgICAgICAgc2VuZFN0b3BNaXNzaW9uLFxyXG4gICAgICAgICAgICBmYWlsU3RvcE1pc3Npb24sXHJcbiAgICAgICAgICAgIHNlbmRSZXN1bWVNaXNzaW9uLFxyXG4gICAgICAgICAgICBmYWlsUmVzdW1lTWlzc2lvbixcclxuICAgICAgICAgICAgc2VuZEFybSxcclxuICAgICAgICAgICAgZmFpbEFybSxcclxuICAgICAgICAgICAgc2VuZERpc2FybSxcclxuICAgICAgICAgICAgZmFpbERpc2FybSxcclxuICAgICAgICAgICAgc2VuZEtpbGwsXHJcbiAgICAgICAgICAgIGZhaWxLaWxsLFxyXG4gICAgICAgICAgICBzZW5kVW5raWxsLFxyXG4gICAgICAgICAgICBmYWlsVW5raWxsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIC8vIFRPRE86IHVpLXN3aXRjaCBkb2Vzbid0IHJlcHJlc2VudCBzdGF0ZSB3aGVuIHNldCgpIGZhaWxzXHJcbiAgICAgICAgaXNBcm1lZDoge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YW12LmFybWVkO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0KGFybSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQXJtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFybVN0YXRlID09IHRoaXMuV0FJVElORyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxBcm0oJ1RpbWVvdXQgcmVhY2hlZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmREaXNhcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYXJtU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbERpc2FybSgnVGltZW91dCByZWFjaGVkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICB1cGxvYWRNaXNzaW9uKCkge1xyXG4gICAgICAgICAgICBsZXQgbWlzc2lvbiA9IHRoaXMubWlzc2lvbnNbdGhpcy5jdXJyZW50TWlzc2lvbkluZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kVXBsb2FkTWlzc2lvbihtaXNzaW9uKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51cGxvYWRNaXNzaW9uU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxVcGxvYWRNaXNzaW9uKCdUaW1lb3V0IHJlYWNoZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZG93bmxvYWRNaXNzaW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmREb3dubG9hZE1pc3Npb24oKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb3dubG9hZE1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbERvd25sb2FkTWlzc2lvbignVGltZW91dCByZWFjaGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0YXJ0TWlzc2lvbigpe1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdGFydE1pc3Npb24oKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydE1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFN0YXJ0TWlzc2lvbignVGltZW91dCByZWFjaGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3BNaXNzaW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0b3BNaXNzaW9uKCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcE1pc3Npb25TdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFN0b3BNaXNzaW9uKCdUaW1lb3V0IHJlYWNoZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzdW1lTWlzc2lvbigpe1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXN1bWVNaXNzaW9uKCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lTWlzc2lvblN0YXRlID09IHRoaXMuV0FJVElORyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsUmVzdW1lTWlzc2lvbignVGltZW91dCByZWFjaGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGtpbGwoKXtcclxuICAgICAgICAgICAgdGhpcy5zZW5kS2lsbCgpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtpbGxTdGF0ZSA9PSB0aGlzLldBSVRJTkcpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbEtpbGwoJ1RpbWVvdXQgcmVhY2hlZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmtpbGwoKXtcclxuICAgICAgICAgICAgdGhpcy5zZW5kVW5raWxsKCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5raWxsU3RhdGUgPT0gdGhpcy5XQUlUSU5HKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxVbmtpbGwoJ1RpbWVvdXQgcmVhY2hlZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIHVwbG9hZE1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7IC8vc3VjY2Vzc2Z1bCByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW9uIHVwbG9hZGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLkZBSUxVUkUpeyAvL2ZhaWx1cmUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHVwbG9hZCBtaXNzaW9uOiAnICsgdGhpcy51cGxvYWRNaXNzaW9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRvd25sb2FkTWlzc2lvblN0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2lvbiBkb3dubG9hZGVkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pc3Npb24odGhpcy5kb3dubG9hZE1pc3Npb25EYXRhKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGRvd25sb2FkIG1pc3Npb246ICcgKyB0aGlzLmRvd25sb2FkTWlzc2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGFydE1pc3Npb25TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3Npb24gc3RhcnRlZC4nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIHN0YXJ0IG1pc3Npb246ICcgKyB0aGlzLnN0YXJ0TWlzc2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wTWlzc2lvblN0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2lvbiBzdG9wcGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLkZBSUxVUkUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gc3RvcCBtaXNzaW9uOiAnICsgdGhpcy5zdG9wTWlzc2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXN1bWVNaXNzaW9uU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLlNVQ0NFU1Mpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW9uIHJlc3VtZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byByZXN1bWUgbWlzc2lvbjogJyArIHRoaXMucmVzdW1lTWlzc2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcm1TdGF0ZShzdGF0ZSwgb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT0gb2xkU3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuU1VDQ0VTUyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZlaGljbGUgYXJtZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IHRoaXMuRkFJTFVSRSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBhcm0gdmVoaWNsZTogJyArIHRoaXMuYXJtRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc2FybVN0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmVoaWNsZSBkaXNhcm1lZC4nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGRpc2FybSB2ZWhpY2xlOiAnICsgdGhpcy5kaXNhcm1EYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAga2lsbFN0YXRlKHN0YXRlLCBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPSBvbGRTdGF0ZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5TVUNDRVNTKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnS2lsbCBzd2l0Y2ggYWN0aXZhdGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLkZBSUxVUkUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gYWN0aXZhdGUga2lsbCBzd2l0Y2g6ICcgKyB0aGlzLmtpbGxEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5raWxsU3RhdGUoc3RhdGUsIG9sZFN0YXRlKXtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9IG9sZFN0YXRlKXtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLlNVQ0NFU1Mpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdLaWxsIHN3aXRjaCBkZWFjdGl2YXRlZC4nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5GQUlMVVJFKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGRlYWN0aXZhdGUga2lsbCBzd2l0Y2g6ICcgKyB0aGlzLnVua2lsbERhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLWNvbW1hbmRzIHtcclxuICAgIG1pbi13aWR0aDogMTAwcHg7XHJcblxyXG4gICAgLnJvdyB7XHJcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xyXG5cclxuICAgICAgICAmOmxhc3QtY2hpbGQge1xyXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NDb21tYW5kcy52dWU/MjM5YTkyN2VcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLWNvbW1hbmRzXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVxcXCJ1cGxvYWRNaXNzaW9uXFxcIj5VcGxvYWQgTWlzc2lvbjwvdWktYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVxcXCJkb3dubG9hZE1pc3Npb25cXFwiPkRvd25sb2FkIE1pc3Npb248L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgdi1pZj1cXFwid2Ftdi5tb2RlID09ICdpZGxlJyB8fCB3YW12Lm1vZGUgPT0gJ3BhdXNlZCdcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJzdGFydE1pc3Npb25cXFwiXFxuICAgICAgICA+U3RhcnQ8L3VpLWJ1dHRvbj5cXG4gICAgICAgIDx1aS1idXR0b25cXG4gICAgICAgICAgICB2LWlmPVxcXCJ3YW12Lm1vZGUgPT0gJ3BhdXNlZCdcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJyZXN1bWVNaXNzaW9uXFxcIlxcbiAgICAgICAgPlJlc3VtZTwvdWktYnV0dG9uPlxcbiAgICAgICAgPHVpLWJ1dHRvblxcbiAgICAgICAgICAgIHYtaWY9XFxcIndhbXYubW9kZSA9PSAnYXV0bydcXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJzdG9wTWlzc2lvblxcXCJcXG4gICAgICAgID5TdG9wPC91aS1idXR0b24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHYtaWY9XFxcIndhbXYubG9hZGVkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbHVtbiBvbmUtaGFsZlxcXCI+IHt7IGlzQXJtZWQgPyAnQXJtZWQnIDogJ0Rpc2FybWVkJyB9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sdW1uIG9uZS1oYWxmXFxcIj5cXG4gICAgICAgICAgICA8dWktc3dpdGNoIDp2YWx1ZS5zeW5jPVxcXCJpc0FybWVkXFxcIj48L3VpLXN3aXRjaD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgIDx1aS1idXR0b24gY29sb3I9XFxcImRhbmdlclxcXCJcXG4gICAgICAgICAgICB2LWlmPVxcXCJ3YW12Lm1vZGUgIT0gJ2tpbGxlZCdcXFwiIEBjbGljaz1cXFwia2lsbFxcXCJcXG4gICAgICAgID5LaWxsPC91aS1idXR0b24+XFxuICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgdi1pZj1cXFwid2Ftdi5tb2RlID09ICdraWxsZWQnXFxcIiBAY2xpY2s9XFxcInVua2lsbFxcXCJcXG4gICAgICAgID5VbmtpbGw8L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJnY3Mtc2lkZWJhci1jb250cm9sc1xcXCJcXG4gICAgOnN0eWxlPVxcXCJ7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoJyArIChzaG93U2lkZWJhciA/ICczNzZweCcgOiAnMTZweCcgKyAnKScpIH1cXFwiXFxuPlxcbiAgICA8dWktYnV0dG9uXFxuICAgICAgICA6Y29sb3I9XFxcInNob3dTaWRlYmFyID8gJ3ByaW1hcnknIDogJ2RlZmF1bHQnXFxcIiBAY2xpY2s9XFxcInRvZ2dsZVNpZGViYXJcXFwiXFxuICAgID5NaXNzaW9uczwvdWktYnV0dG9uPlxcblxcbiAgICA8dWktYnV0dG9uIHYtaWY9XFxcImN1cnJlbnRNaXNzaW9uSW5kZXggIT0gLTFcXFwiIGhhcy1wb3BvdmVyIHRleHQ9XFxcIkNvbW1hbmRzXFxcIj5cXG4gICAgICAgIDxkaXYgc2xvdD1cXFwicG9wb3ZlclxcXCIgY2xhc3M9XFxcImdjcy1zaWRlYmFyLWNvbnRyb2xzLXBvcG92ZXJcXFwiPlxcbiAgICAgICAgICAgIDxnY3MtY29tbWFuZHM+PC9nY3MtY29tbWFuZHM+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC91aS1idXR0b24+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzV2Ftdi52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NXYW12LnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtYXJrZXJzXFxcXEdjc1dhbXYudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzV2Ftdi52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1iNWJhYjRkMi9HY3NXYW12LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2Ftdi52dWVcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLXdhbXZcIj48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBpc01hcmtlciBmcm9tICdtaXhpbnMvaXMtbWFya2VyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgIGNsaWNrKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dhbXYgY2xpY2tlZCcsIGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGluaXRpYWxpemVkKCkge1xyXG4gICAgICAgICAgICB3aW5kb3cud2FtdiA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgZ2V0SWNvbihzY2FsZSA9IHRoaXMuc2NhbGUsIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogZ29vZ2xlLm1hcHMuU3ltYm9sUGF0aC5GT1JXQVJEX0NMT1NFRF9BUlJPVyxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJ3JlZCcsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC44LFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1peGluczogW1xyXG4gICAgICAgIGlzTWFya2VyXHJcbiAgICBdXHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3Mtd2FtdiB7XHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc1dhbXYudnVlPzNkNjA5MGE0XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy13YW12XFxcIj48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2Ftdi52dWVcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInZpZXcgbWFwLXZpZXdcXFwiPlxcbiAgICA8Z2NzLW1hcD48L2djcy1tYXA+XFxuICAgIDxnY3MtbWFwLWNvbnRyb2xzPjwvZ2NzLW1hcC1jb250cm9scz5cXG4gICAgPGdjcy1tYXAtc2lkZWJhciA6c2hvdy1zaWRlYmFyPVxcXCJzaG93U2lkZWJhclxcXCI+PC9nY3MtbWFwLXNpZGViYXI+XFxuXFxuICAgIDxnY3Mtc2lkZWJhci1jb250cm9sc1xcbiAgICAgICAgOnNob3ctc2lkZWJhcj1cXFwic2hvd1NpZGViYXJcXFwiIEB0b2dnbGUtc2lkZWJhcj1cXFwidG9nZ2xlU2lkZWJhclxcXCJcXG4gICAgPjwvZ2NzLXNpZGViYXItY29udHJvbHM+XFxuXFxuICAgIDxnY3Mtd2FtdiB2LWlmPVxcXCJ3YW12LmxvYWRlZFxcXCJcXG4gICAgICAgIDpsYXQ9XFxcIndhbXYucG9zaXRpb24ubGF0XFxcIiA6bG5nPVxcXCJ3YW12LnBvc2l0aW9uLmxuZ1xcXCJcXG4gICAgICAgIDpyb3RhdGlvbj1cXFwid2Ftdi5oZWFkaW5nXFxcIlxcbiAgICA+PC9nY3Mtd2Ftdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3ZpZXdzL01hcFZpZXcudnVlXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QYXJhbXNWaWV3LnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1BhcmFtc1ZpZXcudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXHZpZXdzXFxcXFBhcmFtc1ZpZXcudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vUGFyYW1zVmlldy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wNGU4N2I0ZS9QYXJhbXNWaWV3LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL3ZpZXdzL1BhcmFtc1ZpZXcudnVlXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3ZpZXdzL1BhcmFtc1ZpZXcudnVlXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJ2aWV3IHBhcmFtcy12aWV3XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2VcIj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzPVwicGFnZS1oZWFkZXJcIj5QYXJhbXM8L2gxPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1jb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICA8IS0tIGRpc3BsYXkgcGFyYW1ldGVycyAodXAgdG8gaGllcmFyY2h5IGRlcHRoIDMpIC0tPlxyXG4gICAgICAgICAgICAgICAgPGRpdiB2LWZvcj1cIihuYW1lLCB2YWwpIGluIHBhcmFtZXRlcnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVwiaXNBcnJheSh2YWwpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi10ZXh0PVwibmFtZSArICcgKCcgKyB2YWxbMF0gKyAnKTogJyArIHZhbFsxXVwiXHJcbiAgICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtZWxzZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVwibmFtZVwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWZvcj1cIihuYW1lMiwgdmFsMikgaW4gdmFsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVwiaXNBcnJheSh2YWwyKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi10ZXh0PVwiJz4gJyArIG5hbWUyICsgJyAoJyArIHZhbDJbMF0gKyAnKTogJyArIHZhbDJbMV1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1lbHNlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cIic+ICcgKyBuYW1lMlwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtZm9yPVwiKG5hbWUzLCB2YWwzKSBpbiB2YWwyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJpc0FycmF5KHZhbDMpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cIic+ID4gJyArIG5hbWUzICsgJyAoJyArIHZhbDNbMF0gKyAnKTogJyArIHZhbDNbMV1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cIic+ID4gJyArIG5hbWUzICsgJzogLi4uJ1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IGdldFBhcmFtZXRlcnMgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHZ1ZXg6IHtcclxuICAgICAgICBnZXR0ZXJzOiB7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnNcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaXNBcnJheSh4KXtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCk7IC8vVnVlIGRvZXNuJ3QgbGlrZSBpdCBpZiBJIHVzZSB0aGlzIGRpcmVjdGx5XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4udmlldy5wYXJhbXMtdmlldyB7XHJcbiAgICBwYWRkaW5nOiAyNHB4O1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFBhcmFtc1ZpZXcudnVlPzNkMjNjNzA1XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInZpZXcgcGFyYW1zLXZpZXdcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlXFxcIj5cXG4gICAgICAgIDxoMSBjbGFzcz1cXFwicGFnZS1oZWFkZXJcXFwiPlBhcmFtczwvaDE+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDwhLS0gZGlzcGxheSBwYXJhbWV0ZXJzICh1cCB0byBoaWVyYXJjaHkgZGVwdGggMykgLS0+XFxuICAgICAgICAgICAgPGRpdiB2LWZvcj1cXFwiKG5hbWUsIHZhbCkgaW4gcGFyYW1ldGVyc1xcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XFxcImlzQXJyYXkodmFsKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwibmFtZSArICcgKCcgKyB2YWxbMF0gKyAnKTogJyArIHZhbFsxXVxcXCJcXG4gICAgICAgICAgICAgICAgPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPGRpdiB2LWVsc2U+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LXRleHQ9XFxcIm5hbWVcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi1mb3I9XFxcIihuYW1lMiwgdmFsMikgaW4gdmFsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVxcXCJpc0FycmF5KHZhbDIpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LXRleHQ9XFxcIic+ICcgKyBuYW1lMiArICcgKCcgKyB2YWwyWzBdICsgJyk6ICcgKyB2YWwyWzFdXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgID48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWVsc2U+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cXFwiJz4gJyArIG5hbWUyXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1mb3I9XFxcIihuYW1lMywgdmFsMykgaW4gdmFsMlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVxcXCJpc0FycmF5KHZhbDMpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiJz4gPiAnICsgbmFtZTMgKyAnICgnICsgdmFsM1swXSArICcpOiAnICsgdmFsM1sxXVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LXRleHQ9XFxcIic+ID4gJyArIG5hbWUzICsgJzogLi4uJ1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1NldHRpbmdzVmlldy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TZXR0aW5nc1ZpZXcudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXHZpZXdzXFxcXFNldHRpbmdzVmlldy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TZXR0aW5nc1ZpZXcudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYTZlOTFiMTQvU2V0dGluZ3NWaWV3LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwidmlldyBzZXR0aW5ncy12aWV3XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2VcIj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzPVwicGFnZS1oZWFkZXJcIj5TZXR0aW5nczwvaDE+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIFNldHRpbmdzIGhlcmVcclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4udmlldy5zZXR0aW5ncy12aWV3IHtcclxuICAgIHBhZGRpbmc6IDI0cHg7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogU2V0dGluZ3NWaWV3LnZ1ZT80YTAxYzkyNFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ2aWV3IHNldHRpbmdzLXZpZXdcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlXFxcIj5cXG4gICAgICAgIDxoMSBjbGFzcz1cXFwicGFnZS1oZWFkZXJcXFwiPlNldHRpbmdzPC9oMT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2UtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgU2V0dGluZ3MgaGVyZVxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzSW5kaWNhdG9ycy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NJbmRpY2F0b3JzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxHY3NJbmRpY2F0b3JzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc0luZGljYXRvcnMudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNmNiMGM3ZWEvR2NzSW5kaWNhdG9ycy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8dWwgY2xhc3M9XCJnY3MtaW5kaWNhdG9yc1wiIHYtaWY9XCJ3YW12LmxvYWRlZFwiPlxyXG4gICAgICAgIDxsaSBjbGFzcz1cImluZGljYXRvciBoZWFkaW5nXCI+XHJcbiAgICAgICAgICAgIDx1aS1pY29uXHJcbiAgICAgICAgICAgICAgICBpY29uPVwibmF2aWdhdGlvblwiIDpzdHlsZT1cInsgdHJhbnNmb3JtOiAncm90YXRlWignICsgd2Ftdi5oZWFkaW5nICsgJ2RlZyknIH1cIlxyXG4gICAgICAgICAgICA+PC91aS1pY29uPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCIgdi1odG1sPVwiaGVhZGluZ1wiPjwvc3Bhbj5cclxuICAgICAgICA8L2xpPlxyXG5cclxuICAgICAgICA8bGkgY2xhc3M9XCJpbmRpY2F0b3Igc3BlZWRcIj5cclxuICAgICAgICAgICAgPHVpLWljb24gaWNvbj1cIm5ldHdvcmtfY2hlY2tcIj48L3VpLWljb24+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmFsdWVcIiB2LXRleHQ9XCJzcGVlZFwiPjwvc3Bhbj5cclxuICAgICAgICA8L2xpPlxyXG5cclxuICAgICAgICA8bGkgY2xhc3M9XCJpbmRpY2F0b3IgYmF0dGVyeVwiPlxyXG4gICAgICAgICAgICA8dWktaWNvbiBpY29uPVwiYmF0dGVyeV9mdWxsXCI+PC91aS1pY29uPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCIgdi10ZXh0PVwiYmF0dGVyeVwiPjwvc3Bhbj5cclxuICAgICAgICA8L2xpPlxyXG5cclxuICAgICAgICA8bGkgY2xhc3M9XCJpbmRpY2F0b3Igc2lnbmFsXCI+XHJcbiAgICAgICAgICAgIDx1aS1pY29uIGljb249XCJ3aWZpXCI+PC91aS1pY29uPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCIgdi10ZXh0PVwic2lnbmFsXCI+PC9zcGFuPlxyXG4gICAgICAgIDwvbGk+XHJcbiAgICA8L3VsPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgZ2V0V2FtdiB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgd2FtdjogZ2V0V2FtdlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBoZWFkaW5nKCkge1xyXG4gICAgICAgICAgICBsZXQgZGVnID0gTWF0aC5yb3VuZCh0aGlzLndhbXYuaGVhZGluZyk7IC8vMCBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICByZXR1cm4gZGVnICsgJyZkZWc7ICcgKyB0aGlzLmRlZ3JlZVRvVG9DYXJkaW5hbCh0aGlzLndhbXYuaGVhZGluZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3BlZWQoKSB7XHJcbiAgICAgICAgICAgIGxldCBzcGQgPSBNYXRoLnJvdW5kKHRoaXMud2Ftdi5zcGVlZCoxMDApLzEwMDsgLy8yIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbXYuc3BlZWQgKyAnIEtNUEgnO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJhdHRlcnkoKSB7XHJcbiAgICAgICAgICAgIGxldCBwZXJjID0gTWF0aC5yb3VuZCh0aGlzLndhbXYuYmF0dGVyeSoxMDApLzEwMDsgLy8yIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgIHJldHVybiBwZXJjICsgJyUnO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNpZ25hbCgpIHtcclxuICAgICAgICAgICAgbGV0IHBlcmMgPSBNYXRoLnJvdW5kKHRoaXMud2Ftdi5zaWduYWwqMTAwKS8xMDA7IC8vMiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICByZXR1cm4gcGVyYyArICclJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBkZWdyZWVUb1RvQ2FyZGluYWwoZGVncmVlKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAyMi41IHx8IGRlZ3JlZSA+PSAzMzcuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdOJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDY3LjUgfHwgZGVncmVlID49IDIyLjUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnTkUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMTEyLjUgfHwgZGVncmVlID49IDY3LjUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnRSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAxNTcuNSB8fCBkZWdyZWUgPj0gMTEyLjUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnU0UnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMjAyLjUgfHwgZGVncmVlID49IDE1Ny41KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1MnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMjQ3LjUgfHwgZGVncmVlID49IDIwMi41KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1NXJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDI5Mi41IHx8IGRlZ3JlZSA+PSAyNDcuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdXJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDMzNy41IHx8IGRlZ3JlZSA+PSAyOTIuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdOVyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3MtaW5kaWNhdG9ycyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICByaWdodDogMTZweDtcclxuICAgIHRvcDogMTJweDtcclxuICAgIGhlaWdodDogMjRweDtcclxuICAgIHBhZGRpbmc6IDA7XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgICBsaXN0LXN0eWxlOiBub25lO1xyXG5cclxuICAgIC5pbmRpY2F0b3Ige1xyXG4gICAgICAgIGNvbG9yOiBhbHBoYSh3aGl0ZSwgMC44KTtcclxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxOHB4O1xyXG5cclxuICAgICAgICAmOmxhc3QtY2hpbGQge1xyXG4gICAgICAgICAgICBib3JkZXItcmlnaHQ6IG5vbmU7XHJcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XHJcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC5oZWFkaW5nIC51aS1pY29uIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLnVpLWljb24ge1xyXG4gICAgICAgIGNvbG9yOiBhbHBoYSh3aGl0ZSwgMC41KTtcclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NJbmRpY2F0b3JzLnZ1ZT8xNGE2ZmMzM1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48dWwgY2xhc3M9XFxcImdjcy1pbmRpY2F0b3JzXFxcIiB2LWlmPVxcXCJ3YW12LmxvYWRlZFxcXCI+XFxuICAgIDxsaSBjbGFzcz1cXFwiaW5kaWNhdG9yIGhlYWRpbmdcXFwiPlxcbiAgICAgICAgPHVpLWljb25cXG4gICAgICAgICAgICBpY29uPVxcXCJuYXZpZ2F0aW9uXFxcIiA6c3R5bGU9XFxcInsgdHJhbnNmb3JtOiAncm90YXRlWignICsgd2Ftdi5oZWFkaW5nICsgJ2RlZyknIH1cXFwiXFxuICAgICAgICA+PC91aS1pY29uPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZhbHVlXFxcIiB2LWh0bWw9XFxcImhlYWRpbmdcXFwiPjwvc3Bhbj5cXG4gICAgPC9saT5cXG5cXG4gICAgPGxpIGNsYXNzPVxcXCJpbmRpY2F0b3Igc3BlZWRcXFwiPlxcbiAgICAgICAgPHVpLWljb24gaWNvbj1cXFwibmV0d29ya19jaGVja1xcXCI+PC91aS1pY29uPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZhbHVlXFxcIiB2LXRleHQ9XFxcInNwZWVkXFxcIj48L3NwYW4+XFxuICAgIDwvbGk+XFxuXFxuICAgIDxsaSBjbGFzcz1cXFwiaW5kaWNhdG9yIGJhdHRlcnlcXFwiPlxcbiAgICAgICAgPHVpLWljb24gaWNvbj1cXFwiYmF0dGVyeV9mdWxsXFxcIj48L3VpLWljb24+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidmFsdWVcXFwiIHYtdGV4dD1cXFwiYmF0dGVyeVxcXCI+PC9zcGFuPlxcbiAgICA8L2xpPlxcblxcbiAgICA8bGkgY2xhc3M9XFxcImluZGljYXRvciBzaWduYWxcXFwiPlxcbiAgICAgICAgPHVpLWljb24gaWNvbj1cXFwid2lmaVxcXCI+PC91aS1pY29uPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZhbHVlXFxcIiB2LXRleHQ9XFxcInNpZ25hbFxcXCI+PC9zcGFuPlxcbiAgICA8L2xpPlxcbjwvdWw+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCh1cmksIGxvYyl7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qc1xuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wYXJzZXVyaS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kZWJ1Zy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZGVidWcvZGVidWcuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSByZXF1aXJlKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9qc29uMy9saWIvanNvbjMuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihmbil7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbihkYXRhKXtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbigpe1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGU7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24obnNwKXtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gIHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmUgOlxuICAgIChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnQgP1xuICAgICAgIGxvY2F0aW9uLnBvcnQgOlxuICAgICAgICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIHBmeDogdGhpcy5wZngsXG4gICAga2V5OiB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogdGhpcy5jZXJ0LFxuICAgIGNhOiB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnNcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoKGUpIHsgfVxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9oYXMtY29ycy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKXt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSKG9wdHMpe1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgdWk4QXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpO1xuICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh1aThBcnJbaWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbihvblBhdXNlKXtcbiAgdmFyIHBlbmRpbmcgPSAwO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlKCl7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24ocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlKCl7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICBpZiAob2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLXBhcnNlci9+L2hhcy1iaW5hcnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1wYXJzZXIvfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9hZnRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXRmOC91dGY4LmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jsb2IvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcbiAgdmFyIHFyeSA9IHt9O1xuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcXJ5O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3BhcnNlcXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29tcG9uZW50LWluaGVyaXQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi95ZWFzdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG5cbiAgdGhpcy53cyA9IEJyb3dzZXJXZWJTb2NrZXQgPyBuZXcgV2ViU29ja2V0KHVyaSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3JcbiAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKCl7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG4gICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiB3cyAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pbmRleG9mL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEpTT04gcGFyc2UuXG4gKlxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC87XG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG52YXIgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG5cbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG4gICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wYXJzZWpzb24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCl7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPSB0aGlzLm5zcCkge1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBpZiAocGFja2V0Lm5zcCAhPSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24oaWQpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24oY29tcHJlc3Mpe1xuICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdG8tYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb21wb25lbnQtYmluZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICAgICAgaWYgKG9iai50b0pTT04gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaGFzLWJpbmFyeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaGFzLWJpbmFyeS9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFja28yL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLWFwcFxcXCI+XFxuICAgIDx1aS10YWJzXFxuICAgICAgICBjbGFzcz1cXFwibWFpbi10YWItY29udGFpbmVyXFxcIiBiYWNrZ3JvdW5kLWNvbG9yPVxcXCJkYXJrXFxcIiB0ZXh0LWNvbG9yPVxcXCJsaWdodFxcXCJcXG4gICAgICAgIGluZGljYXRvci1jb2xvcj1cXFwidHJhbnNwYXJlbnRcXFwiXFxuICAgID5cXG4gICAgICAgIDx1aS10YWIgaGVhZGVyPVxcXCJNYXBcXFwiPlxcbiAgICAgICAgICAgIDxtYXAtdmlldz48L21hcC12aWV3PlxcbiAgICAgICAgPC91aS10YWI+XFxuXFxuICAgICAgICA8dWktdGFiIGhlYWRlcj1cXFwiUGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8cGFyYW1zLXZpZXc+PC9wYXJhbXMtdmlldz5cXG4gICAgICAgIDwvdWktdGFiPlxcblxcbiAgICAgICAgPHVpLXRhYiBoZWFkZXI9XFxcIlNldHRpbmdzXFxcIj5cXG4gICAgICAgICAgICA8c2V0dGluZ3Mtdmlldz48L3NldHRpbmdzLXZpZXc+XFxuICAgICAgICA8L3VpLXRhYj5cXG4gICAgPC91aS10YWJzPlxcblxcbiAgICA8Z2NzLWluZGljYXRvcnM+PC9nY3MtaW5kaWNhdG9ycz5cXG5cXG4gICAgPHVpLXNuYWNrYmFyLWNvbnRhaW5lciBwb3NpdGlvbj1cXFwiY2VudGVyXFxcIj48L3VpLXNuYWNrYmFyLWNvbnRhaW5lcj5cXG48L2Rpdj5cXG5cXG48IS0tIDxzb2NrZXQtaW8tbWFuYWdlcj48L3NvY2tldC1pby1tYW5hZ2VyPiAtLT5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnO1xyXG5pbXBvcnQgY29uZmlnIGZyb20gJ2FwcC9jb25maWcnO1xyXG5cclxuLy8gVE9ETzogZ2V0IHNldHRpbmdzIGZyb20gc2VydmVyIGFuZCBhZGQgdG8gc3RhdGVcclxuXHJcblZ1ZS51c2UoVnVleCk7XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICBtYXA6IG51bGwsXHJcbiAgICBtYXBFbDogbnVsbCxcclxuICAgIG1hcExvYWRlZDogZmFsc2UsXHJcbiAgICBtYXBFZGl0aW5nOiBmYWxzZSxcclxuICAgIHdhbXY6IHtcclxuICAgICAgICBsb2FkZWQ6IGZhbHNlLFxyXG4gICAgICAgIHBvc2l0aW9uOiB7bGF0OiAtMzIuODg4MzMzOCwgbG5nOiAxNTEuNzA3NTI3OX0sXHJcbiAgICAgICAgaGVhZGluZzogIDAsXHJcbiAgICAgICAgc3BlZWQ6ICAgIDAsXHJcbiAgICAgICAgYmF0dGVyeTogIDEwMCxcclxuICAgICAgICBhcm1lZDogICAgZmFsc2UsXHJcbiAgICAgICAgbW9kZTogICAgICdpZGxlJyxcclxuICAgICAgICBzaWduYWw6ICAgMTAwXHJcbiAgICB9LFxyXG4gICAgY29uZmlnOiBjb25maWcsXHJcbiAgICBzZXR0aW5nczogY29uZmlnLnNldHRpbmdzLFxyXG4gICAgc2V0dGluZ3NMb2FkZWQ6IGZhbHNlLFxyXG4gICAgbWlzc2lvbnM6IFtdLFxyXG4gICAgY3VycmVudE1pc3Npb25JbmRleDogLTEsXHJcbiAgICBwYXJhbWV0ZXJzOiB7fSxcclxuICAgIG1lc3NhZ2VTdGF0ZToge1xyXG4gICAgICAgIC8vY29uc3RhbnRzIGZvciBpbmRpY2F0aW5nIHN0YXRlXHJcbiAgICAgICAgSU5JVElBTDogMCxcclxuICAgICAgICBXQUlUSU5HOiAxLFxyXG4gICAgICAgIFNVQ0NFU1M6IDIsXHJcbiAgICAgICAgRkFJTFVSRTogMyxcclxuICAgICAgICAvL2ZvciBhIG1lc3NhZ2UgdHlwZSBUIGJlbG93LCBUWzBdIHNwZWNpZmllcyBhIHN0YXRlLCBhbmQgVFsxXSBzcGVjaWZpZXMgZGF0YVxyXG4gICAgICAgIC8vd2hlbiBhIGNvbXBvbmVudCB3YW50cyB0byBzZW5kIGEgbWVzc2FnZSBvZiB0eXBlIFQsIFRbMF0gaXMgc2V0IHRvIFdBSVRJTkdcclxuICAgICAgICAgICAgLy9UWzFdIGlzIHNldCB0byB0aGUgcmVxdWVzdCBkYXRhLCBpZiBhbnlcclxuICAgICAgICAvL3doZW4gYSBzZXJ2ZXIgcmVzcG9uc2UgaXMgcmVjZWl2ZWQsIFRbMF0gaXMgc2V0IHRvIFNVQ0NFU1MsIGFuZCBUWzFdIHRvIHRoZSByZXNwb25zZSBkYXRhXHJcbiAgICAgICAgICAgIC8vaWYgdGhlIHJlcXVlc3QgZmFpbGVkLCBUWzBdIGlzIGluc3RlYWQgc2V0IHRvIEZBSUxVUkUsIGFuZCBUWzFdIHRvIHRoZSBmYWlsdXJlIG1lc3NhZ2VcclxuICAgICAgICBnZXRfcGFyYW1ldGVyczogICBbMCwgbnVsbF0sXHJcbiAgICAgICAgc2V0X3BhcmFtZXRlcjogICAgWzAsIG51bGxdLFxyXG4gICAgICAgIHNhdmVfbWlzc2lvbnM6ICAgIFswLCBudWxsXSxcclxuICAgICAgICBsb2FkX21pc3Npb25zOiAgICBbMCwgbnVsbF0sXHJcbiAgICAgICAgdXBsb2FkX21pc3Npb246ICAgWzAsIG51bGxdLFxyXG4gICAgICAgIGRvd25sb2FkX21pc3Npb246IFswLCBudWxsXSxcclxuICAgICAgICBhcm06ICAgICAgICAgICAgICBbMCwgbnVsbF0sXHJcbiAgICAgICAgZGlzYXJtOiAgICAgICAgICAgWzAsIG51bGxdLFxyXG4gICAgICAgIHN0YXJ0X21pc3Npb246ICAgIFswLCBudWxsXSxcclxuICAgICAgICBzdG9wX21pc3Npb246ICAgICBbMCwgbnVsbF0sXHJcbiAgICAgICAgcmVzdW1lX21pc3Npb246ICAgWzAsIG51bGxdLFxyXG4gICAgICAgIGtpbGw6ICAgICAgICAgICAgIFswLCBudWxsXSxcclxuICAgICAgICB1bmtpbGw6ICAgICAgICAgICBbMCwgbnVsbF1cclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IG11dGF0aW9ucyA9IHtcclxuICAgIFNFVF9NQVAoc3RhdGUsIG1hcCkge1xyXG4gICAgICAgIHN0YXRlLm1hcCA9IG1hcDtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX01BUF9FTChzdGF0ZSwgbWFwRWwpIHtcclxuICAgICAgICBzdGF0ZS5tYXBFbCA9IG1hcEVsO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfTUFQX0xPQURFRChzdGF0ZSwgbG9hZGVkKSB7XHJcbiAgICAgICAgc3RhdGUubWFwTG9hZGVkID0gbG9hZGVkO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfTUFQX0VESVRJTkcoc3RhdGUsIGVkaXRpbmcpIHtcclxuICAgICAgICBzdGF0ZS5tYXBFZGl0aW5nID0gZWRpdGluZztcclxuICAgIH0sXHJcblxyXG4gICAgVVBEQVRFX1dBTVZfUE9TSVRJT04oc3RhdGUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgc3RhdGUud2Ftdi5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfV0FNVihzdGF0ZSwgd2Ftdikge1xyXG4gICAgICAgIHN0YXRlLndhbXYgPSB3YW12O1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfV0FNVl9BUk1FRChzdGF0ZSwgYXJtZWQpIHtcclxuICAgICAgICBzdGF0ZS53YW12LmFybWVkID0gYXJtZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFVF9XQU1WX01PREUoc3RhdGUsIG1vZGUpIHtcclxuICAgICAgICBzdGF0ZS53YW12Lm1vZGUgPSBtb2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICBJTklUX1NFVFRJTkdTKHN0YXRlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIHN0YXRlLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgc3RhdGUuc2V0dGluZ3NMb2FkZWQgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBVUERBVEVfU0VUVElOR1Moc3RhdGUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgc3RhdGUuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX01JU1NJT05TKHN0YXRlLCBtaXNzaW9ucykge1xyXG4gICAgICAgIHN0YXRlLm1pc3Npb25zID0gbWlzc2lvbnM7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFVF9DVVJSRU5UX01JU1NJT05fSU5ERVgoc3RhdGUsIGluZGV4KSB7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudE1pc3Npb25JbmRleCA9IGluZGV4O1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfQ1VSUkVOVF9NSVNTSU9OKHN0YXRlLCBtaXNzaW9uKSB7XHJcbiAgICAgICAgc3RhdGUubWlzc2lvbnMuJHNldChzdGF0ZS5jdXJyZW50TWlzc2lvbkluZGV4LCBtaXNzaW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX1BBUkFNRVRFUlMoc3RhdGUsIHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBzdGF0ZS5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcclxuICAgIH0sXHJcblxyXG4gICAgU0VORF9HRVRfUEFSQU1FVEVSUyhzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5nZXRfcGFyYW1ldGVycy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcclxuICAgIH0sXHJcblxyXG4gICAgU1VDQ0VFRF9HRVRfUEFSQU1FVEVSUyhzdGF0ZSwgcGFyYW1ldGVycykge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5nZXRfcGFyYW1ldGVycy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZ2V0X3BhcmFtZXRlcnMuJHNldCgxLCBwYXJhbWV0ZXJzKTtcclxuICAgIH0sXHJcblxyXG4gICAgRkFJTF9HRVRfUEFSQU1FVEVSUyhzdGF0ZSwgbXNnKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmdldF9wYXJhbWV0ZXJzLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5nZXRfcGFyYW1ldGVycy4kc2V0KDEsIG1zZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFTkRfU0FWRV9NSVNTSU9OUyhzdGF0ZSwgbWlzc2lvbnMpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9ucy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc2F2ZV9taXNzaW9ucy4kc2V0KDEsIG1pc3Npb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgU1VDQ0VFRF9TQVZFX01JU1NJT05TKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnNhdmVfbWlzc2lvbnMuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XHJcbiAgICB9LFxyXG5cclxuICAgIEZBSUxfU0FWRV9NSVNTSU9OUyhzdGF0ZSwgbXNnKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnNhdmVfbWlzc2lvbnMuJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuRkFJTFVSRSk7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnNhdmVfbWlzc2lvbnMuJHNldCgxLCBtc2cpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRU5EX0xPQURfTUlTU0lPTlMoc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUubG9hZF9taXNzaW9ucy4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcclxuICAgIH0sXHJcblxyXG4gICAgU1VDQ0VFRF9MT0FEX01JU1NJT05TKHN0YXRlLCBtaXNzaW9ucykge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5sb2FkX21pc3Npb25zLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1MpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5sb2FkX21pc3Npb25zLiRzZXQoMSwgbWlzc2lvbnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBGQUlMX0xPQURfTUlTU0lPTlMoc3RhdGUsIG1zZykge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5sb2FkX21pc3Npb25zLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5sb2FkX21pc3Npb25zLiRzZXQoMSwgbXNnKTtcclxuICAgIH0sXHJcblxyXG4gICAgU0VORF9VUExPQURfTUlTU0lPTihzdGF0ZSwgbWlzc2lvbikge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS51cGxvYWRfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUudXBsb2FkX21pc3Npb24uJHNldCgxLCBtaXNzaW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgU1VDQ0VFRF9VUExPQURfTUlTU0lPTihzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS51cGxvYWRfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcclxuICAgIH0sXHJcblxyXG4gICAgRkFJTF9VUExPQURfTUlTU0lPTihzdGF0ZSwgbXNnKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVwbG9hZF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS51cGxvYWRfbWlzc2lvbi4kc2V0KDEsIG1zZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFTkRfRE9XTkxPQURfTUlTU0lPTihzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kb3dubG9hZF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTVUNDRUVEX0RPV05MT0FEX01JU1NJT04oc3RhdGUsIG1pc3Npb24pIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZG93bmxvYWRfbWlzc2lvbi4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuZG93bmxvYWRfbWlzc2lvbi4kc2V0KDEsIG1pc3Npb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBGQUlMX0RPV05MT0FEX01JU1NJT04oc3RhdGUsIG1zZykge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kb3dubG9hZF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kb3dubG9hZF9taXNzaW9uLiRzZXQoMSwgbXNnKTtcclxuICAgIH0sXHJcblxyXG4gICAgU0VORF9TVEFSVF9NSVNTSU9OKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnN0YXJ0X21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORyk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNVQ0NFRURfU1RBUlRfTUlTU0lPTihzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBGQUlMX1NUQVJUX01JU1NJT04oc3RhdGUsIG1zZykge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdGFydF9taXNzaW9uLiRzZXQoMSwgbXNnKTtcclxuICAgIH0sXHJcblxyXG4gICAgU0VORF9TVE9QX01JU1NJT04oc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc3RvcF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTVUNDRUVEX1NUT1BfTUlTU0lPTihzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdG9wX21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XHJcbiAgICB9LFxyXG5cclxuICAgIEZBSUxfU1RPUF9NSVNTSU9OKHN0YXRlLCBtc2cpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuc3RvcF9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5zdG9wX21pc3Npb24uJHNldCgxLCBtc2cpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRU5EX1JFU1VNRV9NSVNTSU9OKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTVUNDRUVEX1JFU1VNRV9NSVNTSU9OKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBGQUlMX1JFU1VNRV9NSVNTSU9OKHN0YXRlLCBtc2cpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUucmVzdW1lX21pc3Npb24uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuRkFJTFVSRSk7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnJlc3VtZV9taXNzaW9uLiRzZXQoMSwgbXNnKTtcclxuICAgIH0sXHJcblxyXG4gICAgU0VORF9BUk0oc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuYXJtLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTVUNDRUVEX0FSTShzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5hcm0uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuU1VDQ0VTUyk7XHJcbiAgICB9LFxyXG5cclxuICAgIEZBSUxfQVJNKHN0YXRlLCBtc2cpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUuYXJtLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLkZBSUxVUkUpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5hcm0uJHNldCgxLCBtc2cpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRU5EX0RJU0FSTShzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kaXNhcm0uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuV0FJVElORyk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNVQ0NFRURfRElTQVJNKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRpc2FybS4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcclxuICAgIH0sXHJcblxyXG4gICAgRkFJTF9ESVNBUk0oc3RhdGUsIG1zZykge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5kaXNhcm0uJHNldCgwLCBzdGF0ZS5tZXNzYWdlU3RhdGUuRkFJTFVSRSk7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLmRpc2FybS4kc2V0KDEsIG1zZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFTkRfS0lMTChzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VTdGF0ZS5raWxsLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLldBSVRJTkcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTVUNDRUVEX0tJTEwoc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUua2lsbC4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5TVUNDRVNTKTtcclxuICAgIH0sXHJcblxyXG4gICAgRkFJTF9LSUxMKHN0YXRlLCBtc2cpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUua2lsbC4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUua2lsbC4kc2V0KDEsIG1zZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFTkRfVU5LSUxMKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVua2lsbC4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5XQUlUSU5HKTtcclxuICAgIH0sXHJcblxyXG4gICAgU1VDQ0VFRF9VTktJTEwoc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUudW5raWxsLiRzZXQoMCwgc3RhdGUubWVzc2FnZVN0YXRlLlNVQ0NFU1MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBGQUlMX1VOS0lMTChzdGF0ZSwgbXNnKSB7XHJcbiAgICAgICAgc3RhdGUubWVzc2FnZVN0YXRlLnVua2lsbC4kc2V0KDAsIHN0YXRlLm1lc3NhZ2VTdGF0ZS5GQUlMVVJFKTtcclxuICAgICAgICBzdGF0ZS5tZXNzYWdlU3RhdGUudW5raWxsLiRzZXQoMSwgbXNnKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBWdWV4LlN0b3JlKHtcclxuICAgIHN0YXRlOiBpbml0aWFsU3RhdGUsXHJcbiAgICBtdXRhdGlvbnNcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3N0b3JlL3N0b3JlLmpzXG4gKiovIiwiLyohXG4gKiBWdWV4IHYxLjAuMC1yY1xuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLlZ1ZXggPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH07XG5cbiAgdmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhcnJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBtZXJnZU9iamVjdHMoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG9iaikge1xuICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gcHJldltrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAvLyBhbGxvdyBtdWx0aXBsZSBtdXRhdGlvbiBvYmplY3RzIHRvIGNvbnRhaW4gZHVwbGljYXRlXG4gICAgICAgICAgLy8gaGFuZGxlcnMgZm9yIHRoZSBzYW1lIG11dGF0aW9uIHR5cGVcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IGV4aXN0aW5nLmNvbmNhdChvYmpba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IFtleGlzdGluZ10uY29uY2F0KG9ialtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldltrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIE9iamVjdCBvciBub3RcbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdGF0ZSBzdWIgdHJlZSBieSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBuZXN0ZWRLZXlzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5lc3RlZFN0YXRlKHN0YXRlLCBuZXN0ZWRLZXlzKSB7XG4gICAgcmV0dXJuIG5lc3RlZEtleXMucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7XG4gICAgICByZXR1cm4gc3RhdGVba2V5XTtcbiAgICB9LCBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogSGFja3MgdG8gZ2V0IGFjY2VzcyB0byBWdWUgaW50ZXJuYWxzLlxuICAgKiBNYXliZSB3ZSBzaG91bGQgZXhwb3NlIHRoZXNlLi4uXG4gICAqL1xuXG4gIHZhciBXYXRjaGVyID0gdm9pZCAwO1xuICBmdW5jdGlvbiBnZXRXYXRjaGVyKHZtKSB7XG4gICAgaWYgKCFXYXRjaGVyKSB7XG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICAgIHZhciB1bndhdGNoID0gdm0uJHdhdGNoKG5vb3AsIG5vb3ApO1xuICAgICAgV2F0Y2hlciA9IHZtLl93YXRjaGVyc1swXS5jb25zdHJ1Y3RvcjtcbiAgICAgIHVud2F0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIFdhdGNoZXI7XG4gIH1cblxuICB2YXIgRGVwID0gdm9pZCAwO1xuICBmdW5jdGlvbiBnZXREZXAodm0pIHtcbiAgICBpZiAoIURlcCkge1xuICAgICAgRGVwID0gdm0uX2RhdGEuX19vYl9fLmRlcC5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIERlcDtcbiAgfVxuXG4gIHZhciBob29rID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgZnVuY3Rpb24gZGV2dG9vbFBsdWdpbihzdG9yZSkge1xuICAgIGlmICghaG9vaykgcmV0dXJuO1xuXG4gICAgaG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgICBob29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgICB9KTtcblxuICAgIHN0b3JlLm9uKCdtdXRhdGlvbicsIGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICAgIGhvb2suZW1pdCgndnVleDptdXRhdGlvbicsIG11dGF0aW9uLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvdmVycmlkZSAoVnVlKSB7XG4gICAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgICBpZiAodmVyc2lvbiA+PSAyKSB7XG4gICAgICB2YXIgdXNlc0luaXQgPSBWdWUuY29uZmlnLl9saWZlY3ljbGVIb29rcy5pbmRleE9mKCdpbml0JykgPiAtMTtcbiAgICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb3ZlcnJpZGUgaW5pdCBhbmQgaW5qZWN0IHZ1ZXggaW5pdCBwcm9jZWR1cmVcbiAgICAgICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICAgICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICAgb3B0aW9ucy5pbml0ID0gb3B0aW9ucy5pbml0ID8gW3Z1ZXhJbml0XS5jb25jYXQob3B0aW9ucy5pbml0KSA6IHZ1ZXhJbml0O1xuICAgICAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZ1ZXggaW5pdCBob29rLCBpbmplY3RlZCBpbnRvIGVhY2ggaW5zdGFuY2VzIGluaXQgaG9va3MgbGlzdC5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHZ1ZXhJbml0KCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgdmFyIHN0b3JlID0gb3B0aW9ucy5zdG9yZTtcbiAgICAgIHZhciB2dWV4ID0gb3B0aW9ucy52dWV4O1xuICAgICAgLy8gc3RvcmUgaW5qZWN0aW9uXG5cbiAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICB0aGlzLiRzdG9yZSA9IHN0b3JlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgICAgdGhpcy4kc3RvcmUgPSBvcHRpb25zLnBhcmVudC4kc3RvcmU7XG4gICAgICB9XG4gICAgICAvLyB2dWV4IG9wdGlvbiBoYW5kbGluZ1xuICAgICAgaWYgKHZ1ZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRzdG9yZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW3Z1ZXhdIHN0b3JlIG5vdCBpbmplY3RlZC4gbWFrZSBzdXJlIHRvICcgKyAncHJvdmlkZSB0aGUgc3RvcmUgb3B0aW9uIGluIHlvdXIgcm9vdCBjb21wb25lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gdnVleC5zdGF0ZTtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB2dWV4LmFjdGlvbnM7XG4gICAgICAgIHZhciBnZXR0ZXJzID0gdnVleC5nZXR0ZXJzO1xuICAgICAgICAvLyBoYW5kbGUgZGVwcmVjYXRlZCBzdGF0ZSBvcHRpb25cblxuICAgICAgICBpZiAoc3RhdGUgJiYgIWdldHRlcnMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSB2dWV4LnN0YXRlIG9wdGlvbiB3aWxsIGJlZW4gZGVwcmVjYXRlZCBpbiAxLjAuICcgKyAnVXNlIHZ1ZXguZ2V0dGVycyBpbnN0ZWFkLicpO1xuICAgICAgICAgIGdldHRlcnMgPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXR0ZXJzXG4gICAgICAgIGlmIChnZXR0ZXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQgfHwge307XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGdldHRlcnMpIHtcbiAgICAgICAgICAgIGRlZmluZVZ1ZXhHZXR0ZXIodGhpcywga2V5LCBnZXR0ZXJzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhY3Rpb25zXG4gICAgICAgIGlmIChhY3Rpb25zKSB7XG4gICAgICAgICAgb3B0aW9ucy5tZXRob2RzID0gb3B0aW9ucy5tZXRob2RzIHx8IHt9O1xuICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gYWN0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucy5tZXRob2RzW19rZXldID0gbWFrZUJvdW5kQWN0aW9uKHRoaXMuJHN0b3JlLCBhY3Rpb25zW19rZXldLCBfa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR0ZXIgZm9yIGFsbCBnZXR0ZXIgcHJvcGVydGllcy5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNldHRlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndnVleCBnZXR0ZXIgcHJvcGVydGllcyBhcmUgcmVhZC1vbmx5LicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIFZ1ZXggZ2V0dGVyIG9uIGFuIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZGVmaW5lVnVleEdldHRlcih2bSwga2V5LCBnZXR0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3Z1ZXhdIEdldHRlciBib3VuZCB0byBrZXkgXFwndnVleC5nZXR0ZXJzLicgKyBrZXkgKyAnXFwnIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZtLCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IG1ha2VDb21wdXRlZEdldHRlcih2bS4kc3RvcmUsIGdldHRlciksXG4gICAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGNvbXB1dGVkIGdldHRlciwgdXNpbmcgdGhlIHNhbWUgY2FjaGluZyBtZWNoYW5pc20gb2YgY29tcHV0ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLiBJbiBhZGRpdGlvbiwgaXQgaXMgY2FjaGVkIG9uIHRoZSByYXcgZ2V0dGVyIGZ1bmN0aW9uIHVzaW5nXG4gICAgICogdGhlIHN0b3JlJ3MgdW5pcXVlIGNhY2hlIGlkLiBUaGlzIG1ha2VzIHRoZSBzYW1lIGdldHRlciBzaGFyZWRcbiAgICAgKiBhY3Jvc3MgYWxsIGNvbXBvbmVudHMgdXNlIHRoZSBzYW1lIHVuZGVybHlpbmcgd2F0Y2hlciwgYW5kIG1ha2VzXG4gICAgICogdGhlIGdldHRlciBldmFsdWF0ZWQgb25seSBvbmNlIGR1cmluZyBldmVyeSBmbHVzaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RvcmV9IHN0b3JlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIoc3RvcmUsIGdldHRlcikge1xuICAgICAgdmFyIGlkID0gc3RvcmUuX2dldHRlckNhY2hlSWQ7XG5cbiAgICAgIC8vIGNhY2hlZFxuICAgICAgaWYgKGdldHRlcltpZF0pIHtcbiAgICAgICAgcmV0dXJuIGdldHRlcltpZF07XG4gICAgICB9XG4gICAgICB2YXIgdm0gPSBzdG9yZS5fdm07XG4gICAgICB2YXIgV2F0Y2hlciA9IGdldFdhdGNoZXIodm0pO1xuICAgICAgdmFyIERlcCA9IGdldERlcCh2bSk7XG4gICAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBmdW5jdGlvbiAodm0pIHtcbiAgICAgICAgcmV0dXJuIGdldHRlcih2bS5zdGF0ZSk7XG4gICAgICB9LCBudWxsLCB7IGxhenk6IHRydWUgfSk7XG4gICAgICB2YXIgY29tcHV0ZWRHZXR0ZXIgPSBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcbiAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgICAgfTtcbiAgICAgIGdldHRlcltpZF0gPSBjb21wdXRlZEdldHRlcjtcbiAgICAgIHJldHVybiBjb21wdXRlZEdldHRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgYm91bmQtdG8tc3RvcmUgdmVyc2lvbiBvZiBhIHJhdyBhY3Rpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0b3JlfSBzdG9yZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIG1ha2VCb3VuZEFjdGlvbihzdG9yZSwgYWN0aW9uLCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3Z1ZXhdIEFjdGlvbiBib3VuZCB0byBrZXkgXFwndnVleC5hY3Rpb25zLicgKyBrZXkgKyAnXFwnIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZ1ZXhCb3VuZEFjdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW47IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0aW9uLmNhbGwuYXBwbHkoYWN0aW9uLCBbdGhpcywgc3RvcmVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIG9wdGlvbiBtZXJnaW5nXG4gICAgdmFyIG1lcmdlID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMuY29tcHV0ZWQ7XG4gICAgVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMudnVleCA9IGZ1bmN0aW9uICh0b1ZhbCwgZnJvbVZhbCkge1xuICAgICAgaWYgKCF0b1ZhbCkgcmV0dXJuIGZyb21WYWw7XG4gICAgICBpZiAoIWZyb21WYWwpIHJldHVybiB0b1ZhbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldHRlcnM6IG1lcmdlKHRvVmFsLmdldHRlcnMsIGZyb21WYWwuZ2V0dGVycyksXG4gICAgICAgIHN0YXRlOiBtZXJnZSh0b1ZhbC5zdGF0ZSwgZnJvbVZhbC5zdGF0ZSksXG4gICAgICAgIGFjdGlvbnM6IG1lcmdlKHRvVmFsLmFjdGlvbnMsIGZyb21WYWwuYWN0aW9ucylcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHZhciBWdWUgPSB2b2lkIDA7XG4gIHZhciB1aWQgPSAwO1xuXG4gIHZhciBTdG9yZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogICAgICAgIC0ge09iamVjdH0gc3RhdGVcbiAgICAgKiAgICAgICAgLSB7T2JqZWN0fSBhY3Rpb25zXG4gICAgICogICAgICAgIC0ge09iamVjdH0gbXV0YXRpb25zXG4gICAgICogICAgICAgIC0ge0FycmF5fSBwbHVnaW5zXG4gICAgICogICAgICAgIC0ge0Jvb2xlYW59IHN0cmljdFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3RvcmUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgX3JlZiRzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gICAgICB2YXIgc3RhdGUgPSBfcmVmJHN0YXRlID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkc3RhdGU7XG4gICAgICB2YXIgX3JlZiRtdXRhdGlvbnMgPSBfcmVmLm11dGF0aW9ucztcbiAgICAgIHZhciBtdXRhdGlvbnMgPSBfcmVmJG11dGF0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJG11dGF0aW9ucztcbiAgICAgIHZhciBfcmVmJG1vZHVsZXMgPSBfcmVmLm1vZHVsZXM7XG4gICAgICB2YXIgbW9kdWxlcyA9IF9yZWYkbW9kdWxlcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJG1vZHVsZXM7XG4gICAgICB2YXIgX3JlZiRwbHVnaW5zID0gX3JlZi5wbHVnaW5zO1xuICAgICAgdmFyIHBsdWdpbnMgPSBfcmVmJHBsdWdpbnMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3JlZiRwbHVnaW5zO1xuICAgICAgdmFyIF9yZWYkc3RyaWN0ID0gX3JlZi5zdHJpY3Q7XG4gICAgICB2YXIgc3RyaWN0ID0gX3JlZiRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzdHJpY3Q7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdG9yZSk7XG5cbiAgICAgIHRoaXMuX2dldHRlckNhY2hlSWQgPSAndnVleF9zdG9yZV8nICsgdWlkKys7XG4gICAgICB0aGlzLl9kaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fcm9vdE11dGF0aW9ucyA9IHRoaXMuX211dGF0aW9ucyA9IG11dGF0aW9ucztcbiAgICAgIHRoaXMuX21vZHVsZXMgPSBtb2R1bGVzO1xuICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIC8vIGJpbmQgZGlzcGF0Y2ggdG8gc2VsZlxuICAgICAgdmFyIGRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaDtcbiAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICAvLyB1c2UgYSBWdWUgaW5zdGFuY2UgdG8gc3RvcmUgdGhlIHN0YXRlIHRyZWVcbiAgICAgIC8vIHN1cHByZXNzIHdhcm5pbmdzIGp1c3QgaW4gY2FzZSB0aGUgdXNlciBoYXMgYWRkZWRcbiAgICAgIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICAgICAgaWYgKCFWdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbdnVleF0gbXVzdCBjYWxsIFZ1ZS51c2UoVnVleCkgYmVmb3JlIGNyZWF0aW5nIGEgc3RvcmUgaW5zdGFuY2UuJyk7XG4gICAgICB9XG4gICAgICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gICAgICBWdWUuY29uZmlnLnNpbGVudCA9IHRydWU7XG4gICAgICB0aGlzLl92bSA9IG5ldyBWdWUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG4gICAgICB0aGlzLl9zZXR1cE1vZHVsZVN0YXRlKHN0YXRlLCBtb2R1bGVzKTtcbiAgICAgIHRoaXMuX3NldHVwTW9kdWxlTXV0YXRpb25zKG1vZHVsZXMpO1xuICAgICAgLy8gYWRkIGV4dHJhIHdhcm5pbmdzIGluIHN0cmljdCBtb2RlXG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIHRoaXMuX3NldHVwTXV0YXRpb25DaGVjaygpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcGx1Z2luc1xuICAgICAgZGV2dG9vbFBsdWdpbih0aGlzKTtcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4oX3RoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0dGVyIGZvciB0aGUgZW50aXJlIHN0YXRlIHRyZWUuXG4gICAgICogUmVhZCBvbmx5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuXG4gICAgY3JlYXRlQ2xhc3MoU3RvcmUsIFt7XG4gICAgICBrZXk6ICdyZXBsYWNlU3RhdGUnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSByb290IHN0YXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAgICovXG5cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl92bS5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERpc3BhdGNoIGFuIGFjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXNwYXRjaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2godHlwZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcGF5bG9hZFtfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWxlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzT2JqZWN0U3R5bGVEaXNwYXRjaCA9IGZhbHNlO1xuICAgICAgICAvLyBjb21wYXRpYmlsaXR5IGZvciBvYmplY3QgYWN0aW9ucywgZS5nLiBGU0FcbiAgICAgICAgaWYgKCh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHlwZSkpID09PSAnb2JqZWN0JyAmJiB0eXBlLnR5cGUgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlzT2JqZWN0U3R5bGVEaXNwYXRjaCA9IHRydWU7XG4gICAgICAgICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgICAgICAgaWYgKHR5cGUuc2lsZW50KSBzaWxlbnQgPSB0cnVlO1xuICAgICAgICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgIC8vIGFwcGx5IHRoZSBtdXRhdGlvblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgICAgaXNPYmplY3RTdHlsZURpc3BhdGNoID8gaChzdGF0ZSwgcGF5bG9hZCkgOiBoLmFwcGx5KHVuZGVmaW5lZCwgW3N0YXRlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocGF5bG9hZCkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPyBoYW5kbGVyKHN0YXRlLCBwYXlsb2FkKSA6IGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBbc3RhdGVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShwYXlsb2FkKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9kaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB2YXIgbXV0YXRpb24gPSBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPyBwYXlsb2FkIDogeyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ211dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gVW5rbm93biBtdXRhdGlvbjogJyArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2F0Y2ggc3RhdGUgY2hhbmdlcyBvbiB0aGUgc3RvcmUuXG4gICAgICAgKiBTYW1lIEFQSSBhcyBWdWUncyAkd2F0Y2gsIGV4Y2VwdCB3aGVuIHdhdGNoaW5nIGEgZnVuY3Rpb24sXG4gICAgICAgKiB0aGUgZnVuY3Rpb24gZ2V0cyB0aGUgc3RhdGUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3YXRjaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd2F0Y2goZm4sIGNiLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdWdWV4IHN0b3JlLndhdGNoIG9ubHkgYWNjZXB0cyBmdW5jdGlvbi4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF90aGlzMi5zdGF0ZSk7XG4gICAgICAgIH0sIGNiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIb3QgdXBkYXRlIG11dGF0aW9ucyAmIG1vZHVsZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAqICAgICAgICAtIHtPYmplY3R9IFttdXRhdGlvbnNdXG4gICAgICAgKiAgICAgICAgLSB7T2JqZWN0fSBbbW9kdWxlc11cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaG90VXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBob3RVcGRhdGUoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHZhciBtdXRhdGlvbnMgPSBfcmVmMi5tdXRhdGlvbnM7XG4gICAgICAgIHZhciBtb2R1bGVzID0gX3JlZjIubW9kdWxlcztcblxuICAgICAgICB0aGlzLl9yb290TXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zID0gbXV0YXRpb25zIHx8IHRoaXMuX3Jvb3RNdXRhdGlvbnM7XG4gICAgICAgIHRoaXMuX3NldHVwTW9kdWxlTXV0YXRpb25zKG1vZHVsZXMgfHwgdGhpcy5fbW9kdWxlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQXR0YWNoIHN1YiBzdGF0ZSB0cmVlIG9mIGVhY2ggbW9kdWxlIHRvIHRoZSByb290IHRyZWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNb2R1bGVTdGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwTW9kdWxlU3RhdGUoc3RhdGUsIG1vZHVsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChtb2R1bGVzKSkgcmV0dXJuO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBtb2R1bGUgPSBtb2R1bGVzW2tleV07XG5cbiAgICAgICAgICAvLyBzZXQgdGhpcyBtb2R1bGUncyBzdGF0ZVxuICAgICAgICAgIFZ1ZS5zZXQoc3RhdGUsIGtleSwgbW9kdWxlLnN0YXRlIHx8IHt9KTtcblxuICAgICAgICAgIC8vIHJldHJpZXZlIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgX3RoaXMzLl9zZXR1cE1vZHVsZVN0YXRlKHN0YXRlW2tleV0sIG1vZHVsZS5tb2R1bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmluZCBtdXRhdGlvbnMgZm9yIGVhY2ggbW9kdWxlIHRvIGl0cyBzdWIgdHJlZSBhbmRcbiAgICAgICAqIG1lcmdlIHRoZW0gYWxsIGludG8gb25lIGZpbmFsIG11dGF0aW9ucyBtYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZWRNb2R1bGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXR1cE1vZHVsZU11dGF0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwTW9kdWxlTXV0YXRpb25zKHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgIHZhciBtb2R1bGVzID0gdGhpcy5fbW9kdWxlcztcbiAgICAgICAgT2JqZWN0LmtleXModXBkYXRlZE1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIG1vZHVsZXNba2V5XSA9IHVwZGF0ZWRNb2R1bGVzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdXBkYXRlZE11dGF0aW9ucyA9IHRoaXMuX2NyZWF0ZU1vZHVsZU11dGF0aW9ucyhtb2R1bGVzLCBbXSk7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucyA9IG1lcmdlT2JqZWN0cyhbdGhpcy5fcm9vdE11dGF0aW9uc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHVwZGF0ZWRNdXRhdGlvbnMpKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGVscGVyIG1ldGhvZCBmb3IgX3NldHVwTW9kdWxlTXV0YXRpb25zLlxuICAgICAgICogVGhlIG1ldGhvZCByZXRyaWV2ZSBuZXN0ZWQgc3ViIG1vZHVsZXMgYW5kXG4gICAgICAgKiBiaW5kIGVhY2ggbXV0YXRpb25zIHRvIGl0cyBzdWIgdHJlZSByZWN1cnNpdmVseS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlc1xuICAgICAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBuZXN0ZWRLZXlzXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlTW9kdWxlTXV0YXRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlTW9kdWxlTXV0YXRpb25zKG1vZHVsZXMsIG5lc3RlZEtleXMpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChtb2R1bGVzKSkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtb2R1bGVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBtb2R1bGUgPSBtb2R1bGVzW2tleV07XG4gICAgICAgICAgdmFyIG5ld05lc3RlZEtleXMgPSBuZXN0ZWRLZXlzLmNvbmNhdChrZXkpO1xuXG4gICAgICAgICAgLy8gcmV0cmlldmUgbmVzdGVkIG1vZHVsZXNcbiAgICAgICAgICB2YXIgbmVzdGVkTXV0YXRpb25zID0gX3RoaXM0Ll9jcmVhdGVNb2R1bGVNdXRhdGlvbnMobW9kdWxlLm1vZHVsZXMsIG5ld05lc3RlZEtleXMpO1xuXG4gICAgICAgICAgaWYgKCFtb2R1bGUgfHwgIW1vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZU9iamVjdHMobmVzdGVkTXV0YXRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBiaW5kIG11dGF0aW9ucyB0byBzdWIgc3RhdGUgdHJlZVxuICAgICAgICAgIHZhciBtdXRhdGlvbnMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGUubXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBtb2R1bGUubXV0YXRpb25zW25hbWVdO1xuICAgICAgICAgICAgbXV0YXRpb25zW25hbWVdID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3JpZ2luYWwuYXBwbHkodW5kZWZpbmVkLCBbZ2V0TmVzdGVkU3RhdGUoc3RhdGUsIG5ld05lc3RlZEtleXMpXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIG1lcmdlIG11dGF0aW9ucyBvZiB0aGlzIG1vZHVsZSBhbmQgbmVzdGVkIG1vZHVsZXNcbiAgICAgICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKFttdXRhdGlvbnNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShuZXN0ZWRNdXRhdGlvbnMpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwIG11dGF0aW9uIGNoZWNrOiBpZiB0aGUgdnVleCBpbnN0YW5jZSdzIHN0YXRlIGlzIG11dGF0ZWRcbiAgICAgICAqIG91dHNpZGUgb2YgYSBtdXRhdGlvbiBoYW5kbGVyLCB3ZSB0aHJvdyBlbiBlcnJvci4gVGhpcyBlZmZlY3RpdmVseVxuICAgICAgICogZW5mb3JjZXMgYWxsIG11dGF0aW9ucyB0byB0aGUgc3RhdGUgdG8gYmUgdHJhY2thYmxlIGFuZCBob3QtcmVsb2FkYmxlLlxuICAgICAgICogSG93ZXZlciwgdGhpcyBjb21lcyBhdCBhIHJ1biB0aW1lIGNvc3Qgc2luY2Ugd2UgYXJlIGRvaW5nIGEgZGVlcFxuICAgICAgICogd2F0Y2ggb24gdGhlIGVudGlyZSBzdGF0ZSB0cmVlLCBzbyBpdCBpcyBvbmx5IGVuYWxiZWQgd2l0aCB0aGVcbiAgICAgICAqIHN0cmljdCBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXR1cE11dGF0aW9uQ2hlY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE11dGF0aW9uQ2hlY2soKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBXYXRjaGVyID0gZ2V0V2F0Y2hlcih0aGlzLl92bSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuICAgICAgICBuZXcgV2F0Y2hlcih0aGlzLl92bSwgJ3N0YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghX3RoaXM1Ll9kaXNwYXRjaGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbdnVleF0gRG8gbm90IG11dGF0ZSB2dWV4IHN0b3JlIHN0YXRlIG91dHNpZGUgbXV0YXRpb24gaGFuZGxlcnMuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7IGRlZXA6IHRydWUsIHN5bmM6IHRydWUgfSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc3RhdGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92bS5zdGF0ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIFVzZSBzdG9yZS5yZXBsYWNlU3RhdGUoKSB0byBleHBsaWNpdCByZXBsYWNlIHN0b3JlIHN0YXRlLicpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gU3RvcmU7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBpbnN0YWxsKF9WdWUpIHtcbiAgICBpZiAoVnVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBhbHJlYWR5IGluc3RhbGxlZC4gVnVlLnVzZShWdWV4KSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgVnVlID0gX1Z1ZVxuICAgIC8vIHJldXNlIFZ1ZSdzIGV2ZW50IHN5c3RlbVxuICAgIDtbJ29uJywgJ29mZicsICdvbmNlJywgJ2VtaXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICBTdG9yZS5wcm90b3R5cGVbZV0gPSBTdG9yZS5wcm90b3R5cGVbJyQnICsgZV0gPSBWdWUucHJvdG90eXBlWyckJyArIGVdO1xuICAgIH0pO1xuICAgIG92ZXJyaWRlKFZ1ZSk7XG4gIH1cblxuICAvLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgaW5zdGFsbCh3aW5kb3cuVnVlKTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHtcbiAgICBTdG9yZTogU3RvcmUsXG4gICAgaW5zdGFsbDogaW5zdGFsbFxuICB9O1xuXG4gIHJldHVybiBpbmRleDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZXgvZGlzdC92dWV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBnb29nbGVNYXBzOiB7XHJcbiAgICAgICAga2V5OiAnQUl6YVN5QUJuQ2Nla3lQZWNHbnNBMVJqX05kV2ptVWFmSjF5VnFBJyxcclxuICAgICAgICB2OiAzXHJcbiAgICB9LFxyXG4gICAgbWFwOiB7XHJcbiAgICAgICAgY2VudGVyOiB7XHJcbiAgICAgICAgICAgIGxhdDogMjEuMzA4NzMxLFxyXG4gICAgICAgICAgICBsbmc6IC0xNTcuODg4ODE1XHJcbiAgICAgICAgfSxcclxuICAgICAgICB6b29tOiAxOSxcclxuICAgICAgICBkaXNhYmxlRGVmYXVsdFVJOiB0cnVlLFxyXG4gICAgICAgIGRpc2FibGVEb3VibGVDbGlja1pvb206IHRydWUsXHJcbiAgICAgICAgdGlsdDogMFxyXG4gICAgfSxcclxuICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgZGVmYXVsdE1hcFR5cGU6ICdTQVRFTExJVEUnXHJcbiAgICB9XHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbmZpZy5qc1xuICoqLyIsIi8qKlxyXG4gKiBGYXN0IFVVSUQgZ2VuZXJhdG9yLCBSRkM0MTIyIHZlcnNpb24gNCBjb21wbGlhbnQuXHJcbiAqIEBhdXRob3IgSmVmZiBXYXJkIChqY3dhcmQuY29tKS5cclxuICogQGxpY2Vuc2UgTUlUIGxpY2Vuc2VcclxuICogQGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XHJcbiAqKi9cclxuXHJcbnZhciBsdXQgPSBbXTtcclxuXHJcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgIGx1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyAoaSkudG9TdHJpbmcoMTYpO1xyXG59XHJcblxyXG52YXIgZ2VuZXJhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuICAgIHZhciBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuICAgIHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuICAgIHZhciBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHJcbiAgICByZXR1cm4gbHV0W2QwICYgMHhmZl0gKyBsdXRbZDAgPj4gOCAmIDB4ZmZdICsgbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBsdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArXHJcbiAgICAgICAgbHV0W2QxICYgMHhmZl0gKyBsdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgbHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdICsgbHV0W2QxID4+IDI0ICYgMHhmZl0gKyAnLScgK1xyXG4gICAgICAgIGx1dFtkMiAmIDB4M2YgfCAweDgwXSArIGx1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBsdXRbZDIgPj4gMTYgJiAweGZmXSArIGx1dFtkMiA+PiAyNCAmIDB4ZmZdICtcclxuICAgICAgICBsdXRbZDMgJiAweGZmXSArIGx1dFtkMyA+PiA4ICYgMHhmZl0gKyBsdXRbZDMgPj4gMTYgJiAweGZmXSArIGx1dFtkMyA+PiAyNCAmIDB4ZmZdO1xyXG59O1xyXG5cclxudmFyIHNob3J0ID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XHJcblxyXG4gICAgdmFyIHV1aWQgPSBnZW5lcmF0ZSgpO1xyXG5cclxuICAgIHJldHVybiBwcmVmaXggKyB1dWlkLnNwbGl0KCctJylbMF07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBnZW5lcmF0ZSxcclxuICAgIHNob3J0XHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3V0aWwvdXVpZC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=