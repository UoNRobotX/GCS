/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _keenUi = __webpack_require__(3);
	
	var _keenUi2 = _interopRequireDefault(_keenUi);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _store = __webpack_require__(233);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_keenUi2.default);
	
	var app = new _vue2.default({
	    el: 'body',
	    components: {
	        App: _App2.default
	    },
	    store: _store2.default
	});
	
	window.app = app;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Keen UI v0.8.9 (https://github.com/JosephusPaye/keen-ui)
	 * (c) 2016 Josephus Paye II
	 * Released under the MIT License.
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Keen"] = factory();
		else
			root["Keen"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		__webpack_require__(1);
		
		var _UiAlert = __webpack_require__(2);
		
		var _UiAlert2 = _interopRequireDefault(_UiAlert);
		
		var _UiAutocomplete = __webpack_require__(81);
		
		var _UiAutocomplete2 = _interopRequireDefault(_UiAutocomplete);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		var _UiCheckbox = __webpack_require__(113);
		
		var _UiCheckbox2 = _interopRequireDefault(_UiCheckbox);
		
		var _UiCollapsible = __webpack_require__(117);
		
		var _UiCollapsible2 = _interopRequireDefault(_UiCollapsible);
		
		var _UiConfirm = __webpack_require__(121);
		
		var _UiConfirm2 = _interopRequireDefault(_UiConfirm);
		
		var _UiFab = __webpack_require__(129);
		
		var _UiFab2 = _interopRequireDefault(_UiFab);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiMenuOption = __webpack_require__(16);
		
		var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);
		
		var _UiModal = __webpack_require__(124);
		
		var _UiModal2 = _interopRequireDefault(_UiModal);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiPreloader = __webpack_require__(133);
		
		var _UiPreloader2 = _interopRequireDefault(_UiPreloader);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _UiProgressLinear = __webpack_require__(137);
		
		var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);
		
		var _UiRadio = __webpack_require__(141);
		
		var _UiRadio2 = _interopRequireDefault(_UiRadio);
		
		var _UiRadioGroup = __webpack_require__(145);
		
		var _UiRadioGroup2 = _interopRequireDefault(_UiRadioGroup);
		
		var _UiRating = __webpack_require__(149);
		
		var _UiRating2 = _interopRequireDefault(_UiRating);
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		var _UiRatingPreview = __webpack_require__(157);
		
		var _UiRatingPreview2 = _interopRequireDefault(_UiRatingPreview);
		
		var _UiRippleInk = __webpack_require__(20);
		
		var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);
		
		var _UiSelect = __webpack_require__(161);
		
		var _UiSelect2 = _interopRequireDefault(_UiSelect);
		
		var _UiSlider = __webpack_require__(172);
		
		var _UiSlider2 = _interopRequireDefault(_UiSlider);
		
		var _UiSnackbar = __webpack_require__(184);
		
		var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);
		
		var _UiSnackbarContainer = __webpack_require__(188);
		
		var _UiSnackbarContainer2 = _interopRequireDefault(_UiSnackbarContainer);
		
		var _UiSwitch = __webpack_require__(192);
		
		var _UiSwitch2 = _interopRequireDefault(_UiSwitch);
		
		var _UiTab = __webpack_require__(196);
		
		var _UiTab2 = _interopRequireDefault(_UiTab);
		
		var _UiTabs = __webpack_require__(200);
		
		var _UiTabs2 = _interopRequireDefault(_UiTabs);
		
		var _UiTextbox = __webpack_require__(208);
		
		var _UiTextbox2 = _interopRequireDefault(_UiTextbox);
		
		var _UiToolbar = __webpack_require__(212);
		
		var _UiToolbar2 = _interopRequireDefault(_UiToolbar);
		
		var _UiTooltip = __webpack_require__(74);
		
		var _UiTooltip2 = _interopRequireDefault(_UiTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var Keen = {
		    UiAlert: _UiAlert2.default,
		    UiAutocomplete: _UiAutocomplete2.default,
		    UiButton: _UiButton2.default,
		    UiCheckbox: _UiCheckbox2.default,
		    UiCollapsible: _UiCollapsible2.default,
		    UiConfirm: _UiConfirm2.default,
		    UiFab: _UiFab2.default,
		    UiIcon: _UiIcon2.default,
		    UiIconButton: _UiIconButton2.default,
		    UiMenu: _UiMenu2.default,
		    UiMenuOption: _UiMenuOption2.default,
		    UiModal: _UiModal2.default,
		    UiPopover: _UiPopover2.default,
		    UiPreloader: _UiPreloader2.default,
		    UiProgressCircular: _UiProgressCircular2.default,
		    UiProgressLinear: _UiProgressLinear2.default,
		    UiRadio: _UiRadio2.default,
		    UiRadioGroup: _UiRadioGroup2.default,
		    UiRating: _UiRating2.default,
		    UiRatingIcon: _UiRatingIcon2.default,
		    UiRatingPreview: _UiRatingPreview2.default,
		    UiRippleInk: _UiRippleInk2.default,
		    UiSelect: _UiSelect2.default,
		    UiSlider: _UiSlider2.default,
		    UiSnackbar: _UiSnackbar2.default,
		    UiSnackbarContainer: _UiSnackbarContainer2.default,
		    UiSwitch: _UiSwitch2.default,
		    UiTab: _UiTab2.default,
		    UiTabs: _UiTabs2.default,
		    UiTextbox: _UiTextbox2.default,
		    UiToolbar: _UiToolbar2.default,
		    UiTooltip: _UiTooltip2.default,
		
		    install: function install(Vue) {
		        Vue.component('ui-alert', _UiAlert2.default);
		        Vue.component('ui-autocomplete', _UiAutocomplete2.default);
		        Vue.component('ui-button', _UiButton2.default);
		        Vue.component('ui-checkbox', _UiCheckbox2.default);
		        Vue.component('ui-collapsible', _UiCollapsible2.default);
		        Vue.component('ui-confirm', _UiConfirm2.default);
		        Vue.component('ui-fab', _UiFab2.default);
		        Vue.component('ui-icon', _UiIcon2.default);
		        Vue.component('ui-icon-button', _UiIconButton2.default);
		        Vue.component('ui-menu', _UiMenu2.default);
		        Vue.component('ui-menu-option', _UiMenuOption2.default);
		        Vue.component('ui-modal', _UiModal2.default);
		        Vue.component('ui-popover', _UiPopover2.default);
		        Vue.component('ui-preloader', _UiPreloader2.default);
		        Vue.component('ui-progress-circular', _UiProgressCircular2.default);
		        Vue.component('ui-progress-linear', _UiProgressLinear2.default);
		        Vue.component('ui-radio', _UiRadio2.default);
		        Vue.component('ui-radio-group', _UiRadioGroup2.default);
		        Vue.component('ui-rating', _UiRating2.default);
		        Vue.component('ui-rating-icon', _UiRatingIcon2.default);
		        Vue.component('ui-rating-preview', _UiRatingPreview2.default);
		        Vue.component('ui-ripple-ink', _UiRippleInk2.default);
		        Vue.component('ui-select', _UiSelect2.default);
		        Vue.component('ui-slider', _UiSlider2.default);
		        Vue.component('ui-snackbar', _UiSnackbar2.default);
		        Vue.component('ui-snackbar-container', _UiSnackbarContainer2.default);
		        Vue.component('ui-switch', _UiSwitch2.default);
		        Vue.component('ui-tab', _UiTab2.default);
		        Vue.component('ui-tabs', _UiTabs2.default);
		        Vue.component('ui-textbox', _UiTextbox2.default);
		        Vue.component('ui-toolbar', _UiToolbar2.default);
		        Vue.component('ui-tooltip', _UiTooltip2.default);
		    }
		};
		
		module.exports = Keen;
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		'use strict';
		
		document.addEventListener('DOMContentLoaded', function () {
		    var hadKeyboardEvent = false;
		    var keyboardModalityWhitelist = ['input:not([type])', 'input[type=text]', 'input[type=number]', 'input[type=date]', 'input[type=time]', 'input[type=datetime]', 'textarea', '[role=textbox]', '[supports-modality=keyboard]'].join(',');
		
		    var isHandlingKeyboardThrottle;
		
		    var matcher = function () {
		        var el = document.body;
		
		        if (el.matchesSelector) {
		            return el.matchesSelector;
		        }
		
		        if (el.webkitMatchesSelector) {
		            return el.webkitMatchesSelector;
		        }
		
		        if (el.mozMatchesSelector) {
		            return el.mozMatchesSelector;
		        }
		
		        if (el.msMatchesSelector) {
		            return el.msMatchesSelector;
		        }
		
		        console.error('Couldn\'t find any matchesSelector method on document.body.');
		    }();
		
		    var disableFocusRingByDefault = function disableFocusRingByDefault() {
		        var css = 'body:not([modality=keyboard]) :focus { outline: none; }';
		        var head = document.head || document.getElementsByTagName('head')[0];
		        var style = document.createElement('style');
		
		        style.type = 'text/css';
		        style.id = 'disable-focus-ring';
		
		        if (style.styleSheet) {
		            style.styleSheet.cssText = css;
		        } else {
		            style.appendChild(document.createTextNode(css));
		        }
		
		        head.insertBefore(style, head.firstChild);
		    };
		
		    var focusTriggersKeyboardModality = function focusTriggersKeyboardModality(el) {
		        var triggers = false;
		
		        if (matcher) {
		            triggers = matcher.call(el, keyboardModalityWhitelist) && matcher.call(el, ':not([readonly])');
		        }
		
		        return triggers;
		    };
		
		    disableFocusRingByDefault();
		
		    document.body.addEventListener('keydown', function () {
		        hadKeyboardEvent = true;
		
		        if (isHandlingKeyboardThrottle) {
		            clearTimeout(isHandlingKeyboardThrottle);
		        }
		
		        isHandlingKeyboardThrottle = setTimeout(function () {
		            hadKeyboardEvent = false;
		        }, 100);
		    }, true);
		
		    document.body.addEventListener('focus', function (e) {
		        if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
		            document.body.setAttribute('modality', 'keyboard');
		        }
		    }, true);
		
		    document.body.addEventListener('blur', function () {
		        document.body.removeAttribute('modality');
		    }, true);
		});
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(3)
		__vue_script__ = __webpack_require__(5)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAlert.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(80)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAlert.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 4 */,
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-alert',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: true
		        },
		        type: {
		            type: String,
		            default: 'info' },
		        text: String,
		        icon: String,
		        hideIcon: {
		            type: Boolean,
		            default: false
		        },
		        dismissible: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    computed: {
		        iconName: function iconName() {
		            if (this.icon) {
		                return this.icon;
		            }
		
		            var icon = this.type;
		
		            if (icon === 'success') {
		                icon = 'check_circle';
		            }
		
		            return icon;
		        }
		    },
		
		    methods: {
		        close: function close() {
		            this.show = false;
		            this.$dispatch('dismissed');
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiIconButton: _UiIconButton2.default
		    }
		};
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(7)
		__vue_script__ = __webpack_require__(8)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiIcon.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(9)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiIcon.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-icon',
		
		    props: {
		        icon: {
		            type: String,
		            required: true
		        },
		        removeText: {
		            type: Boolean,
		            default: false
		        }
		    }
		};
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
		module.exports = "\n<i\n    class=\"ui-icon material-icons\" :class=\"[icon]\" v-text=\"removeText ? null : icon\"\n    aria-hidden=\"true\"\n></i>\n";
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(11)
		__vue_script__ = __webpack_require__(12)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiIconButton.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(79)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiIconButton.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 11 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _HasDropdown = __webpack_require__(72);
		
		var _HasDropdown2 = _interopRequireDefault(_HasDropdown);
		
		var _ShowsTooltip = __webpack_require__(73);
		
		var _ShowsTooltip2 = _interopRequireDefault(_ShowsTooltip);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-icon-button',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-icon-button-' + type;
		            }
		        },
		        buttonType: {
		            type: String,
		            default: 'button'
		        },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        icon: {
		            type: String,
		            required: true
		        },
		        ariaLabel: String,
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.color];
		
		            if (this.hasDropdown) {
		                classes.push('ui-dropdown');
		            }
		
		            return classes;
		        },
		        spinnerColor: function spinnerColor() {
		            if (this.color === 'color-default' || this.color === 'color-black') {
		                return 'black';
		            }
		
		            return 'white';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiMenu: _UiMenu2.default,
		        UiPopover: _UiPopover2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasDropdown2.default, _ShowsTooltip2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(14)
		__vue_script__ = __webpack_require__(15)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiMenu.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(62)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiMenu.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 14 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiMenuOption = __webpack_require__(16);
		
		var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);
		
		var _ShowsDropdown = __webpack_require__(58);
		
		var _ShowsDropdown2 = _interopRequireDefault(_ShowsDropdown);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-menu',
		
		    props: {
		        options: {
		            type: Array,
		            required: true,
		            default: function _default() {
		                return [];
		            }
		        },
		        showIcons: {
		            type: Boolean,
		            default: false
		        },
		        showSecondaryText: {
		            type: Boolean,
		            default: false
		        },
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        },
		        closeOnSelect: {
		            type: Boolean,
		            default: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-menu-default'
		        }
		    },
		
		    events: {
		        'dropdown-opened': function dropdownOpened() {
		            if (this.containFocus) {
		                document.addEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('opened');
		
		            return true;
		        },
		
		        'dropdown-closed': function dropdownClosed() {
		            if (this.containFocus) {
		                document.removeEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('closed');
		
		            return true;
		        }
		    },
		
		    methods: {
		        optionSelect: function optionSelect(option) {
		            if (!(option.disabled || option.type === 'divider')) {
		                this.$dispatch('option-selected', option);
		
		                if (this.closeOnSelect) {
		                    this.closeDropdown();
		                }
		            }
		        },
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.dropdown.contains(e.target)) {
		                e.stopPropagation();
		
		                this.$els.dropdown.querySelector('.ui-menu-option').focus();
		            }
		        },
		        redirectFocus: function redirectFocus(e) {
		            e.stopPropagation();
		
		            this.$els.dropdown.querySelector('.ui-menu-option').focus();
		        }
		    },
		
		    components: {
		        UiMenuOption: _UiMenuOption2.default
		    },
		
		    mixins: [_ShowsDropdown2.default]
		};
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(17)
		__vue_script__ = __webpack_require__(18)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiMenuOption.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(57)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiMenuOption.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 17 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-menu-option',
		
		    props: {
		        type: String,
		        text: String,
		        icon: String,
		        showIcon: {
		            type: Boolean,
		            default: false
		        },
		        secondaryText: String,
		        showSecondaryText: {
		            type: Boolean,
		            default: false
		        },
		        partial: {
		            type: String,
		            default: 'ui-menu-default'
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        },
		        option: Object
		    },
		
		    computed: {
		        isDivider: function isDivider() {
		            return this.type === 'divider';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    partials: {
		        'ui-menu-default': '\n            <ui-icon\n                class="ui-menu-option-icon" :icon="icon" v-if="showIcon && !isDivider && icon"\n            ></ui-icon>\n\n            <div class="ui-menu-option-text" v-text="text" v-if="!isDivider"></div>\n\n            <div\n                class="ui-menu-option-secondary-text" v-text="secondaryText"\n                v-if="showSecondaryText && !isDivider && secondaryText"\n            ></div>\n        '
		    },
		
		    mixins: [_ShowsRippleInk2.default]
		};
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRippleInk = __webpack_require__(20);
		
		var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiRippleInk: _UiRippleInk2.default
		    }
		};
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(21)
		__vue_script__ = __webpack_require__(22)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRippleInk.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(56)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRippleInk.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 21 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var startRipple = function startRipple(eventType, event) {
		    var holder = event.currentTarget;
		
		    if (!_classlist2.default.has(holder, 'ui-ripple-ink')) {
		        holder = holder.querySelector('.ui-ripple-ink');
		
		        if (!holder) {
		            return;
		        }
		    }
		
		    var prev = holder.getAttribute('data-ui-event');
		
		    if (prev && prev !== eventType) {
		        return;
		    }
		
		    holder.setAttribute('data-ui-event', eventType);
		
		    var rect = holder.getBoundingClientRect();
		    var x = event.offsetX;
		    var y;
		
		    if (x !== undefined) {
		        y = event.offsetY;
		    } else {
		        x = event.clientX - rect.left;
		        y = event.clientY - rect.top;
		    }
		
		    var ripple = document.createElement('div');
		    var max;
		
		    if (rect.width === rect.height) {
		        max = rect.width * 1.412;
		    } else {
		        max = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
		    }
		
		    var dim = max * 2 + 'px';
		
		    ripple.style.width = dim;
		    ripple.style.height = dim;
		    ripple.style.marginLeft = -max + x + 'px';
		    ripple.style.marginTop = -max + y + 'px';
		
		    ripple.className = 'ripple';
		    holder.appendChild(ripple);
		
		    setTimeout(function () {
		        _classlist2.default.add(ripple, 'held');
		    }, 0);
		
		    var releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';
		
		    var release = function release() {
		        document.removeEventListener(releaseEvent, release);
		
		        _classlist2.default.add(ripple, 'done');
		
		        setTimeout(function () {
		            holder.removeChild(ripple);
		
		            if (!holder.children.length) {
		                _classlist2.default.remove(holder, 'active');
		                holder.removeAttribute('data-ui-event');
		            }
		        }, 450);
		    };
		
		    document.addEventListener(releaseEvent, release);
		};
		
		var handleMouseDown = function handleMouseDown(e) {
		    if (e.button === 0) {
		        startRipple(e.type, e);
		    }
		};
		
		var handleTouchStart = function handleTouchStart(e) {
		    if (e.changedTouches) {
		        for (var i = 0; i < e.changedTouches.length; ++i) {
		            startRipple(e.type, e.changedTouches[i]);
		        }
		    }
		};
		
		exports.default = {
		    name: 'ui-ripple-ink',
		
		    props: {
		        trigger: {
		            type: Element,
		            required: true
		        }
		    },
		
		    watch: {
		        trigger: function trigger() {
		            this.initialize();
		        }
		    },
		
		    ready: function ready() {
		        this.initialize();
		    },
		    beforeDestory: function beforeDestory() {
		        if (this.trigger) {
		            this.trigger.removeEventListener('mousedown', handleMouseDown);
		            this.trigger.removeEventListener('touchstart', handleTouchStart);
		        }
		    },
		
		
		    methods: {
		        initialize: function initialize() {
		            if (this.trigger) {
		                this.trigger.addEventListener('touchstart', handleTouchStart);
		                this.trigger.addEventListener('mousedown', handleMouseDown);
		            }
		        }
		    }
		};
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _typeof2 = __webpack_require__(24);
		
		var _typeof3 = _interopRequireDefault(_typeof2);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var trim = /^\s+|\s+$/g;
		var whitespace = /\s+/g;
		
		function interpret(input) {
		    return typeof input === 'string' ? input.replace(trim, '').split(whitespace) : input;
		}
		
		function classes(el) {
		    if (isElement(el)) {
		        return el.className.replace(trim, '').split(whitespace);
		    }
		
		    return [];
		}
		
		function set(el, input) {
		    if (isElement(el)) {
		        el.className = interpret(input).join(' ');
		    }
		}
		
		function add(el, input) {
		    var current = remove(el, input);
		    var values = interpret(input);
		
		    current.push.apply(current, values);
		    set(el, current);
		
		    return current;
		}
		
		function remove(el, input) {
		    var current = classes(el);
		    var values = interpret(input);
		
		    values.forEach(function (value) {
		        var i = current.indexOf(value);
		        if (i !== -1) {
		            current.splice(i, 1);
		        }
		    });
		
		    set(el, current);
		
		    return current;
		}
		
		function contains(el, input) {
		    var current = classes(el);
		    var values = interpret(input);
		
		    return values.every(function (value) {
		        return current.indexOf(value) !== -1;
		    });
		}
		
		function isElement(o) {
		    var elementObjects = (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object';
		
		    return elementObjects ? o instanceof HTMLElement : isElementObject(o);
		}
		
		function isElementObject(o) {
		    return o && (typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) === 'object' && typeof o.nodeName === 'string' && o.nodeType === 1;
		}
		
		exports.default = {
		    add: add,
		    remove: remove,
		    contains: contains,
		    has: contains,
		    set: set,
		    get: classes
		};
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		var _Symbol = __webpack_require__(25)["default"];
		
		exports["default"] = function (obj) {
		  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
		};
		
		exports.__esModule = true;
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = { "default": __webpack_require__(26), __esModule: true };
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(27);
		__webpack_require__(55);
		module.exports = __webpack_require__(34).Symbol;
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// ECMAScript 6 symbols shim
		var $              = __webpack_require__(28)
		  , global         = __webpack_require__(29)
		  , has            = __webpack_require__(30)
		  , DESCRIPTORS    = __webpack_require__(31)
		  , $export        = __webpack_require__(33)
		  , redefine       = __webpack_require__(37)
		  , $fails         = __webpack_require__(32)
		  , shared         = __webpack_require__(40)
		  , setToStringTag = __webpack_require__(41)
		  , uid            = __webpack_require__(43)
		  , wks            = __webpack_require__(42)
		  , keyOf          = __webpack_require__(44)
		  , $names         = __webpack_require__(49)
		  , enumKeys       = __webpack_require__(50)
		  , isArray        = __webpack_require__(51)
		  , anObject       = __webpack_require__(52)
		  , toIObject      = __webpack_require__(45)
		  , createDesc     = __webpack_require__(39)
		  , getDesc        = $.getDesc
		  , setDesc        = $.setDesc
		  , _create        = $.create
		  , getNames       = $names.get
		  , $Symbol        = global.Symbol
		  , $JSON          = global.JSON
		  , _stringify     = $JSON && $JSON.stringify
		  , setter         = false
		  , HIDDEN         = wks('_hidden')
		  , isEnum         = $.isEnum
		  , SymbolRegistry = shared('symbol-registry')
		  , AllSymbols     = shared('symbols')
		  , useNative      = typeof $Symbol == 'function'
		  , ObjectProto    = Object.prototype;
		
		// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
		var setSymbolDesc = DESCRIPTORS && $fails(function(){
		  return _create(setDesc({}, 'a', {
		    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
		  })).a != 7;
		}) ? function(it, key, D){
		  var protoDesc = getDesc(ObjectProto, key);
		  if(protoDesc)delete ObjectProto[key];
		  setDesc(it, key, D);
		  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
		} : setDesc;
		
		var wrap = function(tag){
		  var sym = AllSymbols[tag] = _create($Symbol.prototype);
		  sym._k = tag;
		  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
		    configurable: true,
		    set: function(value){
		      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
		      setSymbolDesc(this, tag, createDesc(1, value));
		    }
		  });
		  return sym;
		};
		
		var isSymbol = function(it){
		  return typeof it == 'symbol';
		};
		
		var $defineProperty = function defineProperty(it, key, D){
		  if(D && has(AllSymbols, key)){
		    if(!D.enumerable){
		      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
		      it[HIDDEN][key] = true;
		    } else {
		      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
		      D = _create(D, {enumerable: createDesc(0, false)});
		    } return setSymbolDesc(it, key, D);
		  } return setDesc(it, key, D);
		};
		var $defineProperties = function defineProperties(it, P){
		  anObject(it);
		  var keys = enumKeys(P = toIObject(P))
		    , i    = 0
		    , l = keys.length
		    , key;
		  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
		  return it;
		};
		var $create = function create(it, P){
		  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
		};
		var $propertyIsEnumerable = function propertyIsEnumerable(key){
		  var E = isEnum.call(this, key);
		  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
		    ? E : true;
		};
		var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
		  var D = getDesc(it = toIObject(it), key);
		  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
		  return D;
		};
		var $getOwnPropertyNames = function getOwnPropertyNames(it){
		  var names  = getNames(toIObject(it))
		    , result = []
		    , i      = 0
		    , key;
		  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
		  return result;
		};
		var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
		  var names  = getNames(toIObject(it))
		    , result = []
		    , i      = 0
		    , key;
		  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
		  return result;
		};
		var $stringify = function stringify(it){
		  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
		  var args = [it]
		    , i    = 1
		    , $$   = arguments
		    , replacer, $replacer;
		  while($$.length > i)args.push($$[i++]);
		  replacer = args[1];
		  if(typeof replacer == 'function')$replacer = replacer;
		  if($replacer || !isArray(replacer))replacer = function(key, value){
		    if($replacer)value = $replacer.call(this, key, value);
		    if(!isSymbol(value))return value;
		  };
		  args[1] = replacer;
		  return _stringify.apply($JSON, args);
		};
		var buggyJSON = $fails(function(){
		  var S = $Symbol();
		  // MS Edge converts symbol values to JSON as {}
		  // WebKit converts symbol values to JSON as null
		  // V8 throws on boxed symbols
		  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
		});
		
		// 19.4.1.1 Symbol([description])
		if(!useNative){
		  $Symbol = function Symbol(){
		    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
		    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
		  };
		  redefine($Symbol.prototype, 'toString', function toString(){
		    return this._k;
		  });
		
		  isSymbol = function(it){
		    return it instanceof $Symbol;
		  };
		
		  $.create     = $create;
		  $.isEnum     = $propertyIsEnumerable;
		  $.getDesc    = $getOwnPropertyDescriptor;
		  $.setDesc    = $defineProperty;
		  $.setDescs   = $defineProperties;
		  $.getNames   = $names.get = $getOwnPropertyNames;
		  $.getSymbols = $getOwnPropertySymbols;
		
		  if(DESCRIPTORS && !__webpack_require__(54)){
		    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
		  }
		}
		
		var symbolStatics = {
		  // 19.4.2.1 Symbol.for(key)
		  'for': function(key){
		    return has(SymbolRegistry, key += '')
		      ? SymbolRegistry[key]
		      : SymbolRegistry[key] = $Symbol(key);
		  },
		  // 19.4.2.5 Symbol.keyFor(sym)
		  keyFor: function keyFor(key){
		    return keyOf(SymbolRegistry, key);
		  },
		  useSetter: function(){ setter = true; },
		  useSimple: function(){ setter = false; }
		};
		// 19.4.2.2 Symbol.hasInstance
		// 19.4.2.3 Symbol.isConcatSpreadable
		// 19.4.2.4 Symbol.iterator
		// 19.4.2.6 Symbol.match
		// 19.4.2.8 Symbol.replace
		// 19.4.2.9 Symbol.search
		// 19.4.2.10 Symbol.species
		// 19.4.2.11 Symbol.split
		// 19.4.2.12 Symbol.toPrimitive
		// 19.4.2.13 Symbol.toStringTag
		// 19.4.2.14 Symbol.unscopables
		$.each.call((
		  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
		  'species,split,toPrimitive,toStringTag,unscopables'
		).split(','), function(it){
		  var sym = wks(it);
		  symbolStatics[it] = useNative ? sym : wrap(sym);
		});
		
		setter = true;
		
		$export($export.G + $export.W, {Symbol: $Symbol});
		
		$export($export.S, 'Symbol', symbolStatics);
		
		$export($export.S + $export.F * !useNative, 'Object', {
		  // 19.1.2.2 Object.create(O [, Properties])
		  create: $create,
		  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
		  defineProperty: $defineProperty,
		  // 19.1.2.3 Object.defineProperties(O, Properties)
		  defineProperties: $defineProperties,
		  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
		  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
		  // 19.1.2.7 Object.getOwnPropertyNames(O)
		  getOwnPropertyNames: $getOwnPropertyNames,
		  // 19.1.2.8 Object.getOwnPropertySymbols(O)
		  getOwnPropertySymbols: $getOwnPropertySymbols
		});
		
		// 24.3.2 JSON.stringify(value [, replacer [, space]])
		$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
		
		// 19.4.3.5 Symbol.prototype[@@toStringTag]
		setToStringTag($Symbol, 'Symbol');
		// 20.2.1.9 Math[@@toStringTag]
		setToStringTag(Math, 'Math', true);
		// 24.3.3 JSON[@@toStringTag]
		setToStringTag(global.JSON, 'JSON', true);
	
	/***/ },
	/* 28 */
	/***/ function(module, exports) {
	
		var $Object = Object;
		module.exports = {
		  create:     $Object.create,
		  getProto:   $Object.getPrototypeOf,
		  isEnum:     {}.propertyIsEnumerable,
		  getDesc:    $Object.getOwnPropertyDescriptor,
		  setDesc:    $Object.defineProperty,
		  setDescs:   $Object.defineProperties,
		  getKeys:    $Object.keys,
		  getNames:   $Object.getOwnPropertyNames,
		  getSymbols: $Object.getOwnPropertySymbols,
		  each:       [].forEach
		};
	
	/***/ },
	/* 29 */
	/***/ function(module, exports) {
	
		// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		var global = module.exports = typeof window != 'undefined' && window.Math == Math
		  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
		if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
	
	/***/ },
	/* 30 */
	/***/ function(module, exports) {
	
		var hasOwnProperty = {}.hasOwnProperty;
		module.exports = function(it, key){
		  return hasOwnProperty.call(it, key);
		};
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Thank's IE8 for his funny defineProperty
		module.exports = !__webpack_require__(32)(function(){
		  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
		});
	
	/***/ },
	/* 32 */
	/***/ function(module, exports) {
	
		module.exports = function(exec){
		  try {
		    return !!exec();
		  } catch(e){
		    return true;
		  }
		};
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global    = __webpack_require__(29)
		  , core      = __webpack_require__(34)
		  , ctx       = __webpack_require__(35)
		  , PROTOTYPE = 'prototype';
		
		var $export = function(type, name, source){
		  var IS_FORCED = type & $export.F
		    , IS_GLOBAL = type & $export.G
		    , IS_STATIC = type & $export.S
		    , IS_PROTO  = type & $export.P
		    , IS_BIND   = type & $export.B
		    , IS_WRAP   = type & $export.W
		    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
		    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
		    , key, own, out;
		  if(IS_GLOBAL)source = name;
		  for(key in source){
		    // contains in native
		    own = !IS_FORCED && target && key in target;
		    if(own && key in exports)continue;
		    // export native or passed
		    out = own ? target[key] : source[key];
		    // prevent global pollution for namespaces
		    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
		    // bind timers to global for call from export context
		    : IS_BIND && own ? ctx(out, global)
		    // wrap global constructors for prevent change them in library
		    : IS_WRAP && target[key] == out ? (function(C){
		      var F = function(param){
		        return this instanceof C ? new C(param) : C(param);
		      };
		      F[PROTOTYPE] = C[PROTOTYPE];
		      return F;
		    // make static versions for prototype methods
		    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
		    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
		  }
		};
		// type bitmap
		$export.F = 1;  // forced
		$export.G = 2;  // global
		$export.S = 4;  // static
		$export.P = 8;  // proto
		$export.B = 16; // bind
		$export.W = 32; // wrap
		module.exports = $export;
	
	/***/ },
	/* 34 */
	/***/ function(module, exports) {
	
		var core = module.exports = {version: '1.2.6'};
		if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		// optional / simple context binding
		var aFunction = __webpack_require__(36);
		module.exports = function(fn, that, length){
		  aFunction(fn);
		  if(that === undefined)return fn;
		  switch(length){
		    case 1: return function(a){
		      return fn.call(that, a);
		    };
		    case 2: return function(a, b){
		      return fn.call(that, a, b);
		    };
		    case 3: return function(a, b, c){
		      return fn.call(that, a, b, c);
		    };
		  }
		  return function(/* ...args */){
		    return fn.apply(that, arguments);
		  };
		};
	
	/***/ },
	/* 36 */
	/***/ function(module, exports) {
	
		module.exports = function(it){
		  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
		  return it;
		};
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(38);
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $          = __webpack_require__(28)
		  , createDesc = __webpack_require__(39);
		module.exports = __webpack_require__(31) ? function(object, key, value){
		  return $.setDesc(object, key, createDesc(1, value));
		} : function(object, key, value){
		  object[key] = value;
		  return object;
		};
	
	/***/ },
	/* 39 */
	/***/ function(module, exports) {
	
		module.exports = function(bitmap, value){
		  return {
		    enumerable  : !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable    : !(bitmap & 4),
		    value       : value
		  };
		};
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global = __webpack_require__(29)
		  , SHARED = '__core-js_shared__'
		  , store  = global[SHARED] || (global[SHARED] = {});
		module.exports = function(key){
		  return store[key] || (store[key] = {});
		};
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		var def = __webpack_require__(28).setDesc
		  , has = __webpack_require__(30)
		  , TAG = __webpack_require__(42)('toStringTag');
		
		module.exports = function(it, tag, stat){
		  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
		};
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		var store  = __webpack_require__(40)('wks')
		  , uid    = __webpack_require__(43)
		  , Symbol = __webpack_require__(29).Symbol;
		module.exports = function(name){
		  return store[name] || (store[name] =
		    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
		};
	
	/***/ },
	/* 43 */
	/***/ function(module, exports) {
	
		var id = 0
		  , px = Math.random();
		module.exports = function(key){
		  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
		};
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $         = __webpack_require__(28)
		  , toIObject = __webpack_require__(45);
		module.exports = function(object, el){
		  var O      = toIObject(object)
		    , keys   = $.getKeys(O)
		    , length = keys.length
		    , index  = 0
		    , key;
		  while(length > index)if(O[key = keys[index++]] === el)return key;
		};
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		// to indexed object, toObject with fallback for non-array-like ES3 strings
		var IObject = __webpack_require__(46)
		  , defined = __webpack_require__(48);
		module.exports = function(it){
		  return IObject(defined(it));
		};
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		// fallback for non-array-like ES3 and non-enumerable old V8 strings
		var cof = __webpack_require__(47);
		module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
		  return cof(it) == 'String' ? it.split('') : Object(it);
		};
	
	/***/ },
	/* 47 */
	/***/ function(module, exports) {
	
		var toString = {}.toString;
		
		module.exports = function(it){
		  return toString.call(it).slice(8, -1);
		};
	
	/***/ },
	/* 48 */
	/***/ function(module, exports) {
	
		// 7.2.1 RequireObjectCoercible(argument)
		module.exports = function(it){
		  if(it == undefined)throw TypeError("Can't call method on  " + it);
		  return it;
		};
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
		// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
		var toIObject = __webpack_require__(45)
		  , getNames  = __webpack_require__(28).getNames
		  , toString  = {}.toString;
		
		var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
		  ? Object.getOwnPropertyNames(window) : [];
		
		var getWindowNames = function(it){
		  try {
		    return getNames(it);
		  } catch(e){
		    return windowNames.slice();
		  }
		};
		
		module.exports.get = function getOwnPropertyNames(it){
		  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
		  return getNames(toIObject(it));
		};
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		// all enumerable object keys, includes symbols
		var $ = __webpack_require__(28);
		module.exports = function(it){
		  var keys       = $.getKeys(it)
		    , getSymbols = $.getSymbols;
		  if(getSymbols){
		    var symbols = getSymbols(it)
		      , isEnum  = $.isEnum
		      , i       = 0
		      , key;
		    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
		  }
		  return keys;
		};
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 7.2.2 IsArray(argument)
		var cof = __webpack_require__(47);
		module.exports = Array.isArray || function(arg){
		  return cof(arg) == 'Array';
		};
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObject = __webpack_require__(53);
		module.exports = function(it){
		  if(!isObject(it))throw TypeError(it + ' is not an object!');
		  return it;
		};
	
	/***/ },
	/* 53 */
	/***/ function(module, exports) {
	
		module.exports = function(it){
		  return typeof it === 'object' ? it !== null : typeof it === 'function';
		};
	
	/***/ },
	/* 54 */
	/***/ function(module, exports) {
	
		module.exports = true;
	
	/***/ },
	/* 55 */
	/***/ function(module, exports) {
	
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-ripple-ink\"></div>\n";
	
	/***/ },
	/* 57 */
	/***/ function(module, exports) {
	
		module.exports = "\n<a\n    class=\"ui-menu-option\" role=\"menu-item\" :tabindex=\"(isDivider || disabled) ? null : '0'\"\n    :class=\"{ 'divider': isDivider, 'disabled' : disabled }\"\n>\n    <div class=\"ui-menu-option-content\" :class=\"[partial]\">\n        <partial :name=\"partial\"></partial>\n    </div>\n\n    <ui-ripple-ink\n        :trigger=\"$el\" v-if=\"!hideRippleInk && !disabled && !isDivider\"\n    ></ui-ripple-ink>\n</a>\n";
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _tetherDrop = __webpack_require__(59);
		
		var _tetherDrop2 = _interopRequireDefault(_tetherDrop);
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        id: String,
		        trigger: Element,
		        containFocus: {
		            type: Boolean,
		            default: true
		        },
		        dropdownPosition: {
		            type: String,
		            default: 'bottom left'
		        },
		        openOn: {
		            type: String,
		            default: 'click' }
		    },
		
		    data: function data() {
		        return {
		            drop: null,
		            lastFocussedElement: null
		        };
		    },
		    ready: function ready() {
		        if (this.trigger) {
		            this.initializeDropdown();
		        }
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.drop) {
		            this.drop.remove();
		            this.drop.destroy();
		        }
		    },
		
		
		    events: {
		        'ui-dropdown::open': function uiDropdownOpen(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.openDropdown();
		        },
		
		        'ui-dropdown::close': function uiDropdownClose(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.closeDropdown();
		        },
		
		        'ui-dropdown::toggle': function uiDropdownToggle(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.toggleDropdown();
		        }
		    },
		
		    methods: {
		        initializeDropdown: function initializeDropdown() {
		            this.drop = new _tetherDrop2.default({
		                target: this.trigger,
		                content: this.$els.dropdown,
		                position: this.dropdownPosition,
		                constrainToWindow: true,
		                openOn: this.openOn
		            });
		
		            if (this.dropdownPosition !== 'bottom left') {
		                this.drop.open();
		                this.drop.close();
		                this.drop.open();
		                this.drop.close();
		            }
		
		            this.drop.on('open', this.positionDrop);
		            this.drop.on('open', this.dropdownOpened);
		            this.drop.on('close', this.dropdownClosed);
		        },
		        openDropdown: function openDropdown() {
		            if (this.drop) {
		                this.drop.open();
		            }
		        },
		        positionDrop: function positionDrop() {
		            var drop = this.drop;
		            var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		
		            var dropWidth = drop.drop.getBoundingClientRect().width;
		            var left = drop.target.getBoundingClientRect().left;
		            var availableSpace = windowWidth - left;
		
		            if (dropWidth > availableSpace) {
		                var direction = dropWidth > availableSpace ? 'right' : 'left';
		
		                drop.tether.attachment.left = direction;
		                drop.tether.targetAttachment.left = direction;
		
		                drop.position();
		            }
		        },
		        closeDropdown: function closeDropdown() {
		            if (this.drop) {
		                this.drop.close();
		            }
		        },
		        toggleDropdown: function toggleDropdown(e) {
		            if (this.drop) {
		                this.drop.toggle(e);
		            }
		        },
		        dropdownOpened: function dropdownOpened() {
		            _classlist2.default.add(this.trigger, 'dropdown-open');
		
		            this.lastFocussedElement = document.activeElement;
		            this.$els.dropdown.focus();
		
		            this.$dispatch('dropdown-opened');
		        },
		        dropdownClosed: function dropdownClosed() {
		            _classlist2.default.remove(this.trigger, 'dropdown-open');
		
		            if (this.lastFocussedElement) {
		                this.lastFocussedElement.focus();
		            }
		
		            this.$dispatch('dropdown-closed');
		        }
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether-drop 1.4.1 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require('tether'));
		  } else {
		    root.Drop = factory(root.Tether);
		  }
		}(this, function(Tether) {
		
		/* global Tether */
		'use strict';
		
		var _bind = Function.prototype.bind;
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var _Tether$Utils = Tether.Utils;
		var extend = _Tether$Utils.extend;
		var addClass = _Tether$Utils.addClass;
		var removeClass = _Tether$Utils.removeClass;
		var hasClass = _Tether$Utils.hasClass;
		var Evented = _Tether$Utils.Evented;
		
		function sortAttach(str) {
		  var _str$split = str.split(' ');
		
		  var _str$split2 = _slicedToArray(_str$split, 2);
		
		  var first = _str$split2[0];
		  var second = _str$split2[1];
		
		  if (['left', 'right'].indexOf(first) >= 0) {
		    var _ref = [second, first];
		    first = _ref[0];
		    second = _ref[1];
		  }
		  return [first, second].join(' ');
		}
		
		function removeFromArray(arr, item) {
		  var index = undefined;
		  var results = [];
		  while ((index = arr.indexOf(item)) !== -1) {
		    results.push(arr.splice(index, 1));
		  }
		  return results;
		}
		
		var clickEvents = ['click'];
		if ('ontouchstart' in document.documentElement) {
		  clickEvents.push('touchstart');
		}
		
		var transitionEndEvents = {
		  'WebkitTransition': 'webkitTransitionEnd',
		  'MozTransition': 'transitionend',
		  'OTransition': 'otransitionend',
		  'transition': 'transitionend'
		};
		
		var transitionEndEvent = '';
		for (var _name in transitionEndEvents) {
		  if (({}).hasOwnProperty.call(transitionEndEvents, _name)) {
		    var tempEl = document.createElement('p');
		    if (typeof tempEl.style[_name] !== 'undefined') {
		      transitionEndEvent = transitionEndEvents[_name];
		    }
		  }
		}
		
		var MIRROR_ATTACH = {
		  left: 'right',
		  right: 'left',
		  top: 'bottom',
		  bottom: 'top',
		  middle: 'middle',
		  center: 'center'
		};
		
		var allDrops = {};
		
		// Drop can be included in external libraries.  Calling createContext gives you a fresh
		// copy of drop which won't interact with other copies on the page (beyond calling the document events).
		
		function createContext() {
		  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		  var drop = function drop() {
		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }
		
		    return new (_bind.apply(DropInstance, [null].concat(args)))();
		  };
		
		  extend(drop, {
		    createContext: createContext,
		    drops: [],
		    defaults: {}
		  });
		
		  var defaultOptions = {
		    classPrefix: 'drop',
		    defaults: {
		      position: 'bottom left',
		      openOn: 'click',
		      beforeClose: null,
		      constrainToScrollParent: true,
		      constrainToWindow: true,
		      classes: '',
		      remove: false,
		      openDelay: 0,
		      closeDelay: 50,
		      // inherited from openDelay and closeDelay if not explicitly defined
		      focusDelay: null,
		      blurDelay: null,
		      hoverOpenDelay: null,
		      hoverCloseDelay: null,
		      tetherOptions: {}
		    }
		  };
		
		  extend(drop, defaultOptions, options);
		  extend(drop.defaults, defaultOptions.defaults, options.defaults);
		
		  if (typeof allDrops[drop.classPrefix] === 'undefined') {
		    allDrops[drop.classPrefix] = [];
		  }
		
		  drop.updateBodyClasses = function () {
		    // There is only one body, so despite the context concept, we still iterate through all
		    // drops which share our classPrefix.
		
		    var anyOpen = false;
		    var drops = allDrops[drop.classPrefix];
		    var len = drops.length;
		    for (var i = 0; i < len; ++i) {
		      if (drops[i].isOpened()) {
		        anyOpen = true;
		        break;
		      }
		    }
		
		    if (anyOpen) {
		      addClass(document.body, drop.classPrefix + '-open');
		    } else {
		      removeClass(document.body, drop.classPrefix + '-open');
		    }
		  };
		
		  var DropInstance = (function (_Evented) {
		    _inherits(DropInstance, _Evented);
		
		    function DropInstance(opts) {
		      _classCallCheck(this, DropInstance);
		
		      _get(Object.getPrototypeOf(DropInstance.prototype), 'constructor', this).call(this);
		      this.options = extend({}, drop.defaults, opts);
		      this.target = this.options.target;
		
		      if (typeof this.target === 'undefined') {
		        throw new Error('Drop Error: You must provide a target.');
		      }
		
		      var dataPrefix = 'data-' + drop.classPrefix;
		
		      var contentAttr = this.target.getAttribute(dataPrefix);
		      if (contentAttr && this.options.content == null) {
		        this.options.content = contentAttr;
		      }
		
		      var attrsOverride = ['position', 'openOn'];
		      for (var i = 0; i < attrsOverride.length; ++i) {
		
		        var override = this.target.getAttribute(dataPrefix + '-' + attrsOverride[i]);
		        if (override && this.options[attrsOverride[i]] == null) {
		          this.options[attrsOverride[i]] = override;
		        }
		      }
		
		      if (this.options.classes && this.options.addTargetClasses !== false) {
		        addClass(this.target, this.options.classes);
		      }
		
		      drop.drops.push(this);
		      allDrops[drop.classPrefix].push(this);
		
		      this._boundEvents = [];
		      this.bindMethods();
		      this.setupElements();
		      this.setupEvents();
		      this.setupTether();
		    }
		
		    _createClass(DropInstance, [{
		      key: '_on',
		      value: function _on(element, event, handler) {
		        this._boundEvents.push({ element: element, event: event, handler: handler });
		        element.addEventListener(event, handler);
		      }
		    }, {
		      key: 'bindMethods',
		      value: function bindMethods() {
		        this.transitionEndHandler = this._transitionEndHandler.bind(this);
		      }
		    }, {
		      key: 'setupElements',
		      value: function setupElements() {
		        var _this = this;
		
		        this.drop = document.createElement('div');
		        addClass(this.drop, drop.classPrefix);
		
		        if (this.options.classes) {
		          addClass(this.drop, this.options.classes);
		        }
		
		        this.content = document.createElement('div');
		        addClass(this.content, drop.classPrefix + '-content');
		
		        if (typeof this.options.content === 'function') {
		          var generateAndSetContent = function generateAndSetContent() {
		            // content function might return a string or an element
		            var contentElementOrHTML = _this.options.content.call(_this, _this);
		
		            if (typeof contentElementOrHTML === 'string') {
		              _this.content.innerHTML = contentElementOrHTML;
		            } else if (typeof contentElementOrHTML === 'object') {
		              _this.content.innerHTML = '';
		              _this.content.appendChild(contentElementOrHTML);
		            } else {
		              throw new Error('Drop Error: Content function should return a string or HTMLElement.');
		            }
		          };
		
		          generateAndSetContent();
		          this.on('open', generateAndSetContent.bind(this));
		        } else if (typeof this.options.content === 'object') {
		          this.content.appendChild(this.options.content);
		        } else {
		          this.content.innerHTML = this.options.content;
		        }
		
		        this.drop.appendChild(this.content);
		      }
		    }, {
		      key: 'setupTether',
		      value: function setupTether() {
		        // Tether expects two attachment points, one in the target element, one in the
		        // drop.  We use a single one, and use the order as well, to allow us to put
		        // the drop on either side of any of the four corners.  This magic converts between
		        // the two:
		        var dropAttach = this.options.position.split(' ');
		        dropAttach[0] = MIRROR_ATTACH[dropAttach[0]];
		        dropAttach = dropAttach.join(' ');
		
		        var constraints = [];
		        if (this.options.constrainToScrollParent) {
		          constraints.push({
		            to: 'scrollParent',
		            pin: 'top, bottom',
		            attachment: 'together none'
		          });
		        } else {
		          // To get 'out of bounds' classes
		          constraints.push({
		            to: 'scrollParent'
		          });
		        }
		
		        if (this.options.constrainToWindow !== false) {
		          constraints.push({
		            to: 'window',
		            attachment: 'together'
		          });
		        } else {
		          // To get 'out of bounds' classes
		          constraints.push({
		            to: 'window'
		          });
		        }
		
		        var opts = {
		          element: this.drop,
		          target: this.target,
		          attachment: sortAttach(dropAttach),
		          targetAttachment: sortAttach(this.options.position),
		          classPrefix: drop.classPrefix,
		          offset: '0 0',
		          targetOffset: '0 0',
		          enabled: false,
		          constraints: constraints,
		          addTargetClasses: this.options.addTargetClasses
		        };
		
		        if (this.options.tetherOptions !== false) {
		          this.tether = new Tether(extend({}, opts, this.options.tetherOptions));
		        }
		      }
		    }, {
		      key: 'setupEvents',
		      value: function setupEvents() {
		        var _this2 = this;
		
		        if (!this.options.openOn) {
		          return;
		        }
		
		        if (this.options.openOn === 'always') {
		          setTimeout(this.open.bind(this));
		          return;
		        }
		
		        var events = this.options.openOn.split(' ');
		
		        if (events.indexOf('click') >= 0) {
		          var openHandler = function openHandler(event) {
		            _this2.toggle(event);
		            event.preventDefault();
		          };
		
		          var closeHandler = function closeHandler(event) {
		            if (!_this2.isOpened()) {
		              return;
		            }
		
		            // Clicking inside dropdown
		            if (event.target === _this2.drop || _this2.drop.contains(event.target)) {
		              return;
		            }
		
		            // Clicking target
		            if (event.target === _this2.target || _this2.target.contains(event.target)) {
		              return;
		            }
		
		            _this2.close(event);
		          };
		
		          for (var i = 0; i < clickEvents.length; ++i) {
		            var clickEvent = clickEvents[i];
		            this._on(this.target, clickEvent, openHandler);
		            this._on(document, clickEvent, closeHandler);
		          }
		        }
		
		        var inTimeout = null;
		        var outTimeout = null;
		
		        var inHandler = function inHandler(event) {
		          if (outTimeout !== null) {
		            clearTimeout(outTimeout);
		          } else {
		            inTimeout = setTimeout(function () {
		              _this2.open(event);
		              inTimeout = null;
		            }, (event.type === 'focus' ? _this2.options.focusDelay : _this2.options.hoverOpenDelay) || _this2.options.openDelay);
		          }
		        };
		
		        var outHandler = function outHandler(event) {
		          if (inTimeout !== null) {
		            clearTimeout(inTimeout);
		          } else {
		            outTimeout = setTimeout(function () {
		              _this2.close(event);
		              outTimeout = null;
		            }, (event.type === 'blur' ? _this2.options.blurDelay : _this2.options.hoverCloseDelay) || _this2.options.closeDelay);
		          }
		        };
		
		        if (events.indexOf('hover') >= 0) {
		          this._on(this.target, 'mouseover', inHandler);
		          this._on(this.drop, 'mouseover', inHandler);
		          this._on(this.target, 'mouseout', outHandler);
		          this._on(this.drop, 'mouseout', outHandler);
		        }
		
		        if (events.indexOf('focus') >= 0) {
		          this._on(this.target, 'focus', inHandler);
		          this._on(this.drop, 'focus', inHandler);
		          this._on(this.target, 'blur', outHandler);
		          this._on(this.drop, 'blur', outHandler);
		        }
		      }
		    }, {
		      key: 'isOpened',
		      value: function isOpened() {
		        if (this.drop) {
		          return hasClass(this.drop, drop.classPrefix + '-open');
		        }
		      }
		    }, {
		      key: 'toggle',
		      value: function toggle(event) {
		        if (this.isOpened()) {
		          this.close(event);
		        } else {
		          this.open(event);
		        }
		      }
		    }, {
		      key: 'open',
		      value: function open(event) {
		        var _this3 = this;
		
		        /* eslint no-unused-vars: 0 */
		        if (this.isOpened()) {
		          return;
		        }
		
		        if (!this.drop.parentNode) {
		          document.body.appendChild(this.drop);
		        }
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.enable();
		        }
		
		        addClass(this.drop, drop.classPrefix + '-open');
		        addClass(this.drop, drop.classPrefix + '-open-transitionend');
		
		        setTimeout(function () {
		          if (_this3.drop) {
		            addClass(_this3.drop, drop.classPrefix + '-after-open');
		          }
		        });
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.position();
		        }
		
		        this.trigger('open');
		
		        drop.updateBodyClasses();
		      }
		    }, {
		      key: '_transitionEndHandler',
		      value: function _transitionEndHandler(e) {
		        if (e.target !== e.currentTarget) {
		          return;
		        }
		
		        if (!hasClass(this.drop, drop.classPrefix + '-open')) {
		          removeClass(this.drop, drop.classPrefix + '-open-transitionend');
		        }
		        this.drop.removeEventListener(transitionEndEvent, this.transitionEndHandler);
		      }
		    }, {
		      key: 'beforeCloseHandler',
		      value: function beforeCloseHandler(event) {
		        var shouldClose = true;
		
		        if (!this.isClosing && typeof this.options.beforeClose === 'function') {
		          this.isClosing = true;
		          shouldClose = this.options.beforeClose(event, this) !== false;
		        }
		
		        this.isClosing = false;
		
		        return shouldClose;
		      }
		    }, {
		      key: 'close',
		      value: function close(event) {
		        if (!this.isOpened()) {
		          return;
		        }
		
		        if (!this.beforeCloseHandler(event)) {
		          return;
		        }
		
		        removeClass(this.drop, drop.classPrefix + '-open');
		        removeClass(this.drop, drop.classPrefix + '-after-open');
		
		        this.drop.addEventListener(transitionEndEvent, this.transitionEndHandler);
		
		        this.trigger('close');
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.disable();
		        }
		
		        drop.updateBodyClasses();
		
		        if (this.options.remove) {
		          this.remove(event);
		        }
		      }
		    }, {
		      key: 'remove',
		      value: function remove(event) {
		        this.close(event);
		        if (this.drop.parentNode) {
		          this.drop.parentNode.removeChild(this.drop);
		        }
		      }
		    }, {
		      key: 'position',
		      value: function position() {
		        if (this.isOpened() && typeof this.tether !== 'undefined') {
		          this.tether.position();
		        }
		      }
		    }, {
		      key: 'destroy',
		      value: function destroy() {
		        this.remove();
		
		        if (typeof this.tether !== 'undefined') {
		          this.tether.destroy();
		        }
		
		        for (var i = 0; i < this._boundEvents.length; ++i) {
		          var _boundEvents$i = this._boundEvents[i];
		          var element = _boundEvents$i.element;
		          var _event = _boundEvents$i.event;
		          var handler = _boundEvents$i.handler;
		
		          element.removeEventListener(_event, handler);
		        }
		
		        this._boundEvents = [];
		
		        this.tether = null;
		        this.drop = null;
		        this.content = null;
		        this.target = null;
		
		        removeFromArray(allDrops[drop.classPrefix], this);
		        removeFromArray(drop.drops, this);
		      }
		    }]);
		
		    return DropInstance;
		  })(Evented);
		
		  return drop;
		}
		
		var Drop = createContext();
		
		document.addEventListener('DOMContentLoaded', function () {
		  Drop.updateBodyClasses();
		});
		return Drop;
		
		}));
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether 1.2.0 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require, exports, module);
		  } else {
		    root.Tether = factory();
		  }
		}(this, function(require, exports, module) {
		
		'use strict';
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		var TetherBase = undefined;
		if (typeof TetherBase === 'undefined') {
		  TetherBase = { modules: [] };
		}
		
		function getScrollParent(el) {
		  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;
		  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397
		  var computedStyle = getComputedStyle(el) || {};
		  var position = computedStyle.position;
		
		  if (position === 'fixed') {
		    return el;
		  }
		
		  var parent = el;
		  while (parent = parent.parentNode) {
		    var style = undefined;
		    try {
		      style = getComputedStyle(parent);
		    } catch (err) {}
		
		    if (typeof style === 'undefined' || style === null) {
		      return parent;
		    }
		
		    var _style = style;
		    var overflow = _style.overflow;
		    var overflowX = _style.overflowX;
		    var overflowY = _style.overflowY;
		
		    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
		      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {
		        return parent;
		      }
		    }
		  }
		
		  return document.body;
		}
		
		var uniqueId = (function () {
		  var id = 0;
		  return function () {
		    return ++id;
		  };
		})();
		
		var zeroPosCache = {};
		var getOrigin = function getOrigin(doc) {
		  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of
		  // jitter as the user scrolls that messes with our ability to detect if two positions
		  // are equivilant or not.  We place an element at the top left of the page that will
		  // get the same jitter, so we can cancel the two out.
		  var node = doc._tetherZeroElement;
		  if (typeof node === 'undefined') {
		    node = doc.createElement('div');
		    node.setAttribute('data-tether-id', uniqueId());
		    extend(node.style, {
		      top: 0,
		      left: 0,
		      position: 'absolute'
		    });
		
		    doc.body.appendChild(node);
		
		    doc._tetherZeroElement = node;
		  }
		
		  var id = node.getAttribute('data-tether-id');
		  if (typeof zeroPosCache[id] === 'undefined') {
		    zeroPosCache[id] = {};
		
		    var rect = node.getBoundingClientRect();
		    for (var k in rect) {
		      // Can't use extend, as on IE9, elements don't resolve to be hasOwnProperty
		      zeroPosCache[id][k] = rect[k];
		    }
		
		    // Clear the cache when this position call is done
		    defer(function () {
		      delete zeroPosCache[id];
		    });
		  }
		
		  return zeroPosCache[id];
		};
		
		function getBounds(el) {
		  var doc = undefined;
		  if (el === document) {
		    doc = document;
		    el = document.documentElement;
		  } else {
		    doc = el.ownerDocument;
		  }
		
		  var docEl = doc.documentElement;
		
		  var box = {};
		  // The original object returned by getBoundingClientRect is immutable, so we clone it
		  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9
		  var rect = el.getBoundingClientRect();
		  for (var k in rect) {
		    box[k] = rect[k];
		  }
		
		  var origin = getOrigin(doc);
		
		  box.top -= origin.top;
		  box.left -= origin.left;
		
		  if (typeof box.width === 'undefined') {
		    box.width = document.body.scrollWidth - box.left - box.right;
		  }
		  if (typeof box.height === 'undefined') {
		    box.height = document.body.scrollHeight - box.top - box.bottom;
		  }
		
		  box.top = box.top - docEl.clientTop;
		  box.left = box.left - docEl.clientLeft;
		  box.right = doc.body.clientWidth - box.width - box.left;
		  box.bottom = doc.body.clientHeight - box.height - box.top;
		
		  return box;
		}
		
		function getOffsetParent(el) {
		  return el.offsetParent || document.documentElement;
		}
		
		function getScrollBarSize() {
		  var inner = document.createElement('div');
		  inner.style.width = '100%';
		  inner.style.height = '200px';
		
		  var outer = document.createElement('div');
		  extend(outer.style, {
		    position: 'absolute',
		    top: 0,
		    left: 0,
		    pointerEvents: 'none',
		    visibility: 'hidden',
		    width: '200px',
		    height: '150px',
		    overflow: 'hidden'
		  });
		
		  outer.appendChild(inner);
		
		  document.body.appendChild(outer);
		
		  var widthContained = inner.offsetWidth;
		  outer.style.overflow = 'scroll';
		  var widthScroll = inner.offsetWidth;
		
		  if (widthContained === widthScroll) {
		    widthScroll = outer.clientWidth;
		  }
		
		  document.body.removeChild(outer);
		
		  var width = widthContained - widthScroll;
		
		  return { width: width, height: width };
		}
		
		function extend() {
		  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		  var args = [];
		
		  Array.prototype.push.apply(args, arguments);
		
		  args.slice(1).forEach(function (obj) {
		    if (obj) {
		      for (var key in obj) {
		        if (({}).hasOwnProperty.call(obj, key)) {
		          out[key] = obj[key];
		        }
		      }
		    }
		  });
		
		  return out;
		}
		
		function removeClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    name.split(' ').forEach(function (cls) {
		      if (cls.trim()) {
		        el.classList.remove(cls);
		      }
		    });
		  } else {
		    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');
		    var className = getClassName(el).replace(regex, ' ');
		    setClassName(el, className);
		  }
		}
		
		function addClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    name.split(' ').forEach(function (cls) {
		      if (cls.trim()) {
		        el.classList.add(cls);
		      }
		    });
		  } else {
		    removeClass(el, name);
		    var cls = getClassName(el) + (' ' + name);
		    setClassName(el, cls);
		  }
		}
		
		function hasClass(el, name) {
		  if (typeof el.classList !== 'undefined') {
		    return el.classList.contains(name);
		  }
		  var className = getClassName(el);
		  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);
		}
		
		function getClassName(el) {
		  if (el.className instanceof SVGAnimatedString) {
		    return el.className.baseVal;
		  }
		  return el.className;
		}
		
		function setClassName(el, className) {
		  el.setAttribute('class', className);
		}
		
		function updateClasses(el, add, all) {
		  // Of the set of 'all' classes, we need the 'add' classes, and only the
		  // 'add' classes to be set.
		  all.forEach(function (cls) {
		    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
		      removeClass(el, cls);
		    }
		  });
		
		  add.forEach(function (cls) {
		    if (!hasClass(el, cls)) {
		      addClass(el, cls);
		    }
		  });
		}
		
		var deferred = [];
		
		var defer = function defer(fn) {
		  deferred.push(fn);
		};
		
		var flush = function flush() {
		  var fn = undefined;
		  while (fn = deferred.pop()) {
		    fn();
		  }
		};
		
		var Evented = (function () {
		  function Evented() {
		    _classCallCheck(this, Evented);
		  }
		
		  _createClass(Evented, [{
		    key: 'on',
		    value: function on(event, handler, ctx) {
		      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
		
		      if (typeof this.bindings === 'undefined') {
		        this.bindings = {};
		      }
		      if (typeof this.bindings[event] === 'undefined') {
		        this.bindings[event] = [];
		      }
		      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });
		    }
		  }, {
		    key: 'once',
		    value: function once(event, handler, ctx) {
		      this.on(event, handler, ctx, true);
		    }
		  }, {
		    key: 'off',
		    value: function off(event, handler) {
		      if (typeof this.bindings !== 'undefined' && typeof this.bindings[event] !== 'undefined') {
		        return;
		      }
		
		      if (typeof handler === 'undefined') {
		        delete this.bindings[event];
		      } else {
		        var i = 0;
		        while (i < this.bindings[event].length) {
		          if (this.bindings[event][i].handler === handler) {
		            this.bindings[event].splice(i, 1);
		          } else {
		            ++i;
		          }
		        }
		      }
		    }
		  }, {
		    key: 'trigger',
		    value: function trigger(event) {
		      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {
		        var i = 0;
		
		        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		          args[_key - 1] = arguments[_key];
		        }
		
		        while (i < this.bindings[event].length) {
		          var _bindings$event$i = this.bindings[event][i];
		          var handler = _bindings$event$i.handler;
		          var ctx = _bindings$event$i.ctx;
		          var once = _bindings$event$i.once;
		
		          var context = ctx;
		          if (typeof context === 'undefined') {
		            context = this;
		          }
		
		          handler.apply(context, args);
		
		          if (once) {
		            this.bindings[event].splice(i, 1);
		          } else {
		            ++i;
		          }
		        }
		      }
		    }
		  }]);
		
		  return Evented;
		})();
		
		TetherBase.Utils = {
		  getScrollParent: getScrollParent,
		  getBounds: getBounds,
		  getOffsetParent: getOffsetParent,
		  extend: extend,
		  addClass: addClass,
		  removeClass: removeClass,
		  hasClass: hasClass,
		  updateClasses: updateClasses,
		  defer: defer,
		  flush: flush,
		  uniqueId: uniqueId,
		  Evented: Evented,
		  getScrollBarSize: getScrollBarSize
		};
		/* globals TetherBase, performance */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		if (typeof TetherBase === 'undefined') {
		  throw new Error('You must include the utils.js file before tether.js');
		}
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getScrollParent = _TetherBase$Utils.getScrollParent;
		var getBounds = _TetherBase$Utils.getBounds;
		var getOffsetParent = _TetherBase$Utils.getOffsetParent;
		var extend = _TetherBase$Utils.extend;
		var addClass = _TetherBase$Utils.addClass;
		var removeClass = _TetherBase$Utils.removeClass;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		var flush = _TetherBase$Utils.flush;
		var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
		
		function within(a, b) {
		  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
		
		  return a + diff >= b && b >= a - diff;
		}
		
		var transformKey = (function () {
		  if (typeof document === 'undefined') {
		    return '';
		  }
		  var el = document.createElement('div');
		
		  var transforms = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
		  for (var i = 0; i < transforms.length; ++i) {
		    var key = transforms[i];
		    if (el.style[key] !== undefined) {
		      return key;
		    }
		  }
		})();
		
		var tethers = [];
		
		var position = function position() {
		  tethers.forEach(function (tether) {
		    tether.position(false);
		  });
		  flush();
		};
		
		function now() {
		  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {
		    return performance.now();
		  }
		  return +new Date();
		}
		
		(function () {
		  var lastCall = null;
		  var lastDuration = null;
		  var pendingTimeout = null;
		
		  var tick = function tick() {
		    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {
		      // We voluntarily throttle ourselves if we can't manage 60fps
		      lastDuration = Math.min(lastDuration - 16, 250);
		
		      // Just in case this is the last event, remember to position just once more
		      pendingTimeout = setTimeout(tick, 250);
		      return;
		    }
		
		    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {
		      // Some browsers call events a little too frequently, refuse to run more than is reasonable
		      return;
		    }
		
		    if (typeof pendingTimeout !== 'undefined') {
		      clearTimeout(pendingTimeout);
		      pendingTimeout = null;
		    }
		
		    lastCall = now();
		    position();
		    lastDuration = now() - lastCall;
		  };
		
		  if (typeof window !== 'undefined') {
		    ['resize', 'scroll', 'touchmove'].forEach(function (event) {
		      window.addEventListener(event, tick);
		    });
		  }
		})();
		
		var MIRROR_LR = {
		  center: 'center',
		  left: 'right',
		  right: 'left'
		};
		
		var MIRROR_TB = {
		  middle: 'middle',
		  top: 'bottom',
		  bottom: 'top'
		};
		
		var OFFSET_MAP = {
		  top: 0,
		  left: 0,
		  middle: '50%',
		  center: '50%',
		  bottom: '100%',
		  right: '100%'
		};
		
		var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
		  var left = attachment.left;
		  var top = attachment.top;
		
		  if (left === 'auto') {
		    left = MIRROR_LR[relativeToAttachment.left];
		  }
		
		  if (top === 'auto') {
		    top = MIRROR_TB[relativeToAttachment.top];
		  }
		
		  return { left: left, top: top };
		};
		
		var attachmentToOffset = function attachmentToOffset(attachment) {
		  var left = attachment.left;
		  var top = attachment.top;
		
		  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {
		    left = OFFSET_MAP[attachment.left];
		  }
		
		  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {
		    top = OFFSET_MAP[attachment.top];
		  }
		
		  return { left: left, top: top };
		};
		
		function addOffset() {
		  var out = { top: 0, left: 0 };
		
		  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
		    offsets[_key] = arguments[_key];
		  }
		
		  offsets.forEach(function (_ref) {
		    var top = _ref.top;
		    var left = _ref.left;
		
		    if (typeof top === 'string') {
		      top = parseFloat(top, 10);
		    }
		    if (typeof left === 'string') {
		      left = parseFloat(left, 10);
		    }
		
		    out.top += top;
		    out.left += left;
		  });
		
		  return out;
		}
		
		function offsetToPx(offset, size) {
		  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
		    offset.left = parseFloat(offset.left, 10) / 100 * size.width;
		  }
		  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
		    offset.top = parseFloat(offset.top, 10) / 100 * size.height;
		  }
		
		  return offset;
		}
		
		var parseOffset = function parseOffset(value) {
		  var _value$split = value.split(' ');
		
		  var _value$split2 = _slicedToArray(_value$split, 2);
		
		  var top = _value$split2[0];
		  var left = _value$split2[1];
		
		  return { top: top, left: left };
		};
		var parseAttachment = parseOffset;
		
		var TetherClass = (function () {
		  function TetherClass(options) {
		    var _this = this;
		
		    _classCallCheck(this, TetherClass);
		
		    this.position = this.position.bind(this);
		
		    tethers.push(this);
		
		    this.history = [];
		
		    this.setOptions(options, false);
		
		    TetherBase.modules.forEach(function (module) {
		      if (typeof module.initialize !== 'undefined') {
		        module.initialize.call(_this);
		      }
		    });
		
		    this.position();
		  }
		
		  _createClass(TetherClass, [{
		    key: 'getClass',
		    value: function getClass() {
		      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
		      var classes = this.options.classes;
		
		      if (typeof classes !== 'undefined' && classes[key]) {
		        return this.options.classes[key];
		      } else if (this.options.classPrefix) {
		        return this.options.classPrefix + '-' + key;
		      } else {
		        return key;
		      }
		    }
		  }, {
		    key: 'setOptions',
		    value: function setOptions(options) {
		      var _this2 = this;
		
		      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
		
		      var defaults = {
		        offset: '0 0',
		        targetOffset: '0 0',
		        targetAttachment: 'auto auto',
		        classPrefix: 'tether'
		      };
		
		      this.options = extend(defaults, options);
		
		      var _options = this.options;
		      var element = _options.element;
		      var target = _options.target;
		      var targetModifier = _options.targetModifier;
		
		      this.element = element;
		      this.target = target;
		      this.targetModifier = targetModifier;
		
		      if (this.target === 'viewport') {
		        this.target = document.body;
		        this.targetModifier = 'visible';
		      } else if (this.target === 'scroll-handle') {
		        this.target = document.body;
		        this.targetModifier = 'scroll-handle';
		      }
		
		      ['element', 'target'].forEach(function (key) {
		        if (typeof _this2[key] === 'undefined') {
		          throw new Error('Tether Error: Both element and target must be defined');
		        }
		
		        if (typeof _this2[key].jquery !== 'undefined') {
		          _this2[key] = _this2[key][0];
		        } else if (typeof _this2[key] === 'string') {
		          _this2[key] = document.querySelector(_this2[key]);
		        }
		      });
		
		      addClass(this.element, this.getClass('element'));
		      if (!(this.options.addTargetClasses === false)) {
		        addClass(this.target, this.getClass('target'));
		      }
		
		      if (!this.options.attachment) {
		        throw new Error('Tether Error: You must provide an attachment');
		      }
		
		      this.targetAttachment = parseAttachment(this.options.targetAttachment);
		      this.attachment = parseAttachment(this.options.attachment);
		      this.offset = parseOffset(this.options.offset);
		      this.targetOffset = parseOffset(this.options.targetOffset);
		
		      if (typeof this.scrollParent !== 'undefined') {
		        this.disable();
		      }
		
		      if (this.targetModifier === 'scroll-handle') {
		        this.scrollParent = this.target;
		      } else {
		        this.scrollParent = getScrollParent(this.target);
		      }
		
		      if (!(this.options.enabled === false)) {
		        this.enable(pos);
		      }
		    }
		  }, {
		    key: 'getTargetBounds',
		    value: function getTargetBounds() {
		      if (typeof this.targetModifier !== 'undefined') {
		        if (this.targetModifier === 'visible') {
		          if (this.target === document.body) {
		            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };
		          } else {
		            var bounds = getBounds(this.target);
		
		            var out = {
		              height: bounds.height,
		              width: bounds.width,
		              top: bounds.top,
		              left: bounds.left
		            };
		
		            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
		            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
		            out.height = Math.min(innerHeight, out.height);
		            out.height -= 2;
		
		            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
		            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
		            out.width = Math.min(innerWidth, out.width);
		            out.width -= 2;
		
		            if (out.top < pageYOffset) {
		              out.top = pageYOffset;
		            }
		            if (out.left < pageXOffset) {
		              out.left = pageXOffset;
		            }
		
		            return out;
		          }
		        } else if (this.targetModifier === 'scroll-handle') {
		          var bounds = undefined;
		          var target = this.target;
		          if (target === document.body) {
		            target = document.documentElement;
		
		            bounds = {
		              left: pageXOffset,
		              top: pageYOffset,
		              height: innerHeight,
		              width: innerWidth
		            };
		          } else {
		            bounds = getBounds(target);
		          }
		
		          var style = getComputedStyle(target);
		
		          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;
		
		          var scrollBottom = 0;
		          if (hasBottomScroll) {
		            scrollBottom = 15;
		          }
		
		          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;
		
		          var out = {
		            width: 15,
		            height: height * 0.975 * (height / target.scrollHeight),
		            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
		          };
		
		          var fitAdj = 0;
		          if (height < 408 && this.target === document.body) {
		            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
		          }
		
		          if (this.target !== document.body) {
		            out.height = Math.max(out.height, 24);
		          }
		
		          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
		          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);
		
		          if (this.target === document.body) {
		            out.height = Math.max(out.height, 24);
		          }
		
		          return out;
		        }
		      } else {
		        return getBounds(this.target);
		      }
		    }
		  }, {
		    key: 'clearCache',
		    value: function clearCache() {
		      this._cache = {};
		    }
		  }, {
		    key: 'cache',
		    value: function cache(k, getter) {
		      // More than one module will often need the same DOM info, so
		      // we keep a cache which is cleared on each position call
		      if (typeof this._cache === 'undefined') {
		        this._cache = {};
		      }
		
		      if (typeof this._cache[k] === 'undefined') {
		        this._cache[k] = getter.call(this);
		      }
		
		      return this._cache[k];
		    }
		  }, {
		    key: 'enable',
		    value: function enable() {
		      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
		
		      if (!(this.options.addTargetClasses === false)) {
		        addClass(this.target, this.getClass('enabled'));
		      }
		      addClass(this.element, this.getClass('enabled'));
		      this.enabled = true;
		
		      if (this.scrollParent !== document) {
		        this.scrollParent.addEventListener('scroll', this.position);
		      }
		
		      if (pos) {
		        this.position();
		      }
		    }
		  }, {
		    key: 'disable',
		    value: function disable() {
		      removeClass(this.target, this.getClass('enabled'));
		      removeClass(this.element, this.getClass('enabled'));
		      this.enabled = false;
		
		      if (typeof this.scrollParent !== 'undefined') {
		        this.scrollParent.removeEventListener('scroll', this.position);
		      }
		    }
		  }, {
		    key: 'destroy',
		    value: function destroy() {
		      var _this3 = this;
		
		      this.disable();
		
		      tethers.forEach(function (tether, i) {
		        if (tether === _this3) {
		          tethers.splice(i, 1);
		          return;
		        }
		      });
		    }
		  }, {
		    key: 'updateAttachClasses',
		    value: function updateAttachClasses(elementAttach, targetAttach) {
		      var _this4 = this;
		
		      elementAttach = elementAttach || this.attachment;
		      targetAttach = targetAttach || this.targetAttachment;
		      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];
		
		      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {
		        // updateAttachClasses can be called more than once in a position call, so
		        // we need to clean up after ourselves such that when the last defer gets
		        // ran it doesn't add any extra classes from previous calls.
		        this._addAttachClasses.splice(0, this._addAttachClasses.length);
		      }
		
		      if (typeof this._addAttachClasses === 'undefined') {
		        this._addAttachClasses = [];
		      }
		      var add = this._addAttachClasses;
		
		      if (elementAttach.top) {
		        add.push(this.getClass('element-attached') + '-' + elementAttach.top);
		      }
		      if (elementAttach.left) {
		        add.push(this.getClass('element-attached') + '-' + elementAttach.left);
		      }
		      if (targetAttach.top) {
		        add.push(this.getClass('target-attached') + '-' + targetAttach.top);
		      }
		      if (targetAttach.left) {
		        add.push(this.getClass('target-attached') + '-' + targetAttach.left);
		      }
		
		      var all = [];
		      sides.forEach(function (side) {
		        all.push(_this4.getClass('element-attached') + '-' + side);
		        all.push(_this4.getClass('target-attached') + '-' + side);
		      });
		
		      defer(function () {
		        if (!(typeof _this4._addAttachClasses !== 'undefined')) {
		          return;
		        }
		
		        updateClasses(_this4.element, _this4._addAttachClasses, all);
		        if (!(_this4.options.addTargetClasses === false)) {
		          updateClasses(_this4.target, _this4._addAttachClasses, all);
		        }
		
		        delete _this4._addAttachClasses;
		      });
		    }
		  }, {
		    key: 'position',
		    value: function position() {
		      var _this5 = this;
		
		      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
		
		      // flushChanges commits the changes immediately, leave true unless you are positioning multiple
		      // tethers (in which case call Tether.Utils.flush yourself when you're done)
		
		      if (!this.enabled) {
		        return;
		      }
		
		      this.clearCache();
		
		      // Turn 'auto' attachments into the appropriate corner or edge
		      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
		
		      this.updateAttachClasses(this.attachment, targetAttachment);
		
		      var elementPos = this.cache('element-bounds', function () {
		        return getBounds(_this5.element);
		      });
		
		      var width = elementPos.width;
		      var height = elementPos.height;
		
		      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
		        var _lastSize = this.lastSize;
		
		        // We cache the height and width to make it possible to position elements that are
		        // getting hidden.
		        width = _lastSize.width;
		        height = _lastSize.height;
		      } else {
		        this.lastSize = { width: width, height: height };
		      }
		
		      var targetPos = this.cache('target-bounds', function () {
		        return _this5.getTargetBounds();
		      });
		      var targetSize = targetPos;
		
		      // Get an actual px offset from the attachment
		      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });
		      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
		
		      var manualOffset = offsetToPx(this.offset, { width: width, height: height });
		      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
		
		      // Add the manually provided offset
		      offset = addOffset(offset, manualOffset);
		      targetOffset = addOffset(targetOffset, manualTargetOffset);
		
		      // It's now our goal to make (element position + offset) == (target position + target offset)
		      var left = targetPos.left + targetOffset.left - offset.left;
		      var top = targetPos.top + targetOffset.top - offset.top;
		
		      for (var i = 0; i < TetherBase.modules.length; ++i) {
		        var _module2 = TetherBase.modules[i];
		        var ret = _module2.position.call(this, {
		          left: left,
		          top: top,
		          targetAttachment: targetAttachment,
		          targetPos: targetPos,
		          elementPos: elementPos,
		          offset: offset,
		          targetOffset: targetOffset,
		          manualOffset: manualOffset,
		          manualTargetOffset: manualTargetOffset,
		          scrollbarSize: scrollbarSize,
		          attachment: this.attachment
		        });
		
		        if (ret === false) {
		          return false;
		        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {
		          continue;
		        } else {
		          top = ret.top;
		          left = ret.left;
		        }
		      }
		
		      // We describe the position three different ways to give the optimizer
		      // a chance to decide the best possible way to position the element
		      // with the fewest repaints.
		      var next = {
		        // It's position relative to the page (absolute positioning when
		        // the element is a child of the body)
		        page: {
		          top: top,
		          left: left
		        },
		
		        // It's position relative to the viewport (fixed positioning)
		        viewport: {
		          top: top - pageYOffset,
		          bottom: pageYOffset - top - height + innerHeight,
		          left: left - pageXOffset,
		          right: pageXOffset - left - width + innerWidth
		        }
		      };
		
		      var scrollbarSize = undefined;
		      if (document.body.scrollWidth > window.innerWidth) {
		        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
		        next.viewport.bottom -= scrollbarSize.height;
		      }
		
		      if (document.body.scrollHeight > window.innerHeight) {
		        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
		        next.viewport.right -= scrollbarSize.width;
		      }
		
		      if (['', 'static'].indexOf(document.body.style.position) === -1 || ['', 'static'].indexOf(document.body.parentElement.style.position) === -1) {
		        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'
		        next.page.bottom = document.body.scrollHeight - top - height;
		        next.page.right = document.body.scrollWidth - left - width;
		      }
		
		      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {
		        (function () {
		          var offsetParent = _this5.cache('target-offsetparent', function () {
		            return getOffsetParent(_this5.target);
		          });
		          var offsetPosition = _this5.cache('target-offsetparent-bounds', function () {
		            return getBounds(offsetParent);
		          });
		          var offsetParentStyle = getComputedStyle(offsetParent);
		          var offsetParentSize = offsetPosition;
		
		          var offsetBorder = {};
		          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {
		            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
		          });
		
		          offsetPosition.right = document.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
		          offsetPosition.bottom = document.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;
		
		          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
		            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
		              // We're within the visible part of the target's scroll parent
		              var scrollTop = offsetParent.scrollTop;
		              var scrollLeft = offsetParent.scrollLeft;
		
		              // It's position relative to the target's offset parent (absolute positioning when
		              // the element is moved to be a child of the target's offset parent).
		              next.offset = {
		                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
		                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
		              };
		            }
		          }
		        })();
		      }
		
		      // We could also travel up the DOM and try each containing context, rather than only
		      // looking at the body, but we're gonna get diminishing returns.
		
		      this.move(next);
		
		      this.history.unshift(next);
		
		      if (this.history.length > 3) {
		        this.history.pop();
		      }
		
		      if (flushChanges) {
		        flush();
		      }
		
		      return true;
		    }
		
		    // THE ISSUE
		  }, {
		    key: 'move',
		    value: function move(pos) {
		      var _this6 = this;
		
		      if (!(typeof this.element.parentNode !== 'undefined')) {
		        return;
		      }
		
		      var same = {};
		
		      for (var type in pos) {
		        same[type] = {};
		
		        for (var key in pos[type]) {
		          var found = false;
		
		          for (var i = 0; i < this.history.length; ++i) {
		            var point = this.history[i];
		            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {
		              found = true;
		              break;
		            }
		          }
		
		          if (!found) {
		            same[type][key] = true;
		          }
		        }
		      }
		
		      var css = { top: '', left: '', right: '', bottom: '' };
		
		      var transcribe = function transcribe(_same, _pos) {
		        var hasOptimizations = typeof _this6.options.optimizations !== 'undefined';
		        var gpu = hasOptimizations ? _this6.options.optimizations.gpu : null;
		        if (gpu !== false) {
		          var yPos = undefined,
		              xPos = undefined;
		          if (_same.top) {
		            css.top = 0;
		            yPos = _pos.top;
		          } else {
		            css.bottom = 0;
		            yPos = -_pos.bottom;
		          }
		
		          if (_same.left) {
		            css.left = 0;
		            xPos = _pos.left;
		          } else {
		            css.right = 0;
		            xPos = -_pos.right;
		          }
		
		          css[transformKey] = 'translateX(' + Math.round(xPos) + 'px) translateY(' + Math.round(yPos) + 'px)';
		
		          if (transformKey !== 'msTransform') {
		            // The Z transform will keep this in the GPU (faster, and prevents artifacts),
		            // but IE9 doesn't support 3d transforms and will choke.
		            css[transformKey] += " translateZ(0)";
		          }
		        } else {
		          if (_same.top) {
		            css.top = _pos.top + 'px';
		          } else {
		            css.bottom = _pos.bottom + 'px';
		          }
		
		          if (_same.left) {
		            css.left = _pos.left + 'px';
		          } else {
		            css.right = _pos.right + 'px';
		          }
		        }
		      };
		
		      var moved = false;
		      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
		        css.position = 'absolute';
		        transcribe(same.page, pos.page);
		      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
		        css.position = 'fixed';
		        transcribe(same.viewport, pos.viewport);
		      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {
		        (function () {
		          css.position = 'absolute';
		          var offsetParent = _this6.cache('target-offsetparent', function () {
		            return getOffsetParent(_this6.target);
		          });
		
		          if (getOffsetParent(_this6.element) !== offsetParent) {
		            defer(function () {
		              _this6.element.parentNode.removeChild(_this6.element);
		              offsetParent.appendChild(_this6.element);
		            });
		          }
		
		          transcribe(same.offset, pos.offset);
		          moved = true;
		        })();
		      } else {
		        css.position = 'absolute';
		        transcribe({ top: true, left: true }, pos.page);
		      }
		
		      if (!moved) {
		        var offsetParentIsBody = true;
		        var currentNode = this.element.parentNode;
		        while (currentNode && currentNode.tagName !== 'BODY') {
		          if (getComputedStyle(currentNode).position !== 'static') {
		            offsetParentIsBody = false;
		            break;
		          }
		
		          currentNode = currentNode.parentNode;
		        }
		
		        if (!offsetParentIsBody) {
		          this.element.parentNode.removeChild(this.element);
		          document.body.appendChild(this.element);
		        }
		      }
		
		      // Any css change will trigger a repaint, so let's avoid one if nothing changed
		      var writeCSS = {};
		      var write = false;
		      for (var key in css) {
		        var val = css[key];
		        var elVal = this.element.style[key];
		
		        if (elVal !== '' && val !== '' && ['top', 'left', 'bottom', 'right'].indexOf(key) >= 0) {
		          elVal = parseFloat(elVal);
		          val = parseFloat(val);
		        }
		
		        if (elVal !== val) {
		          write = true;
		          writeCSS[key] = val;
		        }
		      }
		
		      if (write) {
		        defer(function () {
		          extend(_this6.element.style, writeCSS);
		        });
		      }
		    }
		  }]);
		
		  return TetherClass;
		})();
		
		TetherClass.modules = [];
		
		TetherBase.position = position;
		
		var Tether = extend(TetherClass, TetherBase);
		/* globals TetherBase */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getBounds = _TetherBase$Utils.getBounds;
		var extend = _TetherBase$Utils.extend;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		
		var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];
		
		function getBoundingRect(tether, to) {
		  if (to === 'scrollParent') {
		    to = tether.scrollParent;
		  } else if (to === 'window') {
		    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
		  }
		
		  if (to === document) {
		    to = to.documentElement;
		  }
		
		  if (typeof to.nodeType !== 'undefined') {
		    (function () {
		      var size = getBounds(to);
		      var pos = size;
		      var style = getComputedStyle(to);
		
		      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];
		
		      BOUNDS_FORMAT.forEach(function (side, i) {
		        side = side[0].toUpperCase() + side.substr(1);
		        if (side === 'Top' || side === 'Left') {
		          to[i] += parseFloat(style['border' + side + 'Width']);
		        } else {
		          to[i] -= parseFloat(style['border' + side + 'Width']);
		        }
		      });
		    })();
		  }
		
		  return to;
		}
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var _this = this;
		
		    var top = _ref.top;
		    var left = _ref.left;
		    var targetAttachment = _ref.targetAttachment;
		
		    if (!this.options.constraints) {
		      return true;
		    }
		
		    var _cache = this.cache('element-bounds', function () {
		      return getBounds(_this.element);
		    });
		
		    var height = _cache.height;
		    var width = _cache.width;
		
		    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
		      var _lastSize = this.lastSize;
		
		      // Handle the item getting hidden as a result of our positioning without glitching
		      // the classes in and out
		      width = _lastSize.width;
		      height = _lastSize.height;
		    }
		
		    var targetSize = this.cache('target-bounds', function () {
		      return _this.getTargetBounds();
		    });
		
		    var targetHeight = targetSize.height;
		    var targetWidth = targetSize.width;
		
		    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];
		
		    this.options.constraints.forEach(function (constraint) {
		      var outOfBoundsClass = constraint.outOfBoundsClass;
		      var pinnedClass = constraint.pinnedClass;
		
		      if (outOfBoundsClass) {
		        allClasses.push(outOfBoundsClass);
		      }
		      if (pinnedClass) {
		        allClasses.push(pinnedClass);
		      }
		    });
		
		    allClasses.forEach(function (cls) {
		      ['left', 'top', 'right', 'bottom'].forEach(function (side) {
		        allClasses.push(cls + '-' + side);
		      });
		    });
		
		    var addClasses = [];
		
		    var tAttachment = extend({}, targetAttachment);
		    var eAttachment = extend({}, this.attachment);
		
		    this.options.constraints.forEach(function (constraint) {
		      var to = constraint.to;
		      var attachment = constraint.attachment;
		      var pin = constraint.pin;
		
		      if (typeof attachment === 'undefined') {
		        attachment = '';
		      }
		
		      var changeAttachX = undefined,
		          changeAttachY = undefined;
		      if (attachment.indexOf(' ') >= 0) {
		        var _attachment$split = attachment.split(' ');
		
		        var _attachment$split2 = _slicedToArray(_attachment$split, 2);
		
		        changeAttachY = _attachment$split2[0];
		        changeAttachX = _attachment$split2[1];
		      } else {
		        changeAttachX = changeAttachY = attachment;
		      }
		
		      var bounds = getBoundingRect(_this, to);
		
		      if (changeAttachY === 'target' || changeAttachY === 'both') {
		        if (top < bounds[1] && tAttachment.top === 'top') {
		          top += targetHeight;
		          tAttachment.top = 'bottom';
		        }
		
		        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
		          top -= targetHeight;
		          tAttachment.top = 'top';
		        }
		      }
		
		      if (changeAttachY === 'together') {
		        if (top < bounds[1] && tAttachment.top === 'top') {
		          if (eAttachment.top === 'bottom') {
		            top += targetHeight;
		            tAttachment.top = 'bottom';
		
		            top += height;
		            eAttachment.top = 'top';
		          } else if (eAttachment.top === 'top') {
		            top += targetHeight;
		            tAttachment.top = 'bottom';
		
		            top -= height;
		            eAttachment.top = 'bottom';
		          }
		        }
		
		        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
		          if (eAttachment.top === 'top') {
		            top -= targetHeight;
		            tAttachment.top = 'top';
		
		            top -= height;
		            eAttachment.top = 'bottom';
		          } else if (eAttachment.top === 'bottom') {
		            top -= targetHeight;
		            tAttachment.top = 'top';
		
		            top += height;
		            eAttachment.top = 'top';
		          }
		        }
		
		        if (tAttachment.top === 'middle') {
		          if (top + height > bounds[3] && eAttachment.top === 'top') {
		            top -= height;
		            eAttachment.top = 'bottom';
		          } else if (top < bounds[1] && eAttachment.top === 'bottom') {
		            top += height;
		            eAttachment.top = 'top';
		          }
		        }
		      }
		
		      if (changeAttachX === 'target' || changeAttachX === 'both') {
		        if (left < bounds[0] && tAttachment.left === 'left') {
		          left += targetWidth;
		          tAttachment.left = 'right';
		        }
		
		        if (left + width > bounds[2] && tAttachment.left === 'right') {
		          left -= targetWidth;
		          tAttachment.left = 'left';
		        }
		      }
		
		      if (changeAttachX === 'together') {
		        if (left < bounds[0] && tAttachment.left === 'left') {
		          if (eAttachment.left === 'right') {
		            left += targetWidth;
		            tAttachment.left = 'right';
		
		            left += width;
		            eAttachment.left = 'left';
		          } else if (eAttachment.left === 'left') {
		            left += targetWidth;
		            tAttachment.left = 'right';
		
		            left -= width;
		            eAttachment.left = 'right';
		          }
		        } else if (left + width > bounds[2] && tAttachment.left === 'right') {
		          if (eAttachment.left === 'left') {
		            left -= targetWidth;
		            tAttachment.left = 'left';
		
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (eAttachment.left === 'right') {
		            left -= targetWidth;
		            tAttachment.left = 'left';
		
		            left += width;
		            eAttachment.left = 'left';
		          }
		        } else if (tAttachment.left === 'center') {
		          if (left + width > bounds[2] && eAttachment.left === 'left') {
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (left < bounds[0] && eAttachment.left === 'right') {
		            left += width;
		            eAttachment.left = 'left';
		          }
		        }
		      }
		
		      if (changeAttachY === 'element' || changeAttachY === 'both') {
		        if (top < bounds[1] && eAttachment.top === 'bottom') {
		          top += height;
		          eAttachment.top = 'top';
		        }
		
		        if (top + height > bounds[3] && eAttachment.top === 'top') {
		          top -= height;
		          eAttachment.top = 'bottom';
		        }
		      }
		
		      if (changeAttachX === 'element' || changeAttachX === 'both') {
		        if (left < bounds[0]) {
		          if (eAttachment.left === 'right') {
		            left += width;
		            eAttachment.left = 'left';
		          } else if (eAttachment.left === 'center') {
		            left += width / 2;
		            eAttachment.left = 'left';
		          }
		        }
		
		        if (left + width > bounds[2]) {
		          if (eAttachment.left === 'left') {
		            left -= width;
		            eAttachment.left = 'right';
		          } else if (eAttachment.left === 'center') {
		            left -= width / 2;
		            eAttachment.left = 'right';
		          }
		        }
		      }
		
		      if (typeof pin === 'string') {
		        pin = pin.split(',').map(function (p) {
		          return p.trim();
		        });
		      } else if (pin === true) {
		        pin = ['top', 'left', 'right', 'bottom'];
		      }
		
		      pin = pin || [];
		
		      var pinned = [];
		      var oob = [];
		
		      if (top < bounds[1]) {
		        if (pin.indexOf('top') >= 0) {
		          top = bounds[1];
		          pinned.push('top');
		        } else {
		          oob.push('top');
		        }
		      }
		
		      if (top + height > bounds[3]) {
		        if (pin.indexOf('bottom') >= 0) {
		          top = bounds[3] - height;
		          pinned.push('bottom');
		        } else {
		          oob.push('bottom');
		        }
		      }
		
		      if (left < bounds[0]) {
		        if (pin.indexOf('left') >= 0) {
		          left = bounds[0];
		          pinned.push('left');
		        } else {
		          oob.push('left');
		        }
		      }
		
		      if (left + width > bounds[2]) {
		        if (pin.indexOf('right') >= 0) {
		          left = bounds[2] - width;
		          pinned.push('right');
		        } else {
		          oob.push('right');
		        }
		      }
		
		      if (pinned.length) {
		        (function () {
		          var pinnedClass = undefined;
		          if (typeof _this.options.pinnedClass !== 'undefined') {
		            pinnedClass = _this.options.pinnedClass;
		          } else {
		            pinnedClass = _this.getClass('pinned');
		          }
		
		          addClasses.push(pinnedClass);
		          pinned.forEach(function (side) {
		            addClasses.push(pinnedClass + '-' + side);
		          });
		        })();
		      }
		
		      if (oob.length) {
		        (function () {
		          var oobClass = undefined;
		          if (typeof _this.options.outOfBoundsClass !== 'undefined') {
		            oobClass = _this.options.outOfBoundsClass;
		          } else {
		            oobClass = _this.getClass('out-of-bounds');
		          }
		
		          addClasses.push(oobClass);
		          oob.forEach(function (side) {
		            addClasses.push(oobClass + '-' + side);
		          });
		        })();
		      }
		
		      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {
		        eAttachment.left = tAttachment.left = false;
		      }
		      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {
		        eAttachment.top = tAttachment.top = false;
		      }
		
		      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
		        _this.updateAttachClasses(eAttachment, tAttachment);
		      }
		    });
		
		    defer(function () {
		      if (!(_this.options.addTargetClasses === false)) {
		        updateClasses(_this.target, addClasses, allClasses);
		      }
		      updateClasses(_this.element, addClasses, allClasses);
		    });
		
		    return { top: top, left: left };
		  }
		});
		/* globals TetherBase */
		
		'use strict';
		
		var _TetherBase$Utils = TetherBase.Utils;
		var getBounds = _TetherBase$Utils.getBounds;
		var updateClasses = _TetherBase$Utils.updateClasses;
		var defer = _TetherBase$Utils.defer;
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var _this = this;
		
		    var top = _ref.top;
		    var left = _ref.left;
		
		    var _cache = this.cache('element-bounds', function () {
		      return getBounds(_this.element);
		    });
		
		    var height = _cache.height;
		    var width = _cache.width;
		
		    var targetPos = this.getTargetBounds();
		
		    var bottom = top + height;
		    var right = left + width;
		
		    var abutted = [];
		    if (top <= targetPos.bottom && bottom >= targetPos.top) {
		      ['left', 'right'].forEach(function (side) {
		        var targetPosSide = targetPos[side];
		        if (targetPosSide === left || targetPosSide === right) {
		          abutted.push(side);
		        }
		      });
		    }
		
		    if (left <= targetPos.right && right >= targetPos.left) {
		      ['top', 'bottom'].forEach(function (side) {
		        var targetPosSide = targetPos[side];
		        if (targetPosSide === top || targetPosSide === bottom) {
		          abutted.push(side);
		        }
		      });
		    }
		
		    var allClasses = [];
		    var addClasses = [];
		
		    var sides = ['left', 'top', 'right', 'bottom'];
		    allClasses.push(this.getClass('abutted'));
		    sides.forEach(function (side) {
		      allClasses.push(_this.getClass('abutted') + '-' + side);
		    });
		
		    if (abutted.length) {
		      addClasses.push(this.getClass('abutted'));
		    }
		
		    abutted.forEach(function (side) {
		      addClasses.push(_this.getClass('abutted') + '-' + side);
		    });
		
		    defer(function () {
		      if (!(_this.options.addTargetClasses === false)) {
		        updateClasses(_this.target, addClasses, allClasses);
		      }
		      updateClasses(_this.element, addClasses, allClasses);
		    });
		
		    return true;
		  }
		});
		/* globals TetherBase */
		
		'use strict';
		
		var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
		
		TetherBase.modules.push({
		  position: function position(_ref) {
		    var top = _ref.top;
		    var left = _ref.left;
		
		    if (!this.options.shift) {
		      return;
		    }
		
		    var shift = this.options.shift;
		    if (typeof this.options.shift === 'function') {
		      shift = this.options.shift.call(this, { top: top, left: left });
		    }
		
		    var shiftTop = undefined,
		        shiftLeft = undefined;
		    if (typeof shift === 'string') {
		      shift = shift.split(' ');
		      shift[1] = shift[1] || shift[0];
		
		      var _shift = shift;
		
		      var _shift2 = _slicedToArray(_shift, 2);
		
		      shiftTop = _shift2[0];
		      shiftLeft = _shift2[1];
		
		      shiftTop = parseFloat(shiftTop, 10);
		      shiftLeft = parseFloat(shiftLeft, 10);
		    } else {
		      shiftTop = shift.top;
		      shiftLeft = shift.left;
		    }
		
		    top += shiftTop;
		    left += shiftLeft;
		
		    return { top: top, left: left };
		  }
		});
		return Tether;
		
		}));
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    props: {
		        id: String
		    },
		
		    methods: {
		        eventTargetsComponent: function eventTargetsComponent(eventTarget) {
		            if (eventTarget === undefined || this.id === eventTarget) {
		                return true;
		            }
		
		            return false;
		        }
		    }
		};
	
	/***/ },
	/* 62 */
	/***/ function(module, exports) {
	
		module.exports = "\n<ul\n    class=\"ui-menu\" role=\"menu\" tabindex=\"-1\" @keydown.esc=\"closeDropdown\" v-el:dropdown\n    :class=\"{ 'has-icons': showIcons, 'has-secondary-text': showSecondaryText }\"\n>\n    <ui-menu-option\n        :type=\"option.type\" :icon=\"option.icon\" :text=\"option.text\" :disabled=\"option.disabled\"\n        :secondary-text=\"option.secondaryText\" :option=\"option\" :show-icon=\"showIcons\"\n        :show-secondary-text=\"showSecondaryText\" :hide-ripple-ink=\"hideRippleInk\"\n        :partial=\"option.partial || partial\"\n\n        @keydown.enter.prevent=\"optionSelect(option)\" @click=\"optionSelect(option)\"\n\n        v-for=\"option in options\"\n    ></ui-menu-option>\n\n    <div\n        class=\"ui-menu-focus-redirector\" @focus=\"redirectFocus\" tabindex=\"0\"\n    ></div>\n</ul>\n";
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(64)
		__vue_script__ = __webpack_require__(65)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiPopover.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(66)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiPopover.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 64 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _ShowsDropdown = __webpack_require__(58);
		
		var _ShowsDropdown2 = _interopRequireDefault(_ShowsDropdown);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-popover',
		
		    events: {
		        'dropdown-opened': function dropdownOpened() {
		            if (this.containFocus) {
		                document.addEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('opened');
		
		            return true;
		        },
		
		        'dropdown-closed': function dropdownClosed() {
		            if (this.containFocus) {
		                document.removeEventListener('focus', this.restrictFocus, true);
		            }
		
		            this.$dispatch('closed');
		
		            return true;
		        }
		    },
		
		    methods: {
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.dropdown.contains(e.target)) {
		                e.stopPropagation();
		
		                this.$els.dropdown.focus();
		            }
		        }
		    },
		
		    mixins: [_ShowsDropdown2.default]
		};
	
	/***/ },
	/* 66 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-popover\" role=\"dialog\" tabindex=\"-1\" @keydown.esc=\"closeDropdown\" v-el:dropdown\n>\n    <slot></slot>\n</div>\n";
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(68)
		__vue_script__ = __webpack_require__(69)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiProgressCircular.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(70)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiProgressCircular.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 68 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 69 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-progress-circular',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: false
		        },
		        type: {
		            type: String,
		            default: 'indeterminate' },
		        color: {
		            type: String,
		            default: 'primary' },
		        value: {
		            type: Number,
		            default: 0
		        },
		        size: {
		            type: Number,
		            default: 32
		        },
		        stroke: Number,
		        autoStroke: {
		            type: Boolean,
		            default: true
		        },
		        disableTransition: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        strokeDashArray: function strokeDashArray() {
		            var circumference = 2 * Math.PI * this.radius;
		
		            return Math.round(circumference * 1000) / 1000;
		        },
		        strokeDashOffset: function strokeDashOffset() {
		            var value = this.moderateValue(this.value);
		            var circumference = 2 * Math.PI * this.radius;
		
		            return (100 - value) / 100 * circumference;
		        },
		        radius: function radius() {
		            return (this.size - this.stroke) / 2;
		        }
		    },
		
		    created: function created() {
		        if (!this.stroke) {
		            if (this.autoStroke) {
		                this.stroke = parseInt(this.size / 8, 10);
		            } else {
		                this.stroke = 4;
		            }
		        }
		    },
		
		
		    methods: {
		        moderateValue: function moderateValue(value) {
		            if (isNaN(value) || value < 0) {
		                return 0;
		            }
		
		            if (value > 100) {
		                return 100;
		            }
		
		            return value;
		        }
		    }
		};
	
	/***/ },
	/* 70 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-progress-circular\" :style=\"{ 'width': size + 'px', 'height': size + 'px' }\"\n    v-show=\"show\" :transition=\"disableTransition ? null : 'ui-progress-circular-toggle'\"\n>\n    <svg\n        class=\"ui-progress-circular-determinate\" :width=\"size\" :height=\"size\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" :aria-valuenow=\"value\"\n        v-if=\"type === 'determinate'\"\n    >\n        <circle\n            class=\"ui-progress-circular-determinate-path\" :class=\"[color]\" :r=\"radius\"\n            :cx=\"size / 2\" :cy=\"size / 2\" fill=\"transparent\" :stroke-dasharray=\"strokeDashArray\"\n            stroke-dashoffset=\"0\"\n\n            :style=\"{ 'stroke-dashoffset': strokeDashOffset, 'stroke-width': stroke }\"\n        ></circle>\n    </svg>\n\n    <svg\n        class=\"ui-progress-circular-indeterminate\" viewBox=\"25 25 50 50\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" v-else\n    >\n        <circle\n            class=\"ui-progress-circular-indeterminate-path\" :class=\"[color]\" cx=\"50\" cy=\"50\"\n            r=\"20\" fill=\"none\" stroke-miterlimit=\"10\" :stroke-width=\"stroke\"\n        >\n    </svg>\n</div>\n";
	
	/***/ },
	/* 71 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		exports.default = function (value) {
		    this.el.disabled = Boolean(value);
		};
	
	/***/ },
	/* 72 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    props: {
		        openDropdownOn: String,
		        dropdownPosition: String,
		        hasPopover: {
		            type: Boolean,
		            default: false
		        },
		        hasDropdownMenu: {
		            type: Boolean,
		            default: false
		        },
		        menuOptions: {
		            type: Array,
		            default: function _default() {
		                return [];
		            }
		        },
		        showMenuIcons: {
		            type: Boolean,
		            default: false
		        },
		        showMenuSecondaryText: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    methods: {
		        menuOptionSelect: function menuOptionSelect(option) {
		            this.$dispatch('menu-option-selected', option);
		        }
		    }
		};
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiTooltip = __webpack_require__(74);
		
		var _UiTooltip2 = _interopRequireDefault(_UiTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        tooltip: String,
		        openTooltipOn: String,
		        tooltipPosition: String
		    },
		
		    components: {
		        UiTooltip: _UiTooltip2.default
		    }
		};
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(75)
		__vue_script__ = __webpack_require__(76)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTooltip.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(78)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTooltip.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 75 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _tetherTooltip = __webpack_require__(77);
		
		var _tetherTooltip2 = _interopRequireDefault(_tetherTooltip);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tooltip',
		
		    props: {
		        content: String,
		        trigger: {
		            type: Element,
		            required: true
		        },
		        position: {
		            type: String,
		            default: 'bottom center'
		        },
		        openOn: {
		            type: String,
		            default: 'hover focus'
		        }
		    },
		
		    data: function data() {
		        return {
		            tooltip: null
		        };
		    },
		
		
		    watch: {
		        trigger: function trigger() {
		            if (!this.tooltip) {
		                this.initialize();
		            }
		        }
		    },
		
		    ready: function ready() {
		        this.initialize();
		    },
		    beforeDestory: function beforeDestory() {
		        if (this.tooltip) {
		            this.tooltip.remove();
		            this.tooltip.destroy();
		        }
		    },
		
		
		    methods: {
		        initialize: function initialize() {
		            if (this.trigger) {
		                this.tooltip = new _tetherTooltip2.default({
		                    target: this.trigger,
		                    content: this.$els.tooltip,
		                    classes: 'ui-tooltip-theme',
		                    position: this.position,
		                    openOn: 'hover focus'
		                });
		            }
		        }
		    }
		};
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether-tooltip 1.1.0 */
		
		(function(root, factory) {
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(59),__webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof exports === 'object') {
		    module.exports = factory(require('tether-drop'), require('tether'));
		  } else {
		    root.Tooltip = factory(root.Drop, root.Tether);
		  }
		}(this, function(Drop, Tether) {
		
		/* global Tether Drop */
		
		'use strict';
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
		
		var extend = Tether.Utils.extend;
		
		var _Drop = Drop.createContext({
		  classPrefix: 'tooltip'
		});
		
		var defaults = {
		  position: 'top center',
		  openOn: 'hover',
		  classes: 'tooltip-theme-arrows',
		  constrainToWindow: true,
		  constrainToScrollParent: false
		};
		
		var tooltipCount = 0;
		
		var Tooltip = (function () {
		  function Tooltip(options) {
		    _classCallCheck(this, Tooltip);
		
		    this.options = options;
		
		    if (!this.options.target) {
		      throw new Error('Tooltip Error: You must provide a target for Tooltip to attach to');
		    }
		
		    var position = this.options.target.getAttribute('data-tooltip-position');
		    if (position) {
		      if (typeof this.options.position === 'undefined') {
		        this.options.position = position;
		      }
		    }
		
		    var content = this.options.target.getAttribute('data-tooltip');
		
		    if (content) {
		      if (typeof this.options.content === 'undefined') {
		        var contentEl = document.createElement('div');
		        contentEl.innerHTML = content;
		
		        // Add ARIA attributes (see #50)
		        contentEl.setAttribute('role', 'tooltip');
		        contentEl.id = 'drop-tooltip-' + tooltipCount;
		        this.options.target.setAttribute('aria-describedby', contentEl.id);
		        tooltipCount += 1;
		
		        this.options.content = contentEl;
		      }
		    }
		
		    if (!this.options.content) {
		      throw new Error('Tooltip Error: You must provide content for Tooltip to display');
		    }
		
		    this.options = extend({}, defaults, this.options);
		
		    this.drop = new _Drop(this.options);
		  }
		
		  _createClass(Tooltip, [{
		    key: 'close',
		    value: function close() {
		      this.drop.close();
		    }
		  }, {
		    key: 'open',
		    value: function open() {
		      this.drop.open();
		    }
		  }, {
		    key: 'toggle',
		    value: function toggle() {
		      this.drop.toggle();
		    }
		  }, {
		    key: 'remove',
		    value: function remove() {
		      this.drop.remove();
		    }
		  }, {
		    key: 'destroy',
		    value: function destroy() {
		      this.drop.destroy();
		    }
		  }, {
		    key: 'position',
		    value: function position() {
		      this.drop.position();
		    }
		  }]);
		
		  return Tooltip;
		})();
		
		var initialized = [];
		
		Tooltip.init = function () {
		  var tooltipElements = document.querySelectorAll('[data-tooltip]');
		  var len = tooltipElements.length;
		  for (var i = 0; i < len; ++i) {
		    var el = tooltipElements[i];
		    if (initialized.indexOf(el) === -1) {
		      new Tooltip({
		        target: el
		      });
		      initialized.push(el);
		    }
		  }
		};
		
		document.addEventListener('DOMContentLoaded', function () {
		  if (Tooltip.autoinit !== false) {
		    Tooltip.init();
		  }
		});
		return Tooltip;
		
		}));
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-tooltip\" v-text=\"content\" v-el:tooltip></div>\n";
	
	/***/ },
	/* 79 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-icon-button\" :class=\"styleClasses\" :aria-label=\"ariaLabel || tooltip\"\n    :type=\"buttonType\" v-disabled=\"disabled || loading\" v-el:button\n>\n    <ui-icon\n        class=\"ui-icon-button-icon\" :icon=\"icon\" v-show=\"!loading\"\n    ></ui-icon>\n\n    <ui-progress-circular\n        class=\"ui-icon-button-spinner\" :color=\"spinnerColor\" :size=\"24\" :stroke=\"4.5\"\n        disable-transition v-show=\"loading\"\n    ></ui-progress-circular>\n\n    <ui-ripple-ink v-if=\"!hideRippleInk && !disabled\" :trigger=\"$els.button\"></ui-ripple-ink>\n\n    <ui-tooltip\n        :trigger=\"$els.button\" :content=\"tooltip\" :position=\"tooltipPosition\" v-if=\"tooltip\"\n        :open-on=\"openTooltipOn\"\n    ></ui-tooltip>\n\n    <ui-menu\n        class=\"ui-button-dropdown-menu\" :trigger=\"$els.button\" :options=\"menuOptions\"\n        :show-icons=\"showMenuIcons\" :show-secondary-text=\"showMenuSecondaryText\"\n        :open-on=\"openDropdownOn\" @option-selected=\"menuOptionSelect\"\n        :dropdown-position=\"dropdownPosition\" v-if=\"hasDropdownMenu\"\n    ></ui-menu>\n\n    <ui-popover\n        :trigger=\"$els.button\" :open-on=\"openDropdownOn\" :dropdown-position=\"dropdownPosition\"\n        v-if=\"hasPopover\"\n    >\n        <slot name=\"popover\"></slot>\n    </ui-popover>\n</button>\n";
	
	/***/ },
	/* 80 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-alert\">\n    <div\n        class=\"ui-alert-body\" :class=\"[type]\" role=\"alert\" v-show=\"show\"\n        transition=\"ui-alert-toggle\"\n    >\n        <ui-icon class=\"ui-alert-icon\" :icon=\"iconName\" v-if=\"!hideIcon\"></ui-icon>\n\n        <div class=\"ui-alert-text\">\n            <slot>\n                <span v-text=\"text\"></span>\n            </slot>\n        </div>\n\n        <ui-icon-button\n            class=\"ui-alert-close-button\" type=\"clear\" icon=\"&#xE5CD\" aria-label=\"Close\"\n            @click=\"close\" v-if=\"dismissible\"\n        ></ui-icon-button>\n    </div>\n</div>\n";
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(82)
		__vue_script__ = __webpack_require__(83)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAutocomplete.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(108)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAutocomplete.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 82 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _fuzzysearch = __webpack_require__(84);
		
		var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiAutocompleteSuggestion = __webpack_require__(85);
		
		var _UiAutocompleteSuggestion2 = _interopRequireDefault(_UiAutocompleteSuggestion);
		
		var _autofocus = __webpack_require__(90);
		
		var _autofocus2 = _interopRequireDefault(_autofocus);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-autocomplete',
		
		    props: {
		        suggestions: {
		            type: Array,
		            default: []
		        },
		        limit: {
		            type: Number,
		            default: 8
		        },
		        partial: String,
		        append: {
		            type: Boolean,
		            default: false
		        },
		        appendDelimiter: {
		            type: String,
		            default: ', '
		        },
		        minChars: {
		            type: Number,
		            default: 2
		        },
		        showOnUpDown: {
		            type: Boolean,
		            default: true
		        },
		        autofocus: {
		            type: Boolean,
		            default: false
		        },
		        filter: Function,
		        autoHighlightFirstMatch: {
		            type: Boolean,
		            default: true
		        },
		        cycleHighlight: {
		            type: Boolean,
		            default: true
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            showDropdown: false,
		            highlightedItem: -1,
		            ignoreValueChange: false
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            if (document.activeElement === this.$els.input) {
		                document.activeElement.blur();
		            }
		
		            this.value = this.initialValue;
		            this.dirty = false;
		            this.valid = true;
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (!this.ignoreValueChange && this.value.length >= this.minChars) {
		                this.open();
		            }
		
		            this.highlightedItem = this.autoHighlightFirstMatch ? 0 : -1;
		        }
		    },
		
		    ready: function ready() {
		        document.addEventListener('click', this.closeOnExternalClick);
		    },
		    beforeDestroy: function beforeDestroy() {
		        document.removeEventListener('click', this.closeOnExternalClick);
		    },
		
		
		    methods: {
		        search: function search(item) {
		            if (this.filter) {
		                return this.filter(item, this.value);
		            }
		
		            var text = item[this.keys.text] || item;
		            var query = this.value;
		
		            if (typeof query === 'string') {
		                query = query.toLowerCase();
		            }
		
		            return (0, _fuzzysearch2.default)(query, text.toLowerCase());
		        },
		        select: function select(item) {
		            var _this = this;
		
		            if (this.append) {
		                this.value += this.appendDelimiter + (item[this.keys.value] || item);
		            } else {
		                this.value = item[this.keys.value] || item;
		            }
		
		            this.$dispatch('selected', item);
		
		            this.validate();
		
		            this.$nextTick(function () {
		                _this.close();
		                _this.$els.input.focus();
		            });
		        },
		        highlight: function highlight(index) {
		            var firstIndex = 0;
		            var lastIndex = this.$refs.items.length - 1;
		
		            if (index === -2) {
		                index = lastIndex;
		            } else if (index < firstIndex) {
		                index = this.cycleHighlight ? lastIndex : index;
		            } else if (index > lastIndex) {
		                index = this.cycleHighlight ? firstIndex : -1;
		            }
		
		            this.highlightedItem = index;
		
		            if (this.showOnUpDown) {
		                this.open();
		            }
		
		            if (index < firstIndex || index > lastIndex) {
		                this.$dispatch('highlight-overflow', index);
		            } else {
		                this.$dispatch('highlighted', this.$refs.items[index].item, index);
		            }
		        },
		        selectHighlighted: function selectHighlighted(index, e) {
		            if (this.showDropdown && this.$refs.items.length) {
		                e.preventDefault();
		                this.select(this.$refs.items[index].item);
		            }
		        },
		        clearSearch: function clearSearch() {
		            this.value = '';
		        },
		        open: function open() {
		            if (!this.showDropdown) {
		                this.showDropdown = true;
		                this.$dispatch('opened');
		            }
		        },
		        close: function close() {
		            if (this.showDropdown) {
		                this.showDropdown = false;
		                this.highlightedItem = -1;
		
		                this.$dispatch('closed');
		                this.validate();
		            }
		        },
		        closeOnExternalClick: function closeOnExternalClick(e) {
		            if (!this.$els.autocomplete.contains(e.target) && this.showDropdown) {
		                this.close();
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiAutocompleteSuggestion: _UiAutocompleteSuggestion2.default
		    },
		
		    directives: {
		        autofocus: _autofocus2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 84 */
	/***/ function(module, exports) {
	
		'use strict';
		
		function fuzzysearch (needle, haystack) {
		  var tlen = haystack.length;
		  var qlen = needle.length;
		  if (qlen > tlen) {
		    return false;
		  }
		  if (qlen === tlen) {
		    return needle === haystack;
		  }
		  outer: for (var i = 0, j = 0; i < qlen; i++) {
		    var nch = needle.charCodeAt(i);
		    while (j < tlen) {
		      if (haystack.charCodeAt(j++) === nch) {
		        continue outer;
		      }
		    }
		    return false;
		  }
		  return true;
		}
		
		module.exports = fuzzysearch;
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(86)
		__vue_script__ = __webpack_require__(87)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiAutocompleteSuggestion.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(89)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiAutocompleteSuggestion.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 86 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-autocomplete-suggestion',
		
		    props: {
		        id: {
		            type: String,
		            default: function _default() {
		                return _uuid2.default.short();
		            }
		        },
		        item: {
		            type: [String, Object],
		            required: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-autocomplete-simple' },
		        highlighted: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    partials: {
		        'ui-autocomplete-simple': '\n            <li class="ui-autocomplete-suggestion-item" v-text="item[keys.text] || item"></li>\n        ',
		
		        'ui-autocomplete-image': '\n            <div\n                class="image" :style="{ \'background-image\': \'url(\' + item[keys.image] + \')\' }"\n            ></div>\n            <div class="text" v-text="item[keys.text]"></div>\n        '
		    }
		};
	
	/***/ },
	/* 88 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		/**
		 * Fast UUID generator, RFC4122 version 4 compliant.
		 * @author Jeff Ward (jcward.com).
		 * @license MIT license
		 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
		 **/
		
		var lut = [];
		
		for (var i = 0; i < 256; i++) {
		    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
		}
		
		var generate = function generate() {
		    var d0 = Math.random() * 0xffffffff | 0;
		    var d1 = Math.random() * 0xffffffff | 0;
		    var d2 = Math.random() * 0xffffffff | 0;
		    var d3 = Math.random() * 0xffffffff | 0;
		
		    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
		};
		
		var short = function short(prefix) {
		    prefix = prefix || '';
		
		    var uuid = generate();
		
		    return prefix + uuid.split('-')[0];
		};
		
		exports.default = {
		    generate: generate,
		    short: short
		};
	
	/***/ },
	/* 89 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-autocomplete-suggestion\" :class=\"[partial, { 'highlighted': highlighted }]\"\n    :id=\"id\"\n>\n    <partial :name=\"partial\"></partial>\n</li>\n";
	
	/***/ },
	/* 90 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		exports.default = function (value) {
		    this.el.autofocus = Boolean(value);
		};
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        id: String,
		        name: {
		            type: String,
		            required: true
		        },
		        placeholder: String,
		        value: {
		            type: [String, Number],
		            default: '',
		            twoWay: true
		        },
		        icon: String,
		        iconRight: {
		            type: Boolean,
		            default: false
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        },
		        debounce: {
		            type: Number,
		            default: null
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: ''
		        };
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            var canBeValidated = Boolean(this.validationRules);
		            var hasHelpText = Boolean(this.helpText);
		
		            return canBeValidated || hasHelpText;
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _validatorjs = __webpack_require__(93);
		
		var _validatorjs2 = _interopRequireDefault(_validatorjs);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    props: {
		        valid: {
		            type: Boolean,
		            default: true,
		            twoWay: true
		        },
		        dirty: {
		            type: Boolean,
		            default: false,
		            twoWay: true
		        },
		        hideValidationErrors: {
		            type: Boolean,
		            default: false
		        },
		        validationRules: [String, Array],
		        validationMessages: Object
		    },
		
		    data: function data() {
		        return {
		            validationError: ''
		        };
		    },
		
		
		    events: {
		        'ui-input::set-validity': function uiInputSetValidity(valid, error, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.setValidity(valid, error);
		        }
		    },
		
		    methods: {
		        validate: function validate() {
		            if (!this.validationRules || !this.dirty) {
		                return;
		            }
		
		            var data = {
		                value: this.value
		            };
		
		            var rules = {
		                value: this.validationRules
		            };
		
		            var validation = new _validatorjs2.default(data, rules, this.validationMessages);
		
		            validation.setAttributeNames({ value: this.name.replace(/_/g, ' ') });
		
		            this.setValidity(validation.passes(), validation.errors.first('value'));
		        },
		        setValidity: function setValidity(valid, error) {
		            this.valid = valid;
		
		            if (!valid && error && error.length) {
		                this.validationError = error;
		            }
		        }
		    }
		};
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Rules = __webpack_require__(94);
		var Lang = __webpack_require__(95);
		var Errors = __webpack_require__(106);
		var Attributes = __webpack_require__(97);
		var AsyncResolvers = __webpack_require__(107);
		
		var Validator = function(input, rules, customMessages) {
		  var lang = Validator.getDefaultLang();
		  this.input = input;
		  this.messages = Lang._make(lang);
		  this.messages._setCustom(customMessages);
		  this.setAttributeFormatter(Validator.prototype.attributeFormatter);
		
		  this.errors = new Errors();
		  this.errorCount = 0;
		
		  this.hasAsync = false;
		  this.rules = this._parseRules(rules);
		};
		
		Validator.prototype = {
		
		  constructor: Validator,
		
		  /**
		   * Default language
		   *
		   * @type {string}
		   */
		  lang: 'en',
		
		  /**
		   * Numeric based rules
		   *
		   * @type {array}
		   */
		  numericRules: ['integer', 'numeric'],
		
		  /**
		   * Attribute formatter.
		   *
		   * @type {function}
		   */
		  attributeFormatter: Attributes.formatter,
		
		  /**
		   * Run validator
		   *
		   * @return {boolean} Whether it passes; true = passes, false = fails
		   */
		  check: function() {
		    var self = this;
		
		    for (var attribute in this.rules) {
		      var attributeRules = this.rules[attribute];
		      var inputValue = this.input[attribute]; // if it doesnt exist in input, it will be undefined
		
		      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {
		        ruleOptions = attributeRules[i];
		        rule = this.getRule(ruleOptions.name);
		
		        if (!this._isValidatable(rule, inputValue)) {
		          continue;
		        }
		
		        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);
		        if (!rulePassed) {
		          this._addFailure(rule);
		        }
		
		        if (this._shouldStopValidating(attribute, rulePassed)) {
		          break;
		        }
		      }
		    }
		
		    return this.errorCount === 0;
		  },
		
		  /**
		   * Run async validator
		   *
		   * @param {function} passes
		   * @param {function} fails
		   * @return {void}
		   */
		  checkAsync: function(passes, fails) {
		    var _this = this;
		    passes = passes || function() {};
		    fails = fails || function() {};
		
		    var failsOne = function(rule, message) {
		      _this._addFailure(rule, message);
		    };
		
		    var resolvedAll = function(allPassed) {
		      if (allPassed) {
		        passes();
		      } else {
		        fails();
		      }
		    };
		
		    var validateRule = function(inputValue, ruleOptions, attribute, rule) {
		      return function() {
		        var resolverIndex = asyncResolvers.add(rule);
		        rule.validate(inputValue, ruleOptions.value, attribute, function() {
		          asyncResolvers.resolve(resolverIndex);
		        });
		      };
		    };
		
		    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);
		
		    for (var attribute in this.rules) {
		      var attributeRules = this.rules[attribute];
		      var inputValue = this.input[attribute]; // if it doesnt exist in input, it will be undefined
		
		      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {
		        ruleOptions = attributeRules[i];
		
		        rule = this.getRule(ruleOptions.name);
		
		        if (!this._isValidatable(rule, inputValue)) {
		          continue;
		        }
		
		        validateRule(inputValue, ruleOptions, attribute, rule)();
		      }
		    }
		
		    asyncResolvers.enableFiring();
		    asyncResolvers.fire();
		  },
		
		  /**
		   * Add failure and error message for given rule
		   *
		   * @param {Rule} rule
		   */
		  _addFailure: function(rule) {
		    var msg = this.messages.render(rule);
		    this.errors.add(rule.attribute, msg);
		    this.errorCount++;
		  },
		
		  /**
		   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }
		   *
		   * @param  {object} rules
		   * @return {object}
		   */
		  _parseRules: function(rules) {
		    var parsedRules = {};
		    for (var attribute in rules) {
		      var rulesArray = rules[attribute];
		      var attributeRules = [];
		
		      if (typeof rulesArray === 'string') {
		        rulesArray = rulesArray.split('|');
		      }
		
		      for (var i = 0, len = rulesArray.length, rule; i < len; i++) {
		        rule = this._extractRuleAndRuleValue(rulesArray[i]);
		        if (Rules.isAsync(rule.name)) {
		          this.hasAsync = true;
		        }
		        attributeRules.push(rule);
		      }
		
		      parsedRules[attribute] = attributeRules;
		    }
		    return parsedRules;
		  },
		
		  /**
		   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3
		   *
		   * @param  {string} ruleString min:3
		   * @return {object} object containing the name of the rule and value
		   */
		  _extractRuleAndRuleValue: function(ruleString) {
		    var rule = {},
		      ruleArray;
		
		    rule.name = ruleString;
		
		    if (ruleString.indexOf(':') >= 0) {
		      ruleArray = ruleString.split(':');
		      rule.name = ruleArray[0];
		      rule.value = ruleArray.slice(1).join(":");
		    }
		
		    return rule;
		  },
		
		  /**
		   * Determine if attribute has any of the given rules
		   *
		   * @param  {string}  attribute
		   * @param  {array}   findRules
		   * @return {boolean}
		   */
		  _hasRule: function(attribute, findRules) {
		    var rules = this.rules[attribute] || [];
		    for (var i = 0, len = rules.length; i < len; i++) {
		      if (findRules.indexOf(rules[i].name) > -1) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Determine if attribute has any numeric-based rules.
		   *
		   * @param  {string}  attribute
		   * @return {Boolean}
		   */
		  _hasNumericRule: function(attribute) {
		    return this._hasRule(attribute, this.numericRules);
		  },
		
		  /**
		   * Determine if rule is validatable
		   *
		   * @param  {Rule}   rule
		   * @param  {mixed}  value
		   * @return {boolean}
		   */
		  _isValidatable: function(rule, value) {
		    if (Rules.isImplicit(rule.name)) {
		      return true;
		    }
		
		    return this.getRule('required').validate(value);
		  },
		
		
		  /**
		   * Determine if we should stop validating.
		   *
		   * @param  {string} attribute
		   * @param  {boolean} rulePassed
		   * @return {boolean}
		   */
		  _shouldStopValidating: function(attribute, rulePassed) {
		
		    var stopOnAttributes = this.stopOnAttributes;
		    if (stopOnAttributes === false || rulePassed === true) {
		      return false;
		    }
		
		    if (stopOnAttributes instanceof Array) {
		      return stopOnAttributes.indexOf(attribute) > -1;
		    }
		
		    return true;
		  },
		
		  /**
		   * Set custom attribute names.
		   *
		   * @param {object} attributes
		   * @return {void}
		   */
		  setAttributeNames: function(attributes) {
		    this.messages._setAttributeNames(attributes);
		  },
		
		  /**
		   * Set the attribute formatter.
		   *
		   * @param {fuction} func
		   * @return {void}
		   */
		  setAttributeFormatter: function(func) {
		    this.messages._setAttributeFormatter(func);
		  },
		
		  /**
		   * Get validation rule
		   *
		   * @param  {string} name
		   * @return {Rule}
		   */
		  getRule: function(name) {
		    return Rules.make(name, this);
		  },
		
		  /**
		   * Stop on first error.
		   *
		   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		   * @return {void}
		   */
		  stopOnError: function(attributes) {
		    this.stopOnAttributes = attributes;
		  },
		
		  /**
		   * Determine if validation passes
		   *
		   * @param {function} passes
		   * @return {boolean|undefined}
		   */
		  passes: function(passes) {
		    var async = this._checkAsync('passes', passes);
		    if (async) {
		      return this.checkAsync(passes);
		    }
		    return this.check();
		  },
		
		  /**
		   * Determine if validation fails
		   *
		   * @param {function} fails
		   * @return {boolean|undefined}
		   */
		  fails: function(fails) {
		    var async = this._checkAsync('fails', fails);
		    if (async) {
		      return this.checkAsync(function() {}, fails);
		    }
		    return !this.check();
		  },
		
		  /**
		   * Check if validation should be called asynchronously
		   *
		   * @param  {string}   funcName Name of the caller
		   * @param  {function} callback
		   * @return {boolean}
		   */
		  _checkAsync: function(funcName, callback) {
		    var hasCallback = typeof callback === 'function';
		    if (this.hasAsync && !hasCallback) {
		      throw funcName + ' expects a callback when async rules are being tested.';
		    }
		
		    return this.hasAsync || hasCallback;
		  }
		
		};
		
		/**
		 * Set messages for language
		 *
		 * @param {string} lang
		 * @param {object} messages
		 * @return {this}
		 */
		Validator.setMessages = function(lang, messages) {
		  Lang._set(lang, messages);
		  return this;
		};
		
		/**
		 * Get messages for given language
		 *
		 * @param  {string} lang
		 * @return {Messages}
		 */
		Validator.getMessages = function(lang) {
		  return Lang._get(lang);
		};
		
		/**
		 * Set default language to use
		 *
		 * @param {string} lang
		 * @return {void}
		 */
		Validator.useLang = function(lang) {
		  this.prototype.lang = lang;
		};
		
		/**
		 * Get default language
		 *
		 * @return {string}
		 */
		Validator.getDefaultLang = function() {
		  return this.prototype.lang;
		};
		
		/**
		 * Set the attribute formatter.
		 *
		 * @param {fuction} func
		 * @return {void}
		 */
		Validator.setAttributeFormatter = function(func) {
		  this.prototype.attributeFormatter = func;
		};
		
		/**
		 * Stop on first error.
		 *
		 * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		 * @return {void}
		 */
		Validator.stopOnError = function(attributes) {
		  this.prototype.stopOnAttributes = attributes;
		};
		
		/**
		 * Register custom validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator.register = function(name, fn, message) {
		  var lang = Validator.getDefaultLang();
		  Rules.register(name, fn);
		  Lang._setRuleMessage(lang, name, message);
		};
		
		/**
		 * Register asynchronous validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator.registerAsync = function(name, fn, message) {
		  var lang = Validator.getDefaultLang();
		  Rules.registerAsync(name, fn);
		  Lang._setRuleMessage(lang, name, message);
		};
		
		module.exports = Validator;
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports) {
	
		var rules = {
		
		  required: function(val) {
		    var str;
		
		    if (val === undefined || val === null) {
		      return false;
		    }
		
		    str = String(val).replace(/\s/g, "");
		    return str.length > 0 ? true : false;
		  },
		
		  required_if: function(val, req, attribute) {
		    req = this.getParameters();
		    if (this.validator.input[req[0]] === req[1]) {
		      return this.validator.getRule('required').validate(val);
		    }
		
		    return true;
		  },
		
		  // compares the size of strings
		  // with numbers, compares the value
		  size: function(val, req, attribute) {
		    if (val) {
		      req = parseFloat(req);
		
		      var size = this.getSize();
		
		      return size === req;
		    }
		
		    return true;
		  },
		
		  string: function(val, req, attribute) {
		    return typeof val === 'string';
		  },
		
		  /**
		   * Compares the size of strings or the value of numbers if there is a truthy value
		   */
		  min: function(val, req, attribute) {
		    var size = this.getSize();
		    return size >= req;
		  },
		
		  /**
		   * Compares the size of strings or the value of numbers if there is a truthy value
		   */
		  max: function(val, req, attribute) {
		    var size = this.getSize();
		    return size <= req;
		  },
		
		  between: function(val, req, attribute) {
		    req = this.getParameters();
		    var size = this.getSize();
		    var min = parseFloat(req[0], 10);
		    var max = parseFloat(req[1], 10);
		    return size >= min && size <= max;
		  },
		
		  email: function(val) {
		    var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
		    return re.test(val);
		  },
		
		  numeric: function(val) {
		    var num;
		
		    num = Number(val); // tries to convert value to a number. useful if value is coming from form element
		
		    if (typeof num === 'number' && !isNaN(num) && typeof val !== 'boolean') {
		      return true;
		    } else {
		      return false;
		    }
		  },
		
		  array: function(val) {
		    return val instanceof Array;
		  },
		
		  url: function(url) {
		    return (/^https?:\/\/\S+/).test(url);
		  },
		
		  alpha: function(val) {
		    return (/^[a-zA-Z]+$/).test(val);
		  },
		
		  alpha_dash: function(val) {
		    return (/^[a-zA-Z0-9_\-]+$/).test(val);
		  },
		
		  alpha_num: function(val) {
		    return (/^[a-zA-Z0-9]+$/).test(val);
		  },
		
		  same: function(val, req) {
		    var val1 = this.validator.input[req];
		    var val2 = val;
		
		    if (val1 === val2) {
		      return true;
		    }
		
		    return false;
		  },
		
		  different: function(val, req) {
		    var val1 = this.validator.input[req];
		    var val2 = val;
		
		    if (val1 !== val2) {
		      return true;
		    }
		
		    return false;
		  },
		
		  "in": function(val, req) {
		    var list, i;
		
		    if (val) {
		      list = req.split(',');
		    }
		
		    if (val && !(val instanceof Array)) {
		      val = String(val); // if it is a number
		
		      for (i = 0; i < list.length; i++) {
		        if (val === list[i]) {
		          return true;
		        }
		      }
		
		      return false;
		    }
		
		    if (val && val instanceof Array) {
		      for (i = 0; i < val.length; i++) {
		        if (list.indexOf(val[i]) < 0) {
		          return false;
		        }
		      }
		    }
		
		    return true;
		  },
		
		  not_in: function(val, req) {
		    var list = req.split(',');
		    var len = list.length;
		    var returnVal = true;
		
		    val = String(val); // convert val to a string if it is a number
		
		    for (var i = 0; i < len; i++) {
		      if (val === list[i]) {
		        returnVal = false;
		        break;
		      }
		    }
		
		    return returnVal;
		  },
		
		  accepted: function(val) {
		    if (val === 'on' || val === 'yes' || val === 1 || val === '1' || val === true) {
		      return true;
		    }
		
		    return false;
		  },
		
		  confirmed: function(val, req, key) {
		    var confirmedKey = key + '_confirmation';
		
		    if (this.validator.input[confirmedKey] === val) {
		      return true;
		    }
		
		    return false;
		  },
		
		  integer: function(val) {
		    return String(parseInt(val, 10)) === String(val);
		  },
		
		  digits: function(val, req) {
		    var numericRule = this.validator.getRule('numeric');
		    if (numericRule.validate(val) && String(val).length === parseInt(req)) {
		      return true;
		    }
		
		    return false;
		  },
		
		  regex: function(val, req) {
		    var mod = /[g|i|m]{1,3}$/;
		    var flag = req.match(mod);
		    flag = flag ? flag[0] : "i";
		    req = req.replace(mod, "").slice(1, -1);
		    req = new RegExp(req, flag);
		    return !!val.match(req);
		  }
		
		};
		
		function Rule(name, fn, async) {
		  this.name = name;
		  this.fn = fn;
		  this.passes = null;
		  this.customMessage = undefined;
		  this.async = async;
		}
		
		Rule.prototype = {
		
		  /**
		   * Validate rule
		   *
		   * @param  {mixed} inputValue
		   * @param  {mixed} ruleValue
		   * @param  {string} attribute
		   * @param  {function} callback
		   * @return {boolean|undefined}
		   */
		  validate: function(inputValue, ruleValue, attribute, callback) {
		    var _this = this;
		    this._setValidatingData(attribute, inputValue, ruleValue);
		    if (typeof callback === 'function') {
		      this.callback = callback;
		      var handleResponse = function(passes, message) {
		        _this.response(passes, message);
		      };
		
		      if (this.async) {
		        return this.fn.apply(this, [inputValue, ruleValue, attribute, handleResponse]);
		      } else {
		        return handleResponse(this.fn.apply(this, [inputValue, ruleValue, attribute]));
		      }
		    }
		    return this.fn.apply(this, [inputValue, ruleValue, attribute]);
		  },
		
		  /**
		   * Set validating data
		   *
		   * @param {string} attribute
		   * @param {mixed} inputValue
		   * @param {mixed} ruleValue
		   * @return {void}
		   */
		  _setValidatingData: function(attribute, inputValue, ruleValue) {
		    this.attribute = attribute;
		    this.inputValue = inputValue;
		    this.ruleValue = ruleValue;
		  },
		
		  /**
		   * Get parameters
		   *
		   * @return {array}
		   */
		  getParameters: function() {
		    return this.ruleValue ? this.ruleValue.split(',') : [];
		  },
		
		  /**
		   * Get true size of value
		   *
		   * @return {integer|float}
		   */
		  getSize: function() {
		    var value = this.inputValue;
		
		    if (value instanceof Array) {
		      return value.length;
		    }
		
		    if (typeof value === 'number') {
		      return value;
		    }
		
		    if (this.validator._hasNumericRule(this.attribute)) {
		      return parseFloat(value, 10);
		    }
		
		    return value.length;
		  },
		
		  /**
		   * Get the type of value being checked; numeric or string.
		   *
		   * @return {string}
		   */
		  _getValueType: function() {
		
		    if (typeof this.inputValue === 'number' || this.validator._hasNumericRule(this.attribute)) {
		      return 'numeric';
		    }
		
		    return 'string';
		  },
		
		  /**
		   * Set the async callback response
		   *
		   * @param  {boolean|undefined} passes  Whether validation passed
		   * @param  {string|undefined} message Custom error message
		   * @return {void}
		   */
		  response: function(passes, message) {
		    this.passes = (passes === undefined || passes === true);
		    this.customMessage = message;
		    this.callback(this.passes, message);
		  },
		
		  /**
		   * Set validator instance
		   *
		   * @param {Validator} validator
		   * @return {void}
		   */
		  setValidator: function(validator) {
		    this.validator = validator;
		  }
		
		};
		
		var manager = {
		
		  /**
		   * List of async rule names
		   *
		   * @type {Array}
		   */
		  asyncRules: [],
		
		  /**
		   * Implicit rules (rules to always validate)
		   *
		   * @type {Array}
		   */
		  implicitRules: ['required', 'required_if', 'accepted'],
		
		  /**
		   * Get rule by name
		   *
		   * @param  {string} name
		   * @param {Validator}
		   * @return {Rule}
		   */
		  make: function(name, validator) {
		    var async = this.isAsync(name);
		    var rule = new Rule(name, rules[name], async);
		    rule.setValidator(validator);
		    return rule;
		  },
		
		  /**
		   * Determine if given rule is async
		   *
		   * @param  {string}  name
		   * @return {boolean}
		   */
		  isAsync: function(name) {
		    for (var i = 0, len = this.asyncRules.length; i < len; i++) {
		      if (this.asyncRules[i] === name) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Determine if rule is implicit (should always validate)
		   *
		   * @param {string} name
		   * @return {boolean}
		   */
		  isImplicit: function(name) {
		    return this.implicitRules.indexOf(name) > -1;
		  },
		
		  /**
		   * Register new rule
		   *
		   * @param  {string}   name
		   * @param  {function} fn
		   * @return {void}
		   */
		  register: function(name, fn) {
		    rules[name] = fn;
		  },
		
		  /**
		   * Register async rule
		   *
		   * @param  {string}   name
		   * @param  {function} fn
		   * @return {void}
		   */
		  registerAsync: function(name, fn) {
		    this.register(name, fn);
		    this.asyncRules.push(name);
		  }
		
		};
		
		
		module.exports = manager;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Messages = __webpack_require__(96);
		
		__webpack_require__(98);
		
		var container = {
		
		  messages: {},
		
		  /**
		   * Set messages for language
		   *
		   * @param {string} lang
		   * @param {object} rawMessages
		   * @return {void}
		   */
		  _set: function(lang, rawMessages) {
		    this.messages[lang] = rawMessages;
		  },
		
		  /**
		   * Set message for given language's rule.
		   *
		   * @param {string} lang
		   * @param {string} attribute
		   * @param {string|object} message
		   * @return {void}
		   */
		  _setRuleMessage: function(lang, attribute, message) {
		    this._load(lang);
		    if (message === undefined) {
		      message = this.messages[lang].def;
		    }
		
		    this.messages[lang][attribute] = message;
		  },
		
		  /**
		   * Load messages (if not already loaded)
		   *
		   * @param  {string} lang
		   * @return {void}
		   */
		  _load: function(lang) {
		    if (!this.messages[lang]) {
		      var rawMessages = __webpack_require__(99)("./" + lang);
		      this._set(lang, rawMessages);
		    }
		  },
		
		  /**
		   * Get raw messages for language
		   *
		   * @param  {string} lang
		   * @return {object}
		   */
		  _get: function(lang) {
		    this._load(lang);
		    return this.messages[lang];
		  },
		
		  /**
		   * Make messages for given language
		   *
		   * @param  {string} lang
		   * @return {Messages}
		   */
		  _make: function(lang) {
		    this._load(lang);
		    return new Messages(lang, this.messages[lang]);
		  }
		
		};
		
		module.exports = container;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Attributes = __webpack_require__(97);
		
		var Messages = function(lang, messages) {
		  this.lang = lang;
		  this.messages = messages;
		  this.customMessages = {};
		  this.attributeNames = {};
		};
		
		Messages.prototype = {
		  constructor: Messages,
		
		  /**
		   * Set custom messages
		   *
		   * @param {object} customMessages
		   * @return {void}
		   */
		  _setCustom: function(customMessages) {
		    this.customMessages = customMessages || {};
		  },
		
		  /**
		   * Set custom attribute names.
		   *
		   * @param {object} attributes
		   */
		  _setAttributeNames: function(attributes) {
		    this.attributeNames = attributes;
		  },
		
		  /**
		   * Set the attribute formatter.
		   *
		   * @param {fuction} func
		   * @return {void}
		   */
		  _setAttributeFormatter: function(func) {
		    this.attributeFormatter = func;
		  },
		
		  /**
		   * Get attribute name to display.
		   *
		   * @param  {string} attribute
		   * @return {string}
		   */
		  _getAttributeName: function(attribute) {
		    var name = attribute;
		    if (this.attributeNames.hasOwnProperty(attribute)) {
		      return this.attributeNames[attribute];
		    } else if (this.messages.attributes.hasOwnProperty(attribute)) {
		      name = this.messages.attributes[attribute];
		    }
		
		    if (this.attributeFormatter) {
		      name = this.attributeFormatter(name);
		    }
		
		    return name;
		  },
		
		  /**
		   * Get all messages
		   *
		   * @return {object}
		   */
		  all: function() {
		    return this.messages;
		  },
		
		  /**
		   * Render message
		   *
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  render: function(rule) {
		    if (rule.customMessage) {
		      return rule.customMessage;
		    }
		    var template = this._getTemplate(rule);
		
		    var message;
		    if (Attributes.replacements[rule.name]) {
		      message = Attributes.replacements[rule.name].apply(this, [template, rule]);
		    } else {
		      message = this._replacePlaceholders(rule, template, {});
		    }
		
		    return message;
		  },
		
		  /**
		   * Get the template to use for given rule
		   *
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  _getTemplate: function(rule) {
		
		    var messages = this.messages;
		    var template = messages.def;
		    var customMessages = this.customMessages;
		    var formats = [rule.name + '.' + rule.attribute, rule.name];
		
		    for (var i = 0, format; i < formats.length; i++) {
		      format = formats[i];
		      if (customMessages.hasOwnProperty(format)) {
		        template = customMessages[format];
		        break;
		      } else if (messages.hasOwnProperty(format)) {
		        template = messages[format];
		        break;
		      }
		    }
		
		    if (typeof template === 'object') {
		      template = template[rule._getValueType()];
		    }
		
		    return template;
		  },
		
		  /**
		   * Replace placeholders in the template using the data object
		   *
		   * @param  {Rule} rule
		   * @param  {string} template
		   * @param  {object} data
		   * @return {string}
		   */
		  _replacePlaceholders: function(rule, template, data) {
		    var message, attribute;
		
		    data.attribute = this._getAttributeName(rule.attribute);
		    data[rule.name] = rule.getParameters().join(',');
		
		    if (typeof template === 'string' && typeof data === 'object') {
		      message = template;
		
		      for (attribute in data) {
		        message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);
		      }
		    }
		
		    return message;
		  }
		
		};
		
		module.exports = Messages;
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports) {
	
		var replacements = {
		
		  /**
		   * Between replacement (replaces :min and :max)
		   *
		   * @param  {string} template
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  between: function(template, rule) {
		    var parameters = rule.getParameters();
		    return this._replacePlaceholders(rule, template, {
		      min: parameters[0],
		      max: parameters[1]
		    });
		  },
		
		  /**
		   * Required_if replacement.
		   *
		   * @param  {string} template
		   * @param  {Rule} rule
		   * @return {string}
		   */
		  required_if: function(template, rule) {
		    var parameters = rule.getParameters();
		    return this._replacePlaceholders(rule, template, {
		      other: parameters[0],
		      value: parameters[1]
		    });
		  }
		};
		
		function formatter(attribute) {
		  return attribute.replace(/[_\[]/g, ' ').replace(/]/g, '');
		}
		
		module.exports = {
		  replacements: replacements,
		  formatter: formatter
		};
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'The :attribute must be accepted.',
		  alpha: 'The :attribute field must contain only alphabetic characters.',
		  alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',
		  alpha_num: 'The :attribute field must be alphanumeric.',
		  between: 'The :attribute field must be between :min and :max.',
		  confirmed: 'The :attribute confirmation does not match.',
		  email: 'The :attribute format is invalid.',
		  def: 'The :attribute attribute has errors.',
		  digits: 'The :attribute must be :digits digits.',
		  different: 'The :attribute and :different must be different.',
		  'in': 'The selected :attribute is invalid.',
		  integer: 'The :attribute must be an integer.',
		  min: {
		    numeric: 'The :attribute must be at least :min.',
		    string: 'The :attribute must be at least :min characters.'
		  },
		  max: {
		    numeric: 'The :attribute may not be greater than :max.',
		    string: 'The :attribute may not be greater than :max characters.'
		  },
		  not_in: 'The selected :attribute is invalid.',
		  numeric: 'The :attribute must be a number.',
		  required: 'The :attribute field is required.',
		  required_if: 'The :attribute field is required when :other is :value.',
		  same: 'The :attribute and :same fields must match.',
		  size: {
		    numeric: 'The :attribute must be :size.',
		    string: 'The :attribute must be :size characters.'
		  },
		  string: 'The :attribute must be a string.',
		  url: 'The :attribute format is invalid.',
		  regex: 'The :attribute format is invalid',
		  attributes: {}
		};
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
		var map = {
			"./en": 98,
			"./en.js": 98,
			"./es": 100,
			"./es.js": 100,
			"./fr": 101,
			"./fr.js": 101,
			"./it": 102,
			"./it.js": 102,
			"./ja": 103,
			"./ja.js": 103,
			"./pl": 104,
			"./pl.js": 104,
			"./ru": 105,
			"./ru.js": 105
		};
		function webpackContext(req) {
			return __webpack_require__(webpackContextResolve(req));
		};
		function webpackContextResolve(req) {
			return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
		};
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = 99;
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'El campo :attribute debe ser aceptado.',
		  alpha: 'El campo :attribute solo debe contener letras.',
		  alpha_dash: 'El campo :attribute solo debe contener letras, nmeros y guiones.',
		  alpha_num: 'El campo :attribute solo debe contener letras y nmeros.',
		  attributes: {},
		  between: 'El campo :attribute tiene que estar entre :min - :max.',
		  confirmed: 'La confirmacin de :attribute no coincide.',
		  different: 'El campo :attribute y :other deben ser diferentes.',
		  digits: 'El campo :attribute debe tener :digits dgitos.',
		  email: 'El campo :attribute no es un correo vlido',
		  'in': 'El campo :attribute es invlido.',
		  integer: 'El campo :attribute debe ser un nmero entero.',
		  max: {
		    numeric: 'El campo :attribute no debe ser mayor a :max.',
		    string: 'El campo :attribute no debe ser mayor que :max caracteres.'
		  },
		  min: {
		    numeric: 'El tamao del campo :attribute debe ser de al menos :min.',
		    string: 'El campo :attribute debe contener al menos :min caracteres.'
		  },
		  not_in: 'El campo :attribute es invlido.',
		  numeric: 'El campo :attribute debe ser numrico.',
		  regex: 'El formato del campo :attribute es invlido.',
		  required: 'El campo :attribute es obligatorio.',
		  required_if: 'El campo :attribute es obligatorio cuando :other es :value.',
		  same: 'El campo :attribute y :other deben coincidir.',
		  size: {
		    numeric: 'El tamao del campo :attribute debe ser :size.',
		    string: 'El campo :attribute debe contener :size caracteres.'
		  },
		  url: 'El formato de :attribute es invlido.'
		};
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Le champs :attribute doit tre accept.',
		  alpha: 'Le champs :attribute ne peut contenir que des caractres alphabtiques.',
		  alpha_dash: 'Le champs :attribute ne peut contenir que des caractres alphanumriques, des tirets et underscores.',
		  alpha_num: 'Le champs :attribute doit tre alphanumrique.',
		  between: 'Le champs :attribute doit tre compris entre :min and :max.',
		  confirmed: 'Le champs :attribute ne correspond pas.',
		  email: 'Le champs :attribute contient un format invalide.',
		  def: 'Le champs :attribute contient un attribut erron.',
		  digits: 'Le champs :attribute doit tre de :digits chiffres.',
		  different: 'Le champs :attribute et :different doivent tre differents.',
		  'in': 'Le champs :attribute est invalide.',
		  integer: 'Le champs :attribute doit tre un entier.',
		  min: {
		    numeric: 'Le champs :attribute doit tre contenir au moins :min.',
		    string: 'Le champs :attribute doit tre contenir au moins :min caractres.'
		  },
		  max: {
		    numeric: 'Le champs :attribute ne doit tre suprieur  :max.',
		    string: 'Le champs :attribute ne doit tre plus de :max characters.'
		  },
		  not_in: 'Le champs :attribute est invalide.',
		  numeric: 'Le champs :attribute doit tre un numro.',
		  required: 'Le champs :attribute est obligatoire.',
		  required_if: 'Le champs :attribute est obligatoire quand :other est :value.',
		  same: 'Le champs :attribute et :same doivent correspondre.',
		  size: {
		    numeric: 'La taille du champs :attribute doit tre :size.',
		    string: 'La taille du champs :attribute doit tre de :size caractres.'
		  },
		  url: 'Le format du champs :attribute est invalide.',
		  regex: 'Le format du champs :attribute est invalide.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 102 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: 'Il campo :attribute deve essere accettato.',
		  alpha: 'Il campo :attribute deve contenere sono caratteri alfabetici.',
		  alpha_dash: 'Il campo :attribute pu contenere solo caratteri alfanumerici oltre a trattini e trattini bassi.',
		  alpha_num: 'Il campo :attribute deve essere alfanumerico.',
		  between: 'Il campo :attribute deve essere compreso tra :min e :max.',
		  confirmed: 'Il campo conferma :attribute non  uguale.',
		  email: 'Il formato dell\'attributo :attribute non  valido.',
		  def: 'Gli attributi del campo :attribute contengono degli errori.',
		  digits: 'Il campo :attribute deve essere di :digits cifre.',
		  different: 'Il campo :attribute e :different devo essere diversi.',
		  'in': 'Il valore del campo :attribute non  valido.',
		  integer: 'Il campo :attribute deve essere un valore intero.',
		  min: {
		    numeric: 'Il campo :attribute deve essere maggiore o uguale di :min.',
		    string: 'Il campo :attribute deve essere composto da almeno :min caratteri.'
		  },
		  max: {
		    numeric: 'Il campo :attribute deve essere minore o uguale di :max.',
		    string: 'Il campo :attribute deve essere composto da massimo :max caratteri.'
		  },
		  not_in: 'Il campo :attribute non  valido.',
		  numeric: 'Il campo :attribute deve essere un numero.',
		  required: 'Il campo :attribute  richiesto.',
		  required_if: 'Il campo :attribute  richiesto quando il campo :other  uguale a :value.',
		  same: 'I campi :attribute e :same devono essere uguali.',
		  size: {
		    numeric: 'La dimensione del campo :attribute deve essere uguale a :size.',
		    string: 'Il campo :attribute deve essere di :size caratteri.'
		  },
		  string: 'Il campo :attribute deve essere una stringa.',
		  url: 'Il formato del campo :attribute non  valido.',
		  regex: 'Il formato del campo :attribute non  valido.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 103 */
	/***/ function(module, exports) {
	
		module.exports = {
		    accepted: ':attribute',
		    alpha: ':attribute',
		    alpha_dash: ':attribute',
		    alpha_num: ':attribute',
		    between: ':attribute:min:max',
		    confirmed: ':attribute',
		    email: ':attribute',
		    def: ':attribute',
		    digits: ':attribute:digits',
		    different: ':attribute:different',
		    'in': ':attribute',
		    integer: ':attribute',
		    min        : {
		        numeric : ":attribute:min",
		        string  : ":attribute:min"
		    },
		    max : {
		        numeric : ":attribute:max",
		        string  : ":attribute:max"
		    },
		    not_in      : ":attribute",
		    numeric     : ":attribute",
		    required    : ":attribute",
		    required_if : ":other:value:attribute",
		    same        : ":attribute:same",
		    size        : {
		        numeric : ":attribute:size",
		        string  : ":attribute:size"
		    },
		    url        : ":attributeURI",
		    regex      : ":attribute \":value\" ",
		    attributes : {}
		};
	
	
	/***/ },
	/* 104 */
	/***/ function(module, exports) {
	
		module.exports = {
		    accepted: 'Pole :attribute musi by zaakceptowane.',
		    alpha: 'Pole :attribute moe zawiera tylko litery.',
		    alpha_dash: 'Pole :attribute moze zawiera tylko litery, mylnik i podrkelenie.',
		    alpha_num: 'Pole :attribute moze zawierac tylko znaki alfanumeryczne.',
		    between: 'Pole :attribute musi mie dugo od :min do :max.',
		    confirmed: 'Pole :attribute nie spenia warunku potwierdzenia.',
		    email: 'Pole :attribute ma niepoprawny format adresu email.',
		    def: 'Pole :attribute zawiera bdy.',
		    digits: 'Pole :attribute moe zawiera tylko cyfry ze zbioru :digits.',
		    different: 'Pola :attribute i :different musz si rni.',
		    'in': 'Pole :attribute musi nalee do zbioru :in.',
		    integer: 'Pole :attribute musi by liczb cakowit.',
		    min: {
		        numeric: 'Pole :attribute musi by rwne conajmniej :min.',
		        string: 'Pole :attribute musi zawiera conajmniej :min znakw.'
		    },
		    max: {
		        numeric: 'Pole :attribute nie moze by wiksze :max.',
		        string: 'Pole :attribute nie moze by dusze ni :max znakw.'
		    },
		    not_in: 'Pole :attribute nie moe nalee do zbioru :not_in.',
		    numeric: 'Pole :attribute musi by liczb.',
		    required: 'Pole :attribute jest wymagane.',
		    required_if: 'Pole :attribute jest wymagane jeli pole :other jest rwne :value.',
		    same: 'Pola :attribute i :same musz by takie same.',
		    size: {
		        numeric: 'Pole :attribute musi by rwne :size.',
		        string: 'Pole :attribute musi zawiera :size znakw.'
		    },
		    string: 'Pole :attribute musi by cigiem znakw.',
		    url: 'Pole :attribute musi by poprawnym adresem URL.',
		    regex: 'Pole :attribute nie spenia warunku.',
		    attributes: {}
		};
	
	
	/***/ },
	/* 105 */
	/***/ function(module, exports) {
	
		module.exports = {
		  accepted: '   :attribute.',
		  alpha: ' :attribute    .',
		  alpha_dash: ' :attribute    , ,    .',
		  alpha_num: ' :attribute      .',
		  between: ' :attribute    :min  :max.',
		  confirmed: ' :attribute    .',
		  email: ' :attribute     .',
		  def: ' :attribute  .',
		  digits: '   :attribute   :digits.',
		  different: ' :attribute  :different  .',
		  'in': '   :attribute .',
		  integer: ' :attribute    .',
		  min: {
		    numeric: '  :attribute      :min.',
		    string: '    :attribute     :min.'
		  },
		  max: {
		    numeric: '  :attribute      :max.',
		    string: '    :attribute    :max.'
		  },
		  not_in: '   :attribute .',
		  numeric: ' :attribute   .',
		  required: ' :attribute   .',
		  required_if: ' :attribute     :other  :value.',
		  same: ' :attribute    :same.',
		  size: {
		    numeric: '  :attribute    :size.',
		    string: '    :attribute    :size.'
		  },
		  url: ' :attribute    URL.',
		  regex: '   :attribute.',
		  attributes: {}
		};
	
	
	/***/ },
	/* 106 */
	/***/ function(module, exports) {
	
		var Errors = function() {
		  this.errors = {};
		};
		
		Errors.prototype = {
		  constructor: Errors,
		
		  /**
		   * Add new error message for given attribute
		   *
		   * @param  {string} attribute
		   * @param  {string} message
		   * @return {void}
		   */
		  add: function(attribute, message) {
		    if (!this.has(attribute)) {
		      this.errors[attribute] = [];
		    }
		
		    if (this.errors[attribute].indexOf(message) === -1) {
		      this.errors[attribute].push(message);
		    }
		  },
		
		  /**
		   * Returns an array of error messages for an attribute, or an empty array
		   *
		   * @param  {string} attribute A key in the data object being validated
		   * @return {array} An array of error messages
		   */
		  get: function(attribute) {
		    if (this.has(attribute)) {
		      return this.errors[attribute];
		    }
		
		    return [];
		  },
		
		  /**
		   * Returns the first error message for an attribute, false otherwise
		   *
		   * @param  {string} attribute A key in the data object being validated
		   * @return {string|false} First error message or false
		   */
		  first: function(attribute) {
		    if (this.has(attribute)) {
		      return this.errors[attribute][0];
		    }
		
		    return false;
		  },
		
		  /**
		   * Get all error messages from all failing attributes
		   *
		   * @return {Object} Failed attribute names for keys and an array of messages for values
		   */
		  all: function() {
		    return this.errors;
		  },
		
		  /**
		   * Determine if there are any error messages for an attribute
		   *
		   * @param  {string}  attribute A key in the data object being validated
		   * @return {boolean}
		   */
		  has: function(attribute) {
		    if (this.errors.hasOwnProperty(attribute)) {
		      return true;
		    }
		
		    return false;
		  }
		};
		
		module.exports = Errors;
	
	
	/***/ },
	/* 107 */
	/***/ function(module, exports) {
	
		function AsyncResolvers(onFailedOne, onResolvedAll) {
		  this.onResolvedAll = onResolvedAll;
		  this.onFailedOne = onFailedOne;
		  this.resolvers = {};
		  this.resolversCount = 0;
		  this.passed = [];
		  this.failed = [];
		  this.firing = false;
		}
		
		AsyncResolvers.prototype = {
		
		  /**
		   * Add resolver
		   *
		   * @param {Rule} rule
		   * @return {integer}
		   */
		  add: function(rule) {
		    var index = this.resolversCount;
		    this.resolvers[index] = rule;
		    this.resolversCount++;
		    return index;
		  },
		
		  /**
		   * Resolve given index
		   *
		   * @param  {integer} index
		   * @return {void}
		   */
		  resolve: function(index) {
		    var rule = this.resolvers[index];
		    if (rule.passes === true) {
		      this.passed.push(rule);
		    } else if (rule.passes === false) {
		      this.failed.push(rule);
		      this.onFailedOne(rule);
		    }
		
		    this.fire();
		  },
		
		  /**
		   * Determine if all have been resolved
		   *
		   * @return {boolean}
		   */
		  isAllResolved: function() {
		    return (this.passed.length + this.failed.length) === this.resolversCount;
		  },
		
		  /**
		   * Attempt to fire final all resolved callback if completed
		   *
		   * @return {void}
		   */
		  fire: function() {
		
		    if (!this.firing) {
		      return;
		    }
		
		    if (this.isAllResolved()) {
		      this.onResolvedAll(this.failed.length === 0);
		    }
		
		  },
		
		  /**
		   * Enable firing
		   *
		   * @return {void}
		   */
		  enableFiring: function() {
		    this.firing = true;
		  }
		
		};
		
		module.exports = AsyncResolvers;
	
	
	/***/ },
	/* 108 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-autocomplete\" v-el:autocomplete\n    :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'icon-right': iconRight\n    }\"\n>\n    <div class=\"ui-autocomplete-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-autocomplete-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-autocomplete-content\">\n        <label class=\"ui-autocomplete-label\">\n            <div class=\"ui-autocomplete-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <ui-icon\n                class=\"ui-autocomplete-clear-button\" icon=\"&#xE5CD\" title=\"Clear\"\n                @click=\"clearSearch\" v-show=\"!disabled && value.length\"\n            ></ui-icon>\n\n            <input\n                class=\"ui-autocomplete-input\" :placeholder=\"placeholder\" :name=\"name\"\n                :id=\"id\" autocomplete=\"off\" v-autofocus=\"autofocus\" :debounce=\"debounce\"\n\n                @focus=\"focus\" @blur=\"blur\" @keydown.up.prevent=\"highlight(highlightedItem - 1)\"\n                @keydown.down.prevent=\"highlight(highlightedItem + 1)\" @keydown.tab=\"close\"\n                @keydown.enter=\"selectHighlighted(highlightedItem, $event)\"\n\n                v-model=\"value\" v-disabled=\"disabled\" v-el:input\n            >\n\n            <ul class=\"ui-autocomplete-suggestions\" v-show=\"showDropdown\">\n                <ui-autocomplete-suggestion\n                    :highlighted=\"highlightedItem === index\" :item=\"item\" :partial=\"partial\"\n                    :keys=\"keys\"\n\n                    v-for=\"(index, item) in suggestions | filterBy search | limitBy limit\"\n                    v-ref:items @click=\"select(item)\"\n                ></ui-autocomplete-suggestion>\n            </ul>\n        </label>\n\n        <div class=\"ui-autocomplete-feedback\" v-if=\"showFeedback\">\n            <div\n                class=\"ui-autocomplete-error-text\" v-text=\"validationError\"\n                transition=\"ui-autocomplete-feedback-toggle\"\n                v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-autocomplete-help-text\" transition=\"ui-autocomplete-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(110)
		__vue_script__ = __webpack_require__(111)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiButton.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(112)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiButton.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 110 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 111 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiMenu = __webpack_require__(13);
		
		var _UiMenu2 = _interopRequireDefault(_UiMenu);
		
		var _UiPopover = __webpack_require__(63);
		
		var _UiPopover2 = _interopRequireDefault(_UiPopover);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _HasDropdown = __webpack_require__(72);
		
		var _HasDropdown2 = _interopRequireDefault(_HasDropdown);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-button',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-button-' + type;
		            }
		        },
		        buttonType: {
		            type: String,
		            default: 'submit' },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        raised: {
		            type: Boolean,
		            default: false
		        },
		        text: String,
		        icon: String,
		        iconRight: {
		            type: Boolean,
		            default: false
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        showDropdownIcon: {
		            type: Boolean,
		            default: true
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.color];
		
		            if (this.raised) {
		                classes.push('ui-button-raised');
		            }
		
		            if (this.hasDropdownMenu || this.hasPopover) {
		                classes.push('has-dropdown');
		            }
		
		            return classes;
		        },
		        spinnerColor: function spinnerColor() {
		            if (this.color === 'color-default' || this.type === 'ui-button-flat') {
		                return 'black';
		            }
		
		            return 'white';
		        },
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiMenu: _UiMenu2.default,
		        UiPopover: _UiPopover2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasDropdown2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 112 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-button\" :class=\"styleClasses\" :type=\"buttonType\" v-disabled=\"disabled || loading\"\n    v-el:button\n>\n    <div class=\"ui-button-content\" :class=\"{ 'invisible': loading }\">\n        <ui-icon\n            class=\"ui-button-icon\" :class=\"{ 'position-right': iconRight }\" :icon=\"icon\"\n            v-if=\"showIcon\"\n        ></ui-icon>\n\n        <div class=\"ui-button-text\">\n            <slot>\n                <span v-text=\"text\"></span>\n            </slot>\n        </div>\n\n        <ui-icon\n            class=\"ui-button-dropdown-icon\" icon=\"&#xE5C5;\"\n            v-if=\"!iconRight && showDropdownIcon && (hasDropdownMenu || hasPopover)\"\n        ></ui-icon>\n    </div>\n\n    <ui-progress-circular\n        class=\"ui-button-spinner\" :color=\"spinnerColor\" :size=\"18\" :stroke=\"4.5\"\n        disable-transition v-show=\"loading\"\n    ></ui-progress-circular>\n\n    <ui-ripple-ink v-if=\"!hideRippleInk && !disabled\" :trigger=\"$els.button\"></ui-ripple-ink>\n\n    <ui-menu\n        class=\"ui-button-dropdown-menu\" :trigger=\"$els.button\" :options=\"menuOptions\"\n        :show-icons=\"showMenuIcons\" :show-secondary-text=\"showMenuSecondaryText\"\n        :open-on=\"openDropdownOn\" @option-selected=\"menuOptionSelect\"\n        :dropdown-position=\"dropdownPosition\" v-if=\"hasDropdownMenu\"\n    ></ui-menu>\n\n    <ui-popover\n        :trigger=\"$els.button\" :open-on=\"openDropdownOn\" :dropdown-position=\"dropdownPosition\"\n        v-if=\"hasPopover\"\n    >\n        <slot name=\"popover\"></slot>\n    </ui-popover>\n</button>\n";
	
	/***/ },
	/* 113 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(114)
		__vue_script__ = __webpack_require__(115)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiCheckbox.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(116)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiCheckbox.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 114 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-checkbox',
		
		    props: {
		        name: String,
		        model: {
		            type: [Array, String, Boolean],
		            required: true,
		            twoWay: true
		        },
		        value: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: false
		        };
		    },
		
		
		    computed: {
		        isChecked: function isChecked() {
		            if (this.value) {
		                return this.model.indexOf(this.value) > -1;
		            }
		
		            return this.model;
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.model;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.model = this.initialValue;
		        }
		    },
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 116 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-checkbox\"\n    :class=\"{\n        'disabled': disabled, 'checked': isChecked, 'active': active, 'label-left': labelLeft\n    }\"\n>\n    <input\n        class=\"ui-checkbox-input\" type=\"checkbox\" :name=\"name\" @focus=\"focus\" @blur=\"blur\"\n        :value=\"value ? value : null\" v-model=\"model\" v-disabled=\"disabled\"\n    >\n\n    <div class=\"ui-checkbox-checkmark\">\n        <div class=\"ui-checkbox-focus-ring\"></div>\n    </div>\n\n    <div class=\"ui-checkbox-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 117 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(118)
		__vue_script__ = __webpack_require__(119)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiCollapsible.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(120)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiCollapsible.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 118 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-collapsible',
		
		    props: {
		        id: String,
		        open: {
		            type: Boolean,
		            default: false
		        },
		        header: String,
		        transition: {
		            type: String,
		            default: 'ui-collapsible-toggle'
		        },
		        hideIcon: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            height: 0,
		            isReady: false
		        };
		    },
		
		
		    computed: {
		        icon: function icon() {
		            return this.open ? 'keyboard_arrow_up' : 'keyboard_arrow_down';
		        },
		        calculatedHeight: function calculatedHeight() {
		            if (this.height === 0) {
		                return 'initial';
		            }
		
		            return this.height + 'px';
		        }
		    },
		
		    created: function created() {
		        this.id = this.id || _uuid2.default.short('ui-collapsible-');
		    },
		    ready: function ready() {
		        this.isReady = true;
		        this.setHeight();
		    },
		
		
		    events: {
		        'ui-collapsible::refresh-height': function uiCollapsibleRefreshHeight(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.$nextTick(this.setHeight);
		        }
		    },
		
		    methods: {
		        toggleMenu: function toggleMenu() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.open = !this.open;
		        },
		        setHeight: function setHeight() {
		            var body = this.$els.body;
		
		            body.style.display = 'block';
		            this.height = body.scrollHeight;
		
		            if (!this.open) {
		                body.style.display = 'none';
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ShowsRippleInk2.default, _ReceivesTargetedEvent2.default],
		
		    transitions: {
		        'ui-collapsible-toggle': {
		            afterEnter: function afterEnter() {
		                this.$dispatch('opened');
		                this.setHeight();
		            },
		            afterLeave: function afterLeave() {
		                this.$dispatch('closed');
		            }
		        }
		    }
		};
	
	/***/ },
	/* 120 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-collapsible\">\n    <button\n        class=\"ui-collapsible-header\" :class=\"{ 'disabled': disabled }\" :aria-controls=\"id\"\n        :aria-expanded=\"open ? 'true' : 'false'\" @click=\"toggleMenu\" v-disabled=\"disabled\"\n        v-el:button\n    >\n        <div class=\"ui-collapsible-header-content\">\n            <slot name=\"header\">\n                <div v-text=\"header\"></div>\n            </slot>\n        </div>\n\n        <ui-icon class=\"ui-collapsible-header-icon\" :icon=\"icon\" v-if=\"!hideIcon\"></ui-icon>\n\n        <ui-ripple-ink\n            v-if=\"!hideRippleInk && !disabled && isReady\" :trigger=\"$els.button\"\n        ></ui-ripple-ink>\n    </button>\n\n    <div\n        class=\"ui-collapsible-body-wrapper\" :transition=\"transition\"\n        :style=\"{ 'height': calculatedHeight }\" v-show=\"open\"v-el:body\n    >\n        <div class=\"ui-collapsible-body\" :id=\"id\" :aria-hidden=\"open ? null : 'true'\">\n            <slot></slot>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 121 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(122)
		__vue_script__ = __webpack_require__(123)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiConfirm.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(128)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiConfirm.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 122 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _UiModal = __webpack_require__(124);
		
		var _UiModal2 = _interopRequireDefault(_UiModal);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-confirm',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        type: {
		            type: String,
		            default: 'primary' },
		        header: {
		            type: String,
		            default: 'UiConfirm'
		        },
		        confirmButtonText: {
		            type: String,
		            default: 'OK'
		        },
		        confirmButtonIcon: String,
		        denyButtonText: {
		            type: String,
		            default: 'Cancel'
		        },
		        denyButtonIcon: String,
		        autofocus: {
		            type: String,
		            default: 'deny-button' },
		        closeOnConfirm: {
		            type: Boolean,
		            default: false
		        },
		        backdropDismissible: {
		            type: Boolean,
		            default: true
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    methods: {
		        confirm: function confirm() {
		            this.$dispatch('confirmed');
		
		            if (this.closeOnConfirm) {
		                this.show = false;
		            }
		        },
		        deny: function deny() {
		            this.show = false;
		            this.$dispatch('denied');
		        },
		        opened: function opened() {
		            var button = void 0;
		
		            if (this.autofocus === 'confirm-button') {
		                button = this.$els.confirmButton;
		            } else if (this.autofocus === 'deny-button') {
		                button = this.$els.denyButton;
		            }
		
		            if (button) {
		                _classlist2.default.add(button, 'autofocus');
		                button.addEventListener('blur', this.removeAutoFocus);
		
		                button.focus();
		            }
		
		            return true;
		        },
		        removeAutoFocus: function removeAutoFocus() {
		            var button = void 0;
		
		            if (this.autofocus === 'confirm-button') {
		                button = this.$els.confirmButton;
		            } else if (this.autofocus === 'deny-button') {
		                button = this.$els.denyButton;
		            }
		
		            if (button) {
		                button.removeEventListener('blur', this.removeAutoFocus);
		
		                _classlist2.default.remove(button, 'autofocus');
		            }
		        }
		    },
		
		    components: {
		        UiModal: _UiModal2.default,
		        UiButton: _UiButton2.default
		    }
		};
	
	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(125)
		__vue_script__ = __webpack_require__(126)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiModal.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(127)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiModal.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 125 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 126 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _classlist = __webpack_require__(23);
		
		var _classlist2 = _interopRequireDefault(_classlist);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-modal',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        type: {
		            type: String,
		            default: 'normal', coerce: function coerce(type) {
		                return 'ui-modal-' + type;
		            }
		        },
		        header: {
		            type: String,
		            default: 'UiModal Header'
		        },
		        body: {
		            type: String,
		            default: 'UiModal body'
		        },
		        role: {
		            type: String,
		            default: 'dialog' },
		        transition: {
		            type: String,
		            default: 'ui-modal-scale' },
		        showCloseButton: {
		            type: Boolean,
		            default: true
		        },
		        hideFooter: {
		            type: Boolean,
		            default: false
		        },
		        dismissible: {
		            type: Boolean,
		            default: true
		        },
		        backdropDismissible: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    data: function data() {
		        return {
		            lastFocussedElement: null
		        };
		    },
		
		
		    watch: {
		        show: function show() {
		            var _this = this;
		
		            this.$nextTick(function () {
		                if (_this.show) {
		                    _this.opened();
		                } else {
		                    _this.closed();
		                }
		            });
		        }
		    },
		
		    beforeDestroy: function beforeDestroy() {
		        if (this.show) {
		            this.tearDown();
		        }
		    },
		
		
		    methods: {
		        close: function close(e) {
		            if (!this.dismissible) {
		                return;
		            }
		
		            if (e.currentTarget === this.$els.modalMask && e.target !== e.currentTarget) {
		                return;
		            }
		
		            if (e.currentTarget === this.$els.modalMask && !this.backdropDismissible) {
		                return;
		            }
		
		            this.show = false;
		        },
		        opened: function opened() {
		            this.lastFocussedElement = document.activeElement;
		            this.$els.modalContainer.focus();
		
		            _classlist2.default.add(document.body, 'ui-modal-open');
		
		            document.addEventListener('focus', this.restrictFocus, true);
		
		            this.$dispatch('opened');
		        },
		        closed: function closed() {
		            this.tearDown();
		            this.$dispatch('closed');
		        },
		        redirectFocus: function redirectFocus(e) {
		            e.stopPropagation();
		
		            this.$els.modalContainer.focus();
		        },
		        restrictFocus: function restrictFocus(e) {
		            if (!this.$els.modalContainer.contains(e.target)) {
		                e.stopPropagation();
		                this.$els.modalContainer.focus();
		            }
		        },
		        tearDown: function tearDown() {
		            _classlist2.default.remove(document.body, 'ui-modal-open');
		
		            document.removeEventListener('focus', this.restrictFocus, true);
		
		            if (this.lastFocussedElement) {
		                this.lastFocussedElement.focus();
		            }
		        },
		        transitionEnd: function transitionEnd() {
		            if (this.show) {
		                this.$dispatch('revealed');
		            } else {
		                this.$dispatch('hidden');
		            }
		        }
		    },
		
		    components: {
		        UiIconButton: _UiIconButton2.default,
		        UiButton: _UiButton2.default
		    }
		};
	
	/***/ },
	/* 127 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-modal ui-modal-mask\" v-show=\"show\" :transition=\"transition\" :class=\"[type]\"\n    :role=\"role\" @transitionend=\"transitionEnd | debounce 100\"\n>\n    <div class=\"ui-modal-wrapper\" @click=\"close\" v-el:modal-mask>\n        <div\n            class=\"ui-modal-container\" tabindex=\"-1\" @keydown.esc=\"close\"\n            v-el:modal-container\n        >\n            <div class=\"ui-modal-header\">\n                <slot name=\"header\">\n                    <h1 v-text=\"header\" class=\"ui-modal-header-text\"></h1>\n                </slot>\n\n                <ui-icon-button\n                    type=\"clear\" icon=\"&#xE5CD\" class=\"ui-modal-close-button\" @click=\"close\"\n                    :disabled=\"!dismissible\" v-if=\"showCloseButton\" v-el:close-button\n                ></ui-icon-button>\n            </div>\n\n            <div class=\"ui-modal-body\">\n                <slot>\n                    <div v-text=\"body\"></div>\n                </slot>\n            </div>\n\n            <div class=\"ui-modal-footer\" v-if=\"!hideFooter\">\n                <slot name=\"footer\">\n                    <ui-button @click=\"close\" v-if=\"dismissible\">Close</ui-button>\n                </slot>\n            </div>\n\n            <div class=\"focus-redirector\" @focus=\"redirectFocus\" tabindex=\"0\"></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 128 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-confirm\">\n    <ui-modal\n        :show.sync=\"show\" role=\"alertdialog\" :header=\"header\" @opened=\"opened\" show-close-button\n        :dismissible=\"!loading\" :backdrop-dismissible=\"backdropDismissible\"\n    >\n        <div class=\"ui-confirm-message\">\n            <slot></slot>\n        </div>\n\n        <div slot=\"footer\">\n            <ui-button\n                :color=\"type\" :text=\"confirmButtonText\" :icon=\"confirmButtonIcon\"\n                @click=\"confirm\" :loading=\"loading\" v-el:confirm-button\n            ></ui-button>\n\n            <ui-button\n                :text=\"denyButtonText\" :icon=\"denyButtonIcon\" @click=\"deny\"\n                :disabled=\"loading\" v-el:deny-button\n            ></ui-button>\n        </div>\n    </ui-modal>\n</div>\n";
	
	/***/ },
	/* 129 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(130)
		__vue_script__ = __webpack_require__(131)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiFab.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(132)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiFab.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 130 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 131 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsTooltip = __webpack_require__(73);
		
		var _ShowsTooltip2 = _interopRequireDefault(_ShowsTooltip);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-fab',
		
		    props: {
		        type: {
		            type: String,
		            default: 'normal',
		            coerce: function coerce(type) {
		                return 'ui-fab-' + type;
		            }
		        },
		        color: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        icon: {
		            type: String,
		            required: true
		        },
		        ariaLabel: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ShowsTooltip2.default, _ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 132 */
	/***/ function(module, exports) {
	
		module.exports = "\n<button\n    class=\"ui-fab\" :class=\"[this.type, this.color]\" :aria-label=\"ariaLabel || tooltip\"\n    v-disabled=\"disabled\" v-el:button\n>\n    <ui-icon class=\"ui-fab-icon\" :icon=\"icon\"></ui-icon>\n\n    <ui-ripple-ink :trigger=\"$els.button\" v-if=\"!hideRippleInk && !disabled\"></ui-ripple-ink>\n\n    <ui-tooltip\n        :trigger=\"$els.button\" :content=\"tooltip\" :position=\"tooltipPosition\" v-if=\"tooltip\"\n        :open-on=\"openTooltipOn\"\n    ></ui-tooltip>\n</button>\n";
	
	/***/ },
	/* 133 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(134)
		__vue_script__ = __webpack_require__(135)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiPreloader.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(136)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiPreloader.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 134 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 135 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-preloader',
		
		    props: {
		        show: {
		            type: Boolean,
		            required: true
		        }
		    }
		};
	
	/***/ },
	/* 136 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-preloader\">\n    <div\n        class=\"ui-preloader-progressbar\" :class=\"{ 'loading' : show }\"\n        :aria-busy=\"show ? 'true' : false\" role=\"progressbar\"\n    ></div>\n</div>\n";
	
	/***/ },
	/* 137 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(138)
		__vue_script__ = __webpack_require__(139)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiProgressLinear.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(140)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiProgressLinear.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 138 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 139 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-progress-linear',
		
		    props: {
		        show: {
		            type: Boolean,
		            default: false
		        },
		        type: {
		            type: String,
		            default: 'indeterminate' },
		        color: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        value: {
		            type: Number,
		            coerce: Number,
		            default: 0
		        }
		    },
		
		    computed: {
		        progress: function progress() {
		            if (this.value < 0) {
		                return 0;
		            }
		
		            if (this.value > 100) {
		                return 100;
		            }
		
		            return this.value;
		        }
		    }
		};
	
	/***/ },
	/* 140 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-progress-linear\" :class=\"[color]\" v-show=\"show\"\n    transition=\"ui-progress-linear-toggle\"\n>\n    <div\n        class=\"ui-progress-linear-determinate\" :style=\"{ 'width': progress + '%' }\"\n        role=\"progressbar\" :aria-valuemin=\"0\" :aria-valuemax=\"100\" :aria-valuenow=\"value\"\n        v-if=\"type === 'determinate'\"\n    ></div>\n\n    <div\n        class=\"ui-progress-linear-indeterminate\" role=\"progressbar\" :aria-valuemin=\"0\"\n        :aria-valuemax=\"100\" v-else\n    ></div>\n</div>\n";
	
	/***/ },
	/* 141 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(142)
		__vue_script__ = __webpack_require__(143)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRadio.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(144)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRadio.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 142 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 143 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-radio',
		
		    props: {
		        id: String,
		        name: String,
		        model: {
		            type: String,
		            default: '',
		            twoWay: true
		        },
		        checked: {
		            type: Boolean,
		            default: false
		        },
		        value: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false
		        };
		    },
		
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		
		            this.$dispatch('focussed');
		        },
		        blur: function blur() {
		            this.active = false;
		
		            this.$dispatch('blurred');
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 144 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-radio\"\n    :class=\"{ 'disabled': disabled, 'checked': active, 'label-left': labelLeft }\"\n>\n    <div class=\"ui-radio-input-wrapper\">\n        <input\n            class=\"ui-radio-input\" type=\"radio\" :id=\"id\" :name=\"name\" :value=\"value\"\n            :checked=\"checked\" @focus=\"focus\" @blur=\"blur\" v-model=\"model\" v-disabled=\"disabled\"\n        >\n\n        <span class=\"ui-radio-border\"></span>\n        <span class=\"ui-radio-inner-dot\"></span>\n    </div>\n\n    <div class=\"ui-radio-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 145 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(146)
		__vue_script__ = __webpack_require__(147)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRadioGroup.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(148)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRadioGroup.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 146 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 147 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _UiRadio = __webpack_require__(141);
		
		var _UiRadio2 = _interopRequireDefault(_UiRadio);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-radio-group',
		
		    props: {
		        name: {
		            type: String,
		            required: true
		        },
		        value: {
		            type: String,
		            default: '',
		            twoWay: true
		        },
		        options: {
		            type: Array,
		            required: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        vertical: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: ''
		        };
		    },
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            return Boolean(this.helpText);
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        }
		    },
		
		    components: {
		        UiRadio: _UiRadio2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 148 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-radio-group\" :id=\"id\"\n    :class=\"{ 'disabled': disabled, 'active': active, 'vertical': vertical }\"\n>\n    <div class=\"ui-radio-group-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n    <div class=\"ui-radio-group-options-wrapper\">\n        <ui-radio\n            class=\"ui-radio-group-radio\" v-for=\"option in options\" :model.sync=\"value\"\n            :name=\"name\" :label=\"option.text || option\" :value=\"option.value || option\"\n            :disabled=\"disabled || option.disabled\" @focussed=\"focus\" @blurred=\"blur\"\n        ></ui-radio>\n    </div>\n\n    <div\n        class=\"ui-radio-group-feedback\" v-if=\"showFeedback\"\n        transition=\"ui-radio-group-feedback-toggle\"\n    >\n        <div class=\"ui-radio-group-help-text\" v-text=\"helpText\"></div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 149 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(150)
		__vue_script__ = __webpack_require__(151)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRating.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(156)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRating.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 150 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 151 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        value: {
		            type: Number,
		            coerce: Number,
		            required: true,
		            twoWay: true
		        },
		        total: {
		            type: Number,
		            coerce: Number,
		            required: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        helpText: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: 0,
		            previewValue: 0,
		            previewing: false
		        };
		    },
		
		
		    computed: {
		        showFeedback: function showFeedback() {
		            return Boolean(this.helpText);
		        }
		    },
		
		    watch: {
		        value: function value() {
		            this.previewValue = this.value;
		        },
		        previewValue: function previewValue() {
		            this.$dispatch('preview-value-changed', this.previewValue);
		        }
		    },
		
		    created: function created() {
		        this.initialValue = this.value;
		
		        this.previewValue = this.value;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    methods: {
		        startPreview: function startPreview() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewing = true;
		        },
		        endPreview: function endPreview() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewing = false;
		            this.previewValue = this.value;
		        },
		        preview: function preview(n) {
		            if (this.disabled) {
		                return;
		            }
		
		            this.previewValue = n + 1;
		        },
		        commitValue: function commitValue(value) {
		            if (this.disabled) {
		                return;
		            }
		
		            if (value > 0 && value <= this.total) {
		                this.value = value;
		            }
		        },
		        incrementPreviewValue: function incrementPreviewValue() {
		            if (this.disabled) {
		                return;
		            }
		
		            var proposedValue = this.previewValue + 1;
		
		            if (proposedValue <= this.total) {
		                this.previewValue = proposedValue;
		            }
		        },
		        decrementPreviewValue: function decrementPreviewValue() {
		            if (this.disabled) {
		                return;
		            }
		
		            var proposedValue = this.previewValue - 1;
		
		            if (proposedValue > 0) {
		                this.previewValue = proposedValue;
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		            this.startPreview();
		        },
		        blur: function blur() {
		            this.active = false;
		
		            this.commitValue(this.previewValue);
		            this.endPreview();
		        }
		    },
		
		    components: {
		        UiRatingIcon: _UiRatingIcon2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 152 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(153)
		__vue_script__ = __webpack_require__(154)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRatingIcon.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(155)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRatingIcon.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 153 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 154 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating-icon',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        selected: {
		            type: Boolean,
		            required: true
		        },
		        filled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        icon: function icon() {
		            if (this.filled || this.selected) {
		                return this.type === 'star' ? 'star' : 'favorite';
		            }
		
		            return this.type === 'star' ? 'star_border' : 'favorite_border';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    }
		};
	
	/***/ },
	/* 155 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-rating-icon\">\n    <ui-icon\n        class=\"ui-rating-icon-icon\" :icon=\"icon\"\n        :class=\"{ 'selected': selected, 'filled' : filled }\"\n    ></ui-icon>\n</div>\n";
	
	/***/ },
	/* 156 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-rating\" :class=\"{ 'disabled': disabled, 'preview': previewing, 'active': active }\"\n\n    :tabindex=\"disabled ? null : 0\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"total\"\n    :aria-valuenow=\"previewValue\"\n\n    @keydown.up.prevent=\"incrementPreviewValue\" @keydown.down.prevent=\"decrementPreviewValue\"\n    @keydown.right.prevent=\"incrementPreviewValue\" @keydown.left.prevent=\"decrementPreviewValue\"\n    @keydown.enter.prevent=\"commitValue(previewValue)\" @focus=\"focus\" @blur=\"blur\"\n>\n    <div class=\"ui-rating-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n    <div\n        class=\"ui-rating-icons-wrapper\" @mouseenter=\"startPreview\" @mouseleave=\"endPreview\"\n    >\n        <ui-rating-icon\n            :type=\"type\" v-for=\"n in total\" :selected=\"(n + 1) <= value\" @mouseover=\"preview(n)\"\n            :filled=\"(n + 1) <= previewValue\" @click=\"commitValue(n + 1)\"\n        ></ui-rating-icon>\n    </div>\n\n    <div\n        class=\"ui-rating-feedback\" v-if=\"showFeedback\" transition=\"ui-rating-feedback-toggle\"\n    >\n        <div class=\"ui-rating-help-text\" v-text=\"helpText\"></div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 157 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(158)
		__vue_script__ = __webpack_require__(159)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiRatingPreview.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(160)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiRatingPreview.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 158 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 159 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiRatingIcon = __webpack_require__(152);
		
		var _UiRatingIcon2 = _interopRequireDefault(_UiRatingIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-rating-preview',
		
		    props: {
		        type: {
		            type: String,
		            default: 'star' },
		        value: {
		            type: Number,
		            coerce: Number,
		            required: true
		        },
		        total: {
		            type: Number,
		            coerce: Number,
		            required: true
		        }
		    },
		
		    components: {
		        UiRatingIcon: _UiRatingIcon2.default
		    }
		};
	
	/***/ },
	/* 160 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-rating-preview\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"total\"\n    :aria-valuenow=\"value\"\n>\n    <ui-rating-icon\n        :type=\"type\" v-for=\"n in total\" :selected=\"(n + 1) <= value\"\n    ></ui-rating-icon>\n</div>\n";
	
	/***/ },
	/* 161 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(162)
		__vue_script__ = __webpack_require__(163)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSelect.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(171)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSelect.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 162 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 163 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _mergeOptions = __webpack_require__(164);
		
		var _mergeOptions2 = _interopRequireDefault(_mergeOptions);
		
		var _fuzzysearch = __webpack_require__(84);
		
		var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);
		
		var _elementScroll = __webpack_require__(166);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _UiSelectOption = __webpack_require__(167);
		
		var _UiSelectOption2 = _interopRequireDefault(_UiSelectOption);
		
		var _UiProgressCircular = __webpack_require__(67);
		
		var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-select',
		
		    props: {
		        value: {
		            type: [Object, Array, String, Number],
		            default: null,
		            twoWay: true
		        },
		        default: {
		            type: [Object, Array, String, Number],
		            default: null
		        },
		        options: {
		            type: Array,
		            default: []
		        },
		        partial: String,
		        showSearch: {
		            type: Boolean,
		            default: false
		        },
		        searchPlaceholder: {
		            type: String,
		            default: 'Search'
		        },
		        multiple: {
		            type: Boolean,
		            default: false
		        },
		        multipleDelimiter: {
		            type: String,
		            default: ', '
		        },
		        optionsDynamic: {
		            type: Boolean,
		            default: false
		        },
		        optionsLoaded: {
		            type: Boolean,
		            default: true
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        },
		        filter: Function
		    },
		
		    data: function data() {
		        return {
		            query: '',
		            selectedIndex: -1,
		            highlightedIndex: -1,
		            showDropdown: false,
		            ignoreQueryChange: false
		        };
		    },
		
		
		    computed: {
		        filteredOptions: function filteredOptions() {
		            if (this.optionsDynamic) {
		                return this.options;
		            }
		
		            return this.options.filter(this.search);
		        },
		        displayText: function displayText() {
		            var _this = this;
		
		            if (this.multiple && this.value.length) {
		                var labels = this.value.map(function (value) {
		                    return value[_this.keys.text] || value;
		                });
		
		                return labels.join(this.multipleDelimiter);
		            }
		
		            return this.value ? this.value[this.keys.text] || this.value : '';
		        },
		        hasDisplayText: function hasDisplayText() {
		            return this.displayText && Boolean(this.displayText.length);
		        },
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        nothingFound: function nothingFound() {
		            if (this.optionsDynamic && !this.optionsLoaded) {
		                return false;
		            }
		
		            if (this.query.length && !this.loading) {
		                return !Boolean(this.filteredOptions.length);
		            }
		
		            return false;
		        }
		    },
		
		    watch: {
		        filteredOptions: function filteredOptions() {
		            this.highlightedIndex = 0;
		            (0, _elementScroll.resetScroll)(this.$els.optionsList);
		        },
		        showDropdown: function showDropdown() {
		            if (this.showDropdown) {
		                this.opened();
		                this.$dispatch('opened');
		            } else {
		                this.closed();
		                this.$dispatch('closed');
		            }
		        },
		        query: function query() {
		            if (!this.ignoreQueryChange) {
		                this.$dispatch('query-changed', this.query);
		            }
		        }
		    },
		
		    created: function created() {
		        this.initValue();
		
		        var errorMessages = {
		            min: 'You must select at least :min options.',
		            max: 'You must select no more than :max options.',
		            between: 'You must select at least :min but no more than :max options.'
		        };
		
		        if (this.validationRules) {
		            this.validationMessages = (0, _mergeOptions2.default)(errorMessages, this.validationMessages);
		        }
		    },
		    ready: function ready() {
		        document.addEventListener('click', this.closeOnExternalClick);
		    },
		    beforeDestroy: function beforeDestroy() {
		        document.removeEventListener('click', this.closeOnExternalClick);
		    },
		
		
		    events: {
		        'ui-select::set-selected': function uiSelectSetSelected(value, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.default = value;
		            this.initValue();
		        },
		
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.initValue();
		            this.dirty = false;
		            this.valid = true;
		
		            this.clearQuery();
		            this.selectedIndex = -1;
		            this.highlightedIndex = -1;
		        }
		    },
		
		    methods: {
		        initValue: function initValue() {
		            this.value = this.multiple ? [] : null;
		
		            if (this.default) {
		                var defaults = Array.isArray(this.default) ? this.default : [this.default];
		
		                if (defaults.length) {
		                    this.setDefaultValue(defaults);
		                }
		            }
		        },
		        search: function search(option) {
		            if (this.filter) {
		                return this.filter(option, this.query);
		            }
		
		            var query = this.query.toLowerCase();
		            var text = option[this.keys.text] || option;
		
		            if (typeof text === 'string') {
		                text = text.toLowerCase();
		            }
		
		            return (0, _fuzzysearch2.default)(query, text);
		        },
		        clearQuery: function clearQuery() {
		            var _this2 = this;
		
		            this.ignoreQueryChange = true;
		
		            this.$nextTick(function () {
		                _this2.query = '';
		
		                _this2.$nextTick(function () {
		                    _this2.ignoreQueryChange = false;
		                });
		            });
		        },
		        select: function select(option, index) {
		            var close = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
		
		            if (this.multiple) {
		                if (this.isSelected(option)) {
		                    this.deselect(option);
		                } else {
		                    this.value.push(option);
		                }
		            } else {
		                this.value = option;
		                this.selectedIndex = index;
		            }
		
		            this.$dispatch('selected', option);
		
		            this.highlightedIndex = index;
		            this.clearQuery();
		            this.validate();
		
		            if (!this.multiple && close) {
		                this.close();
		            }
		        },
		        deselect: function deselect(option) {
		            this.value.$remove(option);
		        },
		        isSelected: function isSelected(option) {
		            if (this.multiple) {
		                return this.value.indexOf(option) > -1;
		            }
		
		            return this.value === option;
		        },
		        selectHighlighted: function selectHighlighted(index, e) {
		            if (this.$refs.options.length) {
		                e.preventDefault();
		                this.select(this.$refs.options[index].option, index);
		            }
		        },
		        highlight: function highlight(index, preventScroll) {
		            if (this.highlightedIndex === index || this.$refs.options.length === 0) {
		                return;
		            }
		
		            var firstIndex = 0;
		            var lastIndex = this.$refs.options.length - 1;
		
		            if (index < firstIndex) {
		                index = lastIndex;
		            } else if (index > lastIndex) {
		                index = firstIndex;
		            }
		
		            this.highlightedIndex = index;
		
		            if (!preventScroll) {
		                this.scrollOptionIntoView(this.$refs.options[index].$el);
		            }
		        },
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		
		            if (this.showDropdown) {
		                this.close();
		            }
		        },
		        toggle: function toggle() {
		            if (this.showDropdown) {
		                this.close();
		            } else {
		                this.open();
		            }
		        },
		        open: function open() {
		            if (this.disabled) {
		                return;
		            }
		
		            this.showDropdown = true;
		        },
		        opened: function opened() {
		            var _this3 = this;
		
		            this.$nextTick(function () {
		                if (_this3.showSearch) {
		                    _this3.$els.searchInput.focus();
		                } else {
		                    _this3.$els.dropdown.focus();
		                }
		
		                _this3.scrollOptionIntoView(_this3.$els.optionsList.querySelector('.selected'));
		            });
		        },
		        close: function close(deactivate) {
		            this.showDropdown = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            if (deactivate) {
		                this.active = false;
		            } else {
		                this.$els.label.focus();
		            }
		        },
		        closeOnExternalClick: function closeOnExternalClick(e) {
		            if (!this.$el.contains(e.target) && (this.showDropdown || this.active)) {
		                this.close(true);
		            }
		        },
		        closed: function closed() {
		            this.validate();
		
		            if (this.multiple) {
		                this.highlightedIndex = -1;
		            } else {
		                this.highlightedIndex = this.selectedIndex;
		            }
		        },
		        setDefaultValue: function setDefaultValue(defaults) {
		            var optionValue = void 0;
		            var defaultOptionValue = void 0;
		
		            for (var i = 0; i < defaults.length; i++) {
		                defaultOptionValue = defaults[i][this.keys.value] || defaults[i];
		
		                for (var j = 0; j < this.options.length; j++) {
		                    optionValue = this.options[j][this.keys.value] || this.options[j];
		
		                    if (optionValue === defaultOptionValue) {
		                        this.select(this.options[j], j, false);
		                        break;
		                    }
		                }
		            }
		        },
		        scrollOptionIntoView: function scrollOptionIntoView(optionEl) {
		            (0, _elementScroll.scrollIntoView)(optionEl, this.$els.optionsList, 80);
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default,
		        UiSelectOption: _UiSelectOption2.default,
		        UiProgressCircular: _UiProgressCircular2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 164 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var isOptionObject = __webpack_require__(165);
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.propertyIsEnumerable;
		var globalThis = this;
		var defaultMergeOpts = {
			concatArrays: false
		};
		
		function getEnumerableOwnPropertyKeys(value) {
			var keys = [];
		
			for (var key in value) {
				if (hasOwnProperty.call(value, key)) {
					keys.push(key);
				}
			}
		
			if (Object.getOwnPropertySymbols) {
				var symbols = Object.getOwnPropertySymbols(value);
		
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(value, symbols[i])) {
						keys.push(symbols[i]);
					}
				}
			}
		
			return keys;
		}
		
		function clone(value) {
			if (Array.isArray(value)) {
				return cloneArray(value);
			}
		
			if (isOptionObject(value)) {
				return cloneOptionObject(value);
			}
		
			return value;
		}
		
		function cloneArray(array) {
			var result = array.slice(0, 0);
		
			getEnumerableOwnPropertyKeys(array).forEach(function (key) {
				result[key] = clone(array[key]);
			});
		
			return result;
		}
		
		function cloneOptionObject(obj) {
			var result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};
		
			getEnumerableOwnPropertyKeys(obj).forEach(function (key) {
				result[key] = clone(obj[key]);
			});
		
			return result;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 */
		function mergeKeys(merged, source, keys, mergeOpts) {
			keys.forEach(function (key) {
				if (key in merged) {
					merged[key] = merge(merged[key], source[key], mergeOpts);
				} else {
					merged[key] = clone(source[key]);
				}
			});
		
			return merged;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 *
		 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
		 */
		function concatArrays(merged, source, mergeOpts) {
			var result = merged.slice(0, 0);
			var resultIndex = 0;
		
			[merged, source].forEach(function (array) {
				var indices = [];
		
				// result.concat(array) with cloning
				for (var k = 0; k < array.length; k++) {
					if (!hasOwnProperty.call(array, k)) {
						continue;
					}
		
					indices.push(String(k));
		
					if (array === merged) {
						// already cloned
						result[resultIndex++] = array[k];
					} else {
						result[resultIndex++] = clone(array[k]);
					}
				}
		
				// merge non-index keys
				result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(function (key) {
					return indices.indexOf(key) === -1;
				}), mergeOpts);
			});
		
			return result;
		}
		
		/**
		 * @param merged {already cloned}
		 * @return {cloned Object}
		 */
		function merge(merged, source, mergeOpts) {
			if (mergeOpts.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
				return concatArrays(merged, source, mergeOpts);
			}
		
			if (!isOptionObject(source) || !isOptionObject(merged)) {
				return clone(source);
			}
		
			return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), mergeOpts);
		}
		
		module.exports = function () {
			var mergeOpts = merge(clone(defaultMergeOpts), (this !== globalThis && this) || {}, defaultMergeOpts);
			var merged = {};
		
			for (var i = 0; i < arguments.length; i++) {
				var option = arguments[i];
		
				if (option === undefined) {
					continue;
				}
		
				if (!isOptionObject(option)) {
					throw new TypeError('`' + option + '` is not an Option Object');
				}
		
				merged = merge(merged, option, mergeOpts);
			}
		
			return merged;
		};
	
	
	/***/ },
	/* 165 */
	/***/ function(module, exports) {
	
		'use strict';
		var toString = Object.prototype.toString;
		
		module.exports = function (x) {
			var prototype;
			return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
		};
	
	
	/***/ },
	/* 166 */
	/***/ function(module, exports) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.inView = inView;
		exports.scrollIntoView = scrollIntoView;
		exports.resetScroll = resetScroll;
		function inView(element, container) {
		    if (!element) {
		        return;
		    }
		
		    container = container || element.parentElement;
		
		    var top = element.offsetTop;
		    var parentTop = container.scrollTop;
		    var bottom = top + element.offsetHeight;
		    var parentBottom = container.offsetHeight;
		
		    return top >= parentTop && bottom <= parentBottom;
		}
		
		function scrollIntoView(element, container) {
		    var marginTop = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
		
		    if (!element || inView(element, container)) {
		        return;
		    }
		
		    container = container || element.parentElement;
		
		    container.scrollTop = element.offsetTop - marginTop;
		}
		
		function resetScroll(element) {
		    if (!element) {
		        return;
		    }
		
		    element.scrollTop = 0;
		}
		
		exports.default = {
		    inView: inView,
		    scrollIntoView: scrollIntoView,
		    resetScroll: resetScroll
		};
	
	/***/ },
	/* 167 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(168)
		__vue_script__ = __webpack_require__(169)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSelectOption.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(170)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSelectOption.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 168 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 169 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-select-option',
		
		    props: {
		        option: {
		            type: [String, Object],
		            required: true
		        },
		        partial: {
		            type: String,
		            default: 'ui-select-simple' },
		        showCheckbox: {
		            type: Boolean,
		            default: false
		        },
		        highlighted: {
		            type: Boolean,
		            default: false
		        },
		        selected: {
		            type: Boolean,
		            default: false
		        },
		        keys: {
		            type: Object,
		            default: function _default() {
		                return {
		                    text: 'text',
		                    value: 'value',
		                    image: 'image'
		                };
		            }
		        }
		    },
		
		    computed: {
		        icon: function icon() {
		            return this.selected ? 'check_box' : 'check_box_outline_blank';
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    partials: {
		        'ui-select-simple': '\n            <li class="ui-select-item-text" v-text="option[keys.text] || option"></li>\n        ',
		
		        'ui-select-image': '\n            <div\n                class="ui-select-item-image"\n                :style="{ \'background-image\': \'url(\' + option[keys.image] + \')\' }"\n            ></div>\n\n            <div class="ui-select-item-text" v-text="option[keys.text]"></div>\n        '
		    }
		};
	
	/***/ },
	/* 170 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-select-option\" :class=\"{ highlighted: highlighted, selected: selected }\"\n>\n    <div class=\"ui-select-option-content\" :class=\"[partial]\">\n        <partial :name=\"partial\"></partial>\n    </div>\n\n    <ui-icon\n        class=\"ui-select-option-checkbox\" :icon=\"icon\" v-if=\"showCheckbox\"\n    ></ui-icon>\n</li>\n";
	
	/***/ },
	/* 171 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-select\" :id=\"id\" :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'icon-right': iconRight\n    }\"\n>\n    <div class=\"ui-select-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-select-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-select-content\">\n        <div\n            class=\"ui-select-label\" :tabindex=\"disabled ? null : '0'\" v-el:label\n            @focus=\"focus\" @keydown.tab=\"blur\" @click=\"toggle\" @keydown.space.prevent=\"open\"\n            @keydown.enter.prevent=\"open\"\n        >\n            <div class=\"ui-select-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <div class=\"ui-select-display\">\n                <div\n                    class=\"ui-select-value\" :class=\"{ placeholder: !hasDisplayText }\"\n                    v-text=\"hasDisplayText ? displayText : placeholder\"\n                ></div>\n\n                <ui-icon icon=\"arrow_drop_down\" class=\"ui-select-dropdown-icon\"></ui-icon>\n            </div>\n\n            <div\n                class=\"ui-select-dropdown\" tabindex=\"-1\" v-show=\"showDropdown\" v-el:dropdown\n                @keydown.esc.prevent=\"close()\" @keydown.tab=\"close()\"\n                @keydown.up.prevent=\"highlight(highlightedIndex - 1)\"\n                @keydown.down.prevent=\"highlight(highlightedIndex + 1)\"\n                @keydown.enter.prevent.stop=\"selectHighlighted(highlightedIndex, $event)\"\n            >\n                <div class=\"ui-select-search\" v-if=\"showSearch\" @click.stop @keydown.space.stop>\n                    <input\n                        class=\"ui-select-search-input\" type=\"text\" v-el:search-input\n                        :placeholder=\"searchPlaceholder\" v-model=\"query\" autocomplete=\"off\"\n                    >\n\n                    <ui-progress-circular\n                        class=\"ui-select-search-spinner\" :size=\"24\" :stroke=\"4\" :show=\"loading\"\n                    ></ui-progress-circular>\n                </div>\n\n                <ul class=\"ui-select-options\" v-el:options-list>\n                    <ui-select-option\n                        :option=\"option\" :partial=\"partial\" :show-checkbox=\"multiple\" :\n                        :keys=\"keys\" @click.stop.prevent=\"select(option, index)\"\n                        @mouseover.stop=\"highlight(index, true)\"\n\n                        :highlighted=\"highlightedIndex === index\"\n                        :selected=\"isSelected(option)\"\n\n                        v-for=\"(index, option) in filteredOptions\" v-ref:options\n                    ></ui-select-option>\n\n                    <li class=\"ui-select-no-results\" v-if=\"nothingFound\">No results found</li>\n                </ul>\n            </div>\n        </div>\n\n        <div class=\"ui-select-feedback\" v-if=\"showFeedback\">\n            <div\n                class=\"ui-select-error-text\" transition=\"ui-select-feedback-toggle\"\n                v-text=\"validationError\" v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-select-help-text\" transition=\"ui-select-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 172 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(173)
		__vue_script__ = __webpack_require__(174)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSlider.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(183)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSlider.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 173 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 174 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _draggabilly = __webpack_require__(175);
		
		var _draggabilly2 = _interopRequireDefault(_draggabilly);
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-slider',
		
		    props: {
		        name: String,
		        value: {
		            type: Number,
		            required: true,
		            twoWay: true
		        },
		        step: {
		            type: Number,
		            default: 5
		        },
		        icon: String,
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            active: false,
		            initialValue: 0,
		            dragging: false,
		            draggable: null
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        hasLabel: function hasLabel() {
		            if (this.hideLabel) {
		                return true;
		            }
		
		            return Boolean(this.label);
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (!this.dragging) {
		                this.$els.thumb.style.left = this.value + '%';
		            }
		        },
		        disabled: function disabled() {
		            if (this.disabled) {
		                this.draggable.disable();
		            } else {
		                this.draggable.enable();
		            }
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    ready: function ready() {
		        this.initialValue = this.value;
		
		        this.$els.thumb.style.left = this.value + '%';
		
		        this.draggable = new _draggabilly2.default(this.$els.thumb, {
		            containment: this.$els.containment,
		            axis: 'x'
		        });
		
		        this.draggable.on('dragStart', this.dragStart);
		        this.draggable.on('dragMove', this.dragMove);
		        this.draggable.on('dragEnd', this.dragEnd);
		
		        if (this.disabled) {
		            this.draggable.disable();
		        }
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.draggable) {
		            this.draggable.destroy();
		        }
		    },
		
		
		    methods: {
		        focus: function focus() {
		            this.active = true;
		        },
		        blur: function blur() {
		            this.active = false;
		        },
		        sliderClick: function sliderClick(e) {
		            if (this.disabled) {
		                return;
		            }
		
		            var sliderPosition = this.$els.slider.getBoundingClientRect();
		
		            var newValue = (e.clientX - sliderPosition.left) / sliderPosition.width * 100;
		
		            this.setValue(newValue);
		
		            if (e.target !== this.$els.thumb) {
		                this.draggable._pointerDown(e, e);
		            }
		
		            this.$el.focus();
		        },
		        dragStart: function dragStart() {
		            this.dragging = true;
		            this.$el.focus();
		        },
		        dragMove: function dragMove() {
		            var x = this.draggable.position.x;
		            var newValue = x / this.$els.slider.getBoundingClientRect().width * 100;
		
		            this.setValue(newValue);
		        },
		        dragEnd: function dragEnd() {
		            this.dragging = false;
		        },
		        increment: function increment() {
		            if (this.value === 100) {
		                return;
		            }
		
		            this.setValue(this.value + this.step);
		        },
		        decrement: function decrement() {
		            if (this.value === 0) {
		                return;
		            }
		
		            this.setValue(this.value - this.step);
		        },
		        setValue: function setValue(value) {
		            if (value === this.value) {
		                return;
		            }
		
		            var moderatedValue = Math.round(value);
		
		            if (moderatedValue >= 100) {
		                moderatedValue = 100;
		            }
		
		            if (moderatedValue <= 0) {
		                moderatedValue = 0;
		            }
		
		            this.value = moderatedValue;
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 175 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Draggabilly v1.2.4
		 * Make that shiz draggable
		 * http://draggabilly.desandro.com
		 * MIT license
		 */
		
		( function( window, factory ) {
		  'use strict';
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		        'classie/classie',
		        'get-style-property/get-style-property',
		        'get-size/get-size',
		        'unidragger/unidragger'
		      ],
		      function( classie, getStyleProperty, getSize, Unidragger ) {
		        return factory( window, classie, getStyleProperty, getSize, Unidragger );
		      });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(176),
		      __webpack_require__(177),
		      __webpack_require__(178),
		      __webpack_require__(179)
		    );
		  } else {
		    // browser global
		    window.Draggabilly = factory(
		      window,
		      window.classie,
		      window.getStyleProperty,
		      window.getSize,
		      window.Unidragger
		    );
		  }
		
		}( window, function factory( window, classie, getStyleProperty, getSize, Unidragger ) {
		
		'use strict';
		
		// vars
		var document = window.document;
		
		function noop() {}
		
		// -------------------------- helpers -------------------------- //
		
		// extend objects
		function extend( a, b ) {
		  for ( var prop in b ) {
		    a[ prop ] = b[ prop ];
		  }
		  return a;
		}
		
		// ----- get style ----- //
		
		var defView = document.defaultView;
		
		var getStyle = defView && defView.getComputedStyle ?
		  function( elem ) {
		    return defView.getComputedStyle( elem, null );
		  } :
		  function( elem ) {
		    return elem.currentStyle;
		  };
		
		
		// http://stackoverflow.com/a/384380/182183
		var isElement = ( typeof HTMLElement == 'object' ) ?
		  function isElementDOM2( obj ) {
		    return obj instanceof HTMLElement;
		  } :
		  function isElementQuirky( obj ) {
		    return obj && typeof obj == 'object' &&
		      obj.nodeType == 1 && typeof obj.nodeName == 'string';
		  };
		
		// -------------------------- requestAnimationFrame -------------------------- //
		
		// https://gist.github.com/1866474
		
		var lastTime = 0;
		var prefixes = 'webkit moz ms o'.split(' ');
		// get unprefixed rAF and cAF, if present
		var requestAnimationFrame = window.requestAnimationFrame;
		var cancelAnimationFrame = window.cancelAnimationFrame;
		// loop through vendor prefixes and get prefixed rAF and cAF
		var prefix;
		for( var i = 0; i < prefixes.length; i++ ) {
		  if ( requestAnimationFrame && cancelAnimationFrame ) {
		    break;
		  }
		  prefix = prefixes[i];
		  requestAnimationFrame = requestAnimationFrame || window[ prefix + 'RequestAnimationFrame' ];
		  cancelAnimationFrame  = cancelAnimationFrame  || window[ prefix + 'CancelAnimationFrame' ] ||
		                            window[ prefix + 'CancelRequestAnimationFrame' ];
		}
		
		// fallback to setTimeout and clearTimeout if either request/cancel is not supported
		if ( !requestAnimationFrame || !cancelAnimationFrame )  {
		  requestAnimationFrame = function( callback ) {
		    var currTime = new Date().getTime();
		    var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
		    var id = window.setTimeout( function() {
		      callback( currTime + timeToCall );
		    }, timeToCall );
		    lastTime = currTime + timeToCall;
		    return id;
		  };
		
		  cancelAnimationFrame = function( id ) {
		    window.clearTimeout( id );
		  };
		}
		
		// -------------------------- support -------------------------- //
		
		var transformProperty = getStyleProperty('transform');
		// TODO fix quick & dirty check for 3D support
		var is3d = !!getStyleProperty('perspective');
		
		var jQuery = window.jQuery;
		
		// --------------------------  -------------------------- //
		
		function Draggabilly( element, options ) {
		  // querySelector if string
		  this.element = typeof element == 'string' ?
		    document.querySelector( element ) : element;
		
		  if ( jQuery ) {
		    this.$element = jQuery( this.element );
		  }
		
		  // options
		  this.options = extend( {}, this.constructor.defaults );
		  this.option( options );
		
		  this._create();
		}
		
		// inherit Unidragger methods
		extend( Draggabilly.prototype, Unidragger.prototype );
		
		Draggabilly.defaults = {
		};
		
		/**
		 * set options
		 * @param {Object} opts
		 */
		Draggabilly.prototype.option = function( opts ) {
		  extend( this.options, opts );
		};
		
		Draggabilly.prototype._create = function() {
		
		  // properties
		  this.position = {};
		  this._getPosition();
		
		  this.startPoint = { x: 0, y: 0 };
		  this.dragPoint = { x: 0, y: 0 };
		
		  this.startPosition = extend( {}, this.position );
		
		  // set relative positioning
		  var style = getStyle( this.element );
		  if ( style.position != 'relative' && style.position != 'absolute' ) {
		    this.element.style.position = 'relative';
		  }
		
		  this.enable();
		  this.setHandles();
		
		};
		
		/**
		 * set this.handles and bind start events to 'em
		 */
		Draggabilly.prototype.setHandles = function() {
		  this.handles = this.options.handle ?
		    this.element.querySelectorAll( this.options.handle ) : [ this.element ];
		
		  this.bindHandles();
		};
		
		/**
		 * emits events via eventEmitter and jQuery events
		 * @param {String} type - name of event
		 * @param {Event} event - original event
		 * @param {Array} args - extra arguments
		 */
		Draggabilly.prototype.dispatchEvent = function( type, event, args ) {
		  var emitArgs = [ event ].concat( args );
		  this.emitEvent( type, emitArgs );
		  var jQuery = window.jQuery;
		  // trigger jQuery event
		  if ( jQuery && this.$element ) {
		    if ( event ) {
		      // create jQuery event
		      var $event = jQuery.Event( event );
		      $event.type = type;
		      this.$element.trigger( $event, args );
		    } else {
		      // just trigger with type if no event available
		      this.$element.trigger( type, args );
		    }
		  }
		};
		
		// -------------------------- position -------------------------- //
		
		// get left/top position from style
		Draggabilly.prototype._getPosition = function() {
		  // properties
		  var style = getStyle( this.element );
		
		  var x = parseInt( style.left, 10 );
		  var y = parseInt( style.top, 10 );
		
		  // clean up 'auto' or other non-integer values
		  this.position.x = isNaN( x ) ? 0 : x;
		  this.position.y = isNaN( y ) ? 0 : y;
		
		  this._addTransformPosition( style );
		};
		
		// add transform: translate( x, y ) to position
		Draggabilly.prototype._addTransformPosition = function( style ) {
		  if ( !transformProperty ) {
		    return;
		  }
		  var transform = style[ transformProperty ];
		  // bail out if value is 'none'
		  if ( transform.indexOf('matrix') !== 0 ) {
		    return;
		  }
		  // split matrix(1, 0, 0, 1, x, y)
		  var matrixValues = transform.split(',');
		  // translate X value is in 12th or 4th position
		  var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;
		  var translateX = parseInt( matrixValues[ xIndex ], 10 );
		  // translate Y value is in 13th or 5th position
		  var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );
		  this.position.x += translateX;
		  this.position.y += translateY;
		};
		
		// -------------------------- events -------------------------- //
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerDown = function( event, pointer ) {
		  this._dragPointerDown( event, pointer );
		  // kludge to blur focused inputs in dragger
		  var focused = document.activeElement;
		  if ( focused && focused.blur ) {
		    focused.blur();
		  }
		  // bind move and end events
		  this._bindPostStartEvents( event );
		  classie.add( this.element, 'is-pointer-down' );
		  this.dispatchEvent( 'pointerDown', event, [ pointer ] );
		};
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerMove = function( event, pointer ) {
		  var moveVector = this._dragPointerMove( event, pointer );
		  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );
		  this._dragMove( event, pointer, moveVector );
		};
		
		/**
		 * drag start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragStart = function( event, pointer ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  this._getPosition();
		  this.measureContainment();
		  // position _when_ drag began
		  this.startPosition.x = this.position.x;
		  this.startPosition.y = this.position.y;
		  // reset left/top style
		  this.setLeftTop();
		
		  this.dragPoint.x = 0;
		  this.dragPoint.y = 0;
		
		  // reset isDragging flag
		  this.isDragging = true;
		  classie.add( this.element, 'is-dragging' );
		  this.dispatchEvent( 'dragStart', event, [ pointer ] );
		  // start animation
		  this.animate();
		};
		
		Draggabilly.prototype.measureContainment = function() {
		  var containment = this.options.containment;
		  if ( !containment ) {
		    return;
		  }
		
		  this.size = getSize( this.element );
		  var elemRect = this.element.getBoundingClientRect();
		
		  // use element if element
		  var container = isElement( containment ) ? containment :
		    // fallback to querySelector if string
		    typeof containment == 'string' ? document.querySelector( containment ) :
		    // otherwise just `true`, use the parent
		    this.element.parentNode;
		
		  this.containerSize = getSize( container );
		  var containerRect = container.getBoundingClientRect();
		
		  this.relativeStartPosition = {
		    x: elemRect.left - containerRect.left,
		    y: elemRect.top  - containerRect.top
		  };
		};
		
		// ----- move event ----- //
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragMove = function( event, pointer, moveVector ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  var dragX = moveVector.x;
		  var dragY = moveVector.y;
		
		  var grid = this.options.grid;
		  var gridX = grid && grid[0];
		  var gridY = grid && grid[1];
		
		  dragX = applyGrid( dragX, gridX );
		  dragY = applyGrid( dragY, gridY );
		
		  dragX = this.containDrag( 'x', dragX, gridX );
		  dragY = this.containDrag( 'y', dragY, gridY );
		
		  // constrain to axis
		  dragX = this.options.axis == 'y' ? 0 : dragX;
		  dragY = this.options.axis == 'x' ? 0 : dragY;
		
		  this.position.x = this.startPosition.x + dragX;
		  this.position.y = this.startPosition.y + dragY;
		  // set dragPoint properties
		  this.dragPoint.x = dragX;
		  this.dragPoint.y = dragY;
		
		  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );
		};
		
		function applyGrid( value, grid, method ) {
		  method = method || 'round';
		  return grid ? Math[ method ]( value / grid ) * grid : value;
		}
		
		Draggabilly.prototype.containDrag = function( axis, drag, grid ) {
		  if ( !this.options.containment ) {
		    return drag;
		  }
		  var measure = axis == 'x' ? 'width' : 'height';
		
		  var rel = this.relativeStartPosition[ axis ];
		  var min = applyGrid( -rel, grid, 'ceil' );
		  var max = this.containerSize[ measure ] - rel - this.size[ measure ];
		  max = applyGrid( max, grid, 'floor' );
		  return  Math.min( max, Math.max( min, drag ) );
		};
		
		// ----- end event ----- //
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.pointerUp = function( event, pointer ) {
		  classie.remove( this.element, 'is-pointer-down' );
		  this.dispatchEvent( 'pointerUp', event, [ pointer ] );
		  this._dragPointerUp( event, pointer );
		};
		
		/**
		 * drag end
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Draggabilly.prototype.dragEnd = function( event, pointer ) {
		  if ( !this.isEnabled ) {
		    return;
		  }
		  this.isDragging = false;
		  // use top left position when complete
		  if ( transformProperty ) {
		    this.element.style[ transformProperty ] = '';
		    this.setLeftTop();
		  }
		  classie.remove( this.element, 'is-dragging' );
		  this.dispatchEvent( 'dragEnd', event, [ pointer ] );
		};
		
		// -------------------------- animation -------------------------- //
		
		Draggabilly.prototype.animate = function() {
		  // only render and animate if dragging
		  if ( !this.isDragging ) {
		    return;
		  }
		
		  this.positionDrag();
		
		  var _this = this;
		  requestAnimationFrame( function animateFrame() {
		    _this.animate();
		  });
		
		};
		
		// transform translate function
		var translate = is3d ?
		  function( x, y ) {
		    return 'translate3d( ' + x + 'px, ' + y + 'px, 0)';
		  } :
		  function( x, y ) {
		    return 'translate( ' + x + 'px, ' + y + 'px)';
		  };
		
		// left/top positioning
		Draggabilly.prototype.setLeftTop = function() {
		  this.element.style.left = this.position.x + 'px';
		  this.element.style.top  = this.position.y + 'px';
		};
		
		Draggabilly.prototype.positionDrag = transformProperty ?
		  function() {
		    // position with transform
		    this.element.style[ transformProperty ] = translate( this.dragPoint.x, this.dragPoint.y );
		  } : Draggabilly.prototype.setLeftTop;
		
		// ----- staticClick ----- //
		
		Draggabilly.prototype.staticClick = function( event, pointer ) {
		  this.dispatchEvent( 'staticClick', event, [ pointer ] );
		};
		
		// ----- methods ----- //
		
		Draggabilly.prototype.enable = function() {
		  this.isEnabled = true;
		};
		
		Draggabilly.prototype.disable = function() {
		  this.isEnabled = false;
		  if ( this.isDragging ) {
		    this.dragEnd();
		  }
		};
		
		Draggabilly.prototype.destroy = function() {
		  this.disable();
		  // reset styles
		  if ( transformProperty ) {
		    this.element.style[ transformProperty ] = '';
		  }
		  this.element.style.left = '';
		  this.element.style.top = '';
		  this.element.style.position = '';
		  // unbind handles
		  this.unbindHandles();
		  // remove jQuery data
		  if ( this.$element ) {
		    this.$element.removeData('draggabilly');
		  }
		};
		
		// ----- jQuery bridget ----- //
		
		// required for jQuery bridget
		Draggabilly.prototype._init = noop;
		
		if ( jQuery && jQuery.bridget ) {
		  jQuery.bridget( 'draggabilly', Draggabilly );
		}
		
		// -----  ----- //
		
		return Draggabilly;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 176 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * classie v1.0.1
		 * class helper functions
		 * from bonzo https://github.com/ded/bonzo
		 * MIT license
		 * 
		 * classie.has( elem, 'my-class' ) -> true/false
		 * classie.add( elem, 'my-new-class' )
		 * classie.remove( elem, 'my-unwanted-class' )
		 * classie.toggle( elem, 'my-class' )
		 */
		
		/*jshint browser: true, strict: true, undef: true, unused: true */
		/*global define: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		// class helper functions from bonzo https://github.com/ded/bonzo
		
		function classReg( className ) {
		  return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
		}
		
		// classList support for class management
		// altho to be fair, the api sucks because it won't accept multiple classes at once
		var hasClass, addClass, removeClass;
		
		if ( 'classList' in document.documentElement ) {
		  hasClass = function( elem, c ) {
		    return elem.classList.contains( c );
		  };
		  addClass = function( elem, c ) {
		    elem.classList.add( c );
		  };
		  removeClass = function( elem, c ) {
		    elem.classList.remove( c );
		  };
		}
		else {
		  hasClass = function( elem, c ) {
		    return classReg( c ).test( elem.className );
		  };
		  addClass = function( elem, c ) {
		    if ( !hasClass( elem, c ) ) {
		      elem.className = elem.className + ' ' + c;
		    }
		  };
		  removeClass = function( elem, c ) {
		    elem.className = elem.className.replace( classReg( c ), ' ' );
		  };
		}
		
		function toggleClass( elem, c ) {
		  var fn = hasClass( elem, c ) ? removeClass : addClass;
		  fn( elem, c );
		}
		
		var classie = {
		  // full names
		  hasClass: hasClass,
		  addClass: addClass,
		  removeClass: removeClass,
		  toggleClass: toggleClass,
		  // short names
		  has: hasClass,
		  add: addClass,
		  remove: removeClass,
		  toggle: toggleClass
		};
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD
		  define( classie );
		} else if ( true ) {
		  // CommonJS
		  module.exports = classie;
		} else {
		  // browser global
		  window.classie = classie;
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 177 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * getStyleProperty v1.0.4
		 * original by kangax
		 * http://perfectionkills.com/feature-testing-css-properties/
		 * MIT license
		 */
		
		/*jshint browser: true, strict: true, undef: true */
		/*global define: false, exports: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		var prefixes = 'Webkit Moz ms Ms O'.split(' ');
		var docElemStyle = document.documentElement.style;
		
		function getStyleProperty( propName ) {
		  if ( !propName ) {
		    return;
		  }
		
		  // test standard property first
		  if ( typeof docElemStyle[ propName ] === 'string' ) {
		    return propName;
		  }
		
		  // capitalize
		  propName = propName.charAt(0).toUpperCase() + propName.slice(1);
		
		  // test vendor specific properties
		  var prefixed;
		  for ( var i=0, len = prefixes.length; i < len; i++ ) {
		    prefixed = prefixes[i] + propName;
		    if ( typeof docElemStyle[ prefixed ] === 'string' ) {
		      return prefixed;
		    }
		  }
		}
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD
		  define( function() {
		    return getStyleProperty;
		  });
		} else if ( true ) {
		  // CommonJS for Component
		  module.exports = getStyleProperty;
		} else {
		  // browser global
		  window.getStyleProperty = getStyleProperty;
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 178 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * getSize v1.2.2
		 * measure size of elements
		 * MIT license
		 */
		
		/*jshint browser: true, strict: true, undef: true, unused: true */
		/*global define: false, exports: false, require: false, module: false, console: false */
		
		( function( window, undefined ) {
		
		'use strict';
		
		// -------------------------- helpers -------------------------- //
		
		// get a number from a string, not a percentage
		function getStyleSize( value ) {
		  var num = parseFloat( value );
		  // not a percent like '100%', and a number
		  var isValid = value.indexOf('%') === -1 && !isNaN( num );
		  return isValid && num;
		}
		
		function noop() {}
		
		var logError = typeof console === 'undefined' ? noop :
		  function( message ) {
		    console.error( message );
		  };
		
		// -------------------------- measurements -------------------------- //
		
		var measurements = [
		  'paddingLeft',
		  'paddingRight',
		  'paddingTop',
		  'paddingBottom',
		  'marginLeft',
		  'marginRight',
		  'marginTop',
		  'marginBottom',
		  'borderLeftWidth',
		  'borderRightWidth',
		  'borderTopWidth',
		  'borderBottomWidth'
		];
		
		function getZeroSize() {
		  var size = {
		    width: 0,
		    height: 0,
		    innerWidth: 0,
		    innerHeight: 0,
		    outerWidth: 0,
		    outerHeight: 0
		  };
		  for ( var i=0, len = measurements.length; i < len; i++ ) {
		    var measurement = measurements[i];
		    size[ measurement ] = 0;
		  }
		  return size;
		}
		
		
		
		function defineGetSize( getStyleProperty ) {
		
		// -------------------------- setup -------------------------- //
		
		var isSetup = false;
		
		var getStyle, boxSizingProp, isBoxSizeOuter;
		
		/**
		 * setup vars and functions
		 * do it on initial getSize(), rather than on script load
		 * For Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=548397
		 */
		function setup() {
		  // setup once
		  if ( isSetup ) {
		    return;
		  }
		  isSetup = true;
		
		  var getComputedStyle = window.getComputedStyle;
		  getStyle = ( function() {
		    var getStyleFn = getComputedStyle ?
		      function( elem ) {
		        return getComputedStyle( elem, null );
		      } :
		      function( elem ) {
		        return elem.currentStyle;
		      };
		
		      return function getStyle( elem ) {
		        var style = getStyleFn( elem );
		        if ( !style ) {
		          logError( 'Style returned ' + style +
		            '. Are you running this code in a hidden iframe on Firefox? ' +
		            'See http://bit.ly/getsizebug1' );
		        }
		        return style;
		      };
		  })();
		
		  // -------------------------- box sizing -------------------------- //
		
		  boxSizingProp = getStyleProperty('boxSizing');
		
		  /**
		   * WebKit measures the outer-width on style.width on border-box elems
		   * IE & Firefox measures the inner-width
		   */
		  if ( boxSizingProp ) {
		    var div = document.createElement('div');
		    div.style.width = '200px';
		    div.style.padding = '1px 2px 3px 4px';
		    div.style.borderStyle = 'solid';
		    div.style.borderWidth = '1px 2px 3px 4px';
		    div.style[ boxSizingProp ] = 'border-box';
		
		    var body = document.body || document.documentElement;
		    body.appendChild( div );
		    var style = getStyle( div );
		
		    isBoxSizeOuter = getStyleSize( style.width ) === 200;
		    body.removeChild( div );
		  }
		
		}
		
		// -------------------------- getSize -------------------------- //
		
		function getSize( elem ) {
		  setup();
		
		  // use querySeletor if elem is string
		  if ( typeof elem === 'string' ) {
		    elem = document.querySelector( elem );
		  }
		
		  // do not proceed on non-objects
		  if ( !elem || typeof elem !== 'object' || !elem.nodeType ) {
		    return;
		  }
		
		  var style = getStyle( elem );
		
		  // if hidden, everything is 0
		  if ( style.display === 'none' ) {
		    return getZeroSize();
		  }
		
		  var size = {};
		  size.width = elem.offsetWidth;
		  size.height = elem.offsetHeight;
		
		  var isBorderBox = size.isBorderBox = !!( boxSizingProp &&
		    style[ boxSizingProp ] && style[ boxSizingProp ] === 'border-box' );
		
		  // get all measurements
		  for ( var i=0, len = measurements.length; i < len; i++ ) {
		    var measurement = measurements[i];
		    var value = style[ measurement ];
		    value = mungeNonPixel( elem, value );
		    var num = parseFloat( value );
		    // any 'auto', 'medium' value will be 0
		    size[ measurement ] = !isNaN( num ) ? num : 0;
		  }
		
		  var paddingWidth = size.paddingLeft + size.paddingRight;
		  var paddingHeight = size.paddingTop + size.paddingBottom;
		  var marginWidth = size.marginLeft + size.marginRight;
		  var marginHeight = size.marginTop + size.marginBottom;
		  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
		  var borderHeight = size.borderTopWidth + size.borderBottomWidth;
		
		  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
		
		  // overwrite width and height if we can get it from style
		  var styleWidth = getStyleSize( style.width );
		  if ( styleWidth !== false ) {
		    size.width = styleWidth +
		      // add padding and border unless it's already including it
		      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
		  }
		
		  var styleHeight = getStyleSize( style.height );
		  if ( styleHeight !== false ) {
		    size.height = styleHeight +
		      // add padding and border unless it's already including it
		      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
		  }
		
		  size.innerWidth = size.width - ( paddingWidth + borderWidth );
		  size.innerHeight = size.height - ( paddingHeight + borderHeight );
		
		  size.outerWidth = size.width + marginWidth;
		  size.outerHeight = size.height + marginHeight;
		
		  return size;
		}
		
		// IE8 returns percent values, not pixels
		// taken from jQuery's curCSS
		function mungeNonPixel( elem, value ) {
		  // IE8 and has percent value
		  if ( window.getComputedStyle || value.indexOf('%') === -1 ) {
		    return value;
		  }
		  var style = elem.style;
		  // Remember the original values
		  var left = style.left;
		  var rs = elem.runtimeStyle;
		  var rsLeft = rs && rs.left;
		
		  // Put in the new values to get a computed value out
		  if ( rsLeft ) {
		    rs.left = elem.currentStyle.left;
		  }
		  style.left = value;
		  value = style.pixelLeft;
		
		  // Revert the changed values
		  style.left = left;
		  if ( rsLeft ) {
		    rs.left = rsLeft;
		  }
		
		  return value;
		}
		
		return getSize;
		
		}
		
		// transport
		if ( typeof define === 'function' && define.amd ) {
		  // AMD for RequireJS
		  define( [ 'get-style-property/get-style-property' ], defineGetSize );
		} else if ( true ) {
		  // CommonJS for Component
		  module.exports = defineGetSize( __webpack_require__(177) );
		} else {
		  // browser global
		  window.getSize = defineGetSize( window.getStyleProperty );
		}
		
		})( window );
		
		}.call(window));
	
	/***/ },
	/* 179 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Unidragger v1.1.5
		 * Draggable base class
		 * MIT license
		 */
		
		/*jshint browser: true, unused: true, undef: true, strict: true */
		
		( function( window, factory ) {
		  /*global define: false, module: false, require: false */
		  'use strict';
		  // universal module definition
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		      'eventie/eventie',
		      'unipointer/unipointer'
		    ], function( eventie, Unipointer ) {
		      return factory( window, eventie, Unipointer );
		    });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(180),
		      __webpack_require__(181)
		    );
		  } else {
		    // browser global
		    window.Unidragger = factory(
		      window,
		      window.eventie,
		      window.Unipointer
		    );
		  }
		
		}( window, function factory( window, eventie, Unipointer ) {
		
		'use strict';
		
		// -----  ----- //
		
		function noop() {}
		
		// handle IE8 prevent default
		function preventDefaultEvent( event ) {
		  if ( event.preventDefault ) {
		    event.preventDefault();
		  } else {
		    event.returnValue = false;
		  }
		}
		
		// -------------------------- Unidragger -------------------------- //
		
		function Unidragger() {}
		
		// inherit Unipointer & EventEmitter
		Unidragger.prototype = new Unipointer();
		
		// ----- bind start ----- //
		
		Unidragger.prototype.bindHandles = function() {
		  this._bindHandles( true );
		};
		
		Unidragger.prototype.unbindHandles = function() {
		  this._bindHandles( false );
		};
		
		var navigator = window.navigator;
		/**
		 * works as unbinder, as you can .bindHandles( false ) to unbind
		 * @param {Boolean} isBind - will unbind if falsey
		 */
		Unidragger.prototype._bindHandles = function( isBind ) {
		  // munge isBind, default to true
		  isBind = isBind === undefined ? true : !!isBind;
		  // extra bind logic
		  var binderExtra;
		  if ( navigator.pointerEnabled ) {
		    binderExtra = function( handle ) {
		      // disable scrolling on the element
		      handle.style.touchAction = isBind ? 'none' : '';
		    };
		  } else if ( navigator.msPointerEnabled ) {
		    binderExtra = function( handle ) {
		      // disable scrolling on the element
		      handle.style.msTouchAction = isBind ? 'none' : '';
		    };
		  } else {
		    binderExtra = function() {
		      // TODO re-enable img.ondragstart when unbinding
		      if ( isBind ) {
		        disableImgOndragstart( handle );
		      }
		    };
		  }
		  // bind each handle
		  var bindMethod = isBind ? 'bind' : 'unbind';
		  for ( var i=0, len = this.handles.length; i < len; i++ ) {
		    var handle = this.handles[i];
		    this._bindStartEvent( handle, isBind );
		    binderExtra( handle );
		    eventie[ bindMethod ]( handle, 'click', this );
		  }
		};
		
		// remove default dragging interaction on all images in IE8
		// IE8 does its own drag thing on images, which messes stuff up
		
		function noDragStart() {
		  return false;
		}
		
		// TODO replace this with a IE8 test
		var isIE8 = 'attachEvent' in document.documentElement;
		
		// IE8 only
		var disableImgOndragstart = !isIE8 ? noop : function( handle ) {
		
		  if ( handle.nodeName == 'IMG' ) {
		    handle.ondragstart = noDragStart;
		  }
		
		  var images = handle.querySelectorAll('img');
		  for ( var i=0, len = images.length; i < len; i++ ) {
		    var img = images[i];
		    img.ondragstart = noDragStart;
		  }
		};
		
		// ----- start event ----- //
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerDown = function( event, pointer ) {
		  // dismiss range sliders
		  if ( event.target.nodeName == 'INPUT' && event.target.type == 'range' ) {
		    // reset pointerDown logic
		    this.isPointerDown = false;
		    delete this.pointerIdentifier;
		    return;
		  }
		
		  this._dragPointerDown( event, pointer );
		  // kludge to blur focused inputs in dragger
		  var focused = document.activeElement;
		  if ( focused && focused.blur ) {
		    focused.blur();
		  }
		  // bind move and end events
		  this._bindPostStartEvents( event );
		  // track scrolling
		  this.pointerDownScroll = Unidragger.getScrollPosition();
		  eventie.bind( window, 'scroll', this );
		
		  this.emitEvent( 'pointerDown', [ event, pointer ] );
		};
		
		// base pointer down logic
		Unidragger.prototype._dragPointerDown = function( event, pointer ) {
		  // track to see when dragging starts
		  this.pointerDownPoint = Unipointer.getPointerPoint( pointer );
		
		  // prevent default, unless touchstart or <select>
		  var isTouchstart = event.type == 'touchstart';
		  var targetNodeName = event.target.nodeName;
		  if ( !isTouchstart && targetNodeName != 'SELECT' ) {
		    preventDefaultEvent( event );
		  }
		};
		
		// ----- move event ----- //
		
		/**
		 * drag move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerMove = function( event, pointer ) {
		  var moveVector = this._dragPointerMove( event, pointer );
		  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
		  this._dragMove( event, pointer, moveVector );
		};
		
		// base pointer move logic
		Unidragger.prototype._dragPointerMove = function( event, pointer ) {
		  var movePoint = Unipointer.getPointerPoint( pointer );
		  var moveVector = {
		    x: movePoint.x - this.pointerDownPoint.x,
		    y: movePoint.y - this.pointerDownPoint.y
		  };
		  // start drag if pointer has moved far enough to start drag
		  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {
		    this._dragStart( event, pointer );
		  }
		  return moveVector;
		};
		
		// condition if pointer has moved far enough to start drag
		Unidragger.prototype.hasDragStarted = function( moveVector ) {
		  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;
		};
		
		
		// ----- end event ----- //
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unidragger.prototype.pointerUp = function( event, pointer ) {
		  this.emitEvent( 'pointerUp', [ event, pointer ] );
		  this._dragPointerUp( event, pointer );
		};
		
		Unidragger.prototype._dragPointerUp = function( event, pointer ) {
		  if ( this.isDragging ) {
		    this._dragEnd( event, pointer );
		  } else {
		    // pointer didn't move enough for drag to start
		    this._staticClick( event, pointer );
		  }
		};
		
		Unipointer.prototype.pointerDone = function() {
		  eventie.unbind( window, 'scroll', this );
		};
		
		// -------------------------- drag -------------------------- //
		
		// dragStart
		Unidragger.prototype._dragStart = function( event, pointer ) {
		  this.isDragging = true;
		  this.dragStartPoint = Unidragger.getPointerPoint( pointer );
		  // prevent clicks
		  this.isPreventingClicks = true;
		
		  this.dragStart( event, pointer );
		};
		
		Unidragger.prototype.dragStart = function( event, pointer ) {
		  this.emitEvent( 'dragStart', [ event, pointer ] );
		};
		
		// dragMove
		Unidragger.prototype._dragMove = function( event, pointer, moveVector ) {
		  // do not drag if not dragging yet
		  if ( !this.isDragging ) {
		    return;
		  }
		
		  this.dragMove( event, pointer, moveVector );
		};
		
		Unidragger.prototype.dragMove = function( event, pointer, moveVector ) {
		  preventDefaultEvent( event );
		  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
		};
		
		// dragEnd
		Unidragger.prototype._dragEnd = function( event, pointer ) {
		  // set flags
		  this.isDragging = false;
		  // re-enable clicking async
		  var _this = this;
		  setTimeout( function() {
		    delete _this.isPreventingClicks;
		  });
		
		  this.dragEnd( event, pointer );
		};
		
		Unidragger.prototype.dragEnd = function( event, pointer ) {
		  this.emitEvent( 'dragEnd', [ event, pointer ] );
		};
		
		Unidragger.prototype.pointerDone = function() {
		  eventie.unbind( window, 'scroll', this );
		  delete this.pointerDownScroll;
		};
		
		// ----- onclick ----- //
		
		// handle all clicks and prevent clicks when dragging
		Unidragger.prototype.onclick = function( event ) {
		  if ( this.isPreventingClicks ) {
		    preventDefaultEvent( event );
		  }
		};
		
		// ----- staticClick ----- //
		
		// triggered after pointer down & up with no/tiny movement
		Unidragger.prototype._staticClick = function( event, pointer ) {
		  // ignore emulated mouse up clicks
		  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {
		    return;
		  }
		
		  // allow click in <input>s and <textarea>s
		  var nodeName = event.target.nodeName;
		  if ( nodeName == 'INPUT' || nodeName == 'TEXTAREA' ) {
		    event.target.focus();
		  }
		  this.staticClick( event, pointer );
		
		  // set flag for emulated clicks 300ms after touchend
		  if ( event.type != 'mouseup' ) {
		    this.isIgnoringMouseUp = true;
		    var _this = this;
		    // reset flag after 300ms
		    setTimeout( function() {
		      delete _this.isIgnoringMouseUp;
		    }, 400 );
		  }
		};
		
		Unidragger.prototype.staticClick = function( event, pointer ) {
		  this.emitEvent( 'staticClick', [ event, pointer ] );
		};
		
		// ----- scroll ----- //
		
		Unidragger.prototype.onscroll = function() {
		  var scroll = Unidragger.getScrollPosition();
		  var scrollMoveX = this.pointerDownScroll.x - scroll.x;
		  var scrollMoveY = this.pointerDownScroll.y - scroll.y;
		  // cancel click/tap if scroll is too much
		  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {
		    this._pointerDone();
		  }
		};
		
		// ----- utils ----- //
		
		Unidragger.getPointerPoint = function( pointer ) {
		  return {
		    x: pointer.pageX !== undefined ? pointer.pageX : pointer.clientX,
		    y: pointer.pageY !== undefined ? pointer.pageY : pointer.clientY
		  };
		};
		
		var isPageOffset = window.pageYOffset !== undefined;
		
		// get scroll in { x, y }
		Unidragger.getScrollPosition = function() {
		  return {
		    x: isPageOffset ? window.pageXOffset : document.body.scrollLeft,
		    y: isPageOffset ? window.pageYOffset : document.body.scrollTop
		  };
		};
		
		// -----  ----- //
		
		Unidragger.getPointerPoint = Unipointer.getPointerPoint;
		
		return Unidragger;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 180 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		 * eventie v1.0.6
		 * event binding helper
		 *   eventie.bind( elem, 'click', myFn )
		 *   eventie.unbind( elem, 'click', myFn )
		 * MIT license
		 */
		
		/*jshint browser: true, undef: true, unused: true */
		/*global define: false, module: false */
		
		( function( window ) {
		
		'use strict';
		
		var docElem = document.documentElement;
		
		var bind = function() {};
		
		function getIEEvent( obj ) {
		  var event = window.event;
		  // add event.target
		  event.target = event.target || event.srcElement || obj;
		  return event;
		}
		
		if ( docElem.addEventListener ) {
		  bind = function( obj, type, fn ) {
		    obj.addEventListener( type, fn, false );
		  };
		} else if ( docElem.attachEvent ) {
		  bind = function( obj, type, fn ) {
		    obj[ type + fn ] = fn.handleEvent ?
		      function() {
		        var event = getIEEvent( obj );
		        fn.handleEvent.call( fn, event );
		      } :
		      function() {
		        var event = getIEEvent( obj );
		        fn.call( obj, event );
		      };
		    obj.attachEvent( "on" + type, obj[ type + fn ] );
		  };
		}
		
		var unbind = function() {};
		
		if ( docElem.removeEventListener ) {
		  unbind = function( obj, type, fn ) {
		    obj.removeEventListener( type, fn, false );
		  };
		} else if ( docElem.detachEvent ) {
		  unbind = function( obj, type, fn ) {
		    obj.detachEvent( "on" + type, obj[ type + fn ] );
		    try {
		      delete obj[ type + fn ];
		    } catch ( err ) {
		      // can't delete window object properties
		      obj[ type + fn ] = undefined;
		    }
		  };
		}
		
		var eventie = {
		  bind: bind,
		  unbind: unbind
		};
		
		// ----- module definition ----- //
		
		if ( true ) {
		  // AMD
		  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (eventie), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if ( typeof exports === 'object' ) {
		  // CommonJS
		  module.exports = eventie;
		} else {
		  // browser global
		  window.eventie = eventie;
		}
		
		})( window );
	
	
	/***/ },
	/* 181 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * Unipointer v1.1.0
		 * base class for doing one thing with pointer event
		 * MIT license
		 */
		
		/*jshint browser: true, undef: true, unused: true, strict: true */
		/*global define: false, module: false, require: false */
		
		( function( window, factory ) {
		  'use strict';
		  // universal module definition
		
		  if ( typeof define == 'function' && define.amd ) {
		    // AMD
		    define( [
		      'eventEmitter/EventEmitter',
		      'eventie/eventie'
		    ], function( EventEmitter, eventie ) {
		      return factory( window, EventEmitter, eventie );
		    });
		  } else if ( true ) {
		    // CommonJS
		    module.exports = factory(
		      window,
		      __webpack_require__(182),
		      __webpack_require__(180)
		    );
		  } else {
		    // browser global
		    window.Unipointer = factory(
		      window,
		      window.EventEmitter,
		      window.eventie
		    );
		  }
		
		}( window, function factory( window, EventEmitter, eventie ) {
		
		'use strict';
		
		function noop() {}
		
		function Unipointer() {}
		
		// inherit EventEmitter
		Unipointer.prototype = new EventEmitter();
		
		Unipointer.prototype.bindStartEvent = function( elem ) {
		  this._bindStartEvent( elem, true );
		};
		
		Unipointer.prototype.unbindStartEvent = function( elem ) {
		  this._bindStartEvent( elem, false );
		};
		
		/**
		 * works as unbinder, as you can ._bindStart( false ) to unbind
		 * @param {Boolean} isBind - will unbind if falsey
		 */
		Unipointer.prototype._bindStartEvent = function( elem, isBind ) {
		  // munge isBind, default to true
		  isBind = isBind === undefined ? true : !!isBind;
		  var bindMethod = isBind ? 'bind' : 'unbind';
		
		  if ( window.navigator.pointerEnabled ) {
		    // W3C Pointer Events, IE11. See https://coderwall.com/p/mfreca
		    eventie[ bindMethod ]( elem, 'pointerdown', this );
		  } else if ( window.navigator.msPointerEnabled ) {
		    // IE10 Pointer Events
		    eventie[ bindMethod ]( elem, 'MSPointerDown', this );
		  } else {
		    // listen for both, for devices like Chrome Pixel
		    eventie[ bindMethod ]( elem, 'mousedown', this );
		    eventie[ bindMethod ]( elem, 'touchstart', this );
		  }
		};
		
		// trigger handler methods for events
		Unipointer.prototype.handleEvent = function( event ) {
		  var method = 'on' + event.type;
		  if ( this[ method ] ) {
		    this[ method ]( event );
		  }
		};
		
		// returns the touch that we're keeping track of
		Unipointer.prototype.getTouch = function( touches ) {
		  for ( var i=0, len = touches.length; i < len; i++ ) {
		    var touch = touches[i];
		    if ( touch.identifier == this.pointerIdentifier ) {
		      return touch;
		    }
		  }
		};
		
		// ----- start event ----- //
		
		Unipointer.prototype.onmousedown = function( event ) {
		  // dismiss clicks from right or middle buttons
		  var button = event.button;
		  if ( button && ( button !== 0 && button !== 1 ) ) {
		    return;
		  }
		  this._pointerDown( event, event );
		};
		
		Unipointer.prototype.ontouchstart = function( event ) {
		  this._pointerDown( event, event.changedTouches[0] );
		};
		
		Unipointer.prototype.onMSPointerDown =
		Unipointer.prototype.onpointerdown = function( event ) {
		  this._pointerDown( event, event );
		};
		
		/**
		 * pointer start
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 */
		Unipointer.prototype._pointerDown = function( event, pointer ) {
		  // dismiss other pointers
		  if ( this.isPointerDown ) {
		    return;
		  }
		
		  this.isPointerDown = true;
		  // save pointer identifier to match up touch events
		  this.pointerIdentifier = pointer.pointerId !== undefined ?
		    // pointerId for pointer events, touch.indentifier for touch events
		    pointer.pointerId : pointer.identifier;
		
		  this.pointerDown( event, pointer );
		};
		
		Unipointer.prototype.pointerDown = function( event, pointer ) {
		  this._bindPostStartEvents( event );
		  this.emitEvent( 'pointerDown', [ event, pointer ] );
		};
		
		// hash of events to be bound after start event
		var postStartEvents = {
		  mousedown: [ 'mousemove', 'mouseup' ],
		  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],
		  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],
		  MSPointerDown: [ 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel' ]
		};
		
		Unipointer.prototype._bindPostStartEvents = function( event ) {
		  if ( !event ) {
		    return;
		  }
		  // get proper events to match start event
		  var events = postStartEvents[ event.type ];
		  // IE8 needs to be bound to document
		  var node = event.preventDefault ? window : document;
		  // bind events to node
		  for ( var i=0, len = events.length; i < len; i++ ) {
		    var evnt = events[i];
		    eventie.bind( node, evnt, this );
		  }
		  // save these arguments
		  this._boundPointerEvents = {
		    events: events,
		    node: node
		  };
		};
		
		Unipointer.prototype._unbindPostStartEvents = function() {
		  var args = this._boundPointerEvents;
		  // IE8 can trigger dragEnd twice, check for _boundEvents
		  if ( !args || !args.events ) {
		    return;
		  }
		
		  for ( var i=0, len = args.events.length; i < len; i++ ) {
		    var event = args.events[i];
		    eventie.unbind( args.node, event, this );
		  }
		  delete this._boundPointerEvents;
		};
		
		// ----- move event ----- //
		
		Unipointer.prototype.onmousemove = function( event ) {
		  this._pointerMove( event, event );
		};
		
		Unipointer.prototype.onMSPointerMove =
		Unipointer.prototype.onpointermove = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerMove( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchmove = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerMove( event, touch );
		  }
		};
		
		/**
		 * pointer move
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerMove = function( event, pointer ) {
		  this.pointerMove( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerMove = function( event, pointer ) {
		  this.emitEvent( 'pointerMove', [ event, pointer ] );
		};
		
		// ----- end event ----- //
		
		
		Unipointer.prototype.onmouseup = function( event ) {
		  this._pointerUp( event, event );
		};
		
		Unipointer.prototype.onMSPointerUp =
		Unipointer.prototype.onpointerup = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerUp( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchend = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerUp( event, touch );
		  }
		};
		
		/**
		 * pointer up
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerUp = function( event, pointer ) {
		  this._pointerDone();
		  this.pointerUp( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerUp = function( event, pointer ) {
		  this.emitEvent( 'pointerUp', [ event, pointer ] );
		};
		
		// ----- pointer done ----- //
		
		// triggered on pointer up & pointer cancel
		Unipointer.prototype._pointerDone = function() {
		  // reset properties
		  this.isPointerDown = false;
		  delete this.pointerIdentifier;
		  // remove events
		  this._unbindPostStartEvents();
		  this.pointerDone();
		};
		
		Unipointer.prototype.pointerDone = noop;
		
		// ----- pointer cancel ----- //
		
		Unipointer.prototype.onMSPointerCancel =
		Unipointer.prototype.onpointercancel = function( event ) {
		  if ( event.pointerId == this.pointerIdentifier ) {
		    this._pointerCancel( event, event );
		  }
		};
		
		Unipointer.prototype.ontouchcancel = function( event ) {
		  var touch = this.getTouch( event.changedTouches );
		  if ( touch ) {
		    this._pointerCancel( event, touch );
		  }
		};
		
		/**
		 * pointer cancel
		 * @param {Event} event
		 * @param {Event or Touch} pointer
		 * @private
		 */
		Unipointer.prototype._pointerCancel = function( event, pointer ) {
		  this._pointerDone();
		  this.pointerCancel( event, pointer );
		};
		
		// public
		Unipointer.prototype.pointerCancel = function( event, pointer ) {
		  this.emitEvent( 'pointerCancel', [ event, pointer ] );
		};
		
		// -----  ----- //
		
		// utility function for getting x/y cooridinates from event, because IE8
		Unipointer.getPointerPoint = function( pointer ) {
		  return {
		    x: pointer.pageX !== undefined ? pointer.pageX : pointer.clientX,
		    y: pointer.pageY !== undefined ? pointer.pageY : pointer.clientY
		  };
		};
		
		// -----  ----- //
		
		return Unipointer;
		
		}));
		
		}.call(window));
	
	/***/ },
	/* 182 */
	/***/ function(module, exports) {
	
		/*** IMPORTS FROM imports-loader ***/
		var define = false;
		(function() {
		
		/*!
		 * EventEmitter v4.2.11 - git.io/ee
		 * Unlicense - http://unlicense.org/
		 * Oliver Caldwell - http://oli.me.uk/
		 * @preserve
		 */
		
		;(function () {
		    'use strict';
		
		    /**
		     * Class for managing events.
		     * Can be extended to provide event functionality in other classes.
		     *
		     * @class EventEmitter Manages event registering and emitting.
		     */
		    function EventEmitter() {}
		
		    // Shortcuts to improve speed and size
		    var proto = EventEmitter.prototype;
		    var exports = this;
		    var originalGlobalValue = exports.EventEmitter;
		
		    /**
		     * Finds the index of the listener for the event in its storage array.
		     *
		     * @param {Function[]} listeners Array of listeners to search through.
		     * @param {Function} listener Method to look for.
		     * @return {Number} Index of the specified listener, -1 if not found
		     * @api private
		     */
		    function indexOfListener(listeners, listener) {
		        var i = listeners.length;
		        while (i--) {
		            if (listeners[i].listener === listener) {
		                return i;
		            }
		        }
		
		        return -1;
		    }
		
		    /**
		     * Alias a method while keeping the context correct, to allow for overwriting of target method.
		     *
		     * @param {String} name The name of the target method.
		     * @return {Function} The aliased method
		     * @api private
		     */
		    function alias(name) {
		        return function aliasClosure() {
		            return this[name].apply(this, arguments);
		        };
		    }
		
		    /**
		     * Returns the listener array for the specified event.
		     * Will initialise the event object and listener arrays if required.
		     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
		     * Each property in the object response is an array of listener functions.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Function[]|Object} All listener functions for the event.
		     */
		    proto.getListeners = function getListeners(evt) {
		        var events = this._getEvents();
		        var response;
		        var key;
		
		        // Return a concatenated array of all matching events if
		        // the selector is a regular expression.
		        if (evt instanceof RegExp) {
		            response = {};
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    response[key] = events[key];
		                }
		            }
		        }
		        else {
		            response = events[evt] || (events[evt] = []);
		        }
		
		        return response;
		    };
		
		    /**
		     * Takes a list of listener objects and flattens it into a list of listener functions.
		     *
		     * @param {Object[]} listeners Raw listener objects.
		     * @return {Function[]} Just the listener functions.
		     */
		    proto.flattenListeners = function flattenListeners(listeners) {
		        var flatListeners = [];
		        var i;
		
		        for (i = 0; i < listeners.length; i += 1) {
		            flatListeners.push(listeners[i].listener);
		        }
		
		        return flatListeners;
		    };
		
		    /**
		     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Object} All listener functions for an event in an object.
		     */
		    proto.getListenersAsObject = function getListenersAsObject(evt) {
		        var listeners = this.getListeners(evt);
		        var response;
		
		        if (listeners instanceof Array) {
		            response = {};
		            response[evt] = listeners;
		        }
		
		        return response || listeners;
		    };
		
		    /**
		     * Adds a listener function to the specified event.
		     * The listener will not be added if it is a duplicate.
		     * If the listener returns true then it will be removed after it is called.
		     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListener = function addListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var listenerIsWrapped = typeof listener === 'object';
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
		                listeners[key].push(listenerIsWrapped ? listener : {
		                    listener: listener,
		                    once: false
		                });
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of addListener
		     */
		    proto.on = alias('addListener');
		
		    /**
		     * Semi-alias of addListener. It will add a listener that will be
		     * automatically removed after its first execution.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addOnceListener = function addOnceListener(evt, listener) {
		        return this.addListener(evt, {
		            listener: listener,
		            once: true
		        });
		    };
		
		    /**
		     * Alias of addOnceListener.
		     */
		    proto.once = alias('addOnceListener');
		
		    /**
		     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
		     * You need to tell it what event names should be matched by a regex.
		     *
		     * @param {String} evt Name of the event to create.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvent = function defineEvent(evt) {
		        this.getListeners(evt);
		        return this;
		    };
		
		    /**
		     * Uses defineEvent to define multiple events.
		     *
		     * @param {String[]} evts An array of event names to define.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvents = function defineEvents(evts) {
		        for (var i = 0; i < evts.length; i += 1) {
		            this.defineEvent(evts[i]);
		        }
		        return this;
		    };
		
		    /**
		     * Removes a listener function from the specified event.
		     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to remove the listener from.
		     * @param {Function} listener Method to remove from the event.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListener = function removeListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var index;
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                index = indexOfListener(listeners[key], listener);
		
		                if (index !== -1) {
		                    listeners[key].splice(index, 1);
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeListener
		     */
		    proto.off = alias('removeListener');
		
		    /**
		     * Adds listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
		     * You can also pass it a regular expression to add the array of listeners to all events that match it.
		     * Yeah, this function does quite a bit. That's probably a bad thing.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListeners = function addListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(false, evt, listeners);
		    };
		
		    /**
		     * Removes listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be removed.
		     * You can also pass it a regular expression to remove the listeners from all events that match it.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListeners = function removeListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(true, evt, listeners);
		    };
		
		    /**
		     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
		     * The first argument will determine if the listeners are removed (true) or added (false).
		     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be added/removed.
		     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
		     *
		     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		        var i;
		        var value;
		        var single = remove ? this.removeListener : this.addListener;
		        var multiple = remove ? this.removeListeners : this.addListeners;
		
		        // If evt is an object then pass each of its properties to this method
		        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
		            for (i in evt) {
		                if (evt.hasOwnProperty(i) && (value = evt[i])) {
		                    // Pass the single listener straight through to the singular method
		                    if (typeof value === 'function') {
		                        single.call(this, i, value);
		                    }
		                    else {
		                        // Otherwise pass back to the multiple function
		                        multiple.call(this, i, value);
		                    }
		                }
		            }
		        }
		        else {
		            // So evt must be a string
		            // And listeners must be an array of listeners
		            // Loop over it and pass each one to the multiple method
		            i = listeners.length;
		            while (i--) {
		                single.call(this, evt, listeners[i]);
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Removes all listeners from a specified event.
		     * If you do not specify an event then all listeners will be removed.
		     * That means every event will be emptied.
		     * You can also pass a regex to remove all events that match it.
		     *
		     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeEvent = function removeEvent(evt) {
		        var type = typeof evt;
		        var events = this._getEvents();
		        var key;
		
		        // Remove different things depending on the state of evt
		        if (type === 'string') {
		            // Remove all listeners for the specified event
		            delete events[evt];
		        }
		        else if (evt instanceof RegExp) {
		            // Remove all events matching the regex.
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    delete events[key];
		                }
		            }
		        }
		        else {
		            // Remove all listeners in all events
		            delete this._events;
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeEvent.
		     *
		     * Added to mirror the node API.
		     */
		    proto.removeAllListeners = alias('removeEvent');
		
		    /**
		     * Emits an event of your choice.
		     * When emitted, every listener attached to that event will be executed.
		     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
		     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
		     * So they will not arrive within the array on the other side, they will be separate.
		     * You can also pass a regular expression to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {Array} [args] Optional array of arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emitEvent = function emitEvent(evt, args) {
		        var listeners = this.getListenersAsObject(evt);
		        var listener;
		        var i;
		        var key;
		        var response;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                i = listeners[key].length;
		
		                while (i--) {
		                    // If the listener returns true then it shall be removed from the event
		                    // The function is executed either with a basic call or an apply if there is an args array
		                    listener = listeners[key][i];
		
		                    if (listener.once === true) {
		                        this.removeListener(evt, listener.listener);
		                    }
		
		                    response = listener.listener.apply(this, args || []);
		
		                    if (response === this._getOnceReturnValue()) {
		                        this.removeListener(evt, listener.listener);
		                    }
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of emitEvent
		     */
		    proto.trigger = alias('emitEvent');
		
		    /**
		     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
		     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {...*} Optional additional arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emit = function emit(evt) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return this.emitEvent(evt, args);
		    };
		
		    /**
		     * Sets the current value to check against when executing listeners. If a
		     * listeners return value matches the one set here then it will be removed
		     * after execution. This value defaults to true.
		     *
		     * @param {*} value The new value to check for when executing listeners.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.setOnceReturnValue = function setOnceReturnValue(value) {
		        this._onceReturnValue = value;
		        return this;
		    };
		
		    /**
		     * Fetches the current value to check against when executing listeners. If
		     * the listeners return value matches this one then it should be removed
		     * automatically. It will return true by default.
		     *
		     * @return {*|Boolean} The current value to check for or the default, true.
		     * @api private
		     */
		    proto._getOnceReturnValue = function _getOnceReturnValue() {
		        if (this.hasOwnProperty('_onceReturnValue')) {
		            return this._onceReturnValue;
		        }
		        else {
		            return true;
		        }
		    };
		
		    /**
		     * Fetches the events object and creates one if required.
		     *
		     * @return {Object} The events storage object.
		     * @api private
		     */
		    proto._getEvents = function _getEvents() {
		        return this._events || (this._events = {});
		    };
		
		    /**
		     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
		     *
		     * @return {Function} Non conflicting EventEmitter class.
		     */
		    EventEmitter.noConflict = function noConflict() {
		        exports.EventEmitter = originalGlobalValue;
		        return EventEmitter;
		    };
		
		    // Expose the class either via AMD, CommonJS or the global object
		    if (typeof define === 'function' && define.amd) {
		        define(function () {
		            return EventEmitter;
		        });
		    }
		    else if (typeof module === 'object' && module.exports){
		        module.exports = EventEmitter;
		    }
		    else {
		        exports.EventEmitter = EventEmitter;
		    }
		}.call(this));
		
		}.call(window));
	
	/***/ },
	/* 183 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-slider\" :id=\"id\"\n    :class=\"{\n        min: value === 0, max: value === 100, dragging: dragging, disabled: disabled,\n        active: active, 'has-label': hasLabel\n    }\"\n\n    :tabindex=\"disabled ? null : 0\" role=\"slider\" :aria-valuemin=\"0\" :aria-valuemax=\"100\"\n    :aria-valuenow=\"value\"\n\n    @keydown.left.prevent=\"decrement\" @keydown.right.prevent=\"increment\"\n    @keydown.down.prevent=\"decrement\" @keydown.up.prevent=\"increment\"\n    @focus=\"focus\" @blur=\"blur\"\n>\n    <input type=\"hidden\" :value=\"value\" :name=\"name\">\n\n    <div class=\"ui-slider-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-slider-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-slider-content\">\n        <div class=\"ui-slider-label\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n        <div class=\"ui-slider-wrapper\" v-el:slider @mousedown=\"sliderClick\">\n            <div class=\"ui-slider-containment\" v-el:containment></div>\n\n            <div class=\"ui-slider-track\">\n                <div class=\"ui-slider-track-fill\" :style=\"{ width: value + '%'}\"></div>\n            </div>\n\n            <div class=\"ui-slider-thumb-container\" v-el:thumb>\n                <div class=\"ui-slider-focus-ring\"></div>\n                <div class=\"ui-slider-thumb\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 184 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(185)
		__vue_script__ = __webpack_require__(186)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSnackbar.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(187)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSnackbar.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 185 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 186 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiButton = __webpack_require__(109);
		
		var _UiButton2 = _interopRequireDefault(_UiButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-snackbar',
		
		    props: {
		        id: String,
		        show: {
		            type: Boolean,
		            default: false,
		            twoWay: true
		        },
		        message: String,
		        action: String,
		        actionColor: {
		            type: String,
		            default: 'accent' },
		        persistent: {
		            type: Boolean,
		            default: false
		        },
		        duration: {
		            type: Number,
		            default: 5000
		        },
		        autoHide: {
		            type: Boolean,
		            default: true
		        }
		    },
		
		    data: function data() {
		        return {
		            height: 0,
		            timeout: null
		        };
		    },
		    beforeDestroy: function beforeDestroy() {
		        if (this.timeout) {
		            clearTimeout(this.timeout);
		        }
		    },
		
		
		    methods: {
		        click: function click() {
		            this.$dispatch('clicked');
		            this.hide();
		        },
		        actionClick: function actionClick() {
		            this.$dispatch('action-clicked');
		            this.hide();
		        },
		        hide: function hide() {
		            if (!this.persistent) {
		                this.show = false;
		            }
		        }
		    },
		
		    components: {
		        UiButton: _UiButton2.default
		    },
		
		    transitions: {
		        'ui-snackbar-toggle': {
		            afterEnter: function afterEnter() {
		                this.$dispatch('shown');
		
		                if (this.autoHide) {
		                    this.timeout = setTimeout(this.hide, this.duration);
		                }
		            },
		            afterLeave: function afterLeave() {
		                this.$dispatch('hidden');
		
		                if (this.timeout) {
		                    clearTimeout(this.timeout);
		                    this.timeout = null;
		                }
		            }
		        }
		    }
		};
	
	/***/ },
	/* 187 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-snackbar\" :id=\"id\" transition=\"ui-snackbar-toggle\" @click=\"click\" v-show=\"show\"\n>\n    <div class=\"ui-snackbar-text\">\n        <slot>\n            <span v-text=\"message\"></span>\n        </slot>\n    </div>\n\n    <div class=\"ui-snackbar-action\">\n        <ui-button\n            class=\"ui-snackbar-action-button\" type=\"flat\" :color=\"actionColor\"\n            :text=\"action\" @click.stop=\"actionClick\" v-if=\"action\"\n        ></ui-button>\n    </div>\n</div>\n";
	
	/***/ },
	/* 188 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(189)
		__vue_script__ = __webpack_require__(190)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSnackbarContainer.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(191)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSnackbarContainer.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 189 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 190 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _UiSnackbar = __webpack_require__(184);
		
		var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-snackbar-container',
		
		    props: {
		        queueSnackbars: {
		            type: Boolean,
		            default: false
		        },
		        defaultDuration: {
		            type: Number,
		            default: 5000
		        },
		        position: {
		            type: String,
		            default: 'left', coerce: function coerce(position) {
		                return 'position-' + position;
		            }
		        }
		    },
		
		    events: {
		        'ui-snackbar::create': function uiSnackbarCreate(snackbar) {
		            snackbar.show = false;
		            snackbar.id = snackbar.id || _uuid2.default.short('ui-snackbar-');
		            snackbar.duration = snackbar.duration || this.defaultDuration;
		
		            this.queue.push(snackbar);
		
		            if (this.queue.length === 1) {
		                this.showNext();
		            } else {
		                if (!this.queueSnackbars) {
		                    this.queue[0].show = false;
		                }
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            queue: [] };
		    },
		
		
		    methods: {
		        showNext: function showNext() {
		            if (!this.queue.length) {
		                return;
		            }
		
		            this.queue[0].show = true;
		        },
		        shown: function shown(snackbar) {
		            this.$dispatch('snackbar-shown', snackbar);
		            this.callHook('onShow', snackbar);
		        },
		        hidden: function hidden(snackbar) {
		            this.$dispatch('snackbar-hidden', snackbar);
		            this.callHook('onHide', snackbar);
		
		            this.queue.$remove(snackbar);
		            this.showNext();
		        },
		        clicked: function clicked(snackbar) {
		            this.callHook('onClick', snackbar);
		        },
		        actionClicked: function actionClicked(snackbar) {
		            this.callHook('onActionClick', snackbar);
		        },
		        callHook: function callHook(hook, snackbar) {
		            if (typeof snackbar[hook] === 'function') {
		                snackbar[hook].call(undefined, snackbar);
		            }
		        }
		    },
		
		    components: {
		        UiSnackbar: _UiSnackbar2.default
		    }
		};
	
	/***/ },
	/* 191 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-snackbar-container\" :class=\"[position]\">\n    <ui-snackbar\n        :duration=\"s.duration\" :show.sync=\"s.show\" :action=\"s.action\"\n        :action-color=\"s.actionColor\" :persistent=\"s.persistent\" :id=\"s.id\" auto-hide\n\n        @shown=\"shown(s)\" @hidden=\"hidden(s)\" @clicked=\"clicked(s)\"\n        @action-clicked=\"actionClicked(s)\"\n\n        v-for=\"s in queue\"\n    >\n        <div v-html=\"s.message\" v-if=\"s.allowHtml\"></div>\n        <span v-text=\"s.message\" v-else></span>\n    </ui-snackbar>\n</div>\n";
	
	/***/ },
	/* 192 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(193)
		__vue_script__ = __webpack_require__(194)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiSwitch.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(195)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiSwitch.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 193 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 194 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-switch',
		
		    props: {
		        name: String,
		        value: {
		            type: Boolean,
		            required: true,
		            twoWay: true
		        },
		        label: String,
		        hideLabel: {
		            type: Boolean,
		            default: false
		        },
		        labelLeft: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            initialValue: false
		        };
		    },
		    created: function created() {
		        this.initialValue = this.value;
		    },
		
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.value = this.initialValue;
		        }
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 195 */
	/***/ function(module, exports) {
	
		module.exports = "\n<label\n    class=\"ui-switch\"\n    :class=\"{ 'checked': value, 'disabled': disabled, 'label-left': labelLeft }\"\n>\n    <div class=\"ui-switch-container\">\n        <input\n            class=\"ui-switch-input\" type=\"checkbox\" :name=\"name\" :id=\"id\" v-model=\"value\"\n            v-disabled=\"disabled\"\n        >\n\n        <div class=\"ui-switch-track\"></div>\n        <div class=\"ui-switch-thumb\"></div>\n\n        <div class=\"ui-switch-focus-ring\"></div>\n    </div>\n\n    <div class=\"ui-switch-label-text\" v-if=\"!hideLabel\">\n        <slot>\n            <span v-text=\"label\"></span>\n        </slot>\n    </div>\n</label>\n";
	
	/***/ },
	/* 196 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(197)
		__vue_script__ = __webpack_require__(198)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTab.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(199)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTab.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 197 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 198 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = {
		    name: 'ui-tab',
		
		    props: {
		        id: String,
		        header: String,
		        icon: String,
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        active: function active() {
		            return this.$parent.activeTab === this.id;
		        }
		    },
		
		    watch: {
		        active: function active() {
		            if (this.active) {
		                this.$dispatch('selected', this.id);
		            } else {
		                this.$dispatch('deselected', this.id);
		            }
		        }
		    }
		};
	
	/***/ },
	/* 199 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-tab\" :id=\"id\" role=\"tabpanel\" :tabindex=\"active ? '0' : null\"\n    :aria-hidden=\"!active ? 'true' : null\" v-show=\"active\"\n>\n    <slot></slot>\n</div>\n";
	
	/***/ },
	/* 200 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(201)
		__vue_script__ = __webpack_require__(202)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTabs.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(207)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTabs.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 201 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 202 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _uuid = __webpack_require__(88);
		
		var _uuid2 = _interopRequireDefault(_uuid);
		
		var _UiTabHeaderItem = __webpack_require__(203);
		
		var _UiTabHeaderItem2 = _interopRequireDefault(_UiTabHeaderItem);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ReceivesTargetedEvent = __webpack_require__(61);
		
		var _ReceivesTargetedEvent2 = _interopRequireDefault(_ReceivesTargetedEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tabs',
		
		    props: {
		        type: {
		            type: String,
		            default: 'text' },
		        activeTab: String,
		        backgroundColor: {
		            type: String,
		            default: 'default', coerce: function coerce(color) {
		                return 'background-color-' + color;
		            }
		        },
		        textColor: {
		            type: String,
		            default: 'black', coerce: function coerce(color) {
		                return 'text-color-' + color;
		            }
		        },
		        textColorActive: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'text-color-active-' + color;
		            }
		        },
		        indicatorColor: {
		            type: String,
		            default: 'primary', coerce: function coerce(color) {
		                return 'color-' + color;
		            }
		        },
		        fullwidth: {
		            type: Boolean,
		            default: false
		        },
		        raised: {
		            type: Boolean,
		            default: false
		        },
		        hideRippleInk: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    data: function data() {
		        return {
		            activeTabElement: null
		        };
		    },
		
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = ['ui-tabs-type-' + this.type];
		
		            if (this.raised) {
		                classes.push('raised');
		            }
		
		            if (this.fullwidth) {
		                classes.push('fullwidth');
		            }
		
		            return classes;
		        },
		        indicatorLeft: function indicatorLeft() {
		            if (this.activeTabElement) {
		                return this.activeTabElement.offsetLeft + 'px';
		            }
		
		            return 0;
		        },
		        indicatorRight: function indicatorRight() {
		            if (this.activeTabElement) {
		                var left = this.activeTabElement.offsetLeft;
		                var width = this.activeTabElement.offsetWidth;
		                var tabContainerWidth = this.$els.tabsContainer.offsetWidth;
		
		                return tabContainerWidth - (left + width) + 'px';
		            }
		        }
		    },
		
		    ready: function ready() {
		        var _this = this;
		
		        for (var i = 0; i < this.$children.length; i++) {
		            this.$children[i].id = this.$children[i].id || _uuid2.default.short('ui-tab-');
		        }
		
		        this.activeTab = this.activeTab || this.$children[0].id;
		
		        this.$nextTick(function () {
		            if (_this.$els.tabsContainer) {
		                _this.activeTabElement = _this.$els.tabsContainer.querySelector('.active');
		            }
		        });
		    },
		
		
		    events: {
		        'ui-tabs::select': function uiTabsSelect(tabId, id) {
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            var tab = this.findTabById(tabId);
		
		            if (tab) {
		                this.select(tab.$el, tab);
		            }
		        }
		    },
		
		    methods: {
		        select: function select(e, tab) {
		            var newTabElement = e.currentTarget ? e.currentTarget : e;
		
		            if (tab.disabled || this.activeTabElement === newTabElement) {
		                return;
		            }
		
		            this.activeTabElement = newTabElement;
		            this.activeTab = tab.id;
		
		            this.$dispatch('active-tab-changed', tab.id);
		        },
		        selectPrev: function selectPrev(currentTabIndex) {
		            if (currentTabIndex === 0) {
		                return;
		            }
		
		            var prevTab = this.findTab(currentTabIndex);
		            this.select(prevTab.$el, prevTab);
		
		            this.activeTabElement.focus();
		        },
		        selectNext: function selectNext(currentTabIndex) {
		            if (currentTabIndex === this.$refs.tabElements.length - 1) {
		                return;
		            }
		
		            var nextTab = this.findTab(currentTabIndex, true);
		            this.select(nextTab.$el, nextTab);
		
		            this.activeTabElement.focus();
		        },
		        findTab: function findTab(currentTabIndex, next) {
		            var tab = void 0;
		
		            if (next) {
		                for (var i = currentTabIndex + 1; i < this.$refs.tabElements.length; i++) {
		                    if (!this.$refs.tabElements[i].disabled) {
		                        tab = this.$refs.tabElements[i];
		                        break;
		                    }
		                }
		            } else {
		                for (var _i = currentTabIndex - 1; _i >= 0; _i--) {
		                    if (!this.$refs.tabElements[_i].disabled) {
		                        tab = this.$refs.tabElements[_i];
		                        break;
		                    }
		                }
		            }
		
		            tab = tab || this.$refs.tabElements[currentTabIndex];
		
		            return tab;
		        },
		        findTabById: function findTabById(id) {
		            var tab = null;
		
		            var numOfTabs = this.$refs.tabElements.length;
		
		            for (var i = 0; i <= numOfTabs; i++) {
		                if (id === this.$refs.tabElements[i].id) {
		                    tab = this.$refs.tabElements[i];
		                    break;
		                }
		            }
		
		            return tab;
		        }
		    },
		
		    components: {
		        UiTabHeaderItem: _UiTabHeaderItem2.default
		    },
		
		    directives: {
		        disabled: _disabled2.default
		    },
		
		    mixins: [_ReceivesTargetedEvent2.default]
		};
	
	/***/ },
	/* 203 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(204)
		__vue_script__ = __webpack_require__(205)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTabHeaderItem.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(206)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTabHeaderItem.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 204 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 205 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _disabled = __webpack_require__(71);
		
		var _disabled2 = _interopRequireDefault(_disabled);
		
		var _ShowsRippleInk = __webpack_require__(19);
		
		var _ShowsRippleInk2 = _interopRequireDefault(_ShowsRippleInk);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-tab-header-item',
		
		    props: {
		        id: String,
		        type: {
		            type: String,
		            default: 'text' },
		        text: String,
		        icon: String,
		        active: {
		            type: Boolean,
		            default: false
		        },
		        disabled: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    mixins: [_ShowsRippleInk2.default],
		
		    directives: {
		        disabled: _disabled2.default
		    }
		};
	
	/***/ },
	/* 206 */
	/***/ function(module, exports) {
	
		module.exports = "\n<li\n    class=\"ui-tab-header-item\" role=\"tab\"\n    :class=\"['type-' + type, { 'active': active, 'disabled': disabled }]\"\n\n    :tabindex=\"active ? 0 : -1\" :aria-controls=\"id\" :aria-selected=\"active ? 'true' : null\"\n    v-disabled=\"disabled\" v-el:item\n>\n    <div\n        class=\"ui-tab-header-item-icon\" v-if=\"type === 'icon' || type === 'icon-and-text'\"\n    >\n        <ui-icon :icon=\"icon\"></ui-icon>\n    </div>\n\n    <div\n        class=\"ui-tab-header-item-text\" v-text=\"text\"\n        v-if=\"type === 'text' || type === 'icon-and-text'\"\n    ></div>\n\n    <ui-ripple-ink :trigger=\"$els.item\" v-if=\"!hideRippleInk && !disabled\"></ui-ripple-ink>\n</li>\n";
	
	/***/ },
	/* 207 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-tabs\" :class=\"styleClasses\">\n    <div class=\"ui-tabs-header\" :class=\"[backgroundColor]\">\n        <ul\n            class=\"ui-tabs-header-items\" :class=\"[textColor, textColorActive]\" role=\"tablist\"\n            v-el:tabs-container\n        >\n            <ui-tab-header-item\n                :type=\"type\" :id=\"tab.id\" :icon=\"tab.icon\" :text=\"tab.header\"\n                :active=\"activeTab === tab.id\" :disabled=\"tab.disabled\"\n                :hide-ripple-ink=\"hideRippleInk\"\n\n                @click=\"select($event, tab)\" @keydown.left=\"selectPrev(index)\"\n                @keydown.right=\"selectNext($index)\"\n\n                v-for=\"(index, tab) in $children\" v-ref:tab-elements\n            ></ui-tab-header-item>\n        </ul>\n\n        <div\n            class=\"ui-tabs-active-tab-indicator\" :class=\"[indicatorColor]\"\n            :style=\"{ 'left': indicatorLeft, 'right': indicatorRight }\"\n        ></div>\n    </div>\n\n    <div class=\"ui-tabs-body\">\n        <slot></slot>\n    </div>\n</div>\n";
	
	/***/ },
	/* 208 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(209)
		__vue_script__ = __webpack_require__(210)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiTextbox.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(211)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiTextbox.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 209 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 210 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiIcon = __webpack_require__(6);
		
		var _UiIcon2 = _interopRequireDefault(_UiIcon);
		
		var _autofocus = __webpack_require__(90);
		
		var _autofocus2 = _interopRequireDefault(_autofocus);
		
		var _HasTextInput = __webpack_require__(91);
		
		var _HasTextInput2 = _interopRequireDefault(_HasTextInput);
		
		var _ValidatesInput = __webpack_require__(92);
		
		var _ValidatesInput2 = _interopRequireDefault(_ValidatesInput);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-textbox',
		
		    props: {
		        type: {
		            type: String,
		            default: 'text'
		        },
		        multiLine: {
		            type: Boolean,
		            default: false
		        },
		        rows: {
		            type: Number,
		            default: 2
		        },
		        maxLength: Number,
		        trimValue: {
		            type: Boolean,
		            default: true
		        },
		        validateOnBlur: {
		            type: Boolean,
		            default: false
		        },
		        autocomplete: String,
		        autofocus: {
		            type: Boolean,
		            default: false
		        },
		        min: Number,
		        max: Number,
		        step: {
		            type: String,
		            default: 'any',
		            coerce: String
		        }
		    },
		
		    watch: {
		        value: function value() {
		            if (this.ignoreValueChange) {
		                return;
		            }
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            if (!this.validateOnBlur) {
		                this.validate();
		            }
		        }
		    },
		
		    data: function data() {
		        return {
		            ignoreValueChange: false
		        };
		    },
		
		
		    computed: {
		        showIcon: function showIcon() {
		            return Boolean(this.icon);
		        },
		        minValue: function minValue() {
		            if (this.type !== 'number') {
		                return null;
		            }
		
		            if (this.min || this.min === 0) {
		                return this.min;
		            }
		
		            return null;
		        },
		        maxValue: function maxValue() {
		            if (this.type !== 'number') {
		                return null;
		            }
		
		            if (this.max || this.max === 0) {
		                return this.max;
		            }
		
		            return null;
		        },
		        stepValue: function stepValue() {
		            if (this.type === 'number') {
		                return this.step;
		            }
		
		            return null;
		        }
		    },
		
		    events: {
		        'ui-input::reset': function uiInputReset(id) {
		            var _this = this;
		
		            if (!this.eventTargetsComponent(id)) {
		                return;
		            }
		
		            this.ignoreValueChange = true;
		
		            if (document.activeElement === this.$el.querySelector('input') || document.activeElement === this.$el.querySelector('textarea')) {
		                document.activeElement.blur();
		            }
		
		            this.validationError = '';
		            this.value = this.initialValue;
		            this.valid = true;
		            this.dirty = false;
		
		            this.$nextTick(function () {
		                _this.ignoreValueChange = false;
		            });
		        }
		    },
		
		    methods: {
		        focussed: function focussed() {
		            this.active = true;
		            this.$dispatch('focussed');
		        },
		        blurred: function blurred() {
		            this.active = false;
		
		            if (!this.dirty) {
		                this.dirty = true;
		            }
		
		            this.$dispatch('blurred');
		            this.validate();
		        },
		        changed: function changed() {
		            this.$dispatch('changed');
		        },
		        keydown: function keydown(e) {
		            this.$dispatch('keydown', e);
		        },
		        keydownEnter: function keydownEnter(e) {
		            this.$dispatch('keydown-enter', e);
		        }
		    },
		
		    filters: {
		        trim: {
		            write: function write(value) {
		                if (this.type !== 'number' && this.trimValue) {
		                    return value.trim();
		                }
		
		                return value;
		            }
		        }
		    },
		
		    components: {
		        UiIcon: _UiIcon2.default
		    },
		
		    directives: {
		        autofocus: _autofocus2.default
		    },
		
		    mixins: [_HasTextInput2.default, _ValidatesInput2.default]
		};
	
	/***/ },
	/* 211 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div\n    class=\"ui-textbox\"\n    :class=\"{\n        'disabled': disabled, 'invalid': !valid, 'dirty': dirty, 'active': active,\n        'has-label': !hideLabel, 'is-multi-line': multiLine, 'icon-right': iconRight,\n        'has-counter': maxLength\n    }\"\n>\n    <div class=\"ui-textbox-icon-wrapper\" v-if=\"showIcon\">\n        <ui-icon :icon=\"icon\" class=\"ui-textbox-icon\"></ui-icon>\n    </div>\n\n    <div class=\"ui-textbox-content\">\n        <label class=\"ui-textbox-label\">\n            <div class=\"ui-textbox-label-text\" v-text=\"label\" v-if=\"!hideLabel\"></div>\n\n            <input\n                class=\"ui-textbox-input\" :type=\"type\" :placeholder=\"placeholder\" :name=\"name\"\n                :id=\"id\" :number=\"type === 'number' ? true : null\" :min=\"minValue\"\n                :max=\"maxValue\" :step=\"stepValue\"\n                :autocomplete=\"autocomplete ? autocomplete : null\"\n\n                @focus=\"focussed\" @blur=\"blurred\" @change=\"changed\" @keydown=\"keydown\"\n                @keydown.enter=\"keydownEnter\" :debounce=\"debounce\"\n\n                v-model=\"value | trim\" v-disabled=\"disabled\" v-if=\"!multiLine\"\n                v-autofocus=\"autofocus\"\n            >\n\n            <textarea\n                class=\"ui-textbox-textarea\" :placeholder=\"placeholder\" :name=\"name\" :id=\"id\"\n                :rows=\"rows\"\n\n                @focus=\"focussed\" @blur=\"blurred\" @change=\"changed\" @keydown=\"keydown\"\n                @keydown.enter=\"keydownEnter\" :debounce=\"debounce\"\n\n                v-model=\"value | trim\" v-disabled=\"disabled\" v-else\n            ></textarea>\n        </label>\n\n        <div class=\"ui-textbox-feedback\" v-if=\"showFeedback || maxLength\">\n            <div\n                class=\"ui-textbox-error-text\" transition=\"ui-textbox-feedback-toggle\"\n                v-text=\"validationError\" v-show=\"!hideValidationErrors && !valid\"\n            ></div>\n\n            <div\n                class=\"ui-textbox-help-text\" transition=\"ui-textbox-feedback-toggle\"\n                v-text=\"helpText\" v-else\n            ></div>\n\n            <div\n                class=\"ui-textbox-counter\" v-text=\"value.length + '/' + maxLength\"\n                v-if=\"maxLength\"\n            ></div>\n        </div>\n    </div>\n</div>\n";
	
	/***/ },
	/* 212 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __vue_script__, __vue_template__
		__webpack_require__(213)
		__vue_script__ = __webpack_require__(214)
		if (__vue_script__ &&
		    __vue_script__.__esModule &&
		    Object.keys(__vue_script__).length > 1) {
		  console.warn("[vue-loader] src\\UiToolbar.vue: named exports in *.vue files are ignored.")}
		__vue_template__ = __webpack_require__(215)
		module.exports = __vue_script__ || {}
		if (module.exports.__esModule) module.exports = module.exports.default
		if (__vue_template__) {
		(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
		}
		if (false) {(function () {  module.hot.accept()
		  var hotAPI = require("vue-hot-reload-api")
		  hotAPI.install(require("vue"), true)
		  if (!hotAPI.compatible) return
		  var id = "C:\\code\\packages\\keen-ui\\src\\UiToolbar.vue"
		  if (!module.hot.data) {
		    hotAPI.createRecord(id, module.exports)
		  } else {
		    hotAPI.update(id, module.exports, __vue_template__)
		  }
		})()}
	
	/***/ },
	/* 213 */
	/***/ function(module, exports) {
	
		// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 214 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _UiProgressLinear = __webpack_require__(137);
		
		var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);
		
		var _UiIconButton = __webpack_require__(10);
		
		var _UiIconButton2 = _interopRequireDefault(_UiIconButton);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = {
		    name: 'ui-toolbar',
		
		    props: {
		        type: {
		            type: String,
		            default: 'default', coerce: function coerce(type) {
		                return 'ui-toolbar-' + type;
		            }
		        },
		        textColor: {
		            type: String,
		            default: 'black', coerce: function coerce(color) {
		                return 'text-color-' + color;
		            }
		        },
		        title: String,
		        brand: String,
		        showBrand: {
		            type: Boolean,
		            default: false
		        },
		        showBrandDivider: {
		            type: Boolean,
		            default: null
		        },
		        navIcon: {
		            type: String,
		            default: 'menu'
		        },
		        hideNavIcon: {
		            type: Boolean,
		            default: false
		        },
		        flat: {
		            type: Boolean,
		            default: false
		        },
		        preloaderTop: {
		            type: Boolean,
		            default: false
		        },
		        loading: {
		            type: Boolean,
		            default: false
		        }
		    },
		
		    computed: {
		        styleClasses: function styleClasses() {
		            var classes = [this.type, this.textColor];
		
		            if (!this.flat) {
		                classes.push('ui-toolbar-raised');
		            }
		
		            return classes;
		        },
		        iconColor: function iconColor() {
		            if (this.textColor === 'text-color-black') {
		                return 'black';
		            }
		
		            return 'white';
		        },
		        preloaderColor: function preloaderColor() {
		            if (this.textColor === 'text-color-black') {
		                return 'primary';
		            }
		
		            return 'white';
		        },
		        brandDividerVisible: function brandDividerVisible() {
		            if (this.showBrandDivider !== null) {
		                return this.showBrandDivider;
		            }
		
		            if (!this.showBrand) {
		                return false;
		            }
		
		            return true;
		        }
		    },
		
		    methods: {
		        navIconClick: function navIconClick() {
		            this.$dispatch('nav-icon-clicked');
		        }
		    },
		
		    components: {
		        UiProgressLinear: _UiProgressLinear2.default,
		        UiIconButton: _UiIconButton2.default
		    }
		};
	
	/***/ },
	/* 215 */
	/***/ function(module, exports) {
	
		module.exports = "\n<div class=\"ui-toolbar\" :class=\"styleClasses\">\n    <div class=\"ui-toolbar-left\">\n        <ui-icon-button\n            class=\"ui-toolbar-nav-icon\" type=\"clear\" :color=\"iconColor\" :icon=\"navIcon\"\n            @click=\"navIconClick\" v-if=\"!hideNavIcon\"\n        ></ui-icon-button>\n\n        <div class=\"ui-toolbar-brand\" v-if=\"showBrand\">\n            <slot name=\"brand\">\n                <div class=\"ui-toolbar-brand-text\" v-text=\"brand\"></div>\n            </slot>\n        </div>\n    </div>\n\n    <div class=\"ui-toolbar-center\">\n        <div class=\"ui-toolbar-divider\" v-if=\"brandDividerVisible\"></div>\n\n        <slot>\n            <div class=\"ui-toolbar-title\" v-text=\"title\"></div>\n        </slot>\n    </div>\n\n    <div class=\"ui-toolbar-right\">\n        <slot name=\"actions\"></slot>\n    </div>\n\n    <ui-progress-linear\n        :show=\"loading\" class=\"ui-toolbar-preloader\" :class=\"{ 'position-top' : preloaderTop }\"\n        :color=\"preloaderColor\"\n    ></ui-progress-linear>\n</div>\n";
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=keen-ui.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(8)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(232)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7ca1b1bb/App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 6 */,
/* 7 */,
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _MapView = __webpack_require__(9);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _ParamsView = __webpack_require__(144);
	
	var _ParamsView2 = _interopRequireDefault(_ParamsView);
	
	var _SettingsView = __webpack_require__(152);
	
	var _SettingsView2 = _interopRequireDefault(_SettingsView);
	
	var _GcsIndicators = __webpack_require__(156);
	
	var _GcsIndicators2 = _interopRequireDefault(_GcsIndicators);
	
	var _SocketIoManager = __webpack_require__(160);
	
	var _SocketIoManager2 = _interopRequireDefault(_SocketIoManager);
	
	var _GcsEditMissionModal = __webpack_require__(224);
	
	var _GcsEditMissionModal2 = _interopRequireDefault(_GcsEditMissionModal);
	
	var _controllerManager = __webpack_require__(227);
	
	var _controllerManager2 = _interopRequireDefault(_controllerManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    data: function data() {
	        return {
	            showEditMissionModal: false
	        };
	    },
	    ready: function ready() {
	        new _controllerManager2.default(this.controllerEvent);
	    },
	
	
	    events: {
	        'app::create-snackbar': function appCreateSnackbar(message, snackbar) {
	            this.createSnackbar(message, snackbar);
	        },
	        'app::show-edit-mission-modal': function appShowEditMissionModal() {
	            this.showEditMissionModal = true;
	        },
	        'map::pan-up': function mapPanUp() {
	            this.$broadcast('map::pan-up');
	        },
	        'map::pan-down': function mapPanDown() {
	            this.$broadcast('map::pan-down');
	        },
	        'map::pan-left': function mapPanLeft() {
	            this.$broadcast('map::pan-left');
	        },
	        'map::pan-right': function mapPanRight() {
	            this.$broadcast('map::pan-right');
	        },
	        'map::pan-center': function mapPanCenter() {
	            this.$broadcast('map::pan-center');
	        },
	        'map::zoom-in': function mapZoomIn() {
	            this.$broadcast('map::zoom-in');
	        },
	        'map::zoom-out': function mapZoomOut() {
	            this.$broadcast('map::zoom-out');
	        },
	        'map::change-type': function mapChangeType(newType) {
	            this.$broadcast('map::change-type', newType);
	        },
	        'map:click': function mapClick(e) {
	            this.$broadcast('map:click', e);
	        },
	        'map:dblclick': function mapDblclick(e) {
	            this.$broadcast('map:dblclick', e);
	        },
	        'map:rightclick': function mapRightclick(e) {
	            this.$broadcast('map:rightclick', e);
	        },
	        'client::get_parameters': function clientGet_parameters() {
	            this.$broadcast('client::get_parameters');
	        },
	        'client::set_parameters': function clientSet_parameters(params) {
	            this.$broadcast('client::set_parameters', params);
	        },
	        'client::get_settings': function clientGet_settings() {
	            this.$broadcast('client::get_settings');
	        },
	        'client::set_settings': function clientSet_settings(settings) {
	            this.$broadcast('client::set_settings', settings);
	        },
	        'client::set_missions': function clientSet_missions(missions) {
	            this.$broadcast('client::set_missions', missions);
	        },
	        'client::get_missions': function clientGet_missions() {
	            this.$broadcast('client::get_missions');
	        },
	        'client::set_mission': function clientSet_mission(mission) {
	            this.$broadcast('client::set_mission', mission);
	        },
	        'client::get_mission': function clientGet_mission() {
	            this.$broadcast('client::get_mission');
	        },
	        'client::arm': function clientArm() {
	            this.$broadcast('client::arm');
	        },
	        'client::disarm': function clientDisarm() {
	            this.$broadcast('client::disarm');
	        },
	        'client::start_mission': function clientStart_mission() {
	            this.$broadcast('client::start_mission');
	        },
	        'client::stop_mission': function clientStop_mission() {
	            this.$broadcast('client::stop_mission');
	        },
	        'client::resume_mission': function clientResume_mission() {
	            this.$broadcast('client::resume_mission');
	        },
	        'client::kill': function clientKill() {
	            this.$broadcast('client::kill');
	        },
	        'client::unkill': function clientUnkill() {
	            this.$broadcast('client::unkill');
	        },
	        'client::manual': function clientManual() {
	            this.$broadcast('client::manual');
	        },
	        'client::auto': function clientAuto() {
	            this.$broadcast('client::auto');
	        },
	        'server::set_parameters_ack': function serverSet_parameters_ack() {
	            this.$broadcast('server::set_parameters_ack');
	        },
	        'server::set_settings_ack': function serverSet_settings_ack() {
	            this.$broadcast('server::set_settings_ack');
	        },
	        'server::set_mission_ack': function serverSet_mission_ack() {
	            this.$broadcast('server::set_mission_ack');
	        }
	    },
	
	    methods: {
	        controllerEvent: function controllerEvent(event, data) {
	            console.info(event, data);
	            this.$broadcast('client::controller_event', data);
	        },
	        createSnackbar: function createSnackbar(message, snackbar) {
	            snackbar = snackbar || {
	                message: message
	            };
	
	            this.$broadcast('ui-snackbar::create', snackbar);
	        }
	    },
	
	    components: {
	        MapView: _MapView2.default,
	        ParamsView: _ParamsView2.default,
	        SettingsView: _SettingsView2.default,
	        GcsIndicators: _GcsIndicators2.default,
	        SocketIoManager: _SocketIoManager2.default,
	        GcsEditMissionModal: _GcsEditMissionModal2.default
	    }
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(10)
	__vue_script__ = __webpack_require__(11)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\views\\MapView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(143)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-106887fa/MapView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 10 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsMap = __webpack_require__(12);
	
	var _GcsMap2 = _interopRequireDefault(_GcsMap);
	
	var _GcsMapControls = __webpack_require__(74);
	
	var _GcsMapControls2 = _interopRequireDefault(_GcsMapControls);
	
	var _GcsMapSidebar = __webpack_require__(78);
	
	var _GcsMapSidebar2 = _interopRequireDefault(_GcsMapSidebar);
	
	var _GcsCommands = __webpack_require__(131);
	
	var _GcsCommands2 = _interopRequireDefault(_GcsCommands);
	
	var _GcsSidebarControls = __webpack_require__(135);
	
	var _GcsSidebarControls2 = _interopRequireDefault(_GcsSidebarControls);
	
	var _GcsWamv = __webpack_require__(139);
	
	var _GcsWamv2 = _interopRequireDefault(_GcsWamv);
	
	var _getters = __webpack_require__(72);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    data: function data() {
	        return {
	            showSidebar: true
	        };
	    },
	
	
	    methods: {
	        toggleSidebar: function toggleSidebar() {
	            this.showSidebar = !this.showSidebar;
	        }
	    },
	
	    components: {
	        GcsMap: _GcsMap2.default,
	        GcsWamv: _GcsWamv2.default,
	        GcsMapControls: _GcsMapControls2.default,
	        GcsMapSidebar: _GcsMapSidebar2.default,
	        GcsSidebarControls: _GcsSidebarControls2.default,
	        GcsCommands: _GcsCommands2.default
	    }
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(13)
	__vue_script__ = __webpack_require__(14)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsMap.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(73)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-18281c25/GcsMap.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 13 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(15);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _loadGoogleMapsApi = __webpack_require__(68);
	
	var _loadGoogleMapsApi2 = _interopRequireDefault(_loadGoogleMapsApi);
	
	var _actions = __webpack_require__(69);
	
	var _getters = __webpack_require__(72);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapEl: _getters.getMapEl,
	            mapLoaded: _getters.getMapLoaded,
	            mapEditing: _getters.getMapEditing,
	            wamv: _getters.getWamv,
	            settings: _getters.getSettings,
	            settingsLastUpdateTime: _getters.getSettingsLastUpdateTime
	        },
	
	        actions: {
	            setMap: _actions.setMap,
	            setMapEl: _actions.setMapEl,
	            setMapLoaded: _actions.setMapLoaded
	        }
	    },
	
	    watch: {
	        mapEditing: function mapEditing() {
	            if (!this.mapLoaded) {
	                return;
	            }
	
	            if (this.mapEditing) {
	                this.map.setOptions({ draggableCursor: 'crosshair' });
	            } else {
	                this.map.setOptions({ draggableCursor: 'move' });
	            }
	        },
	        settingsLastUpdateTime: function settingsLastUpdateTime() {
	            if (this.mapLoaded) {
	                return;
	            }
	
	            this.setMapEl(document.getElementById('map'));
	
	            var key = null;
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                SearchKey: for (var _iterator = (0, _getIterator3.default)(this.settings), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var section = _step.value;
	
	                    if (section.title === 'Map') {
	                        var _iteratorNormalCompletion2 = true;
	                        var _didIteratorError2 = false;
	                        var _iteratorError2 = undefined;
	
	                        try {
	                            for (var _iterator2 = (0, _getIterator3.default)(section.settings), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                                var setting = _step2.value;
	
	                                if (setting.title === 'key') {
	                                    key = setting.value;
	                                    break SearchKey;
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError2 = true;
	                            _iteratorError2 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                    _iterator2.return();
	                                }
	                            } finally {
	                                if (_didIteratorError2) {
	                                    throw _iteratorError2;
	                                }
	                            }
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            if (key === null) {
	                console.log('Unable to find Google Maps key');
	            } else {
	                (0, _loadGoogleMapsApi2.default)({ key: key, v: 3 }).then(this.initializeMap).catch(function (error) {
	                    console.log('Unable to load Google Maps API', error);
	                });
	            }
	        }
	    },
	
	    events: {
	        'map::pan-up': function mapPanUp() {
	            if (this.mapLoaded) {
	                this.map.panBy(0, -1 * (this.mapEl.clientHeight / 4));
	            }
	        },
	        'map::pan-down': function mapPanDown() {
	            if (this.mapLoaded) {
	                this.map.panBy(0, this.mapEl.clientHeight / 4);
	            }
	        },
	        'map::pan-left': function mapPanLeft() {
	            if (this.mapLoaded) {
	                this.map.panBy(-1 * (this.mapEl.clientWidth / 4), 0);
	            }
	        },
	        'map::pan-right': function mapPanRight() {
	            if (this.mapLoaded) {
	                this.map.panBy(this.mapEl.clientWidth / 4, 0);
	            }
	        },
	        'map::pan-center': function mapPanCenter() {
	            if (this.mapLoaded && this.wamv.loaded) {
	                this.map.panTo(this.wamv.position);
	            }
	        },
	        'map::zoom-in': function mapZoomIn() {
	            if (this.mapLoaded && this.wamv.loaded) {
	                this.map.setZoom(this.map.getZoom() + 1);
	            }
	        },
	        'map::zoom-out': function mapZoomOut() {
	            if (this.mapLoaded && this.wamv.loaded) {
	                this.map.setZoom(this.map.getZoom() - 1);
	            }
	        },
	        'map::change-type': function mapChangeType(newType) {
	            if (this.mapLoaded && this.wamv.loaded) {
	                this.map.setMapTypeId(google.maps.MapTypeId[newType]);
	            }
	        }
	    },
	
	    methods: {
	        initializeMap: function initializeMap() {
	            var lat = null,
	                lng = null,
	                zoom = null;
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = (0, _getIterator3.default)(this.settings), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var section = _step3.value;
	
	                    if (section.title === 'Map') {
	                        var _iteratorNormalCompletion4 = true;
	                        var _didIteratorError4 = false;
	                        var _iteratorError4 = undefined;
	
	                        try {
	                            for (var _iterator4 = (0, _getIterator3.default)(section.settings), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                                var setting = _step4.value;
	
	                                if (setting.title === 'lat') {
	                                    lat = setting.value;
	                                } else if (setting.title === 'lng') {
	                                    lng = setting.value;
	                                } else if (setting.title === 'zoom') {
	                                    zoom = setting.value;
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError4 = true;
	                            _iteratorError4 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                                    _iterator4.return();
	                                }
	                            } finally {
	                                if (_didIteratorError4) {
	                                    throw _iteratorError4;
	                                }
	                            }
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            if (lat === null || lng === null || zoom === null) {
	                console.log('Could not find lng/lng/zoom setting');
	            } else {
	                var map = new google.maps.Map(this.mapEl, {
	                    center: {
	                        lat: parseFloat(lat),
	                        lng: parseFloat(lng)
	                    },
	                    zoom: parseFloat(zoom),
	                    mapTypeId: google.maps.MapTypeId.SATELLITE,
	                    disableDefaultUI: true,
	                    disableDoubleClickZoom: true,
	                    tilt: 0
	                });
	                this.setupEvents(map);
	                this.setMap(map);
	                this.setMapLoaded(true);
	            }
	        },
	        setupEvents: function setupEvents(map) {
	            var _this = this;
	
	            map.addListener('click', function (e) {
	                _this.$dispatch('map:click', e);
	            });
	
	            map.addListener('dblclick', function (e) {
	                _this.$dispatch('map:dblclick', e);
	            });
	
	            map.addListener('rightclick', function (e) {
	                _this.$dispatch('map:rightclick', e);
	            });
	        }
	    }
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(16), __esModule: true };

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(17);
	__webpack_require__(63);
	module.exports = __webpack_require__(65);

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(18);
	var global        = __webpack_require__(29)
	  , hide          = __webpack_require__(33)
	  , Iterators     = __webpack_require__(21)
	  , TO_STRING_TAG = __webpack_require__(60)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(19)
	  , step             = __webpack_require__(20)
	  , Iterators        = __webpack_require__(21)
	  , toIObject        = __webpack_require__(22);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(26)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(23)
	  , defined = __webpack_require__(25);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(24);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(27)
	  , $export        = __webpack_require__(28)
	  , redefine       = __webpack_require__(43)
	  , hide           = __webpack_require__(33)
	  , has            = __webpack_require__(44)
	  , Iterators      = __webpack_require__(21)
	  , $iterCreate    = __webpack_require__(45)
	  , setToStringTag = __webpack_require__(59)
	  , getPrototypeOf = __webpack_require__(61)
	  , ITERATOR       = __webpack_require__(60)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(29)
	  , core      = __webpack_require__(30)
	  , ctx       = __webpack_require__(31)
	  , hide      = __webpack_require__(33)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 29 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 30 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(32);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(34)
	  , createDesc = __webpack_require__(42);
	module.exports = __webpack_require__(38) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(35)
	  , IE8_DOM_DEFINE = __webpack_require__(37)
	  , toPrimitive    = __webpack_require__(41)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(38) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(36);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(38) && !__webpack_require__(39)(function(){
	  return Object.defineProperty(__webpack_require__(40)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(39)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(36)
	  , document = __webpack_require__(29).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(36);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(33);

/***/ },
/* 44 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(46)
	  , descriptor     = __webpack_require__(42)
	  , setToStringTag = __webpack_require__(59)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(33)(IteratorPrototype, __webpack_require__(60)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(35)
	  , dPs         = __webpack_require__(47)
	  , enumBugKeys = __webpack_require__(57)
	  , IE_PROTO    = __webpack_require__(54)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(40)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(58).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(34)
	  , anObject = __webpack_require__(35)
	  , getKeys  = __webpack_require__(48);
	
	module.exports = __webpack_require__(38) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(49)
	  , enumBugKeys = __webpack_require__(57);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(44)
	  , toIObject    = __webpack_require__(22)
	  , arrayIndexOf = __webpack_require__(50)(false)
	  , IE_PROTO     = __webpack_require__(54)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(22)
	  , toLength  = __webpack_require__(51)
	  , toIndex   = __webpack_require__(53);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(52)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(52)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(55)('keys')
	  , uid    = __webpack_require__(56);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(29)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 56 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 57 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(29).document && document.documentElement;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(34).f
	  , has = __webpack_require__(44)
	  , TAG = __webpack_require__(60)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(55)('wks')
	  , uid        = __webpack_require__(56)
	  , Symbol     = __webpack_require__(29).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(44)
	  , toObject    = __webpack_require__(62)
	  , IE_PROTO    = __webpack_require__(54)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(25);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(64)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(26)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(52)
	  , defined   = __webpack_require__(25);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(35)
	  , get      = __webpack_require__(66);
	module.exports = __webpack_require__(30).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(67)
	  , ITERATOR  = __webpack_require__(60)('iterator')
	  , Iterators = __webpack_require__(21);
	module.exports = __webpack_require__(30).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(24)
	  , TAG = __webpack_require__(60)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 68 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var client = _ref.client;
	  var key = _ref.key;
	  var language = _ref.language;
	  var _ref$libraries = _ref.libraries;
	  var libraries = _ref$libraries === undefined ? [] : _ref$libraries;
	  var _ref$timeout = _ref.timeout;
	  var timeout = _ref$timeout === undefined ? 10000 : _ref$timeout;
	  var v = _ref.v;
	
	  var callbackName = '__googleMapsApiOnLoadCallback';
	
	  return new Promise(function (resolve, reject) {
	
	    // Exit if not running inside a browser.
	    if (typeof window === 'undefined') {
	      return reject(new Error('Can only load the Google Maps API in the browser'));
	    }
	
	    // Prepare the `script` tag to be inserted into the page.
	    var scriptElement = document.createElement('script');
	    var params = ['callback=' + callbackName];
	    if (client) params.push('client=' + client);
	    if (key) params.push('key=' + key);
	    if (language) params.push('language=' + language);
	    libraries = [].concat(libraries); // Ensure that `libraries` is an array
	    if (libraries.length) params.push('libraries=' + libraries.join(','));
	    if (v) params.push('v=' + v);
	    scriptElement.src = 'https://maps.googleapis.com/maps/api/js?' + params.join('&');
	
	    // Timeout if necessary.
	    var timeoutId = null;
	    if (timeout) {
	      timeoutId = setTimeout(function () {
	        window[callbackName] = function () {}; // Set the on load callback to a no-op.
	        reject(new Error('Could not load the Google Maps API'));
	      }, timeout);
	    }
	
	    // Hook up the on load callback.
	    window[callbackName] = function () {
	      if (timeoutId !== null) {
	        clearTimeout(timeoutId);
	      }
	      resolve(window.google.maps);
	      delete window[callbackName];
	    };
	
	    // Insert the `script` tag.
	    document.body.appendChild(scriptElement);
	  });
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setMap = setMap;
	exports.setMapEl = setMapEl;
	exports.setMapLoaded = setMapLoaded;
	exports.setWaypointsVisible = setWaypointsVisible;
	exports.setWamv = setWamv;
	exports.setWamvArmed = setWamvArmed;
	exports.setWamvMode = setWamvMode;
	exports.setSettings = setSettings;
	exports.setMissions = setMissions;
	exports.setCurrentMissionIndex = setCurrentMissionIndex;
	exports.setCurrentMissionTitle = setCurrentMissionTitle;
	exports.setParameters = setParameters;
	
	var _deepAssign = __webpack_require__(70);
	
	var _deepAssign2 = _interopRequireDefault(_deepAssign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function setMap(_ref, map) {
	  var dispatch = _ref.dispatch;
	  var state = _ref.state;
	
	  dispatch('SET_MAP', map);
	}
	
	function setMapEl(_ref2, mapEl) {
	  var dispatch = _ref2.dispatch;
	  var state = _ref2.state;
	
	  dispatch('SET_MAP_EL', mapEl);
	}
	
	function setMapLoaded(_ref3, loaded) {
	  var dispatch = _ref3.dispatch;
	  var state = _ref3.state;
	
	  dispatch('SET_MAP_LOADED', loaded);
	}
	
	function setWaypointsVisible(_ref4, visible) {
	  var dispatch = _ref4.dispatch;
	  var state = _ref4.state;
	
	  dispatch('SET_WAYPOINTS_VISIBLE', visible);
	}
	
	function setWamv(_ref5, wamv) {
	  var dispatch = _ref5.dispatch;
	  var state = _ref5.state;
	
	  dispatch('SET_WAMV', wamv);
	}
	
	function setWamvArmed(_ref6, armed) {
	  var dispatch = _ref6.dispatch;
	  var state = _ref6.state;
	
	  dispatch('SET_WAMV_ARMED', armed);
	}
	
	function setWamvMode(_ref7, mode) {
	  var dispatch = _ref7.dispatch;
	  var state = _ref7.state;
	
	  dispatch('SET_WAMV_MODE', mode);
	}
	
	function setSettings(_ref8, settings) {
	  var dispatch = _ref8.dispatch;
	  var state = _ref8.state;
	
	  dispatch('SET_SETTINGS', settings);
	}
	
	function setMissions(_ref9, missions) {
	  var dispatch = _ref9.dispatch;
	  var state = _ref9.state;
	
	  dispatch('SET_MISSIONS', missions);
	}
	
	function setCurrentMissionIndex(_ref10, index) {
	  var dispatch = _ref10.dispatch;
	  var state = _ref10.state;
	
	  dispatch('SET_CURRENT_MISSION_INDEX', index);
	}
	
	function setCurrentMissionTitle(_ref11, title) {
	  var dispatch = _ref11.dispatch;
	  var state = _ref11.state;
	
	  dispatch('SET_CURRENT_MISSION_TITLE', title);
	}
	
	function setParameters(_ref12, parameters) {
	  var dispatch = _ref12.dispatch;
	  var state = _ref12.state;
	
	  dispatch('SET_PARAMETERS', parameters);
	}

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObj = __webpack_require__(71);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Sources cannot be null or undefined');
		}
	
		return Object(val);
	}
	
	function assignKey(to, from, key) {
		var val = from[key];
	
		if (val === undefined || val === null) {
			return;
		}
	
		if (hasOwnProperty.call(to, key)) {
			if (to[key] === undefined || to[key] === null) {
				throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
			}
		}
	
		if (!hasOwnProperty.call(to, key) || !isObj(val)) {
			to[key] = val;
		} else {
			to[key] = assign(Object(to[key]), from[key]);
		}
	}
	
	function assign(to, from) {
		if (to === from) {
			return to;
		}
	
		from = Object(from);
	
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				assignKey(to, from, key);
			}
		}
	
		if (Object.getOwnPropertySymbols) {
			var symbols = Object.getOwnPropertySymbols(from);
	
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					assignKey(to, from, symbols[i]);
				}
			}
		}
	
		return to;
	}
	
	module.exports = function deepAssign(target) {
		target = toObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			assign(target, arguments[s]);
		}
	
		return target;
	};


/***/ },
/* 71 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (x) {
		var type = typeof x;
		return x !== null && (type === 'object' || type === 'function');
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getMap = getMap;
	exports.getMapEl = getMapEl;
	exports.getMapLoaded = getMapLoaded;
	exports.getWayPointsVisible = getWayPointsVisible;
	exports.getMapEditing = getMapEditing;
	exports.getWamv = getWamv;
	exports.getSettings = getSettings;
	exports.getSettingsLastUpdateTime = getSettingsLastUpdateTime;
	exports.getMissions = getMissions;
	exports.getMissionsLastUpdateTime = getMissionsLastUpdateTime;
	exports.getCurrentMissionIndex = getCurrentMissionIndex;
	exports.getCurrentMission = getCurrentMission;
	exports.getParameters = getParameters;
	exports.getParametersLastUpdateTime = getParametersLastUpdateTime;
	function getMap(state) {
	    return state.map;
	}
	
	function getMapEl(state) {
	    return state.mapEl;
	}
	
	function getMapLoaded(state) {
	    return state.mapLoaded;
	}
	
	function getWayPointsVisible(state) {
	    return state.waypointsVisible;
	}
	
	function getMapEditing(state) {
	    return state.mapLoaded && state.wamv.mode != 'auto' && state.waypointsVisible;
	}
	
	function getWamv(state) {
	    return state.wamv;
	}
	
	function getSettings(state) {
	    return state.settings;
	}
	
	function getSettingsLastUpdateTime(state) {
	    return state.settingsLastUpdateTime;
	}
	
	function getMissions(state) {
	    return state.missions;
	}
	
	function getMissionsLastUpdateTime(state) {
	    return state.missionsLastUpdateTime;
	}
	
	function getCurrentMissionIndex(state) {
	    return state.currentMissionIndex;
	}
	
	function getCurrentMission(state) {
	    return state.missions[state.currentMissionIndex];
	}
	
	function getParameters(state) {
	    return state.parameters;
	}
	
	function getParametersLastUpdateTime(state) {
	    return state.parametersLastUpdateTime;
	}

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map\" id=\"map\" :class=\"{ 'gcs-map-edit-mode': mapEditing }\"></div>\n";

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(75)
	__vue_script__ = __webpack_require__(76)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsMapControls.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(77)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-475ae20a/GcsMapControls.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 75 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {
	            mapType: 'Satellite',
	            mapTypesMenu: [{ 'value': 'ROADMAP', text: 'Road' }, { 'value': 'TERRAIN', text: 'Terrain' }, { 'value': 'SATELLITE', text: 'Satellite' }, { 'value': 'HYBRID', text: 'Hybrid' }]
	        };
	    },
	
	
	    methods: {
	        pan: function pan(direction) {
	            this.$dispatch('map::pan-' + direction);
	        },
	        zoom: function zoom(type) {
	            this.$dispatch('map::zoom-' + type);
	        },
	        changeMapType: function changeMapType(selected) {
	            this.mapType = selected.text;
	            this.$dispatch('map::change-type', selected.value);
	        }
	    }
	};

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map-controls\">\n    <div class=\"pan-controls\">\n        <ui-icon-button\n            class=\"pan-control up\" icon=\"keyboard_arrow_up\" @click=\"pan('up')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control right\" icon=\"keyboard_arrow_right\" @click=\"pan('right')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control down\" icon=\"keyboard_arrow_down\" @click=\"pan('down')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control left\" icon=\"keyboard_arrow_left\" @click=\"pan('left')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"pan-control center\" icon=\"my_location\" @click=\"pan('center')\"\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"zoom-controls\">\n        <ui-icon-button\n            class=\"zoom-control in\" icon=\"add\" @click=\"zoom('in')\"\n        ></ui-icon-button>\n\n        <ui-icon-button\n            class=\"zoom-control out\" icon=\"remove\" @click=\"zoom('out')\"\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"type-control\">\n        <ui-button\n            :menu-options=\"mapTypesMenu\" name=\"map_types\" :text=\"mapType\"\n            @menu-option-selected=\"changeMapType\" has-dropdown-menu raised\n            dropdown-position=\"top right\" :show-dropdown-icon=\"false\"\n        ></ui-button>\n    </div>\n</div>\n";

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(79)
	__vue_script__ = __webpack_require__(80)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsMapSidebar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(130)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7fccf4b2/GcsMapSidebar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 79 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsMissions = __webpack_require__(81);
	
	var _GcsMissions2 = _interopRequireDefault(_GcsMissions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        showSidebar: {
	            type: Boolean,
	            required: true
	        }
	    },
	
	    components: {
	        GcsMissions: _GcsMissions2.default
	    }
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(82)
	__vue_script__ = __webpack_require__(83)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsMissions.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(129)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-009767c4/GcsMissions.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 82 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _typeof2 = __webpack_require__(84);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _stringify = __webpack_require__(104);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _GcsMission = __webpack_require__(106);
	
	var _GcsMission2 = _interopRequireDefault(_GcsMission);
	
	var _GcsMissionRow = __webpack_require__(125);
	
	var _GcsMissionRow2 = _interopRequireDefault(_GcsMissionRow);
	
	var _actions = __webpack_require__(69);
	
	var _getters = __webpack_require__(72);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv,
	            missions: _getters.getMissions,
	            currentMissionIndex: _getters.getCurrentMissionIndex,
	            currentMission: _getters.getCurrentMission
	        },
	
	        actions: {
	            setMissions: _actions.setMissions,
	            setCurrentMissionIndex: _actions.setCurrentMissionIndex
	        }
	    },
	
	    data: function data() {
	        return {
	            currentView: 'listing',
	            overflowMenu: [{ id: 'save', text: 'Save to server' }, { id: 'load', text: 'Load from server' }, { id: 'sep1', text: '', type: 'divider' }, { id: 'export', text: 'Export to file' }, { id: 'import', text: 'Import from file' }, { id: 'sep2', text: '', type: 'divider' }, { id: 'clear', text: 'Clear all' }]
	        };
	    },
	
	
	    methods: {
	        selectMission: function selectMission(index) {
	            this.setCurrentMissionIndex(index);
	            this.currentView = 'gcs-mission';
	        },
	        showListingView: function showListingView() {
	            this.currentView = 'listing';
	            this.setCurrentMissionIndex(-1);
	        },
	        addMission: function addMission() {
	            this.missions.push({
	                title: 'Mission ' + (this.missions.length + 1),
	                origin: { lat: this.wamv.position.lat, lng: this.wamv.position.lng },
	                waypoints: []
	            });
	        },
	        downloadMission: function downloadMission() {
	            this.$dispatch('client::get_mission');
	        },
	        menuOptionSelected: function menuOptionSelected(option) {
	            switch (option.id) {
	                case 'save':
	                    this.$dispatch('client::set_missions', this.missions);
	                    break;
	                case 'load':
	                    this.$dispatch('client::get_missions');
	                    break;
	                case 'import':
	                    document.getElementById('import_missions_input').click();
	                    break;
	                case 'export':
	                    var uri = 'data:application/json,';
	                    uri += (0, _stringify2.default)(this.missions);
	                    uri = encodeURI(uri);
	
	                    var link = document.getElementById('export_missions_link');
	                    link.href = uri;
	                    link.download = 'missions.json';
	
	                    link.click();
	                    break;
	                case 'clear':
	                    this.setMissions([]);
	                    break;
	            }
	        },
	        importMission: function importMission() {
	            var _this = this;
	
	            var files = document.getElementById('import_missions_input').files;
	
	            if (files.length > 0) {
	                var file = files[0];
	                var reader = new FileReader();
	
	                reader.onload = function (e) {
	                    var contents = e.target.result;
	                    try {
	                        var newMissions = JSON.parse(contents);
	                        if (!_this.isMissionList(newMissions)) {
	                            console.log('File content does not represent a valid mission list');
	                        } else {
	                            _this.setMissions(newMissions);
	                        }
	                    } catch (e) {
	                        console.log('File content is not valid JSON: ' + e.message);
	                    }
	                };
	
	                reader.readAsText(file);
	            }
	        },
	        isMissionList: function isMissionList(data) {
	            if (!Array.isArray(data)) {
	                return false;
	            }
	            for (var i = 0; i < data.length; i++) {
	                var mission = data[i];
	                if ((typeof mission === 'undefined' ? 'undefined' : (0, _typeof3.default)(mission)) != 'object' || typeof mission.title != 'string' || (0, _typeof3.default)(mission.origin) != 'object' || typeof mission.origin.lat != 'number' || typeof mission.origin.lng != 'number' || !Array.isArray(mission.waypoints)) {
	                    return false;
	                }
	                for (var j = 0; j < mission.waypoints.length; j++) {
	                    var wp = mission.waypoints[j];
	                    if ((typeof wp === 'undefined' ? 'undefined' : (0, _typeof3.default)(wp)) != 'object' || !wp.hasOwnProperty('title') || typeof wp.title != 'string' || !wp.hasOwnProperty('type') || typeof wp.type != 'string' || !wp.hasOwnProperty('position') || (0, _typeof3.default)(wp.position) != 'object' || !wp.position.hasOwnProperty('lat') || typeof wp.position.lat != 'number' || !wp.position.hasOwnProperty('lng') || typeof wp.position.lng != 'number') {
	                        return false;
	                    }
	                }
	            }
	            return true;
	        }
	    },
	
	    events: {
	        'delete-mission': function deleteMission(index) {
	            this.missions.splice(index, 1);
	        },
	        'delete-waypoint': function deleteWaypoint(index) {
	            this.currentMission.waypoints.splice(index, 1);
	        }
	    },
	
	    components: {
	        GcsMission: _GcsMission2.default,
	        GcsMissionRow: _GcsMissionRow2.default
	    }
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(85);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(88);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(86), __esModule: true };

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(63);
	__webpack_require__(17);
	module.exports = __webpack_require__(87).f('iterator');

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(60);

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(89), __esModule: true };

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(90);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	module.exports = __webpack_require__(30).Symbol;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(29)
	  , has            = __webpack_require__(44)
	  , DESCRIPTORS    = __webpack_require__(38)
	  , $export        = __webpack_require__(28)
	  , redefine       = __webpack_require__(43)
	  , META           = __webpack_require__(91).KEY
	  , $fails         = __webpack_require__(39)
	  , shared         = __webpack_require__(55)
	  , setToStringTag = __webpack_require__(59)
	  , uid            = __webpack_require__(56)
	  , wks            = __webpack_require__(60)
	  , wksExt         = __webpack_require__(87)
	  , wksDefine      = __webpack_require__(92)
	  , keyOf          = __webpack_require__(93)
	  , enumKeys       = __webpack_require__(94)
	  , isArray        = __webpack_require__(97)
	  , anObject       = __webpack_require__(35)
	  , toIObject      = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(41)
	  , createDesc     = __webpack_require__(42)
	  , _create        = __webpack_require__(46)
	  , gOPNExt        = __webpack_require__(98)
	  , $GOPD          = __webpack_require__(100)
	  , $DP            = __webpack_require__(34)
	  , $keys          = __webpack_require__(48)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(99).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(96).f  = $propertyIsEnumerable;
	  __webpack_require__(95).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(27)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(33)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(56)('meta')
	  , isObject = __webpack_require__(36)
	  , has      = __webpack_require__(44)
	  , setDesc  = __webpack_require__(34).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(39)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(29)
	  , core           = __webpack_require__(30)
	  , LIBRARY        = __webpack_require__(27)
	  , wksExt         = __webpack_require__(87)
	  , defineProperty = __webpack_require__(34).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(48)
	  , toIObject = __webpack_require__(22);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(48)
	  , gOPS    = __webpack_require__(95)
	  , pIE     = __webpack_require__(96);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 95 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 96 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(24);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(22)
	  , gOPN      = __webpack_require__(99).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(49)
	  , hiddenKeys = __webpack_require__(57).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(96)
	  , createDesc     = __webpack_require__(42)
	  , toIObject      = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(41)
	  , has            = __webpack_require__(44)
	  , IE8_DOM_DEFINE = __webpack_require__(37)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(38) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 101 */
/***/ function(module, exports) {



/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(92)('asyncIterator');

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(92)('observable');

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(105), __esModule: true };

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(30)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(107)
	__vue_script__ = __webpack_require__(108)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsMission.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(124)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-b5eeecb6/GcsMission.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 107 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsWaypoint = __webpack_require__(109);
	
	var _GcsWaypoint2 = _interopRequireDefault(_GcsWaypoint);
	
	var _GcsWaypointLink = __webpack_require__(115);
	
	var _GcsWaypointLink2 = _interopRequireDefault(_GcsWaypointLink);
	
	var _GcsOrigin = __webpack_require__(119);
	
	var _GcsOrigin2 = _interopRequireDefault(_GcsOrigin);
	
	var _elementScroll = __webpack_require__(113);
	
	var _elementScroll2 = _interopRequireDefault(_elementScroll);
	
	var _numberToLetter = __webpack_require__(123);
	
	var _numberToLetter2 = _interopRequireDefault(_numberToLetter);
	
	var _getters = __webpack_require__(72);
	
	var _actions = __webpack_require__(69);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            mapEditing: _getters.getMapEditing,
	            missions: _getters.getMissions,
	            currentMissionIndex: _getters.getCurrentMissionIndex,
	            waypointsVisible: _getters.getWayPointsVisible
	        },
	
	        actions: {
	            setWaypointsVisible: _actions.setWaypointsVisible
	        }
	    },
	
	    props: {
	        mission: {
	            type: Object,
	            required: true
	        }
	    },
	
	    data: function data() {
	        return {
	            overflowMenu: [{ id: 'edit', text: 'Edit mission' }, { id: 'clear_all', text: 'Clear all waypoints' }],
	            originValid: true,
	            lastSetMissionAckTime: null,
	            TIMEOUT: 1000
	        };
	    },
	    ready: function ready() {
	        this.setWaypointsVisible(true);
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.setWaypointsVisible(false);
	    },
	
	
	    methods: {
	        goBack: function goBack() {
	            this.$dispatch('go-back');
	        },
	        toLetter: function toLetter(number) {
	            return (0, _numberToLetter2.default)(number);
	        },
	        toggleWaypointVisibility: function toggleWaypointVisibility() {
	            this.setWaypointsVisible(!this.waypointsVisible);
	        },
	        deleteWaypoint: function deleteWaypoint(index) {
	            this.mission.waypoints.splice(index, 1);
	        },
	        clearWaypoints: function clearWaypoints() {
	            if (!this.waypointsVisible) {
	                return;
	            }
	
	            this.mission.waypoints = [];
	            this.setWaypointsVisible(true);
	        },
	        uploadMission: function uploadMission() {
	            var _this = this;
	
	            if (this.mission.origin.lat < -90 || this.mission.origin.lat > 90 || this.mission.origin.lng < -180 || this.mission.origin.lng > 180) {
	                this.$dispatch('app::create-snackbar', 'Mission origin is out of range');
	                return;
	            }
	            this.$dispatch('client::set_mission', this.missions[this.currentMissionIndex]);
	
	            var requestTime = Date.now();
	            setTimeout(function () {
	                if (_this.lastSetMissionAckTime < requestTime) {
	                    _this.$dispatch('app::create-snackbar', 'Mission not uploaded within timeout');
	                }
	            }, this.TIMEOUT);
	        },
	        overflowMenuOptionSelected: function overflowMenuOptionSelected(option) {
	            if (option.id === 'edit') {
	                this.$dispatch('app::show-edit-mission-modal');
	            } else if (option.id === 'clear_all') {
	                this.clearWaypoints();
	            }
	        }
	    },
	
	    events: {
	        'map:click': function mapClick(e) {
	            var _this2 = this;
	
	            if (!this.mapEditing) {
	                return;
	            }
	
	            var lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            var lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	
	            var newWaypoint = {
	                title: '',
	                type: 'go_to_point',
	                position: {
	                    lat: lat,
	                    lng: lng
	                }
	            };
	
	            this.mission.waypoints.push(newWaypoint);
	
	            this.$nextTick(function () {
	                _elementScroll2.default.scrollToEnd(_this2.$els.pageContent);
	            });
	        },
	        'map:dblclick': function mapDblclick(e) {
	            console.log('Map double clicked', e);
	        },
	        'map:rightclick': function mapRightclick(e) {
	            console.log('Map right-clicked', e);
	        },
	        'waypointLink:click': function waypointLinkClick(index, lat, lng) {
	            var _this3 = this;
	
	            if (!this.mapEditing) {
	                return;
	            }
	
	            var newWaypoint = {
	                title: '',
	                type: 'go_to_point',
	                position: {
	                    lat: lat,
	                    lng: lng
	                }
	            };
	            this.mission.waypoints.splice(index + 1, 0, newWaypoint);
	
	            this.$nextTick(function () {
	                _elementScroll2.default.scrollIntoView(_this3.$el.querySelector('#waypoint-' + (index + 1)), _this3.$els.pageContent, 56);
	            });
	        },
	        'server::set_mission_ack': function serverSet_mission_ack() {
	            this.lastSetMissionAckTime = Date.now();
	        }
	    },
	
	    components: {
	        GcsWaypoint: _GcsWaypoint2.default,
	        GcsWaypointLink: _GcsWaypointLink2.default,
	        GcsOrigin: _GcsOrigin2.default
	    }
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(110)
	__vue_script__ = __webpack_require__(111)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsWaypoint.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(114)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-00e23ea5/GcsWaypoint.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 110 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(112);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	var _elementScroll = __webpack_require__(113);
	
	var _elementScroll2 = _interopRequireDefault(_elementScroll);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        index: Number,
	        label: {
	            type: String,
	            coerce: String
	        },
	        title: {
	            type: String
	        },
	        waypointType: {
	            type: String
	        },
	        lat: {
	            type: Number
	        },
	        lng: {
	            type: Number
	        }
	    },
	
	    data: function data() {
	        return {
	            dragging: false,
	            highlighted: false,
	            fillColor: { normal: 'yellow', hover: 'lime' }
	        };
	    },
	
	
	    events: {
	        click: function click() {
	            _elementScroll2.default.scrollIntoView(this.$el, this.$el.parentElement.parentElement, 56);
	        },
	        rightclick: function rightclick() {
	            this.$dispatch('delete');
	        },
	        drag: function drag(e) {
	            this.lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            this.lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	        },
	        mouseover: function mouseover() {
	            this.highlighted = true;
	            if (this.marker) {
	                this.marker.setIcon(this.getIcon(this.fillColor.hover));
	            }
	        },
	        mouseout: function mouseout() {
	            this.highlighted = false;
	            if (this.marker && !this.dragging) {
	                this.marker.setIcon(this.getIcon(this.fillColor.normal));
	            }
	        },
	        dragstart: function dragstart() {
	            this.dragging = true;
	        },
	        dragend: function dragend() {
	            this.dragging = false;
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var fillColor = arguments.length <= 0 || arguments[0] === undefined ? this.fillColor.normal : arguments[0];
	            var scale = arguments.length <= 1 || arguments[1] === undefined ? this.scale : arguments[1];
	            var rotation = arguments.length <= 2 || arguments[2] === undefined ? this.rotation : arguments[2];
	
	            return {
	                path: google.maps.SymbolPath.CIRCLE,
	                rotation: rotation,
	                scale: scale,
	                fillColor: fillColor,
	                fillOpacity: 1,
	                strokeColor: 'white',
	                strokeWeight: 2
	            };
	        },
	        deleteWaypoint: function deleteWaypoint() {
	            this.$dispatch('delete-waypoint', this.index);
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(72);
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapEl: _getters.getMapEl,
	            mapLoaded: _getters.getMapLoaded
	        }
	    },
	
	    props: {
	        title: String,
	        lat: {
	            type: Number,
	            required: true
	        },
	        lng: {
	            type: Number,
	            required: true
	        },
	        rotation: {
	            type: Number,
	            default: 0
	        },
	        scale: {
	            type: Number,
	            default: 6
	        },
	        visible: {
	            type: Boolean,
	            default: true
	        },
	        draggable: {
	            type: Boolean,
	            default: false
	        }
	    },
	
	    data: function data() {
	        return {
	            marker: null
	        };
	    },
	
	
	    computed: {
	        position: function position() {
	            return {
	                lat: this.lat,
	                lng: this.lng
	            };
	        }
	    },
	
	    ready: function ready() {
	        if (this.mapLoaded) {
	            this.initializeMarker();
	        }
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.marker.setMap(null);
	        this.marker = null;
	    },
	
	
	    watch: {
	        mapLoaded: function mapLoaded(newVal, oldVal) {
	            if (!oldVal && newVal && !this.marker) {
	                this.initializeMarker();
	            }
	        },
	        map: function map() {
	            if (this.marker) {
	                this.marker.setMap(this.map);
	            }
	        },
	        title: function title() {
	            if (this.marker) {
	                this.marker.setTitle(this.title);
	            }
	        },
	        label: function label() {
	            if (this.marker) {
	                this.marker.setLabel(this.label);
	            }
	        },
	        position: function position() {
	            if (this.marker) {
	                this.marker.setPosition(this.position);
	            }
	        },
	        visible: function visible() {
	            if (this.marker) {
	                this.marker.setVisible(this.visible);
	            }
	        },
	        draggable: function draggable() {
	            if (this.marker) {
	                this.marker.setDraggable(this.draggable);
	            }
	        },
	        rotation: function rotation() {
	            this.updateIcon();
	        },
	        scale: function scale() {
	            this.updateIcon();
	        }
	    },
	
	    methods: {
	        initializeMarker: function initializeMarker() {
	            this.marker = new google.maps.Marker({
	                position: this.position,
	                icon: this.getIcon(),
	                draggable: this.draggable,
	                visible: this.visible,
	                map: this.map
	            });
	
	            if (this.title) {
	                this.marker.setTitle(this.title);
	            }
	
	            if (this.label) {
	                this.marker.setLabel(this.label);
	            }
	
	            this.$dispatch('initialized', this.marker);
	
	            this.setupEvents();
	        },
	        updateIcon: function updateIcon() {
	            if (this.marker) {
	                this.marker.setIcon(this.getIcon());
	            }
	        },
	        setupEvents: function setupEvents() {
	            var _this = this;
	
	            this.marker.addListener('click', function (e) {
	                _this.$dispatch('click', e);
	            });
	
	            this.marker.addListener('dblclick', function (e) {
	                _this.$dispatch('dblclick', e);
	            });
	
	            this.marker.addListener('rightclick', function (e) {
	                _this.$dispatch('rightclick', e);
	            });
	
	            this.marker.addListener('mouseover', function (e) {
	                _this.$dispatch('mouseover', e);
	            });
	
	            this.marker.addListener('mouseout', function (e) {
	                _this.$dispatch('mouseout', e);
	            });
	
	            this.marker.addListener('dragstart', function (e) {
	                _this.$dispatch('dragstart', e);
	            });
	
	            this.marker.addListener('drag', function (e) {
	                _this.$dispatch('drag', e);
	            });
	
	            this.marker.addListener('dragend', function (e) {
	                _this.$dispatch('dragend', e);
	            });
	
	            this.marker.addListener('position_changed', function (e) {
	                _this.$dispatch('position_changed', e);
	            });
	        }
	    }
	};

/***/ },
/* 113 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.inView = inView;
	exports.scrollIntoView = scrollIntoView;
	exports.scrollToStart = scrollToStart;
	exports.scrollToEnd = scrollToEnd;
	function inView(element, container) {
	    if (!element) {
	        return;
	    }
	
	    container = container || element.parentElement;
	
	    var top = element.offsetTop;
	    var parentTop = container.scrollTop;
	    var bottom = top + element.offsetHeight;
	    var parentBottom = container.offsetHeight;
	
	    return top >= parentTop && bottom <= parentBottom;
	}
	
	function scrollIntoView(element, container) {
	    var marginTop = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    if (!element || inView(element, container)) {
	        return;
	    }
	
	    container = container || element.parentElement;
	
	    container.scrollTop = element.offsetTop - marginTop;
	}
	
	function scrollToStart(element) {
	    if (!element) {
	        return;
	    }
	
	    element.scrollTop = 0;
	}
	
	function scrollToEnd(element) {
	    if (!element) {
	        return;
	    }
	
	    element.scrollTop = element.scrollHeight;
	}
	
	exports.default = {
	    inView: inView,
	    scrollIntoView: scrollIntoView,
	    scrollToStart: scrollToStart,
	    scrollToEnd: scrollToEnd
	};

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-waypoint\" :class=\"{ 'highlighted': (dragging || highlighted) }\">\n    <div class=\"number\">\n        <div v-text=\"index + 1\"></div>\n        <ui-icon-button\n            type=\"clear\" icon=\"delete\" tooltip=\"Delete\" @click=\"deleteWaypoint\"\n            class='delete-button'\n        ></ui-icon-button>\n    </div>\n\n    <div class=\"content\">\n        <div class=\"row\">\n            <ui-textbox\n                class=\"column\" label=\"Title\" name=\"title\" :value.sync=\"title\"\n            ></ui-textbox>\n        </div>\n\n        <div class=\"row\">\n            <ui-textbox\n                class=\"column one-half\" label=\"Latitude\" name=\"latitude\" :value.sync=\"lat\"\n                type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n\n            <ui-textbox\n                class=\"column one-half\" label=\"Longitude\" name=\"longitude\" :value.sync=\"lng\"\n                type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n        </div>\n\n        <div class=\"row\">\n            <ui-select\n                class=\"column one-half\" label=\"Type\" name=\"type\" :value.sync=\"waypointType\"\n                :options=\"[{ text: 'Go To Point', value: 'go_to_point' }]\" :default=\"waypointType\"\n            ></ui-select>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(116)
	__vue_script__ = __webpack_require__(117)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsWaypointLink.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(118)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-b8581182/GcsWaypointLink.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 116 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(72);
	
	exports.default = {
	    vuex: {
	        getters: {
	            map: _getters.getMap,
	            mapLoaded: _getters.getMapLoaded
	        }
	    },
	
	    props: {
	        index: {
	            type: Number,
	            required: true
	        },
	
	        startLat: {
	            type: Number,
	            required: true
	        },
	
	        startLng: {
	            type: Number,
	            required: true
	        },
	
	        endLat: {
	            type: Number,
	            required: true
	        },
	
	        endLng: {
	            type: Number,
	            required: true
	        },
	
	        visible: {
	            type: Boolean,
	            default: true
	        }
	    },
	
	    data: function data() {
	        return {
	            link: null,
	            strokeColor: { normal: 'black', hover: 'green' }
	        };
	    },
	    ready: function ready() {
	        if (this.mapLoaded) {
	            this.initializeLink();
	        }
	    },
	    beforeDestroy: function beforeDestroy() {
	        this.link.setMap(null);
	        this.link = null;
	    },
	
	
	    watch: {
	        mapLoaded: function mapLoaded(newVal, oldVal) {
	            if (!oldVal && newVal && !this.link) {
	                this.initializeLink();
	            }
	        },
	        map: function map() {
	            if (this.link) {
	                this.link.setMap(this.map);
	            }
	        },
	        startLat: function startLat() {
	            if (this.link) {
	                this.link.getPath().setAt(0, new google.maps.LatLng(this.startLat, this.startLng));
	            }
	        },
	        startLng: function startLng() {
	            if (this.link) {
	                this.link.getPath().setAt(0, new google.maps.LatLng(this.startLat, this.startLng));
	            }
	        },
	        endLat: function endLat() {
	            if (this.link) {
	                this.link.getPath().setAt(1, new google.maps.LatLng(this.endLat, this.endLng));
	            }
	        },
	        endLng: function endLng() {
	            if (this.link) {
	                this.link.getPath().setAt(1, new google.maps.LatLng(this.endLat, this.endLng));
	            }
	        },
	        visible: function visible() {
	            if (this.link) {
	                this.link.setVisible(this.visible);
	            }
	        }
	    },
	
	    methods: {
	        initializeLink: function initializeLink() {
	            var _this = this;
	
	            this.link = new google.maps.Polyline({
	                path: [{ lat: this.startLat, lng: this.startLng }, { lat: this.endLat, lng: this.endLng }],
	                strokeColor: this.strokeColor.normal,
	                strokeOpacity: 1,
	                strokeWeight: 5,
	                visible: this.visible,
	                map: this.map
	            });
	            this.link.addListener('click', function (e) {
	                var lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	                var lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	                _this.$dispatch('waypointLink:click', _this.index, lat, lng);
	            });
	            this.link.addListener('mouseover', function () {
	                if (_this.link) {
	                    _this.link.setOptions({ strokeColor: _this.strokeColor.hover });
	                }
	            });
	            this.link.addListener('mouseout', function () {
	                if (_this.link) {
	                    _this.link.setOptions({ strokeColor: _this.strokeColor.normal });
	                }
	            });
	        }
	    }
	};

/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-waypoint-link\"></div>\n";

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(120)
	__vue_script__ = __webpack_require__(121)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsOrigin.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(122)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-6f2b036c/GcsOrigin.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 120 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(112);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        lat: {
	            type: Number
	        },
	        lng: {
	            type: Number
	        }
	    },
	
	    events: {
	        drag: function drag(e) {
	            this.lat = Number(parseFloat(e.latLng.lat()).toFixed(7));
	            this.lng = Number(parseFloat(e.latLng.lng()).toFixed(7));
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var scale = arguments.length <= 0 || arguments[0] === undefined ? this.scale : arguments[0];
	            var rotation = arguments.length <= 1 || arguments[1] === undefined ? this.rotation : arguments[1];
	
	            return {
	                path: google.maps.SymbolPath.CIRCLE,
	                rotation: rotation,
	                scale: scale,
	                fillColor: 'orange',
	                fillOpacity: 0.8,
	                strokeColor: 'white',
	                strokeWeight: 0
	            };
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-origin\"></div>\n";

/***/ },
/* 123 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (number) {
	    if (number > 52) {
	        return '0';
	    }
	
	    var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
	
	    return alphabet[number - 1];
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-mission\">\n    <ui-toolbar :title=\"mission.title\" hide-nav-icon show-brand :show-brand-divider=\"false\">\n        <div slot=\"brand\">\n            <ui-icon-button\n                @click=\"goBack\" type=\"clear\" icon=\"arrow_back\" tooltip=\"Back to Missions\"\n                tooltip-position=\"bottom left\"\n            ></ui-icon-button>\n        </div>\n\n        <div slot=\"actions\">\n            <ui-icon-button\n                type=\"clear\" icon=\"file_upload\" tooltip=\"Upload mission\" @click=\"uploadMission\"\n                :disabled=\"!waypointsVisible\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" :icon=\"waypointsVisible ? 'visibility' : 'visibility_off'\"\n                @click=\"toggleWaypointVisibility\"\n                :tooltip=\"waypointsVisible ? 'Hide waypoints' : 'Show waypoints'\"\n            ></ui-icon-button>\n\n            <ui-icon-button\n                type=\"clear\" icon=\"more_vert\" has-dropdown-menu dropdown-position=\"bottom right\"\n                :menu-options=\"overflowMenu\" @menu-option-selected=\"overflowMenuOptionSelected\"\n            ></ui-icon-button>\n        </div>\n    </ui-toolbar>\n\n    <div class=\"sidebar-page-content\" v-el:page-content>\n        <div class=\"row origin-row\">\n            <ui-textbox\n                class=\"column one-half\" label=\"Origin Latitude\" name=\"latitude\"\n                :value.sync=\"mission.origin.lat\" type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n            <ui-textbox\n                class=\"column one-half\" label=\"Origin Longitude\" name=\"longitude\"\n                :value.sync=\"mission.origin.lng\" type=\"number\" :step=\"0.00001\"\n            ></ui-textbox>\n        </div>\n\n        <gcs-origin\n            :lat.sync=\"mission.origin.lat\" :lng.sync=\"mission.origin.lng\"\n            :scale=\"5\" :draggable=\"mapEditing\"\n        ></gcs-origin>\n\n        <p\n            class=\"no-waypoints\" v-if=\"!mission.waypoints.length\"\n        >No waypoints for this mission. Click the map to add a waypoint.</p>\n\n        <div v-else>\n            <gcs-waypoint\n                v-for=\"(index, waypoint) in mission.waypoints\" :index=\"index\" :id=\"'waypoint-' + index\"\n                :label=\"toLetter(index + 1)\" :title.sync=\"waypoint.title\" :waypoint-type=\"waypoint.type\"\n                :lat.sync=\"waypoint.position.lat\" :lng.sync=\"waypoint.position.lng\"\n                :rotation=\"waypoint.rotation\" :scale=\"10\"\n                :draggable=\"mapEditing\" :visible=\"waypointsVisible\"\n                @delete=\"deleteWaypoint(index)\"\n            ></gcs-waypoint>\n\n            <!--\n                it seems, when waypoint.position is used, instead of waypoint.position.lat/lng,\n                changing the waypoint.position.lat/lng elsewhere won't trigger updates here\n            -->\n            <gcs-waypoint-link\n                v-for=\"(index, waypoint) in mission.waypoints\" :index=\"index\"\n                :start-lat=\"waypoint.position.lat\"\n                :start-lng=\"waypoint.position.lng\"\n                :end-lat=\"mission.waypoints[(index+1) % mission.waypoints.length].position.lat;\"\n                :end-lng=\"mission.waypoints[(index+1) % mission.waypoints.length].position.lng;\"\n                :visible=\"waypointsVisible\"\n            ></gcs-waypoint-link>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(126)
	__vue_script__ = __webpack_require__(127)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsMissionRow.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(128)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-fe058db6/GcsMissionRow.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 126 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 127 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: {
	        mission: {
	            type: Object,
	            required: true
	        },
	        index: {
	            type: Number,
	            required: true
	        }
	    },
	
	    computed: {
	        hasWaypoints: function hasWaypoints() {
	            return this.mission.waypoints && this.mission.waypoints.length;
	        },
	        firstWaypoint: function firstWaypoint() {
	            return this.mission.waypoints[0];
	        },
	        lastWaypoint: function lastWaypoint() {
	            return this.mission.waypoints[this.mission.waypoints.length - 1];
	        }
	    },
	
	    methods: {
	        deleteMission: function deleteMission() {
	            this.$dispatch('delete-mission', this.index);
	        }
	    }
	};

/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-mission-row\">\n    <ui-icon-button\n        type=\"clear\" icon=\"delete\" class=\"delete-button\" tooltip=\"Delete\" @click=\"deleteMission\"\n    ></ui-icon-button>\n\n    <h3 class=\"mission-header\" v-text=\"mission.title\"></h3>\n\n    <div class=\"mission-summary\">\n        <p class=\"description\" v-if=\"mission.description\" v-text=\"mission.description\"></p>\n\n        <p class=\"waypoints\" v-if=\"!mission.description && hasWaypoints\">\n            <span>From: ({{ firstWaypoint.position.lat }}, {{ firstWaypoint.position.lng }})</span>\n            <span>To: ({{ lastWaypoint.position.lat }}, {{ lastWaypoint.position.lng }})</span>\n        </p>\n\n        <p class=\"no-waypoints\" v-if=\"!mission.description && !hasWaypoints\">No waypoints</p>\n    </div>\n</div>\n";

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-missions\">\n    <div class=\"sidebar-page\">\n        <div class=\"missions-list\" v-if=\"currentView === 'listing'\">\n            <ui-toolbar title=\"Missions\" hide-nav-icon>\n                <div slot=\"actions\">\n                    <ui-icon-button\n                        type=\"clear\" icon=\"add\" tooltip=\"Add mission\" @click=\"addMission\"\n                    ></ui-icon-button>\n\n                    <ui-icon-button\n                        type=\"clear\" icon=\"file_download\" tooltip=\"Download mission\"\n                        @click=\"downloadMission\"\n                    ></ui-icon-button>\n\n                    <ui-icon-button\n                        type=\"clear\" icon=\"more_vert\" has-dropdown-menu\n                        dropdown-position=\"bottom right\" :menu-options=\"overflowMenu\"\n                        @menu-option-selected=\"menuOptionSelected\"\n                    ></ui-icon-button>\n                </div>\n            </ui-toolbar>\n\n            <div class=\"sidebar-page-content\">\n                <div class=\"blank-state\" v-if=\"!missions.length\">No missions</div>\n\n                <gcs-mission-row\n                    v-for=\"(index, mission) in missions\" :index=\"index\" :mission=\"mission\"\n                    @click=\"selectMission(index)\"\n                ></gcs-mission-row>\n            </div>\n        </div>\n\n        <component\n            v-else :is=\"currentView\" :mission=\"currentMission\" @go-back=\"showListingView\"\n        ></component>\n    </div>\n</div>\n<!-- hidden input element used for selecting a file to import from -->\n<input type=\"file\" id=\"import_missions_input\" @change=\"importMission\">\n<!-- hidden link used for prompting a download -->\n<a id=\"export_missions_link\"></a>\n";

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-map-sidebar\" v-show=\"showSidebar\" transition=\"sidebar-collapse\">\n    <gcs-missions></gcs-missions>\n</div>\n";

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(132)
	__vue_script__ = __webpack_require__(133)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsCommands.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(134)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-4c2b1d8f/GcsCommands.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 132 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(72);
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    data: function data() {
	        return {
	            overflowMenu: [{ id: 'auto', text: 'Auto' }, { id: 'manual', text: 'Manual' }],
	            toggleMissionFailureTimer: null,
	            TIMEOUT: 1000
	        };
	    },
	
	
	    computed: {
	        modeButtonText: function modeButtonText() {
	            if (this.wamv.mode === 'manual') {
	                return 'Mode: M';
	            } else {
	                return 'Mode: A';
	            }
	        },
	        startButtonText: function startButtonText() {
	            switch (this.wamv.mode) {
	                case 'idle':
	                case 'killed':
	                    return 'Start';
	                case 'paused':
	                    return 'Resume';
	                case 'auto':
	                    return 'Pause';
	                default:
	                    return '';
	            }
	        },
	
	        isArmed: {
	            get: function get() {
	                return this.wamv.armed;
	            },
	            set: function set(arm) {
	                if (arm) {
	                    this.$dispatch('client::arm');
	                } else {
	                    this.$dispatch('client::disarm');
	                }
	            }
	        }
	    },
	
	    methods: {
	        toggleMission: function toggleMission() {
	            var _this = this;
	
	            if (this.wamv.mode === 'idle') {
	                this.startMission();
	            } else if (this.wamv.mode === 'paused') {
	                this.$dispatch('client::resume_mission');
	                clearTimeout(this.toggleMissionFailureTimer);
	                this.toggleMissionFailureTimer = setTimeout(function () {
	                    if (_this.wamv.mode !== 'auto') {
	                        _this.$dispatch('app::create-snackbar', 'Resuming seems to have failed (Possible reasons: not armed, no battery, ...)');
	                    }
	                }, this.TIMEOUT);
	            } else if (this.wamv.mode === 'auto') {
	                this.$dispatch('client::stop_mission');
	            }
	        },
	        startMission: function startMission() {
	            var _this2 = this;
	
	            this.$dispatch('client::start_mission');
	            clearTimeout(this.toggleMissionFailureTimer);
	            this.toggleMissionFailureTimer = setTimeout(function () {
	                if (_this2.wamv.mode !== 'auto') {
	                    _this2.$dispatch('app::create-snackbar', 'Starting seems to have failed (Possible reasons: no uploaded mission, not armed, ...)');
	                }
	            }, this.TIMEOUT);
	        },
	        toggleKill: function toggleKill() {
	            this.$dispatch(this.wamv.mode === 'killed' ? 'client::unkill' : 'client::kill');
	        },
	        menuOptionSelected: function menuOptionSelected(option) {
	            switch (option.id) {
	                case 'auto':
	                    if (this.wamv.mode !== 'manual') {
	                        this.$dispatch('app::create-snackbar', 'Already in automatic mode');
	                        return;
	                    }
	                    this.$dispatch('client::auto');
	                    break;
	                case 'manual':
	                    if (this.wamv.mode === 'manual') {
	                        this.$dispatch('app::create-snackbar', 'Already in manual mode');
	                        return;
	                    }
	                    this.$dispatch('client::manual');
	                    break;
	            }
	        }
	    }
	};

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-commands\">\n    <ui-button v-if=\"wamv.mode === 'paused'\"\n        @click=\"startMission\"\n    >Restart</ui-button>\n\n    <ui-button v-if=\"wamv.mode !== 'manual'\"\n        @click=\"toggleMission\" :text=\"startButtonText\"\n        :disabled=\"wamv.mode === 'killed'\"\n    ></ui-button>\n\n    <ui-button v-if=\"wamv.mode !== 'manual'\"\n        color=\"danger\" :text=\"wamv.mode === 'killed' ? 'Unkill' : 'Kill'\"\n        @click=\"toggleKill\"\n    ></ui-button>\n\n    <ui-button\n        :text=\"modeButtonText\"\n        has-dropdown-menu dropdown-position=\"bottom right\" :menu-options=\"overflowMenu\"\n        @menu-option-selected=\"menuOptionSelected\"\n    ></ui-button>\n\n    <div class=\"armed-toggle\" v-if=\"wamv.loaded\">\n        <ui-switch\n            :value.sync=\"isArmed\" :label=\"isArmed ? 'Armed' : 'Disarmed'\" label-left\n            :disabled=\"wamv.mode === 'auto'\"\n        ></ui-switch>\n    </div>\n</div>\n";

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(136)
	__vue_script__ = __webpack_require__(137)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\map\\GcsSidebarControls.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(138)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-aa18170a/GcsSidebarControls.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 136 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _GcsCommands = __webpack_require__(131);
	
	var _GcsCommands2 = _interopRequireDefault(_GcsCommands);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: {
	        showSidebar: {
	            type: Boolean,
	            required: true
	        }
	    },
	
	    methods: {
	        toggleSidebar: function toggleSidebar() {
	            this.$dispatch('toggle-sidebar');
	        }
	    },
	
	    components: {
	        GcsCommands: _GcsCommands2.default
	    }
	};

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = "\n<div\n    class=\"gcs-sidebar-controls\"\n    :style=\"{ transform: 'translateX(' + (showSidebar ? '376px' : '16px' + ')') }\"\n>\n    <ui-button\n        :color=\"showSidebar ? 'primary' : 'default'\" @click=\"toggleSidebar\"\n    >Missions</ui-button>\n</div>\n";

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(140)
	__vue_script__ = __webpack_require__(141)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\markers\\GcsWamv.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(142)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-b5bab4d2/GcsWamv.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 140 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isMarker = __webpack_require__(112);
	
	var _isMarker2 = _interopRequireDefault(_isMarker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    events: {
	        click: function click(e) {
	            console.log('Wamv clicked', e);
	        },
	        initialized: function initialized() {
	            window.wamv = this;
	        }
	    },
	
	    methods: {
	        getIcon: function getIcon() {
	            var scale = arguments.length <= 0 || arguments[0] === undefined ? this.scale : arguments[0];
	            var rotation = arguments.length <= 1 || arguments[1] === undefined ? this.rotation : arguments[1];
	
	            return {
	                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
	                rotation: rotation,
	                scale: scale,
	                fillColor: 'red',
	                fillOpacity: 0.8,
	                strokeColor: 'white',
	                strokeWeight: 2
	            };
	        }
	    },
	
	    mixins: [_isMarker2.default]
	};

/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-wamv\"></div>\n";

/***/ },
/* 143 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view map-view\">\n    <gcs-map></gcs-map>\n    <gcs-map-controls></gcs-map-controls>\n    <gcs-map-sidebar :show-sidebar=\"showSidebar\"></gcs-map-sidebar>\n\n    <gcs-sidebar-controls\n        :show-sidebar=\"showSidebar\" @toggle-sidebar=\"toggleSidebar\"\n    ></gcs-sidebar-controls>\n\n    <gcs-commands></gcs-commands>\n\n    <gcs-wamv v-if=\"wamv.loaded\"\n        :lat=\"wamv.position.lat\" :lng=\"wamv.position.lng\"\n        :rotation=\"wamv.heading\"\n    ></gcs-wamv>\n</div>\n";

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(145)
	__vue_script__ = __webpack_require__(146)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\views\\ParamsView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(151)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-04e87b4e/ParamsView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 145 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _defineProperty2 = __webpack_require__(147);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getters = __webpack_require__(72);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            parameters: _getters.getParameters,
	            parametersLastUpdateTime: _getters.getParametersLastUpdateTime
	        }
	    },
	
	    data: function data() {
	        return {
	            currentSectionIndex: 0,
	            changedParams: {},
	            lastSetParametersAckTime: null,
	            validationRules: {
	                vec3: ['regex:/^(-?\\d*\\.?\\d+,){2}(-?\\d*\\.?\\d+)$/'],
	                double: ['regex:/^(-?\\d*\\.?\\d+)$/'],
	                mat3: ['regex:/^(-?\\d*\\.?\\d+,){8}(-?\\d*\\.?\\d+)$/']
	            },
	            TIMEOUT: 1000
	        };
	    },
	
	
	    computed: {
	        currentSection: function currentSection() {
	            return this.parameters[this.currentSectionIndex];
	        }
	    },
	
	    methods: {
	        selectSection: function selectSection(index) {
	            this.currentSectionIndex = index;
	        },
	        isArray: function isArray(x) {
	            return Array.isArray(x);
	        },
	        paramChanged: function paramChanged(section, subsection, title, type, value, valid) {
	            if (this.changedParams.hasOwnProperty(section)) {
	                if (this.changedParams[section].hasOwnProperty(subsection)) {
	                    this.changedParams[section][subsection][title] = {
	                        type: type, value: value, valid: valid
	                    };
	                } else {
	                    this.changedParams[section][subsection] = (0, _defineProperty3.default)({}, title, { type: type, value: value, valid: valid });
	                }
	            } else {
	                this.changedParams[section] = (0, _defineProperty3.default)({}, subsection, (0, _defineProperty3.default)({}, title, { type: type, value: value, valid: valid }));
	            }
	        },
	        saveParams: function saveParams() {
	            var _this = this;
	
	            var data = [];
	            for (var sectionName in this.changedParams) {
	                var section = this.changedParams[sectionName];
	                for (var subsectionName in section) {
	                    var subsection = section[subsectionName];
	                    for (var paramName in subsection) {
	                        var param = subsection[paramName];
	                        if (!param.valid) {
	                            this.$dispatch('app::create-snackbar', 'A parameter value is invalid');
	                            return;
	                        }
	                        data.push({
	                            section: sectionName,
	                            subsection: subsectionName,
	                            title: paramName,
	                            type: param.type,
	                            value: param.value
	                        });
	                    }
	                }
	            }
	            this.$dispatch('client::set_parameters', data);
	
	            var requestTime = Date.now();
	            setTimeout(function () {
	                if (_this.lastSetParametersAckTime < requestTime) {
	                    _this.$dispatch('app::create-snackbar', 'Parameters not set within timeout');
	                }
	            }, this.TIMEOUT);
	        },
	        resetParams: function resetParams() {
	            var _this2 = this;
	
	            this.$dispatch('client::get_parameters');
	            var requestTime = Date.now();
	            setTimeout(function () {
	                if (_this2.parametersLastUpdateTime < requestTime) {
	                    _this2.$dispatch('app::create-snackbar', 'Parameters not received within timeout');
	                }
	            }, this.TIMEOUT);
	        },
	        getValidationRule: function getValidationRule(type) {
	            if (type) {
	                return this.validationRules[type];
	            }
	
	            return null;
	        }
	    },
	
	    events: {
	        'server::set_parameters_ack': function serverSet_parameters_ack() {
	            this.lastSetParametersAckTime = Date.now();
	        }
	    }
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(148);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(149), __esModule: true };

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(150);
	var $Object = __webpack_require__(30).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(28);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(38), 'Object', {defineProperty: __webpack_require__(34).f});

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view params-view\">\n    <div class=\"page\">\n        <h1 class=\"page-header\">\n            <span class=\"title\">Params</span>\n            <div class=\"action-buttons\">\n                <ui-button color=\"primary\"\n                    @click=\"saveParams\"\n                >Save</ui-button>\n                <ui-button\n                    @click=\"resetParams\"\n                >Reset</ui-button>\n            </div>\n        </h1>\n\n        <div class=\"page-content\">\n            <div class=\"page-sidebar\">\n                <div class=\"sidebar-menu\">\n                    <a\n                        href=\"#\" class=\"sidebar-menu-item\" v-for=\"(index, section) in parameters\"\n                        @click=\"selectSection(index)\" :class=\"{ 'selected': index === currentSectionIndex }\"\n                    >{{ section.title }}</a>\n                </div>\n            </div>\n\n            <div class=\"page-main\" v-if=\"parameters.length > 0\">\n                <ui-collapsible\n                    v-for=\"section in currentSection.subSections\" :header=\"section.title\"\n                >\n                    <div class=\"param\" v-for=\"param in section.params\">\n                        <ui-textbox\n                            :label=\"param.title\" :name=\"param.title\"\n                            :value.sync=\"param.value\" :valid.sync=\"param.valid\"\n                            @changed=\"paramChanged(currentSection.title, section.title, param.title, param.type, param.value, param.valid)\"\n                            :validation-rules=\"getValidationRule(param.type)\"\n                        ></ui-textbox>\n                    </div>\n                </ui-collapsible>\n            </div>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(153)
	__vue_script__ = __webpack_require__(154)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\views\\SettingsView.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(155)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-a6e91b14/SettingsView.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 153 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _defineProperty2 = __webpack_require__(147);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getters = __webpack_require__(72);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            settings: _getters.getSettings,
	            settingsLastUpdateTime: _getters.getSettingsLastUpdateTime
	        }
	    },
	
	    data: function data() {
	        return {
	            changedSettings: {},
	            lastSetSettingsAckTime: null,
	            TIMEOUT: 1000
	        };
	    },
	
	
	    methods: {
	        settingChanged: function settingChanged(section, param, value) {
	            if (this.changedSettings.hasOwnProperty(section)) {
	                this.changedSettings[section][param] = value;
	            } else {
	                this.changedSettings[section] = (0, _defineProperty3.default)({}, param, value);
	            }
	        },
	        saveSettings: function saveSettings() {
	            var _this = this;
	
	            var data = [];
	            for (var section in this.changedSettings) {
	                for (var setting in this.changedSettings[section]) {
	                    data.push({
	                        section: section,
	                        title: setting,
	                        value: this.changedSettings[section][setting]
	                    });
	                }
	            }
	            this.$dispatch('client::set_settings', data);
	
	            var requestTime = Date.now();
	            setTimeout(function () {
	                if (_this.lastSetSettingsAckTime < requestTime) {
	                    _this.$dispatch('app::create-snackbar', 'Settings not set within timeout');
	                }
	            }, this.TIMEOUT);
	        },
	        resetSettings: function resetSettings() {
	            var _this2 = this;
	
	            this.$dispatch('client::get_settings');
	            var requestTime = Date.now();
	            setTimeout(function () {
	                if (_this2.settingsLastUpdateTime < requestTime) {
	                    _this2.$dispatch('app::create-snackbar', 'Settings not received within timeout');
	                }
	            }, this.TIMEOUT);
	        }
	    },
	
	    events: {
	        'server::set_settings_ack': function serverSet_settings_ack() {
	            this.lastSetSettingsAckTime = Date.now();
	        }
	    }
	};

/***/ },
/* 155 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"view settings-view\">\n    <div class=\"page\">\n        <h1 class=\"page-header\">\n            Settings\n            <div class=\"action-buttons\">\n                <ui-button color=\"primary\"\n                    @click=\"saveSettings\"\n                >Save</ui-button>\n                <ui-button\n                    @click=\"resetSettings\"\n                >Reset</ui-button>\n            </div>\n        </h1>\n        <div class=\"page-content\">\n            <div class=\"page-main\">\n                <ui-collapsible v-for=\"section in settings\" :header=\"section.title\">\n                    <div class=\"setting\" v-for=\"setting in section.settings\">\n                        <ui-textbox\n                            :label=\"setting.title\" :name=\"setting.title\" :value.sync=\"setting.value\"\n                            @changed=\"settingChanged(section.title, setting.title, setting.value)\"\n                        ></ui-textbox>\n                    </div>\n                </ui-collapsible>\n            </div>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(157)
	__vue_script__ = __webpack_require__(158)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\GcsIndicators.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(159)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-6cb0c7ea/GcsIndicators.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 157 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(72);
	
	exports.default = {
	    vuex: {
	        getters: {
	            wamv: _getters.getWamv
	        }
	    },
	
	    computed: {
	        heading: function heading() {
	            var deg = Math.round(this.wamv.heading);
	            return deg + '&deg; ' + this.degreeToToCardinal(this.wamv.heading);
	        },
	        speed: function speed() {
	            var spd = Math.round(this.wamv.speed * 100) / 100;
	            return spd + ' K';
	        },
	        battery: function battery() {
	            var perc = Math.round(this.wamv.battery * 100) / 100;
	            return perc + '%';
	        },
	        signal: function signal() {
	            var perc = Math.round(this.wamv.signal * 100) / 100;
	            return perc + '%';
	        }
	    },
	
	    methods: {
	        degreeToToCardinal: function degreeToToCardinal(degree) {
	            if (degree < 22.5 || degree >= 337.5) {
	                return 'N';
	            }
	
	            if (degree < 67.5 && degree >= 22.5) {
	                return 'NE';
	            }
	
	            if (degree < 112.5 && degree >= 67.5) {
	                return 'E';
	            }
	
	            if (degree < 157.5 && degree >= 112.5) {
	                return 'SE';
	            }
	
	            if (degree < 202.5 && degree >= 157.5) {
	                return 'S';
	            }
	
	            if (degree < 247.5 && degree >= 202.5) {
	                return 'SW';
	            }
	
	            if (degree < 292.5 && degree >= 247.5) {
	                return 'W';
	            }
	
	            if (degree < 337.5 && degree >= 292.5) {
	                return 'NW';
	            }
	
	            return '';
	        }
	    }
	};

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = "\n<ul class=\"gcs-indicators\" v-if=\"wamv.loaded\">\n    <li class=\"indicator heading\">\n        <ui-icon\n            icon=\"navigation\" :style=\"{ transform: 'rotateZ(' + wamv.heading + 'deg)' }\"\n        ></ui-icon>\n        <span class=\"value\" v-html=\"heading\"></span>\n    </li>\n\n    <li class=\"indicator speed\">\n        <ui-icon icon=\"network_check\"></ui-icon>\n        <span class=\"value\" v-text=\"speed\"></span>\n    </li>\n\n    <li class=\"indicator battery\">\n        <ui-icon icon=\"battery_full\"></ui-icon>\n        <span class=\"value\" v-text=\"battery\"></span>\n    </li>\n\n    <li class=\"indicator signal\">\n        <ui-icon icon=\"wifi\"></ui-icon>\n        <span class=\"value\" v-text=\"signal\"></span>\n    </li>\n</ul>\n";

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(161)
	__vue_script__ = __webpack_require__(162)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\SocketIoManager.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(223)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-2be7ff78/SocketIoManager.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 161 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getOwnPropertyNames = __webpack_require__(163);
	
	var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);
	
	var _defineProperty2 = __webpack_require__(147);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getIterator2 = __webpack_require__(15);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _socket = __webpack_require__(167);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _protobufjs = __webpack_require__(217);
	
	var _protobufjs2 = _interopRequireDefault(_protobufjs);
	
	var _getters = __webpack_require__(72);
	
	var _actions = __webpack_require__(69);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    vuex: {
	        getters: {
	            missions: _getters.getMissions,
	            missionsLastUpdateTime: _getters.getMissionsLastUpdateTime,
	            parameters: _getters.getParameters,
	            parametersLastUpdateTime: _getters.getParametersLastUpdateTime,
	            settings: _getters.getSettings,
	            settingsLastUpdateTime: _getters.getSettingsLastUpdateTime
	        },
	        actions: {
	            setWamv: _actions.setWamv,
	            setParameters: _actions.setParameters,
	            setSettings: _actions.setSettings,
	            setMissions: _actions.setMissions
	        }
	    },
	
	    data: function data() {
	        return {
	            TIMEOUT: 1000,
	            socket: null,
	            protoBuilder: null,
	            protoPkg: null
	        };
	    },
	    ready: function ready() {
	        var _this = this;
	
	        this.protoBuilder = _protobufjs2.default.newBuilder();
	        _protobufjs2.default.loadProtoFile('assets/proto/Test.proto', function () {
	            _this.protoPkg = _this.protoBuilder.build();
	            _this.initSocket();
	        }, this.protoBuilder);
	    },
	
	
	    methods: {
	        initSocket: function initSocket() {
	            this.socket = (0, _socket2.default)('localhost:3000');
	            this.socket.on('connect', this.handleConnectionEstablished);
	            this.socket.on('disconnect', function () {
	                console.log('disconnected from server');
	            });
	            this.socket.on('Status', this.handleStatus);
	            this.socket.on('GetParametersResponse', this.handleGetParametersResponse);
	            this.socket.on('GetSettingsResponse', this.handleGetSettingsResponse);
	            this.socket.on('GetMissionsResponse', this.handleGetMissionsResponse);
	            this.socket.on('GetMissionResponse', this.handleGetMissionResponse);
	            this.socket.on('SetParametersAck', this.handleSetParametersAck);
	            this.socket.on('SetSettingsAck', this.handleSetSettingsAck);
	            this.socket.on('SetMissionAck', this.handleSetMissionAck);
	            this.socket.on('SetMissionsAck', this.handleSetMissionsAck);
	            this.socket.on('Attention', this.handleAttention);
	        },
	        sendMsg: function sendMsg(msgType, data) {
	            var timestamp = Date.now();
	            var msg = void 0;
	            switch (msgType) {
	                case 'controller_event':
	                    this.socket.emit('ControllerAction', data);
	                    break;
	                case 'get_parameters':
	                    this.socket.emit('GetParameters', new this.protoPkg.GetParameters(timestamp).toBuffer());
	                    break;
	                case 'set_parameters':
	                    msg = new this.protoPkg.SetParameters();
	                    msg.timestamp = timestamp;
	                    var _iteratorNormalCompletion = true;
	                    var _didIteratorError = false;
	                    var _iteratorError = undefined;
	
	                    try {
	                        for (var _iterator = (0, _getIterator3.default)(data), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                            var param = _step.value;
	
	                            msg.add('parameters', new this.protoPkg.Parameter(param.section, param.subsection, param.title, this.paramType(param.type), param.value));
	                        }
	                    } catch (err) {
	                        _didIteratorError = true;
	                        _iteratorError = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion && _iterator.return) {
	                                _iterator.return();
	                            }
	                        } finally {
	                            if (_didIteratorError) {
	                                throw _iteratorError;
	                            }
	                        }
	                    }
	
	                    this.socket.emit('SetParameters', msg.toBuffer());
	                    break;
	                case 'get_settings':
	                    this.socket.emit('GetSettings', new this.protoPkg.GetSettings(timestamp).toBuffer());
	                    break;
	                case 'set_settings':
	                    msg = new this.protoPkg.SetSettings();
	                    msg.timestamp = timestamp;
	                    var _iteratorNormalCompletion2 = true;
	                    var _didIteratorError2 = false;
	                    var _iteratorError2 = undefined;
	
	                    try {
	                        for (var _iterator2 = (0, _getIterator3.default)(data), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                            var setting = _step2.value;
	
	                            msg.add('settings', new this.protoPkg.Setting(setting.section, setting.title, setting.value));
	                        }
	                    } catch (err) {
	                        _didIteratorError2 = true;
	                        _iteratorError2 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                _iterator2.return();
	                            }
	                        } finally {
	                            if (_didIteratorError2) {
	                                throw _iteratorError2;
	                            }
	                        }
	                    }
	
	                    this.socket.emit('SetSettings', msg.toBuffer());
	                    break;
	                case 'get_mission':
	                    this.socket.emit('GetMission', new this.protoPkg.GetMission(timestamp).toBuffer());
	                    break;
	                case 'set_mission':
	                    msg = new this.protoPkg.SetMission(timestamp, new this.protoPkg.Mission());
	                    msg.mission.title = data.title;
	                    msg.mission.originLatitude = data.origin.lat;
	                    msg.mission.originLongitude = data.origin.lng;
	                    var _iteratorNormalCompletion3 = true;
	                    var _didIteratorError3 = false;
	                    var _iteratorError3 = undefined;
	
	                    try {
	                        for (var _iterator3 = (0, _getIterator3.default)(data.waypoints), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                            var waypoint = _step3.value;
	
	                            msg.mission.add('waypoints', new this.protoPkg.Mission.Waypoint(waypoint.title, this.waypointType(waypoint.type), waypoint.position.lat, waypoint.position.lng));
	                        }
	                    } catch (err) {
	                        _didIteratorError3 = true;
	                        _iteratorError3 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                                _iterator3.return();
	                            }
	                        } finally {
	                            if (_didIteratorError3) {
	                                throw _iteratorError3;
	                            }
	                        }
	                    }
	
	                    this.socket.emit('SetMission', msg.toBuffer());
	                    break;
	                case 'get_missions':
	                    this.socket.emit('GetMissions', new this.protoPkg.GetMissions(timestamp).toBuffer());
	                    break;
	                case 'set_missions':
	                    msg = new this.protoPkg.SetMissions();
	                    msg.timestamp = timestamp;
	                    var _iteratorNormalCompletion4 = true;
	                    var _didIteratorError4 = false;
	                    var _iteratorError4 = undefined;
	
	                    try {
	                        for (var _iterator4 = (0, _getIterator3.default)(data), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                            var mission = _step4.value;
	
	                            var m = new this.protoPkg.Mission();
	                            m.title = mission.title;
	                            m.originLatitude = mission.origin.lat;
	                            m.originLongitude = mission.origin.lng;
	                            var _iteratorNormalCompletion5 = true;
	                            var _didIteratorError5 = false;
	                            var _iteratorError5 = undefined;
	
	                            try {
	                                for (var _iterator5 = (0, _getIterator3.default)(mission.waypoints), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                                    var _waypoint = _step5.value;
	
	                                    m.add('waypoints', new this.protoPkg.Mission.Waypoint(_waypoint.title, this.waypointType(_waypoint.type), _waypoint.position.lat, _waypoint.position.lng));
	                                }
	                            } catch (err) {
	                                _didIteratorError5 = true;
	                                _iteratorError5 = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                                        _iterator5.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError5) {
	                                        throw _iteratorError5;
	                                    }
	                                }
	                            }
	
	                            msg.add('missions', m);
	                        }
	                    } catch (err) {
	                        _didIteratorError4 = true;
	                        _iteratorError4 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                                _iterator4.return();
	                            }
	                        } finally {
	                            if (_didIteratorError4) {
	                                throw _iteratorError4;
	                            }
	                        }
	                    }
	
	                    this.socket.emit('SetMissions', msg.toBuffer());
	                    break;
	                case 'arm':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.ARM);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'disarm':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.DISARM);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'start_mission':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.START);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'stop_mission':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.STOP);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'resume_mission':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.RESUME);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'kill':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.KILL);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'unkill':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.UNKILL);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'manual':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.MANUAL);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	                case 'auto':
	                    msg = new this.protoPkg.Command(timestamp, this.protoPkg.Command.Type.AUTOMATIC);
	                    this.socket.emit('Command', msg.toBuffer());
	                    break;
	            }
	        },
	        handleConnectionEstablished: function handleConnectionEstablished() {
	            var _this2 = this;
	
	            console.log('connected to server');
	
	            this.sendMsg('get_parameters', null);
	            setTimeout(function () {
	                if (_this2.parametersLastUpdateTime === null) {
	                    _this2.$dispatch('app::create-snackbar', 'Parameters list failed to load');
	                }
	            }, this.TIMEOUT);
	
	            this.sendMsg('get_settings', null);
	            setTimeout(function () {
	                if (_this2.settingsLastUpdateTime === null) {
	                    _this2.$dispatch('app::create-snackbar', 'Settings list failed to load');
	                }
	            }, this.TIMEOUT);
	
	            this.sendMsg('get_missions', null);
	            setTimeout(function () {
	                if (_this2.missionsLastUpdateTime === null) {
	                    _this2.$dispatch('app::create-snackbar', 'Mission list failed to load');
	                }
	            }, this.TIMEOUT);
	        },
	        handleStatus: function handleStatus(data) {
	
	            this.setWamv({
	                loaded: true,
	                position: { lat: data.lat, lng: data.lng },
	                heading: data.heading,
	                speed: data.surge_vel,
	                battery: 100,
	                armed: data.armed,
	                mode: 'manual',
	                signal: 100
	            });
	        },
	        handleGetParametersResponse: function handleGetParametersResponse(data) {
	            var paramsMsg = void 0;
	            try {
	                paramsMsg = this.protoPkg.GetParametersResponse.decode(data);
	            } catch (e) {
	                console.log('Unable to decode GetParametersResponse message');
	                return;
	            }
	
	            var tempParams = {};
	            var _iteratorNormalCompletion6 = true;
	            var _didIteratorError6 = false;
	            var _iteratorError6 = undefined;
	
	            try {
	                for (var _iterator6 = (0, _getIterator3.default)(paramsMsg.parameters), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	                    var p = _step6.value;
	
	                    if (p.section in tempParams) {
	                        if (p.subSection in tempParams[p.section]) {
	                            if (p.title in tempParams[p.section][p.subSection]) {
	                                console.log('Warning: received duplicate parameter');
	                            } else {
	                                tempParams[p.section][p.subSection][p.title] = {
	                                    type: this.paramTypeString(p.type),
	                                    value: p.value
	                                };
	                            }
	                        } else {
	                            tempParams[p.section][p.subSection] = (0, _defineProperty3.default)({}, p.title, {
	                                type: this.paramTypeString(p.type),
	                                value: p.value
	                            });
	                        }
	                    } else {
	                        tempParams[p.section] = (0, _defineProperty3.default)({}, p.subSection, (0, _defineProperty3.default)({}, p.title, {
	                            type: this.paramTypeString(p.type),
	                            value: p.value
	                        }));
	                    }
	                }
	            } catch (err) {
	                _didIteratorError6 = true;
	                _iteratorError6 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                        _iterator6.return();
	                    }
	                } finally {
	                    if (_didIteratorError6) {
	                        throw _iteratorError6;
	                    }
	                }
	            }
	
	            var newParams = [];
	            var _iteratorNormalCompletion7 = true;
	            var _didIteratorError7 = false;
	            var _iteratorError7 = undefined;
	
	            try {
	                for (var _iterator7 = (0, _getIterator3.default)((0, _getOwnPropertyNames2.default)(tempParams)), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	                    var sectionName = _step7.value;
	
	                    var section = tempParams[sectionName];
	                    var newSection = { title: sectionName, subSections: [] };
	                    newParams.push(newSection);
	                    var _iteratorNormalCompletion8 = true;
	                    var _didIteratorError8 = false;
	                    var _iteratorError8 = undefined;
	
	                    try {
	                        for (var _iterator8 = (0, _getIterator3.default)((0, _getOwnPropertyNames2.default)(section)), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	                            var subSectionName = _step8.value;
	
	                            var subSection = section[subSectionName];
	                            var newSubSection = { title: subSectionName, params: [] };
	                            newSection.subSections.push(newSubSection);
	                            var _iteratorNormalCompletion9 = true;
	                            var _didIteratorError9 = false;
	                            var _iteratorError9 = undefined;
	
	                            try {
	                                for (var _iterator9 = (0, _getIterator3.default)((0, _getOwnPropertyNames2.default)(subSection)), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	                                    var paramName = _step9.value;
	
	                                    var param = subSection[paramName];
	                                    newSubSection.params.push({
	                                        title: paramName,
	                                        type: param.type,
	                                        value: param.value,
	                                        valid: true
	                                    });
	                                }
	                            } catch (err) {
	                                _didIteratorError9 = true;
	                                _iteratorError9 = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
	                                        _iterator9.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError9) {
	                                        throw _iteratorError9;
	                                    }
	                                }
	                            }
	                        }
	                    } catch (err) {
	                        _didIteratorError8 = true;
	                        _iteratorError8 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion8 && _iterator8.return) {
	                                _iterator8.return();
	                            }
	                        } finally {
	                            if (_didIteratorError8) {
	                                throw _iteratorError8;
	                            }
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError7 = true;
	                _iteratorError7 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                        _iterator7.return();
	                    }
	                } finally {
	                    if (_didIteratorError7) {
	                        throw _iteratorError7;
	                    }
	                }
	            }
	
	            this.setParameters(newParams);
	            console.log('Parameters loaded.');
	        },
	        handleGetSettingsResponse: function handleGetSettingsResponse(data) {
	            var settingsMsg = void 0;
	            try {
	                settingsMsg = this.protoPkg.GetSettingsResponse.decode(data);
	            } catch (e) {
	                console.log('Unable to decode GetSettingsResponse message');
	                return;
	            }
	
	            var tempSettings = {};
	            var _iteratorNormalCompletion10 = true;
	            var _didIteratorError10 = false;
	            var _iteratorError10 = undefined;
	
	            try {
	                for (var _iterator10 = (0, _getIterator3.default)(settingsMsg.settings), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	                    var s = _step10.value;
	
	                    if (s.section in tempSettings) {
	                        if (s.title in tempSettings[s.section]) {
	                            console.log('Warning: received duplicate setting');
	                        } else {
	                            tempSettings[s.section][s.title] = s.value;
	                        }
	                    } else {
	                        tempSettings[s.section] = (0, _defineProperty3.default)({}, s.title, s.value);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError10 = true;
	                _iteratorError10 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion10 && _iterator10.return) {
	                        _iterator10.return();
	                    }
	                } finally {
	                    if (_didIteratorError10) {
	                        throw _iteratorError10;
	                    }
	                }
	            }
	
	            var newSettings = [];
	            var _iteratorNormalCompletion11 = true;
	            var _didIteratorError11 = false;
	            var _iteratorError11 = undefined;
	
	            try {
	                for (var _iterator11 = (0, _getIterator3.default)((0, _getOwnPropertyNames2.default)(tempSettings)), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	                    var sectionName = _step11.value;
	
	                    var section = tempSettings[sectionName];
	                    var newSection = { title: sectionName, settings: [] };
	                    newSettings.push(newSection);
	                    var _iteratorNormalCompletion12 = true;
	                    var _didIteratorError12 = false;
	                    var _iteratorError12 = undefined;
	
	                    try {
	                        for (var _iterator12 = (0, _getIterator3.default)((0, _getOwnPropertyNames2.default)(section)), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	                            var settingName = _step12.value;
	
	                            newSection.settings.push({
	                                title: settingName,
	                                value: section[settingName]
	                            });
	                        }
	                    } catch (err) {
	                        _didIteratorError12 = true;
	                        _iteratorError12 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion12 && _iterator12.return) {
	                                _iterator12.return();
	                            }
	                        } finally {
	                            if (_didIteratorError12) {
	                                throw _iteratorError12;
	                            }
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError11 = true;
	                _iteratorError11 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion11 && _iterator11.return) {
	                        _iterator11.return();
	                    }
	                } finally {
	                    if (_didIteratorError11) {
	                        throw _iteratorError11;
	                    }
	                }
	            }
	
	            this.setSettings(newSettings);
	            console.log('Settings loaded.');
	        },
	        handleGetMissionsResponse: function handleGetMissionsResponse(data) {
	            var _this3 = this;
	
	            var missionsMsg = void 0;
	            try {
	                missionsMsg = this.protoPkg.GetMissionsResponse.decode(data);
	            } catch (e) {
	                console.log('Unable to decode GetMissionsResponse message');
	                return;
	            }
	
	            var newMissions = [];
	            var _iteratorNormalCompletion13 = true;
	            var _didIteratorError13 = false;
	            var _iteratorError13 = undefined;
	
	            try {
	                for (var _iterator13 = (0, _getIterator3.default)(missionsMsg.missions), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
	                    var mission = _step13.value;
	
	                    newMissions.push({
	                        title: mission.title,
	                        origin: {
	                            lat: mission.originLatitude,
	                            lng: mission.originLongitude
	                        },
	                        waypoints: mission.waypoints.map(function (wp) {
	                            return {
	                                title: wp.title,
	                                type: _this3.waypointTypeString(wp.type),
	                                position: {
	                                    lat: wp.latitude,
	                                    lng: wp.longitude
	                                }
	                            };
	                        })
	                    });
	                }
	            } catch (err) {
	                _didIteratorError13 = true;
	                _iteratorError13 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion13 && _iterator13.return) {
	                        _iterator13.return();
	                    }
	                } finally {
	                    if (_didIteratorError13) {
	                        throw _iteratorError13;
	                    }
	                }
	            }
	
	            this.setMissions(newMissions);
	            console.log('Missions loaded.');
	        },
	        handleGetMissionResponse: function handleGetMissionResponse(data) {
	            var _this4 = this;
	
	            var missionMsg = void 0;
	            try {
	                missionMsg = this.protoPkg.GetMissionResponse.decode(data).mission;
	            } catch (e) {
	                console.log('Unable to decode GetMissionResponse message');
	                return;
	            }
	
	            this.missions.push({
	                title: missionMsg.title,
	                origin: {
	                    lat: missionMsg.originLatitude,
	                    lng: missionMsg.originLongitude
	                },
	                waypoints: missionMsg.waypoints.map(function (wp) {
	                    return {
	                        title: wp.title,
	                        type: _this4.waypointTypeString(wp.type),
	                        position: {
	                            lat: wp.latitude,
	                            lng: wp.longitude
	                        }
	                    };
	                })
	            });
	            console.log('Mission downloaded.');
	        },
	        handleSetParametersAck: function handleSetParametersAck(data) {
	            try {
	                this.protoPkg.SetParametersAck.decode(data);
	            } catch (e) {
	                console.log('Unable to decode SetParametersAck message');
	                return;
	            }
	
	            this.$dispatch('app::create-snackbar', 'Parameters set on vehicle');
	            this.$dispatch('server::set_parameters_ack');
	        },
	        handleSetSettingsAck: function handleSetSettingsAck(data) {
	            try {
	                this.protoPkg.SetSettingsAck.decode(data);
	            } catch (e) {
	                console.log('Unable to decode SetSettingsAck message');
	                return;
	            }
	
	            this.$dispatch('app::create-snackbar', 'Settings set on server');
	            this.$dispatch('server::set_settings_ack');
	        },
	        handleSetMissionAck: function handleSetMissionAck(data) {
	            try {
	                this.protoPkg.SetMissionAck.decode(data);
	            } catch (e) {
	                console.log('Unable to decode SetMissionAck message');
	                return;
	            }
	
	            this.$dispatch('app::create-snackbar', 'Mission set on vehicle');
	            this.$dispatch('server::set_mission_ack');
	        },
	        handleSetMissionsAck: function handleSetMissionsAck(data) {
	            try {
	                this.protoPkg.SetMissionsAck.decode(data);
	            } catch (e) {
	                console.log('Unable to decode SetMissionsAck message');
	                return;
	            }
	
	            this.$dispatch('app::create-snackbar', 'Mission list set on server');
	        },
	        handleAttention: function handleAttention(data) {
	            var attentionMsg = void 0;
	            try {
	                attentionMsg = this.protoPkg.Attention.decode(data);
	            } catch (e) {
	                console.log('Unable to decode Attention message');
	                return;
	            }
	
	            this.$dispatch('app::create-snackbar', attentionMsg.msg);
	        },
	        modeString: function modeString(mode) {
	            switch (mode) {
	                case this.protoPkg.Status.Mode.STOPPED:
	                    return 'idle';
	                case this.protoPkg.Status.Mode.AUTO:
	                    return 'auto';
	                case this.protoPkg.Status.Mode.PAUSED:
	                    return 'paused';
	                case this.protoPkg.Status.Mode.KILLED:
	                    return 'killed';
	                case this.protoPkg.Status.Mode.MANUAL:
	                    return 'manual';
	                default:
	                    throw new Error('Invalid mode type');
	            }
	        },
	        paramTypeString: function paramTypeString(type) {
	            switch (type) {
	                case this.protoPkg.Parameter.Type.DOUBLE:
	                    return 'double';
	                case this.protoPkg.Parameter.Type.VEC3:
	                    return 'vec3';
	                case this.protoPkg.Parameter.Type.MAT3:
	                    return 'mat3';
	                default:
	                    throw new Error('Invalid parameter type');
	            }
	        },
	        paramType: function paramType(str) {
	            switch (str) {
	                case 'double':
	                    return this.protoPkg.Parameter.Type.DOUBLE;
	                case 'vec3':
	                    return this.protoPkg.Parameter.Type.VEC3;
	                case 'mat3':
	                    return this.protoPkg.Parameter.Type.MAT3;
	                default:
	                    throw new Error('Invalid parameter type string');
	            }
	        },
	        waypointTypeString: function waypointTypeString(type) {
	            switch (type) {
	                case this.protoPkg.Mission.Waypoint.Type.GO_TO_POINT:
	                    return 'go_to_point';
	                default:
	                    throw new Error('Invalid waypoint type string');
	            }
	        },
	        waypointType: function waypointType(str) {
	            switch (str) {
	                case 'go_to_point':
	                    return this.protoPkg.Mission.Waypoint.Type.GO_TO_POINT;
	                default:
	                    throw new Error('Invalid waypoint type');
	            }
	        }
	    },
	
	    events: {
	        'client::get_parameters': function clientGet_parameters() {
	            this.sendMsg('get_parameters', null);
	        },
	        'client::set_parameters': function clientSet_parameters(params) {
	            this.sendMsg('set_parameters', params);
	        },
	        'client::get_settings': function clientGet_settings() {
	            this.sendMsg('get_settings', null);
	        },
	        'client::set_settings': function clientSet_settings(settings) {
	            this.sendMsg('set_settings', settings);
	        },
	        'client::set_missions': function clientSet_missions(missions) {
	            this.sendMsg('set_missions', missions);
	        },
	        'client::get_missions': function clientGet_missions() {
	            this.sendMsg('get_missions', null);
	        },
	        'client::set_mission': function clientSet_mission(mission) {
	            this.sendMsg('set_mission', mission);
	        },
	        'client::get_mission': function clientGet_mission() {
	            this.sendMsg('get_mission', null);
	        },
	        'client::arm': function clientArm() {
	            this.sendMsg('arm', null);
	        },
	        'client::disarm': function clientDisarm() {
	            this.sendMsg('disarm', null);
	        },
	        'client::start_mission': function clientStart_mission() {
	            this.sendMsg('start_mission', null);
	        },
	        'client::stop_mission': function clientStop_mission() {
	            this.sendMsg('stop_mission', null);
	        },
	        'client::resume_mission': function clientResume_mission() {
	            this.sendMsg('resume_mission', null);
	        },
	        'client::kill': function clientKill() {
	            this.sendMsg('kill', null);
	        },
	        'client::unkill': function clientUnkill() {
	            this.sendMsg('unkill', null);
	        },
	        'client::manual': function clientManual() {
	            this.sendMsg('manual', null);
	        },
	        'client::auto': function clientAuto() {
	            this.sendMsg('auto', null);
	        },
	        'client::controller_event': function clientController_event(data) {
	            this.sendMsg('controller_event', data);
	        }
	    }
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(164), __esModule: true };

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(165);
	var $Object = __webpack_require__(30).Object;
	module.exports = function getOwnPropertyNames(it){
	  return $Object.getOwnPropertyNames(it);
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(166)('getOwnPropertyNames', function(){
	  return __webpack_require__(98).f;
	});

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(28)
	  , core    = __webpack_require__(30)
	  , fails   = __webpack_require__(39);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(168);
	var parser = __webpack_require__(173);
	var Manager = __webpack_require__(181);
	var debug = __webpack_require__(170)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] ||
	                      false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(181);
	exports.Socket = __webpack_require__(209);


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(169);
	var debug = __webpack_require__(170)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc){
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
	
	  return obj;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 169 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(171);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(172);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 172 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(170)('socket.io-parser');
	var json = __webpack_require__(174);
	var isArray = __webpack_require__(177);
	var Emitter = __webpack_require__(178);
	var binary = __webpack_require__(179);
	var isBuf = __webpack_require__(180);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(176);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(175)(module), (function() { return this; }())))

/***/ },
/* 175 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 176 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 177 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 178 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(177);
	var isBuf = __webpack_require__(180);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 180 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(182);
	var Socket = __webpack_require__(209);
	var Emitter = __webpack_require__(210);
	var parser = __webpack_require__(173);
	var on = __webpack_require__(212);
	var bind = __webpack_require__(213);
	var debug = __webpack_require__(170)('socket.io-client:manager');
	var indexOf = __webpack_require__(207);
	var Backoff = __webpack_require__(216);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function(){
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function(){
	  this.lastPing = new Date;
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function(){
	  this.emitAll('pong', new Date - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function(){
	  debug('cleanup');
	
	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();
	
	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' == this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function(reason){
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(183);


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(184);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(191);


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(185);
	var Emitter = __webpack_require__(200);
	var debug = __webpack_require__(170)('engine.io-client:socket');
	var index = __webpack_require__(207);
	var parser = __webpack_require__(191);
	var parseuri = __webpack_require__(169);
	var parsejson = __webpack_require__(208);
	var parseqs = __webpack_require__(201);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop(){}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(190);
	Socket.transports = __webpack_require__(185);
	Socket.parser = __webpack_require__(191);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose(){
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function(){
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function() {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(186);
	var XHR = __webpack_require__(188);
	var JSONP = __webpack_require__(204);
	var websocket = __webpack_require__(205);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(187);
	
	module.exports = function(opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }
	
	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 187 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(186);
	var Polling = __webpack_require__(189);
	var Emitter = __webpack_require__(200);
	var inherit = __webpack_require__(202);
	var debug = __webpack_require__(170)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty(){}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts){
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }
	
	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function(){
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(190);
	var parseqs = __webpack_require__(201);
	var parser = __webpack_require__(191);
	var inherit = __webpack_require__(202);
	var yeast = __webpack_require__(203);
	var debug = __webpack_require__(170)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(186);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function(){
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function(){
	  var self = this;
	
	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(191);
	var Emitter = __webpack_require__(200);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(192);
	var hasBinary = __webpack_require__(193);
	var sliceBuffer = __webpack_require__(195);
	var base64encoder = __webpack_require__(196);
	var after = __webpack_require__(197);
	var utf8 = __webpack_require__(198);
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = navigator.userAgent.match(/Android/i);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(199);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if(numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 192 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(194);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 195 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
	
	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 196 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 197 */
/***/ function(module, exports) {

	module.exports = after
	
	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count
	
	    return (count === 0) ? callback() : proxy
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}
	
	function noop() {}


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, its not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(175)(module), (function() { return this; }())))

/***/ },
/* 199 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      ary[i] = buf;
	    }
	  }
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);
	
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};
	
	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 200 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 201 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 202 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 203 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;
	
	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(189);
	var inherit = __webpack_require__(202);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  }
	  else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch(e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(190);
	var parser = __webpack_require__(191);
	var parseqs = __webpack_require__(201);
	var inherit = __webpack_require__(202);
	var yeast = __webpack_require__(203);
	var debug = __webpack_require__(170)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(206);
	  } catch (e) { }
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	
	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function(){
	  var self = this;
	
	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function(packet) {
	      parser.encodePacket(packet, self.supportsBinary, function(data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e){
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done(){
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function(){
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 206 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 207 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 208 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(173);
	var Emitter = __webpack_require__(210);
	var toArray = __webpack_require__(211);
	var on = __webpack_require__(212);
	var bind = __webpack_require__(213);
	var debug = __webpack_require__(170)('socket.io-client:socket');
	var hasBin = __webpack_require__(214);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function() {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  delete this.flags;
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function(packet){
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function(compress){
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};


/***/ },
/* 210 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = toArray
	
	function toArray(list, index) {
	    var array = []
	
	    index = index || 0
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }
	
	    return array
	}


/***/ },
/* 212 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 213 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(215);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 216 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, module) {/*
	 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
	
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	
	 http://www.apache.org/licenses/LICENSE-2.0
	
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: https://github.com/dcodeIO/protobuf.js for details
	 */
	(function(global, factory) {
	
	    /* AMD */ if ("function" === 'function' && __webpack_require__(218)["amd"])
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(219)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    /* CommonJS */ else if ("function" === "function" && typeof module === "object" && module && module["exports"])
	        module["exports"] = factory(__webpack_require__(219), true);
	    /* Global */ else
	        (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
	
	})(this, function(ByteBuffer, isCommonJS) {
	    "use strict";
	
	    /**
	     * The ProtoBuf namespace.
	     * @exports ProtoBuf
	     * @namespace
	     * @expose
	     */
	    var ProtoBuf = {};
	
	    /**
	     * @type {!function(new: ByteBuffer, ...[*])}
	     * @expose
	     */
	    ProtoBuf.ByteBuffer = ByteBuffer;
	
	    /**
	     * @type {?function(new: Long, ...[*])}
	     * @expose
	     */
	    ProtoBuf.Long = ByteBuffer.Long || null;
	
	    /**
	     * ProtoBuf.js version.
	     * @type {string}
	     * @const
	     * @expose
	     */
	    ProtoBuf.VERSION = "5.0.1";
	
	    /**
	     * Wire types.
	     * @type {Object.<string,number>}
	     * @const
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES = {};
	
	    /**
	     * Varint wire type.
	     * @type {number}
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES.VARINT = 0;
	
	    /**
	     * Fixed 64 bits wire type.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES.BITS64 = 1;
	
	    /**
	     * Length delimited wire type.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES.LDELIM = 2;
	
	    /**
	     * Start group wire type.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;
	
	    /**
	     * End group wire type.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;
	
	    /**
	     * Fixed 32 bits wire type.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.WIRE_TYPES.BITS32 = 5;
	
	    /**
	     * Packable wire types.
	     * @type {!Array.<number>}
	     * @const
	     * @expose
	     */
	    ProtoBuf.PACKABLE_WIRE_TYPES = [
	        ProtoBuf.WIRE_TYPES.VARINT,
	        ProtoBuf.WIRE_TYPES.BITS64,
	        ProtoBuf.WIRE_TYPES.BITS32
	    ];
	
	    /**
	     * Types.
	     * @dict
	     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
	     * @const
	     * @expose
	     */
	    ProtoBuf.TYPES = {
	        // According to the protobuf spec.
	        "int32": {
	            name: "int32",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: 0
	        },
	        "uint32": {
	            name: "uint32",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: 0
	        },
	        "sint32": {
	            name: "sint32",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: 0
	        },
	        "int64": {
	            name: "int64",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
	        },
	        "uint64": {
	            name: "uint64",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
	        },
	        "sint64": {
	            name: "sint64",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
	        },
	        "bool": {
	            name: "bool",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: false
	        },
	        "double": {
	            name: "double",
	            wireType: ProtoBuf.WIRE_TYPES.BITS64,
	            defaultValue: 0
	        },
	        "string": {
	            name: "string",
	            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
	            defaultValue: ""
	        },
	        "bytes": {
	            name: "bytes",
	            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
	            defaultValue: null // overridden in the code, must be a unique instance
	        },
	        "fixed32": {
	            name: "fixed32",
	            wireType: ProtoBuf.WIRE_TYPES.BITS32,
	            defaultValue: 0
	        },
	        "sfixed32": {
	            name: "sfixed32",
	            wireType: ProtoBuf.WIRE_TYPES.BITS32,
	            defaultValue: 0
	        },
	        "fixed64": {
	            name: "fixed64",
	            wireType: ProtoBuf.WIRE_TYPES.BITS64,
	            defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
	        },
	        "sfixed64": {
	            name: "sfixed64",
	            wireType: ProtoBuf.WIRE_TYPES.BITS64,
	            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
	        },
	        "float": {
	            name: "float",
	            wireType: ProtoBuf.WIRE_TYPES.BITS32,
	            defaultValue: 0
	        },
	        "enum": {
	            name: "enum",
	            wireType: ProtoBuf.WIRE_TYPES.VARINT,
	            defaultValue: 0
	        },
	        "message": {
	            name: "message",
	            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
	            defaultValue: null
	        },
	        "group": {
	            name: "group",
	            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
	            defaultValue: null
	        }
	    };
	
	    /**
	     * Valid map key types.
	     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
	     * @const
	     * @expose
	     */
	    ProtoBuf.MAP_KEY_TYPES = [
	        ProtoBuf.TYPES["int32"],
	        ProtoBuf.TYPES["sint32"],
	        ProtoBuf.TYPES["sfixed32"],
	        ProtoBuf.TYPES["uint32"],
	        ProtoBuf.TYPES["fixed32"],
	        ProtoBuf.TYPES["int64"],
	        ProtoBuf.TYPES["sint64"],
	        ProtoBuf.TYPES["sfixed64"],
	        ProtoBuf.TYPES["uint64"],
	        ProtoBuf.TYPES["fixed64"],
	        ProtoBuf.TYPES["bool"],
	        ProtoBuf.TYPES["string"],
	        ProtoBuf.TYPES["bytes"]
	    ];
	
	    /**
	     * Minimum field id.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.ID_MIN = 1;
	
	    /**
	     * Maximum field id.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ProtoBuf.ID_MAX = 0x1FFFFFFF;
	
	    /**
	     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
	     *  Must be set prior to parsing.
	     * @type {boolean}
	     * @expose
	     */
	    ProtoBuf.convertFieldsToCamelCase = false;
	
	    /**
	     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
	     *  setting this to `false` prior to building messages.
	     * @type {boolean}
	     * @expose
	     */
	    ProtoBuf.populateAccessors = true;
	
	    /**
	     * By default, messages are populated with default values if a field is not present on the wire. To disable
	     *  this behavior, set this setting to `false`.
	     * @type {boolean}
	     * @expose
	     */
	    ProtoBuf.populateDefaults = true;
	
	    /**
	     * @alias ProtoBuf.Util
	     * @expose
	     */
	    ProtoBuf.Util = (function() {
	        "use strict";
	
	        /**
	         * ProtoBuf utilities.
	         * @exports ProtoBuf.Util
	         * @namespace
	         */
	        var Util = {};
	
	        /**
	         * Flag if running in node or not.
	         * @type {boolean}
	         * @const
	         * @expose
	         */
	        Util.IS_NODE = !!(
	            typeof process === 'object' && process+'' === '[object process]' && !process['browser']
	        );
	
	        /**
	         * Constructs a XMLHttpRequest object.
	         * @return {XMLHttpRequest}
	         * @throws {Error} If XMLHttpRequest is not supported
	         * @expose
	         */
	        Util.XHR = function() {
	            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
	            var XMLHttpFactories = [
	                function () {return new XMLHttpRequest()},
	                function () {return new ActiveXObject("Msxml2.XMLHTTP")},
	                function () {return new ActiveXObject("Msxml3.XMLHTTP")},
	                function () {return new ActiveXObject("Microsoft.XMLHTTP")}
	            ];
	            /** @type {?XMLHttpRequest} */
	            var xhr = null;
	            for (var i=0;i<XMLHttpFactories.length;i++) {
	                try { xhr = XMLHttpFactories[i](); }
	                catch (e) { continue; }
	                break;
	            }
	            if (!xhr)
	                throw Error("XMLHttpRequest is not supported");
	            return xhr;
	        };
	
	        /**
	         * Fetches a resource.
	         * @param {string} path Resource path
	         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
	         *   be fetched synchronously. If the request failed, contents will be null.
	         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
	         * @expose
	         */
	        Util.fetch = function(path, callback) {
	            if (callback && typeof callback != 'function')
	                callback = null;
	            if (Util.IS_NODE) {
	                var fs = __webpack_require__(221);
	                if (callback) {
	                    fs.readFile(path, function(err, data) {
	                        if (err)
	                            callback(null);
	                        else
	                            callback(""+data);
	                    });
	                } else
	                    try {
	                        return fs.readFileSync(path);
	                    } catch (e) {
	                        return null;
	                    }
	            } else {
	                var xhr = Util.XHR();
	                xhr.open('GET', path, callback ? true : false);
	                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
	                xhr.setRequestHeader('Accept', 'text/plain');
	                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
	                if (callback) {
	                    xhr.onreadystatechange = function() {
	                        if (xhr.readyState != 4) return;
	                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
	                            callback(xhr.responseText);
	                        else
	                            callback(null);
	                    };
	                    if (xhr.readyState == 4)
	                        return;
	                    xhr.send(null);
	                } else {
	                    xhr.send(null);
	                    if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
	                        return xhr.responseText;
	                    return null;
	                }
	            }
	        };
	
	        /**
	         * Converts a string to camel case.
	         * @param {string} str
	         * @returns {string}
	         * @expose
	         */
	        Util.toCamelCase = function(str) {
	            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
	                return $1.toUpperCase();
	            });
	        };
	
	        return Util;
	    })();
	
	    /**
	     * Language expressions.
	     * @type {!Object.<string,!RegExp>}
	     * @expose
	     */
	    ProtoBuf.Lang = {
	
	        // Characters always ending a statement
	        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,
	
	        // Field rules
	        RULE: /^(?:required|optional|repeated|map)$/,
	
	        // Field types
	        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
	
	        // Names
	        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
	
	        // Type definitions
	        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
	
	        // Type references
	        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
	
	        // Fully qualified type references
	        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
	
	        // All numbers
	        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,
	
	        // Decimal numbers
	        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
	
	        // Hexadecimal numbers
	        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,
	
	        // Octal numbers
	        NUMBER_OCT: /^0[0-7]+$/,
	
	        // Floating point numbers
	        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,
	
	        // Booleans
	        BOOL: /^(?:true|false)$/i,
	
	        // Id numbers
	        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
	
	        // Negative id numbers (enum values)
	        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
	
	        // Whitespaces
	        WHITESPACE: /\s/,
	
	        // All strings
	        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
	
	        // Double quoted strings
	        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
	
	        // Single quoted strings
	        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
	    };
	
	    /**
	     * @alias ProtoBuf.DotProto
	     * @expose
	     */
	    ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
	        "use strict";
	
	        /**
	         * Utilities to parse .proto files.
	         * @exports ProtoBuf.DotProto
	         * @namespace
	         */
	        var DotProto = {};
	
	        /**
	         * Constructs a new Tokenizer.
	         * @exports ProtoBuf.DotProto.Tokenizer
	         * @class prototype tokenizer
	         * @param {string} proto Proto to tokenize
	         * @constructor
	         */
	        var Tokenizer = function(proto) {
	
	            /**
	             * Source to parse.
	             * @type {string}
	             * @expose
	             */
	            this.source = proto+"";
	
	            /**
	             * Current index.
	             * @type {number}
	             * @expose
	             */
	            this.index = 0;
	
	            /**
	             * Current line.
	             * @type {number}
	             * @expose
	             */
	            this.line = 1;
	
	            /**
	             * Token stack.
	             * @type {!Array.<string>}
	             * @expose
	             */
	            this.stack = [];
	
	            /**
	             * Opening character of the current string read, if any.
	             * @type {?string}
	             * @private
	             */
	            this._stringOpen = null;
	        };
	
	        /**
	         * @alias ProtoBuf.DotProto.Tokenizer.prototype
	         * @inner
	         */
	        var TokenizerPrototype = Tokenizer.prototype;
	
	        /**
	         * Reads a string beginning at the current index.
	         * @return {string}
	         * @private
	         */
	        TokenizerPrototype._readString = function() {
	            var re = this._stringOpen === '"'
	                ? Lang.STRING_DQ
	                : Lang.STRING_SQ;
	            re.lastIndex = this.index - 1; // Include the open quote
	            var match = re.exec(this.source);
	            if (!match)
	                throw Error("unterminated string");
	            this.index = re.lastIndex;
	            this.stack.push(this._stringOpen);
	            this._stringOpen = null;
	            return match[1];
	        };
	
	        /**
	         * Gets the next token and advances by one.
	         * @return {?string} Token or `null` on EOF
	         * @expose
	         */
	        TokenizerPrototype.next = function() {
	            if (this.stack.length > 0)
	                return this.stack.shift();
	            if (this.index >= this.source.length)
	                return null;
	            if (this._stringOpen !== null)
	                return this._readString();
	
	            var repeat,
	                prev,
	                next;
	            do {
	                repeat = false;
	
	                // Strip white spaces
	                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
	                    if (next === '\n')
	                        ++this.line;
	                    if (++this.index === this.source.length)
	                        return null;
	                }
	
	                // Strip comments
	                if (this.source.charAt(this.index) === '/') {
	                    ++this.index;
	                    if (this.source.charAt(this.index) === '/') { // Line
	                        while (this.source.charAt(++this.index) !== '\n')
	                            if (this.index == this.source.length)
	                                return null;
	                        ++this.index;
	                        ++this.line;
	                        repeat = true;
	                    } else if ((next = this.source.charAt(this.index)) === '*') { /* Block */
	                        do {
	                            if (next === '\n')
	                                ++this.line;
	                            if (++this.index === this.source.length)
	                                return null;
	                            prev = next;
	                            next = this.source.charAt(this.index);
	                        } while (prev !== '*' || next !== '/');
	                        ++this.index;
	                        repeat = true;
	                    } else
	                        return '/';
	                }
	            } while (repeat);
	
	            if (this.index === this.source.length)
	                return null;
	
	            // Read the next token
	            var end = this.index;
	            Lang.DELIM.lastIndex = 0;
	            var delim = Lang.DELIM.test(this.source.charAt(end++));
	            if (!delim)
	                while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
	                    ++end;
	            var token = this.source.substring(this.index, this.index = end);
	            if (token === '"' || token === "'")
	                this._stringOpen = token;
	            return token;
	        };
	
	        /**
	         * Peeks for the next token.
	         * @return {?string} Token or `null` on EOF
	         * @expose
	         */
	        TokenizerPrototype.peek = function() {
	            if (this.stack.length === 0) {
	                var token = this.next();
	                if (token === null)
	                    return null;
	                this.stack.push(token);
	            }
	            return this.stack[0];
	        };
	
	        /**
	         * Skips a specific token and throws if it differs.
	         * @param {string} expected Expected token
	         * @throws {Error} If the actual token differs
	         */
	        TokenizerPrototype.skip = function(expected) {
	            var actual = this.next();
	            if (actual !== expected)
	                throw Error("illegal '"+actual+"', '"+expected+"' expected");
	        };
	
	        /**
	         * Omits an optional token.
	         * @param {string} expected Expected optional token
	         * @returns {boolean} `true` if the token exists
	         */
	        TokenizerPrototype.omit = function(expected) {
	            if (this.peek() === expected) {
	                this.next();
	                return true;
	            }
	            return false;
	        };
	
	        /**
	         * Returns a string representation of this object.
	         * @return {string} String representation as of "Tokenizer(index/length)"
	         * @expose
	         */
	        TokenizerPrototype.toString = function() {
	            return "Tokenizer ("+this.index+"/"+this.source.length+" at line "+this.line+")";
	        };
	
	        /**
	         * @alias ProtoBuf.DotProto.Tokenizer
	         * @expose
	         */
	        DotProto.Tokenizer = Tokenizer;
	
	        /**
	         * Constructs a new Parser.
	         * @exports ProtoBuf.DotProto.Parser
	         * @class prototype parser
	         * @param {string} source Source
	         * @constructor
	         */
	        var Parser = function(source) {
	
	            /**
	             * Tokenizer.
	             * @type {!ProtoBuf.DotProto.Tokenizer}
	             * @expose
	             */
	            this.tn = new Tokenizer(source);
	
	            /**
	             * Whether parsing proto3 or not.
	             * @type {boolean}
	             */
	            this.proto3 = false;
	        };
	
	        /**
	         * @alias ProtoBuf.DotProto.Parser.prototype
	         * @inner
	         */
	        var ParserPrototype = Parser.prototype;
	
	        /**
	         * Parses the source.
	         * @returns {!Object}
	         * @throws {Error} If the source cannot be parsed
	         * @expose
	         */
	        ParserPrototype.parse = function() {
	            var topLevel = {
	                "name": "[ROOT]", // temporary
	                "package": null,
	                "messages": [],
	                "enums": [],
	                "imports": [],
	                "options": {},
	                "services": []
	                // "syntax": undefined
	            };
	            var token,
	                head = true,
	                weak;
	            try {
	                while (token = this.tn.next()) {
	                    switch (token) {
	                        case 'package':
	                            if (!head || topLevel["package"] !== null)
	                                throw Error("unexpected 'package'");
	                            token = this.tn.next();
	                            if (!Lang.TYPEREF.test(token))
	                                throw Error("illegal package name: " + token);
	                            this.tn.skip(";");
	                            topLevel["package"] = token;
	                            break;
	                        case 'import':
	                            if (!head)
	                                throw Error("unexpected 'import'");
	                            token = this.tn.peek();
	                            if (token === "public" || (weak = token === "weak")) // token ignored
	                                this.tn.next();
	                            token = this._readString();
	                            this.tn.skip(";");
	                            if (!weak) // import ignored
	                                topLevel["imports"].push(token);
	                            break;
	                        case 'syntax':
	                            if (!head)
	                                throw Error("unexpected 'syntax'");
	                            this.tn.skip("=");
	                            if ((topLevel["syntax"] = this._readString()) === "proto3")
	                                this.proto3 = true;
	                            this.tn.skip(";");
	                            break;
	                        case 'message':
	                            this._parseMessage(topLevel, null);
	                            head = false;
	                            break;
	                        case 'enum':
	                            this._parseEnum(topLevel);
	                            head = false;
	                            break;
	                        case 'option':
	                            this._parseOption(topLevel);
	                            break;
	                        case 'service':
	                            this._parseService(topLevel);
	                            break;
	                        case 'extend':
	                            this._parseExtend(topLevel);
	                            break;
	                        default:
	                            throw Error("unexpected '" + token + "'");
	                    }
	                }
	            } catch (e) {
	                e.message = "Parse error at line "+this.tn.line+": " + e.message;
	                throw e;
	            }
	            delete topLevel["name"];
	            return topLevel;
	        };
	
	        /**
	         * Parses the specified source.
	         * @returns {!Object}
	         * @throws {Error} If the source cannot be parsed
	         * @expose
	         */
	        Parser.parse = function(source) {
	            return new Parser(source).parse();
	        };
	
	        // ----- Conversion ------
	
	        /**
	         * Converts a numerical string to an id.
	         * @param {string} value
	         * @param {boolean=} mayBeNegative
	         * @returns {number}
	         * @inner
	         */
	        function mkId(value, mayBeNegative) {
	            var id = -1,
	                sign = 1;
	            if (value.charAt(0) == '-') {
	                sign = -1;
	                value = value.substring(1);
	            }
	            if (Lang.NUMBER_DEC.test(value))
	                id = parseInt(value);
	            else if (Lang.NUMBER_HEX.test(value))
	                id = parseInt(value.substring(2), 16);
	            else if (Lang.NUMBER_OCT.test(value))
	                id = parseInt(value.substring(1), 8);
	            else
	                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
	            id = (sign*id)|0; // Force to 32bit
	            if (!mayBeNegative && id < 0)
	                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
	            return id;
	        }
	
	        /**
	         * Converts a numerical string to a number.
	         * @param {string} val
	         * @returns {number}
	         * @inner
	         */
	        function mkNumber(val) {
	            var sign = 1;
	            if (val.charAt(0) == '-') {
	                sign = -1;
	                val = val.substring(1);
	            }
	            if (Lang.NUMBER_DEC.test(val))
	                return sign * parseInt(val, 10);
	            else if (Lang.NUMBER_HEX.test(val))
	                return sign * parseInt(val.substring(2), 16);
	            else if (Lang.NUMBER_OCT.test(val))
	                return sign * parseInt(val.substring(1), 8);
	            else if (val === 'inf')
	                return sign * Infinity;
	            else if (val === 'nan')
	                return NaN;
	            else if (Lang.NUMBER_FLT.test(val))
	                return sign * parseFloat(val);
	            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
	        }
	
	        // ----- Reading ------
	
	        /**
	         * Reads a string.
	         * @returns {string}
	         * @private
	         */
	        ParserPrototype._readString = function() {
	            var value = "",
	                token,
	                delim;
	            do {
	                delim = this.tn.next();
	                if (delim !== "'" && delim !== '"')
	                    throw Error("illegal string delimiter: "+delim);
	                value += this.tn.next();
	                this.tn.skip(delim);
	                token = this.tn.peek();
	            } while (token === '"' || token === '"'); // multi line?
	            return value;
	        };
	
	        /**
	         * Reads a value.
	         * @param {boolean=} mayBeTypeRef
	         * @returns {number|boolean|string}
	         * @private
	         */
	        ParserPrototype._readValue = function(mayBeTypeRef) {
	            var token = this.tn.peek(),
	                value;
	            if (token === '"' || token === "'")
	                return this._readString();
	            this.tn.next();
	            if (Lang.NUMBER.test(token))
	                return mkNumber(token);
	            if (Lang.BOOL.test(token))
	                return (token.toLowerCase() === 'true');
	            if (mayBeTypeRef && Lang.TYPEREF.test(token))
	                return token;
	            throw Error("illegal value: "+token);
	
	        };
	
	        // ----- Parsing constructs -----
	
	        /**
	         * Parses a namespace option.
	         * @param {!Object} parent Parent definition
	         * @param {boolean=} isList
	         * @private
	         */
	        ParserPrototype._parseOption = function(parent, isList) {
	            var token = this.tn.next(),
	                custom = false;
	            if (token === '(') {
	                custom = true;
	                token = this.tn.next();
	            }
	            if (!Lang.TYPEREF.test(token))
	                // we can allow options of the form google.protobuf.* since they will just get ignored anyways
	                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
	                    throw Error("illegal option name: "+token);
	            var name = token;
	            if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
	                this.tn.skip(')');
	                name = '('+name+')';
	                token = this.tn.peek();
	                if (Lang.FQTYPEREF.test(token)) {
	                    name += token;
	                    this.tn.next();
	                }
	            }
	            this.tn.skip('=');
	            this._parseOptionValue(parent, name);
	            if (!isList)
	                this.tn.skip(";");
	        };
	
	        /**
	         * Sets an option on the specified options object.
	         * @param {!Object.<string,*>} options
	         * @param {string} name
	         * @param {string|number|boolean} value
	         * @inner
	         */
	        function setOption(options, name, value) {
	            if (typeof options[name] === 'undefined')
	                options[name] = value;
	            else {
	                if (!Array.isArray(options[name]))
	                    options[name] = [ options[name] ];
	                options[name].push(value);
	            }
	        }
	
	        /**
	         * Parses an option value.
	         * @param {!Object} parent
	         * @param {string} name
	         * @private
	         */
	        ParserPrototype._parseOptionValue = function(parent, name) {
	            var token = this.tn.peek();
	            if (token !== '{') { // Plain value
	                setOption(parent["options"], name, this._readValue(true));
	            } else { // Aggregate options
	                this.tn.skip("{");
	                while ((token = this.tn.next()) !== '}') {
	                    if (!Lang.NAME.test(token))
	                        throw Error("illegal option name: " + name + "." + token);
	                    if (this.tn.omit(":"))
	                        setOption(parent["options"], name + "." + token, this._readValue(true));
	                    else
	                        this._parseOptionValue(parent, name + "." + token);
	                }
	            }
	        };
	
	        /**
	         * Parses a service definition.
	         * @param {!Object} parent Parent definition
	         * @private
	         */
	        ParserPrototype._parseService = function(parent) {
	            var token = this.tn.next();
	            if (!Lang.NAME.test(token))
	                throw Error("illegal service name at line "+this.tn.line+": "+token);
	            var name = token;
	            var svc = {
	                "name": name,
	                "rpc": {},
	                "options": {}
	            };
	            this.tn.skip("{");
	            while ((token = this.tn.next()) !== '}') {
	                if (token === "option")
	                    this._parseOption(svc);
	                else if (token === 'rpc')
	                    this._parseServiceRPC(svc);
	                else
	                    throw Error("illegal service token: "+token);
	            }
	            this.tn.omit(";");
	            parent["services"].push(svc);
	        };
	
	        /**
	         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
	         * @param {!Object} svc Service definition
	         * @private
	         */
	        ParserPrototype._parseServiceRPC = function(svc) {
	            var type = "rpc",
	                token = this.tn.next();
	            if (!Lang.NAME.test(token))
	                throw Error("illegal rpc service method name: "+token);
	            var name = token;
	            var method = {
	                "request": null,
	                "response": null,
	                "request_stream": false,
	                "response_stream": false,
	                "options": {}
	            };
	            this.tn.skip("(");
	            token = this.tn.next();
	            if (token.toLowerCase() === "stream") {
	              method["request_stream"] = true;
	              token = this.tn.next();
	            }
	            if (!Lang.TYPEREF.test(token))
	                throw Error("illegal rpc service request type: "+token);
	            method["request"] = token;
	            this.tn.skip(")");
	            token = this.tn.next();
	            if (token.toLowerCase() !== "returns")
	                throw Error("illegal rpc service request type delimiter: "+token);
	            this.tn.skip("(");
	            token = this.tn.next();
	            if (token.toLowerCase() === "stream") {
	              method["response_stream"] = true;
	              token = this.tn.next();
	            }
	            method["response"] = token;
	            this.tn.skip(")");
	            token = this.tn.peek();
	            if (token === '{') {
	                this.tn.next();
	                while ((token = this.tn.next()) !== '}') {
	                    if (token === 'option')
	                        this._parseOption(method);
	                    else
	                        throw Error("illegal rpc service token: " + token);
	                }
	                this.tn.omit(";");
	            } else
	                this.tn.skip(";");
	            if (typeof svc[type] === 'undefined')
	                svc[type] = {};
	            svc[type][name] = method;
	        };
	
	        /**
	         * Parses a message definition.
	         * @param {!Object} parent Parent definition
	         * @param {!Object=} fld Field definition if this is a group
	         * @returns {!Object}
	         * @private
	         */
	        ParserPrototype._parseMessage = function(parent, fld) {
	            var isGroup = !!fld,
	                token = this.tn.next();
	            var msg = {
	                "name": "",
	                "fields": [],
	                "enums": [],
	                "messages": [],
	                "options": {},
	                "services": [],
	                "oneofs": {}
	                // "extensions": undefined
	            };
	            if (!Lang.NAME.test(token))
	                throw Error("illegal "+(isGroup ? "group" : "message")+" name: "+token);
	            msg["name"] = token;
	            if (isGroup) {
	                this.tn.skip("=");
	                fld["id"] = mkId(this.tn.next());
	                msg["isGroup"] = true;
	            }
	            token = this.tn.peek();
	            if (token === '[' && fld)
	                this._parseFieldOptions(fld);
	            this.tn.skip("{");
	            while ((token = this.tn.next()) !== '}') {
	                if (Lang.RULE.test(token))
	                    this._parseMessageField(msg, token);
	                else if (token === "oneof")
	                    this._parseMessageOneOf(msg);
	                else if (token === "enum")
	                    this._parseEnum(msg);
	                else if (token === "message")
	                    this._parseMessage(msg);
	                else if (token === "option")
	                    this._parseOption(msg);
	                else if (token === "service")
	                    this._parseService(msg);
	                else if (token === "extensions")
	                    msg["extensions"] = this._parseExtensionRanges();
	                else if (token === "reserved")
	                    this._parseIgnored(); // TODO
	                else if (token === "extend")
	                    this._parseExtend(msg);
	                else if (Lang.TYPEREF.test(token)) {
	                    if (!this.proto3)
	                        throw Error("illegal field rule: "+token);
	                    this._parseMessageField(msg, "optional", token);
	                } else
	                    throw Error("illegal message token: "+token);
	            }
	            this.tn.omit(";");
	            parent["messages"].push(msg);
	            return msg;
	        };
	
	        /**
	         * Parses an ignored statement.
	         * @private
	         */
	        ParserPrototype._parseIgnored = function() {
	            while (this.tn.peek() !== ';')
	                this.tn.next();
	            this.tn.skip(";");
	        };
	
	        /**
	         * Parses a message field.
	         * @param {!Object} msg Message definition
	         * @param {string} rule Field rule
	         * @param {string=} type Field type if already known (never known for maps)
	         * @returns {!Object} Field descriptor
	         * @private
	         */
	        ParserPrototype._parseMessageField = function(msg, rule, type) {
	            if (!Lang.RULE.test(rule))
	                throw Error("illegal message field rule: "+rule);
	            var fld = {
	                "rule": rule,
	                "type": "",
	                "name": "",
	                "options": {},
	                "id": 0
	            };
	            var token;
	            if (rule === "map") {
	
	                if (type)
	                    throw Error("illegal type: " + type);
	                this.tn.skip('<');
	                token = this.tn.next();
	                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
	                    throw Error("illegal message field type: " + token);
	                fld["keytype"] = token;
	                this.tn.skip(',');
	                token = this.tn.next();
	                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
	                    throw Error("illegal message field: " + token);
	                fld["type"] = token;
	                this.tn.skip('>');
	                token = this.tn.next();
	                if (!Lang.NAME.test(token))
	                    throw Error("illegal message field name: " + token);
	                fld["name"] = token;
	                this.tn.skip("=");
	                fld["id"] = mkId(this.tn.next());
	                token = this.tn.peek();
	                if (token === '[')
	                    this._parseFieldOptions(fld);
	                this.tn.skip(";");
	
	            } else {
	
	                type = typeof type !== 'undefined' ? type : this.tn.next();
	
	                if (type === "group") {
	
	                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
	                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
	                    // converted to lower-case so that it does not conflict with the former)."
	                    var grp = this._parseMessage(msg, fld);
	                    if (!/^[A-Z]/.test(grp["name"]))
	                        throw Error('illegal group name: '+grp["name"]);
	                    fld["type"] = grp["name"];
	                    fld["name"] = grp["name"].toLowerCase();
	                    this.tn.omit(";");
	
	                } else {
	
	                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type))
	                        throw Error("illegal message field type: " + type);
	                    fld["type"] = type;
	                    token = this.tn.next();
	                    if (!Lang.NAME.test(token))
	                        throw Error("illegal message field name: " + token);
	                    fld["name"] = token;
	                    this.tn.skip("=");
	                    fld["id"] = mkId(this.tn.next());
	                    token = this.tn.peek();
	                    if (token === "[")
	                        this._parseFieldOptions(fld);
	                    this.tn.skip(";");
	
	                }
	            }
	            msg["fields"].push(fld);
	            return fld;
	        };
	
	        /**
	         * Parses a message oneof.
	         * @param {!Object} msg Message definition
	         * @private
	         */
	        ParserPrototype._parseMessageOneOf = function(msg) {
	            var token = this.tn.next();
	            if (!Lang.NAME.test(token))
	                throw Error("illegal oneof name: "+token);
	            var name = token,
	                fld;
	            var fields = [];
	            this.tn.skip("{");
	            while ((token = this.tn.next()) !== "}") {
	                fld = this._parseMessageField(msg, "optional", token);
	                fld["oneof"] = name;
	                fields.push(fld["id"]);
	            }
	            this.tn.omit(";");
	            msg["oneofs"][name] = fields;
	        };
	
	        /**
	         * Parses a set of field option definitions.
	         * @param {!Object} fld Field definition
	         * @private
	         */
	        ParserPrototype._parseFieldOptions = function(fld) {
	            this.tn.skip("[");
	            var token,
	                first = true;
	            while ((token = this.tn.peek()) !== ']') {
	                if (!first)
	                    this.tn.skip(",");
	                this._parseOption(fld, true);
	                first = false;
	            }
	            this.tn.next();
	        };
	
	        /**
	         * Parses an enum.
	         * @param {!Object} msg Message definition
	         * @private
	         */
	        ParserPrototype._parseEnum = function(msg) {
	            var enm = {
	                "name": "",
	                "values": [],
	                "options": {}
	            };
	            var token = this.tn.next();
	            if (!Lang.NAME.test(token))
	                throw Error("illegal name: "+token);
	            enm["name"] = token;
	            this.tn.skip("{");
	            while ((token = this.tn.next()) !== '}') {
	                if (token === "option")
	                    this._parseOption(enm);
	                else {
	                    if (!Lang.NAME.test(token))
	                        throw Error("illegal name: "+token);
	                    this.tn.skip("=");
	                    var val = {
	                        "name": token,
	                        "id": mkId(this.tn.next(), true)
	                    };
	                    token = this.tn.peek();
	                    if (token === "[")
	                        this._parseFieldOptions({ "options": {} });
	                    this.tn.skip(";");
	                    enm["values"].push(val);
	                }
	            }
	            this.tn.omit(";");
	            msg["enums"].push(enm);
	        };
	
	        /**
	         * Parses extension / reserved ranges.
	         * @returns {!Array.<!Array.<number>>}
	         * @private
	         */
	        ParserPrototype._parseExtensionRanges = function() {
	            var ranges = [];
	            var token,
	                range,
	                value;
	            do {
	                range = [];
	                while (true) {
	                    token = this.tn.next();
	                    switch (token) {
	                        case "min":
	                            value = ProtoBuf.ID_MIN;
	                            break;
	                        case "max":
	                            value = ProtoBuf.ID_MAX;
	                            break;
	                        default:
	                            value = mkNumber(token);
	                            break;
	                    }
	                    range.push(value);
	                    if (range.length === 2)
	                        break;
	                    if (this.tn.peek() !== "to") {
	                        range.push(value);
	                        break;
	                    }
	                    this.tn.next();
	                }
	                ranges.push(range);
	            } while (this.tn.omit(","));
	            this.tn.skip(";");
	            return ranges;
	        };
	
	        /**
	         * Parses an extend block.
	         * @param {!Object} parent Parent object
	         * @private
	         */
	        ParserPrototype._parseExtend = function(parent) {
	            var token = this.tn.next();
	            if (!Lang.TYPEREF.test(token))
	                throw Error("illegal extend reference: "+token);
	            var ext = {
	                "ref": token,
	                "fields": []
	            };
	            this.tn.skip("{");
	            while ((token = this.tn.next()) !== '}') {
	                if (Lang.RULE.test(token))
	                    this._parseMessageField(ext, token);
	                else if (Lang.TYPEREF.test(token)) {
	                    if (!this.proto3)
	                        throw Error("illegal field rule: "+token);
	                    this._parseMessageField(ext, "optional", token);
	                } else
	                    throw Error("illegal extend token: "+token);
	            }
	            this.tn.omit(";");
	            parent["messages"].push(ext);
	            return ext;
	        };
	
	        // ----- General -----
	
	        /**
	         * Returns a string representation of this parser.
	         * @returns {string}
	         */
	        ParserPrototype.toString = function() {
	            return "Parser at line "+this.tn.line;
	        };
	
	        /**
	         * @alias ProtoBuf.DotProto.Parser
	         * @expose
	         */
	        DotProto.Parser = Parser;
	
	        return DotProto;
	
	    })(ProtoBuf, ProtoBuf.Lang);
	
	    /**
	     * @alias ProtoBuf.Reflect
	     * @expose
	     */
	    ProtoBuf.Reflect = (function(ProtoBuf) {
	        "use strict";
	
	        /**
	         * Reflection types.
	         * @exports ProtoBuf.Reflect
	         * @namespace
	         */
	        var Reflect = {};
	
	        /**
	         * Constructs a Reflect base class.
	         * @exports ProtoBuf.Reflect.T
	         * @constructor
	         * @abstract
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {?ProtoBuf.Reflect.T} parent Parent object
	         * @param {string} name Object name
	         */
	        var T = function(builder, parent, name) {
	
	            /**
	             * Builder reference.
	             * @type {!ProtoBuf.Builder}
	             * @expose
	             */
	            this.builder = builder;
	
	            /**
	             * Parent object.
	             * @type {?ProtoBuf.Reflect.T}
	             * @expose
	             */
	            this.parent = parent;
	
	            /**
	             * Object name in namespace.
	             * @type {string}
	             * @expose
	             */
	            this.name = name;
	
	            /**
	             * Fully qualified class name
	             * @type {string}
	             * @expose
	             */
	            this.className;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.T.prototype
	         * @inner
	         */
	        var TPrototype = T.prototype;
	
	        /**
	         * Returns the fully qualified name of this object.
	         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
	         * @expose
	         */
	        TPrototype.fqn = function() {
	            var name = this.name,
	                ptr = this;
	            do {
	                ptr = ptr.parent;
	                if (ptr == null)
	                    break;
	                name = ptr.name+"."+name;
	            } while (true);
	            return name;
	        };
	
	        /**
	         * Returns a string representation of this Reflect object (its fully qualified name).
	         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
	         * @return String representation
	         * @expose
	         */
	        TPrototype.toString = function(includeClass) {
	            return (includeClass ? this.className + " " : "") + this.fqn();
	        };
	
	        /**
	         * Builds this type.
	         * @throws {Error} If this type cannot be built directly
	         * @expose
	         */
	        TPrototype.build = function() {
	            throw Error(this.toString(true)+" cannot be built directly");
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.T
	         * @expose
	         */
	        Reflect.T = T;
	
	        /**
	         * Constructs a new Namespace.
	         * @exports ProtoBuf.Reflect.Namespace
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
	         * @param {string} name Namespace name
	         * @param {Object.<string,*>=} options Namespace options
	         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
	         * @constructor
	         * @extends ProtoBuf.Reflect.T
	         */
	        var Namespace = function(builder, parent, name, options, syntax) {
	            T.call(this, builder, parent, name);
	
	            /**
	             * @override
	             */
	            this.className = "Namespace";
	
	            /**
	             * Children inside the namespace.
	             * @type {!Array.<ProtoBuf.Reflect.T>}
	             */
	            this.children = [];
	
	            /**
	             * Options.
	             * @type {!Object.<string, *>}
	             */
	            this.options = options || {};
	
	            /**
	             * Syntax level (e.g., proto2 or proto3).
	             * @type {!string}
	             */
	            this.syntax = syntax || "proto2";
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Namespace.prototype
	         * @inner
	         */
	        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);
	
	        /**
	         * Returns an array of the namespace's children.
	         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
	         * @return {Array.<ProtoBuf.Reflect.T>}
	         * @expose
	         */
	        NamespacePrototype.getChildren = function(type) {
	            type = type || null;
	            if (type == null)
	                return this.children.slice();
	            var children = [];
	            for (var i=0, k=this.children.length; i<k; ++i)
	                if (this.children[i] instanceof type)
	                    children.push(this.children[i]);
	            return children;
	        };
	
	        /**
	         * Adds a child to the namespace.
	         * @param {ProtoBuf.Reflect.T} child Child
	         * @throws {Error} If the child cannot be added (duplicate)
	         * @expose
	         */
	        NamespacePrototype.addChild = function(child) {
	            var other;
	            if (other = this.getChild(child.name)) {
	                // Try to revert camelcase transformation on collision
	                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null)
	                    other.name = other.originalName; // Revert previous first (effectively keeps both originals)
	                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)
	                    child.name = child.originalName;
	                else
	                    throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
	            }
	            this.children.push(child);
	        };
	
	        /**
	         * Gets a child by its name or id.
	         * @param {string|number} nameOrId Child name or id
	         * @return {?ProtoBuf.Reflect.T} The child or null if not found
	         * @expose
	         */
	        NamespacePrototype.getChild = function(nameOrId) {
	            var key = typeof nameOrId === 'number' ? 'id' : 'name';
	            for (var i=0, k=this.children.length; i<k; ++i)
	                if (this.children[i][key] === nameOrId)
	                    return this.children[i];
	            return null;
	        };
	
	        /**
	         * Resolves a reflect object inside of this namespace.
	         * @param {string|!Array.<string>} qn Qualified name to resolve
	         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
	         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
	         * @expose
	         */
	        NamespacePrototype.resolve = function(qn, excludeNonNamespace) {
	            var part = typeof qn === 'string' ? qn.split(".") : qn,
	                ptr = this,
	                i = 0;
	            if (part[i] === "") { // Fully qualified name, e.g. ".My.Message'
	                while (ptr.parent !== null)
	                    ptr = ptr.parent;
	                i++;
	            }
	            var child;
	            do {
	                do {
	                    if (!(ptr instanceof Reflect.Namespace)) {
	                        ptr = null;
	                        break;
	                    }
	                    child = ptr.getChild(part[i]);
	                    if (!child || !(child instanceof Reflect.T) || (excludeNonNamespace && !(child instanceof Reflect.Namespace))) {
	                        ptr = null;
	                        break;
	                    }
	                    ptr = child; i++;
	                } while (i < part.length);
	                if (ptr != null)
	                    break; // Found
	                // Else search the parent
	                if (this.parent !== null)
	                    return this.parent.resolve(qn, excludeNonNamespace);
	            } while (ptr != null);
	            return ptr;
	        };
	
	        /**
	         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
	         * @param {!ProtoBuf.Reflect.T} t Reflection type
	         * @returns {string} The shortest qualified name or, if there is none, the fqn
	         * @expose
	         */
	        NamespacePrototype.qn = function(t) {
	            var part = [], ptr = t;
	            do {
	                part.unshift(ptr.name);
	                ptr = ptr.parent;
	            } while (ptr !== null);
	            for (var len=1; len <= part.length; len++) {
	                var qn = part.slice(part.length-len);
	                if (t === this.resolve(qn, t instanceof Reflect.Namespace))
	                    return qn.join(".");
	            }
	            return t.fqn();
	        };
	
	        /**
	         * Builds the namespace and returns the runtime counterpart.
	         * @return {Object.<string,Function|Object>} Runtime namespace
	         * @expose
	         */
	        NamespacePrototype.build = function() {
	            /** @dict */
	            var ns = {};
	            var children = this.children;
	            for (var i=0, k=children.length, child; i<k; ++i) {
	                child = children[i];
	                if (child instanceof Namespace)
	                    ns[child.name] = child.build();
	            }
	            if (Object.defineProperty)
	                Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
	            return ns;
	        };
	
	        /**
	         * Builds the namespace's '$options' property.
	         * @return {Object.<string,*>}
	         */
	        NamespacePrototype.buildOpt = function() {
	            var opt = {},
	                keys = Object.keys(this.options);
	            for (var i=0, k=keys.length; i<k; ++i) {
	                var key = keys[i],
	                    val = this.options[keys[i]];
	                // TODO: Options are not resolved, yet.
	                // if (val instanceof Namespace) {
	                //     opt[key] = val.build();
	                // } else {
	                opt[key] = val;
	                // }
	            }
	            return opt;
	        };
	
	        /**
	         * Gets the value assigned to the option with the specified name.
	         * @param {string=} name Returns the option value if specified, otherwise all options are returned.
	         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
	         */
	        NamespacePrototype.getOption = function(name) {
	            if (typeof name === 'undefined')
	                return this.options;
	            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Namespace
	         * @expose
	         */
	        Reflect.Namespace = Namespace;
	
	        /**
	         * Constructs a new Element implementation that checks and converts values for a
	         * particular field type, as appropriate.
	         *
	         * An Element represents a single value: either the value of a singular field,
	         * or a value contained in one entry of a repeated field or map field. This
	         * class does not implement these higher-level concepts; it only encapsulates
	         * the low-level typechecking and conversion.
	         *
	         * @exports ProtoBuf.Reflect.Element
	         * @param {{name: string, wireType: number}} type Resolved data type
	         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
	         * (e.g. submessage field).
	         * @param {boolean} isMapKey Is this element a Map key? The value will be
	         * converted to string form if so.
	         * @param {string} syntax Syntax level of defining message type, e.g.,
	         * proto2 or proto3.
	         * @constructor
	         */
	        var Element = function(type, resolvedType, isMapKey, syntax) {
	
	            /**
	             * Element type, as a string (e.g., int32).
	             * @type {{name: string, wireType: number}}
	             */
	            this.type = type;
	
	            /**
	             * Element type reference to submessage or enum definition, if needed.
	             * @type {ProtoBuf.Reflect.T|null}
	             */
	            this.resolvedType = resolvedType;
	
	            /**
	             * Element is a map key.
	             * @type {boolean}
	             */
	            this.isMapKey = isMapKey;
	
	            /**
	             * Syntax level of defining message type, e.g., proto2 or proto3.
	             * @type {string}
	             */
	            this.syntax = syntax;
	
	            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0)
	                throw Error("Invalid map key type: " + type.name);
	        };
	
	        var ElementPrototype = Element.prototype;
	
	        /**
	         * Obtains a (new) default value for the specified type.
	         * @param type {string|{name: string, wireType: number}} Field type
	         * @returns {*} Default value
	         * @inner
	         */
	        function mkDefault(type) {
	            if (typeof type === 'string')
	                type = ProtoBuf.TYPES[type];
	            if (typeof type.defaultValue === 'undefined')
	                throw Error("default value for type "+type.name+" is not supported");
	            if (type == ProtoBuf.TYPES["bytes"])
	                return new ByteBuffer(0);
	            return type.defaultValue;
	        }
	
	        /**
	         * Returns the default value for this field in proto3.
	         * @function
	         * @param type {string|{name: string, wireType: number}} the field type
	         * @returns {*} Default value
	         */
	        Element.defaultFieldValue = mkDefault;
	
	        /**
	         * Makes a Long from a value.
	         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
	         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
	         *  strings and numbers
	         * @returns {!Long}
	         * @throws {Error} If the value cannot be converted to a Long
	         * @inner
	         */
	        function mkLong(value, unsigned) {
	            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
	                && value.low === value.low && value.high === value.high)
	                return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
	            if (typeof value === 'string')
	                return ProtoBuf.Long.fromString(value, unsigned || false, 10);
	            if (typeof value === 'number')
	                return ProtoBuf.Long.fromNumber(value, unsigned || false);
	            throw Error("not convertible to Long");
	        }
	
	        /**
	         * Checks if the given value can be set for an element of this type (singular
	         * field or one element of a repeated field or map).
	         * @param {*} value Value to check
	         * @return {*} Verified, maybe adjusted, value
	         * @throws {Error} If the value cannot be verified for this element slot
	         * @expose
	         */
	        ElementPrototype.verifyValue = function(value) {
	            var self = this;
	            function fail(val, msg) {
	                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
	            }
	            switch (this.type) {
	                // Signed 32bit
	                case ProtoBuf.TYPES["int32"]:
	                case ProtoBuf.TYPES["sint32"]:
	                case ProtoBuf.TYPES["sfixed32"]:
	                    // Account for !NaN: value === value
	                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))
	                        fail(typeof value, "not an integer");
	                    return value > 4294967295 ? value | 0 : value;
	
	                // Unsigned 32bit
	                case ProtoBuf.TYPES["uint32"]:
	                case ProtoBuf.TYPES["fixed32"]:
	                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))
	                        fail(typeof value, "not an integer");
	                    return value < 0 ? value >>> 0 : value;
	
	                // Signed 64bit
	                case ProtoBuf.TYPES["int64"]:
	                case ProtoBuf.TYPES["sint64"]:
	                case ProtoBuf.TYPES["sfixed64"]: {
	                    if (ProtoBuf.Long)
	                        try {
	                            return mkLong(value, false);
	                        } catch (e) {
	                            fail(typeof value, e.message);
	                        }
	                    else
	                        fail(typeof value, "requires Long.js");
	                }
	
	                // Unsigned 64bit
	                case ProtoBuf.TYPES["uint64"]:
	                case ProtoBuf.TYPES["fixed64"]: {
	                    if (ProtoBuf.Long)
	                        try {
	                            return mkLong(value, true);
	                        } catch (e) {
	                            fail(typeof value, e.message);
	                        }
	                    else
	                        fail(typeof value, "requires Long.js");
	                }
	
	                // Bool
	                case ProtoBuf.TYPES["bool"]:
	                    if (typeof value !== 'boolean')
	                        fail(typeof value, "not a boolean");
	                    return value;
	
	                // Float
	                case ProtoBuf.TYPES["float"]:
	                case ProtoBuf.TYPES["double"]:
	                    if (typeof value !== 'number')
	                        fail(typeof value, "not a number");
	                    return value;
	
	                // Length-delimited string
	                case ProtoBuf.TYPES["string"]:
	                    if (typeof value !== 'string' && !(value && value instanceof String))
	                        fail(typeof value, "not a string");
	                    return ""+value; // Convert String object to string
	
	                // Length-delimited bytes
	                case ProtoBuf.TYPES["bytes"]:
	                    if (ByteBuffer.isByteBuffer(value))
	                        return value;
	                    return ByteBuffer.wrap(value, "base64");
	
	                // Constant enum value
	                case ProtoBuf.TYPES["enum"]: {
	                    var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
	                    for (i=0; i<values.length; i++)
	                        if (values[i].name == value)
	                            return values[i].id;
	                        else if (values[i].id == value)
	                            return values[i].id;
	
	                    if (this.syntax === 'proto3') {
	                        // proto3: just make sure it's an integer.
	                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
	                            fail(typeof value, "not an integer");
	                        if (value > 4294967295 || value < 0)
	                            fail(typeof value, "not in range for uint32")
	                        return value;
	                    } else {
	                        // proto2 requires enum values to be valid.
	                        fail(value, "not a valid enum value");
	                    }
	                }
	                // Embedded message
	                case ProtoBuf.TYPES["group"]:
	                case ProtoBuf.TYPES["message"]: {
	                    if (!value || typeof value !== 'object')
	                        fail(typeof value, "object expected");
	                    if (value instanceof this.resolvedType.clazz)
	                        return value;
	                    if (value instanceof ProtoBuf.Builder.Message) {
	                        // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
	                        var obj = {};
	                        for (var i in value)
	                            if (value.hasOwnProperty(i))
	                                obj[i] = value[i];
	                        value = obj;
	                    }
	                    // Else let's try to construct one from a key-value object
	                    return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
	                }
	            }
	
	            // We should never end here
	            throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
	        };
	
	        /**
	         * Calculates the byte length of an element on the wire.
	         * @param {number} id Field number
	         * @param {*} value Field value
	         * @returns {number} Byte length
	         * @throws {Error} If the value cannot be calculated
	         * @expose
	         */
	        ElementPrototype.calculateLength = function(id, value) {
	            if (value === null) return 0; // Nothing to encode
	            // Tag has already been written
	            var n;
	            switch (this.type) {
	                case ProtoBuf.TYPES["int32"]:
	                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
	                case ProtoBuf.TYPES["uint32"]:
	                    return ByteBuffer.calculateVarint32(value);
	                case ProtoBuf.TYPES["sint32"]:
	                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
	                case ProtoBuf.TYPES["fixed32"]:
	                case ProtoBuf.TYPES["sfixed32"]:
	                case ProtoBuf.TYPES["float"]:
	                    return 4;
	                case ProtoBuf.TYPES["int64"]:
	                case ProtoBuf.TYPES["uint64"]:
	                    return ByteBuffer.calculateVarint64(value);
	                case ProtoBuf.TYPES["sint64"]:
	                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
	                case ProtoBuf.TYPES["fixed64"]:
	                case ProtoBuf.TYPES["sfixed64"]:
	                    return 8;
	                case ProtoBuf.TYPES["bool"]:
	                    return 1;
	                case ProtoBuf.TYPES["enum"]:
	                    return ByteBuffer.calculateVarint32(value);
	                case ProtoBuf.TYPES["double"]:
	                    return 8;
	                case ProtoBuf.TYPES["string"]:
	                    n = ByteBuffer.calculateUTF8Bytes(value);
	                    return ByteBuffer.calculateVarint32(n) + n;
	                case ProtoBuf.TYPES["bytes"]:
	                    if (value.remaining() < 0)
	                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
	                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
	                case ProtoBuf.TYPES["message"]:
	                    n = this.resolvedType.calculate(value);
	                    return ByteBuffer.calculateVarint32(n) + n;
	                case ProtoBuf.TYPES["group"]:
	                    n = this.resolvedType.calculate(value);
	                    return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
	            }
	            // We should never end here
	            throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
	        };
	
	        /**
	         * Encodes a value to the specified buffer. Does not encode the key.
	         * @param {number} id Field number
	         * @param {*} value Field value
	         * @param {ByteBuffer} buffer ByteBuffer to encode to
	         * @return {ByteBuffer} The ByteBuffer for chaining
	         * @throws {Error} If the value cannot be encoded
	         * @expose
	         */
	        ElementPrototype.encodeValue = function(id, value, buffer) {
	            if (value === null) return buffer; // Nothing to encode
	            // Tag has already been written
	
	            switch (this.type) {
	                // 32bit signed varint
	                case ProtoBuf.TYPES["int32"]:
	                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
	                    // long  it is, effectively, treated like a very large unsigned integer." (see #122)
	                    if (value < 0)
	                        buffer.writeVarint64(value);
	                    else
	                        buffer.writeVarint32(value);
	                    break;
	
	                // 32bit unsigned varint
	                case ProtoBuf.TYPES["uint32"]:
	                    buffer.writeVarint32(value);
	                    break;
	
	                // 32bit varint zig-zag
	                case ProtoBuf.TYPES["sint32"]:
	                    buffer.writeVarint32ZigZag(value);
	                    break;
	
	                // Fixed unsigned 32bit
	                case ProtoBuf.TYPES["fixed32"]:
	                    buffer.writeUint32(value);
	                    break;
	
	                // Fixed signed 32bit
	                case ProtoBuf.TYPES["sfixed32"]:
	                    buffer.writeInt32(value);
	                    break;
	
	                // 64bit varint as-is
	                case ProtoBuf.TYPES["int64"]:
	                case ProtoBuf.TYPES["uint64"]:
	                    buffer.writeVarint64(value); // throws
	                    break;
	
	                // 64bit varint zig-zag
	                case ProtoBuf.TYPES["sint64"]:
	                    buffer.writeVarint64ZigZag(value); // throws
	                    break;
	
	                // Fixed unsigned 64bit
	                case ProtoBuf.TYPES["fixed64"]:
	                    buffer.writeUint64(value); // throws
	                    break;
	
	                // Fixed signed 64bit
	                case ProtoBuf.TYPES["sfixed64"]:
	                    buffer.writeInt64(value); // throws
	                    break;
	
	                // Bool
	                case ProtoBuf.TYPES["bool"]:
	                    if (typeof value === 'string')
	                        buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
	                    else
	                        buffer.writeVarint32(value ? 1 : 0);
	                    break;
	
	                // Constant enum value
	                case ProtoBuf.TYPES["enum"]:
	                    buffer.writeVarint32(value);
	                    break;
	
	                // 32bit float
	                case ProtoBuf.TYPES["float"]:
	                    buffer.writeFloat32(value);
	                    break;
	
	                // 64bit float
	                case ProtoBuf.TYPES["double"]:
	                    buffer.writeFloat64(value);
	                    break;
	
	                // Length-delimited string
	                case ProtoBuf.TYPES["string"]:
	                    buffer.writeVString(value);
	                    break;
	
	                // Length-delimited bytes
	                case ProtoBuf.TYPES["bytes"]:
	                    if (value.remaining() < 0)
	                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
	                    var prevOffset = value.offset;
	                    buffer.writeVarint32(value.remaining());
	                    buffer.append(value);
	                    value.offset = prevOffset;
	                    break;
	
	                // Embedded message
	                case ProtoBuf.TYPES["message"]:
	                    var bb = new ByteBuffer().LE();
	                    this.resolvedType.encode(value, bb);
	                    buffer.writeVarint32(bb.offset);
	                    buffer.append(bb.flip());
	                    break;
	
	                // Legacy group
	                case ProtoBuf.TYPES["group"]:
	                    this.resolvedType.encode(value, buffer);
	                    buffer.writeVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
	                    break;
	
	                default:
	                    // We should never end here
	                    throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
	            }
	            return buffer;
	        };
	
	        /**
	         * Decode one element value from the specified buffer.
	         * @param {ByteBuffer} buffer ByteBuffer to decode from
	         * @param {number} wireType The field wire type
	         * @param {number} id The field number
	         * @return {*} Decoded value
	         * @throws {Error} If the field cannot be decoded
	         * @expose
	         */
	        ElementPrototype.decode = function(buffer, wireType, id) {
	            if (wireType != this.type.wireType)
	                throw Error("Unexpected wire type for element");
	
	            var value, nBytes;
	            switch (this.type) {
	                // 32bit signed varint
	                case ProtoBuf.TYPES["int32"]:
	                    return buffer.readVarint32() | 0;
	
	                // 32bit unsigned varint
	                case ProtoBuf.TYPES["uint32"]:
	                    return buffer.readVarint32() >>> 0;
	
	                // 32bit signed varint zig-zag
	                case ProtoBuf.TYPES["sint32"]:
	                    return buffer.readVarint32ZigZag() | 0;
	
	                // Fixed 32bit unsigned
	                case ProtoBuf.TYPES["fixed32"]:
	                    return buffer.readUint32() >>> 0;
	
	                case ProtoBuf.TYPES["sfixed32"]:
	                    return buffer.readInt32() | 0;
	
	                // 64bit signed varint
	                case ProtoBuf.TYPES["int64"]:
	                    return buffer.readVarint64();
	
	                // 64bit unsigned varint
	                case ProtoBuf.TYPES["uint64"]:
	                    return buffer.readVarint64().toUnsigned();
	
	                // 64bit signed varint zig-zag
	                case ProtoBuf.TYPES["sint64"]:
	                    return buffer.readVarint64ZigZag();
	
	                // Fixed 64bit unsigned
	                case ProtoBuf.TYPES["fixed64"]:
	                    return buffer.readUint64();
	
	                // Fixed 64bit signed
	                case ProtoBuf.TYPES["sfixed64"]:
	                    return buffer.readInt64();
	
	                // Bool varint
	                case ProtoBuf.TYPES["bool"]:
	                    return !!buffer.readVarint32();
	
	                // Constant enum value (varint)
	                case ProtoBuf.TYPES["enum"]:
	                    // The following Builder.Message#set will already throw
	                    return buffer.readVarint32();
	
	                // 32bit float
	                case ProtoBuf.TYPES["float"]:
	                    return buffer.readFloat();
	
	                // 64bit float
	                case ProtoBuf.TYPES["double"]:
	                    return buffer.readDouble();
	
	                // Length-delimited string
	                case ProtoBuf.TYPES["string"]:
	                    return buffer.readVString();
	
	                // Length-delimited bytes
	                case ProtoBuf.TYPES["bytes"]: {
	                    nBytes = buffer.readVarint32();
	                    if (buffer.remaining() < nBytes)
	                        throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
	                    value = buffer.clone(); // Offset already set
	                    value.limit = value.offset+nBytes;
	                    buffer.offset += nBytes;
	                    return value;
	                }
	
	                // Length-delimited embedded message
	                case ProtoBuf.TYPES["message"]: {
	                    nBytes = buffer.readVarint32();
	                    return this.resolvedType.decode(buffer, nBytes);
	                }
	
	                // Legacy group
	                case ProtoBuf.TYPES["group"]:
	                    return this.resolvedType.decode(buffer, -1, id);
	            }
	
	            // We should never end here
	            throw Error("[INTERNAL] Illegal decode type");
	        };
	
	        /**
	         * Converts a value from a string to the canonical element type.
	         *
	         * Legal only when isMapKey is true.
	         *
	         * @param {string} str The string value
	         * @returns {*} The value
	         */
	        ElementPrototype.valueFromString = function(str) {
	            if (!this.isMapKey) {
	                throw Error("valueFromString() called on non-map-key element");
	            }
	
	            switch (this.type) {
	                case ProtoBuf.TYPES["int32"]:
	                case ProtoBuf.TYPES["sint32"]:
	                case ProtoBuf.TYPES["sfixed32"]:
	                case ProtoBuf.TYPES["uint32"]:
	                case ProtoBuf.TYPES["fixed32"]:
	                    return this.verifyValue(parseInt(str));
	
	                case ProtoBuf.TYPES["int64"]:
	                case ProtoBuf.TYPES["sint64"]:
	                case ProtoBuf.TYPES["sfixed64"]:
	                case ProtoBuf.TYPES["uint64"]:
	                case ProtoBuf.TYPES["fixed64"]:
	                      // Long-based fields support conversions from string already.
	                      return this.verifyValue(str);
	
	                case ProtoBuf.TYPES["bool"]:
	                      return str === "true";
	
	                case ProtoBuf.TYPES["string"]:
	                      return this.verifyValue(str);
	
	                case ProtoBuf.TYPES["bytes"]:
	                      return ByteBuffer.fromBinary(str);
	            }
	        };
	
	        /**
	         * Converts a value from the canonical element type to a string.
	         *
	         * It should be the case that `valueFromString(valueToString(val))` returns
	         * a value equivalent to `verifyValue(val)` for every legal value of `val`
	         * according to this element type.
	         *
	         * This may be used when the element must be stored or used as a string,
	         * e.g., as a map key on an Object.
	         *
	         * Legal only when isMapKey is true.
	         *
	         * @param {*} val The value
	         * @returns {string} The string form of the value.
	         */
	        ElementPrototype.valueToString = function(value) {
	            if (!this.isMapKey) {
	                throw Error("valueToString() called on non-map-key element");
	            }
	
	            if (this.type === ProtoBuf.TYPES["bytes"]) {
	                return value.toString("binary");
	            } else {
	                return value.toString();
	            }
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Element
	         * @expose
	         */
	        Reflect.Element = Element;
	
	        /**
	         * Constructs a new Message.
	         * @exports ProtoBuf.Reflect.Message
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
	         * @param {string} name Message name
	         * @param {Object.<string,*>=} options Message options
	         * @param {boolean=} isGroup `true` if this is a legacy group
	         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
	         * @constructor
	         * @extends ProtoBuf.Reflect.Namespace
	         */
	        var Message = function(builder, parent, name, options, isGroup, syntax) {
	            Namespace.call(this, builder, parent, name, options, syntax);
	
	            /**
	             * @override
	             */
	            this.className = "Message";
	
	            /**
	             * Extensions range.
	             * @type {!Array.<number>|undefined}
	             * @expose
	             */
	            this.extensions = undefined;
	
	            /**
	             * Runtime message class.
	             * @type {?function(new:ProtoBuf.Builder.Message)}
	             * @expose
	             */
	            this.clazz = null;
	
	            /**
	             * Whether this is a legacy group or not.
	             * @type {boolean}
	             * @expose
	             */
	            this.isGroup = !!isGroup;
	
	            // The following cached collections are used to efficiently iterate over or look up fields when decoding.
	
	            /**
	             * Cached fields.
	             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
	             * @private
	             */
	            this._fields = null;
	
	            /**
	             * Cached fields by id.
	             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
	             * @private
	             */
	            this._fieldsById = null;
	
	            /**
	             * Cached fields by name.
	             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
	             * @private
	             */
	            this._fieldsByName = null;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Message.prototype
	         * @inner
	         */
	        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);
	
	        /**
	         * Builds the message and returns the runtime counterpart, which is a fully functional class.
	         * @see ProtoBuf.Builder.Message
	         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
	         * @return {ProtoBuf.Reflect.Message} Message class
	         * @throws {Error} If the message cannot be built
	         * @expose
	         */
	        MessagePrototype.build = function(rebuild) {
	            if (this.clazz && !rebuild)
	                return this.clazz;
	
	            // Create the runtime Message class in its own scope
	            var clazz = (function(ProtoBuf, T) {
	
	                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
	                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);
	
	                /**
	                 * Constructs a new runtime Message.
	                 * @name ProtoBuf.Builder.Message
	                 * @class Barebone of all runtime messages.
	                 * @param {!Object.<string,*>|string} values Preset values
	                 * @param {...string} var_args
	                 * @constructor
	                 * @throws {Error} If the message cannot be created
	                 */
	                var Message = function(values, var_args) {
	                    ProtoBuf.Builder.Message.call(this);
	
	                    // Create virtual oneof properties
	                    for (var i=0, k=oneofs.length; i<k; ++i)
	                        this[oneofs[i].name] = null;
	                    // Create fields and set default values
	                    for (i=0, k=fields.length; i<k; ++i) {
	                        var field = fields[i];
	                        this[field.name] =
	                            field.repeated ? [] :
	                            (field.map ? new ProtoBuf.Map(field) : null);
	                        if ((field.required || T.syntax === 'proto3') &&
	                            field.defaultValue !== null)
	                            this[field.name] = field.defaultValue;
	                    }
	
	                    if (arguments.length > 0) {
	                        var value;
	                        // Set field values from a values object
	                        if (arguments.length === 1 && values !== null && typeof values === 'object' &&
	                            /* not _another_ Message */ (typeof values.encode !== 'function' || values instanceof Message) &&
	                            /* not a repeated field */ !Array.isArray(values) &&
	                            /* not a Map */ !(values instanceof ProtoBuf.Map) &&
	                            /* not a ByteBuffer */ !ByteBuffer.isByteBuffer(values) &&
	                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
	                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
	                            this.$set(values);
	                        } else // Set field values from arguments, in declaration order
	                            for (i=0, k=arguments.length; i<k; ++i)
	                                if (typeof (value = arguments[i]) !== 'undefined')
	                                    this.$set(fields[i].name, value); // May throw
	                    }
	                };
	
	                /**
	                 * @alias ProtoBuf.Builder.Message.prototype
	                 * @inner
	                 */
	                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);
	
	                /**
	                 * Adds a value to a repeated field.
	                 * @name ProtoBuf.Builder.Message#add
	                 * @function
	                 * @param {string} key Field name
	                 * @param {*} value Value to add
	                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
	                 * @returns {!ProtoBuf.Builder.Message} this
	                 * @throws {Error} If the value cannot be added
	                 * @expose
	                 */
	                MessagePrototype.add = function(key, value, noAssert) {
	                    var field = T._fieldsByName[key];
	                    if (!noAssert) {
	                        if (!field)
	                            throw Error(this+"#"+key+" is undefined");
	                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
	                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
	                        if (!field.repeated)
	                            throw Error(this+"#"+key+" is not a repeated field");
	                        value = field.verifyValue(value, true);
	                    }
	                    if (this[key] === null)
	                        this[key] = [];
	                    this[key].push(value);
	                    return this;
	                };
	
	                /**
	                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
	                 * @name ProtoBuf.Builder.Message#$add
	                 * @function
	                 * @param {string} key Field name
	                 * @param {*} value Value to add
	                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
	                 * @returns {!ProtoBuf.Builder.Message} this
	                 * @throws {Error} If the value cannot be added
	                 * @expose
	                 */
	                MessagePrototype.$add = MessagePrototype.add;
	
	                /**
	                 * Sets a field's value.
	                 * @name ProtoBuf.Builder.Message#set
	                 * @function
	                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
	                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
	                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
	                 * @returns {!ProtoBuf.Builder.Message} this
	                 * @throws {Error} If the value cannot be set
	                 * @expose
	                 */
	                MessagePrototype.set = function(keyOrObj, value, noAssert) {
	                    if (keyOrObj && typeof keyOrObj === 'object') {
	                        noAssert = value;
	                        for (var ikey in keyOrObj)
	                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined')
	                                this.$set(ikey, value, noAssert);
	                        return this;
	                    }
	                    var field = T._fieldsByName[keyOrObj];
	                    if (!noAssert) {
	                        if (!field)
	                            throw Error(this+"#"+keyOrObj+" is not a field: undefined");
	                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
	                            throw Error(this+"#"+keyOrObj+" is not a field: "+field.toString(true));
	                        this[field.name] = (value = field.verifyValue(value)); // May throw
	                    } else
	                        this[keyOrObj] = value;
	                    if (field && field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)
	                        var currentField = this[field.oneof.name]; // Virtual field references currently set field
	                        if (value !== null) {
	                            if (currentField !== null && currentField !== field.name)
	                                this[currentField] = null; // Clear currently set field
	                            this[field.oneof.name] = field.name; // Point virtual field at this field
	                        } else if (/* value === null && */currentField === keyOrObj)
	                            this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
	                    }
	                    return this;
	                };
	
	                /**
	                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
	                 * @name ProtoBuf.Builder.Message#$set
	                 * @function
	                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
	                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
	                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
	                 * @throws {Error} If the value cannot be set
	                 * @expose
	                 */
	                MessagePrototype.$set = MessagePrototype.set;
	
	                /**
	                 * Gets a field's value.
	                 * @name ProtoBuf.Builder.Message#get
	                 * @function
	                 * @param {string} key Key
	                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
	                 * @return {*} Value
	                 * @throws {Error} If there is no such field
	                 * @expose
	                 */
	                MessagePrototype.get = function(key, noAssert) {
	                    if (noAssert)
	                        return this[key];
	                    var field = T._fieldsByName[key];
	                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
	                        throw Error(this+"#"+key+" is not a field: undefined");
	                    if (!(field instanceof ProtoBuf.Reflect.Message.Field))
	                        throw Error(this+"#"+key+" is not a field: "+field.toString(true));
	                    return this[field.name];
	                };
	
	                /**
	                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
	                 * @name ProtoBuf.Builder.Message#$get
	                 * @function
	                 * @param {string} key Key
	                 * @return {*} Value
	                 * @throws {Error} If there is no such field
	                 * @expose
	                 */
	                MessagePrototype.$get = MessagePrototype.get;
	
	                // Getters and setters
	
	                for (var i=0; i<fields.length; i++) {
	                    var field = fields[i];
	                    // no setters for extension fields as these are named by their fqn
	                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)
	                        continue;
	
	                    if (T.builder.options['populateAccessors'])
	                        (function(field) {
	                            // set/get[SomeValue]
	                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
	                                return match.toUpperCase().replace('_','');
	                            });
	                            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);
	
	                            // set/get_[some_value] FIXME: Do we really need these?
	                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
	                                return "_"+match;
	                            });
	
	                            /**
	                             * The current field's unbound setter function.
	                             * @function
	                             * @param {*} value
	                             * @param {boolean=} noAssert
	                             * @returns {!ProtoBuf.Builder.Message}
	                             * @inner
	                             */
	                            var setter = function(value, noAssert) {
	                                this[field.name] = noAssert ? value : field.verifyValue(value);
	                                return this;
	                            };
	
	                            /**
	                             * The current field's unbound getter function.
	                             * @function
	                             * @returns {*}
	                             * @inner
	                             */
	                            var getter = function() {
	                                return this[field.name];
	                            };
	
	                            if (T.getChild("set"+Name) === null)
	                                /**
	                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
	                                 *  another field.
	                                 * @name ProtoBuf.Builder.Message#set[SomeField]
	                                 * @function
	                                 * @param {*} value Value to set
	                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
	                                 * @returns {!ProtoBuf.Builder.Message} this
	                                 * @abstract
	                                 * @throws {Error} If the value cannot be set
	                                 */
	                                MessagePrototype["set"+Name] = setter;
	
	                            if (T.getChild("set_"+name) === null)
	                                /**
	                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
	                                 *  another field.
	                                 * @name ProtoBuf.Builder.Message#set_[some_field]
	                                 * @function
	                                 * @param {*} value Value to set
	                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
	                                 * @returns {!ProtoBuf.Builder.Message} this
	                                 * @abstract
	                                 * @throws {Error} If the value cannot be set
	                                 */
	                                MessagePrototype["set_"+name] = setter;
	
	                            if (T.getChild("get"+Name) === null)
	                                /**
	                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
	                                 *  another field.
	                                 * @name ProtoBuf.Builder.Message#get[SomeField]
	                                 * @function
	                                 * @abstract
	                                 * @return {*} The value
	                                 */
	                                MessagePrototype["get"+Name] = getter;
	
	                            if (T.getChild("get_"+name) === null)
	                                /**
	                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
	                                 *  another field.
	                                 * @name ProtoBuf.Builder.Message#get_[some_field]
	                                 * @function
	                                 * @return {*} The value
	                                 * @abstract
	                                 */
	                                MessagePrototype["get_"+name] = getter;
	
	                        })(field);
	                }
	
	                // En-/decoding
	
	                /**
	                 * Encodes the message.
	                 * @name ProtoBuf.Builder.Message#$encode
	                 * @function
	                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
	                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
	                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
	                 * @expose
	                 * @see ProtoBuf.Builder.Message#encode64
	                 * @see ProtoBuf.Builder.Message#encodeHex
	                 * @see ProtoBuf.Builder.Message#encodeAB
	                 */
	                MessagePrototype.encode = function(buffer, noVerify) {
	                    if (typeof buffer === 'boolean')
	                        noVerify = buffer,
	                        buffer = undefined;
	                    var isNew = false;
	                    if (!buffer)
	                        buffer = new ByteBuffer(),
	                        isNew = true;
	                    var le = buffer.littleEndian;
	                    try {
	                        T.encode(this, buffer.LE(), noVerify);
	                        return (isNew ? buffer.flip() : buffer).LE(le);
	                    } catch (e) {
	                        buffer.LE(le);
	                        throw(e);
	                    }
	                };
	
	                /**
	                 * Encodes a message using the specified data payload.
	                 * @param {!Object.<string,*>} data Data payload
	                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
	                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
	                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
	                 * @expose
	                 */
	                Message.encode = function(data, buffer, noVerify) {
	                    return new Message(data).encode(buffer, noVerify);
	                };
	
	                /**
	                 * Calculates the byte length of the message.
	                 * @name ProtoBuf.Builder.Message#calculate
	                 * @function
	                 * @returns {number} Byte length
	                 * @throws {Error} If the message cannot be calculated or if required fields are missing.
	                 * @expose
	                 */
	                MessagePrototype.calculate = function() {
	                    return T.calculate(this);
	                };
	
	                /**
	                 * Encodes the varint32 length-delimited message.
	                 * @name ProtoBuf.Builder.Message#encodeDelimited
	                 * @function
	                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
	                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
	                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.encodeDelimited = function(buffer, noVerify) {
	                    var isNew = false;
	                    if (!buffer)
	                        buffer = new ByteBuffer(),
	                        isNew = true;
	                    var enc = new ByteBuffer().LE();
	                    T.encode(this, enc, noVerify).flip();
	                    buffer.writeVarint32(enc.remaining());
	                    buffer.append(enc);
	                    return isNew ? buffer.flip() : buffer;
	                };
	
	                /**
	                 * Directly encodes the message to an ArrayBuffer.
	                 * @name ProtoBuf.Builder.Message#encodeAB
	                 * @function
	                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.encodeAB = function() {
	                    try {
	                        return this.encode().toArrayBuffer();
	                    } catch (e) {
	                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
	                        throw(e);
	                    }
	                };
	
	                /**
	                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
	                 * @name ProtoBuf.Builder.Message#toArrayBuffer
	                 * @function
	                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;
	
	                /**
	                 * Directly encodes the message to a node Buffer.
	                 * @name ProtoBuf.Builder.Message#encodeNB
	                 * @function
	                 * @return {!Buffer}
	                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
	                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.encodeNB = function() {
	                    try {
	                        return this.encode().toBuffer();
	                    } catch (e) {
	                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
	                        throw(e);
	                    }
	                };
	
	                /**
	                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
	                 * @name ProtoBuf.Builder.Message#toBuffer
	                 * @function
	                 * @return {!Buffer}
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded node Buffer in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.toBuffer = MessagePrototype.encodeNB;
	
	                /**
	                 * Directly encodes the message to a base64 encoded string.
	                 * @name ProtoBuf.Builder.Message#encode64
	                 * @function
	                 * @return {string} Base64 encoded string
	                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
	                 *  still returns the encoded base64 string in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.encode64 = function() {
	                    try {
	                        return this.encode().toBase64();
	                    } catch (e) {
	                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
	                        throw(e);
	                    }
	                };
	
	                /**
	                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
	                 * @name ProtoBuf.Builder.Message#toBase64
	                 * @function
	                 * @return {string} Base64 encoded string
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded base64 string in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.toBase64 = MessagePrototype.encode64;
	
	                /**
	                 * Directly encodes the message to a hex encoded string.
	                 * @name ProtoBuf.Builder.Message#encodeHex
	                 * @function
	                 * @return {string} Hex encoded string
	                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
	                 *  still returns the encoded hex string in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.encodeHex = function() {
	                    try {
	                        return this.encode().toHex();
	                    } catch (e) {
	                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
	                        throw(e);
	                    }
	                };
	
	                /**
	                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
	                 * @name ProtoBuf.Builder.Message#toHex
	                 * @function
	                 * @return {string} Hex encoded string
	                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
	                 *  returns the encoded hex string in the `encoded` property on the error.
	                 * @expose
	                 */
	                MessagePrototype.toHex = MessagePrototype.encodeHex;
	
	                /**
	                 * Clones a message object or field value to a raw object.
	                 * @param {*} obj Object to clone
	                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
	                 * @param {boolean} longsAsStrings Whether to encode longs as strings
	                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
	                 * @returns {*} Cloned object
	                 * @inner
	                 */
	                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
	                    if (obj === null || typeof obj !== 'object') {
	                        // Convert enum values to their respective names
	                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
	                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
	                            if (name !== null)
	                                return name;
	                        }
	                        // Pass-through string, number, boolean, null...
	                        return obj;
	                    }
	                    // Convert ByteBuffers to raw buffer or strings
	                    if (ByteBuffer.isByteBuffer(obj))
	                        return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
	                    // Convert Longs to proper objects or strings
	                    if (ProtoBuf.Long.isLong(obj))
	                        return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
	                    var clone;
	                    // Clone arrays
	                    if (Array.isArray(obj)) {
	                        clone = [];
	                        obj.forEach(function(v, k) {
	                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
	                        });
	                        return clone;
	                    }
	                    clone = {};
	                    // Convert maps to objects
	                    if (obj instanceof ProtoBuf.Map) {
	                        var it = obj.entries();
	                        for (var e = it.next(); !e.done; e = it.next())
	                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
	                        return clone;
	                    }
	                    // Everything else is a non-null object
	                    var type = obj.$type,
	                        field = undefined;
	                    for (var i in obj)
	                        if (obj.hasOwnProperty(i)) {
	                            if (type && (field = type.getChild(i)))
	                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);
	                            else
	                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
	                        }
	                    return clone;
	                }
	
	                /**
	                 * Returns the message's raw payload.
	                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
	                 * @param {boolean} longsAsStrings Whether to encode longs as strings
	                 * @returns {Object.<string,*>} Raw payload
	                 * @expose
	                 */
	                MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) {
	                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
	                };
	
	                /**
	                 * Encodes a message to JSON.
	                 * @returns {string} JSON string
	                 * @expose
	                 */
	                MessagePrototype.encodeJSON = function() {
	                    return JSON.stringify(
	                        cloneRaw(this,
	                             /* binary-as-base64 */ true,
	                             /* longs-as-strings */ true,
	                             this.$type
	                        )
	                    );
	                };
	
	                /**
	                 * Decodes a message from the specified buffer or string.
	                 * @name ProtoBuf.Builder.Message.decode
	                 * @function
	                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
	                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.
	                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
	                 * @return {!ProtoBuf.Builder.Message} Decoded message
	                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
	                 *  returns the decoded message with missing fields in the `decoded` property on the error.
	                 * @expose
	                 * @see ProtoBuf.Builder.Message.decode64
	                 * @see ProtoBuf.Builder.Message.decodeHex
	                 */
	                Message.decode = function(buffer, length, enc) {
	                    if (typeof length === 'string')
	                        enc = length,
	                        length = -1;
	                    if (typeof buffer === 'string')
	                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
	                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw
	                    var le = buffer.littleEndian;
	                    try {
	                        var msg = T.decode(buffer.LE());
	                        buffer.LE(le);
	                        return msg;
	                    } catch (e) {
	                        buffer.LE(le);
	                        throw(e);
	                    }
	                };
	
	                /**
	                 * Decodes a varint32 length-delimited message from the specified buffer or string.
	                 * @name ProtoBuf.Builder.Message.decodeDelimited
	                 * @function
	                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
	                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
	                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
	                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
	                 *  returns the decoded message with missing fields in the `decoded` property on the error.
	                 * @expose
	                 */
	                Message.decodeDelimited = function(buffer, enc) {
	                    if (typeof buffer === 'string')
	                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
	                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw
	                    if (buffer.remaining() < 1)
	                        return null;
	                    var off = buffer.offset,
	                        len = buffer.readVarint32();
	                    if (buffer.remaining() < len) {
	                        buffer.offset = off;
	                        return null;
	                    }
	                    try {
	                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
	                        buffer.offset += len;
	                        return msg;
	                    } catch (err) {
	                        buffer.offset += len;
	                        throw err;
	                    }
	                };
	
	                /**
	                 * Decodes the message from the specified base64 encoded string.
	                 * @name ProtoBuf.Builder.Message.decode64
	                 * @function
	                 * @param {string} str String to decode from
	                 * @return {!ProtoBuf.Builder.Message} Decoded message
	                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
	                 *  returns the decoded message with missing fields in the `decoded` property on the error.
	                 * @expose
	                 */
	                Message.decode64 = function(str) {
	                    return Message.decode(str, "base64");
	                };
	
	                /**
	                 * Decodes the message from the specified hex encoded string.
	                 * @name ProtoBuf.Builder.Message.decodeHex
	                 * @function
	                 * @param {string} str String to decode from
	                 * @return {!ProtoBuf.Builder.Message} Decoded message
	                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
	                 *  returns the decoded message with missing fields in the `decoded` property on the error.
	                 * @expose
	                 */
	                Message.decodeHex = function(str) {
	                    return Message.decode(str, "hex");
	                };
	
	                /**
	                 * Decodes the message from a JSON string.
	                 * @name ProtoBuf.Builder.Message.decodeJSON
	                 * @function
	                 * @param {string} str String to decode from
	                 * @return {!ProtoBuf.Builder.Message} Decoded message
	                 * @throws {Error} If the message cannot be decoded or if required fields are
	                 * missing.
	                 * @expose
	                 */
	                Message.decodeJSON = function(str) {
	                    return new Message(JSON.parse(str));
	                };
	
	                // Utility
	
	                /**
	                 * Returns a string representation of this Message.
	                 * @name ProtoBuf.Builder.Message#toString
	                 * @function
	                 * @return {string} String representation as of ".Fully.Qualified.MessageName"
	                 * @expose
	                 */
	                MessagePrototype.toString = function() {
	                    return T.toString();
	                };
	
	                // Properties
	
	                /**
	                 * Message options.
	                 * @name ProtoBuf.Builder.Message.$options
	                 * @type {Object.<string,*>}
	                 * @expose
	                 */
	                var $optionsS; // cc needs this
	
	                /**
	                 * Message options.
	                 * @name ProtoBuf.Builder.Message#$options
	                 * @type {Object.<string,*>}
	                 * @expose
	                 */
	                var $options;
	
	                /**
	                 * Reflection type.
	                 * @name ProtoBuf.Builder.Message.$type
	                 * @type {!ProtoBuf.Reflect.Message}
	                 * @expose
	                 */
	                var $typeS;
	
	                /**
	                 * Reflection type.
	                 * @name ProtoBuf.Builder.Message#$type
	                 * @type {!ProtoBuf.Reflect.Message}
	                 * @expose
	                 */
	                var $type;
	
	                if (Object.defineProperty)
	                    Object.defineProperty(Message, '$options', { "value": T.buildOpt() }),
	                    Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }),
	                    Object.defineProperty(Message, "$type", { "value": T }),
	                    Object.defineProperty(MessagePrototype, "$type", { "value": T });
	
	                return Message;
	
	            })(ProtoBuf, this);
	
	            // Static enums and prototyped sub-messages / cached collections
	            this._fields = [];
	            this._fieldsById = {};
	            this._fieldsByName = {};
	            for (var i=0, k=this.children.length, child; i<k; i++) {
	                child = this.children[i];
	                if (child instanceof Enum || child instanceof Message || child instanceof Service) {
	                    if (clazz.hasOwnProperty(child.name))
	                        throw Error("Illegal reflect child of "+this.toString(true)+": "+child.toString(true)+" cannot override static property '"+child.name+"'");
	                    clazz[child.name] = child.build();
	                } else if (child instanceof Message.Field)
	                    child.build(),
	                    this._fields.push(child),
	                    this._fieldsById[child.id] = child,
	                    this._fieldsByName[child.name] = child;
	                else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
	                    throw Error("Illegal reflect child of "+this.toString(true)+": "+this.children[i].toString(true));
	            }
	
	            return this.clazz = clazz;
	        };
	
	        /**
	         * Encodes a runtime message's contents to the specified buffer.
	         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
	         * @param {ByteBuffer} buffer ByteBuffer to write to
	         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
	         * @return {ByteBuffer} The ByteBuffer for chaining
	         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
	         * @expose
	         */
	        MessagePrototype.encode = function(message, buffer, noVerify) {
	            var fieldMissing = null,
	                field;
	            for (var i=0, k=this._fields.length, val; i<k; ++i) {
	                field = this._fields[i];
	                val = message[field.name];
	                if (field.required && val === null) {
	                    if (fieldMissing === null)
	                        fieldMissing = field;
	                } else
	                    field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
	            }
	            if (fieldMissing !== null) {
	                var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
	                err["encoded"] = buffer; // Still expose what we got
	                throw(err);
	            }
	            return buffer;
	        };
	
	        /**
	         * Calculates a runtime message's byte length.
	         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
	         * @returns {number} Byte length
	         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
	         * @expose
	         */
	        MessagePrototype.calculate = function(message) {
	            for (var n=0, i=0, k=this._fields.length, field, val; i<k; ++i) {
	                field = this._fields[i];
	                val = message[field.name];
	                if (field.required && val === null)
	                   throw Error("Missing at least one required field for "+this.toString(true)+": "+field);
	                else
	                    n += field.calculate(val, message);
	            }
	            return n;
	        };
	
	        /**
	         * Skips all data until the end of the specified group has been reached.
	         * @param {number} expectedId Expected GROUPEND id
	         * @param {!ByteBuffer} buf ByteBuffer
	         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
	         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
	         * @inner
	         */
	        function skipTillGroupEnd(expectedId, buf) {
	            var tag = buf.readVarint32(), // Throws on OOB
	                wireType = tag & 0x07,
	                id = tag >>> 3;
	            switch (wireType) {
	                case ProtoBuf.WIRE_TYPES.VARINT:
	                    do tag = buf.readUint8();
	                    while ((tag & 0x80) === 0x80);
	                    break;
	                case ProtoBuf.WIRE_TYPES.BITS64:
	                    buf.offset += 8;
	                    break;
	                case ProtoBuf.WIRE_TYPES.LDELIM:
	                    tag = buf.readVarint32(); // reads the varint
	                    buf.offset += tag;        // skips n bytes
	                    break;
	                case ProtoBuf.WIRE_TYPES.STARTGROUP:
	                    skipTillGroupEnd(id, buf);
	                    break;
	                case ProtoBuf.WIRE_TYPES.ENDGROUP:
	                    if (id === expectedId)
	                        return false;
	                    else
	                        throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
	                case ProtoBuf.WIRE_TYPES.BITS32:
	                    buf.offset += 4;
	                    break;
	                default:
	                    throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
	            }
	            return true;
	        }
	
	        /**
	         * Decodes an encoded message and returns the decoded message.
	         * @param {ByteBuffer} buffer ByteBuffer to decode from
	         * @param {number=} length Message length. Defaults to decode all remaining data.
	         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
	         * @return {ProtoBuf.Builder.Message} Decoded message
	         * @throws {Error} If the message cannot be decoded
	         * @expose
	         */
	        MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {
	            length = typeof length === 'number' ? length : -1;
	            var start = buffer.offset,
	                msg = new (this.clazz)(),
	                tag, wireType, id, field;
	            while (buffer.offset < start+length || (length === -1 && buffer.remaining() > 0)) {
	                tag = buffer.readVarint32();
	                wireType = tag & 0x07;
	                id = tag >>> 3;
	                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
	                    if (id !== expectedGroupEndId)
	                        throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
	                    break;
	                }
	                if (!(field = this._fieldsById[id])) {
	                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
	                    switch (wireType) {
	                        case ProtoBuf.WIRE_TYPES.VARINT:
	                            buffer.readVarint32();
	                            break;
	                        case ProtoBuf.WIRE_TYPES.BITS32:
	                            buffer.offset += 4;
	                            break;
	                        case ProtoBuf.WIRE_TYPES.BITS64:
	                            buffer.offset += 8;
	                            break;
	                        case ProtoBuf.WIRE_TYPES.LDELIM:
	                            var len = buffer.readVarint32();
	                            buffer.offset += len;
	                            break;
	                        case ProtoBuf.WIRE_TYPES.STARTGROUP:
	                            while (skipTillGroupEnd(id, buffer)) {}
	                            break;
	                        default:
	                            throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
	                    }
	                    continue;
	                }
	                if (field.repeated && !field.options["packed"]) {
	                    msg[field.name].push(field.decode(wireType, buffer));
	                } else if (field.map) {
	                    var keyval = field.decode(wireType, buffer);
	                    msg[field.name].set(keyval[0], keyval[1]);
	                } else {
	                    msg[field.name] = field.decode(wireType, buffer);
	                    if (field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)
	                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field
	                        if (currentField !== null && currentField !== field.name)
	                            msg[currentField] = null; // Clear currently set field
	                        msg[field.oneof.name] = field.name; // Point virtual field at this field
	                    }
	                }
	            }
	
	            // Check if all required fields are present and set default values for optional fields that are not
	            for (var i=0, k=this._fields.length; i<k; ++i) {
	                field = this._fields[i];
	                if (msg[field.name] === null) {
	                    if (this.syntax === "proto3") { // Proto3 sets default values by specification
	                        msg[field.name] = field.defaultValue;
	                    } else if (field.required) {
	                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
	                        err["decoded"] = msg; // Still expose what we got
	                        throw(err);
	                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null)
	                        msg[field.name] = field.defaultValue;
	                }
	            }
	            return msg;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Message
	         * @expose
	         */
	        Reflect.Message = Message;
	
	        /**
	         * Constructs a new Message Field.
	         * @exports ProtoBuf.Reflect.Message.Field
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Message} message Message reference
	         * @param {string} rule Rule, one of requried, optional, repeated
	         * @param {string?} keytype Key data type, if any.
	         * @param {string} type Data type, e.g. int32
	         * @param {string} name Field name
	         * @param {number} id Unique field id
	         * @param {Object.<string,*>=} options Options
	         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
	         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
	         * @constructor
	         * @extends ProtoBuf.Reflect.T
	         */
	        var Field = function(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
	            T.call(this, builder, message, name);
	
	            /**
	             * @override
	             */
	            this.className = "Message.Field";
	
	            /**
	             * Message field required flag.
	             * @type {boolean}
	             * @expose
	             */
	            this.required = rule === "required";
	
	            /**
	             * Message field repeated flag.
	             * @type {boolean}
	             * @expose
	             */
	            this.repeated = rule === "repeated";
	
	            /**
	             * Message field map flag.
	             * @type {boolean}
	             * @expose
	             */
	            this.map = rule === "map";
	
	            /**
	             * Message field key type. Type reference string if unresolved, protobuf
	             * type if resolved. Valid only if this.map === true, null otherwise.
	             * @type {string|{name: string, wireType: number}|null}
	             * @expose
	             */
	            this.keyType = keytype || null;
	
	            /**
	             * Message field type. Type reference string if unresolved, protobuf type if
	             * resolved. In a map field, this is the value type.
	             * @type {string|{name: string, wireType: number}}
	             * @expose
	             */
	            this.type = type;
	
	            /**
	             * Resolved type reference inside the global namespace.
	             * @type {ProtoBuf.Reflect.T|null}
	             * @expose
	             */
	            this.resolvedType = null;
	
	            /**
	             * Unique message field id.
	             * @type {number}
	             * @expose
	             */
	            this.id = id;
	
	            /**
	             * Message field options.
	             * @type {!Object.<string,*>}
	             * @dict
	             * @expose
	             */
	            this.options = options || {};
	
	            /**
	             * Default value.
	             * @type {*}
	             * @expose
	             */
	            this.defaultValue = null;
	
	            /**
	             * Enclosing OneOf.
	             * @type {?ProtoBuf.Reflect.Message.OneOf}
	             * @expose
	             */
	            this.oneof = oneof || null;
	
	            /**
	             * Syntax level of this definition (e.g., proto3).
	             * @type {string}
	             * @expose
	             */
	            this.syntax = syntax || 'proto2';
	
	            /**
	             * Original field name.
	             * @type {string}
	             * @expose
	             */
	            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions
	
	            /**
	             * Element implementation. Created in build() after types are resolved.
	             * @type {ProtoBuf.Element}
	             * @expose
	             */
	            this.element = null;
	
	            /**
	             * Key element implementation, for map fields. Created in build() after
	             * types are resolved.
	             * @type {ProtoBuf.Element}
	             * @expose
	             */
	            this.keyElement = null;
	
	            // Convert field names to camel case notation if the override is set
	            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField))
	                this.name = ProtoBuf.Util.toCamelCase(this.name);
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Message.Field.prototype
	         * @inner
	         */
	        var FieldPrototype = Field.prototype = Object.create(T.prototype);
	
	        /**
	         * Builds the field.
	         * @override
	         * @expose
	         */
	        FieldPrototype.build = function() {
	            this.element = new Element(this.type, this.resolvedType, false, this.syntax);
	            if (this.map)
	                this.keyElement = new Element(this.keyType, undefined, true, this.syntax);
	
	            // In proto3, fields do not have field presence, and every field is set to
	            // its type's default value ("", 0, 0.0, or false).
	            if (this.syntax === 'proto3' && !this.repeated && !this.map)
	                this.defaultValue = Element.defaultFieldValue(this.type);
	
	            // Otherwise, default values are present when explicitly specified
	            else if (typeof this.options['default'] !== 'undefined')
	                this.defaultValue = this.verifyValue(this.options['default']);
	        };
	
	        /**
	         * Checks if the given value can be set for this field.
	         * @param {*} value Value to check
	         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
	         * @return {*} Verified, maybe adjusted, value
	         * @throws {Error} If the value cannot be set for this field
	         * @expose
	         */
	        FieldPrototype.verifyValue = function(value, skipRepeated) {
	            skipRepeated = skipRepeated || false;
	            var self = this;
	            function fail(val, msg) {
	                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
	            }
	            if (value === null) { // NULL values for optional fields
	                if (this.required)
	                    fail(typeof value, "required");
	                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"])
	                    fail(typeof value, "proto3 field without field presence cannot be null");
	                return null;
	            }
	            var i;
	            if (this.repeated && !skipRepeated) { // Repeated values as arrays
	                if (!Array.isArray(value))
	                    value = [value];
	                var res = [];
	                for (i=0; i<value.length; i++)
	                    res.push(this.element.verifyValue(value[i]));
	                return res;
	            }
	            if (this.map && !skipRepeated) { // Map values as objects
	                if (!(value instanceof ProtoBuf.Map)) {
	                    // If not already a Map, attempt to convert.
	                    if (!(value instanceof Object)) {
	                        fail(typeof value,
	                             "expected ProtoBuf.Map or raw object for map field");
	                    }
	                    return new ProtoBuf.Map(this, value);
	                } else {
	                    return value;
	                }
	            }
	            // All non-repeated fields expect no array
	            if (!this.repeated && Array.isArray(value))
	                fail(typeof value, "no array expected");
	
	            return this.element.verifyValue(value);
	        };
	
	        /**
	         * Determines whether the field will have a presence on the wire given its
	         * value.
	         * @param {*} value Verified field value
	         * @param {!ProtoBuf.Builder.Message} message Runtime message
	         * @return {boolean} Whether the field will be present on the wire
	         */
	        FieldPrototype.hasWirePresence = function(value, message) {
	            if (this.syntax !== 'proto3')
	                return (value !== null);
	            if (this.oneof && message[this.oneof.name] === this.name)
	                return true;
	            switch (this.type) {
	                case ProtoBuf.TYPES["int32"]:
	                case ProtoBuf.TYPES["sint32"]:
	                case ProtoBuf.TYPES["sfixed32"]:
	                case ProtoBuf.TYPES["uint32"]:
	                case ProtoBuf.TYPES["fixed32"]:
	                    return value !== 0;
	
	                case ProtoBuf.TYPES["int64"]:
	                case ProtoBuf.TYPES["sint64"]:
	                case ProtoBuf.TYPES["sfixed64"]:
	                case ProtoBuf.TYPES["uint64"]:
	                case ProtoBuf.TYPES["fixed64"]:
	                    return value.low !== 0 || value.high !== 0;
	
	                case ProtoBuf.TYPES["bool"]:
	                    return value;
	
	                case ProtoBuf.TYPES["float"]:
	                case ProtoBuf.TYPES["double"]:
	                    return value !== 0.0;
	
	                case ProtoBuf.TYPES["string"]:
	                    return value.length > 0;
	
	                case ProtoBuf.TYPES["bytes"]:
	                    return value.remaining() > 0;
	
	                case ProtoBuf.TYPES["enum"]:
	                    return value !== 0;
	
	                case ProtoBuf.TYPES["message"]:
	                    return value !== null;
	                default:
	                    return true;
	            }
	        };
	
	        /**
	         * Encodes the specified field value to the specified buffer.
	         * @param {*} value Verified field value
	         * @param {ByteBuffer} buffer ByteBuffer to encode to
	         * @param {!ProtoBuf.Builder.Message} message Runtime message
	         * @return {ByteBuffer} The ByteBuffer for chaining
	         * @throws {Error} If the field cannot be encoded
	         * @expose
	         */
	        FieldPrototype.encode = function(value, buffer, message) {
	            if (this.type === null || typeof this.type !== 'object')
	                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
	            if (value === null || (this.repeated && value.length == 0))
	                return buffer; // Optional omitted
	            try {
	                if (this.repeated) {
	                    var i;
	                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
	                    // types) can be declared 'packed'."
	                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
	                        // "All of the elements of the field are packed into a single key-value pair with wire type 2
	                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
	                        // tag preceding it."
	                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
	                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
	                        var start = buffer.offset; // Remember where the contents begin
	                        for (i=0; i<value.length; i++)
	                            this.element.encodeValue(this.id, value[i], buffer);
	                        var len = buffer.offset-start,
	                            varintLen = ByteBuffer.calculateVarint32(len);
	                        if (varintLen > 1) { // We need to move the contents
	                            var contents = buffer.slice(start, buffer.offset);
	                            start += varintLen-1;
	                            buffer.offset = start;
	                            buffer.append(contents);
	                        }
	                        buffer.writeVarint32(len, start-varintLen);
	                    } else {
	                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
	                        // message has zero or more key-value pairs with the same tag number"
	                        for (i=0; i<value.length; i++)
	                            buffer.writeVarint32((this.id << 3) | this.type.wireType),
	                            this.element.encodeValue(this.id, value[i], buffer);
	                    }
	                } else if (this.map) {
	                    // Write out each map entry as a submessage.
	                    value.forEach(function(val, key, m) {
	                        // Compute the length of the submessage (key, val) pair.
	                        var length =
	                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
	                            this.keyElement.calculateLength(1, key) +
	                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +
	                            this.element.calculateLength(2, val);
	
	                        // Submessage with wire type of length-delimited.
	                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
	                        buffer.writeVarint32(length);
	
	                        // Write out the key and val.
	                        buffer.writeVarint32((1 << 3) | this.keyType.wireType);
	                        this.keyElement.encodeValue(1, key, buffer);
	                        buffer.writeVarint32((2 << 3) | this.type.wireType);
	                        this.element.encodeValue(2, val, buffer);
	                    }, this);
	                } else {
	                    if (this.hasWirePresence(value, message)) {
	                        buffer.writeVarint32((this.id << 3) | this.type.wireType);
	                        this.element.encodeValue(this.id, value, buffer);
	                    }
	                }
	            } catch (e) {
	                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
	            }
	            return buffer;
	        };
	
	        /**
	         * Calculates the length of this field's value on the network level.
	         * @param {*} value Field value
	         * @param {!ProtoBuf.Builder.Message} message Runtime message
	         * @returns {number} Byte length
	         * @expose
	         */
	        FieldPrototype.calculate = function(value, message) {
	            value = this.verifyValue(value); // May throw
	            if (this.type === null || typeof this.type !== 'object')
	                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
	            if (value === null || (this.repeated && value.length == 0))
	                return 0; // Optional omitted
	            var n = 0;
	            try {
	                if (this.repeated) {
	                    var i, ni;
	                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
	                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
	                        ni = 0;
	                        for (i=0; i<value.length; i++)
	                            ni += this.element.calculateLength(this.id, value[i]);
	                        n += ByteBuffer.calculateVarint32(ni);
	                        n += ni;
	                    } else {
	                        for (i=0; i<value.length; i++)
	                            n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
	                            n += this.element.calculateLength(this.id, value[i]);
	                    }
	                } else if (this.map) {
	                    // Each map entry becomes a submessage.
	                    value.forEach(function(val, key, m) {
	                        // Compute the length of the submessage (key, val) pair.
	                        var length =
	                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
	                            this.keyElement.calculateLength(1, key) +
	                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +
	                            this.element.calculateLength(2, val);
	
	                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
	                        n += ByteBuffer.calculateVarint32(length);
	                        n += length;
	                    }, this);
	                } else {
	                    if (this.hasWirePresence(value, message)) {
	                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);
	                        n += this.element.calculateLength(this.id, value);
	                    }
	                }
	            } catch (e) {
	                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
	            }
	            return n;
	        };
	
	        /**
	         * Decode the field value from the specified buffer.
	         * @param {number} wireType Leading wire type
	         * @param {ByteBuffer} buffer ByteBuffer to decode from
	         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
	         * @return {*} Decoded value: array for packed repeated fields, [key, value] for
	         *             map fields, or an individual value otherwise.
	         * @throws {Error} If the field cannot be decoded
	         * @expose
	         */
	        FieldPrototype.decode = function(wireType, buffer, skipRepeated) {
	            var value, nBytes;
	
	            // We expect wireType to match the underlying type's wireType unless we see
	            // a packed repeated field, or unless this is a map field.
	            var wireTypeOK =
	                (!this.map && wireType == this.type.wireType) ||
	                (!skipRepeated && this.repeated && this.options["packed"] &&
	                 wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||
	                (this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM);
	            if (!wireTypeOK)
	                throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");
	
	            // Handle packed repeated fields.
	            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
	                if (!skipRepeated) {
	                    nBytes = buffer.readVarint32();
	                    nBytes = buffer.offset + nBytes; // Limit
	                    var values = [];
	                    while (buffer.offset < nBytes)
	                        values.push(this.decode(this.type.wireType, buffer, true));
	                    return values;
	                }
	                // Read the next value otherwise...
	            }
	
	            // Handle maps.
	            if (this.map) {
	                // Read one (key, value) submessage, and return [key, value]
	                var key = Element.defaultFieldValue(this.keyType);
	                value = Element.defaultFieldValue(this.type);
	
	                // Read the length
	                nBytes = buffer.readVarint32();
	                if (buffer.remaining() < nBytes)
	                    throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
	
	                // Get a sub-buffer of this key/value submessage
	                var msgbuf = buffer.clone();
	                msgbuf.limit = msgbuf.offset + nBytes;
	                buffer.offset += nBytes;
	
	                while (msgbuf.remaining() > 0) {
	                    var tag = msgbuf.readVarint32();
	                    wireType = tag & 0x07;
	                    var id = tag >>> 3;
	                    if (id === 1) {
	                        key = this.keyElement.decode(msgbuf, wireType, id);
	                    } else if (id === 2) {
	                        value = this.element.decode(msgbuf, wireType, id);
	                    } else {
	                        throw Error("Unexpected tag in map field key/value submessage");
	                    }
	                }
	
	                return [key, value];
	            }
	
	            // Handle singular and non-packed repeated field values.
	            return this.element.decode(buffer, wireType, this.id);
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Message.Field
	         * @expose
	         */
	        Reflect.Message.Field = Field;
	
	        /**
	         * Constructs a new Message ExtensionField.
	         * @exports ProtoBuf.Reflect.Message.ExtensionField
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Message} message Message reference
	         * @param {string} rule Rule, one of requried, optional, repeated
	         * @param {string} type Data type, e.g. int32
	         * @param {string} name Field name
	         * @param {number} id Unique field id
	         * @param {!Object.<string,*>=} options Options
	         * @constructor
	         * @extends ProtoBuf.Reflect.Message.Field
	         */
	        var ExtensionField = function(builder, message, rule, type, name, id, options) {
	            Field.call(this, builder, message, rule, /* keytype = */ null, type, name, id, options);
	
	            /**
	             * Extension reference.
	             * @type {!ProtoBuf.Reflect.Extension}
	             * @expose
	             */
	            this.extension;
	        };
	
	        // Extends Field
	        ExtensionField.prototype = Object.create(Field.prototype);
	
	        /**
	         * @alias ProtoBuf.Reflect.Message.ExtensionField
	         * @expose
	         */
	        Reflect.Message.ExtensionField = ExtensionField;
	
	        /**
	         * Constructs a new Message OneOf.
	         * @exports ProtoBuf.Reflect.Message.OneOf
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Message} message Message reference
	         * @param {string} name OneOf name
	         * @constructor
	         * @extends ProtoBuf.Reflect.T
	         */
	        var OneOf = function(builder, message, name) {
	            T.call(this, builder, message, name);
	
	            /**
	             * Enclosed fields.
	             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
	             * @expose
	             */
	            this.fields = [];
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Message.OneOf
	         * @expose
	         */
	        Reflect.Message.OneOf = OneOf;
	
	        /**
	         * Constructs a new Enum.
	         * @exports ProtoBuf.Reflect.Enum
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
	         * @param {string} name Enum name
	         * @param {Object.<string,*>=} options Enum options
	         * @param {string?} syntax The syntax level (e.g., proto3)
	         * @constructor
	         * @extends ProtoBuf.Reflect.Namespace
	         */
	        var Enum = function(builder, parent, name, options, syntax) {
	            Namespace.call(this, builder, parent, name, options, syntax);
	
	            /**
	             * @override
	             */
	            this.className = "Enum";
	
	            /**
	             * Runtime enum object.
	             * @type {Object.<string,number>|null}
	             * @expose
	             */
	            this.object = null;
	        };
	
	        /**
	         * Gets the string name of an enum value.
	         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
	         * @param {number} value Enum value
	         * @returns {?string} Name or `null` if not present
	         * @expose
	         */
	        Enum.getName = function(enm, value) {
	            var keys = Object.keys(enm);
	            for (var i=0, key; i<keys.length; ++i)
	                if (enm[key = keys[i]] === value)
	                    return key;
	            return null;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Enum.prototype
	         * @inner
	         */
	        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);
	
	        /**
	         * Builds this enum and returns the runtime counterpart.
	         * @param {boolean} rebuild Whether to rebuild or not, defaults to false
	         * @returns {!Object.<string,number>}
	         * @expose
	         */
	        EnumPrototype.build = function(rebuild) {
	            if (this.object && !rebuild)
	                return this.object;
	            var enm = new ProtoBuf.Builder.Enum(),
	                values = this.getChildren(Enum.Value);
	            for (var i=0, k=values.length; i<k; ++i)
	                enm[values[i]['name']] = values[i]['id'];
	            if (Object.defineProperty)
	                Object.defineProperty(enm, '$options', {
	                    "value": this.buildOpt(),
	                    "enumerable": false
	                });
	            return this.object = enm;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Enum
	         * @expose
	         */
	        Reflect.Enum = Enum;
	
	        /**
	         * Constructs a new Enum Value.
	         * @exports ProtoBuf.Reflect.Enum.Value
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
	         * @param {string} name Field name
	         * @param {number} id Unique field id
	         * @constructor
	         * @extends ProtoBuf.Reflect.T
	         */
	        var Value = function(builder, enm, name, id) {
	            T.call(this, builder, enm, name);
	
	            /**
	             * @override
	             */
	            this.className = "Enum.Value";
	
	            /**
	             * Unique enum value id.
	             * @type {number}
	             * @expose
	             */
	            this.id = id;
	        };
	
	        // Extends T
	        Value.prototype = Object.create(T.prototype);
	
	        /**
	         * @alias ProtoBuf.Reflect.Enum.Value
	         * @expose
	         */
	        Reflect.Enum.Value = Value;
	
	        /**
	         * An extension (field).
	         * @exports ProtoBuf.Reflect.Extension
	         * @constructor
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.T} parent Parent object
	         * @param {string} name Object name
	         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
	         */
	        var Extension = function(builder, parent, name, field) {
	            T.call(this, builder, parent, name);
	
	            /**
	             * Extended message field.
	             * @type {!ProtoBuf.Reflect.Message.Field}
	             * @expose
	             */
	            this.field = field;
	        };
	
	        // Extends T
	        Extension.prototype = Object.create(T.prototype);
	
	        /**
	         * @alias ProtoBuf.Reflect.Extension
	         * @expose
	         */
	        Reflect.Extension = Extension;
	
	        /**
	         * Constructs a new Service.
	         * @exports ProtoBuf.Reflect.Service
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Namespace} root Root
	         * @param {string} name Service name
	         * @param {Object.<string,*>=} options Options
	         * @constructor
	         * @extends ProtoBuf.Reflect.Namespace
	         */
	        var Service = function(builder, root, name, options) {
	            Namespace.call(this, builder, root, name, options);
	
	            /**
	             * @override
	             */
	            this.className = "Service";
	
	            /**
	             * Built runtime service class.
	             * @type {?function(new:ProtoBuf.Builder.Service)}
	             */
	            this.clazz = null;
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Service.prototype
	         * @inner
	         */
	        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);
	
	        /**
	         * Builds the service and returns the runtime counterpart, which is a fully functional class.
	         * @see ProtoBuf.Builder.Service
	         * @param {boolean=} rebuild Whether to rebuild or not
	         * @return {Function} Service class
	         * @throws {Error} If the message cannot be built
	         * @expose
	         */
	        ServicePrototype.build = function(rebuild) {
	            if (this.clazz && !rebuild)
	                return this.clazz;
	
	            // Create the runtime Service class in its own scope
	            return this.clazz = (function(ProtoBuf, T) {
	
	                /**
	                 * Constructs a new runtime Service.
	                 * @name ProtoBuf.Builder.Service
	                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
	                 * @class Barebone of all runtime services.
	                 * @constructor
	                 * @throws {Error} If the service cannot be created
	                 */
	                var Service = function(rpcImpl) {
	                    ProtoBuf.Builder.Service.call(this);
	
	                    /**
	                     * Service implementation.
	                     * @name ProtoBuf.Builder.Service#rpcImpl
	                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
	                     * @expose
	                     */
	                    this.rpcImpl = rpcImpl || function(name, msg, callback) {
	                        // This is what a user has to implement: A function receiving the method name, the actual message to
	                        // send (type checked) and the callback that's either provided with the error as its first
	                        // argument or null and the actual response message.
	                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
	                    };
	                };
	
	                /**
	                 * @alias ProtoBuf.Builder.Service.prototype
	                 * @inner
	                 */
	                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);
	
	                /**
	                 * Asynchronously performs an RPC call using the given RPC implementation.
	                 * @name ProtoBuf.Builder.Service.[Method]
	                 * @function
	                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
	                 * @param {ProtoBuf.Builder.Message} req Request
	                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
	                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
	                 * @abstract
	                 */
	
	                /**
	                 * Asynchronously performs an RPC call using the instance's RPC implementation.
	                 * @name ProtoBuf.Builder.Service#[Method]
	                 * @function
	                 * @param {ProtoBuf.Builder.Message} req Request
	                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
	                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
	                 * @abstract
	                 */
	
	                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
	                for (var i=0; i<rpc.length; i++) {
	                    (function(method) {
	
	                        // service#Method(message, callback)
	                        ServicePrototype[method.name] = function(req, callback) {
	                            try {
	                                try {
	                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
	                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
	                                } catch (err) {
	                                    if (!(err instanceof TypeError))
	                                        throw err;
	                                }
	                                if (req === null || typeof req !== 'object')
	                                    throw Error("Illegal arguments");
	                                if (!(req instanceof method.resolvedRequestType.clazz))
	                                    req = new method.resolvedRequestType.clazz(req);
	                                this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
	                                    if (err) {
	                                        callback(err);
	                                        return;
	                                    }
	                                    // Coalesce to empty string when service response has empty content
	                                    if (res === null)
	                                        res = ''
	                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
	                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
	                                        callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
	                                        return;
	                                    }
	                                    callback(null, res);
	                                });
	                            } catch (err) {
	                                setTimeout(callback.bind(this, err), 0);
	                            }
	                        };
	
	                        // Service.Method(rpcImpl, message, callback)
	                        Service[method.name] = function(rpcImpl, req, callback) {
	                            new Service(rpcImpl)[method.name](req, callback);
	                        };
	
	                        if (Object.defineProperty)
	                            Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
	                            Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
	                    })(rpc[i]);
	                }
	
	                // Properties
	
	                /**
	                 * Service options.
	                 * @name ProtoBuf.Builder.Service.$options
	                 * @type {Object.<string,*>}
	                 * @expose
	                 */
	                var $optionsS; // cc needs this
	
	                /**
	                 * Service options.
	                 * @name ProtoBuf.Builder.Service#$options
	                 * @type {Object.<string,*>}
	                 * @expose
	                 */
	                var $options;
	
	                /**
	                 * Reflection type.
	                 * @name ProtoBuf.Builder.Service.$type
	                 * @type {!ProtoBuf.Reflect.Service}
	                 * @expose
	                 */
	                var $typeS;
	
	                /**
	                 * Reflection type.
	                 * @name ProtoBuf.Builder.Service#$type
	                 * @type {!ProtoBuf.Reflect.Service}
	                 * @expose
	                 */
	                var $type;
	
	                if (Object.defineProperty)
	                    Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
	                    Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }),
	                    Object.defineProperty(Service, "$type", { "value": T }),
	                    Object.defineProperty(ServicePrototype, "$type", { "value": T });
	
	                return Service;
	
	            })(ProtoBuf, this);
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Service
	         * @expose
	         */
	        Reflect.Service = Service;
	
	        /**
	         * Abstract service method.
	         * @exports ProtoBuf.Reflect.Service.Method
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Service} svc Service
	         * @param {string} name Method name
	         * @param {Object.<string,*>=} options Options
	         * @constructor
	         * @extends ProtoBuf.Reflect.T
	         */
	        var Method = function(builder, svc, name, options) {
	            T.call(this, builder, svc, name);
	
	            /**
	             * @override
	             */
	            this.className = "Service.Method";
	
	            /**
	             * Options.
	             * @type {Object.<string, *>}
	             * @expose
	             */
	            this.options = options || {};
	        };
	
	        /**
	         * @alias ProtoBuf.Reflect.Service.Method.prototype
	         * @inner
	         */
	        var MethodPrototype = Method.prototype = Object.create(T.prototype);
	
	        /**
	         * Builds the method's '$options' property.
	         * @name ProtoBuf.Reflect.Service.Method#buildOpt
	         * @function
	         * @return {Object.<string,*>}
	         */
	        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;
	
	        /**
	         * @alias ProtoBuf.Reflect.Service.Method
	         * @expose
	         */
	        Reflect.Service.Method = Method;
	
	        /**
	         * RPC service method.
	         * @exports ProtoBuf.Reflect.Service.RPCMethod
	         * @param {!ProtoBuf.Builder} builder Builder reference
	         * @param {!ProtoBuf.Reflect.Service} svc Service
	         * @param {string} name Method name
	         * @param {string} request Request message name
	         * @param {string} response Response message name
	         * @param {boolean} request_stream Whether requests are streamed
	         * @param {boolean} response_stream Whether responses are streamed
	         * @param {Object.<string,*>=} options Options
	         * @constructor
	         * @extends ProtoBuf.Reflect.Service.Method
	         */
	        var RPCMethod = function(builder, svc, name, request, response, request_stream, response_stream, options) {
	            Method.call(this, builder, svc, name, options);
	
	            /**
	             * @override
	             */
	            this.className = "Service.RPCMethod";
	
	            /**
	             * Request message name.
	             * @type {string}
	             * @expose
	             */
	            this.requestName = request;
	
	            /**
	             * Response message name.
	             * @type {string}
	             * @expose
	             */
	            this.responseName = response;
	
	            /**
	             * Whether requests are streamed
	             * @type {bool}
	             * @expose
	             */
	            this.requestStream = request_stream;
	
	            /**
	             * Whether responses are streamed
	             * @type {bool}
	             * @expose
	             */
	            this.responseStream = response_stream;
	
	            /**
	             * Resolved request message type.
	             * @type {ProtoBuf.Reflect.Message}
	             * @expose
	             */
	            this.resolvedRequestType = null;
	
	            /**
	             * Resolved response message type.
	             * @type {ProtoBuf.Reflect.Message}
	             * @expose
	             */
	            this.resolvedResponseType = null;
	        };
	
	        // Extends Method
	        RPCMethod.prototype = Object.create(Method.prototype);
	
	        /**
	         * @alias ProtoBuf.Reflect.Service.RPCMethod
	         * @expose
	         */
	        Reflect.Service.RPCMethod = RPCMethod;
	
	        return Reflect;
	
	    })(ProtoBuf);
	
	    /**
	     * @alias ProtoBuf.Builder
	     * @expose
	     */
	    ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
	        "use strict";
	
	        /**
	         * Constructs a new Builder.
	         * @exports ProtoBuf.Builder
	         * @class Provides the functionality to build protocol messages.
	         * @param {Object.<string,*>=} options Options
	         * @constructor
	         */
	        var Builder = function(options) {
	
	            /**
	             * Namespace.
	             * @type {ProtoBuf.Reflect.Namespace}
	             * @expose
	             */
	            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace
	
	            /**
	             * Namespace pointer.
	             * @type {ProtoBuf.Reflect.T}
	             * @expose
	             */
	            this.ptr = this.ns;
	
	            /**
	             * Resolved flag.
	             * @type {boolean}
	             * @expose
	             */
	            this.resolved = false;
	
	            /**
	             * The current building result.
	             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
	             * @expose
	             */
	            this.result = null;
	
	            /**
	             * Imported files.
	             * @type {Array.<string>}
	             * @expose
	             */
	            this.files = {};
	
	            /**
	             * Import root override.
	             * @type {?string}
	             * @expose
	             */
	            this.importRoot = null;
	
	            /**
	             * Options.
	             * @type {!Object.<string, *>}
	             * @expose
	             */
	            this.options = options || {};
	        };
	
	        /**
	         * @alias ProtoBuf.Builder.prototype
	         * @inner
	         */
	        var BuilderPrototype = Builder.prototype;
	
	        // ----- Definition tests -----
	
	        /**
	         * Tests if a definition most likely describes a message.
	         * @param {!Object} def
	         * @returns {boolean}
	         * @expose
	         */
	        Builder.isMessage = function(def) {
	            // Messages require a string name
	            if (typeof def["name"] !== 'string')
	                return false;
	            // Messages do not contain values (enum) or rpc methods (service)
	            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')
	                return false;
	            return true;
	        };
	
	        /**
	         * Tests if a definition most likely describes a message field.
	         * @param {!Object} def
	         * @returns {boolean}
	         * @expose
	         */
	        Builder.isMessageField = function(def) {
	            // Message fields require a string rule, name and type and an id
	            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
	                return false;
	            return true;
	        };
	
	        /**
	         * Tests if a definition most likely describes an enum.
	         * @param {!Object} def
	         * @returns {boolean}
	         * @expose
	         */
	        Builder.isEnum = function(def) {
	            // Enums require a string name
	            if (typeof def["name"] !== 'string')
	                return false;
	            // Enums require at least one value
	            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0)
	                return false;
	            return true;
	        };
	
	        /**
	         * Tests if a definition most likely describes a service.
	         * @param {!Object} def
	         * @returns {boolean}
	         * @expose
	         */
	        Builder.isService = function(def) {
	            // Services require a string name and an rpc object
	            if (typeof def["name"] !== 'string' || typeof def["rpc"] !== 'object' || !def["rpc"])
	                return false;
	            return true;
	        };
	
	        /**
	         * Tests if a definition most likely describes an extended message
	         * @param {!Object} def
	         * @returns {boolean}
	         * @expose
	         */
	        Builder.isExtend = function(def) {
	            // Extends rquire a string ref
	            if (typeof def["ref"] !== 'string')
	                return false;
	            return true;
	        };
	
	        // ----- Building -----
	
	        /**
	         * Resets the pointer to the root namespace.
	         * @returns {!ProtoBuf.Builder} this
	         * @expose
	         */
	        BuilderPrototype.reset = function() {
	            this.ptr = this.ns;
	            return this;
	        };
	
	        /**
	         * Defines a namespace on top of the current pointer position and places the pointer on it.
	         * @param {string} namespace
	         * @return {!ProtoBuf.Builder} this
	         * @expose
	         */
	        BuilderPrototype.define = function(namespace) {
	            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace))
	                throw Error("illegal namespace: "+namespace);
	            namespace.split(".").forEach(function(part) {
	                var ns = this.ptr.getChild(part);
	                if (ns === null) // Keep existing
	                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
	                this.ptr = ns;
	            }, this);
	            return this;
	        };
	
	        /**
	         * Creates the specified definitions at the current pointer position.
	         * @param {!Array.<!Object>} defs Messages, enums or services to create
	         * @returns {!ProtoBuf.Builder} this
	         * @throws {Error} If a message definition is invalid
	         * @expose
	         */
	        BuilderPrototype.create = function(defs) {
	            if (!defs)
	                return this; // Nothing to create
	            if (!Array.isArray(defs))
	                defs = [defs];
	            else {
	                if (defs.length === 0)
	                    return this;
	                defs = defs.slice();
	            }
	
	            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
	            var stack = [defs];
	            while (stack.length > 0) {
	                defs = stack.pop();
	
	                if (!Array.isArray(defs)) // Stack always contains entire namespaces
	                    throw Error("not a valid namespace: "+JSON.stringify(defs));
	
	                while (defs.length > 0) {
	                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services
	
	                    if (Builder.isMessage(def)) {
	                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);
	
	                        // Create OneOfs
	                        var oneofs = {};
	                        if (def["oneofs"])
	                            Object.keys(def["oneofs"]).forEach(function(name) {
	                                obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
	                            }, this);
	
	                        // Create fields
	                        if (def["fields"])
	                            def["fields"].forEach(function(fld) {
	                                if (obj.getChild(fld["id"]|0) !== null)
	                                    throw Error("duplicate or invalid field id in "+obj.name+": "+fld['id']);
	                                if (fld["options"] && typeof fld["options"] !== 'object')
	                                    throw Error("illegal field options in "+obj.name+"#"+fld["name"]);
	                                var oneof = null;
	                                if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]]))
	                                    throw Error("illegal oneof in "+obj.name+"#"+fld["name"]+": "+fld["oneof"]);
	                                fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
	                                if (oneof)
	                                    oneof.fields.push(fld);
	                                obj.addChild(fld);
	                            }, this);
	
	                        // Push children to stack
	                        var subObj = [];
	                        if (def["enums"])
	                            def["enums"].forEach(function(enm) {
	                                subObj.push(enm);
	                            });
	                        if (def["messages"])
	                            def["messages"].forEach(function(msg) {
	                                subObj.push(msg);
	                            });
	                        if (def["services"])
	                            def["services"].forEach(function(svc) {
	                                subObj.push(svc);
	                            });
	
	                        // Set extension ranges
	                        if (def["extensions"]) {
	                            if (typeof def["extensions"][0] === 'number') // pre 5.0.1
	                                obj.extensions = [ def["extensions"] ];
	                            else
	                                obj.extensions = def["extensions"];
	                        }
	
	                        // Create on top of current namespace
	                        this.ptr.addChild(obj);
	                        if (subObj.length > 0) {
	                            stack.push(defs); // Push the current level back
	                            defs = subObj; // Continue processing sub level
	                            subObj = null;
	                            this.ptr = obj; // And move the pointer to this namespace
	                            obj = null;
	                            continue;
	                        }
	                        subObj = null;
	
	                    } else if (Builder.isEnum(def)) {
	
	                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
	                        def["values"].forEach(function(val) {
	                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
	                        }, this);
	                        this.ptr.addChild(obj);
	
	                    } else if (Builder.isService(def)) {
	
	                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
	                        Object.keys(def["rpc"]).forEach(function(name) {
	                            var mtd = def["rpc"][name];
	                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
	                        }, this);
	                        this.ptr.addChild(obj);
	
	                    } else if (Builder.isExtend(def)) {
	
	                        obj = this.ptr.resolve(def["ref"], true);
	                        if (obj) {
	                            def["fields"].forEach(function(fld) {
	                                if (obj.getChild(fld['id']|0) !== null)
	                                    throw Error("duplicate extended field id in "+obj.name+": "+fld['id']);
	                                // Check if field id is allowed to be extended
	                                if (obj.extensions) {
	                                    var valid = false;
	                                    obj.extensions.forEach(function(range) {
	                                        if (fld["id"] >= range[0] && fld["id"] <= range[1])
	                                            valid = true;
	                                    });
	                                    if (!valid)
	                                        throw Error("illegal extended field id in "+obj.name+": "+fld['id']+" (not within valid ranges)");
	                                }
	                                // Convert extension field names to camel case notation if the override is set
	                                var name = fld["name"];
	                                if (this.options['convertFieldsToCamelCase'])
	                                    name = ProtoBuf.Util.toCamelCase(name);
	                                // see #161: Extensions use their fully qualified name as their runtime key and...
	                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn()+'.'+name, fld["id"], fld["options"]);
	                                // ...are added on top of the current namespace as an extension which is used for
	                                // resolving their type later on (the extension always keeps the original name to
	                                // prevent naming collisions)
	                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
	                                field.extension = ext;
	                                this.ptr.addChild(ext);
	                                obj.addChild(field);
	                            }, this);
	
	                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
	                            throw Error("extended message "+def["ref"]+" is not defined");
	
	                    } else
	                        throw Error("not a valid definition: "+JSON.stringify(def));
	
	                    def = null;
	                    obj = null;
	                }
	                // Break goes here
	                defs = null;
	                this.ptr = this.ptr.parent; // Namespace done, continue at parent
	            }
	            this.resolved = false; // Require re-resolve
	            this.result = null; // Require re-build
	            return this;
	        };
	
	        /**
	         * Propagates syntax to all children.
	         * @param {!Object} parent
	         * @inner
	         */
	        function propagateSyntax(parent) {
	            if (parent['messages']) {
	                parent['messages'].forEach(function(child) {
	                    child["syntax"] = parent["syntax"];
	                    propagateSyntax(child);
	                });
	            }
	            if (parent['enums']) {
	                parent['enums'].forEach(function(child) {
	                    child["syntax"] = parent["syntax"];
	                });
	            }
	        }
	
	        /**
	         * Imports another definition into this builder.
	         * @param {Object.<string,*>} json Parsed import
	         * @param {(string|{root: string, file: string})=} filename Imported file name
	         * @returns {!ProtoBuf.Builder} this
	         * @throws {Error} If the definition or file cannot be imported
	         * @expose
	         */
	        BuilderPrototype["import"] = function(json, filename) {
	            var delim = '/';
	
	            // Make sure to skip duplicate imports
	
	            if (typeof filename === 'string') {
	
	                if (ProtoBuf.Util.IS_NODE)
	                    filename = __webpack_require__(222)['resolve'](filename);
	                if (this.files[filename] === true)
	                    return this.reset();
	                this.files[filename] = true;
	
	            } else if (typeof filename === 'object') { // Object with root, file.
	
	                var root = filename.root;
	                if (ProtoBuf.Util.IS_NODE)
	                    root = __webpack_require__(222)['resolve'](root);
	                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0)
	                    delim = '\\';
	                var fname = root + delim + filename.file;
	                if (this.files[fname] === true)
	                    return this.reset();
	                this.files[fname] = true;
	            }
	
	            // Import imports
	
	            if (json['imports'] && json['imports'].length > 0) {
	                var importRoot,
	                    resetRoot = false;
	
	                if (typeof filename === 'object') { // If an import root is specified, override
	
	                    this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards
	                    importRoot = this.importRoot;
	                    filename = filename["file"];
	                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0)
	                        delim = '\\';
	
	                } else if (typeof filename === 'string') {
	
	                    if (this.importRoot) // If import root is overridden, use it
	                        importRoot = this.importRoot;
	                    else { // Otherwise compute from filename
	                        if (filename.indexOf("/") >= 0) { // Unix
	                            importRoot = filename.replace(/\/[^\/]*$/, "");
	                            if (/* /file.proto */ importRoot === "")
	                                importRoot = "/";
	                        } else if (filename.indexOf("\\") >= 0) { // Windows
	                            importRoot = filename.replace(/\\[^\\]*$/, "");
	                            delim = '\\';
	                        } else
	                            importRoot = ".";
	                    }
	
	                } else
	                    importRoot = null;
	
	                for (var i=0; i<json['imports'].length; i++) {
	                    if (typeof json['imports'][i] === 'string') { // Import file
	                        if (!importRoot)
	                            throw Error("cannot determine import root");
	                        var importFilename = json['imports'][i];
	                        if (importFilename === "google/protobuf/descriptor.proto")
	                            continue; // Not needed and therefore not used
	                        importFilename = importRoot + delim + importFilename;
	                        if (this.files[importFilename] === true)
	                            continue; // Already imported
	                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)       // If this is a light build
	                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
	                        var contents = ProtoBuf.Util.fetch(importFilename);
	                        if (contents === null)
	                            throw Error("failed to import '"+importFilename+"' in '"+filename+"': file not found");
	                        if (/\.json$/i.test(importFilename)) // Always possible
	                            this["import"](JSON.parse(contents+""), importFilename); // May throw
	                        else
	                            this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
	                    } else // Import structure
	                        if (!filename)
	                            this["import"](json['imports'][i]);
	                        else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
	                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
	                        else // Without extension: Append _importN to make it unique
	                            this["import"](json['imports'][i], filename+"_import"+i);
	                }
	                if (resetRoot) // Reset import root override when all imports are done
	                    this.importRoot = null;
	            }
	
	            // Import structures
	
	            if (json['package'])
	                this.define(json['package']);
	            if (json['syntax'])
	                propagateSyntax(json);
	            var base = this.ptr;
	            if (json['options'])
	                Object.keys(json['options']).forEach(function(key) {
	                    base.options[key] = json['options'][key];
	                });
	            if (json['messages'])
	                this.create(json['messages']),
	                this.ptr = base;
	            if (json['enums'])
	                this.create(json['enums']),
	                this.ptr = base;
	            if (json['services'])
	                this.create(json['services']),
	                this.ptr = base;
	            if (json['extends'])
	                this.create(json['extends']);
	
	            return this.reset();
	        };
	
	        /**
	         * Resolves all namespace objects.
	         * @throws {Error} If a type cannot be resolved
	         * @returns {!ProtoBuf.Builder} this
	         * @expose
	         */
	        BuilderPrototype.resolveAll = function() {
	            // Resolve all reflected objects
	            var res;
	            if (this.ptr == null || typeof this.ptr.type === 'object')
	                return this; // Done (already resolved)
	
	            if (this.ptr instanceof Reflect.Namespace) { // Resolve children
	
	                this.ptr.children.forEach(function(child) {
	                    this.ptr = child;
	                    this.resolveAll();
	                }, this);
	
	            } else if (this.ptr instanceof Reflect.Message.Field) { // Resolve type
	
	                if (!Lang.TYPE.test(this.ptr.type)) {
	                    if (!Lang.TYPEREF.test(this.ptr.type))
	                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
	                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
	                    if (!res)
	                        throw Error("unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
	                    this.ptr.resolvedType = res;
	                    if (res instanceof Reflect.Enum) {
	                        this.ptr.type = ProtoBuf.TYPES["enum"];
	                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3')
	                            throw Error("proto3 message cannot reference proto2 enum");
	                    }
	                    else if (res instanceof Reflect.Message)
	                        this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
	                    else
	                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
	                } else
	                    this.ptr.type = ProtoBuf.TYPES[this.ptr.type];
	
	                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
	                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
	                if (this.ptr.map) {
	                    if (!Lang.TYPE.test(this.ptr.keyType))
	                        throw Error("illegal key type for map field in "+this.ptr.toString(true)+": "+this.ptr.keyType);
	                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
	                }
	
	            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
	
	                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
	                    res = this.ptr.parent.resolve(this.ptr.requestName, true);
	                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))
	                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
	                    this.ptr.resolvedRequestType = res;
	                    res = this.ptr.parent.resolve(this.ptr.responseName, true);
	                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))
	                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
	                    this.ptr.resolvedResponseType = res;
	                } else // Should not happen as nothing else is implemented
	                    throw Error("illegal service type in "+this.ptr.toString(true));
	
	            } else if (
	                !(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
	                !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
	                !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
	            )
	                throw Error("illegal object in namespace: "+typeof(this.ptr)+": "+this.ptr);
	
	            return this.reset();
	        };
	
	        /**
	         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
	         * return the built package.
	         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
	         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
	         * @throws {Error} If a type could not be resolved
	         * @expose
	         */
	        BuilderPrototype.build = function(path) {
	            this.reset();
	            if (!this.resolved)
	                this.resolveAll(),
	                this.resolved = true,
	                this.result = null; // Require re-build
	            if (this.result === null) // (Re-)Build
	                this.result = this.ns.build();
	            if (!path)
	                return this.result;
	            var part = typeof path === 'string' ? path.split(".") : path,
	                ptr = this.result; // Build namespace pointer (no hasChild etc.)
	            for (var i=0; i<part.length; i++)
	                if (ptr[part[i]])
	                    ptr = ptr[part[i]];
	                else {
	                    ptr = null;
	                    break;
	                }
	            return ptr;
	        };
	
	        /**
	         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
	         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
	         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
	         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
	         */
	        BuilderPrototype.lookup = function(path, excludeNonNamespace) {
	            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
	        };
	
	        /**
	         * Returns a string representation of this object.
	         * @return {string} String representation as of "Builder"
	         * @expose
	         */
	        BuilderPrototype.toString = function() {
	            return "Builder";
	        };
	
	        // ----- Base classes -----
	        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.
	
	        /**
	         * @alias ProtoBuf.Builder.Message
	         */
	        Builder.Message = function() {};
	
	        /**
	         * @alias ProtoBuf.Builder.Enum
	         */
	        Builder.Enum = function() {};
	
	        /**
	         * @alias ProtoBuf.Builder.Message
	         */
	        Builder.Service = function() {};
	
	        return Builder;
	
	    })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);
	
	    /**
	     * @alias ProtoBuf.Map
	     * @expose
	     */
	    ProtoBuf.Map = (function(ProtoBuf, Reflect) {
	        "use strict";
	
	        /**
	         * Constructs a new Map. A Map is a container that is used to implement map
	         * fields on message objects. It closely follows the ES6 Map API; however,
	         * it is distinct because we do not want to depend on external polyfills or
	         * on ES6 itself.
	         *
	         * @exports ProtoBuf.Map
	         * @param {!ProtoBuf.Reflect.Field} field Map field
	         * @param {Object.<string,*>=} contents Initial contents
	         * @constructor
	         */
	        var Map = function(field, contents) {
	            if (!field.map)
	                throw Error("field is not a map");
	
	            /**
	             * The field corresponding to this map.
	             * @type {!ProtoBuf.Reflect.Field}
	             */
	            this.field = field;
	
	            /**
	             * Element instance corresponding to key type.
	             * @type {!ProtoBuf.Reflect.Element}
	             */
	            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);
	
	            /**
	             * Element instance corresponding to value type.
	             * @type {!ProtoBuf.Reflect.Element}
	             */
	            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);
	
	            /**
	             * Internal map: stores mapping of (string form of key) -> (key, value)
	             * pair.
	             *
	             * We provide map semantics for arbitrary key types, but we build on top
	             * of an Object, which has only string keys. In order to avoid the need
	             * to convert a string key back to its native type in many situations,
	             * we store the native key value alongside the value. Thus, we only need
	             * a one-way mapping from a key type to its string form that guarantees
	             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
	             * === K2).
	             *
	             * @type {!Object<string, {key: *, value: *}>}
	             */
	            this.map = {};
	
	            /**
	             * Returns the number of elements in the map.
	             */
	            Object.defineProperty(this, "size", {
	                get: function() { return Object.keys(this.map).length; }
	            });
	
	            // Fill initial contents from a raw object.
	            if (contents) {
	                var keys = Object.keys(contents);
	                for (var i = 0; i < keys.length; i++) {
	                    var key = this.keyElem.valueFromString(keys[i]);
	                    var val = this.valueElem.verifyValue(contents[keys[i]]);
	                    this.map[this.keyElem.valueToString(key)] =
	                        { key: key, value: val };
	                }
	            }
	        };
	
	        var MapPrototype = Map.prototype;
	
	        /**
	         * Helper: return an iterator over an array.
	         * @param {!Array<*>} arr the array
	         * @returns {!Object} an iterator
	         * @inner
	         */
	        function arrayIterator(arr) {
	            var idx = 0;
	            return {
	                next: function() {
	                    if (idx < arr.length)
	                        return { done: false, value: arr[idx++] };
	                    return { done: true };
	                }
	            }
	        }
	
	        /**
	         * Clears the map.
	         */
	        MapPrototype.clear = function() {
	            this.map = {};
	        };
	
	        /**
	         * Deletes a particular key from the map.
	         * @returns {boolean} Whether any entry with this key was deleted.
	         */
	        MapPrototype["delete"] = function(key) {
	            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
	            var hadKey = keyValue in this.map;
	            delete this.map[keyValue];
	            return hadKey;
	        };
	
	        /**
	         * Returns an iterator over [key, value] pairs in the map.
	         * @returns {Object} The iterator
	         */
	        MapPrototype.entries = function() {
	            var entries = [];
	            var strKeys = Object.keys(this.map);
	            for (var i = 0, entry; i < strKeys.length; i++)
	                entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);
	            return arrayIterator(entries);
	        };
	
	        /**
	         * Returns an iterator over keys in the map.
	         * @returns {Object} The iterator
	         */
	        MapPrototype.keys = function() {
	            var keys = [];
	            var strKeys = Object.keys(this.map);
	            for (var i = 0; i < strKeys.length; i++)
	                keys.push(this.map[strKeys[i]].key);
	            return arrayIterator(keys);
	        };
	
	        /**
	         * Returns an iterator over values in the map.
	         * @returns {!Object} The iterator
	         */
	        MapPrototype.values = function() {
	            var values = [];
	            var strKeys = Object.keys(this.map);
	            for (var i = 0; i < strKeys.length; i++)
	                values.push(this.map[strKeys[i]].value);
	            return arrayIterator(values);
	        };
	
	        /**
	         * Iterates over entries in the map, calling a function on each.
	         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
	         * @param {Object=} thisArg The `this` value for the callback
	         */
	        MapPrototype.forEach = function(cb, thisArg) {
	            var strKeys = Object.keys(this.map);
	            for (var i = 0, entry; i < strKeys.length; i++)
	                cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);
	        };
	
	        /**
	         * Sets a key in the map to the given value.
	         * @param {*} key The key
	         * @param {*} value The value
	         * @returns {!ProtoBuf.Map} The map instance
	         */
	        MapPrototype.set = function(key, value) {
	            var keyValue = this.keyElem.verifyValue(key);
	            var valValue = this.valueElem.verifyValue(value);
	            this.map[this.keyElem.valueToString(keyValue)] =
	                { key: keyValue, value: valValue };
	            return this;
	        };
	
	        /**
	         * Gets the value corresponding to a key in the map.
	         * @param {*} key The key
	         * @returns {*|undefined} The value, or `undefined` if key not present
	         */
	        MapPrototype.get = function(key) {
	            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
	            if (!(keyValue in this.map))
	                return undefined;
	            return this.map[keyValue].value;
	        };
	
	        /**
	         * Determines whether the given key is present in the map.
	         * @param {*} key The key
	         * @returns {boolean} `true` if the key is present
	         */
	        MapPrototype.has = function(key) {
	            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
	            return (keyValue in this.map);
	        };
	
	        return Map;
	    })(ProtoBuf, ProtoBuf.Reflect);
	
	
	    /**
	     * Loads a .proto string and returns the Builder.
	     * @param {string} proto .proto file contents
	     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
	     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
	     * @return {ProtoBuf.Builder} Builder to create new messages
	     * @throws {Error} If the definition cannot be parsed or built
	     * @expose
	     */
	    ProtoBuf.loadProto = function(proto, builder, filename) {
	        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
	            filename = builder,
	            builder = undefined;
	        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
	    };
	
	    /**
	     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
	     * @function
	     * @param {string} proto .proto file contents
	     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
	     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
	     * @return {ProtoBuf.Builder} Builder to create new messages
	     * @throws {Error} If the definition cannot be parsed or built
	     * @expose
	     */
	    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy
	
	    /**
	     * Loads a .proto file and returns the Builder.
	     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
	     *  an overridden 'root' path for all imported files.
	     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
	     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
	     *  file will be read synchronously and this function will return the Builder.
	     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
	     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
	     *   request has failed), else undefined
	     * @expose
	     */
	    ProtoBuf.loadProtoFile = function(filename, callback, builder) {
	        if (callback && typeof callback === 'object')
	            builder = callback,
	            callback = null;
	        else if (!callback || typeof callback !== 'function')
	            callback = null;
	        if (callback)
	            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
	                if (contents === null) {
	                    callback(Error("Failed to fetch file"));
	                    return;
	                }
	                try {
	                    callback(null, ProtoBuf.loadProto(contents, builder, filename));
	                } catch (e) {
	                    callback(e);
	                }
	            });
	        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
	        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
	    };
	
	    /**
	     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
	     * @function
	     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
	     *  an overridden 'root' path for all imported files.
	     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
	     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
	     *  file will be read synchronously and this function will return the Builder.
	     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
	     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
	     *   request has failed), else undefined
	     * @expose
	     */
	    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy
	
	
	    /**
	     * Constructs a new empty Builder.
	     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
	     * @return {!ProtoBuf.Builder} Builder
	     * @expose
	     */
	    ProtoBuf.newBuilder = function(options) {
	        options = options || {};
	        if (typeof options['convertFieldsToCamelCase'] === 'undefined')
	            options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
	        if (typeof options['populateAccessors'] === 'undefined')
	            options['populateAccessors'] = ProtoBuf.populateAccessors;
	        return new ProtoBuf.Builder(options);
	    };
	
	    /**
	     * Loads a .json definition and returns the Builder.
	     * @param {!*|string} json JSON definition
	     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
	     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
	     * @return {ProtoBuf.Builder} Builder to create new messages
	     * @throws {Error} If the definition cannot be parsed or built
	     * @expose
	     */
	    ProtoBuf.loadJson = function(json, builder, filename) {
	        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
	            filename = builder,
	            builder = null;
	        if (!builder || typeof builder !== 'object')
	            builder = ProtoBuf.newBuilder();
	        if (typeof json === 'string')
	            json = JSON.parse(json);
	        builder["import"](json, filename);
	        builder.resolveAll();
	        return builder;
	    };
	
	    /**
	     * Loads a .json file and returns the Builder.
	     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
	     *  an overridden 'root' path for all imported files.
	     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
	     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
	     *  file will be read synchronously and this function will return the Builder.
	     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
	     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
	     *   request has failed), else undefined
	     * @expose
	     */
	    ProtoBuf.loadJsonFile = function(filename, callback, builder) {
	        if (callback && typeof callback === 'object')
	            builder = callback,
	            callback = null;
	        else if (!callback || typeof callback !== 'function')
	            callback = null;
	        if (callback)
	            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
	                if (contents === null) {
	                    callback(Error("Failed to fetch file"));
	                    return;
	                }
	                try {
	                    callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
	                } catch (e) {
	                    callback(e);
	                }
	            });
	        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
	        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
	    };
	
	    return ProtoBuf;
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(175)(module)))

/***/ },
/* 218 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*
	 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>
	
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	
	 http://www.apache.org/licenses/LICENSE-2.0
	
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
	 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
	 * Released under the Apache License, Version 2.0
	 * see: https://github.com/dcodeIO/bytebuffer.js for details
	 */
	(function(global, factory) {
	
	    /* AMD */ if ("function" === 'function' && __webpack_require__(218)["amd"])
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(220)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    /* CommonJS */ else if ("function" === 'function' && typeof module === "object" && module && module["exports"])
	        module['exports'] = (function() {
	            var Long; try { Long = __webpack_require__(220); } catch (e) {}
	            return factory(Long);
	        })();
	    /* Global */ else
	        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);
	
	})(this, function(Long) {
	    "use strict";
	
	    /**
	     * Constructs a new ByteBuffer.
	     * @class The swiss army knife for binary data in JavaScript.
	     * @exports ByteBuffer
	     * @constructor
	     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @expose
	     */
	    var ByteBuffer = function(capacity, littleEndian, noAssert) {
	        if (typeof capacity === 'undefined')
	            capacity = ByteBuffer.DEFAULT_CAPACITY;
	        if (typeof littleEndian === 'undefined')
	            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
	        if (typeof noAssert === 'undefined')
	            noAssert = ByteBuffer.DEFAULT_NOASSERT;
	        if (!noAssert) {
	            capacity = capacity | 0;
	            if (capacity < 0)
	                throw RangeError("Illegal capacity");
	            littleEndian = !!littleEndian;
	            noAssert = !!noAssert;
	        }
	
	        /**
	         * Backing ArrayBuffer.
	         * @type {!ArrayBuffer}
	         * @expose
	         */
	        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);
	
	        /**
	         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
	         * @type {?Uint8Array}
	         * @expose
	         */
	        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);
	
	        /**
	         * Absolute read/write offset.
	         * @type {number}
	         * @expose
	         * @see ByteBuffer#flip
	         * @see ByteBuffer#clear
	         */
	        this.offset = 0;
	
	        /**
	         * Marked offset.
	         * @type {number}
	         * @expose
	         * @see ByteBuffer#mark
	         * @see ByteBuffer#reset
	         */
	        this.markedOffset = -1;
	
	        /**
	         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
	         * @type {number}
	         * @expose
	         * @see ByteBuffer#flip
	         * @see ByteBuffer#clear
	         */
	        this.limit = capacity;
	
	        /**
	         * Whether to use little endian byte order, defaults to `false` for big endian.
	         * @type {boolean}
	         * @expose
	         */
	        this.littleEndian = littleEndian;
	
	        /**
	         * Whether to skip assertions of offsets and values, defaults to `false`.
	         * @type {boolean}
	         * @expose
	         */
	        this.noAssert = noAssert;
	    };
	
	    /**
	     * ByteBuffer version.
	     * @type {string}
	     * @const
	     * @expose
	     */
	    ByteBuffer.VERSION = "5.0.1";
	
	    /**
	     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
	     * @type {boolean}
	     * @const
	     * @expose
	     */
	    ByteBuffer.LITTLE_ENDIAN = true;
	
	    /**
	     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
	     * @type {boolean}
	     * @const
	     * @expose
	     */
	    ByteBuffer.BIG_ENDIAN = false;
	
	    /**
	     * Default initial capacity of `16`.
	     * @type {number}
	     * @expose
	     */
	    ByteBuffer.DEFAULT_CAPACITY = 16;
	
	    /**
	     * Default endianess of `false` for big endian.
	     * @type {boolean}
	     * @expose
	     */
	    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;
	
	    /**
	     * Default no assertions flag of `false`.
	     * @type {boolean}
	     * @expose
	     */
	    ByteBuffer.DEFAULT_NOASSERT = false;
	
	    /**
	     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
	     *  and int64 support is not available.
	     * @type {?Long}
	     * @const
	     * @see https://github.com/dcodeIO/long.js
	     * @expose
	     */
	    ByteBuffer.Long = Long || null;
	
	    /**
	     * @alias ByteBuffer.prototype
	     * @inner
	     */
	    var ByteBufferPrototype = ByteBuffer.prototype;
	
	    /**
	     * An indicator used to reliably determine if an object is a ByteBuffer or not.
	     * @type {boolean}
	     * @const
	     * @expose
	     * @private
	     */
	    ByteBufferPrototype.__isByteBuffer__;
	
	    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
	        value: true,
	        enumerable: false,
	        configurable: false
	    });
	
	    // helpers
	
	    /**
	     * @type {!ArrayBuffer}
	     * @inner
	     */
	    var EMPTY_BUFFER = new ArrayBuffer(0);
	
	    /**
	     * String.fromCharCode reference for compile-time renaming.
	     * @type {function(...number):string}
	     * @inner
	     */
	    var stringFromCharCode = String.fromCharCode;
	
	    /**
	     * Creates a source function for a string.
	     * @param {string} s String to read from
	     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
	     *  no more characters left.
	     * @throws {TypeError} If the argument is invalid
	     * @inner
	     */
	    function stringSource(s) {
	        var i=0; return function() {
	            return i < s.length ? s.charCodeAt(i++) : null;
	        };
	    }
	
	    /**
	     * Creates a destination function for a string.
	     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
	     *  Returns the final string when called without arguments.
	     * @inner
	     */
	    function stringDestination() {
	        var cs = [], ps = []; return function() {
	            if (arguments.length === 0)
	                return ps.join('')+stringFromCharCode.apply(String, cs);
	            if (cs.length + arguments.length > 1024)
	                ps.push(stringFromCharCode.apply(String, cs)),
	                    cs.length = 0;
	            Array.prototype.push.apply(cs, arguments);
	        };
	    }
	
	    /**
	     * Gets the accessor type.
	     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
	     * @expose
	     */
	    ByteBuffer.accessor = function() {
	        return Uint8Array;
	    };
	    /**
	     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
	     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @returns {!ByteBuffer}
	     * @expose
	     */
	    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
	        return new ByteBuffer(capacity, littleEndian, noAssert);
	    };
	
	    /**
	     * Concatenates multiple ByteBuffers into one.
	     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
	     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
	     *  defaults to "utf8")
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
	     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @returns {!ByteBuffer} Concatenated ByteBuffer
	     * @expose
	     */
	    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
	        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
	            noAssert = littleEndian;
	            littleEndian = encoding;
	            encoding = undefined;
	        }
	        var capacity = 0;
	        for (var i=0, k=buffers.length, length; i<k; ++i) {
	            if (!ByteBuffer.isByteBuffer(buffers[i]))
	                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
	            length = buffers[i].limit - buffers[i].offset;
	            if (length > 0) capacity += length;
	        }
	        if (capacity === 0)
	            return new ByteBuffer(0, littleEndian, noAssert);
	        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
	            bi;
	        i=0; while (i<k) {
	            bi = buffers[i++];
	            length = bi.limit - bi.offset;
	            if (length <= 0) continue;
	            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
	            bb.offset += length;
	        }
	        bb.limit = bb.offset;
	        bb.offset = 0;
	        return bb;
	    };
	
	    /**
	     * Tests if the specified type is a ByteBuffer.
	     * @param {*} bb ByteBuffer to test
	     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
	     * @expose
	     */
	    ByteBuffer.isByteBuffer = function(bb) {
	        return (bb && bb["__isByteBuffer__"]) === true;
	    };
	    /**
	     * Gets the backing buffer type.
	     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
	     * @expose
	     */
	    ByteBuffer.type = function() {
	        return ArrayBuffer;
	    };
	    /**
	     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
	     *  {@link ByteBuffer#limit} to the length of the wrapped data.
	     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
	     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
	     *  "utf8")
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
	     * @expose
	     */
	    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
	        if (typeof encoding !== 'string') {
	            noAssert = littleEndian;
	            littleEndian = encoding;
	            encoding = undefined;
	        }
	        if (typeof buffer === 'string') {
	            if (typeof encoding === 'undefined')
	                encoding = "utf8";
	            switch (encoding) {
	                case "base64":
	                    return ByteBuffer.fromBase64(buffer, littleEndian);
	                case "hex":
	                    return ByteBuffer.fromHex(buffer, littleEndian);
	                case "binary":
	                    return ByteBuffer.fromBinary(buffer, littleEndian);
	                case "utf8":
	                    return ByteBuffer.fromUTF8(buffer, littleEndian);
	                case "debug":
	                    return ByteBuffer.fromDebug(buffer, littleEndian);
	                default:
	                    throw Error("Unsupported encoding: "+encoding);
	            }
	        }
	        if (buffer === null || typeof buffer !== 'object')
	            throw TypeError("Illegal buffer");
	        var bb;
	        if (ByteBuffer.isByteBuffer(buffer)) {
	            bb = ByteBufferPrototype.clone.call(buffer);
	            bb.markedOffset = -1;
	            return bb;
	        }
	        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
	            bb = new ByteBuffer(0, littleEndian, noAssert);
	            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
	                bb.buffer = buffer.buffer;
	                bb.offset = buffer.byteOffset;
	                bb.limit = buffer.byteOffset + buffer.byteLength;
	                bb.view = new Uint8Array(buffer.buffer);
	            }
	        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
	            bb = new ByteBuffer(0, littleEndian, noAssert);
	            if (buffer.byteLength > 0) {
	                bb.buffer = buffer;
	                bb.offset = 0;
	                bb.limit = buffer.byteLength;
	                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
	            }
	        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
	            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
	            bb.limit = buffer.length;
	            for (var i=0; i<buffer.length; ++i)
	                bb.view[i] = buffer[i];
	        } else
	            throw TypeError("Illegal buffer"); // Otherwise fail
	        return bb;
	    };
	
	    /**
	     * Writes the array as a bitset.
	     * @param {Array<boolean>} value Array of booleans to write
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
	     * @returns {!ByteBuffer}
	     * @expose
	     */
	    ByteBufferPrototype.writeBitSet = function(value, offset) {
	      var relative = typeof offset === 'undefined';
	      if (relative) offset = this.offset;
	      if (!this.noAssert) {
	        if (!(value instanceof Array))
	          throw TypeError("Illegal BitSet: Not an array");
	        if (typeof offset !== 'number' || offset % 1 !== 0)
	            throw TypeError("Illegal offset: "+offset+" (not an integer)");
	        offset >>>= 0;
	        if (offset < 0 || offset + 0 > this.buffer.byteLength)
	            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	      }
	
	      var start = offset,
	          bits = value.length,
	          bytes = (bits >> 3),
	          bit = 0,
	          k;
	
	      offset += this.writeVarint32(bits,offset);
	
	      while(bytes--) {
	        k = (!!value[bit++] & 1) |
	            ((!!value[bit++] & 1) << 1) |
	            ((!!value[bit++] & 1) << 2) |
	            ((!!value[bit++] & 1) << 3) |
	            ((!!value[bit++] & 1) << 4) |
	            ((!!value[bit++] & 1) << 5) |
	            ((!!value[bit++] & 1) << 6) |
	            ((!!value[bit++] & 1) << 7);
	        this.writeByte(k,offset++);
	      }
	
	      if(bit < bits) {
	        var m = 0; k = 0;
	        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
	        this.writeByte(k,offset++);
	      }
	
	      if (relative) {
	        this.offset = offset;
	        return this;
	      }
	      return offset - start;
	    }
	
	    /**
	     * Reads a BitSet as an array of booleans.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
	     * @returns {Array<boolean>
	     * @expose
	     */
	    ByteBufferPrototype.readBitSet = function(offset) {
	      var relative = typeof offset === 'undefined';
	      if (relative) offset = this.offset;
	
	      var ret = this.readVarint32(offset),
	          bits = ret.value,
	          bytes = (bits >> 3),
	          bit = 0,
	          value = [],
	          k;
	
	      offset += ret.length;
	
	      while(bytes--) {
	        k = this.readByte(offset++);
	        value[bit++] = !!(k & 0x01);
	        value[bit++] = !!(k & 0x02);
	        value[bit++] = !!(k & 0x04);
	        value[bit++] = !!(k & 0x08);
	        value[bit++] = !!(k & 0x10);
	        value[bit++] = !!(k & 0x20);
	        value[bit++] = !!(k & 0x40);
	        value[bit++] = !!(k & 0x80);
	      }
	
	      if(bit < bits) {
	        var m = 0;
	        k = this.readByte(offset++);
	        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
	      }
	
	      if (relative) {
	        this.offset = offset;
	      }
	      return value;
	    }
	    /**
	     * Reads the specified number of bytes.
	     * @param {number} length Number of bytes to read
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
	     * @returns {!ByteBuffer}
	     * @expose
	     */
	    ByteBufferPrototype.readBytes = function(length, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + length > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
	        }
	        var slice = this.slice(offset, offset + length);
	        if (relative) this.offset += length;
	        return slice;
	    };
	
	    /**
	     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
	     * @function
	     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
	     *  will be modified according to the performed read operation.
	     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;
	
	    // types/ints/int8
	
	    /**
	     * Writes an 8bit signed integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeInt8 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value |= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 1;
	        var capacity0 = this.buffer.byteLength;
	        if (offset > capacity0)
	            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
	        offset -= 1;
	        this.view[offset] = value;
	        if (relative) this.offset += 1;
	        return this;
	    };
	
	    /**
	     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;
	
	    /**
	     * Reads an 8bit signed integer.
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readInt8 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 1 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
	        }
	        var value = this.view[offset];
	        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
	        if (relative) this.offset += 1;
	        return value;
	    };
	
	    /**
	     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;
	
	    /**
	     * Writes an 8bit unsigned integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeUint8 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value >>>= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 1;
	        var capacity1 = this.buffer.byteLength;
	        if (offset > capacity1)
	            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
	        offset -= 1;
	        this.view[offset] = value;
	        if (relative) this.offset += 1;
	        return this;
	    };
	
	    /**
	     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;
	
	    /**
	     * Reads an 8bit unsigned integer.
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readUint8 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 1 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
	        }
	        var value = this.view[offset];
	        if (relative) this.offset += 1;
	        return value;
	    };
	
	    /**
	     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;
	
	    // types/ints/int16
	
	    /**
	     * Writes a 16bit signed integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @throws {TypeError} If `offset` or `value` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.writeInt16 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value |= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 2;
	        var capacity2 = this.buffer.byteLength;
	        if (offset > capacity2)
	            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
	        offset -= 2;
	        if (this.littleEndian) {
	            this.view[offset+1] = (value & 0xFF00) >>> 8;
	            this.view[offset  ] =  value & 0x00FF;
	        } else {
	            this.view[offset]   = (value & 0xFF00) >>> 8;
	            this.view[offset+1] =  value & 0x00FF;
	        }
	        if (relative) this.offset += 2;
	        return this;
	    };
	
	    /**
	     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @throws {TypeError} If `offset` or `value` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;
	
	    /**
	     * Reads a 16bit signed integer.
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @returns {number} Value read
	     * @throws {TypeError} If `offset` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.readInt16 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 2 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
	        }
	        var value = 0;
	        if (this.littleEndian) {
	            value  = this.view[offset  ];
	            value |= this.view[offset+1] << 8;
	        } else {
	            value  = this.view[offset  ] << 8;
	            value |= this.view[offset+1];
	        }
	        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
	        if (relative) this.offset += 2;
	        return value;
	    };
	
	    /**
	     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @returns {number} Value read
	     * @throws {TypeError} If `offset` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;
	
	    /**
	     * Writes a 16bit unsigned integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @throws {TypeError} If `offset` or `value` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.writeUint16 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value >>>= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 2;
	        var capacity3 = this.buffer.byteLength;
	        if (offset > capacity3)
	            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
	        offset -= 2;
	        if (this.littleEndian) {
	            this.view[offset+1] = (value & 0xFF00) >>> 8;
	            this.view[offset  ] =  value & 0x00FF;
	        } else {
	            this.view[offset]   = (value & 0xFF00) >>> 8;
	            this.view[offset+1] =  value & 0x00FF;
	        }
	        if (relative) this.offset += 2;
	        return this;
	    };
	
	    /**
	     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @throws {TypeError} If `offset` or `value` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;
	
	    /**
	     * Reads a 16bit unsigned integer.
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @returns {number} Value read
	     * @throws {TypeError} If `offset` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.readUint16 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 2 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
	        }
	        var value = 0;
	        if (this.littleEndian) {
	            value  = this.view[offset  ];
	            value |= this.view[offset+1] << 8;
	        } else {
	            value  = this.view[offset  ] << 8;
	            value |= this.view[offset+1];
	        }
	        if (relative) this.offset += 2;
	        return value;
	    };
	
	    /**
	     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
	     * @returns {number} Value read
	     * @throws {TypeError} If `offset` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;
	
	    // types/ints/int32
	
	    /**
	     * Writes a 32bit signed integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @expose
	     */
	    ByteBufferPrototype.writeInt32 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value |= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 4;
	        var capacity4 = this.buffer.byteLength;
	        if (offset > capacity4)
	            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
	        offset -= 4;
	        if (this.littleEndian) {
	            this.view[offset+3] = (value >>> 24) & 0xFF;
	            this.view[offset+2] = (value >>> 16) & 0xFF;
	            this.view[offset+1] = (value >>>  8) & 0xFF;
	            this.view[offset  ] =  value         & 0xFF;
	        } else {
	            this.view[offset  ] = (value >>> 24) & 0xFF;
	            this.view[offset+1] = (value >>> 16) & 0xFF;
	            this.view[offset+2] = (value >>>  8) & 0xFF;
	            this.view[offset+3] =  value         & 0xFF;
	        }
	        if (relative) this.offset += 4;
	        return this;
	    };
	
	    /**
	     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @expose
	     */
	    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;
	
	    /**
	     * Reads a 32bit signed integer.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readInt32 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 4 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
	        }
	        var value = 0;
	        if (this.littleEndian) {
	            value  = this.view[offset+2] << 16;
	            value |= this.view[offset+1] <<  8;
	            value |= this.view[offset  ];
	            value += this.view[offset+3] << 24 >>> 0;
	        } else {
	            value  = this.view[offset+1] << 16;
	            value |= this.view[offset+2] <<  8;
	            value |= this.view[offset+3];
	            value += this.view[offset  ] << 24 >>> 0;
	        }
	        value |= 0; // Cast to signed
	        if (relative) this.offset += 4;
	        return value;
	    };
	
	    /**
	     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
	     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;
	
	    /**
	     * Writes a 32bit unsigned integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @expose
	     */
	    ByteBufferPrototype.writeUint32 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value >>>= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 4;
	        var capacity5 = this.buffer.byteLength;
	        if (offset > capacity5)
	            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
	        offset -= 4;
	        if (this.littleEndian) {
	            this.view[offset+3] = (value >>> 24) & 0xFF;
	            this.view[offset+2] = (value >>> 16) & 0xFF;
	            this.view[offset+1] = (value >>>  8) & 0xFF;
	            this.view[offset  ] =  value         & 0xFF;
	        } else {
	            this.view[offset  ] = (value >>> 24) & 0xFF;
	            this.view[offset+1] = (value >>> 16) & 0xFF;
	            this.view[offset+2] = (value >>>  8) & 0xFF;
	            this.view[offset+3] =  value         & 0xFF;
	        }
	        if (relative) this.offset += 4;
	        return this;
	    };
	
	    /**
	     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @expose
	     */
	    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;
	
	    /**
	     * Reads a 32bit unsigned integer.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readUint32 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 4 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
	        }
	        var value = 0;
	        if (this.littleEndian) {
	            value  = this.view[offset+2] << 16;
	            value |= this.view[offset+1] <<  8;
	            value |= this.view[offset  ];
	            value += this.view[offset+3] << 24 >>> 0;
	        } else {
	            value  = this.view[offset+1] << 16;
	            value |= this.view[offset+2] <<  8;
	            value |= this.view[offset+3];
	            value += this.view[offset  ] << 24 >>> 0;
	        }
	        if (relative) this.offset += 4;
	        return value;
	    };
	
	    /**
	     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {number} Value read
	     * @expose
	     */
	    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;
	
	    // types/ints/int64
	
	    if (Long) {
	
	        /**
	         * Writes a 64bit signed integer.
	         * @param {number|!Long} value Value to write
	         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!ByteBuffer} this
	         * @expose
	         */
	        ByteBufferPrototype.writeInt64 = function(value, offset) {
	            var relative = typeof offset === 'undefined';
	            if (relative) offset = this.offset;
	            if (!this.noAssert) {
	                if (typeof value === 'number')
	                    value = Long.fromNumber(value);
	                else if (typeof value === 'string')
	                    value = Long.fromString(value);
	                else if (!(value && value instanceof Long))
	                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	            }
	            if (typeof value === 'number')
	                value = Long.fromNumber(value);
	            else if (typeof value === 'string')
	                value = Long.fromString(value);
	            offset += 8;
	            var capacity6 = this.buffer.byteLength;
	            if (offset > capacity6)
	                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
	            offset -= 8;
	            var lo = value.low,
	                hi = value.high;
	            if (this.littleEndian) {
	                this.view[offset+3] = (lo >>> 24) & 0xFF;
	                this.view[offset+2] = (lo >>> 16) & 0xFF;
	                this.view[offset+1] = (lo >>>  8) & 0xFF;
	                this.view[offset  ] =  lo         & 0xFF;
	                offset += 4;
	                this.view[offset+3] = (hi >>> 24) & 0xFF;
	                this.view[offset+2] = (hi >>> 16) & 0xFF;
	                this.view[offset+1] = (hi >>>  8) & 0xFF;
	                this.view[offset  ] =  hi         & 0xFF;
	            } else {
	                this.view[offset  ] = (hi >>> 24) & 0xFF;
	                this.view[offset+1] = (hi >>> 16) & 0xFF;
	                this.view[offset+2] = (hi >>>  8) & 0xFF;
	                this.view[offset+3] =  hi         & 0xFF;
	                offset += 4;
	                this.view[offset  ] = (lo >>> 24) & 0xFF;
	                this.view[offset+1] = (lo >>> 16) & 0xFF;
	                this.view[offset+2] = (lo >>>  8) & 0xFF;
	                this.view[offset+3] =  lo         & 0xFF;
	            }
	            if (relative) this.offset += 8;
	            return this;
	        };
	
	        /**
	         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
	         * @param {number|!Long} value Value to write
	         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!ByteBuffer} this
	         * @expose
	         */
	        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;
	
	        /**
	         * Reads a 64bit signed integer.
	         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!Long}
	         * @expose
	         */
	        ByteBufferPrototype.readInt64 = function(offset) {
	            var relative = typeof offset === 'undefined';
	            if (relative) offset = this.offset;
	            if (!this.noAssert) {
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + 8 > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
	            }
	            var lo = 0,
	                hi = 0;
	            if (this.littleEndian) {
	                lo  = this.view[offset+2] << 16;
	                lo |= this.view[offset+1] <<  8;
	                lo |= this.view[offset  ];
	                lo += this.view[offset+3] << 24 >>> 0;
	                offset += 4;
	                hi  = this.view[offset+2] << 16;
	                hi |= this.view[offset+1] <<  8;
	                hi |= this.view[offset  ];
	                hi += this.view[offset+3] << 24 >>> 0;
	            } else {
	                hi  = this.view[offset+1] << 16;
	                hi |= this.view[offset+2] <<  8;
	                hi |= this.view[offset+3];
	                hi += this.view[offset  ] << 24 >>> 0;
	                offset += 4;
	                lo  = this.view[offset+1] << 16;
	                lo |= this.view[offset+2] <<  8;
	                lo |= this.view[offset+3];
	                lo += this.view[offset  ] << 24 >>> 0;
	            }
	            var value = new Long(lo, hi, false);
	            if (relative) this.offset += 8;
	            return value;
	        };
	
	        /**
	         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
	         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!Long}
	         * @expose
	         */
	        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;
	
	        /**
	         * Writes a 64bit unsigned integer.
	         * @param {number|!Long} value Value to write
	         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!ByteBuffer} this
	         * @expose
	         */
	        ByteBufferPrototype.writeUint64 = function(value, offset) {
	            var relative = typeof offset === 'undefined';
	            if (relative) offset = this.offset;
	            if (!this.noAssert) {
	                if (typeof value === 'number')
	                    value = Long.fromNumber(value);
	                else if (typeof value === 'string')
	                    value = Long.fromString(value);
	                else if (!(value && value instanceof Long))
	                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	            }
	            if (typeof value === 'number')
	                value = Long.fromNumber(value);
	            else if (typeof value === 'string')
	                value = Long.fromString(value);
	            offset += 8;
	            var capacity7 = this.buffer.byteLength;
	            if (offset > capacity7)
	                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
	            offset -= 8;
	            var lo = value.low,
	                hi = value.high;
	            if (this.littleEndian) {
	                this.view[offset+3] = (lo >>> 24) & 0xFF;
	                this.view[offset+2] = (lo >>> 16) & 0xFF;
	                this.view[offset+1] = (lo >>>  8) & 0xFF;
	                this.view[offset  ] =  lo         & 0xFF;
	                offset += 4;
	                this.view[offset+3] = (hi >>> 24) & 0xFF;
	                this.view[offset+2] = (hi >>> 16) & 0xFF;
	                this.view[offset+1] = (hi >>>  8) & 0xFF;
	                this.view[offset  ] =  hi         & 0xFF;
	            } else {
	                this.view[offset  ] = (hi >>> 24) & 0xFF;
	                this.view[offset+1] = (hi >>> 16) & 0xFF;
	                this.view[offset+2] = (hi >>>  8) & 0xFF;
	                this.view[offset+3] =  hi         & 0xFF;
	                offset += 4;
	                this.view[offset  ] = (lo >>> 24) & 0xFF;
	                this.view[offset+1] = (lo >>> 16) & 0xFF;
	                this.view[offset+2] = (lo >>>  8) & 0xFF;
	                this.view[offset+3] =  lo         & 0xFF;
	            }
	            if (relative) this.offset += 8;
	            return this;
	        };
	
	        /**
	         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
	         * @function
	         * @param {number|!Long} value Value to write
	         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!ByteBuffer} this
	         * @expose
	         */
	        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;
	
	        /**
	         * Reads a 64bit unsigned integer.
	         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!Long}
	         * @expose
	         */
	        ByteBufferPrototype.readUint64 = function(offset) {
	            var relative = typeof offset === 'undefined';
	            if (relative) offset = this.offset;
	            if (!this.noAssert) {
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + 8 > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
	            }
	            var lo = 0,
	                hi = 0;
	            if (this.littleEndian) {
	                lo  = this.view[offset+2] << 16;
	                lo |= this.view[offset+1] <<  8;
	                lo |= this.view[offset  ];
	                lo += this.view[offset+3] << 24 >>> 0;
	                offset += 4;
	                hi  = this.view[offset+2] << 16;
	                hi |= this.view[offset+1] <<  8;
	                hi |= this.view[offset  ];
	                hi += this.view[offset+3] << 24 >>> 0;
	            } else {
	                hi  = this.view[offset+1] << 16;
	                hi |= this.view[offset+2] <<  8;
	                hi |= this.view[offset+3];
	                hi += this.view[offset  ] << 24 >>> 0;
	                offset += 4;
	                lo  = this.view[offset+1] << 16;
	                lo |= this.view[offset+2] <<  8;
	                lo |= this.view[offset+3];
	                lo += this.view[offset  ] << 24 >>> 0;
	            }
	            var value = new Long(lo, hi, true);
	            if (relative) this.offset += 8;
	            return value;
	        };
	
	        /**
	         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
	         * @function
	         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	         * @returns {!Long}
	         * @expose
	         */
	        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;
	
	    } // Long
	
	
	    // types/floats/float32
	
	    /*
	     ieee754 - https://github.com/feross/ieee754
	
	     The MIT License (MIT)
	
	     Copyright (c) Feross Aboukhadijeh
	
	     Permission is hereby granted, free of charge, to any person obtaining a copy
	     of this software and associated documentation files (the "Software"), to deal
	     in the Software without restriction, including without limitation the rights
	     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	     copies of the Software, and to permit persons to whom the Software is
	     furnished to do so, subject to the following conditions:
	
	     The above copyright notice and this permission notice shall be included in
	     all copies or substantial portions of the Software.
	
	     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	     THE SOFTWARE.
	    */
	
	    /**
	     * Reads an IEEE754 float from a byte array.
	     * @param {!Array} buffer
	     * @param {number} offset
	     * @param {boolean} isLE
	     * @param {number} mLen
	     * @param {number} nBytes
	     * @returns {number}
	     * @inner
	     */
	    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
	        var e, m,
	            eLen = nBytes * 8 - mLen - 1,
	            eMax = (1 << eLen) - 1,
	            eBias = eMax >> 1,
	            nBits = -7,
	            i = isLE ? (nBytes - 1) : 0,
	            d = isLE ? -1 : 1,
	            s = buffer[offset + i];
	
	        i += d;
	
	        e = s & ((1 << (-nBits)) - 1);
	        s >>= (-nBits);
	        nBits += eLen;
	        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	        m = e & ((1 << (-nBits)) - 1);
	        e >>= (-nBits);
	        nBits += mLen;
	        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	        if (e === 0) {
	            e = 1 - eBias;
	        } else if (e === eMax) {
	            return m ? NaN : ((s ? -1 : 1) * Infinity);
	        } else {
	            m = m + Math.pow(2, mLen);
	            e = e - eBias;
	        }
	        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	    }
	
	    /**
	     * Writes an IEEE754 float to a byte array.
	     * @param {!Array} buffer
	     * @param {number} value
	     * @param {number} offset
	     * @param {boolean} isLE
	     * @param {number} mLen
	     * @param {number} nBytes
	     * @inner
	     */
	    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
	        var e, m, c,
	            eLen = nBytes * 8 - mLen - 1,
	            eMax = (1 << eLen) - 1,
	            eBias = eMax >> 1,
	            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	            i = isLE ? 0 : (nBytes - 1),
	            d = isLE ? 1 : -1,
	            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
	
	        value = Math.abs(value);
	
	        if (isNaN(value) || value === Infinity) {
	            m = isNaN(value) ? 1 : 0;
	            e = eMax;
	        } else {
	            e = Math.floor(Math.log(value) / Math.LN2);
	            if (value * (c = Math.pow(2, -e)) < 1) {
	                e--;
	                c *= 2;
	            }
	            if (e + eBias >= 1) {
	                value += rt / c;
	            } else {
	                value += rt * Math.pow(2, 1 - eBias);
	            }
	            if (value * c >= 2) {
	                e++;
	                c /= 2;
	            }
	
	            if (e + eBias >= eMax) {
	                m = 0;
	                e = eMax;
	            } else if (e + eBias >= 1) {
	                m = (value * c - 1) * Math.pow(2, mLen);
	                e = e + eBias;
	            } else {
	                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	                e = 0;
	            }
	        }
	
	        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	        e = (e << mLen) | m;
	        eLen += mLen;
	        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	        buffer[offset + i - d] |= s * 128;
	    }
	
	    /**
	     * Writes a 32bit float.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeFloat32 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number')
	                throw TypeError("Illegal value: "+value+" (not a number)");
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 4;
	        var capacity8 = this.buffer.byteLength;
	        if (offset > capacity8)
	            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
	        offset -= 4;
	        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
	        if (relative) this.offset += 4;
	        return this;
	    };
	
	    /**
	     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;
	
	    /**
	     * Reads a 32bit float.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {number}
	     * @expose
	     */
	    ByteBufferPrototype.readFloat32 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 4 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
	        }
	        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
	        if (relative) this.offset += 4;
	        return value;
	    };
	
	    /**
	     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
	     * @returns {number}
	     * @expose
	     */
	    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;
	
	    // types/floats/float64
	
	    /**
	     * Writes a 64bit float.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeFloat64 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number')
	                throw TypeError("Illegal value: "+value+" (not a number)");
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        offset += 8;
	        var capacity9 = this.buffer.byteLength;
	        if (offset > capacity9)
	            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
	        offset -= 8;
	        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
	        if (relative) this.offset += 8;
	        return this;
	    };
	
	    /**
	     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
	     * @function
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;
	
	    /**
	     * Reads a 64bit float.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	     * @returns {number}
	     * @expose
	     */
	    ByteBufferPrototype.readFloat64 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 8 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
	        }
	        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
	        if (relative) this.offset += 8;
	        return value;
	    };
	
	    /**
	     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
	     * @function
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
	     * @returns {number}
	     * @expose
	     */
	    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;
	
	
	    // types/varints/varint32
	
	    /**
	     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
	     * @type {number}
	     * @const
	     * @expose
	     */
	    ByteBuffer.MAX_VARINT32_BYTES = 5;
	
	    /**
	     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
	     * @param {number} value Value to encode
	     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
	     * @expose
	     */
	    ByteBuffer.calculateVarint32 = function(value) {
	        // ref: src/google/protobuf/io/coded_stream.cc
	        value = value >>> 0;
	             if (value < 1 << 7 ) return 1;
	        else if (value < 1 << 14) return 2;
	        else if (value < 1 << 21) return 3;
	        else if (value < 1 << 28) return 4;
	        else                      return 5;
	    };
	
	    /**
	     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
	     * @param {number} n Signed 32bit integer
	     * @returns {number} Unsigned zigzag encoded 32bit integer
	     * @expose
	     */
	    ByteBuffer.zigZagEncode32 = function(n) {
	        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
	    };
	
	    /**
	     * Decodes a zigzag encoded signed 32bit integer.
	     * @param {number} n Unsigned zigzag encoded 32bit integer
	     * @returns {number} Signed 32bit integer
	     * @expose
	     */
	    ByteBuffer.zigZagDecode32 = function(n) {
	        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
	    };
	
	    /**
	     * Writes a 32bit base 128 variable-length integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
	     * @expose
	     */
	    ByteBufferPrototype.writeVarint32 = function(value, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value |= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        var size = ByteBuffer.calculateVarint32(value),
	            b;
	        offset += size;
	        var capacity10 = this.buffer.byteLength;
	        if (offset > capacity10)
	            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
	        offset -= size;
	        value >>>= 0;
	        while (value >= 0x80) {
	            b = (value & 0x7f) | 0x80;
	            this.view[offset++] = b;
	            value >>>= 7;
	        }
	        this.view[offset++] = value;
	        if (relative) {
	            this.offset = offset;
	            return this;
	        }
	        return size;
	    };
	
	    /**
	     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
	     * @param {number} value Value to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
	     * @expose
	     */
	    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
	        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
	    };
	
	    /**
	     * Reads a 32bit base 128 variable-length integer.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
	     *  and the actual number of bytes read.
	     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
	     *  to fully decode the varint.
	     * @expose
	     */
	    ByteBufferPrototype.readVarint32 = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 1 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
	        }
	        var c = 0,
	            value = 0 >>> 0,
	            b;
	        do {
	            if (!this.noAssert && offset > this.limit) {
	                var err = Error("Truncated");
	                err['truncated'] = true;
	                throw err;
	            }
	            b = this.view[offset++];
	            if (c < 5)
	                value |= (b & 0x7f) << (7*c);
	            ++c;
	        } while ((b & 0x80) !== 0);
	        value |= 0;
	        if (relative) {
	            this.offset = offset;
	            return value;
	        }
	        return {
	            "value": value,
	            "length": c
	        };
	    };
	
	    /**
	     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
	     *  and the actual number of bytes read.
	     * @throws {Error} If it's not a valid varint
	     * @expose
	     */
	    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
	        var val = this.readVarint32(offset);
	        if (typeof val === 'object')
	            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
	        else
	            val = ByteBuffer.zigZagDecode32(val);
	        return val;
	    };
	
	    // types/varints/varint64
	
	    if (Long) {
	
	        /**
	         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
	         * @type {number}
	         * @const
	         * @expose
	         */
	        ByteBuffer.MAX_VARINT64_BYTES = 10;
	
	        /**
	         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
	         * @param {number|!Long} value Value to encode
	         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
	         * @expose
	         */
	        ByteBuffer.calculateVarint64 = function(value) {
	            if (typeof value === 'number')
	                value = Long.fromNumber(value);
	            else if (typeof value === 'string')
	                value = Long.fromString(value);
	            // ref: src/google/protobuf/io/coded_stream.cc
	            var part0 = value.toInt() >>> 0,
	                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
	                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
	            if (part2 == 0) {
	                if (part1 == 0) {
	                    if (part0 < 1 << 14)
	                        return part0 < 1 << 7 ? 1 : 2;
	                    else
	                        return part0 < 1 << 21 ? 3 : 4;
	                } else {
	                    if (part1 < 1 << 14)
	                        return part1 < 1 << 7 ? 5 : 6;
	                    else
	                        return part1 < 1 << 21 ? 7 : 8;
	                }
	            } else
	                return part2 < 1 << 7 ? 9 : 10;
	        };
	
	        /**
	         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
	         * @param {number|!Long} value Signed long
	         * @returns {!Long} Unsigned zigzag encoded long
	         * @expose
	         */
	        ByteBuffer.zigZagEncode64 = function(value) {
	            if (typeof value === 'number')
	                value = Long.fromNumber(value, false);
	            else if (typeof value === 'string')
	                value = Long.fromString(value, false);
	            else if (value.unsigned !== false) value = value.toSigned();
	            // ref: src/google/protobuf/wire_format_lite.h
	            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
	        };
	
	        /**
	         * Decodes a zigzag encoded signed 64bit integer.
	         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
	         * @returns {!Long} Signed long
	         * @expose
	         */
	        ByteBuffer.zigZagDecode64 = function(value) {
	            if (typeof value === 'number')
	                value = Long.fromNumber(value, false);
	            else if (typeof value === 'string')
	                value = Long.fromString(value, false);
	            else if (value.unsigned !== false) value = value.toSigned();
	            // ref: src/google/protobuf/wire_format_lite.h
	            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
	        };
	
	        /**
	         * Writes a 64bit base 128 variable-length integer.
	         * @param {number|Long} value Value to write
	         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	         *  written if omitted.
	         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
	         * @expose
	         */
	        ByteBufferPrototype.writeVarint64 = function(value, offset) {
	            var relative = typeof offset === 'undefined';
	            if (relative) offset = this.offset;
	            if (!this.noAssert) {
	                if (typeof value === 'number')
	                    value = Long.fromNumber(value);
	                else if (typeof value === 'string')
	                    value = Long.fromString(value);
	                else if (!(value && value instanceof Long))
	                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	            }
	            if (typeof value === 'number')
	                value = Long.fromNumber(value, false);
	            else if (typeof value === 'string')
	                value = Long.fromString(value, false);
	            else if (value.unsigned !== false) value = value.toSigned();
	            var size = ByteBuffer.calculateVarint64(value),
	                part0 = value.toInt() >>> 0,
	                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
	                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
	            offset += size;
	            var capacity11 = this.buffer.byteLength;
	            if (offset > capacity11)
	                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
	            offset -= size;
	            switch (size) {
	                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
	                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
	                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
	                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
	                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
	                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
	                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
	                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
	                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
	                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
	            }
	            if (relative) {
	                this.offset += size;
	                return this;
	            } else {
	                return size;
	            }
	        };
	
	        /**
	         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
	         * @param {number|Long} value Value to write
	         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	         *  written if omitted.
	         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
	         * @expose
	         */
	        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
	            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
	        };
	
	        /**
	         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
	         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	         *  read if omitted.
	         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
	         *  the actual number of bytes read.
	         * @throws {Error} If it's not a valid varint
	         * @expose
	         */
	        ByteBufferPrototype.readVarint64 = function(offset) {
	            var relative = typeof offset === 'undefined';
	            if (relative) offset = this.offset;
	            if (!this.noAssert) {
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + 1 > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
	            }
	            // ref: src/google/protobuf/io/coded_stream.cc
	            var start = offset,
	                part0 = 0,
	                part1 = 0,
	                part2 = 0,
	                b  = 0;
	            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
	            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
	            throw Error("Buffer overrun"); }}}}}}}}}}
	            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
	            if (relative) {
	                this.offset = offset;
	                return value;
	            } else {
	                return {
	                    'value': value,
	                    'length': offset-start
	                };
	            }
	        };
	
	        /**
	         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
	         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	         *  read if omitted.
	         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
	         *  the actual number of bytes read.
	         * @throws {Error} If it's not a valid varint
	         * @expose
	         */
	        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
	            var val = this.readVarint64(offset);
	            if (val && val['value'] instanceof Long)
	                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
	            else
	                val = ByteBuffer.zigZagDecode64(val);
	            return val;
	        };
	
	    } // Long
	
	
	    // types/strings/cstring
	
	    /**
	     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
	     *  characters itself.
	     * @param {string} str String to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  contained in `str` + 1 if omitted.
	     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
	     * @expose
	     */
	    ByteBufferPrototype.writeCString = function(str, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        var i,
	            k = str.length;
	        if (!this.noAssert) {
	            if (typeof str !== 'string')
	                throw TypeError("Illegal str: Not a string");
	            for (i=0; i<k; ++i) {
	                if (str.charCodeAt(i) === 0)
	                    throw RangeError("Illegal str: Contains NULL-characters");
	            }
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
	        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
	        offset += k+1;
	        var capacity12 = this.buffer.byteLength;
	        if (offset > capacity12)
	            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
	        offset -= k+1;
	        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
	            this.view[offset++] = b;
	        }.bind(this));
	        this.view[offset++] = 0;
	        if (relative) {
	            this.offset = offset;
	            return this;
	        }
	        return k;
	    };
	
	    /**
	     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
	     *  itself.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  read if omitted.
	     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	     *  read and the actual number of bytes read.
	     * @expose
	     */
	    ByteBufferPrototype.readCString = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 1 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
	        }
	        var start = offset,
	            temp;
	        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
	        var sd, b = -1;
	        utfx.decodeUTF8toUTF16(function() {
	            if (b === 0) return null;
	            if (offset >= this.limit)
	                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
	            b = this.view[offset++];
	            return b === 0 ? null : b;
	        }.bind(this), sd = stringDestination(), true);
	        if (relative) {
	            this.offset = offset;
	            return sd();
	        } else {
	            return {
	                "string": sd(),
	                "length": offset - start
	            };
	        }
	    };
	
	    // types/strings/istring
	
	    /**
	     * Writes a length as uint32 prefixed UTF8 encoded string.
	     * @param {string} str String to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
	     * @expose
	     * @see ByteBuffer#writeVarint32
	     */
	    ByteBufferPrototype.writeIString = function(str, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof str !== 'string')
	                throw TypeError("Illegal str: Not a string");
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        var start = offset,
	            k;
	        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
	        offset += 4+k;
	        var capacity13 = this.buffer.byteLength;
	        if (offset > capacity13)
	            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
	        offset -= 4+k;
	        if (this.littleEndian) {
	            this.view[offset+3] = (k >>> 24) & 0xFF;
	            this.view[offset+2] = (k >>> 16) & 0xFF;
	            this.view[offset+1] = (k >>>  8) & 0xFF;
	            this.view[offset  ] =  k         & 0xFF;
	        } else {
	            this.view[offset  ] = (k >>> 24) & 0xFF;
	            this.view[offset+1] = (k >>> 16) & 0xFF;
	            this.view[offset+2] = (k >>>  8) & 0xFF;
	            this.view[offset+3] =  k         & 0xFF;
	        }
	        offset += 4;
	        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
	            this.view[offset++] = b;
	        }.bind(this));
	        if (offset !== start + 4 + k)
	            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
	        if (relative) {
	            this.offset = offset;
	            return this;
	        }
	        return offset - start;
	    };
	
	    /**
	     * Reads a length as uint32 prefixed UTF8 encoded string.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  read if omitted.
	     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	     *  read and the actual number of bytes read.
	     * @expose
	     * @see ByteBuffer#readVarint32
	     */
	    ByteBufferPrototype.readIString = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 4 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
	        }
	        var start = offset;
	        var len = this.readUint32(offset);
	        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
	        offset += str['length'];
	        if (relative) {
	            this.offset = offset;
	            return str['string'];
	        } else {
	            return {
	                'string': str['string'],
	                'length': offset - start
	            };
	        }
	    };
	
	    // types/strings/utf8string
	
	    /**
	     * Metrics representing number of UTF8 characters. Evaluates to `c`.
	     * @type {string}
	     * @const
	     * @expose
	     */
	    ByteBuffer.METRICS_CHARS = 'c';
	
	    /**
	     * Metrics representing number of bytes. Evaluates to `b`.
	     * @type {string}
	     * @const
	     * @expose
	     */
	    ByteBuffer.METRICS_BYTES = 'b';
	
	    /**
	     * Writes an UTF8 encoded string.
	     * @param {string} str String to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
	     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
	     * @expose
	     */
	    ByteBufferPrototype.writeUTF8String = function(str, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        var k;
	        var start = offset;
	        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
	        offset += k;
	        var capacity14 = this.buffer.byteLength;
	        if (offset > capacity14)
	            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
	        offset -= k;
	        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
	            this.view[offset++] = b;
	        }.bind(this));
	        if (relative) {
	            this.offset = offset;
	            return this;
	        }
	        return offset - start;
	    };
	
	    /**
	     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
	     * @function
	     * @param {string} str String to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
	     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
	     * @expose
	     */
	    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;
	
	    /**
	     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
	     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
	     * @param {string} str String to calculate
	     * @returns {number} Number of UTF8 characters
	     * @expose
	     */
	    ByteBuffer.calculateUTF8Chars = function(str) {
	        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
	    };
	
	    /**
	     * Calculates the number of UTF8 bytes of a string.
	     * @param {string} str String to calculate
	     * @returns {number} Number of UTF8 bytes
	     * @expose
	     */
	    ByteBuffer.calculateUTF8Bytes = function(str) {
	        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
	    };
	
	    /**
	     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
	     * @function
	     * @param {string} str String to calculate
	     * @returns {number} Number of UTF8 bytes
	     * @expose
	     */
	    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;
	
	    /**
	     * Reads an UTF8 encoded string.
	     * @param {number} length Number of characters or bytes to read.
	     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
	     *  {@link ByteBuffer.METRICS_CHARS}.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  read if omitted.
	     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	     *  read and the actual number of bytes read.
	     * @expose
	     */
	    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
	        if (typeof metrics === 'number') {
	            offset = metrics;
	            metrics = undefined;
	        }
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
	        if (!this.noAssert) {
	            if (typeof length !== 'number' || length % 1 !== 0)
	                throw TypeError("Illegal length: "+length+" (not an integer)");
	            length |= 0;
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        var i = 0,
	            start = offset,
	            sd;
	        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
	            sd = stringDestination();
	            utfx.decodeUTF8(function() {
	                return i < length && offset < this.limit ? this.view[offset++] : null;
	            }.bind(this), function(cp) {
	                ++i; utfx.UTF8toUTF16(cp, sd);
	            });
	            if (i !== length)
	                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
	            if (relative) {
	                this.offset = offset;
	                return sd();
	            } else {
	                return {
	                    "string": sd(),
	                    "length": offset - start
	                };
	            }
	        } else if (metrics === ByteBuffer.METRICS_BYTES) {
	            if (!this.noAssert) {
	                if (typeof offset !== 'number' || offset % 1 !== 0)
	                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
	                offset >>>= 0;
	                if (offset < 0 || offset + length > this.buffer.byteLength)
	                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
	            }
	            var k = offset + length;
	            utfx.decodeUTF8toUTF16(function() {
	                return offset < k ? this.view[offset++] : null;
	            }.bind(this), sd = stringDestination(), this.noAssert);
	            if (offset !== k)
	                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
	            if (relative) {
	                this.offset = offset;
	                return sd();
	            } else {
	                return {
	                    'string': sd(),
	                    'length': offset - start
	                };
	            }
	        } else
	            throw TypeError("Unsupported metrics: "+metrics);
	    };
	
	    /**
	     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
	     * @function
	     * @param {number} length Number of characters or bytes to read
	     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
	     *  {@link ByteBuffer.METRICS_CHARS}.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  read if omitted.
	     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	     *  read and the actual number of bytes read.
	     * @expose
	     */
	    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;
	
	    // types/strings/vstring
	
	    /**
	     * Writes a length as varint32 prefixed UTF8 encoded string.
	     * @param {string} str String to write
	     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
	     * @expose
	     * @see ByteBuffer#writeVarint32
	     */
	    ByteBufferPrototype.writeVString = function(str, offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof str !== 'string')
	                throw TypeError("Illegal str: Not a string");
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        var start = offset,
	            k, l;
	        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
	        l = ByteBuffer.calculateVarint32(k);
	        offset += l+k;
	        var capacity15 = this.buffer.byteLength;
	        if (offset > capacity15)
	            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
	        offset -= l+k;
	        offset += this.writeVarint32(k, offset);
	        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
	            this.view[offset++] = b;
	        }.bind(this));
	        if (offset !== start+k+l)
	            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
	        if (relative) {
	            this.offset = offset;
	            return this;
	        }
	        return offset - start;
	    };
	
	    /**
	     * Reads a length as varint32 prefixed UTF8 encoded string.
	     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  read if omitted.
	     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
	     *  read and the actual number of bytes read.
	     * @expose
	     * @see ByteBuffer#readVarint32
	     */
	    ByteBufferPrototype.readVString = function(offset) {
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 1 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
	        }
	        var start = offset;
	        var len = this.readVarint32(offset);
	        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
	        offset += str['length'];
	        if (relative) {
	            this.offset = offset;
	            return str['string'];
	        } else {
	            return {
	                'string': str['string'],
	                'length': offset - start
	            };
	        }
	    };
	
	
	    /**
	     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
	     *  data's length.
	     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
	     *  will be modified according to the performed read operation.
	     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
	     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
	     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
	     */
	    ByteBufferPrototype.append = function(source, encoding, offset) {
	        if (typeof encoding === 'number' || typeof encoding !== 'string') {
	            offset = encoding;
	            encoding = undefined;
	        }
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        if (!(source instanceof ByteBuffer))
	            source = ByteBuffer.wrap(source, encoding);
	        var length = source.limit - source.offset;
	        if (length <= 0) return this; // Nothing to append
	        offset += length;
	        var capacity16 = this.buffer.byteLength;
	        if (offset > capacity16)
	            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
	        offset -= length;
	        this.view.set(source.view.subarray(source.offset, source.limit), offset);
	        source.offset += length;
	        if (relative) this.offset += length;
	        return this;
	    };
	
	    /**
	     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
	        specified offset up to the length of this ByteBuffer's data.
	     * @param {!ByteBuffer} target Target ByteBuffer
	     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  read if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     * @see ByteBuffer#append
	     */
	    ByteBufferPrototype.appendTo = function(target, offset) {
	        target.append(this, offset);
	        return this;
	    };
	
	    /**
	     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
	     *  disable them if your code already makes sure that everything is valid.
	     * @param {boolean} assert `true` to enable assertions, otherwise `false`
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.assert = function(assert) {
	        this.noAssert = !assert;
	        return this;
	    };
	
	    /**
	     * Gets the capacity of this ByteBuffer's backing buffer.
	     * @returns {number} Capacity of the backing buffer
	     * @expose
	     */
	    ByteBufferPrototype.capacity = function() {
	        return this.buffer.byteLength;
	    };
	    /**
	     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
	     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.clear = function() {
	        this.offset = 0;
	        this.limit = this.buffer.byteLength;
	        this.markedOffset = -1;
	        return this;
	    };
	
	    /**
	     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
	     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
	     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
	     * @returns {!ByteBuffer} Cloned instance
	     * @expose
	     */
	    ByteBufferPrototype.clone = function(copy) {
	        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
	        if (copy) {
	            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
	            bb.view = new Uint8Array(bb.buffer);
	        } else {
	            bb.buffer = this.buffer;
	            bb.view = this.view;
	        }
	        bb.offset = this.offset;
	        bb.markedOffset = this.markedOffset;
	        bb.limit = this.limit;
	        return bb;
	    };
	
	    /**
	     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
	     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
	     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
	     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
	     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.compact = function(begin, end) {
	        if (typeof begin === 'undefined') begin = this.offset;
	        if (typeof end === 'undefined') end = this.limit;
	        if (!this.noAssert) {
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        if (begin === 0 && end === this.buffer.byteLength)
	            return this; // Already compacted
	        var len = end - begin;
	        if (len === 0) {
	            this.buffer = EMPTY_BUFFER;
	            this.view = null;
	            if (this.markedOffset >= 0) this.markedOffset -= begin;
	            this.offset = 0;
	            this.limit = 0;
	            return this;
	        }
	        var buffer = new ArrayBuffer(len);
	        var view = new Uint8Array(buffer);
	        view.set(this.view.subarray(begin, end));
	        this.buffer = buffer;
	        this.view = view;
	        if (this.markedOffset >= 0) this.markedOffset -= begin;
	        this.offset = 0;
	        this.limit = len;
	        return this;
	    };
	
	    /**
	     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
	     *  {@link ByteBuffer#limit}.
	     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
	     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
	     * @returns {!ByteBuffer} Copy
	     * @expose
	     */
	    ByteBufferPrototype.copy = function(begin, end) {
	        if (typeof begin === 'undefined') begin = this.offset;
	        if (typeof end === 'undefined') end = this.limit;
	        if (!this.noAssert) {
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        if (begin === end)
	            return new ByteBuffer(0, this.littleEndian, this.noAssert);
	        var capacity = end - begin,
	            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
	        bb.offset = 0;
	        bb.limit = capacity;
	        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
	        this.copyTo(bb, 0, begin, end);
	        return bb;
	    };
	
	    /**
	     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
	     *  {@link ByteBuffer#limit}.
	     * @param {!ByteBuffer} target Target ByteBuffer
	     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
	     *  by the number of bytes copied if omitted.
	     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
	     *  number of bytes copied if omitted.
	     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
	        var relative,
	            targetRelative;
	        if (!this.noAssert) {
	            if (!ByteBuffer.isByteBuffer(target))
	                throw TypeError("Illegal target: Not a ByteBuffer");
	        }
	        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
	        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
	        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;
	
	        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
	            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
	        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
	            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);
	
	        var len = sourceLimit - sourceOffset;
	        if (len === 0)
	            return target; // Nothing to copy
	
	        target.ensureCapacity(targetOffset + len);
	
	        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);
	
	        if (relative) this.offset += len;
	        if (targetRelative) target.offset += len;
	
	        return this;
	    };
	
	    /**
	     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
	     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
	     *  the required capacity will be used instead.
	     * @param {number} capacity Required capacity
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.ensureCapacity = function(capacity) {
	        var current = this.buffer.byteLength;
	        if (current < capacity)
	            return this.resize((current *= 2) > capacity ? current : capacity);
	        return this;
	    };
	
	    /**
	     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
	     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
	     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
	     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
	     *  written if omitted. defaults to {@link ByteBuffer#offset}.
	     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
	     * @returns {!ByteBuffer} this
	     * @expose
	     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
	     */
	    ByteBufferPrototype.fill = function(value, begin, end) {
	        var relative = typeof begin === 'undefined';
	        if (relative) begin = this.offset;
	        if (typeof value === 'string' && value.length > 0)
	            value = value.charCodeAt(0);
	        if (typeof begin === 'undefined') begin = this.offset;
	        if (typeof end === 'undefined') end = this.limit;
	        if (!this.noAssert) {
	            if (typeof value !== 'number' || value % 1 !== 0)
	                throw TypeError("Illegal value: "+value+" (not an integer)");
	            value |= 0;
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        if (begin >= end)
	            return this; // Nothing to fill
	        while (begin < end) this.view[begin++] = value;
	        if (relative) this.offset = begin;
	        return this;
	    };
	
	    /**
	     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
	     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.flip = function() {
	        this.limit = this.offset;
	        this.offset = 0;
	        return this;
	    };
	    /**
	     * Marks an offset on this ByteBuffer to be used later.
	     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
	     * @returns {!ByteBuffer} this
	     * @throws {TypeError} If `offset` is not a valid number
	     * @throws {RangeError} If `offset` is out of bounds
	     * @see ByteBuffer#reset
	     * @expose
	     */
	    ByteBufferPrototype.mark = function(offset) {
	        offset = typeof offset === 'undefined' ? this.offset : offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        this.markedOffset = offset;
	        return this;
	    };
	    /**
	     * Sets the byte order.
	     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.order = function(littleEndian) {
	        if (!this.noAssert) {
	            if (typeof littleEndian !== 'boolean')
	                throw TypeError("Illegal littleEndian: Not a boolean");
	        }
	        this.littleEndian = !!littleEndian;
	        return this;
	    };
	
	    /**
	     * Switches (to) little endian byte order.
	     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.LE = function(littleEndian) {
	        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
	        return this;
	    };
	
	    /**
	     * Switches (to) big endian byte order.
	     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.BE = function(bigEndian) {
	        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
	        return this;
	    };
	    /**
	     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
	     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
	     *  will be resized and its contents moved accordingly.
	     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
	     *  modified according to the performed read operation.
	     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
	     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
	     *  prepended if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
	     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
	     */
	    ByteBufferPrototype.prepend = function(source, encoding, offset) {
	        if (typeof encoding === 'number' || typeof encoding !== 'string') {
	            offset = encoding;
	            encoding = undefined;
	        }
	        var relative = typeof offset === 'undefined';
	        if (relative) offset = this.offset;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: "+offset+" (not an integer)");
	            offset >>>= 0;
	            if (offset < 0 || offset + 0 > this.buffer.byteLength)
	                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
	        }
	        if (!(source instanceof ByteBuffer))
	            source = ByteBuffer.wrap(source, encoding);
	        var len = source.limit - source.offset;
	        if (len <= 0) return this; // Nothing to prepend
	        var diff = len - offset;
	        if (diff > 0) { // Not enough space before offset, so resize + move
	            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
	            var view = new Uint8Array(buffer);
	            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
	            this.buffer = buffer;
	            this.view = view;
	            this.offset += diff;
	            if (this.markedOffset >= 0) this.markedOffset += diff;
	            this.limit += diff;
	            offset += diff;
	        } else {
	            var arrayView = new Uint8Array(this.buffer);
	        }
	        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);
	
	        source.offset = source.limit;
	        if (relative)
	            this.offset -= len;
	        return this;
	    };
	
	    /**
	     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
	     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
	     *  will be resized and its contents moved accordingly.
	     * @param {!ByteBuffer} target Target ByteBuffer
	     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
	     *  prepended if omitted.
	     * @returns {!ByteBuffer} this
	     * @expose
	     * @see ByteBuffer#prepend
	     */
	    ByteBufferPrototype.prependTo = function(target, offset) {
	        target.prepend(this, offset);
	        return this;
	    };
	    /**
	     * Prints debug information about this ByteBuffer's contents.
	     * @param {function(string)=} out Output function to call, defaults to console.log
	     * @expose
	     */
	    ByteBufferPrototype.printDebug = function(out) {
	        if (typeof out !== 'function') out = console.log.bind(console);
	        out(
	            this.toString()+"\n"+
	            "-------------------------------------------------------------------\n"+
	            this.toDebug(/* columns */ true)
	        );
	    };
	
	    /**
	     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
	     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
	     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
	     * @expose
	     */
	    ByteBufferPrototype.remaining = function() {
	        return this.limit - this.offset;
	    };
	    /**
	     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
	     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
	     *  marked, sets `offset = 0`.
	     * @returns {!ByteBuffer} this
	     * @see ByteBuffer#mark
	     * @expose
	     */
	    ByteBufferPrototype.reset = function() {
	        if (this.markedOffset >= 0) {
	            this.offset = this.markedOffset;
	            this.markedOffset = -1;
	        } else {
	            this.offset = 0;
	        }
	        return this;
	    };
	    /**
	     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
	     *  large or larger.
	     * @param {number} capacity Capacity required
	     * @returns {!ByteBuffer} this
	     * @throws {TypeError} If `capacity` is not a number
	     * @throws {RangeError} If `capacity < 0`
	     * @expose
	     */
	    ByteBufferPrototype.resize = function(capacity) {
	        if (!this.noAssert) {
	            if (typeof capacity !== 'number' || capacity % 1 !== 0)
	                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
	            capacity |= 0;
	            if (capacity < 0)
	                throw RangeError("Illegal capacity: 0 <= "+capacity);
	        }
	        if (this.buffer.byteLength < capacity) {
	            var buffer = new ArrayBuffer(capacity);
	            var view = new Uint8Array(buffer);
	            view.set(this.view);
	            this.buffer = buffer;
	            this.view = view;
	        }
	        return this;
	    };
	    /**
	     * Reverses this ByteBuffer's contents.
	     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
	     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.reverse = function(begin, end) {
	        if (typeof begin === 'undefined') begin = this.offset;
	        if (typeof end === 'undefined') end = this.limit;
	        if (!this.noAssert) {
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        if (begin === end)
	            return this; // Nothing to reverse
	        Array.prototype.reverse.call(this.view.subarray(begin, end));
	        return this;
	    };
	    /**
	     * Skips the next `length` bytes. This will just advance
	     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
	     * @returns {!ByteBuffer} this
	     * @expose
	     */
	    ByteBufferPrototype.skip = function(length) {
	        if (!this.noAssert) {
	            if (typeof length !== 'number' || length % 1 !== 0)
	                throw TypeError("Illegal length: "+length+" (not an integer)");
	            length |= 0;
	        }
	        var offset = this.offset + length;
	        if (!this.noAssert) {
	            if (offset < 0 || offset > this.buffer.byteLength)
	                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
	        }
	        this.offset = offset;
	        return this;
	    };
	
	    /**
	     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
	     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
	     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
	     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
	     * @expose
	     */
	    ByteBufferPrototype.slice = function(begin, end) {
	        if (typeof begin === 'undefined') begin = this.offset;
	        if (typeof end === 'undefined') end = this.limit;
	        if (!this.noAssert) {
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        var bb = this.clone();
	        bb.offset = begin;
	        bb.limit = end;
	        return bb;
	    };
	    /**
	     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
	     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
	     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
	     *  possible. Defaults to `false`
	     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
	     * @expose
	     */
	    ByteBufferPrototype.toBuffer = function(forceCopy) {
	        var offset = this.offset,
	            limit = this.limit;
	        if (!this.noAssert) {
	            if (typeof offset !== 'number' || offset % 1 !== 0)
	                throw TypeError("Illegal offset: Not an integer");
	            offset >>>= 0;
	            if (typeof limit !== 'number' || limit % 1 !== 0)
	                throw TypeError("Illegal limit: Not an integer");
	            limit >>>= 0;
	            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
	        }
	        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
	        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
	        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
	            return this.buffer;
	        if (offset === limit)
	            return EMPTY_BUFFER;
	        var buffer = new ArrayBuffer(limit - offset);
	        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
	        return buffer;
	    };
	
	    /**
	     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
	     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
	     * @function
	     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
	     *  Defaults to `false`
	     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
	     * @expose
	     */
	    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;
	
	    /**
	     * Converts the ByteBuffer's contents to a string.
	     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
	     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
	     *  highlighted offsets.
	     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
	     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
	     * @returns {string} String representation
	     * @throws {Error} If `encoding` is invalid
	     * @expose
	     */
	    ByteBufferPrototype.toString = function(encoding, begin, end) {
	        if (typeof encoding === 'undefined')
	            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
	        if (typeof encoding === 'number')
	            encoding = "utf8",
	            begin = encoding,
	            end = begin;
	        switch (encoding) {
	            case "utf8":
	                return this.toUTF8(begin, end);
	            case "base64":
	                return this.toBase64(begin, end);
	            case "hex":
	                return this.toHex(begin, end);
	            case "binary":
	                return this.toBinary(begin, end);
	            case "debug":
	                return this.toDebug();
	            case "columns":
	                return this.toColumns();
	            default:
	                throw Error("Unsupported encoding: "+encoding);
	        }
	    };
	
	    // lxiv-embeddable
	
	    /**
	     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
	     * Released under the Apache License, Version 2.0
	     * see: https://github.com/dcodeIO/lxiv for details
	     */
	    var lxiv = function() {
	        "use strict";
	
	        /**
	         * lxiv namespace.
	         * @type {!Object.<string,*>}
	         * @exports lxiv
	         */
	        var lxiv = {};
	
	        /**
	         * Character codes for output.
	         * @type {!Array.<number>}
	         * @inner
	         */
	        var aout = [
	            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
	            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
	            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
	            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
	        ];
	
	        /**
	         * Character codes for input.
	         * @type {!Array.<number>}
	         * @inner
	         */
	        var ain = [];
	        for (var i=0, k=aout.length; i<k; ++i)
	            ain[aout[i]] = i;
	
	        /**
	         * Encodes bytes to base64 char codes.
	         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
	         *  there are no more bytes left.
	         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
	         *  code.
	         */
	        lxiv.encode = function(src, dst) {
	            var b, t;
	            while ((b = src()) !== null) {
	                dst(aout[(b>>2)&0x3f]);
	                t = (b&0x3)<<4;
	                if ((b = src()) !== null) {
	                    t |= (b>>4)&0xf;
	                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
	                    t = (b&0xf)<<2;
	                    if ((b = src()) !== null)
	                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
	                        dst(aout[b&0x3f]);
	                    else
	                        dst(aout[t&0x3f]),
	                        dst(61);
	                } else
	                    dst(aout[t&0x3f]),
	                    dst(61),
	                    dst(61);
	            }
	        };
	
	        /**
	         * Decodes base64 char codes to bytes.
	         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
	         *  `null` if there are no more characters left.
	         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
	         * @throws {Error} If a character code is invalid
	         */
	        lxiv.decode = function(src, dst) {
	            var c, t1, t2;
	            function fail(c) {
	                throw Error("Illegal character code: "+c);
	            }
	            while ((c = src()) !== null) {
	                t1 = ain[c];
	                if (typeof t1 === 'undefined') fail(c);
	                if ((c = src()) !== null) {
	                    t2 = ain[c];
	                    if (typeof t2 === 'undefined') fail(c);
	                    dst((t1<<2)>>>0|(t2&0x30)>>4);
	                    if ((c = src()) !== null) {
	                        t1 = ain[c];
	                        if (typeof t1 === 'undefined')
	                            if (c === 61) break; else fail(c);
	                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
	                        if ((c = src()) !== null) {
	                            t2 = ain[c];
	                            if (typeof t2 === 'undefined')
	                                if (c === 61) break; else fail(c);
	                            dst(((t1&0x3)<<6)>>>0|t2);
	                        }
	                    }
	                }
	            }
	        };
	
	        /**
	         * Tests if a string is valid base64.
	         * @param {string} str String to test
	         * @returns {boolean} `true` if valid, otherwise `false`
	         */
	        lxiv.test = function(str) {
	            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
	        };
	
	        return lxiv;
	    }();
	
	    // encodings/base64
	
	    /**
	     * Encodes this ByteBuffer's contents to a base64 encoded string.
	     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
	     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
	     * @returns {string} Base64 encoded string
	     * @throws {RangeError} If `begin` or `end` is out of bounds
	     * @expose
	     */
	    ByteBufferPrototype.toBase64 = function(begin, end) {
	        if (typeof begin === 'undefined')
	            begin = this.offset;
	        if (typeof end === 'undefined')
	            end = this.limit;
	        begin = begin | 0; end = end | 0;
	        if (begin < 0 || end > this.capacity || begin > end)
	            throw RangeError("begin, end");
	        var sd; lxiv.encode(function() {
	            return begin < end ? this.view[begin++] : null;
	        }.bind(this), sd = stringDestination());
	        return sd();
	    };
	
	    /**
	     * Decodes a base64 encoded string to a ByteBuffer.
	     * @param {string} str String to decode
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @returns {!ByteBuffer} ByteBuffer
	     * @expose
	     */
	    ByteBuffer.fromBase64 = function(str, littleEndian) {
	        if (typeof str !== 'string')
	            throw TypeError("str");
	        var bb = new ByteBuffer(str.length/4*3, littleEndian),
	            i = 0;
	        lxiv.decode(stringSource(str), function(b) {
	            bb.view[i++] = b;
	        });
	        bb.limit = i;
	        return bb;
	    };
	
	    /**
	     * Encodes a binary string to base64 like `window.btoa` does.
	     * @param {string} str Binary string
	     * @returns {string} Base64 encoded string
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
	     * @expose
	     */
	    ByteBuffer.btoa = function(str) {
	        return ByteBuffer.fromBinary(str).toBase64();
	    };
	
	    /**
	     * Decodes a base64 encoded string to binary like `window.atob` does.
	     * @param {string} b64 Base64 encoded string
	     * @returns {string} Binary string
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
	     * @expose
	     */
	    ByteBuffer.atob = function(b64) {
	        return ByteBuffer.fromBase64(b64).toBinary();
	    };
	
	    // encodings/binary
	
	    /**
	     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
	     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
	     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
	     * @returns {string} Binary encoded string
	     * @throws {RangeError} If `offset > limit`
	     * @expose
	     */
	    ByteBufferPrototype.toBinary = function(begin, end) {
	        if (typeof begin === 'undefined')
	            begin = this.offset;
	        if (typeof end === 'undefined')
	            end = this.limit;
	        begin |= 0; end |= 0;
	        if (begin < 0 || end > this.capacity() || begin > end)
	            throw RangeError("begin, end");
	        if (begin === end)
	            return "";
	        var chars = [],
	            parts = [];
	        while (begin < end) {
	            chars.push(this.view[begin++]);
	            if (chars.length >= 1024)
	                parts.push(String.fromCharCode.apply(String, chars)),
	                chars = [];
	        }
	        return parts.join('') + String.fromCharCode.apply(String, chars);
	    };
	
	    /**
	     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
	     * @param {string} str String to decode
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @returns {!ByteBuffer} ByteBuffer
	     * @expose
	     */
	    ByteBuffer.fromBinary = function(str, littleEndian) {
	        if (typeof str !== 'string')
	            throw TypeError("str");
	        var i = 0,
	            k = str.length,
	            charCode,
	            bb = new ByteBuffer(k, littleEndian);
	        while (i<k) {
	            charCode = str.charCodeAt(i);
	            if (charCode > 0xff)
	                throw RangeError("illegal char code: "+charCode);
	            bb.view[i++] = charCode;
	        }
	        bb.limit = k;
	        return bb;
	    };
	
	    // encodings/debug
	
	    /**
	     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
	     * * `<` : offset,
	     * * `'` : markedOffset,
	     * * `>` : limit,
	     * * `|` : offset and limit,
	     * * `[` : offset and markedOffset,
	     * * `]` : markedOffset and limit,
	     * * `!` : offset, markedOffset and limit
	     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
	     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
	     * @expose
	     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
	     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
	     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
	     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
	     */
	    ByteBufferPrototype.toDebug = function(columns) {
	        var i = -1,
	            k = this.buffer.byteLength,
	            b,
	            hex = "",
	            asc = "",
	            out = "";
	        while (i<k) {
	            if (i !== -1) {
	                b = this.view[i];
	                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
	                else hex += b.toString(16).toUpperCase();
	                if (columns)
	                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
	            }
	            ++i;
	            if (columns) {
	                if (i > 0 && i % 16 === 0 && i !== k) {
	                    while (hex.length < 3*16+3) hex += " ";
	                    out += hex+asc+"\n";
	                    hex = asc = "";
	                }
	            }
	            if (i === this.offset && i === this.limit)
	                hex += i === this.markedOffset ? "!" : "|";
	            else if (i === this.offset)
	                hex += i === this.markedOffset ? "[" : "<";
	            else if (i === this.limit)
	                hex += i === this.markedOffset ? "]" : ">";
	            else
	                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
	        }
	        if (columns && hex !== " ") {
	            while (hex.length < 3*16+3)
	                hex += " ";
	            out += hex + asc + "\n";
	        }
	        return columns ? out : hex;
	    };
	
	    /**
	     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
	     * @param {string} str Debug string to decode (not be generated with `columns = true`)
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @returns {!ByteBuffer} ByteBuffer
	     * @expose
	     * @see ByteBuffer#toDebug
	     */
	    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
	        var k = str.length,
	            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
	        var i = 0, j = 0, ch, b,
	            rs = false, // Require symbol next
	            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
	            fail = false;
	        while (i<k) {
	            switch (ch = str.charAt(i++)) {
	                case '!':
	                    if (!noAssert) {
	                        if (ho || hm || hl) {
	                            fail = true;
	                            break;
	                        }
	                        ho = hm = hl = true;
	                    }
	                    bb.offset = bb.markedOffset = bb.limit = j;
	                    rs = false;
	                    break;
	                case '|':
	                    if (!noAssert) {
	                        if (ho || hl) {
	                            fail = true;
	                            break;
	                        }
	                        ho = hl = true;
	                    }
	                    bb.offset = bb.limit = j;
	                    rs = false;
	                    break;
	                case '[':
	                    if (!noAssert) {
	                        if (ho || hm) {
	                            fail = true;
	                            break;
	                        }
	                        ho = hm = true;
	                    }
	                    bb.offset = bb.markedOffset = j;
	                    rs = false;
	                    break;
	                case '<':
	                    if (!noAssert) {
	                        if (ho) {
	                            fail = true;
	                            break;
	                        }
	                        ho = true;
	                    }
	                    bb.offset = j;
	                    rs = false;
	                    break;
	                case ']':
	                    if (!noAssert) {
	                        if (hl || hm) {
	                            fail = true;
	                            break;
	                        }
	                        hl = hm = true;
	                    }
	                    bb.limit = bb.markedOffset = j;
	                    rs = false;
	                    break;
	                case '>':
	                    if (!noAssert) {
	                        if (hl) {
	                            fail = true;
	                            break;
	                        }
	                        hl = true;
	                    }
	                    bb.limit = j;
	                    rs = false;
	                    break;
	                case "'":
	                    if (!noAssert) {
	                        if (hm) {
	                            fail = true;
	                            break;
	                        }
	                        hm = true;
	                    }
	                    bb.markedOffset = j;
	                    rs = false;
	                    break;
	                case ' ':
	                    rs = false;
	                    break;
	                default:
	                    if (!noAssert) {
	                        if (rs) {
	                            fail = true;
	                            break;
	                        }
	                    }
	                    b = parseInt(ch+str.charAt(i++), 16);
	                    if (!noAssert) {
	                        if (isNaN(b) || b < 0 || b > 255)
	                            throw TypeError("Illegal str: Not a debug encoded string");
	                    }
	                    bb.view[j++] = b;
	                    rs = true;
	            }
	            if (fail)
	                throw TypeError("Illegal str: Invalid symbol at "+i);
	        }
	        if (!noAssert) {
	            if (!ho || !hl)
	                throw TypeError("Illegal str: Missing offset or limit");
	            if (j<bb.buffer.byteLength)
	                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
	        }
	        return bb;
	    };
	
	    // encodings/hex
	
	    /**
	     * Encodes this ByteBuffer's contents to a hex encoded string.
	     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
	     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
	     * @returns {string} Hex encoded string
	     * @expose
	     */
	    ByteBufferPrototype.toHex = function(begin, end) {
	        begin = typeof begin === 'undefined' ? this.offset : begin;
	        end = typeof end === 'undefined' ? this.limit : end;
	        if (!this.noAssert) {
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        var out = new Array(end - begin),
	            b;
	        while (begin < end) {
	            b = this.view[begin++];
	            if (b < 0x10)
	                out.push("0", b.toString(16));
	            else out.push(b.toString(16));
	        }
	        return out.join('');
	    };
	
	    /**
	     * Decodes a hex encoded string to a ByteBuffer.
	     * @param {string} str String to decode
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @returns {!ByteBuffer} ByteBuffer
	     * @expose
	     */
	    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
	        if (!noAssert) {
	            if (typeof str !== 'string')
	                throw TypeError("Illegal str: Not a string");
	            if (str.length % 2 !== 0)
	                throw TypeError("Illegal str: Length not a multiple of 2");
	        }
	        var k = str.length,
	            bb = new ByteBuffer((k / 2) | 0, littleEndian),
	            b;
	        for (var i=0, j=0; i<k; i+=2) {
	            b = parseInt(str.substring(i, i+2), 16);
	            if (!noAssert)
	                if (!isFinite(b) || b < 0 || b > 255)
	                    throw TypeError("Illegal str: Contains non-hex characters");
	            bb.view[j++] = b;
	        }
	        bb.limit = j;
	        return bb;
	    };
	
	    // utfx-embeddable
	
	    /**
	     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
	     * Released under the Apache License, Version 2.0
	     * see: https://github.com/dcodeIO/utfx for details
	     */
	    var utfx = function() {
	        "use strict";
	
	        /**
	         * utfx namespace.
	         * @inner
	         * @type {!Object.<string,*>}
	         */
	        var utfx = {};
	
	        /**
	         * Maximum valid code point.
	         * @type {number}
	         * @const
	         */
	        utfx.MAX_CODEPOINT = 0x10FFFF;
	
	        /**
	         * Encodes UTF8 code points to UTF8 bytes.
	         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
	         *  respectively `null` if there are no more code points left or a single numeric code point.
	         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
	         */
	        utfx.encodeUTF8 = function(src, dst) {
	            var cp = null;
	            if (typeof src === 'number')
	                cp = src,
	                src = function() { return null; };
	            while (cp !== null || (cp = src()) !== null) {
	                if (cp < 0x80)
	                    dst(cp&0x7F);
	                else if (cp < 0x800)
	                    dst(((cp>>6)&0x1F)|0xC0),
	                    dst((cp&0x3F)|0x80);
	                else if (cp < 0x10000)
	                    dst(((cp>>12)&0x0F)|0xE0),
	                    dst(((cp>>6)&0x3F)|0x80),
	                    dst((cp&0x3F)|0x80);
	                else
	                    dst(((cp>>18)&0x07)|0xF0),
	                    dst(((cp>>12)&0x3F)|0x80),
	                    dst(((cp>>6)&0x3F)|0x80),
	                    dst((cp&0x3F)|0x80);
	                cp = null;
	            }
	        };
	
	        /**
	         * Decodes UTF8 bytes to UTF8 code points.
	         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
	         *  are no more bytes left.
	         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
	         * @throws {RangeError} If a starting byte is invalid in UTF8
	         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
	         *  remaining bytes.
	         */
	        utfx.decodeUTF8 = function(src, dst) {
	            var a, b, c, d, fail = function(b) {
	                b = b.slice(0, b.indexOf(null));
	                var err = Error(b.toString());
	                err.name = "TruncatedError";
	                err['bytes'] = b;
	                throw err;
	            };
	            while ((a = src()) !== null) {
	                if ((a&0x80) === 0)
	                    dst(a);
	                else if ((a&0xE0) === 0xC0)
	                    ((b = src()) === null) && fail([a, b]),
	                    dst(((a&0x1F)<<6) | (b&0x3F));
	                else if ((a&0xF0) === 0xE0)
	                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
	                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
	                else if ((a&0xF8) === 0xF0)
	                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
	                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
	                else throw RangeError("Illegal starting byte: "+a);
	            }
	        };
	
	        /**
	         * Converts UTF16 characters to UTF8 code points.
	         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
	         *  `null` if there are no more characters left.
	         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
	         *  point.
	         */
	        utfx.UTF16toUTF8 = function(src, dst) {
	            var c1, c2 = null;
	            while (true) {
	                if ((c1 = c2 !== null ? c2 : src()) === null)
	                    break;
	                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
	                    if ((c2 = src()) !== null) {
	                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
	                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
	                            c2 = null; continue;
	                        }
	                    }
	                }
	                dst(c1);
	            }
	            if (c2 !== null) dst(c2);
	        };
	
	        /**
	         * Converts UTF8 code points to UTF16 characters.
	         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
	         *  respectively `null` if there are no more code points left or a single numeric code point.
	         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
	         * @throws {RangeError} If a code point is out of range
	         */
	        utfx.UTF8toUTF16 = function(src, dst) {
	            var cp = null;
	            if (typeof src === 'number')
	                cp = src, src = function() { return null; };
	            while (cp !== null || (cp = src()) !== null) {
	                if (cp <= 0xFFFF)
	                    dst(cp);
	                else
	                    cp -= 0x10000,
	                    dst((cp>>10)+0xD800),
	                    dst((cp%0x400)+0xDC00);
	                cp = null;
	            }
	        };
	
	        /**
	         * Converts and encodes UTF16 characters to UTF8 bytes.
	         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
	         *  if there are no more characters left.
	         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
	         */
	        utfx.encodeUTF16toUTF8 = function(src, dst) {
	            utfx.UTF16toUTF8(src, function(cp) {
	                utfx.encodeUTF8(cp, dst);
	            });
	        };
	
	        /**
	         * Decodes and converts UTF8 bytes to UTF16 characters.
	         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
	         *  are no more bytes left.
	         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
	         * @throws {RangeError} If a starting byte is invalid in UTF8
	         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
	         */
	        utfx.decodeUTF8toUTF16 = function(src, dst) {
	            utfx.decodeUTF8(src, function(cp) {
	                utfx.UTF8toUTF16(cp, dst);
	            });
	        };
	
	        /**
	         * Calculates the byte length of an UTF8 code point.
	         * @param {number} cp UTF8 code point
	         * @returns {number} Byte length
	         */
	        utfx.calculateCodePoint = function(cp) {
	            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
	        };
	
	        /**
	         * Calculates the number of UTF8 bytes required to store UTF8 code points.
	         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
	         *  `null` if there are no more code points left.
	         * @returns {number} The number of UTF8 bytes required
	         */
	        utfx.calculateUTF8 = function(src) {
	            var cp, l=0;
	            while ((cp = src()) !== null)
	                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
	            return l;
	        };
	
	        /**
	         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
	         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
	         *  `null` if there are no more characters left.
	         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
	         */
	        utfx.calculateUTF16asUTF8 = function(src) {
	            var n=0, l=0;
	            utfx.UTF16toUTF8(src, function(cp) {
	                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
	            });
	            return [n,l];
	        };
	
	        return utfx;
	    }();
	
	    // encodings/utf8
	
	    /**
	     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
	     *  string.
	     * @returns {string} Hex encoded string
	     * @throws {RangeError} If `offset > limit`
	     * @expose
	     */
	    ByteBufferPrototype.toUTF8 = function(begin, end) {
	        if (typeof begin === 'undefined') begin = this.offset;
	        if (typeof end === 'undefined') end = this.limit;
	        if (!this.noAssert) {
	            if (typeof begin !== 'number' || begin % 1 !== 0)
	                throw TypeError("Illegal begin: Not an integer");
	            begin >>>= 0;
	            if (typeof end !== 'number' || end % 1 !== 0)
	                throw TypeError("Illegal end: Not an integer");
	            end >>>= 0;
	            if (begin < 0 || begin > end || end > this.buffer.byteLength)
	                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
	        }
	        var sd; try {
	            utfx.decodeUTF8toUTF16(function() {
	                return begin < end ? this.view[begin++] : null;
	            }.bind(this), sd = stringDestination());
	        } catch (e) {
	            if (begin !== end)
	                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
	        }
	        return sd();
	    };
	
	    /**
	     * Decodes an UTF8 encoded string to a ByteBuffer.
	     * @param {string} str String to decode
	     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
	     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
	     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
	     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
	     * @returns {!ByteBuffer} ByteBuffer
	     * @expose
	     */
	    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
	        if (!noAssert)
	            if (typeof str !== 'string')
	                throw TypeError("Illegal str: Not a string");
	        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
	            i = 0;
	        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
	            bb.view[i++] = b;
	        });
	        bb.limit = i;
	        return bb;
	    };
	
	    return ByteBuffer;
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(175)(module)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*
	 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
	 Copyright 2009 The Closure Library Authors. All Rights Reserved.
	
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	
	 http://www.apache.org/licenses/LICENSE-2.0
	
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS-IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: https://github.com/dcodeIO/long.js for details
	 */
	(function(global, factory) {
	
	    /* AMD */ if ("function" === 'function' && __webpack_require__(218)["amd"])
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    /* CommonJS */ else if ("function" === 'function' && typeof module === "object" && module && module["exports"])
	        module["exports"] = factory();
	    /* Global */ else
	        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
	
	})(this, function() {
	    "use strict";
	
	    /**
	     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
	     *  See the from* functions below for more convenient ways of constructing Longs.
	     * @exports Long
	     * @class A Long class for representing a 64 bit two's-complement integer value.
	     * @param {number} low The low (signed) 32 bits of the long
	     * @param {number} high The high (signed) 32 bits of the long
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @constructor
	     */
	    function Long(low, high, unsigned) {
	
	        /**
	         * The low 32 bits as a signed value.
	         * @type {number}
	         */
	        this.low = low | 0;
	
	        /**
	         * The high 32 bits as a signed value.
	         * @type {number}
	         */
	        this.high = high | 0;
	
	        /**
	         * Whether unsigned or not.
	         * @type {boolean}
	         */
	        this.unsigned = !!unsigned;
	    }
	
	    // The internal representation of a long is the two given signed, 32-bit values.
	    // We use 32-bit pieces because these are the size of integers on which
	    // Javascript performs bit-operations.  For operations like addition and
	    // multiplication, we split each number into 16 bit pieces, which can easily be
	    // multiplied within Javascript's floating-point representation without overflow
	    // or change in sign.
	    //
	    // In the algorithms below, we frequently reduce the negative case to the
	    // positive case by negating the input(s) and then post-processing the result.
	    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
	    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	    // a positive number, it overflows back into a negative).  Not handling this
	    // case would often result in infinite recursion.
	    //
	    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
	    // methods on which they depend.
	
	    /**
	     * An indicator used to reliably determine if an object is a Long or not.
	     * @type {boolean}
	     * @const
	     * @private
	     */
	    Long.prototype.__isLong__;
	
	    Object.defineProperty(Long.prototype, "__isLong__", {
	        value: true,
	        enumerable: false,
	        configurable: false
	    });
	
	    /**
	     * @function
	     * @param {*} obj Object
	     * @returns {boolean}
	     * @inner
	     */
	    function isLong(obj) {
	        return (obj && obj["__isLong__"]) === true;
	    }
	
	    /**
	     * Tests if the specified object is a Long.
	     * @function
	     * @param {*} obj Object
	     * @returns {boolean}
	     */
	    Long.isLong = isLong;
	
	    /**
	     * A cache of the Long representations of small integer values.
	     * @type {!Object}
	     * @inner
	     */
	    var INT_CACHE = {};
	
	    /**
	     * A cache of the Long representations of small unsigned integer values.
	     * @type {!Object}
	     * @inner
	     */
	    var UINT_CACHE = {};
	
	    /**
	     * @param {number} value
	     * @param {boolean=} unsigned
	     * @returns {!Long}
	     * @inner
	     */
	    function fromInt(value, unsigned) {
	        var obj, cachedObj, cache;
	        if (unsigned) {
	            value >>>= 0;
	            if (cache = (0 <= value && value < 256)) {
	                cachedObj = UINT_CACHE[value];
	                if (cachedObj)
	                    return cachedObj;
	            }
	            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
	            if (cache)
	                UINT_CACHE[value] = obj;
	            return obj;
	        } else {
	            value |= 0;
	            if (cache = (-128 <= value && value < 128)) {
	                cachedObj = INT_CACHE[value];
	                if (cachedObj)
	                    return cachedObj;
	            }
	            obj = fromBits(value, value < 0 ? -1 : 0, false);
	            if (cache)
	                INT_CACHE[value] = obj;
	            return obj;
	        }
	    }
	
	    /**
	     * Returns a Long representing the given 32 bit integer value.
	     * @function
	     * @param {number} value The 32 bit integer in question
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @returns {!Long} The corresponding Long value
	     */
	    Long.fromInt = fromInt;
	
	    /**
	     * @param {number} value
	     * @param {boolean=} unsigned
	     * @returns {!Long}
	     * @inner
	     */
	    function fromNumber(value, unsigned) {
	        if (isNaN(value) || !isFinite(value))
	            return unsigned ? UZERO : ZERO;
	        if (unsigned) {
	            if (value < 0)
	                return UZERO;
	            if (value >= TWO_PWR_64_DBL)
	                return MAX_UNSIGNED_VALUE;
	        } else {
	            if (value <= -TWO_PWR_63_DBL)
	                return MIN_VALUE;
	            if (value + 1 >= TWO_PWR_63_DBL)
	                return MAX_VALUE;
	        }
	        if (value < 0)
	            return fromNumber(-value, unsigned).neg();
	        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
	    }
	
	    /**
	     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	     * @function
	     * @param {number} value The number in question
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @returns {!Long} The corresponding Long value
	     */
	    Long.fromNumber = fromNumber;
	
	    /**
	     * @param {number} lowBits
	     * @param {number} highBits
	     * @param {boolean=} unsigned
	     * @returns {!Long}
	     * @inner
	     */
	    function fromBits(lowBits, highBits, unsigned) {
	        return new Long(lowBits, highBits, unsigned);
	    }
	
	    /**
	     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
	     *  assumed to use 32 bits.
	     * @function
	     * @param {number} lowBits The low 32 bits
	     * @param {number} highBits The high 32 bits
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @returns {!Long} The corresponding Long value
	     */
	    Long.fromBits = fromBits;
	
	    /**
	     * @function
	     * @param {number} base
	     * @param {number} exponent
	     * @returns {number}
	     * @inner
	     */
	    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
	
	    /**
	     * @param {string} str
	     * @param {(boolean|number)=} unsigned
	     * @param {number=} radix
	     * @returns {!Long}
	     * @inner
	     */
	    function fromString(str, unsigned, radix) {
	        if (str.length === 0)
	            throw Error('empty string');
	        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
	            return ZERO;
	        if (typeof unsigned === 'number') {
	            // For goog.math.long compatibility
	            radix = unsigned,
	            unsigned = false;
	        } else {
	            unsigned = !! unsigned;
	        }
	        radix = radix || 10;
	        if (radix < 2 || 36 < radix)
	            throw RangeError('radix');
	
	        var p;
	        if ((p = str.indexOf('-')) > 0)
	            throw Error('interior hyphen');
	        else if (p === 0) {
	            return fromString(str.substring(1), unsigned, radix).neg();
	        }
	
	        // Do several (8) digits each time through the loop, so as to
	        // minimize the calls to the very expensive emulated div.
	        var radixToPower = fromNumber(pow_dbl(radix, 8));
	
	        var result = ZERO;
	        for (var i = 0; i < str.length; i += 8) {
	            var size = Math.min(8, str.length - i),
	                value = parseInt(str.substring(i, i + size), radix);
	            if (size < 8) {
	                var power = fromNumber(pow_dbl(radix, size));
	                result = result.mul(power).add(fromNumber(value));
	            } else {
	                result = result.mul(radixToPower);
	                result = result.add(fromNumber(value));
	            }
	        }
	        result.unsigned = unsigned;
	        return result;
	    }
	
	    /**
	     * Returns a Long representation of the given string, written using the specified radix.
	     * @function
	     * @param {string} str The textual representation of the Long
	     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
	     * @returns {!Long} The corresponding Long value
	     */
	    Long.fromString = fromString;
	
	    /**
	     * @function
	     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
	     * @returns {!Long}
	     * @inner
	     */
	    function fromValue(val) {
	        if (val /* is compatible */ instanceof Long)
	            return val;
	        if (typeof val === 'number')
	            return fromNumber(val);
	        if (typeof val === 'string')
	            return fromString(val);
	        // Throws for non-objects, converts non-instanceof Long:
	        return fromBits(val.low, val.high, val.unsigned);
	    }
	
	    /**
	     * Converts the specified value to a Long.
	     * @function
	     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
	     * @returns {!Long}
	     */
	    Long.fromValue = fromValue;
	
	    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
	    // no runtime penalty for these.
	
	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_16_DBL = 1 << 16;
	
	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_24_DBL = 1 << 24;
	
	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
	
	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
	
	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
	
	    /**
	     * @type {!Long}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var ZERO = fromInt(0);
	
	    /**
	     * Signed zero.
	     * @type {!Long}
	     */
	    Long.ZERO = ZERO;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var UZERO = fromInt(0, true);
	
	    /**
	     * Unsigned zero.
	     * @type {!Long}
	     */
	    Long.UZERO = UZERO;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var ONE = fromInt(1);
	
	    /**
	     * Signed one.
	     * @type {!Long}
	     */
	    Long.ONE = ONE;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var UONE = fromInt(1, true);
	
	    /**
	     * Unsigned one.
	     * @type {!Long}
	     */
	    Long.UONE = UONE;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var NEG_ONE = fromInt(-1);
	
	    /**
	     * Signed negative one.
	     * @type {!Long}
	     */
	    Long.NEG_ONE = NEG_ONE;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);
	
	    /**
	     * Maximum signed value.
	     * @type {!Long}
	     */
	    Long.MAX_VALUE = MAX_VALUE;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);
	
	    /**
	     * Maximum unsigned value.
	     * @type {!Long}
	     */
	    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
	
	    /**
	     * @type {!Long}
	     * @inner
	     */
	    var MIN_VALUE = fromBits(0, 0x80000000|0, false);
	
	    /**
	     * Minimum signed value.
	     * @type {!Long}
	     */
	    Long.MIN_VALUE = MIN_VALUE;
	
	    /**
	     * @alias Long.prototype
	     * @inner
	     */
	    var LongPrototype = Long.prototype;
	
	    /**
	     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
	     * @returns {number}
	     */
	    LongPrototype.toInt = function toInt() {
	        return this.unsigned ? this.low >>> 0 : this.low;
	    };
	
	    /**
	     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
	     * @returns {number}
	     */
	    LongPrototype.toNumber = function toNumber() {
	        if (this.unsigned)
	            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
	        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
	    };
	
	    /**
	     * Converts the Long to a string written in the specified radix.
	     * @param {number=} radix Radix (2-36), defaults to 10
	     * @returns {string}
	     * @override
	     * @throws {RangeError} If `radix` is out of range
	     */
	    LongPrototype.toString = function toString(radix) {
	        radix = radix || 10;
	        if (radix < 2 || 36 < radix)
	            throw RangeError('radix');
	        if (this.isZero())
	            return '0';
	        if (this.isNegative()) { // Unsigned Longs are never negative
	            if (this.eq(MIN_VALUE)) {
	                // We need to change the Long value before it can be negated, so we remove
	                // the bottom-most digit in this base and then recurse to do the rest.
	                var radixLong = fromNumber(radix),
	                    div = this.div(radixLong),
	                    rem1 = div.mul(radixLong).sub(this);
	                return div.toString(radix) + rem1.toInt().toString(radix);
	            } else
	                return '-' + this.neg().toString(radix);
	        }
	
	        // Do several (6) digits each time through the loop, so as to
	        // minimize the calls to the very expensive emulated div.
	        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
	            rem = this;
	        var result = '';
	        while (true) {
	            var remDiv = rem.div(radixToPower),
	                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
	                digits = intval.toString(radix);
	            rem = remDiv;
	            if (rem.isZero())
	                return digits + result;
	            else {
	                while (digits.length < 6)
	                    digits = '0' + digits;
	                result = '' + digits + result;
	            }
	        }
	    };
	
	    /**
	     * Gets the high 32 bits as a signed integer.
	     * @returns {number} Signed high bits
	     */
	    LongPrototype.getHighBits = function getHighBits() {
	        return this.high;
	    };
	
	    /**
	     * Gets the high 32 bits as an unsigned integer.
	     * @returns {number} Unsigned high bits
	     */
	    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
	        return this.high >>> 0;
	    };
	
	    /**
	     * Gets the low 32 bits as a signed integer.
	     * @returns {number} Signed low bits
	     */
	    LongPrototype.getLowBits = function getLowBits() {
	        return this.low;
	    };
	
	    /**
	     * Gets the low 32 bits as an unsigned integer.
	     * @returns {number} Unsigned low bits
	     */
	    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
	        return this.low >>> 0;
	    };
	
	    /**
	     * Gets the number of bits needed to represent the absolute value of this Long.
	     * @returns {number}
	     */
	    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
	        if (this.isNegative()) // Unsigned Longs are never negative
	            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
	        var val = this.high != 0 ? this.high : this.low;
	        for (var bit = 31; bit > 0; bit--)
	            if ((val & (1 << bit)) != 0)
	                break;
	        return this.high != 0 ? bit + 33 : bit + 1;
	    };
	
	    /**
	     * Tests if this Long's value equals zero.
	     * @returns {boolean}
	     */
	    LongPrototype.isZero = function isZero() {
	        return this.high === 0 && this.low === 0;
	    };
	
	    /**
	     * Tests if this Long's value is negative.
	     * @returns {boolean}
	     */
	    LongPrototype.isNegative = function isNegative() {
	        return !this.unsigned && this.high < 0;
	    };
	
	    /**
	     * Tests if this Long's value is positive.
	     * @returns {boolean}
	     */
	    LongPrototype.isPositive = function isPositive() {
	        return this.unsigned || this.high >= 0;
	    };
	
	    /**
	     * Tests if this Long's value is odd.
	     * @returns {boolean}
	     */
	    LongPrototype.isOdd = function isOdd() {
	        return (this.low & 1) === 1;
	    };
	
	    /**
	     * Tests if this Long's value is even.
	     * @returns {boolean}
	     */
	    LongPrototype.isEven = function isEven() {
	        return (this.low & 1) === 0;
	    };
	
	    /**
	     * Tests if this Long's value equals the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.equals = function equals(other) {
	        if (!isLong(other))
	            other = fromValue(other);
	        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
	            return false;
	        return this.high === other.high && this.low === other.low;
	    };
	
	    /**
	     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.eq = LongPrototype.equals;
	
	    /**
	     * Tests if this Long's value differs from the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.notEquals = function notEquals(other) {
	        return !this.eq(/* validates */ other);
	    };
	
	    /**
	     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.neq = LongPrototype.notEquals;
	
	    /**
	     * Tests if this Long's value is less than the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.lessThan = function lessThan(other) {
	        return this.comp(/* validates */ other) < 0;
	    };
	
	    /**
	     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.lt = LongPrototype.lessThan;
	
	    /**
	     * Tests if this Long's value is less than or equal the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
	        return this.comp(/* validates */ other) <= 0;
	    };
	
	    /**
	     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.lte = LongPrototype.lessThanOrEqual;
	
	    /**
	     * Tests if this Long's value is greater than the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.greaterThan = function greaterThan(other) {
	        return this.comp(/* validates */ other) > 0;
	    };
	
	    /**
	     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.gt = LongPrototype.greaterThan;
	
	    /**
	     * Tests if this Long's value is greater than or equal the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
	        return this.comp(/* validates */ other) >= 0;
	    };
	
	    /**
	     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     */
	    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
	
	    /**
	     * Compares this Long's value with the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
	     *  if the given one is greater
	     */
	    LongPrototype.compare = function compare(other) {
	        if (!isLong(other))
	            other = fromValue(other);
	        if (this.eq(other))
	            return 0;
	        var thisNeg = this.isNegative(),
	            otherNeg = other.isNegative();
	        if (thisNeg && !otherNeg)
	            return -1;
	        if (!thisNeg && otherNeg)
	            return 1;
	        // At this point the sign bits are the same
	        if (!this.unsigned)
	            return this.sub(other).isNegative() ? -1 : 1;
	        // Both are positive if at least one is unsigned
	        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
	    };
	
	    /**
	     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
	     *  if the given one is greater
	     */
	    LongPrototype.comp = LongPrototype.compare;
	
	    /**
	     * Negates this Long's value.
	     * @returns {!Long} Negated Long
	     */
	    LongPrototype.negate = function negate() {
	        if (!this.unsigned && this.eq(MIN_VALUE))
	            return MIN_VALUE;
	        return this.not().add(ONE);
	    };
	
	    /**
	     * Negates this Long's value. This is an alias of {@link Long#negate}.
	     * @function
	     * @returns {!Long} Negated Long
	     */
	    LongPrototype.neg = LongPrototype.negate;
	
	    /**
	     * Returns the sum of this and the specified Long.
	     * @param {!Long|number|string} addend Addend
	     * @returns {!Long} Sum
	     */
	    LongPrototype.add = function add(addend) {
	        if (!isLong(addend))
	            addend = fromValue(addend);
	
	        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	        var a48 = this.high >>> 16;
	        var a32 = this.high & 0xFFFF;
	        var a16 = this.low >>> 16;
	        var a00 = this.low & 0xFFFF;
	
	        var b48 = addend.high >>> 16;
	        var b32 = addend.high & 0xFFFF;
	        var b16 = addend.low >>> 16;
	        var b00 = addend.low & 0xFFFF;
	
	        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	        c00 += a00 + b00;
	        c16 += c00 >>> 16;
	        c00 &= 0xFFFF;
	        c16 += a16 + b16;
	        c32 += c16 >>> 16;
	        c16 &= 0xFFFF;
	        c32 += a32 + b32;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c48 += a48 + b48;
	        c48 &= 0xFFFF;
	        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
	    };
	
	    /**
	     * Returns the difference of this and the specified Long.
	     * @param {!Long|number|string} subtrahend Subtrahend
	     * @returns {!Long} Difference
	     */
	    LongPrototype.subtract = function subtract(subtrahend) {
	        if (!isLong(subtrahend))
	            subtrahend = fromValue(subtrahend);
	        return this.add(subtrahend.neg());
	    };
	
	    /**
	     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
	     * @function
	     * @param {!Long|number|string} subtrahend Subtrahend
	     * @returns {!Long} Difference
	     */
	    LongPrototype.sub = LongPrototype.subtract;
	
	    /**
	     * Returns the product of this and the specified Long.
	     * @param {!Long|number|string} multiplier Multiplier
	     * @returns {!Long} Product
	     */
	    LongPrototype.multiply = function multiply(multiplier) {
	        if (this.isZero())
	            return ZERO;
	        if (!isLong(multiplier))
	            multiplier = fromValue(multiplier);
	        if (multiplier.isZero())
	            return ZERO;
	        if (this.eq(MIN_VALUE))
	            return multiplier.isOdd() ? MIN_VALUE : ZERO;
	        if (multiplier.eq(MIN_VALUE))
	            return this.isOdd() ? MIN_VALUE : ZERO;
	
	        if (this.isNegative()) {
	            if (multiplier.isNegative())
	                return this.neg().mul(multiplier.neg());
	            else
	                return this.neg().mul(multiplier).neg();
	        } else if (multiplier.isNegative())
	            return this.mul(multiplier.neg()).neg();
	
	        // If both longs are small, use float multiplication
	        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
	            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
	
	        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
	        // We can skip products that would overflow.
	
	        var a48 = this.high >>> 16;
	        var a32 = this.high & 0xFFFF;
	        var a16 = this.low >>> 16;
	        var a00 = this.low & 0xFFFF;
	
	        var b48 = multiplier.high >>> 16;
	        var b32 = multiplier.high & 0xFFFF;
	        var b16 = multiplier.low >>> 16;
	        var b00 = multiplier.low & 0xFFFF;
	
	        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	        c00 += a00 * b00;
	        c16 += c00 >>> 16;
	        c00 &= 0xFFFF;
	        c16 += a16 * b00;
	        c32 += c16 >>> 16;
	        c16 &= 0xFFFF;
	        c16 += a00 * b16;
	        c32 += c16 >>> 16;
	        c16 &= 0xFFFF;
	        c32 += a32 * b00;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c32 += a16 * b16;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c32 += a00 * b32;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	        c48 &= 0xFFFF;
	        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
	    };
	
	    /**
	     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
	     * @function
	     * @param {!Long|number|string} multiplier Multiplier
	     * @returns {!Long} Product
	     */
	    LongPrototype.mul = LongPrototype.multiply;
	
	    /**
	     * Returns this Long divided by the specified. The result is signed if this Long is signed or
	     *  unsigned if this Long is unsigned.
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Quotient
	     */
	    LongPrototype.divide = function divide(divisor) {
	        if (!isLong(divisor))
	            divisor = fromValue(divisor);
	        if (divisor.isZero())
	            throw Error('division by zero');
	        if (this.isZero())
	            return this.unsigned ? UZERO : ZERO;
	        var approx, rem, res;
	        if (!this.unsigned) {
	            // This section is only relevant for signed longs and is derived from the
	            // closure library as a whole.
	            if (this.eq(MIN_VALUE)) {
	                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
	                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	                else if (divisor.eq(MIN_VALUE))
	                    return ONE;
	                else {
	                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	                    var halfThis = this.shr(1);
	                    approx = halfThis.div(divisor).shl(1);
	                    if (approx.eq(ZERO)) {
	                        return divisor.isNegative() ? ONE : NEG_ONE;
	                    } else {
	                        rem = this.sub(divisor.mul(approx));
	                        res = approx.add(rem.div(divisor));
	                        return res;
	                    }
	                }
	            } else if (divisor.eq(MIN_VALUE))
	                return this.unsigned ? UZERO : ZERO;
	            if (this.isNegative()) {
	                if (divisor.isNegative())
	                    return this.neg().div(divisor.neg());
	                return this.neg().div(divisor).neg();
	            } else if (divisor.isNegative())
	                return this.div(divisor.neg()).neg();
	            res = ZERO;
	        } else {
	            // The algorithm below has not been made for unsigned longs. It's therefore
	            // required to take special care of the MSB prior to running it.
	            if (!divisor.unsigned)
	                divisor = divisor.toUnsigned();
	            if (divisor.gt(this))
	                return UZERO;
	            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
	                return UONE;
	            res = UZERO;
	        }
	
	        // Repeat the following until the remainder is less than other:  find a
	        // floating-point that approximates remainder / other *from below*, add this
	        // into the result, and subtract it from the remainder.  It is critical that
	        // the approximate value is less than or equal to the real value so that the
	        // remainder never becomes negative.
	        rem = this;
	        while (rem.gte(divisor)) {
	            // Approximate the result of division. This may be a little greater or
	            // smaller than the actual value.
	            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
	
	            // We will tweak the approximate result by changing it in the 48-th digit or
	            // the smallest non-fractional digit, whichever is larger.
	            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
	                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),
	
	            // Decrease the approximation until it is smaller than the remainder.  Note
	            // that if it is too large, the product overflows and is negative.
	                approxRes = fromNumber(approx),
	                approxRem = approxRes.mul(divisor);
	            while (approxRem.isNegative() || approxRem.gt(rem)) {
	                approx -= delta;
	                approxRes = fromNumber(approx, this.unsigned);
	                approxRem = approxRes.mul(divisor);
	            }
	
	            // We know the answer can't be zero... and actually, zero would cause
	            // infinite recursion since we would make no progress.
	            if (approxRes.isZero())
	                approxRes = ONE;
	
	            res = res.add(approxRes);
	            rem = rem.sub(approxRem);
	        }
	        return res;
	    };
	
	    /**
	     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
	     * @function
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Quotient
	     */
	    LongPrototype.div = LongPrototype.divide;
	
	    /**
	     * Returns this Long modulo the specified.
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Remainder
	     */
	    LongPrototype.modulo = function modulo(divisor) {
	        if (!isLong(divisor))
	            divisor = fromValue(divisor);
	        return this.sub(this.div(divisor).mul(divisor));
	    };
	
	    /**
	     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
	     * @function
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Remainder
	     */
	    LongPrototype.mod = LongPrototype.modulo;
	
	    /**
	     * Returns the bitwise NOT of this Long.
	     * @returns {!Long}
	     */
	    LongPrototype.not = function not() {
	        return fromBits(~this.low, ~this.high, this.unsigned);
	    };
	
	    /**
	     * Returns the bitwise AND of this Long and the specified.
	     * @param {!Long|number|string} other Other Long
	     * @returns {!Long}
	     */
	    LongPrototype.and = function and(other) {
	        if (!isLong(other))
	            other = fromValue(other);
	        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
	    };
	
	    /**
	     * Returns the bitwise OR of this Long and the specified.
	     * @param {!Long|number|string} other Other Long
	     * @returns {!Long}
	     */
	    LongPrototype.or = function or(other) {
	        if (!isLong(other))
	            other = fromValue(other);
	        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
	    };
	
	    /**
	     * Returns the bitwise XOR of this Long and the given one.
	     * @param {!Long|number|string} other Other Long
	     * @returns {!Long}
	     */
	    LongPrototype.xor = function xor(other) {
	        if (!isLong(other))
	            other = fromValue(other);
	        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
	    };
	
	    /**
	     * Returns this Long with bits shifted to the left by the given amount.
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     */
	    LongPrototype.shiftLeft = function shiftLeft(numBits) {
	        if (isLong(numBits))
	            numBits = numBits.toInt();
	        if ((numBits &= 63) === 0)
	            return this;
	        else if (numBits < 32)
	            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
	        else
	            return fromBits(0, this.low << (numBits - 32), this.unsigned);
	    };
	
	    /**
	     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
	     * @function
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     */
	    LongPrototype.shl = LongPrototype.shiftLeft;
	
	    /**
	     * Returns this Long with bits arithmetically shifted to the right by the given amount.
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     */
	    LongPrototype.shiftRight = function shiftRight(numBits) {
	        if (isLong(numBits))
	            numBits = numBits.toInt();
	        if ((numBits &= 63) === 0)
	            return this;
	        else if (numBits < 32)
	            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
	        else
	            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
	    };
	
	    /**
	     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
	     * @function
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     */
	    LongPrototype.shr = LongPrototype.shiftRight;
	
	    /**
	     * Returns this Long with bits logically shifted to the right by the given amount.
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     */
	    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
	        if (isLong(numBits))
	            numBits = numBits.toInt();
	        numBits &= 63;
	        if (numBits === 0)
	            return this;
	        else {
	            var high = this.high;
	            if (numBits < 32) {
	                var low = this.low;
	                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
	            } else if (numBits === 32)
	                return fromBits(high, 0, this.unsigned);
	            else
	                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
	        }
	    };
	
	    /**
	     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
	     * @function
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     */
	    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
	
	    /**
	     * Converts this Long to signed.
	     * @returns {!Long} Signed long
	     */
	    LongPrototype.toSigned = function toSigned() {
	        if (!this.unsigned)
	            return this;
	        return fromBits(this.low, this.high, false);
	    };
	
	    /**
	     * Converts this Long to unsigned.
	     * @returns {!Long} Unsigned long
	     */
	    LongPrototype.toUnsigned = function toUnsigned() {
	        if (this.unsigned)
	            return this;
	        return fromBits(this.low, this.high, true);
	    };
	
	    /**
	     * Converts this Long to its byte representation.
	     * @param {boolean=} le Whether little or big endian, defaults to big endian
	     * @returns {!Array.<number>} Byte representation
	     */
	    LongPrototype.toBytes = function(le) {
	        return le ? this.toBytesLE() : this.toBytesBE();
	    }
	
	    /**
	     * Converts this Long to its little endian byte representation.
	     * @returns {!Array.<number>} Little endian byte representation
	     */
	    LongPrototype.toBytesLE = function() {
	        var hi = this.high,
	            lo = this.low;
	        return [
	             lo         & 0xff,
	            (lo >>>  8) & 0xff,
	            (lo >>> 16) & 0xff,
	            (lo >>> 24) & 0xff,
	             hi         & 0xff,
	            (hi >>>  8) & 0xff,
	            (hi >>> 16) & 0xff,
	            (hi >>> 24) & 0xff
	        ];
	    }
	
	    /**
	     * Converts this Long to its big endian byte representation.
	     * @returns {!Array.<number>} Big endian byte representation
	     */
	    LongPrototype.toBytesBE = function() {
	        var hi = this.high,
	            lo = this.low;
	        return [
	            (hi >>> 24) & 0xff,
	            (hi >>> 16) & 0xff,
	            (hi >>>  8) & 0xff,
	             hi         & 0xff,
	            (lo >>> 24) & 0xff,
	            (lo >>> 16) & 0xff,
	            (lo >>>  8) & 0xff,
	             lo         & 0xff
	        ];
	    }
	
	    return Long;
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(175)(module)))

/***/ },
/* 221 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 222 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 223 */
/***/ function(module, exports) {

	module.exports = "\n<div></div>\n";

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__vue_script__ = __webpack_require__(225)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\mission\\GcsEditMissionModal.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(226)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-3fe1ee62/GcsEditMissionModal.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getters = __webpack_require__(72);
	
	var _actions = __webpack_require__(69);
	
	exports.default = {
	    vuex: {
	        getters: {
	            missions: _getters.getMissions,
	            currentMissionIndex: _getters.getCurrentMissionIndex
	        },
	
	        actions: {
	            setCurrentMissionTitle: _actions.setCurrentMissionTitle
	        }
	    },
	
	    props: {
	        show: {
	            type: Boolean,
	            required: true,
	            twoWay: true
	        }
	    },
	
	    data: function data() {
	        return {
	            missionTitle: ''
	        };
	    },
	
	
	    computed: {
	        mission: function mission() {
	            if (this.currentMissionIndex === -1) {
	                return {};
	            }
	
	            return this.missions[this.currentMissionIndex];
	        }
	    },
	
	    methods: {
	        opened: function opened() {
	            this.missionTitle = this.mission.title || '';
	            this.$els.input.querySelector('input').focus();
	        },
	        save: function save() {
	            this.setCurrentMissionTitle(this.missionTitle);
	            this.show = false;
	        }
	    }
	};

/***/ },
/* 226 */
/***/ function(module, exports) {

	module.exports = "\n<ui-modal :show.sync=\"show\" class=\"gcs-edit-mission-modal\" header=\"Edit mission\" @opened=\"opened\">\n    <ui-textbox\n        label=\"Mission title\" name=\"mission_title\" :value.sync=\"missionTitle\"\n        validation-rules=\"required\" v-el:input\n    ></ui-textbox>\n\n    <div slot=\"footer\">\n        <ui-button color=\"primary\" @click=\"save\">Save</ui-button>\n        <ui-button @click=\"show = false\">Cancel</ui-button>\n    </div>\n</ui-modal>\n";

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(228);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(229);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _controller = __webpack_require__(230);
	
	var _controller2 = _interopRequireDefault(_controller);
	
	var _ControllerLayouts = __webpack_require__(231);
	
	var _ControllerLayouts2 = _interopRequireDefault(_ControllerLayouts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_controller2.default.layouts.register(_ControllerLayouts2.default);
	
	var ControllerManager = function () {
	    function ControllerManager(callback) {
	        (0, _classCallCheck3.default)(this, ControllerManager);
	
	        this.gamepads = {};
	        this.Controller = _controller2.default;
	        this.callback = this.broadcast = callback;
	
	        this.gamepadEvents = ['gc.button.press', 'gc.button.hold', 'gc.button.release', 'gc.analog.start', 'gc.analog.hold', 'gc.analog.change', 'gc.analog.end'];
	
	        this.initializeControllers();
	    }
	
	    (0, _createClass3.default)(ControllerManager, [{
	        key: 'initializeControllers',
	        value: function initializeControllers() {
	            var _this = this;
	
	            _controller2.default.search();
	
	            window.addEventListener('gc.controller.found', function (event) {
	                _this.broadcast('gc.controller.found', event.detail);
	                _this.gamepads[event.detail.controller.id] = event.detail.controller;
	            }, false);
	
	            window.addEventListener('gc.controller.lost', function (event) {
	                _this.broadcast('gc.controller.lost', event.detail);
	                delete _this.gamepads[event.detail.id];
	            }, false);
	
	            this.gamepadEvents.map(function (eventname) {
	                window.addEventListener(eventname, function (event) {
	                    _this.broadcast(eventname, event.detail);
	                }, false);
	            });
	        }
	    }]);
	    return ControllerManager;
	}();
	
	exports.default = ControllerManager;

/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(148);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define('controller.js', factory) :
	    (global.Controller = factory());
	}(this, (function () { 'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*! Controller.js - v1.0.0 - 2016-08-30 */
	function Controller(HTMLgamepad) {
	    "use strict";
	
	    if (HTMLgamepad.constructor.name !== "Gamepad") {
	        return false;
	    }
	    var id = HTMLgamepad.id;
	    var index = HTMLgamepad.index;
	    var timestamp = Date.now();
	    var RAF = null;
	    var lastUpdated = 0;
	    var analogMap = {};
	    var eventQueue = {};
	    var layoutInfo = {};
	    var connected = true;
	    var state = {};
	    var unknownLayout = true;
	    var settings = arguments[1] || false;
	    var gamepad = HTMLgamepad;
	    var _disconnectController = disconnectController.bind(this);
	    function updateController() {
	        if (!connected) {
	            window.cancelAnimationFrame(RAF);
	            RAF = null;
	            return;
	        }
	        checkInputs.call(this);
	        RAF = window.requestAnimationFrame(updateController.bind(this));
	    }
	    function checkInputs() {
	        gamepad = this.constructor.gamepads[index];
	        lastUpdated = performance.now();
	        loopThroughButtons.call(this);
	        if ("LEFT_ANALOG_STICK_HOR" in analogMap && "LEFT_ANALOG_STICK_VERT" in analogMap) {
	            processAnalogStick.call(this, "LEFT_ANALOG_STICK", {
	                x: getNormalizedAnalogInput(gamepad.axes[analogMap.LEFT_ANALOG_STICK_HOR]),
	                y: getNormalizedAnalogInput(gamepad.axes[analogMap.LEFT_ANALOG_STICK_VERT])
	            });
	        }
	        if ("RIGHT_ANALOG_STICK_HOR" in analogMap && "RIGHT_ANALOG_STICK_VERT" in analogMap) {
	            processAnalogStick.call(this, "RIGHT_ANALOG_STICK", {
	                x: getNormalizedAnalogInput(gamepad.axes[analogMap.RIGHT_ANALOG_STICK_HOR]),
	                y: getNormalizedAnalogInput(gamepad.axes[analogMap.RIGHT_ANALOG_STICK_VERT])
	            });
	        }
	        switch (this.settings.useAnalogAsDpad) {
	            case "left":
	                processAnalogAsDpad.call(this, "left");
	                break;
	
	            case "right":
	                processAnalogAsDpad.call(this, "right");
	                break;
	
	            case "both":
	                processAnalogAsDpad.call(this, "left");
	                processAnalogAsDpad.call(this, "right");
	                break;
	        }
	        for (var input in eventQueue) {
	            var event = eventQueue[input];
	            dispatchCustomEvent(event.name, event.detail, event.info);
	            delete eventQueue[input];
	        }
	    }
	    function setupController() {
	        this.settings = new GC_Settings();
	        if (settings) {
	            initSettings.call(this);
	        }
	        var layout = initControllerMapping.call(this);
	        initPreviousInputs.call(this, layout);
	        if (layout.init && typeof layout.init === "function") {
	            layout.init(gamepad);
	        }
	        if (this.constructor.controllerCount === 0) {
	            window.addEventListener("gamepaddisconnected", _disconnectController, false);
	        }
	        updateController.call(this);
	    }
	    function initControllerMapping() {
	        var layout = {};
	        if (gamepad.mapping === "standard") {
	            unknownLayout = false;
	            layout = this.constructor.layouts.get("standard");
	        } else if (this.constructor.layouts.has(this.name)) {
	            unknownLayout = false;
	            layout = this.constructor.layouts.get(this.name);
	        } else {
	            console.warn(GC_Errors.MAP);
	            layout = this.constructor.layouts.get("_unknown");
	        }
	        setLayoutInfo(layout);
	        if (unknownLayout) {
	            return layout;
	        }
	        var browser = getBrowser();
	        if (browser && browser in layout) {
	            layout = layout[browser];
	        }
	        for (var name in layout.axes) {
	            switch (name) {
	                case "LEFT_ANALOG_STICK_HOR":
	                case "LEFT_ANALOG_STICK_VERT":
	                case "RIGHT_ANALOG_STICK_HOR":
	                case "RIGHT_ANALOG_STICK_VERT":
	                    analogMap[name] = layout.axes[name];
	                    break;
	            }
	        }
	        layout.misc = {
	            L_DPAD_UP: 0,
	            L_DPAD_DOWN: 1,
	            L_DPAD_LEFT: 2,
	            L_DPAD_RIGHT: 3,
	            R_DPAD_UP: 4,
	            R_DPAD_DOWN: 5,
	            R_DPAD_LEFT: 6,
	            R_DPAD_RIGHT: 7
	        };
	        return layout;
	    }
	    function initPreviousInputs(layout) {
	        var buttonNames = [];
	        var axisNames = [];
	        lastUpdated = performance.now();
	        state.buttons = {};
	        state.axes = {};
	        state.misc = {};
	        for (var group in state) {
	            var map = layout[group];
	            for (var name in map) {
	                var inputIndex = map[name].index || map[name];
	                var type = map[name].type || group;
	                var data = map[name].data || undefined;
	                var options = {};
	                if (_typeof(map[name]) === "object") {
	                    options = {
	                        inputMin: map[name].inputMin || undefined,
	                        inputMax: map[name].inputMax || undefined,
	                        method: map[name].method || undefined,
	                        ignoreConversion: map[name].ignoreConversion || undefined
	                    };
	                }
	                if (type === "axes") {
	                    if (name.endsWith("_HOR")) {
	                        name = name.slice(0, -4);
	                    } else if (name.endsWith("_VERT")) {
	                        name = name.slice(0, -5);
	                    }
	                    state[type][name] = new AnalogStick(name, {
	                        map: [group, inputIndex],
	                        settings: this.settings,
	                        options: options,
	                        data: data
	                    });
	                    axisNames.push(inputIndex);
	                } else if (type === "buttons") {
	                    if (gamepad.buttons[inputIndex]) {
	                        state[type][name] = new Button(name, {
	                            map: [group, inputIndex],
	                            settings: this.settings,
	                            options: options,
	                            data: data
	                        });
	                    }
	                    buttonNames.push(inputIndex);
	                } else if (type === "misc") {
	                    state[type][name] = new Button(name, {
	                        map: [group, inputIndex],
	                        settings: this.settings,
	                        options: options,
	                        data: data
	                    });
	                }
	            }
	        }
	        if (layout.options && layout.options.allowsExtras) {
	            setupExtraButtons.call(this, buttonNames, "buttons");
	            setupExtraButtons.call(this, axisNames, "axes");
	        }
	    }
	    function initSettings() {
	        this.settings.update(settings);
	    }
	    function disconnectController(event) {
	        if (event.gamepad.index === this.index) {
	            connected = false;
	            this.unwatch.call(this);
	            delete this.constructor.controllers[this.index];
	            if (this.constructor.controllerCount === 0) {
	                window.removeEventListener("gamepaddisconnected", _disconnectController);
	            }
	            dispatchCustomEvent(this.constructor.events.getName("controller", "disconnect"), {
	                index: this.index,
	                timestamp: Date.now()
	            }, "Controller at index " + this.index + " disconnected.");
	        }
	    }
	    function setupExtraButtons(list, type) {
	        var prefix = type === "buttons" ? "BUTTON" : "AXIS";
	        var i = 0;
	        for (var _index in gamepad[type]) {
	            if (list.indexOf(parseInt(_index)) === -1) {
	                i++;
	                var name = "MISC" + prefix + "_" + i;
	                state.buttons[name] = new Button(name, {
	                    map: [type, _index],
	                    settings: this.settings
	                });
	            }
	        }
	    }
	    function setLayoutInfo(layout) {
	        layoutInfo.name = layout.name || undefined;
	        layoutInfo.description = layout.description || undefined;
	        layoutInfo.unknownLayout = unknownLayout || undefined;
	        for (var _index2 in layoutInfo) {
	            if (layoutInfo[_index2] === undefined) delete layoutInfo[_index2];
	        }
	    }
	    function loopThroughButtons() {
	        var inputs = state.buttons;
	        for (var name in inputs) {
	            var _index3 = inputs[name].getGamepadIndex();
	            var section = inputs[name].getGamepadSection();
	            var value = _typeof(gamepad[section][_index3]) === "object" ? gamepad[section][_index3].value : gamepad[section][_index3];
	            processButton.call(this, name, value);
	        }
	    }
	    function processButton(name, value) {
	        if (value === undefined) {
	            return;
	        }
	        var inputName = name.startsWith("L_") || name.startsWith("R_") ? name.substring(2) : name;
	        var button = state.buttons[name] || state.axes[name] || state.misc[name];
	        if (eventQueue[inputName] && eventQueue[inputName].name === this.constructor.events.getName("button", "during")) {
	            return;
	        }
	        if (typeof button.getOption("method") === "function") {
	            value = button.getOption("method").call(this, this.constructor.gamepads[this.index], button);
	        }
	        if (value !== button.value) {
	            button.hasUpdated = true;
	        }
	        if (!button.getOption("ignoreConversion") && button.hasUpdated) {
	            var min = button.getOption("inputMin") || 0;
	            var max = button.getOption("inputMax") || 1;
	            value = getLinearConversion(value, min, max, 0, 1);
	        }
	        var pressed = value > 0;
	        var previouslyPressed = button.value > 0;
	        if (!pressed && !previouslyPressed) {
	            return;
	        }
	        button.update(value);
	        var copy = button.copy();
	        copy.name = inputName;
	        if (pressed && !previouslyPressed) {
	            queueEvent(inputName, this.constructor.events.getName("button", "start"), copy);
	        } else if (pressed && previouslyPressed) {
	            queueEvent(inputName, this.constructor.events.getName("button", "during"), copy);
	        } else if (!pressed && previouslyPressed) {
	            queueEvent(inputName, this.constructor.events.getName("button", "end"), copy);
	        }
	    }
	    function processAnalogStick(name, input) {
	        if (input.x === undefined || input.y === undefined) {
	            return;
	        }
	        if (eventQueue[name] && eventQueue[name].name === this.constructor.events.getName("analog", "during")) {
	            return;
	        }
	        var analogStick = state.axes[name] || state.buttons[name] || state.misc[name];
	        var values = calculateAnalogValues.call(this, input);
	        var pressed = isAnalogStickPressed(values);
	        var previouslyPressed = isAnalogStickPressed(analogStick.position);
	        var previousValues = {
	            x: analogStick.position.x,
	            y: analogStick.position.y
	        };
	        if (!pressed && !previouslyPressed) {
	            return;
	        }
	        analogStick.update(values);
	        var changed = analogStick.position.x !== previousValues.x || analogStick.position.y !== previousValues.y;
	        var copy = analogStick.copy();
	        if (pressed && !previouslyPressed) {
	            queueEvent(name + "start", this.constructor.events.getName("analog", "start"), copy);
	        } else if (pressed && previouslyPressed) {
	            queueEvent(name + "during", this.constructor.events.getName("analog", "during"), copy);
	        } else if (!pressed && previouslyPressed) {
	            queueEvent(name + "end", this.constructor.events.getName("analog", "end"), copy);
	        }
	        if (changed) {
	            queueEvent(name + "change", this.constructor.events.getName("analog", "change"), copy);
	        }
	    }
	    function processAnalogAsDpad(stick) {
	        var prefix = stick === "left" ? "L_" : "R_";
	        var analogStick = stick === "left" ? "LEFT_ANALOG_STICK" : "RIGHT_ANALOG_STICK";
	        var names = ["DPAD_UP", "DPAD_DOWN", "DPAD_LEFT", "DPAD_RIGHT"];
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var name = _step.value;
	
	                var inputAxis = 0;
	                var otherAxis = 0;
	                var isPastThreshold = false;
	                switch (name) {
	                    case "DPAD_UP":
	                        inputAxis = state.axes[analogStick].position.y;
	                        otherAxis = state.axes[analogStick].position.x;
	                        isPastThreshold = inputAxis <= this.settings.analogStickDpadThreshold * -1;
	                        break;
	
	                    case "DPAD_DOWN":
	                        inputAxis = state.axes[analogStick].position.y;
	                        otherAxis = state.axes[analogStick].position.x;
	                        isPastThreshold = inputAxis >= this.settings.analogStickDpadThreshold;
	                        break;
	
	                    case "DPAD_LEFT":
	                        inputAxis = state.axes[analogStick].position.x;
	                        otherAxis = state.axes[analogStick].position.y;
	                        isPastThreshold = inputAxis <= this.settings.analogStickDpadThreshold * -1;
	                        break;
	
	                    case "DPAD_RIGHT":
	                        inputAxis = state.axes[analogStick].position.x;
	                        otherAxis = state.axes[analogStick].position.y;
	                        isPastThreshold = inputAxis >= this.settings.analogStickDpadThreshold;
	                        break;
	                }
	                var value = isPastThreshold && Math.abs(inputAxis) > Math.abs(otherAxis) ? 1 : 0;
	                processButton.call(this, prefix + name, value);
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	    }
	    function calculateAnalogValues(values) {
	        var output = {
	            x: 0,
	            y: 0
	        };
	        if (values.x !== 0) {
	            output.x = getLinearConversion(Math.abs(values.x), this.settings.analogStickDeadzone.min, this.settings.analogStickDeadzone.max, 0, 1);
	            if (values.x < 0 && output.x !== 0) {
	                output.x *= -1;
	            }
	        }
	        if (values.y !== 0) {
	            output.y = getLinearConversion(Math.abs(values.y), this.settings.analogStickDeadzone.min, this.settings.analogStickDeadzone.max, 0, 1);
	            if (values.y < 0 && output.y !== 0) {
	                output.y *= -1;
	            }
	        }
	        return this.settings.mapAnalogToShape === "square" ? getCoordsMappedToSquare(output) : output;
	    }
	    function dispatchCustomEvent(eventName, detail, info) {
	        detail = detail || {};
	        info = info || undefined;
	        if (info) {
	            console.info(info);
	        }
	        var event = new CustomEvent(eventName, {
	            detail: detail,
	            bubbles: true,
	            cancelable: false
	        });
	        window.dispatchEvent(event);
	    }
	    function getCoordsMappedToSquare(coords) {
	        if (coords.x === 0 || coords.y === 0) {
	            return {
	                x: coords.x,
	                y: coords.y
	            };
	        } else {
	            var abs = {
	                x: Math.abs(coords.x),
	                y: Math.abs(coords.y)
	            };
	            var oldLength = Math.hypot(abs.x, abs.y);
	            var max = 1;
	            if (abs.x > abs.y) {
	                max = oldLength * (1 / abs.x);
	            } else {
	                max = oldLength * (1 / abs.y);
	            }
	            var newVals = getShortenedLineDistance(abs, getLinearConversion(oldLength, 0, 1, 0, max));
	            return {
	                x: coords.x > 0 ? newVals.x : -newVals.x,
	                y: coords.y > 0 ? newVals.y : -newVals.y
	            };
	        }
	    }
	    function getLinearConversion(value, oldMin, oldMax, newMin, newMax) {
	        var result = (value - oldMin) * (newMax - newMin) / (oldMax - oldMin) + newMin;
	        if (newMax < newMin) {
	            if (result < newMax) {
	                result = newMax;
	            } else if (result > newMin) {
	                result = newMin;
	            }
	        } else {
	            if (result > newMax) {
	                result = newMax;
	            } else if (result < newMin) {
	                result = newMin;
	            }
	        }
	        return result;
	    }
	    function getNormalizedAnalogInput(input) {
	        if (Math.abs(input) < .1) {
	            return 0;
	        } else {
	            return getLinearConversion(input, -.9, 1, -1, 1);
	        }
	    }
	    function getShortenedLineDistance(values, distance) {
	        var hypotenuse = Math.hypot(values.x, values.y);
	        var angle = Math.acos(values.y / hypotenuse);
	        return {
	            x: Math.sin(angle) * distance,
	            y: Math.cos(angle) * distance
	        };
	    }
	    function isAnalogStickPressed(values) {
	        return Math.abs(values.x) > 0 || Math.abs(values.y) > 0;
	    }
	    function queueEvent(input, eventName, detail, info) {
	        eventQueue[input] = {
	            name: eventName,
	            detail: detail || {},
	            info: info || undefined
	        };
	    }
	    function getBrowser() {
	        if ("chrome" in window) {
	            return "Chrome";
	        } else if ("opera" in window && {}.toString.call(window.opera) === "[object Opera]") {
	            return "Opera";
	        } else if ("MozAppearance" in document.documentElement.style) {
	            return "Mozilla";
	        } else if ("WebkitAppearance" in document.documentElement.style) {
	            return "Webkit";
	        } else {
	            return undefined;
	        }
	    }
	    this.watch = function () {
	        if (!RAF) {
	            updateController.call(this);
	        }
	    };
	    this.unwatch = function () {
	        if (RAF) {
	            window.cancelAnimationFrame(RAF);
	            RAF = undefined;
	        }
	    };
	    Object.defineProperty(this, "index", {
	        get: function get() {
	            return index;
	        }
	    });
	    Object.defineProperty(this, "id", {
	        get: function get() {
	            return id;
	        }
	    });
	    Object.defineProperty(this, "name", {
	        get: function get() {
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = Controller.layouts.regex[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var regex = _step2.value;
	
	                    if (regex.test(id)) {
	                        return id.match(regex)[1].trim();
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	        }
	    });
	    Object.defineProperty(this, "connectedTimestamp", {
	        get: function get() {
	            return timestamp;
	        }
	    });
	    Object.defineProperty(this, "layoutInfo", {
	        get: function get() {
	            return layoutInfo;
	        }
	    });
	    Object.defineProperty(this, "inputs", {
	        get: function get() {
	            var buttons = {};
	            var analogSticks = {};
	            for (var button in state.buttons) {
	                buttons[button] = state.buttons[button].copy();
	            }
	            for (var axis in state.axes) {
	                analogSticks[axis] = state.axes[axis].copy();
	            }
	            return {
	                buttons: buttons,
	                analogSticks: analogSticks
	            };
	        }
	    });
	    function Button(name, args) {
	        args = args || {};
	        var map = args.map || [];
	        var options = args.options || {};
	        var settings = args.settings || {};
	        var data = args.data || undefined;
	        var updated = false;
	        this.controllerIndex = index;
	        this.name = name;
	        this.value = 0;
	        setPressed.call(this);
	        setTime.call(this);
	        function setPressed() {
	            this.pressed = this.value > (settings.buttonThreshold || 0);
	        }
	        function setTime() {
	            this.time = lastUpdated;
	        }
	        this.getGamepadSection = function () {
	            return map[0];
	        };
	        this.getGamepadIndex = function () {
	            return map[1];
	        };
	        this.getOption = function (option) {
	            return options[option];
	        };
	        this.update = function (value) {
	            this.value = value;
	            setPressed.call(this);
	            setTime.call(this);
	            if (!updated) {
	                updated = true;
	            }
	        };
	        this.copy = function () {
	            var copy = {};
	            for (var property in this) {
	                if (typeof this[property] !== "function") {
	                    copy[property] = this[property];
	                }
	            }
	            return copy;
	        };
	        Object.defineProperty(this, "data", {
	            get: function get() {
	                return data;
	            },
	            set: function set(newData) {
	                data = newData;
	            }
	        });
	        Object.defineProperty(this, "hasUpdated", {
	            get: function get() {
	                return updated;
	            },
	            set: function set(hasUpdated) {
	                updated = hasUpdated;
	            }
	        });
	    }
	    function AnalogStick(name, args) {
	        args = args || {};
	        var map = args.map || [];
	        var options = args.options || {};
	        var settings = args.settings || {};
	        var data = args.data || undefined;
	        var updated = false;
	        this.controllerIndex = index;
	        this.name = name;
	        this.position = getPosition.call(this, {
	            x: 0,
	            y: 0
	        });
	        setAngle.call(this);
	        setTime.call(this);
	        function setAngle() {
	            var radians = coordinatesToRadians(this.position.x, -this.position.y);
	            var degrees = radiansToDegrees(radians);
	            this.angle = {
	                radians: getShortenedNumber(radians, 3),
	                degrees: getShortenedNumber(degrees, 3)
	            };
	        }
	        function setTime() {
	            this.time = lastUpdated;
	        }
	        function getPosition(values) {
	            return {
	                x: roundPosition(values.x),
	                y: roundPosition(values.y)
	            };
	        }
	        function coordinatesToRadians(x, y) {
	            if (x === 0 && y === 0) {
	                return NaN;
	            }
	            var radians = Math.atan2(y, x);
	            if (radians < 0) {
	                radians += 2 * Math.PI;
	            }
	            return Math.abs(radians);
	        }
	        function roundPosition(number) {
	            var result = 0;
	            if (Math.abs(number) > 1) {
	                result = Math.floor(number);
	                if (result === -2) {
	                    result = -1;
	                }
	            } else {
	                result = Math.fround(number);
	            }
	            return result;
	        }
	        function getShortenedNumber(number, places) {
	            var mult = Math.pow(10, places);
	            return Math.round(number * mult) / mult;
	        }
	        function radiansToDegrees(radians) {
	            if (isNaN(radians)) {
	                return NaN;
	            }
	            return radians * (180 / Math.PI);
	        }
	        this.getGamepadSection = function () {
	            return map[0];
	        };
	        this.getGamepadIndex = function () {
	            return map[1];
	        };
	        this.getOption = function (option) {
	            return options[option];
	        };
	        this.update = function (values) {
	            this.position = getPosition.call(this, values);
	            setAngle.call(this);
	            setTime.call(this);
	            if (!updated) {
	                updated = true;
	            }
	        };
	        this.copy = function () {
	            var copy = {};
	            for (var property in this) {
	                if (typeof this[property] !== "function") {
	                    copy[property] = this[property];
	                }
	            }
	            return copy;
	        };
	        Object.defineProperty(this, "data", {
	            get: function get() {
	                return data;
	            },
	            set: function set(newData) {
	                data = newData;
	            }
	        });
	        Object.defineProperty(this, "hasUpdated", {
	            get: function get() {
	                return updated;
	            },
	            set: function set(hasUpdated) {
	                updated = hasUpdated;
	            }
	        });
	    }
	    this._postSetup = function () {
	        var data = {
	            controller: this,
	            id: id,
	            index: index,
	            timestamp: timestamp
	        };
	        if (unknownLayout) {
	            data.unknownLayout = unknownLayout;
	        }
	        dispatchCustomEvent(this.constructor.events.getName("controller", "connect"), data, "Gamepad connected at index " + index + ".");
	    };
	    setupController.call(this);
	}
	
	Controller.search = function (options) {
	    var timer = options && options.interval || 500;
	    var limit = options && options.limit || undefined;
	    if (!Controller.supported) {
	        if (options && typeof options.unsupportedCallback === "function") {
	            options.unsupportedCallback();
	        }
	        return false;
	    }
	    this.interval = setInterval(function () {
	        if (limit !== undefined && this.controllerCount >= limit) {
	            clearInterval(this.interval);
	            return;
	        }
	        for (var index in this.gamepads) {
	            index = parseInt(index, 10);
	            if (isNaN(index)) {
	                return;
	            }
	            if (this.gamepads[index] !== null && this.gamepads[index] !== undefined && this.getController(index) === undefined) {
	                if (!this.controllers) {
	                    this.controllers = {};
	                }
	                var settings = {};
	                if (options && "settings" in options) {
	                    settings = options.settings;
	                }
	                this.controllers[index] = new Controller(this.gamepads[index], settings);
	                this.controllers[index]._postSetup.call(this.controllers[index]);
	            }
	        }
	    }.bind(this), timer);
	};
	
	Controller.getController = function (index) {
	    index = parseInt(index);
	    if (typeof index !== "number" || isNaN(index)) {
	        console.warn(index + " must be a number");
	    } else if (index % 1 !== 0) {
	        console.warn(index + " must be an int");
	    } else if (index < 0) {
	        console.warn(index + " must be positive");
	    }
	    return this.controllers && this.controllers[index];
	};
	
	Controller.watchAll = function () {
	    for (var index in Controller.controllers) {
	        Controller.getController(index).watch();
	    }
	};
	
	Controller.unwatchAll = function () {
	    for (var index in Controller.controllers) {
	        Controller.getController(index).unwatch();
	    }
	};
	
	Object.defineProperty(Controller, "controllerCount", {
	    get: function get() {
	        if (this.controllers) {
	            return Object.keys(this.controllers).length;
	        } else {
	            return 0;
	        }
	    }
	});
	
	Object.defineProperty(Controller, "supported", {
	    get: function get() {
	        try {
	            if (this.gamepads === null) {
	                throw "GAMEPAD";
	            } else if (!("defineProperty" in Object)) {
	                throw "DEFINEPROPERTY";
	            } else {
	                return true;
	            }
	        } catch (error) {
	            console.warn(GC_Errors[error]);
	            return false;
	        }
	    }
	});
	
	Object.defineProperty(Controller, "gamepads", {
	    get: function get() {
	        var gamepads = null;
	        if ("getGamepads" in navigator) {
	            gamepads = navigator.getGamepads();
	        } else if ("webkitGamepads" in navigator) {
	            gamepads = navigator.webkitGamepads();
	        } else if ("mozGamepads" in navigator) {
	            gamepads = navigator.mozGamepads();
	        } else if ("gamepads" in navigator) {
	            gamepads = navigator.gamepads();
	        }
	        return gamepads;
	    },
	    enumerable: false
	});
	
	Math.hypot = Math.hypot || function () {
	    var y = 0;
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = arguments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var arg = _step3.value;
	
	            if (arg === Infinity || arg === -Infinity) {
	                return Infinity;
	            }
	            y += arg * arg;
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	
	    return Math.sqrt(y);
	};
	
	Object.assign = Object.assign || function (target) {
	    "use strict";
	
	    if (target === null) {
	        throw new TypeError("Cannot convert undefined or null to object");
	    }
	    target = Object(target);
	    for (var index = 1; index < arguments.length; index++) {
	        var source = arguments[index];
	        if (source !== null) {
	            for (var key in source) {
	                if (Object.prototype.hasOwnProperty.call(source, key)) {
	                    target[key] = source[key];
	                }
	            }
	        }
	    }
	    return target;
	};
	
	var GC_Errors = {
	    get GAMEPAD() {
	        return "This browser does not support the Gamepad API.";
	    },
	    get DEFINEPROPERTY() {
	        return "This browser does not suppoert Object.defineProperty().";
	    },
	    get MAP() {
	        return 'No matching map found. Using "Standard".';
	    }
	};
	
	var GC_Events = function GC_Events() {
	    var pre = "gc";
	    this.getName = function (base, action) {
	        var message = [pre, this[base.toUpperCase()].base, this[base.toUpperCase()].actions[action]];
	        return message.join(".");
	    };
	};
	
	Object.defineProperty(GC_Events.prototype, "CONTROLLER", {
	    value: {
	        base: "controller",
	        actions: {
	            connect: "found",
	            disconnect: "lost"
	        }
	    }
	});
	
	Object.defineProperty(GC_Events.prototype, "BUTTON", {
	    value: {
	        base: "button",
	        actions: {
	            start: "press",
	            during: "hold",
	            end: "release"
	        }
	    }
	});
	
	Object.defineProperty(GC_Events.prototype, "ANALOG", {
	    value: {
	        base: "analog",
	        actions: {
	            start: "start",
	            during: "hold",
	            change: "change",
	            end: "end"
	        }
	    }
	});
	
	Controller.events = new GC_Events();
	
	var GC_Layouts = {
	    list: {
	        _unknown: {
	            name: "Unknown Layout",
	            description: "A fallback for when no appropriate layouts are found.",
	            options: {
	                allowsExtras: true
	            }
	        }
	    },
	    register: function register(map) {
	        var layouts = Controller.layouts;
	        var id = map.match;
	        for (var i = 0; i < layouts.regex.length; i++) {
	            var regex = this.regex[i];
	            if (regex.test(id)) {
	                id = id.match(regex)[1].trim();
	                break;
	            }
	        }
	        layouts.list[id.toLowerCase()] = map;
	    },
	    has: function has(name) {
	        name = name.toLowerCase();
	        return name in Controller.layouts.list;
	    },
	    get: function get(name) {
	        name = name.toLowerCase();
	        return Controller.layouts.list[name];
	    },
	    get regex() {
	        return [/(.*)\(.*\)/, /[a-zA-Z0-9]{3,4}-[a-zA-Z0-9]{3,4}-(.*)/];
	    }
	};
	
	Controller.layouts = GC_Layouts;
	
	(function () {
	    var standard = {
	        match: "Standard",
	        name: "Standard",
	        description: "The W3C standard gamepad layout.",
	        buttons: {
	            FACE_1: 0,
	            FACE_2: 1,
	            FACE_3: 2,
	            FACE_4: 3,
	            LEFT_SHOULDER: 4,
	            RIGHT_SHOULDER: 5,
	            LEFT_SHOULDER_BOTTOM: 6,
	            RIGHT_SHOULDER_BOTTOM: 7,
	            SELECT: 8,
	            START: 9,
	            LEFT_ANALOG_BUTTON: 10,
	            RIGHT_ANALOG_BUTTON: 11,
	            DPAD_UP: 12,
	            DPAD_DOWN: 13,
	            DPAD_LEFT: 14,
	            DPAD_RIGHT: 15,
	            HOME: 16
	        },
	        axes: {
	            LEFT_ANALOG_STICK_HOR: 0,
	            LEFT_ANALOG_STICK_VERT: 1,
	            RIGHT_ANALOG_STICK_HOR: 2,
	            RIGHT_ANALOG_STICK_VERT: 3
	        },
	        options: {
	            allowsExtras: true
	        }
	    };
	    Controller.layouts.register(standard);
	})();
	
	var GC_Setting = function GC_Setting(name, defaultValue, setterFunction) {
	    this.name = name;
	    this.defaultValue = defaultValue;
	    this.setterFunction = setterFunction;
	};
	
	var GC_Settings = function GC_Settings(isGlobalSettingList) {
	    var globalSettings = isGlobalSettingList ? false : Controller.globalSettings;
	    var localSettings = {};
	    Object.defineProperty(this, "global", {
	        value: !!isGlobalSettingList,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	    this.register = function (setting) {
	        if (!isGlobalSettingList) {
	            console.warn("You can only register settings globally:\nController.globalSettings.register()");
	            return false;
	        }
	        if (_typeof(setting.defaultValue) === "object") {
	            setting.value = Object.assign({}, setting.defaultValue);
	        } else {
	            setting.value = setting.defaultValue;
	        }
	        Object.defineProperty(this.constructor.prototype, setting.name, {
	            get: function get() {
	                if (!this.global && setting.name in localSettings) {
	                    return localSettings[setting.name];
	                } else {
	                    return setting.value;
	                }
	            },
	            set: function set(value) {
	                if (value === undefined || value === "default" && this.global) {
	                    if (this.global) {
	                        if (_typeof(setting.defaultValue) === "object") {
	                            setting.value = Object.assign({}, setting.defaultValue);
	                        } else {
	                            setting.value = setting.defaultValue;
	                        }
	                    } else {
	                        delete localSettings[setting.name];
	                    }
	                } else if (value === "default") {
	                    if (_typeof(setting.defaultValue) === "object") {
	                        localSettings[setting.name] = Object.assign({}, setting.defaultValue);
	                    } else {
	                        localSettings[setting.name] = setting.defaultValue;
	                    }
	                } else {
	                    var newValue = setting.setterFunction(value);
	                    if (newValue !== null) {
	                        if (this.global) {
	                            if ((typeof newValue === "undefined" ? "undefined" : _typeof(newValue)) === "object") {
	                                Object.assign(setting.value, newValue);
	                            } else {
	                                setting.value = newValue;
	                            }
	                        } else {
	                            if ((typeof newValue === "undefined" ? "undefined" : _typeof(newValue)) === "object") {
	                                Object.assign(localSettings[setting.name], newValue);
	                            } else {
	                                localSettings[setting.name] = newValue;
	                            }
	                        }
	                    }
	                }
	            },
	            enumerable: true
	        });
	        return true;
	    };
	};
	
	GC_Settings.prototype.list = function () {
	    var output = {};
	    for (var name in this.constructor.prototype) {
	        if (this.constructor.prototype.hasOwnProperty(name) && typeof this.constructor.prototype[name] !== "function") {
	            output[name] = this[name];
	        }
	    }
	    return output;
	};
	
	GC_Settings.prototype.clear = function () {
	    for (var name in this.constructor.prototype) {
	        if (this.constructor.prototype.hasOwnProperty(name) && typeof this.constructor.prototype[name] !== "function") {
	            this[name] = undefined;
	        }
	    }
	    return true;
	};
	
	GC_Settings.prototype.update = function () {
	    var success = false;
	    switch (arguments.length) {
	        case 1:
	            if (_typeof(arguments[0]) === "object") {
	                updateMultiple.call(this, arguments[0]);
	            } else {
	                console.warn('GC_Settings.update(settings) expects "settings" to be an object of key/value pairs.');
	            }
	            break;
	
	        case 2:
	            if (typeof arguments[0] === "string" && arguments[0] in this) {
	                this[arguments[0]] = arguments[1];
	            } else {
	                console.warn('GC_Settings.update(settingName, value) expects "settingname" to be the name of a setting.');
	            }
	            break;
	
	        default:
	            console.warn('GC_Settings.update() expects either 1 or 2 arguments:\nupdate(settings) - where "settings" is an object key/value pairs\nupdate(settingName, value) - where "settingName" is the setting you want to change and "value" is what you want to change it to.');
	            break;
	    }
	    function updateMultiple(list) {
	        for (var name in list) {
	            this[name] = list[name];
	        }
	    }
	    return success;
	};
	
	Controller.globalSettings = new GC_Settings(true);
	
	Controller.globalSettings.register(new GC_Setting("analogStickDeadzone", {
	    min: 0,
	    max: 1
	}, function (value) {
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || !("min" in value || "max" in value)) {
	        console.warn('Value must be an object containing either/both "min" and "max" values');
	        return null;
	    }
	    var output = {};
	    if ("min" in value && typeof value.min === "number" && value.min >= 0 && value.min <= 1) {
	        output.min = value.min;
	    }
	    if ("max" in value && typeof value.max === "number" && value.max >= 0 && value.max <= 1) {
	        output.max = value.max;
	    }
	    return output;
	}));
	
	Controller.globalSettings.register(new GC_Setting("analogStickDpadThreshold", .7, function (value) {
	    if (typeof value === "number" && value >= 0 && value <= 1) {
	        return value;
	    } else {
	        console.warn("angry");
	        return null;
	    }
	}));
	
	Controller.globalSettings.register(new GC_Setting("buttonThreshold", .95, function (value) {
	    if (typeof value === "number" && value >= 0 && value <= 1) {
	        return value;
	    } else {
	        console.warn("angry");
	        return null;
	    }
	}));
	
	Controller.globalSettings.register(new GC_Setting("mapAnalogToShape", "none", function (value) {
	    if (value === "none") {
	        return "none";
	    } else if (value === "square") {
	        return "square";
	    } else {
	        return null;
	    }
	}));
	
	Controller.globalSettings.register(new GC_Setting("useAnalogAsDpad", "none", function (value) {
	    var possible = ["none", "left", "right", "both", false];
	    if (possible.indexOf(value) > -1) {
	        return value;
	    } else {
	        console.warn('Not a valid option for "useAnalogAsDpad".');
	        return null;
	    }
	}));
	
	return Controller;
	
	})));


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define('controller.layouts.js', factory) :
	    (global.ControllerLayouts = factory());
	}(this, (function () { 'use strict';
	
	/*! Controller.layouts.js - v1.0.0 - 2016-08-30 */
	
	var xboxOneOSX = {
	    match: "Xbox One Wired Controller",
	    name: "Xbox One (Xbox 360 Controller Driver)",
	    description: "A standard Xbox One gamepad on Mac OS X using the driver " + "Xbox 360 Controller Driver (https://github.com/360Controller/360Controller/).",
	    init: function init() {
	        console.warn("Reporting of buttons.HOME is buggy and unreliable.");
	    },
	    buttons: {
	        FACE_1: 0,
	        FACE_2: 1,
	        FACE_3: 2,
	        FACE_4: 3,
	        LEFT_SHOULDER: 4,
	        RIGHT_SHOULDER: 5,
	        LEFT_ANALOG_BUTTON: 6,
	        RIGHT_ANALOG_BUTTON: 7,
	        START: 8,
	        SELECT: 9,
	        DPAD_UP: 11,
	        DPAD_DOWN: 12,
	        DPAD_LEFT: 13,
	        DPAD_RIGHT: 14
	    },
	    axes: {
	        LEFT_ANALOG_STICK_HOR: 0,
	        LEFT_ANALOG_STICK_VERT: 1,
	        LEFT_SHOULDER_BOTTOM: {
	            index: 2,
	            inputMin: -1,
	            type: "buttons"
	        },
	        RIGHT_ANALOG_STICK_HOR: 3,
	        RIGHT_ANALOG_STICK_VERT: 4,
	        RIGHT_SHOULDER_BOTTOM: {
	            index: 5,
	            inputMin: -1,
	            type: "buttons"
	        },
	        HOME: {
	            index: 9,
	            type: "buttons",
	            data: {
	                value: undefined,
	                pressed: false
	            },
	            method: homeButton,
	            ignoreConversion: true
	        }
	    }
	};
	var mozillaVariant = {
	    buttons: {
	        FACE_1: 3,
	        FACE_2: 4,
	        FACE_3: 5,
	        FACE_4: 6,
	        LEFT_SHOULDER: 11,
	        RIGHT_SHOULDER: 12,
	        LEFT_ANALOG_BUTTON: 13,
	        RIGHT_ANALOG_BUTTON: 14,
	        START: 2,
	        SELECT: 1,
	        DPAD_UP: 7,
	        DPAD_DOWN: 8,
	        DPAD_LEFT: 9,
	        DPAD_RIGHT: 10,
	        HOME: 15
	    },
	    axes: {
	        LEFT_ANALOG_STICK_HOR: 0,
	        LEFT_ANALOG_STICK_VERT: 1,
	        LEFT_SHOULDER_BOTTOM: {
	            index: 2,
	            inputMin: -1,
	            type: "buttons"
	        },
	        RIGHT_ANALOG_STICK_HOR: 3,
	        RIGHT_ANALOG_STICK_VERT: 4,
	        RIGHT_SHOULDER_BOTTOM: {
	            index: 5,
	            inputMin: -1,
	            type: "buttons"
	        }
	    }
	};
	xboxOneOSX.Mozilla = mozillaVariant;
	
	function homeButton(gamepad, button) {
	    if (!gamepad) {
	        return;
	    }
	    var value = gamepad.axes[9];
	    var previous = button.data;
	    if (previous.value === undefined) {
	        button.data = {
	            value: value,
	            pressed: false
	        };
	        return 0;
	    }
	    if (value === previous.value) {
	        button.data = {
	            value: button.data.value,
	            pressed: button.data.pressed
	        };
	        return previous.pressed ? 1 : 0;
	    } else {
	        if (previous.pressed) {
	            button.data = {
	                value: value,
	                pressed: false
	            };
	            return 0;
	        } else {
	            button.data = {
	                value: value,
	                pressed: true
	            };
	            return 1;
	        }
	    }
	}
	
	return xboxOneOSX;
	
	})));


/***/ },
/* 232 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"gcs-app\">\n    <ui-tabs\n        class=\"main-tab-container\" background-color=\"dark\" text-color=\"light\"\n        indicator-color=\"transparent\"\n    >\n        <ui-tab header=\"Map\">\n            <map-view></map-view>\n        </ui-tab>\n\n        <ui-tab header=\"Params\">\n            <params-view></params-view>\n        </ui-tab>\n\n        <ui-tab header=\"Settings\">\n            <settings-view></settings-view>\n        </ui-tab>\n    </ui-tabs>\n\n    <gcs-indicators></gcs-indicators>\n\n    <ui-snackbar-container position=\"left\"></ui-snackbar-container>\n\n    <gcs-edit-mission-modal :show.sync=\"showEditMissionModal\"></gcs-edit-mission-modal>\n</div>\n\n<socket-io-manager></socket-io-manager>\n";

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vuex = __webpack_require__(234);
	
	var _vuex2 = _interopRequireDefault(_vuex);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vuex2.default);
	
	var initialState = {
	    map: null,
	    mapEl: null,
	    mapLoaded: false,
	    waypointsVisible: true,
	    wamv: {
	        loaded: false,
	        position: { lat: -32.8883338, lng: 151.7075279 },
	        heading: 0,
	        speed: 0,
	        battery: 100,
	        armed: false,
	        mode: 'manual',
	        signal: 100
	    },
	    settings: [],
	    settingsLastUpdateTime: null,
	    missions: [],
	
	    missionsLastUpdateTime: null,
	    currentMissionIndex: -1,
	    parameters: [],
	
	    parametersLastUpdateTime: null
	};
	
	var mutations = {
	    SET_MAP: function SET_MAP(state, map) {
	        state.map = map;
	    },
	    SET_MAP_EL: function SET_MAP_EL(state, mapEl) {
	        state.mapEl = mapEl;
	    },
	    SET_MAP_LOADED: function SET_MAP_LOADED(state, loaded) {
	        state.mapLoaded = loaded;
	    },
	    SET_WAYPOINTS_VISIBLE: function SET_WAYPOINTS_VISIBLE(state, visible) {
	        state.waypointsVisible = visible;
	    },
	    UPDATE_WAMV_POSITION: function UPDATE_WAMV_POSITION(state, position) {
	        state.wamv.position = position;
	    },
	    SET_WAMV: function SET_WAMV(state, wamv) {
	        state.wamv = wamv;
	    },
	    SET_WAMV_ARMED: function SET_WAMV_ARMED(state, armed) {
	        state.wamv.armed = armed;
	    },
	    SET_WAMV_MODE: function SET_WAMV_MODE(state, mode) {
	        state.wamv.mode = mode;
	    },
	    SET_SETTINGS: function SET_SETTINGS(state, settings) {
	        state.settingsLastUpdateTime = Date.now();
	        state.settings = settings;
	    },
	    SET_MISSIONS: function SET_MISSIONS(state, missions) {
	        state.missionsLastUpdateTime = Date.now();
	        state.missions = missions;
	    },
	    SET_CURRENT_MISSION_INDEX: function SET_CURRENT_MISSION_INDEX(state, index) {
	        state.currentMissionIndex = index;
	    },
	    SET_CURRENT_MISSION_TITLE: function SET_CURRENT_MISSION_TITLE(state, title) {
	        state.missions[state.currentMissionIndex].title = title;
	    },
	    SET_PARAMETERS: function SET_PARAMETERS(state, parameters) {
	        state.parametersLastUpdateTime = Date.now();
	        state.parameters = parameters;
	    }
	};
	
	exports.default = new _vuex2.default.Store({
	    state: initialState,
	    mutations: mutations
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Vuex v1.0.0-rc
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Vuex = factory());
	}(this, function () { 'use strict';
	
	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
	  };
	
	  var classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  };
	
	  var createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }
	
	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();
	
	  var toConsumableArray = function (arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
	
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  };
	
	  /**
	   * Merge an array of objects into one.
	   *
	   * @param {Array<Object>} arr
	   * @return {Object}
	   */
	
	  function mergeObjects(arr) {
	    return arr.reduce(function (prev, obj) {
	      Object.keys(obj).forEach(function (key) {
	        var existing = prev[key];
	        if (existing) {
	          // allow multiple mutation objects to contain duplicate
	          // handlers for the same mutation type
	          if (Array.isArray(existing)) {
	            prev[key] = existing.concat(obj[key]);
	          } else {
	            prev[key] = [existing].concat(obj[key]);
	          }
	        } else {
	          prev[key] = obj[key];
	        }
	      });
	      return prev;
	    }, {});
	  }
	
	  /**
	   * Check whether the given value is Object or not
	   *
	   * @param {*} obj
	   * @return {Boolean}
	   */
	
	  function isObject(obj) {
	    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	  }
	
	  /**
	   * Get state sub tree by given keys.
	   *
	   * @param {Object} state
	   * @param {Array<String>} nestedKeys
	   * @return {Object}
	   */
	  function getNestedState(state, nestedKeys) {
	    return nestedKeys.reduce(function (state, key) {
	      return state[key];
	    }, state);
	  }
	
	  /**
	   * Hacks to get access to Vue internals.
	   * Maybe we should expose these...
	   */
	
	  var Watcher = void 0;
	  function getWatcher(vm) {
	    if (!Watcher) {
	      var noop = function noop() {};
	      var unwatch = vm.$watch(noop, noop);
	      Watcher = vm._watchers[0].constructor;
	      unwatch();
	    }
	    return Watcher;
	  }
	
	  var Dep = void 0;
	  function getDep(vm) {
	    if (!Dep) {
	      Dep = vm._data.__ob__.dep.constructor;
	    }
	    return Dep;
	  }
	
	  var hook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	  function devtoolPlugin(store) {
	    if (!hook) return;
	
	    hook.emit('vuex:init', store);
	
	    hook.on('vuex:travel-to-state', function (targetState) {
	      store.replaceState(targetState);
	    });
	
	    store.on('mutation', function (mutation, state) {
	      hook.emit('vuex:mutation', mutation, state);
	    });
	  }
	
	  function override (Vue) {
	    var version = Number(Vue.version.split('.')[0]);
	
	    if (version >= 2) {
	      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
	      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
	    } else {
	      (function () {
	        // override init and inject vuex init procedure
	        // for 1.x backwards compatibility.
	        var _init = Vue.prototype._init;
	        Vue.prototype._init = function () {
	          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	          options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
	          _init.call(this, options);
	        };
	      })();
	    }
	
	    /**
	     * Vuex init hook, injected into each instances init hooks list.
	     */
	
	    function vuexInit() {
	      var options = this.$options;
	      var store = options.store;
	      var vuex = options.vuex;
	      // store injection
	
	      if (store) {
	        this.$store = store;
	      } else if (options.parent && options.parent.$store) {
	        this.$store = options.parent.$store;
	      }
	      // vuex option handling
	      if (vuex) {
	        if (!this.$store) {
	          console.warn('[vuex] store not injected. make sure to ' + 'provide the store option in your root component.');
	        }
	        var state = vuex.state;
	        var actions = vuex.actions;
	        var getters = vuex.getters;
	        // handle deprecated state option
	
	        if (state && !getters) {
	          console.warn('[vuex] vuex.state option will been deprecated in 1.0. ' + 'Use vuex.getters instead.');
	          getters = state;
	        }
	        // getters
	        if (getters) {
	          options.computed = options.computed || {};
	          for (var key in getters) {
	            defineVuexGetter(this, key, getters[key]);
	          }
	        }
	        // actions
	        if (actions) {
	          options.methods = options.methods || {};
	          for (var _key in actions) {
	            options.methods[_key] = makeBoundAction(this.$store, actions[_key], _key);
	          }
	        }
	      }
	    }
	
	    /**
	     * Setter for all getter properties.
	     */
	
	    function setter() {
	      throw new Error('vuex getter properties are read-only.');
	    }
	
	    /**
	     * Define a Vuex getter on an instance.
	     *
	     * @param {Vue} vm
	     * @param {String} key
	     * @param {Function} getter
	     */
	
	    function defineVuexGetter(vm, key, getter) {
	      if (typeof getter !== 'function') {
	        console.warn('[vuex] Getter bound to key \'vuex.getters.' + key + '\' is not a function.');
	      } else {
	        Object.defineProperty(vm, key, {
	          enumerable: true,
	          configurable: true,
	          get: makeComputedGetter(vm.$store, getter),
	          set: setter
	        });
	      }
	    }
	
	    /**
	     * Make a computed getter, using the same caching mechanism of computed
	     * properties. In addition, it is cached on the raw getter function using
	     * the store's unique cache id. This makes the same getter shared
	     * across all components use the same underlying watcher, and makes
	     * the getter evaluated only once during every flush.
	     *
	     * @param {Store} store
	     * @param {Function} getter
	     */
	
	    function makeComputedGetter(store, getter) {
	      var id = store._getterCacheId;
	
	      // cached
	      if (getter[id]) {
	        return getter[id];
	      }
	      var vm = store._vm;
	      var Watcher = getWatcher(vm);
	      var Dep = getDep(vm);
	      var watcher = new Watcher(vm, function (vm) {
	        return getter(vm.state);
	      }, null, { lazy: true });
	      var computedGetter = function computedGetter() {
	        if (watcher.dirty) {
	          watcher.evaluate();
	        }
	        if (Dep.target) {
	          watcher.depend();
	        }
	        return watcher.value;
	      };
	      getter[id] = computedGetter;
	      return computedGetter;
	    }
	
	    /**
	     * Make a bound-to-store version of a raw action function.
	     *
	     * @param {Store} store
	     * @param {Function} action
	     * @param {String} key
	     */
	
	    function makeBoundAction(store, action, key) {
	      if (typeof action !== 'function') {
	        console.warn('[vuex] Action bound to key \'vuex.actions.' + key + '\' is not a function.');
	      }
	      return function vuexBoundAction() {
	        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
	          args[_key2] = arguments[_key2];
	        }
	
	        return action.call.apply(action, [this, store].concat(args));
	      };
	    }
	
	    // option merging
	    var merge = Vue.config.optionMergeStrategies.computed;
	    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
	      if (!toVal) return fromVal;
	      if (!fromVal) return toVal;
	      return {
	        getters: merge(toVal.getters, fromVal.getters),
	        state: merge(toVal.state, fromVal.state),
	        actions: merge(toVal.actions, fromVal.actions)
	      };
	    };
	  }
	
	  var Vue = void 0;
	  var uid = 0;
	
	  var Store = function () {
	
	    /**
	     * @param {Object} options
	     *        - {Object} state
	     *        - {Object} actions
	     *        - {Object} mutations
	     *        - {Array} plugins
	     *        - {Boolean} strict
	     */
	
	    function Store() {
	      var _this = this;
	
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$state = _ref.state;
	      var state = _ref$state === undefined ? {} : _ref$state;
	      var _ref$mutations = _ref.mutations;
	      var mutations = _ref$mutations === undefined ? {} : _ref$mutations;
	      var _ref$modules = _ref.modules;
	      var modules = _ref$modules === undefined ? {} : _ref$modules;
	      var _ref$plugins = _ref.plugins;
	      var plugins = _ref$plugins === undefined ? [] : _ref$plugins;
	      var _ref$strict = _ref.strict;
	      var strict = _ref$strict === undefined ? false : _ref$strict;
	      classCallCheck(this, Store);
	
	      this._getterCacheId = 'vuex_store_' + uid++;
	      this._dispatching = false;
	      this._rootMutations = this._mutations = mutations;
	      this._modules = modules;
	      this._events = Object.create(null);
	      // bind dispatch to self
	      var dispatch = this.dispatch;
	      this.dispatch = function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	
	        dispatch.apply(_this, args);
	      };
	      // use a Vue instance to store the state tree
	      // suppress warnings just in case the user has added
	      // some funky global mixins
	      if (!Vue) {
	        throw new Error('[vuex] must call Vue.use(Vuex) before creating a store instance.');
	      }
	      var silent = Vue.config.silent;
	      Vue.config.silent = true;
	      this._vm = new Vue({
	        data: {
	          state: state
	        }
	      });
	      Vue.config.silent = silent;
	      this._setupModuleState(state, modules);
	      this._setupModuleMutations(modules);
	      // add extra warnings in strict mode
	      if (strict) {
	        this._setupMutationCheck();
	      }
	      // apply plugins
	      devtoolPlugin(this);
	      plugins.forEach(function (plugin) {
	        return plugin(_this);
	      });
	    }
	
	    /**
	     * Getter for the entire state tree.
	     * Read only.
	     *
	     * @return {Object}
	     */
	
	    createClass(Store, [{
	      key: 'replaceState',
	
	
	      /**
	       * Replace root state.
	       *
	       * @param {Object} state
	       */
	
	      value: function replaceState(state) {
	        this._dispatching = true;
	        this._vm.state = state;
	        this._dispatching = false;
	      }
	
	      /**
	       * Dispatch an action.
	       *
	       * @param {String} type
	       */
	
	    }, {
	      key: 'dispatch',
	      value: function dispatch(type) {
	        for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          payload[_key2 - 1] = arguments[_key2];
	        }
	
	        var silent = false;
	        var isObjectStyleDispatch = false;
	        // compatibility for object actions, e.g. FSA
	        if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type.type && arguments.length === 1) {
	          isObjectStyleDispatch = true;
	          payload = type;
	          if (type.silent) silent = true;
	          type = type.type;
	        }
	        var handler = this._mutations[type];
	        var state = this.state;
	        if (handler) {
	          this._dispatching = true;
	          // apply the mutation
	          if (Array.isArray(handler)) {
	            handler.forEach(function (h) {
	              isObjectStyleDispatch ? h(state, payload) : h.apply(undefined, [state].concat(toConsumableArray(payload)));
	            });
	          } else {
	            isObjectStyleDispatch ? handler(state, payload) : handler.apply(undefined, [state].concat(toConsumableArray(payload)));
	          }
	          this._dispatching = false;
	          if (!silent) {
	            var mutation = isObjectStyleDispatch ? payload : { type: type, payload: payload };
	            this.emit('mutation', mutation, state);
	          }
	        } else {
	          console.warn('[vuex] Unknown mutation: ' + type);
	        }
	      }
	
	      /**
	       * Watch state changes on the store.
	       * Same API as Vue's $watch, except when watching a function,
	       * the function gets the state as the first argument.
	       *
	       * @param {Function} fn
	       * @param {Function} cb
	       * @param {Object} [options]
	       */
	
	    }, {
	      key: 'watch',
	      value: function watch(fn, cb, options) {
	        var _this2 = this;
	
	        if (typeof fn !== 'function') {
	          console.error('Vuex store.watch only accepts function.');
	          return;
	        }
	        return this._vm.$watch(function () {
	          return fn(_this2.state);
	        }, cb, options);
	      }
	
	      /**
	       * Hot update mutations & modules.
	       *
	       * @param {Object} options
	       *        - {Object} [mutations]
	       *        - {Object} [modules]
	       */
	
	    }, {
	      key: 'hotUpdate',
	      value: function hotUpdate() {
	        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	        var mutations = _ref2.mutations;
	        var modules = _ref2.modules;
	
	        this._rootMutations = this._mutations = mutations || this._rootMutations;
	        this._setupModuleMutations(modules || this._modules);
	      }
	
	      /**
	       * Attach sub state tree of each module to the root tree.
	       *
	       * @param {Object} state
	       * @param {Object} modules
	       */
	
	    }, {
	      key: '_setupModuleState',
	      value: function _setupModuleState(state, modules) {
	        var _this3 = this;
	
	        if (!isObject(modules)) return;
	
	        Object.keys(modules).forEach(function (key) {
	          var module = modules[key];
	
	          // set this module's state
	          Vue.set(state, key, module.state || {});
	
	          // retrieve nested modules
	          _this3._setupModuleState(state[key], module.modules);
	        });
	      }
	
	      /**
	       * Bind mutations for each module to its sub tree and
	       * merge them all into one final mutations map.
	       *
	       * @param {Object} updatedModules
	       */
	
	    }, {
	      key: '_setupModuleMutations',
	      value: function _setupModuleMutations(updatedModules) {
	        var modules = this._modules;
	        Object.keys(updatedModules).forEach(function (key) {
	          modules[key] = updatedModules[key];
	        });
	        var updatedMutations = this._createModuleMutations(modules, []);
	        this._mutations = mergeObjects([this._rootMutations].concat(toConsumableArray(updatedMutations)));
	      }
	
	      /**
	       * Helper method for _setupModuleMutations.
	       * The method retrieve nested sub modules and
	       * bind each mutations to its sub tree recursively.
	       *
	       * @param {Object} modules
	       * @param {Array<String>} nestedKeys
	       * @return {Array<Object>}
	       */
	
	    }, {
	      key: '_createModuleMutations',
	      value: function _createModuleMutations(modules, nestedKeys) {
	        var _this4 = this;
	
	        if (!isObject(modules)) return [];
	
	        return Object.keys(modules).map(function (key) {
	          var module = modules[key];
	          var newNestedKeys = nestedKeys.concat(key);
	
	          // retrieve nested modules
	          var nestedMutations = _this4._createModuleMutations(module.modules, newNestedKeys);
	
	          if (!module || !module.mutations) {
	            return mergeObjects(nestedMutations);
	          }
	
	          // bind mutations to sub state tree
	          var mutations = {};
	          Object.keys(module.mutations).forEach(function (name) {
	            var original = module.mutations[name];
	            mutations[name] = function (state) {
	              for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	                args[_key3 - 1] = arguments[_key3];
	              }
	
	              original.apply(undefined, [getNestedState(state, newNestedKeys)].concat(args));
	            };
	          });
	
	          // merge mutations of this module and nested modules
	          return mergeObjects([mutations].concat(toConsumableArray(nestedMutations)));
	        });
	      }
	
	      /**
	       * Setup mutation check: if the vuex instance's state is mutated
	       * outside of a mutation handler, we throw en error. This effectively
	       * enforces all mutations to the state to be trackable and hot-reloadble.
	       * However, this comes at a run time cost since we are doing a deep
	       * watch on the entire state tree, so it is only enalbed with the
	       * strict option is set to true.
	       */
	
	    }, {
	      key: '_setupMutationCheck',
	      value: function _setupMutationCheck() {
	        var _this5 = this;
	
	        var Watcher = getWatcher(this._vm);
	        /* eslint-disable no-new */
	        new Watcher(this._vm, 'state', function () {
	          if (!_this5._dispatching) {
	            throw new Error('[vuex] Do not mutate vuex store state outside mutation handlers.');
	          }
	        }, { deep: true, sync: true });
	        /* eslint-enable no-new */
	      }
	    }, {
	      key: 'state',
	      get: function get() {
	        return this._vm.state;
	      },
	      set: function set(v) {
	        throw new Error('[vuex] Use store.replaceState() to explicit replace store state.');
	      }
	    }]);
	    return Store;
	  }();
	
	  function install(_Vue) {
	    if (Vue) {
	      console.warn('[vuex] already installed. Vue.use(Vuex) should be called only once.');
	      return;
	    }
	    Vue = _Vue
	    // reuse Vue's event system
	    ;['on', 'off', 'once', 'emit'].forEach(function (e) {
	      Store.prototype[e] = Store.prototype['$' + e] = Vue.prototype['$' + e];
	    });
	    override(Vue);
	  }
	
	  // auto install in dist mode
	  if (typeof window !== 'undefined' && window.Vue) {
	    install(window.Vue);
	  }
	
	  var index = {
	    Store: Store,
	    install: install
	  };
	
	  return index;
	
	}));

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOGM4MTVjMzM4YmI0MWFkOThhMGEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUvZGlzdC92dWUuY29tbW9uLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34va2Vlbi11aS9kaXN0L2tlZW4tdWkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/N2U5MSIsIndlYnBhY2s6Ly8vQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZT84MDk4Iiwid2VicGFjazovLy9NYXBWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZT83NDk3Iiwid2VicGFjazovLy9HY3NNYXAudnVlIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvYWQtZ29vZ2xlLW1hcHMtYXBpL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RvcmUvYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlZXAtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaXMtb2JqL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zdG9yZS9nZXR0ZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXAudnVlPzJjMmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcENvbnRyb2xzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlPzMxM2YiLCJ3ZWJwYWNrOi8vL0djc01hcENvbnRyb2xzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlPzIyMDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBTaWRlYmFyLnZ1ZT9kNDMwIiwid2VicGFjazovLy9HY3NNYXBTaWRlYmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25zLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25zLnZ1ZT9iNmQ4Iiwid2VicGFjazovLy9HY3NNaXNzaW9ucy52dWUiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb24udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWU/MjMzZiIsIndlYnBhY2s6Ly8vR2NzTWlzc2lvbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWU/YTVmNCIsIndlYnBhY2s6Ly8vR2NzV2F5cG9pbnQudnVlIiwid2VicGFjazovLy8uL3NyYy9taXhpbnMvaXMtbWFya2VyLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL2VsZW1lbnQtc2Nyb2xsLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnQudnVlPzMyZjEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludExpbmsudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZT9iZThiIiwid2VicGFjazovLy9HY3NXYXlwb2ludExpbmsudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2F5cG9pbnRMaW5rLnZ1ZT80MmE5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzT3JpZ2luLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc09yaWdpbi52dWU/OTNiYyIsIndlYnBhY2s6Ly8vR2NzT3JpZ2luLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc09yaWdpbi52dWU/MTJhMiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9udW1iZXItdG8tbGV0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWU/OWZkOCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25Sb3cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWU/ZjdiNCIsIndlYnBhY2s6Ly8vR2NzTWlzc2lvblJvdy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZT81YTBjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbnMudnVlPzRhZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcFNpZGViYXIudnVlPzY5ZjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc0NvbW1hbmRzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlPzg1Y2IiLCJ3ZWJwYWNrOi8vL0djc0NvbW1hbmRzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlPzI2ZjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc1NpZGViYXJDb250cm9scy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFwL0djc1NpZGViYXJDb250cm9scy52dWU/YmJkYiIsIndlYnBhY2s6Ly8vR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZT83M2RjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2Ftdi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZT9kNTFmIiwid2VicGFjazovLy9HY3NXYW12LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dhbXYudnVlPzY2NTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWU/MDQxMCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZT9kMWU5Iiwid2VicGFjazovLy9QYXJhbXNWaWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9QYXJhbXNWaWV3LnZ1ZT9iYWM5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZT80YWNlIiwid2VicGFjazovLy9TZXR0aW5nc1ZpZXcudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWU/NjY2MCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZT82ODZkIiwid2VicGFjazovLy9HY3NJbmRpY2F0b3JzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZT84YmYyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU29ja2V0SW9NYW5hZ2VyLnZ1ZT9iZWUxIiwid2VicGFjazovLy9Tb2NrZXRJb01hbmFnZXIudnVlIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNldXJpL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZGVidWcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vanNvbjMvbGliL2pzb24zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLXBhcnNlci9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhcy1jb3JzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLXBhcnNlci9+L2hhcy1iaW5hcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tcGFyc2VyL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V0ZjgvdXRmOC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jsb2IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZXFzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWluaGVyaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi95ZWFzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy93cyAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4vfi9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcGFyc2Vqc29uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaGFzLWJpbmFyeS9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWNrbzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm90b2J1ZmpzL2Rpc3QvcHJvdG9idWYuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ieXRlYnVmZmVyL2Rpc3QvYnl0ZWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvbmcvZGlzdC9sb25nLmpzIiwid2VicGFjazovLy9mcyAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3BhdGggKGlnbm9yZWQpIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWU/ZThkMyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc0VkaXRNaXNzaW9uTW9kYWwudnVlIiwid2VicGFjazovLy9HY3NFZGl0TWlzc2lvbk1vZGFsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc0VkaXRNaXNzaW9uTW9kYWwudnVlPzM2YWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvY29udHJvbGxlci1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL34vY29udHJvbGxlci5qcy9kaXN0L0NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb250cm9sbGVyLmpzL2Rpc3QvQ29udHJvbGxlci5sYXlvdXRzLmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlP2Q4MTgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL3N0b3JlLmpzIiwid2VicGFjazovLy8uL34vdnVleC9kaXN0L3Z1ZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEtBQUs7QUFDaEIsYUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCLFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUE4QjtBQUM5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsZ0RBQStDO0FBQy9DLE1BQUs7QUFDTCxvQ0FBbUM7QUFDbkM7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsb0NBQW1DO0FBQ25DO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsSUFBSTtBQUNqQixjQUFhLE9BQU87QUFDcEIsY0FBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsUUFBUTtBQUNyQixjQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEtBQUs7QUFDbEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxJQUFJO0FBQ2pCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsU0FBUztBQUN0QixjQUFhLFNBQVM7QUFDdEI7QUFDQTs7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVOzs7Ozs7O0FDL0p0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBLDJEQUEwRCxlQUFlLEVBQUU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTtBQUNOLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWdHO0FBQ2hHO0FBQ0EsY0FBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBLHNFQUFxRTs7QUFFckU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJ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QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRO0FBQ1I7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSOztBQUVBO0FBQ0Esc0VBQXFFLCtCQUErQjtBQUNwRzs7QUFFQSxvREFBbUQsK0JBQStCO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWLFNBQVE7QUFDUjtBQUNBLHNCQUFxQix3QkFBd0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFDQUFvQyxpQ0FBaUMsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0seUNBQXlDLEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWEsRUFBRSwyQkFBMkIsMEJBQTBCLFlBQVksRUFBRSwyQ0FBMkMsOEJBQThCLEVBQUUsT0FBTyw2RUFBNkUsRUFBRSxHQUFHLEVBQUU7O0FBRXZwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjs7QUFFQSxpQ0FBZ0M7QUFDaEMsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1osV0FBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1osV0FBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOLGNBQWE7QUFDYjtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUEsR0FBRTs7O0FBR0YsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07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QUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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VTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQSw0SUFBMkksMENBQTBDOztBQUVyTCxRQUFPO0FBQ1A7QUFDQTs7QUFFQSw4REFBNkQsZ0VBQWdFOztBQUU3SCxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWdHO0FBQ2hHO0FBQ0EsY0FBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx3Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsZUFBYztBQUNkLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkLFdBQVU7QUFDVjtB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ZDtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBc0I7QUFDdEIsc0JBQXFCOztBQUVyQixtQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksTUFBTTtBQUNsQixhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRixHQUFFOztBQUVGLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUYsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGLEdBQUU7O0FBRUYsUUFBTztBQUNQO0FBQ0E7O0FBRUEsb0VBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLEdBQUU7OztBQUdGLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUYsR0FBRTs7QUFFRixRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsV0FBVztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7Ozs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTO0FBQzFCLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGNBQWM7QUFDekIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNpQkE7Ozs7Ozs7O0FDQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGNBQWM7QUFDekIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBMkY7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3Z0QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcERBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLFlBQVk7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLFlBQVk7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsTUFBSyxXQUFXO0FBQ2hCO0FBQ0E7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCw0REFBMkQ7QUFDM0Q7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBdUU7QUFDdkUsTUFB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TztBQUNsQixhQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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OzttQ0MzQkE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQSxNQUFLO0FBQ0wsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBOzs7Ozs7OztpR0NuRkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9EOztBQUVwRCxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGlCQUFpQixnREFBZ0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNU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QTtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLFFBQVE7QUFDdkIsa0JBQWlCO0FBQ2pCO0FBQ0EsaUJBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFpRSxnRUFBZ0U7QUFDakk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxpQ0FBaUM7QUFDMUM7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMEYsbUVBQW1FO0FBQzdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFtRSxtRUFBbUU7QUFDdEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSw0Q0FBMkMsSUFBSSxhQUFhLElBQUk7QUFDaEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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dCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDhjODE1YzMzOGJiNDFhZDk4YTBhXG4gKiovIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xyXG5pbXBvcnQgS2VlblVJIGZyb20gJ2tlZW4tdWknO1xyXG5pbXBvcnQgQXBwIGZyb20gJ2FwcC9BcHAudnVlJztcclxuaW1wb3J0IHN0b3JlIGZyb20gJ3N0b3JlL3N0b3JlJztcclxuXHJcblZ1ZS51c2UoS2VlblVJKTtcclxuXHJcbnZhciBhcHAgPSBuZXcgVnVlKHtcclxuICAgIGVsOiAnYm9keScsXHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgQXBwXHJcbiAgICB9LFxyXG4gICAgc3RvcmVcclxufSk7XHJcblxyXG53aW5kb3cuYXBwID0gYXBwO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tYWluLmpzXG4gKiovIiwiLyohXG4gKiBWdWUuanMgdjEuMC4yNlxuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBvYi5jb252ZXJ0KGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl9wcm94eShrZXkpO1xuICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGRlbChvYmosIGtleSkge1xuICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVsZXRlIG9ialtrZXldO1xuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgaWYgKG9iai5faXNWdWUpIHtcbiAgICAgIGRlbGV0ZSBvYmouX2RhdGFba2V5XTtcbiAgICAgIG9iai5fZGlnZXN0KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3VucHJveHkoa2V5KTtcbiAgICAgIHZtLl9kaWdlc3QoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBsaXRlcmFsIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIGxpdGVyYWxWYWx1ZVJFID0gL15cXHM/KHRydWV8ZmFsc2V8LT9bXFxkXFwuXSt8J1teJ10qJ3xcIlteXCJdKlwiKVxccz8kLztcblxuZnVuY3Rpb24gaXNMaXRlcmFsKGV4cCkge1xuICByZXR1cm4gbGl0ZXJhbFZhbHVlUkUudGVzdChleHApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUY7XG59XG5cbi8qKlxuICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICogZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIF90b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBDaGVjayBhbmQgY29udmVydCBwb3NzaWJsZSBudW1lcmljIHN0cmluZ3MgdG8gbnVtYmVyc1xuICogYmVmb3JlIHNldHRpbmcgYmFjayB0byBkYXRhXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxOdW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIGJvb2xlYW4gbGl0ZXJhbHMgaW50byByZWFsIGJvb2xlYW5zLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgPyB0cnVlIDogdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlO1xufVxuXG4vKipcbiAqIFN0cmlwIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nIHwgZmFsc2V9XG4gKi9cblxuZnVuY3Rpb24gc3RyaXBRdW90ZXMoc3RyKSB7XG4gIHZhciBhID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KSA/IHN0ci5zbGljZSgxLCAtMSkgOiBzdHI7XG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCB0b1VwcGVyKTtcbn1cblxuZnVuY3Rpb24gdG9VcHBlcihfLCBjKSB7XG4gIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGh5cGhlbmF0ZVJFID0gLyhbYS16XFxkXSkoW0EtWl0pL2c7XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGh5cGhlbi91bmRlcnNjb3JlL3NsYXNoIGRlbGltaXRlcmVkIG5hbWVzIGludG9cbiAqIGNhbWVsaXplZCBjbGFzc05hbWVzLlxuICpcbiAqIGUuZy4gbXktY29tcG9uZW50ID0+IE15Q29tcG9uZW50XG4gKiAgICAgIHNvbWVfZWxzZSAgICA9PiBTb21lRWxzZVxuICogICAgICBzb21lL2NvbXAgICAgPT4gU29tZUNvbXBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9cXC9dKShcXHcpL2c7XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgdG9VcHBlcik7XG59XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBiaW5kKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsID8gbCA+IDEgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cykgOiBmbi5jYWxsKGN0eCwgYSkgOiBmbi5jYWxsKGN0eCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheS1saWtlfSBsaXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSAtIHN0YXJ0IGluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqL1xuXG5mdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRvW2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklORztcbn1cblxuLyoqXG4gKiBBcnJheSB0eXBlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtCb29sZWFufSBbZW51bWVyYWJsZV1cbiAqL1xuXG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gX2RlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBNYW51YWwgaW5kZXhPZiBiZWNhdXNlIGl0J3Mgc2xpZ2h0bHkgZmFzdGVyIHRoYW5cbiAqIG5hdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY2FuY2VsbGFibGUoZm4pIHtcbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGNiLmNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiBjYjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpID8gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpIDogZmFsc2UpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuXG52YXIgaGFzUHJvdG8gPSAoJ19fcHJvdG9fXycgaW4ge30pO1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLy8gVUEgc25pZmZpbmcgZm9yIHdvcmtpbmcgYXJvdW5kIGJyb3dzZXItc3BlY2lmaWMgcXVpcmtzXG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgVUEuaW5kZXhPZigndHJpZGVudCcpID4gMDtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJb3MgPSBVQSAmJiAvKGlwaG9uZXxpcGFkfGlwb2R8aW9zKS9pLnRlc3QoVUEpO1xudmFyIGlvc1ZlcnNpb25NYXRjaCA9IGlzSW9zICYmIFVBLm1hdGNoKC9vcyAoW1xcZF9dKykvKTtcbnZhciBpb3NWZXJzaW9uID0gaW9zVmVyc2lvbk1hdGNoICYmIGlvc1ZlcnNpb25NYXRjaFsxXS5zcGxpdCgnXycpO1xuXG4vLyBkZXRlY3RpbmcgaU9TIFVJV2ViVmlldyBieSBpbmRleGVkREJcbnZhciBoYXNNdXRhdGlvbk9ic2VydmVyQnVnID0gaW9zVmVyc2lvbiAmJiBOdW1iZXIoaW9zVmVyc2lvblswXSkgPj0gOSAmJiBOdW1iZXIoaW9zVmVyc2lvblsxXSkgPj0gMyAmJiAhd2luZG93LmluZGV4ZWREQjtcblxudmFyIHRyYW5zaXRpb25Qcm9wID0gdW5kZWZpbmVkO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9IHVuZGVmaW5lZDtcbnZhciBhbmltYXRpb25Qcm9wID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFOSkge1xuICB2YXIgaXNXZWJraXRUcmFucyA9IHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpc1dlYmtpdEFuaW0gPSB3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zID8gJ1dlYmtpdFRyYW5zaXRpb24nIDogJ3RyYW5zaXRpb24nO1xuICB0cmFuc2l0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdFRyYW5zID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xuICBhbmltYXRpb25Qcm9wID0gaXNXZWJraXRBbmltID8gJ1dlYmtpdEFuaW1hdGlvbicgOiAnYW5pbWF0aW9uJztcbiAgYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW0gPyAnd2Via2l0QW5pbWF0aW9uRW5kJyA6ICdhbmltYXRpb25lbmQnO1xufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAqIHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIG1pY3JvdGFzaywgc28gd2UgbGV2ZXJhZ2VcbiAqIE11dGF0aW9uT2JzZXJ2ZXIgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBmYWxsYmFjayB0b1xuICogc2V0VGltZW91dCgwKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICovXG5cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAhaGFzTXV0YXRpb25PYnNlcnZlckJ1Zykge1xuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHdlYnBhY2sgYXR0ZW1wdHMgdG8gaW5qZWN0IGEgc2hpbSBmb3Igc2V0SW1tZWRpYXRlXG4gICAgLy8gaWYgaXQgaXMgdXNlZCBhcyBhIGdsb2JhbCwgc28gd2UgaGF2ZSB0byB3b3JrIGFyb3VuZCB0aGF0IHRvXG4gICAgLy8gYXZvaWQgYnVuZGxpbmcgdW5uZWNlc3NhcnkgY29kZS5cbiAgICB2YXIgY29udGV4dCA9IGluQnJvd3NlciA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG4gICAgdGltZXJGdW5jID0gY29udGV4dC5zZXRJbW1lZGlhdGUgfHwgc2V0VGltZW91dDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNiLCBjdHgpIHtcbiAgICB2YXIgZnVuYyA9IGN0eCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICB9IDogY2I7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuYyk7XG4gICAgaWYgKHBlbmRpbmcpIHJldHVybjtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgfTtcbn0pKCk7XG5cbnZhciBfU2V0ID0gdW5kZWZpbmVkO1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgU2V0LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLykpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuc2V0W2tleV0gPSAxO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIENhY2hlKGxpbWl0KSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdW5kZWZpbmVkO1xuICB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG52YXIgcCA9IENhY2hlLnByb3RvdHlwZTtcblxuLyoqXG4gKiBQdXQgPHZhbHVlPiBpbnRvIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGggPGtleT4uXG4gKiBSZXR1cm5zIHRoZSBlbnRyeSB3aGljaCB3YXMgcmVtb3ZlZCB0byBtYWtlIHJvb20gZm9yXG4gKiB0aGUgbmV3IGVudHJ5LiBPdGhlcndpc2UgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICogKGkuZS4gaWYgdGhlcmUgd2FzIGVub3VnaCByb29tIGFscmVhZHkpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0VudHJ5fHVuZGVmaW5lZH1cbiAqL1xuXG5wLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciByZW1vdmVkO1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLmxpbWl0KSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5zaGlmdCgpO1xuICAgIH1cbiAgICBlbnRyeSA9IHtcbiAgICAgIGtleToga2V5XG4gICAgfTtcbiAgICB0aGlzLl9rZXltYXBba2V5XSA9IGVudHJ5O1xuICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5O1xuICAgICAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLnNpemUrKztcbiAgfVxuICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuXG4gIHJldHVybiByZW1vdmVkO1xufTtcblxuLyoqXG4gKiBQdXJnZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBmcm9tIHRoZVxuICogY2FjaGUuIFJldHVybnMgdGhlIHJlbW92ZWQgZW50cnkgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICogY2FjaGUgd2FzIGVtcHR5LlxuICovXG5cbnAuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgaWYgKGVudHJ5KSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5ld2VyO1xuICAgIHRoaXMuaGVhZC5vbGRlciA9IHVuZGVmaW5lZDtcbiAgICBlbnRyeS5uZXdlciA9IGVudHJ5Lm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2l6ZS0tO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8qKlxuICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxuICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxuICogQHJldHVybiB7RW50cnl8Kn1cbiAqL1xuXG5wLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldO1xuICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAoZW50cnkgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG4gIH1cbiAgLy8gSEVBRC0tLS0tLS0tLS0tLS0tVEFJTFxuICAvLyAgIDwub2xkZXIgICAubmV3ZXI+XG4gIC8vICA8LS0tIGFkZCBkaXJlY3Rpb24gLS1cbiAgLy8gICBBICBCICBDICA8RD4gIEVcbiAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyOyAvLyBDIDwtLSBFLlxuICB9XG4gIGlmIChlbnRyeS5vbGRlcikge1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7IC8vIEMuIC0tPiBFXG4gIH1cbiAgZW50cnkubmV3ZXIgPSB1bmRlZmluZWQ7IC8vIEQgLS14XG4gIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsOyAvLyBELiAtLT4gRVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7IC8vIEUuIDwtLSBEXG4gIH1cbiAgdGhpcy50YWlsID0gZW50cnk7XG4gIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG59O1xuXG52YXIgY2FjaGUkMSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBmaWx0ZXJUb2tlblJFID0gL1teXFxzJ1wiXSt8J1teJ10qJ3xcIlteXCJdKlwiL2c7XG52YXIgcmVzZXJ2ZWRBcmdSRSA9IC9eaW4kfF4tP1xcZCsvO1xuXG4vKipcbiAqIFBhcnNlciBzdGF0ZVxuICovXG5cbnZhciBzdHI7XG52YXIgZGlyO1xudmFyIGM7XG52YXIgcHJldjtcbnZhciBpO1xudmFyIGw7XG52YXIgbGFzdEZpbHRlckluZGV4O1xudmFyIGluU2luZ2xlO1xudmFyIGluRG91YmxlO1xudmFyIGN1cmx5O1xudmFyIHNxdWFyZTtcbnZhciBwYXJlbjtcbi8qKlxuICogUHVzaCBhIGZpbHRlciB0byB0aGUgY3VycmVudCBkaXJlY3RpdmUgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcbiAgdmFyIGV4cCA9IHN0ci5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKTtcbiAgdmFyIGZpbHRlcjtcbiAgaWYgKGV4cCkge1xuICAgIGZpbHRlciA9IHt9O1xuICAgIHZhciB0b2tlbnMgPSBleHAubWF0Y2goZmlsdGVyVG9rZW5SRSk7XG4gICAgZmlsdGVyLm5hbWUgPSB0b2tlbnNbMF07XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXIuYXJncyA9IHRva2Vucy5zbGljZSgxKS5tYXAocHJvY2Vzc0ZpbHRlckFyZyk7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIpIHtcbiAgICAoZGlyLmZpbHRlcnMgPSBkaXIuZmlsdGVycyB8fCBbXSkucHVzaChmaWx0ZXIpO1xuICB9XG4gIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGFyZ3VtZW50IGlzIGR5bmFtaWMgYW5kIHN0cmlwIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyhhcmcpIHtcbiAgaWYgKHJlc2VydmVkQXJnUkUudGVzdChhcmcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0b051bWJlcihhcmcpLFxuICAgICAgZHluYW1pYzogZmFsc2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwUXVvdGVzKGFyZyk7XG4gICAgdmFyIGR5bmFtaWMgPSBzdHJpcHBlZCA9PT0gYXJnO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZHluYW1pYyA/IGFyZyA6IHN0cmlwcGVkLFxuICAgICAgZHluYW1pYzogZHluYW1pY1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRpcmVjdGl2ZSB2YWx1ZSBhbmQgZXh0cmFjdCB0aGUgZXhwcmVzc2lvblxuICogYW5kIGl0cyBmaWx0ZXJzIGludG8gYSBkZXNjcmlwdG9yLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogXCJhICsgMSB8IHVwcGVyY2FzZVwiIHdpbGwgeWllbGQ6XG4gKiB7XG4gKiAgIGV4cHJlc3Npb246ICdhICsgMScsXG4gKiAgIGZpbHRlcnM6IFtcbiAqICAgICB7IG5hbWU6ICd1cHBlcmNhc2UnLCBhcmdzOiBudWxsIH1cbiAqICAgXVxuICogfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUocykge1xuICB2YXIgaGl0ID0gY2FjaGUkMS5nZXQocyk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgLy8gcmVzZXQgcGFyc2VyIHN0YXRlXG4gIHN0ciA9IHM7XG4gIGluU2luZ2xlID0gaW5Eb3VibGUgPSBmYWxzZTtcbiAgY3VybHkgPSBzcXVhcmUgPSBwYXJlbiA9IDA7XG4gIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGRpciA9IHt9O1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9ICFpblNpbmdsZTtcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gIWluRG91YmxlO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgc3RyLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmIHN0ci5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3Qykge1xuICAgICAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZGlyLmV4cHJlc3Npb24gPSBzdHIuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjpcbiAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7YnJlYWs7IC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICBpblNpbmdsZSA9IHRydWU7YnJlYWs7IC8vICdcbiAgICAgICAgY2FzZSAweDI4OlxuICAgICAgICAgIHBhcmVuKys7YnJlYWs7IC8vIChcbiAgICAgICAgY2FzZSAweDI5OlxuICAgICAgICAgIHBhcmVuLS07YnJlYWs7IC8vIClcbiAgICAgICAgY2FzZSAweDVCOlxuICAgICAgICAgIHNxdWFyZSsrO2JyZWFrOyAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDpcbiAgICAgICAgICBzcXVhcmUtLTticmVhazsgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6XG4gICAgICAgICAgY3VybHkrKzticmVhazsgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6XG4gICAgICAgICAgY3VybHktLTticmVhazsgLy8gfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgZGlyLmV4cHJlc3Npb24gPSBzdHIuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGNhY2hlJDEucHV0KHMsIGRpcik7XG4gIHJldHVybiBkaXI7XG59XG5cbnZhciBkaXJlY3RpdmUgPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VEaXJlY3RpdmU6IHBhcnNlRGlyZWN0aXZlXG59KTtcblxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xudmFyIGNhY2hlID0gdW5kZWZpbmVkO1xudmFyIHRhZ1JFID0gdW5kZWZpbmVkO1xudmFyIGh0bWxSRSA9IHVuZGVmaW5lZDtcbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSZWdleCgpIHtcbiAgdmFyIG9wZW4gPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1swXSk7XG4gIHZhciBjbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzFdKTtcbiAgdmFyIHVuc2FmZU9wZW4gPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1swXSk7XG4gIHZhciB1bnNhZmVDbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzFdKTtcbiAgdGFnUkUgPSBuZXcgUmVnRXhwKHVuc2FmZU9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICsgb3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJyk7XG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoJ14nICsgdW5zYWZlT3BlbiArICcoKD86LnxcXFxcbikrPyknICsgdW5zYWZlQ2xvc2UgKyAnJCcpO1xuICAvLyByZXNldCBjYWNoZVxuICBjYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHRlbXBsYXRlIHRleHQgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+IHwgbnVsbH1cbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2h0bWxdXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtvbmVUaW1lXVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0KSB7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjb21waWxlUmVnZXgoKTtcbiAgfVxuICB2YXIgaGl0ID0gY2FjaGUuZ2V0KHRleHQpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWU7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIHdoaWxlIChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleClcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBodG1sID0gaHRtbFJFLnRlc3QobWF0Y2hbMF0pO1xuICAgIHZhbHVlID0gaHRtbCA/IG1hdGNoWzFdIDogbWF0Y2hbMl07XG4gICAgZmlyc3QgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgIG9uZVRpbWUgPSBmaXJzdCA9PT0gNDI7IC8vICpcbiAgICB2YWx1ZSA9IG9uZVRpbWUgPyB2YWx1ZS5zbGljZSgxKSA6IHZhbHVlO1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHRhZzogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZS50cmltKCksXG4gICAgICBodG1sOiBodG1sLFxuICAgICAgb25lVGltZTogb25lVGltZVxuICAgIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleClcbiAgICB9KTtcbiAgfVxuICBjYWNoZS5wdXQodGV4dCwgdG9rZW5zKTtcbiAgcmV0dXJuIHRva2Vucztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBsaXN0IG9mIHRva2VucyBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKiBlLmcuIHRva2VucyBwYXJzZWQgZnJvbSAnYSB7e2J9fSBjJyBjYW4gYmUgc2VyaWFsaXplZFxuICogaW50byBvbmUgc2luZ2xlIGV4cHJlc3Npb24gYXMgJ1wiYSBcIiArIGIgKyBcIiBjXCInLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbnNUb0V4cCh0b2tlbnMsIHZtKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2VuLCB2bSk7XG4gICAgfSkuam9pbignKycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbnNbMF0sIHZtLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIHNpbmdsZSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzaW5nbGVdXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VG9rZW4odG9rZW4sIHZtLCBzaW5nbGUpIHtcbiAgcmV0dXJuIHRva2VuLnRhZyA/IHRva2VuLm9uZVRpbWUgJiYgdm0gPyAnXCInICsgdm0uJGV2YWwodG9rZW4udmFsdWUpICsgJ1wiJyA6IGlubGluZUZpbHRlcnModG9rZW4udmFsdWUsIHNpbmdsZSkgOiAnXCInICsgdG9rZW4udmFsdWUgKyAnXCInO1xufVxuXG4vKipcbiAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gKiBlLmcuIGF0dHI9XCJzb21lLXt7dGhpbmcgfCBmaWx0ZXJ9fVwiLCBpbiBvcmRlciB0byBjb21iaW5lXG4gKiB0aGUgd2hvbGUgdGhpbmcgaW50byBhIHNpbmdsZSB3YXRjaGFibGUgZXhwcmVzc2lvbiwgd2VcbiAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gKiB0aGF0LiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCBpdCBhdm9pZHMgaGVhdnkgY2hhbmdlc1xuICogdG8gZGlyZWN0aXZlIHBhcnNlciBhbmQgd2F0Y2hlciBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vO1xuZnVuY3Rpb24gaW5saW5lRmlsdGVycyhleHAsIHNpbmdsZSkge1xuICBpZiAoIWZpbHRlclJFLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGUgPyBleHAgOiAnKCcgKyBleHAgKyAnKSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKGV4cCk7XG4gICAgaWYgKCFkaXIuZmlsdGVycykge1xuICAgICAgcmV0dXJuICcoJyArIGV4cCArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICcsbnVsbCwnICsgLy8gb2xkVmFsdWUgKG51bGwgZm9yIHJlYWQpXG4gICAgICBKU09OLnN0cmluZ2lmeShkaXIuZmlsdGVycykgKyAvLyBmaWx0ZXIgZGVzY3JpcHRvcnNcbiAgICAgICcsZmFsc2UpJzsgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNvbXBpbGVSZWdleDogY29tcGlsZVJlZ2V4LFxuICBwYXJzZVRleHQ6IHBhcnNlVGV4dCxcbiAgdG9rZW5zVG9FeHA6IHRva2Vuc1RvRXhwXG59KTtcblxudmFyIGRlbGltaXRlcnMgPSBbJ3t7JywgJ319J107XG52YXIgdW5zYWZlRGVsaW1pdGVycyA9IFsne3t7JywgJ319fSddO1xuXG52YXIgY29uZmlnID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzLlxuICAgKiBBbHNvIGVuYWJsZXMgc3RhY2sgdHJhY2UgZm9yIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZGVidWc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byB1c2UgYXN5bmMgcmVuZGVyaW5nLlxuICAgKi9cblxuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byB3YXJuIGFnYWluc3QgZXJyb3JzIGNhdWdodCB3aGVuIGV2YWx1YXRpbmdcbiAgICogZXhwcmVzc2lvbnMuXG4gICAqL1xuXG4gIHdhcm5FeHByZXNzaW9uRXJyb3JzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFsbG93IGRldnRvb2xzIGluc3BlY3Rpb24uXG4gICAqIERpc2FibGVkIGJ5IGRlZmF1bHQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gICAqL1xuXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmbGFnIHRvIGluZGljYXRlIHRoZSBkZWxpbWl0ZXJzIGhhdmUgYmVlblxuICAgKiBjaGFuZ2VkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgX2RlbGltaXRlcnNDaGFuZ2VkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cblxuICBfYXNzZXRUeXBlczogWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2VsZW1lbnREaXJlY3RpdmUnLCAnZmlsdGVyJywgJ3RyYW5zaXRpb24nLCAncGFydGlhbCddLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn0sIHtcbiAgZGVsaW1pdGVyczogeyAvKipcbiAgICAgICAgICAgICAgICAgKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCBwYXJzZXIgdG8gcmUtY29tcGlsZSB0aGUgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgZGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgdW5zYWZlRGVsaW1pdGVyczoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIHVuc2FmZURlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgd2FybiA9IHVuZGVmaW5lZDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gdW5kZWZpbmVkO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgICBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVnVlIHdhcm5dOiAnICsgbXNnICsgKHZtID8gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkgOiAnJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9pc1Z1ZSA/IHZtLiRvcHRpb25zLm5hbWUgOiB2bS5uYW1lO1xuICAgICAgcmV0dXJuIG5hbWUgPyAnIChmb3VuZCBpbiBjb21wb25lbnQ6IDwnICsgaHlwaGVuYXRlKG5hbWUpICsgJz4pJyA6ICcnO1xuICAgIH07XG4gIH0pKCk7XG59XG5cbi8qKlxuICogQXBwZW5kIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwZW5kV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogSW5zZXJ0QmVmb3JlIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVdpdGhUcmFuc2l0aW9uKGVsLCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAtMSwgZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZShlbCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogQXBwbHkgdHJhbnNpdGlvbnMgd2l0aCBhbiBvcGVyYXRpb24gY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICogICAgICAgICAgICAgICAgICAxOiBlbnRlclxuICogICAgICAgICAgICAgICAgIC0xOiBsZWF2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSB0aGUgYWN0dWFsIERPTSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNpdGlvbihlbCwgZGlyZWN0aW9uLCBvcCwgdm0sIGNiKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZWwuX192X3RyYW5zO1xuICBpZiAoIXRyYW5zaXRpb24gfHxcbiAgLy8gc2tpcCBpZiB0aGVyZSBhcmUgbm8ganMgaG9va3MgYW5kIENTUyB0cmFuc2l0aW9uIGlzXG4gIC8vIG5vdCBzdXBwb3J0ZWRcbiAgIXRyYW5zaXRpb24uaG9va3MgJiYgIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIHRyYW5zaXRpb25zIGZvciBpbml0aWFsIGNvbXBpbGVcbiAgIXZtLl9pc0NvbXBpbGVkIHx8XG4gIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgLy8gZHVyaW5nIHRoZSBwYXJlbnQncyBjb21waWxhdGlvbiBwaGFzZSwgc2tpcCB0aGVcbiAgLy8gYW5pbWF0aW9uLlxuICB2bS4kcGFyZW50ICYmICF2bS4kcGFyZW50Ll9pc0NvbXBpbGVkKSB7XG4gICAgb3AoKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhY3Rpb24gPSBkaXJlY3Rpb24gPiAwID8gJ2VudGVyJyA6ICdsZWF2ZSc7XG4gIHRyYW5zaXRpb25bYWN0aW9uXShvcCwgY2IpO1xufVxuXG52YXIgdHJhbnNpdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuICBhcHBlbmRXaXRoVHJhbnNpdGlvbjogYXBwZW5kV2l0aFRyYW5zaXRpb24sXG4gIGJlZm9yZVdpdGhUcmFuc2l0aW9uOiBiZWZvcmVXaXRoVHJhbnNpdGlvbixcbiAgcmVtb3ZlV2l0aFRyYW5zaXRpb246IHJlbW92ZVdpdGhUcmFuc2l0aW9uLFxuICBhcHBseVRyYW5zaXRpb246IGFwcGx5VHJhbnNpdGlvblxufSk7XG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBlbDtcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIHNlbGVjdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gKiBOb3RlOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgc2hvdWxkIHdvcmsgaGVyZVxuICogYnV0IGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBjb21tZW50IG5vZGVzIGluIHBoYW50b21qcyxcbiAqIG1ha2luZyB1bml0IHRlc3RzIGRpZmZpY3VsdC4gVGhpcyBpcyBmaXhlZCBieSBkb2luZyB0aGVcbiAqIGNvbnRhaW5zKCkgY2hlY2sgb24gdGhlIG5vZGUncyBwYXJlbnROb2RlIGluc3RlYWQgb2ZcbiAqIHRoZSBub2RlIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaW5Eb2Mobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBkb2MgPT09IG5vZGUgfHwgZG9jID09PSBwYXJlbnQgfHwgISEocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiBkb2MuY29udGFpbnMocGFyZW50KSk7XG59XG5cbi8qKlxuICogR2V0IGFuZCByZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IF9hdHRyXG4gKi9cblxuZnVuY3Rpb24gZ2V0QXR0cihub2RlLCBfYXR0cikge1xuICB2YXIgdmFsID0gbm9kZS5nZXRBdHRyaWJ1dGUoX2F0dHIpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogR2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGNvbG9uIG9yIHYtYmluZDogcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG5cbmZ1bmN0aW9uIGdldEJpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHZhbCA9IGdldEF0dHIobm9kZSwgJzonICsgbmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICB2YWwgPSBnZXRBdHRyKG5vZGUsICd2LWJpbmQ6JyArIG5hbWUpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogQ2hlY2sgdGhlIHByZXNlbmNlIG9mIGEgYmluZCBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5kQXR0cihub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgnOicgKyBuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndi1iaW5kOicgKyBuYW1lKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlKGVsLCB0YXJnZXQpIHtcbiAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBhZnRlciB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIGFmdGVyKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0Lm5leHRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZWwgZnJvbSBET01cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xufVxuXG4vKipcbiAqIFByZXBlbmQgZWwgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBwcmVwZW5kKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGFyZ2V0IHdpdGggZWxcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0LCBlbCkge1xuICB2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbmZ1bmN0aW9uIG9uKGVsLCBldmVudCwgY2IsIHVzZUNhcHR1cmUpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIHVzZUNhcHR1cmUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKTtcbn1cblxuLyoqXG4gKiBGb3IgSUU5IGNvbXBhdDogd2hlbiBib3RoIGNsYXNzIGFuZCA6Y2xhc3MgYXJlIHByZXNlbnRcbiAqIGdldEF0dHJpYnV0ZSgnY2xhc3MnKSByZXR1cm5zIHdyb25nIHZhbHVlLi4uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XG4gIHZhciBjbGFzc25hbWUgPSBlbC5jbGFzc05hbWU7XG4gIGlmICh0eXBlb2YgY2xhc3NuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGNsYXNzbmFtZSA9IGNsYXNzbmFtZS5iYXNlVmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBjbGFzc25hbWU7XG59XG5cbi8qKlxuICogSW4gSUU5LCBzZXRBdHRyaWJ1dGUoJ2NsYXNzJykgd2lsbCByZXN1bHQgaW4gZW1wdHkgY2xhc3NcbiAqIGlmIHRoZSBlbGVtZW50IGFsc28gaGFzIHRoZSA6Y2xhc3MgYXR0cmlidXRlOyBIb3dldmVyIGluXG4gKiBQaGFudG9tSlMsIHNldHRpbmcgYGNsYXNzTmFtZWAgZG9lcyBub3Qgd29yayBvbiBTVkcgZWxlbWVudHMuLi5cbiAqIFNvIHdlIGhhdmUgdG8gZG8gYSBjb25kaXRpb25hbCBjaGVjayBoZXJlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBzZXRDbGFzcyhlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgIS9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbHM7XG4gIH0gZWxzZSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBJRSAmIFNWR1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIGdldENsYXNzKGVsKSArICcgJztcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIHNldENsYXNzKGVsLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBzZXRDbGFzcyhlbCwgY3VyLnRyaW0oKSk7XG4gIH1cbiAgaWYgKCFlbC5jbGFzc05hbWUpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJhdyBjb250ZW50IGluc2lkZSBhbiBlbGVtZW50IGludG8gYSB0ZW1wb3JhcnlcbiAqIGNvbnRhaW5lciBkaXZcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzRnJhZ21lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29udGVudChlbCwgYXNGcmFnbWVudCkge1xuICB2YXIgY2hpbGQ7XG4gIHZhciByYXdDb250ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzVGVtcGxhdGUoZWwpICYmIGlzRnJhZ21lbnQoZWwuY29udGVudCkpIHtcbiAgICBlbCA9IGVsLmNvbnRlbnQ7XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRyaW1Ob2RlKGVsKTtcbiAgICByYXdDb250ZW50ID0gYXNGcmFnbWVudCA/IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gZWwuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdDb250ZW50O1xufVxuXG4vKipcbiAqIFRyaW0gcG9zc2libGUgZW1wdHkgaGVhZC90YWlsIHRleHQgYW5kIGNvbW1lbnRcbiAqIG5vZGVzIGluc2lkZSBhIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiB0cmltTm9kZShub2RlKSB7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VxdWVuY2VzICovXG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGlzVHJpbW1hYmxlKGNoaWxkKSkpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICB3aGlsZSAoKGNoaWxkID0gbm9kZS5sYXN0Q2hpbGQsIGlzVHJpbW1hYmxlKGNoaWxkKSkpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlcXVlbmNlcyAqL1xufVxuXG5mdW5jdGlvbiBpc1RyaW1tYWJsZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAzICYmICFub2RlLmRhdGEudHJpbSgpIHx8IG5vZGUubm9kZVR5cGUgPT09IDgpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAqIHdpbGwgYmUgaW4gbG93ZXJjYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiBpc1RlbXBsYXRlKGVsKSB7XG4gIHJldHVybiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RlbXBsYXRlJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHNjZW5hcmlvczpcbiAqIC0gZnJhZ21lbnQgaW5zdGFuY2VcbiAqIC0gdi1odG1sXG4gKiAtIHYtaWZcbiAqIC0gdi1mb3JcbiAqIC0gY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZU5vZGUodHJ1ZSksIHNvIGluIGNlcnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzIHRoZSBhbmNob3IgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5cbiAqIEByZXR1cm4ge0NvbW1lbnR8VGV4dH1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBbmNob3IoY29udGVudCwgcGVyc2lzdCkge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmRlYnVnID8gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50KSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBlcnNpc3QgPyAnICcgOiAnJyk7XG4gIGFuY2hvci5fX3ZfYW5jaG9yID0gdHJ1ZTtcbiAgcmV0dXJuIGFuY2hvcjtcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tcG9uZW50IHJlZiBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCAkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG52YXIgcmVmUkUgPSAvXnYtcmVmOi87XG5cbmZ1bmN0aW9uIGZpbmRSZWYobm9kZSkge1xuICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjYW1lbGl6ZShuYW1lLnJlcGxhY2UocmVmUkUsICcnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFwIGEgZnVuY3Rpb24gdG8gYSByYW5nZSBvZiBub2RlcyAuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3BcbiAqL1xuXG5mdW5jdGlvbiBtYXBOb2RlUmFuZ2Uobm9kZSwgZW5kLCBvcCkge1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKG5vZGUgIT09IGVuZCkge1xuICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIG9wKG5vZGUpO1xuICAgIG5vZGUgPSBuZXh0O1xuICB9XG4gIG9wKGVuZCk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgcmFuZ2Ugb2Ygbm9kZXMgd2l0aCB0cmFuc2l0aW9uLCBzdG9yZVxuICogdGhlIG5vZGVzIGluIGEgZnJhZ21lbnQgd2l0aCBjb3JyZWN0IG9yZGVyaW5nLFxuICogYW5kIGNhbGwgY2FsbGJhY2sgd2hlbiBkb25lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZW1vdmVkID0gMDtcbiAgdmFyIG5vZGVzID0gW107XG4gIG1hcE5vZGVSYW5nZShzdGFydCwgZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbmQpIGRvbmUgPSB0cnVlO1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgcmVtb3ZlV2l0aFRyYW5zaXRpb24obm9kZSwgdm0sIG9uUmVtb3ZlZCk7XG4gIH0pO1xuICBmdW5jdGlvbiBvblJlbW92ZWQoKSB7XG4gICAgcmVtb3ZlZCsrO1xuICAgIGlmIChkb25lICYmIHJlbW92ZWQgPj0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0ZyYWdtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xuICB9XG59XG5cbnZhciBjb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC9pO1xudmFyIHJlc2VydmVkVGFnUkUgPSAvXihzbG90fHBhcnRpYWx8Y29tcG9uZW50KSQvaTtcblxudmFyIGlzVW5rbm93bkVsZW1lbnQgPSB1bmRlZmluZWQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpc1Vua25vd25FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCB0YWcpIHtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICByZXR1cm4gZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHwgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpICYmXG4gICAgICAgIC8vIENocm9tZSByZXR1cm5zIHVua25vd24gZm9yIHNldmVyYWwgSFRNTDUgZWxlbWVudHMuXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01NDA1MjZcbiAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIHVua25vd24gZm9yIHNvbWUgXCJJbnRlcmFjdGl2ZSBlbGVtZW50cy5cIlxuICAgICAgICAhL14oZGF0YXx0aW1lfHJ0Y3xyYnxkZXRhaWxzfGRpYWxvZ3xzdW1tYXJ5KSQvLnRlc3QodGFnKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudCwgaWYgeWVzIHJldHVybiBpdHNcbiAqIGNvbXBvbmVudCBpZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpO1xuICBpZiAoIWNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiAhcmVzZXJ2ZWRUYWdSRS50ZXN0KHRhZykpIHtcbiAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXMgPSBoYXNBdHRycyAmJiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIHJldHVybiBpcztcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUYWcgPSBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwICYmIG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXBbdGFnXTtcbiAgICAgICAgaWYgKGV4cGVjdGVkVGFnKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtICcgKyAnZGlkIHlvdSBtZWFuIDwnICsgZXhwZWN0ZWRUYWcgKyAnPj8gJyArICdIVE1MIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHJlbWVtYmVyIHRvIHVzZSBrZWJhYi1jYXNlIGluIHRlbXBsYXRlcy4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Vua25vd25FbGVtZW50KGVsLCB0YWcpKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICsgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzQXR0cnMpIHtcbiAgICByZXR1cm4gZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBcImlzXCIgYmluZGluZyBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKSB7XG4gIC8vIGR5bmFtaWMgc3ludGF4XG4gIHZhciBleHAgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lzJyk7XG4gIGlmIChleHAgIT0gbnVsbCkge1xuICAgIGlmIChyZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCBleHApKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICByZXR1cm4geyBpZDogZXhwIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cCA9IGdldEJpbmRBdHRyKGVsLCAnaXMnKTtcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKlxuICogQWxsIHN0cmF0ZWd5IGZ1bmN0aW9ucyBmb2xsb3cgdGhlIHNhbWUgc2lnbmF0dXJlOlxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyZW50VmFsXG4gKiBAcGFyYW0geyp9IGNoaWxkVmFsXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICovXG5cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZURhdGEodG8sIGZyb20pIHtcbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodG9WYWwpICYmIGlzT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogRGF0YVxuICovXG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoY2hpbGRWYWwuY2FsbCh0aGlzKSwgcGFyZW50VmFsLmNhbGwodGhpcykpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHZtKSA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHZtKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIEVsXG4gKi9cblxuc3RyYXRzLmVsID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gIGlmICghdm0gJiYgY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZXQgPSBjaGlsZFZhbCB8fCBwYXJlbnRWYWw7XG4gIC8vIGludm9rZSB0aGUgZWxlbWVudCBmYWN0b3J5IGlmIHRoaXMgaXMgaW5zdGFuY2UgbWVyZ2VcbiAgcmV0dXJuIHZtICYmIHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgPyByZXQuY2FsbCh2bSkgOiByZXQ7XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID0gc3RyYXRzLmNyZWF0ZWQgPSBzdHJhdHMucmVhZHkgPSBzdHJhdHMuYXR0YWNoZWQgPSBzdHJhdHMuZGV0YWNoZWQgPSBzdHJhdHMuYmVmb3JlQ29tcGlsZSA9IHN0cmF0cy5jb21waWxlZCA9IHN0cmF0cy5iZWZvcmVEZXN0cm95ID0gc3RyYXRzLmRlc3Ryb3llZCA9IHN0cmF0cy5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG59O1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWwgPyBleHRlbmQocmVzLCBndWFyZEFycmF5QXNzZXRzKGNoaWxkVmFsKSkgOiByZXM7XG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID0gc3RyYXRzLmV2ZW50cyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnQgPyBwYXJlbnQuY29uY2F0KGNoaWxkKSA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuXG5zdHJhdHMucHJvcHMgPSBzdHJhdHMubWV0aG9kcyA9IHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cblxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICogY29uc3RydWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5jb21wb25lbnRzID0gZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpO1xuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKTtcbiAgICB2YXIgZGVmO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFwID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCA9IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGlkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBpZHNbaV07XG4gICAgICBpZiAoY29tbW9uVGFnUkUudGVzdChrZXkpIHx8IHJlc2VydmVkVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsga2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyByZWNvcmQgYSBhbGwgbG93ZXJjYXNlIDwtPiBrZWJhYi1jYXNlIG1hcHBpbmcgZm9yXG4gICAgICAvLyBwb3NzaWJsZSBjdXN0b20gZWxlbWVudCBjYXNlIGVycm9yIHdhcm5pbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1hcFtrZXkucmVwbGFjZSgvLS9nLCAnJykudG9Mb3dlckNhc2UoKV0gPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIGRlZiA9IGNvbXBvbmVudHNba2V5XTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlZikpIHtcbiAgICAgICAgY29tcG9uZW50c1trZXldID0gVnVlLmV4dGVuZChkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICB2YXIgaSwgdmFsO1xuICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICBvcHRpb25zLnByb3BzID0ge307XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh2YWwubmFtZSkge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbC5uYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNba2V5c1tpXV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR3VhcmQgYW4gQXJyYXktZm9ybWF0IGFzc2V0cyBvcHRpb24gYW5kIGNvbnZlcnRlZCBpdFxuICogaW50byB0aGUga2V5LXZhbHVlIE9iamVjdCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFzc2V0c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGd1YXJkQXJyYXlBc3NldHMoYXNzZXRzKSB7XG4gIGlmIChpc0FycmF5KGFzc2V0cykpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGkgPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBhc3NldDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhc3NldCA9IGFzc2V0c1tpXTtcbiAgICAgIHZhciBpZCA9IHR5cGVvZiBhc3NldCA9PT0gJ2Z1bmN0aW9uJyA/IGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lIHx8IGFzc2V0LmlkIDogYXNzZXQubmFtZSB8fCBhc3NldC5pZDtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBcnJheS1zeW50YXggYXNzZXRzIG11c3QgcHJvdmlkZSBhIFwibmFtZVwiIG9yIFwiaWRcIiBmaWVsZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1tpZF0gPSBhc3NldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYXNzZXRzO1xufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXSAtIGlmIHZtIGlzIHByZXNlbnQsIGluZGljYXRlcyB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgIGFuIGluc3RhbnRpYXRpb24gbWVyZ2UuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gIGd1YXJkQ29tcG9uZW50cyhjaGlsZCk7XG4gIGd1YXJkUHJvcHMoY2hpbGQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjaGlsZC5wcm9wc0RhdGEgJiYgIXZtKSB7XG4gICAgICB3YXJuKCdwcm9wc0RhdGEgY2FuIG9ubHkgYmUgdXNlZCBhcyBhbiBpbnN0YW50aWF0aW9uIG9wdGlvbi4nKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgaWYgKGNoaWxkWydleHRlbmRzJ10pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgY2hpbGRbJ2V4dGVuZHMnXSA9PT0gJ2Z1bmN0aW9uJyA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkWydleHRlbmRzJ10ub3B0aW9ucywgdm0pIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGRbJ2V4dGVuZHMnXSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIHZhciBtaXhpbk9wdGlvbnMgPSBtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUgPyBtaXhpbi5vcHRpb25zIDogbWl4aW47XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbk9wdGlvbnMsIHZtKTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2Fybk1pc3NpbmdcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgdmFyIGNhbWVsaXplZElkO1xuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fFxuICAvLyBjYW1lbENhc2UgSURcbiAgYXNzZXRzW2NhbWVsaXplZElkID0gY2FtZWxpemUoaWQpXSB8fFxuICAvLyBQYXNjYWwgQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbGl6ZWRJZC5zbGljZSgxKV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEZXAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn1cblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLiRyZW1vdmUoc3ViKTtcbn07XG5cbi8qKlxuICogQWRkIHNlbGYgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0YXJnZXQgd2F0Y2hlci5cbiAqL1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG59O1xuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0b0FycmF5KHRoaXMuc3Vicyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pXG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cblxuO1sncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnLCAnc29ydCcsICdyZXZlcnNlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvcigpIHtcbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbmRlZihhcnJheVByb3RvLCAnJHNldCcsIGZ1bmN0aW9uICRzZXQoaW5kZXgsIHZhbCkge1xuICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IE51bWJlcihpbmRleCkgKyAxO1xuICB9XG4gIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXTtcbn0pO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgdGhlIGVsZW1lbnQgYXQgZ2l2ZW4gaW5kZXggb3IgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaXRlbVxuICovXG5cbmRlZihhcnJheVByb3RvLCAnJHJlbW92ZScsIGZ1bmN0aW9uICRyZW1vdmUoaXRlbSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMsIGl0ZW0pO1xuICBpZiAoaW5kZXggPiAtMSkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn0pO1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgaW4gY2VydGFpbiBjYXNlcywgZS5nLlxuICogdi1mb3Igc2NvcGUgYWxpYXMgYW5kIHByb3BzLCB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb25cbiAqIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZSB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS5cbiAqXG4gKiBTbyB3aGVuZXZlciB3ZSB3YW50IHRvIHNldCBhIHJlYWN0aXZlIHByb3BlcnR5IHdpdGhvdXQgZm9yY2luZ1xuICogY29udmVyc2lvbiBvbiB0aGUgbmV3IHZhbHVlLCB3ZSB3cmFwIHRoYXQgY2FsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAqL1xuXG52YXIgc2hvdWxkQ29udmVydCA9IHRydWU7XG5cbmZ1bmN0aW9uIHdpdGhvdXRDb252ZXJzaW9uKGZuKSB7XG4gIHNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgZm4oKTtcbiAgc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvID8gcHJvdG9BdWdtZW50IDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59XG5cbi8vIEluc3RhbmNlIG1ldGhvZHNcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0aGlzLmNvbnZlcnQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcHJvcGVydHkgaW50byBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBlbWl0XG4gKiB0aGUgZXZlbnRzIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkL2NoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICBkZWZpbmVSZWFjdGl2ZSh0aGlzLnZhbHVlLCBrZXksIHZhbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gb3duZXIgdm0uIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIG9iamVjdCBpc1xuICogc3dhcHBlZCBvdXQgYXMgYW4gaW5zdGFuY2UncyAkZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLnJlbW92ZVZtID0gZnVuY3Rpb24gKHZtKSB7XG4gIHRoaXMudm1zLiRyZW1vdmUodm0pO1xufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXVnbWVudCh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWUsIHZtKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKHNob3VsZENvbnZlcnQgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJiAhdmFsdWUuX2lzVnVlKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKTtcbiAgfVxuICByZXR1cm4gb2I7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxudmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlLFxuXHRzZXQ6IHNldCxcblx0ZGVsOiBkZWwsXG5cdGhhc093bjogaGFzT3duLFxuXHRpc0xpdGVyYWw6IGlzTGl0ZXJhbCxcblx0aXNSZXNlcnZlZDogaXNSZXNlcnZlZCxcblx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG5cdHRvTnVtYmVyOiB0b051bWJlcixcblx0dG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG5cdHN0cmlwUXVvdGVzOiBzdHJpcFF1b3Rlcyxcblx0Y2FtZWxpemU6IGNhbWVsaXplLFxuXHRoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcblx0Y2xhc3NpZnk6IGNsYXNzaWZ5LFxuXHRiaW5kOiBiaW5kLFxuXHR0b0FycmF5OiB0b0FycmF5LFxuXHRleHRlbmQ6IGV4dGVuZCxcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuXHRkZWY6IGRlZixcblx0ZGVib3VuY2U6IF9kZWJvdW5jZSxcblx0aW5kZXhPZjogaW5kZXhPZixcblx0Y2FuY2VsbGFibGU6IGNhbmNlbGxhYmxlLFxuXHRsb29zZUVxdWFsOiBsb29zZUVxdWFsLFxuXHRpc0FycmF5OiBpc0FycmF5LFxuXHRoYXNQcm90bzogaGFzUHJvdG8sXG5cdGluQnJvd3NlcjogaW5Ccm93c2VyLFxuXHRkZXZ0b29sczogZGV2dG9vbHMsXG5cdGlzSUU6IGlzSUUsXG5cdGlzSUU5OiBpc0lFOSxcblx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG5cdGlzSW9zOiBpc0lvcyxcblx0aW9zVmVyc2lvbk1hdGNoOiBpb3NWZXJzaW9uTWF0Y2gsXG5cdGlvc1ZlcnNpb246IGlvc1ZlcnNpb24sXG5cdGhhc011dGF0aW9uT2JzZXJ2ZXJCdWc6IGhhc011dGF0aW9uT2JzZXJ2ZXJCdWcsXG5cdGdldCB0cmFuc2l0aW9uUHJvcCAoKSB7IHJldHVybiB0cmFuc2l0aW9uUHJvcDsgfSxcblx0Z2V0IHRyYW5zaXRpb25FbmRFdmVudCAoKSB7IHJldHVybiB0cmFuc2l0aW9uRW5kRXZlbnQ7IH0sXG5cdGdldCBhbmltYXRpb25Qcm9wICgpIHsgcmV0dXJuIGFuaW1hdGlvblByb3A7IH0sXG5cdGdldCBhbmltYXRpb25FbmRFdmVudCAoKSB7IHJldHVybiBhbmltYXRpb25FbmRFdmVudDsgfSxcblx0bmV4dFRpY2s6IG5leHRUaWNrLFxuXHRnZXQgX1NldCAoKSB7IHJldHVybiBfU2V0OyB9LFxuXHRxdWVyeTogcXVlcnksXG5cdGluRG9jOiBpbkRvYyxcblx0Z2V0QXR0cjogZ2V0QXR0cixcblx0Z2V0QmluZEF0dHI6IGdldEJpbmRBdHRyLFxuXHRoYXNCaW5kQXR0cjogaGFzQmluZEF0dHIsXG5cdGJlZm9yZTogYmVmb3JlLFxuXHRhZnRlcjogYWZ0ZXIsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRwcmVwZW5kOiBwcmVwZW5kLFxuXHRyZXBsYWNlOiByZXBsYWNlLFxuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHRzZXRDbGFzczogc2V0Q2xhc3MsXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHRleHRyYWN0Q29udGVudDogZXh0cmFjdENvbnRlbnQsXG5cdHRyaW1Ob2RlOiB0cmltTm9kZSxcblx0aXNUZW1wbGF0ZTogaXNUZW1wbGF0ZSxcblx0Y3JlYXRlQW5jaG9yOiBjcmVhdGVBbmNob3IsXG5cdGZpbmRSZWY6IGZpbmRSZWYsXG5cdG1hcE5vZGVSYW5nZTogbWFwTm9kZVJhbmdlLFxuXHRyZW1vdmVOb2RlUmFuZ2U6IHJlbW92ZU5vZGVSYW5nZSxcblx0aXNGcmFnbWVudDogaXNGcmFnbWVudCxcblx0Z2V0T3V0ZXJIVE1MOiBnZXRPdXRlckhUTUwsXG5cdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuXHRyZXNvbHZlQXNzZXQ6IHJlc29sdmVBc3NldCxcblx0Y2hlY2tDb21wb25lbnRBdHRyOiBjaGVja0NvbXBvbmVudEF0dHIsXG5cdGNvbW1vblRhZ1JFOiBjb21tb25UYWdSRSxcblx0cmVzZXJ2ZWRUYWdSRTogcmVzZXJ2ZWRUYWdSRSxcblx0Z2V0IHdhcm4gKCkgeyByZXR1cm4gd2FybjsgfVxufSk7XG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogVGhlIG1haW4gaW5pdCBzZXF1ZW5jZS4gVGhpcyBpcyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAgICogY29uc3RydWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBhbmQgdGhlIG9wdGlvbnMgcGFzc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLiRyb290ID0gdGhpcy4kcGFyZW50ID8gdGhpcy4kcGFyZW50LiRyb290IDogdGhpcztcbiAgICB0aGlzLiRjaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuJHJlZnMgPSB7fTsgLy8gY2hpbGQgdm0gcmVmZXJlbmNlc1xuICAgIHRoaXMuJGVscyA9IHt9OyAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgICB0aGlzLl93YXRjaGVycyA9IFtdOyAvLyBhbGwgd2F0Y2hlcnMgYXMgYW4gYXJyYXlcbiAgICB0aGlzLl9kaXJlY3RpdmVzID0gW107IC8vIGFsbCBkaXJlY3RpdmVzXG5cbiAgICAvLyBhIHVpZFxuICAgIHRoaXMuX3VpZCA9IHVpZCsrO1xuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB0aGlzLl9pc1Z1ZSA9IHRydWU7XG5cbiAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcbiAgICB0aGlzLl9ldmVudHMgPSB7fTsgLy8gcmVnaXN0ZXJlZCBjYWxsYmFja3NcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IHt9OyAvLyBmb3IgJGJyb2FkY2FzdCBvcHRpbWl6YXRpb25cblxuICAgIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhZ21lbnQgPSAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gLy8gQHR5cGUge1RleHR8Q29tbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IG51bGw7IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG5cbiAgICAvLyBsaWZlY3ljbGUgc3RhdGVcbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdGhpcy5faXNEZXN0cm95ZWQgPSB0aGlzLl9pc1JlYWR5ID0gdGhpcy5faXNBdHRhY2hlZCA9IHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0aGlzLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl91bmxpbmtGbiA9IG51bGw7XG5cbiAgICAvLyBjb250ZXh0OlxuICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuX2NvbnRleHQgfHwgdGhpcy4kcGFyZW50O1xuXG4gICAgLy8gc2NvcGU6XG4gICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGU7XG5cbiAgICAvLyBmcmFnbWVudDpcbiAgICAvLyBpZiB0aGlzIGluc3RhbmNlIGlzIGNvbXBpbGVkIGluc2lkZSBhIEZyYWdtZW50LCBpdFxuICAgIC8vIG5lZWRzIHRvIHJlaWdzdGVyIGl0c2VsZiBhcyBhIGNoaWxkIG9mIHRoYXQgZnJhZ21lbnRcbiAgICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICAgIHRoaXMuX2ZyYWcgPSBvcHRpb25zLl9mcmFnO1xuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQuJGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucy5cbiAgICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gc2V0IHJlZlxuICAgIHRoaXMuX3VwZGF0ZVJlZigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIGFzIGVtcHR5IG9iamVjdC5cbiAgICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdERhdGEoKS5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAvLyBjYWxsIGluaXQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdpbml0Jyk7XG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgb2JzZXJ2YXRpb24gYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxuICAgIHRoaXMuX2luaXRTdGF0ZSgpO1xuXG4gICAgLy8gc2V0dXAgZXZlbnQgc3lzdGVtIGFuZCBvcHRpb24gZXZlbnRzLlxuICAgIHRoaXMuX2luaXRFdmVudHMoKTtcblxuICAgIC8vIGNhbGwgY3JlYXRlZCBob29rXG4gICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcblxuICAgIC8vIGlmIGBlbGAgb3B0aW9uIGlzIHBhc3NlZCwgc3RhcnQgY29tcGlsYXRpb24uXG4gICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgIHRoaXMuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhdGhDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxuLy8gYWN0aW9uc1xudmFyIEFQUEVORCA9IDA7XG52YXIgUFVTSCA9IDE7XG52YXIgSU5DX1NVQl9QQVRIX0RFUFRIID0gMjtcbnZhciBQVVNIX1NVQl9QQVRIID0gMztcblxuLy8gc3RhdGVzXG52YXIgQkVGT1JFX1BBVEggPSAwO1xudmFyIElOX1BBVEggPSAxO1xudmFyIEJFRk9SRV9JREVOVCA9IDI7XG52YXIgSU5fSURFTlQgPSAzO1xudmFyIElOX1NVQl9QQVRIID0gNDtcbnZhciBJTl9TSU5HTEVfUVVPVEUgPSA1O1xudmFyIElOX0RPVUJMRV9RVU9URSA9IDY7XG52YXIgQUZURVJfUEFUSCA9IDc7XG52YXIgRVJST1IgPSA4O1xuXG52YXIgcGF0aFN0YXRlTWFjaGluZSA9IFtdO1xuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9QQVRIXSA9IHtcbiAgJ3dzJzogW0JFRk9SRV9QQVRIXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fUEFUSF0gPSB7XG4gICd3cyc6IFtJTl9QQVRIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5UXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfSURFTlRdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fSURFTlRdID0ge1xuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICcwJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnbnVtYmVyJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnd3MnOiBbSU5fUEFUSCwgUFVTSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVCwgUFVTSF0sXG4gICdbJzogW0lOX1NVQl9QQVRILCBQVVNIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRILCBQVVNIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9TVUJfUEFUSF0gPSB7XG4gIFwiJ1wiOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdLFxuICAnXCInOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgSU5DX1NVQl9QQVRIX0RFUFRIXSxcbiAgJ10nOiBbSU5fUEFUSCwgUFVTSF9TVUJfUEFUSF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU1VCX1BBVEgsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU0lOR0xFX1FVT1RFXSA9IHtcbiAgXCInXCI6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fRE9VQkxFX1FVT1RFXSA9IHtcbiAgJ1wiJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBjaGFyYWN0ZXIgaW4gYSBrZXlwYXRoLlxuICpcbiAqIEBwYXJhbSB7Q2hhcn0gY2hcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhDaGFyVHlwZShjaCkge1xuICBpZiAoY2ggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnZW9mJztcbiAgfVxuXG4gIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4NUI6IC8vIFtcbiAgICBjYXNlIDB4NUQ6IC8vIF1cbiAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICBjYXNlIDB4MjI6IC8vIFwiXG4gICAgY2FzZSAweDI3OiAvLyAnXG4gICAgY2FzZSAweDMwOlxuICAgICAgLy8gMFxuICAgICAgcmV0dXJuIGNoO1xuXG4gICAgY2FzZSAweDVGOiAvLyBfXG4gICAgY2FzZSAweDI0OlxuICAgICAgLy8gJFxuICAgICAgcmV0dXJuICdpZGVudCc7XG5cbiAgICBjYXNlIDB4MjA6IC8vIFNwYWNlXG4gICAgY2FzZSAweDA5OiAvLyBUYWJcbiAgICBjYXNlIDB4MEE6IC8vIE5ld2xpbmVcbiAgICBjYXNlIDB4MEQ6IC8vIFJldHVyblxuICAgIGNhc2UgMHhBMDogLy8gTm8tYnJlYWsgc3BhY2VcbiAgICBjYXNlIDB4RkVGRjogLy8gQnl0ZSBPcmRlciBNYXJrXG4gICAgY2FzZSAweDIwMjg6IC8vIExpbmUgU2VwYXJhdG9yXG4gICAgY2FzZSAweDIwMjk6XG4gICAgICAvLyBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gICAgICByZXR1cm4gJ3dzJztcbiAgfVxuXG4gIC8vIGEteiwgQS1aXG4gIGlmIChjb2RlID49IDB4NjEgJiYgY29kZSA8PSAweDdBIHx8IGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NUEpIHtcbiAgICByZXR1cm4gJ2lkZW50JztcbiAgfVxuXG4gIC8vIDEtOVxuICBpZiAoY29kZSA+PSAweDMxICYmIGNvZGUgPD0gMHgzOSkge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuXG4gIHJldHVybiAnZWxzZSc7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc3ViUGF0aCwgcmV0dXJuIGl0cyBwbGFpbiBmb3JtIGlmIGl0IGlzXG4gKiBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci4gT3RoZXJ3aXNlIHByZXBlbmQgdGhlXG4gKiBkeW5hbWljIGluZGljYXRvciAoKikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRTdWJQYXRoKHBhdGgpIHtcbiAgdmFyIHRyaW1tZWQgPSBwYXRoLnRyaW0oKTtcbiAgLy8gaW52YWxpZCBsZWFkaW5nIDBcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnMCcgJiYgaXNOYU4ocGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTGl0ZXJhbCh0cmltbWVkKSA/IHN0cmlwUXVvdGVzKHRyaW1tZWQpIDogJyonICsgdHJpbW1lZDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBtb2RlID0gQkVGT1JFX1BBVEg7XG4gIHZhciBzdWJQYXRoRGVwdGggPSAwO1xuICB2YXIgYywgbmV3Q2hhciwga2V5LCB0eXBlLCB0cmFuc2l0aW9uLCBhY3Rpb24sIHR5cGVNYXA7XG5cbiAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIGFjdGlvbnNbQVBQRU5EXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9IG5ld0NoYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSArPSBuZXdDaGFyO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0lOQ19TVUJfUEFUSF9ERVBUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgc3ViUGF0aERlcHRoKys7XG4gIH07XG5cbiAgYWN0aW9uc1tQVVNIX1NVQl9QQVRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3ViUGF0aERlcHRoID4gMCkge1xuICAgICAgc3ViUGF0aERlcHRoLS07XG4gICAgICBtb2RlID0gSU5fU1VCX1BBVEg7XG4gICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViUGF0aERlcHRoID0gMDtcbiAgICAgIGtleSA9IGZvcm1hdFN1YlBhdGgoa2V5KTtcbiAgICAgIGlmIChrZXkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnNbUFVTSF0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVVbmVzY2FwZVF1b3RlKCkge1xuICAgIHZhciBuZXh0Q2hhciA9IHBhdGhbaW5kZXggKyAxXTtcbiAgICBpZiAobW9kZSA9PT0gSU5fU0lOR0xFX1FVT1RFICYmIG5leHRDaGFyID09PSBcIidcIiB8fCBtb2RlID09PSBJTl9ET1VCTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09ICdcIicpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICBuZXdDaGFyID0gJ1xcXFwnICsgbmV4dENoYXI7XG4gICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChtb2RlICE9IG51bGwpIHtcbiAgICBpbmRleCsrO1xuICAgIGMgPSBwYXRoW2luZGV4XTtcblxuICAgIGlmIChjID09PSAnXFxcXCcgJiYgbWF5YmVVbmVzY2FwZVF1b3RlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBnZXRQYXRoQ2hhclR5cGUoYyk7XG4gICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV07XG4gICAgdHJhbnNpdGlvbiA9IHR5cGVNYXBbdHlwZV0gfHwgdHlwZU1hcFsnZWxzZSddIHx8IEVSUk9SO1xuXG4gICAgaWYgKHRyYW5zaXRpb24gPT09IEVSUk9SKSB7XG4gICAgICByZXR1cm47IC8vIHBhcnNlIGVycm9yXG4gICAgfVxuXG4gICAgbW9kZSA9IHRyYW5zaXRpb25bMF07XG4gICAgYWN0aW9uID0gYWN0aW9uc1t0cmFuc2l0aW9uWzFdXTtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBuZXdDaGFyID0gdHJhbnNpdGlvblsyXTtcbiAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWQgPyBjIDogbmV3Q2hhcjtcbiAgICAgIGlmIChhY3Rpb24oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlID09PSBBRlRFUl9QQVRIKSB7XG4gICAgICBrZXlzLnJhdyA9IHBhdGg7XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRlcm5hbCBwYXJzZSB0aGF0IGNoZWNrIGZvciBhIGNhY2hlIGhpdCBmaXJzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIGhpdCA9IHBhdGhDYWNoZS5nZXQocGF0aCk7XG4gIGlmICghaGl0KSB7XG4gICAgaGl0ID0gcGFyc2UocGF0aCk7XG4gICAgaWYgKGhpdCkge1xuICAgICAgcGF0aENhY2hlLnB1dChwYXRoLCBoaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGl0O1xufVxuXG4vKipcbiAqIEdldCBmcm9tIGFuIG9iamVjdCBmcm9tIGEgcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICovXG5cbmZ1bmN0aW9uIGdldFBhdGgob2JqLCBwYXRoKSB7XG4gIHJldHVybiBwYXJzZUV4cHJlc3Npb24ocGF0aCkuZ2V0KG9iaik7XG59XG5cbi8qKlxuICogV2FybiBhZ2FpbnN0IHNldHRpbmcgbm9uLWV4aXN0ZW50IHJvb3QgcGF0aCBvbiBhIHZtLlxuICovXG5cbnZhciB3YXJuTm9uRXhpc3RlbnQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuTm9uRXhpc3RlbnQgPSBmdW5jdGlvbiAocGF0aCwgdm0pIHtcbiAgICB3YXJuKCdZb3UgYXJlIHNldHRpbmcgYSBub24tZXhpc3RlbnQgcGF0aCBcIicgKyBwYXRoLnJhdyArICdcIiAnICsgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgKyAnd2l0aCB0aGUgXCJkYXRhXCIgb3B0aW9uIGZvciBtb3JlIHJlbGlhYmxlIHJlYWN0aXZpdHkgJyArICdhbmQgYmV0dGVyIHBlcmZvcm1hbmNlLicsIHZtKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXQgb24gYW4gb2JqZWN0IGZyb20gYSBwYXRoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gcGF0aFxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBzZXRQYXRoKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9iajtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBwYXJzZShwYXRoKTtcbiAgfVxuICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3QsIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxhc3QgPSBvYmo7XG4gICAga2V5ID0gcGF0aFtpXTtcbiAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJyonKSB7XG4gICAgICBrZXkgPSBwYXJzZUV4cHJlc3Npb24oa2V5LnNsaWNlKDEpKS5nZXQuY2FsbChvcmlnaW5hbCwgb3JpZ2luYWwpO1xuICAgIH1cbiAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCwgbGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGxhc3QsIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBvYmouJHNldChrZXksIHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KG9iaiwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHBhdGggPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VQYXRoOiBwYXJzZVBhdGgsXG4gIGdldFBhdGg6IGdldFBhdGgsXG4gIHNldFBhdGg6IHNldFBhdGhcbn0pO1xuXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgYWxsb3dlZEtleXdvcmRzID0gJ01hdGgsRGF0ZSx0aGlzLHRydWUsZmFsc2UsbnVsbCx1bmRlZmluZWQsSW5maW5pdHksTmFOLCcgKyAnaXNOYU4saXNGaW5pdGUsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksJyArICdlbmNvZGVVUklDb21wb25lbnQscGFyc2VJbnQscGFyc2VGbG9hdCc7XG52YXIgYWxsb3dlZEtleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBhbGxvd2VkS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID0gJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICsgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgKyAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgKyAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArICdwcm90ZWN0ZWQsc3RhdGljLGludGVyZmFjZSxwcml2YXRlLHB1YmxpYyc7XG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxudmFyIHdzUkUgPSAvXFxzL2c7XG52YXIgbmV3bGluZVJFID0gL1xcbi9nO1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYCl8bmV3IHx0eXBlb2YgfHZvaWQgL2c7XG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZztcbnZhciBwYXRoVGVzdFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC87XG52YXIgaWRlbnRSRSA9IC9bXlxcdyRcXC5dKD86W0EtWmEtel8kXVtcXHckXSopL2c7XG52YXIgbGl0ZXJhbFZhbHVlUkUkMSA9IC9eKD86dHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZHxJbmZpbml0eXxOYU4pJC87XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIFNhdmUgLyBSZXdyaXRlIC8gUmVzdG9yZVxuICpcbiAqIFdoZW4gcmV3cml0aW5nIHBhdGhzIGZvdW5kIGluIGFuIGV4cHJlc3Npb24sIGl0IGlzXG4gKiBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgbGV0dGVyIHNlcXVlbmNlcyB0byBiZSBmb3VuZCBpblxuICogc3RyaW5ncyBhbmQgT2JqZWN0IGxpdGVyYWwgcHJvcGVydHkga2V5cy4gVGhlcmVmb3JlIHdlXG4gKiByZW1vdmUgYW5kIHN0b3JlIHRoZXNlIHBhcnRzIGluIGEgdGVtcG9yYXJ5IGFycmF5LCBhbmRcbiAqIHJlc3RvcmUgdGhlbSBhZnRlciB0aGUgcGF0aCByZXdyaXRlLlxuICovXG5cbnZhciBzYXZlZCA9IFtdO1xuXG4vKipcbiAqIFNhdmUgcmVwbGFjZXJcbiAqXG4gKiBUaGUgc2F2ZSByZWdleCBjYW4gbWF0Y2ggdHdvIHBvc3NpYmxlIGNhc2VzOlxuICogMS4gQW4gb3BlbmluZyBvYmplY3QgbGl0ZXJhbFxuICogMi4gQSBzdHJpbmdcbiAqIElmIG1hdGNoZWQgYXMgYSBwbGFpbiBzdHJpbmcsIHdlIG5lZWQgdG8gZXNjYXBlIGl0c1xuICogbmV3bGluZXMsIHNpbmNlIHRoZSBzdHJpbmcgbmVlZHMgdG8gYmUgcHJlc2VydmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBwbGFjZWhvbGRlciB3aXRoIGluZGV4XG4gKi9cblxuZnVuY3Rpb24gc2F2ZShzdHIsIGlzU3RyaW5nKSB7XG4gIHZhciBpID0gc2F2ZWQubGVuZ3RoO1xuICBzYXZlZFtpXSA9IGlzU3RyaW5nID8gc3RyLnJlcGxhY2UobmV3bGluZVJFLCAnXFxcXG4nKSA6IHN0cjtcbiAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbn1cblxuLyoqXG4gKiBQYXRoIHJld3JpdGUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmV3cml0ZShyYXcpIHtcbiAgdmFyIGMgPSByYXcuY2hhckF0KDApO1xuICB2YXIgcGF0aCA9IHJhdy5zbGljZSgxKTtcbiAgaWYgKGFsbG93ZWRLZXl3b3Jkc1JFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJ1wiJykgPiAtMSA/IHBhdGgucmVwbGFjZShyZXN0b3JlUkUsIHJlc3RvcmUpIDogcGF0aDtcbiAgICByZXR1cm4gYyArICdzY29wZS4nICsgcGF0aDtcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaSAtIG1hdGNoZWQgc2F2ZSBpbmRleFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmUoc3RyLCBpKSB7XG4gIHJldHVybiBzYXZlZFtpXTtcbn1cblxuLyoqXG4gKiBSZXdyaXRlIGFuIGV4cHJlc3Npb24sIHByZWZpeGluZyBhbGwgcGF0aCBhY2Nlc3NvcnMgd2l0aFxuICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVHZXR0ZXIoZXhwKSB7XG4gIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBdm9pZCB1c2luZyByZXNlcnZlZCBrZXl3b3JkcyBpbiBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxuICAvLyByZXNldCBzdGF0ZVxuICBzYXZlZC5sZW5ndGggPSAwO1xuICAvLyBzYXZlIHN0cmluZ3MgYW5kIG9iamVjdCBsaXRlcmFsIGtleXNcbiAgdmFyIGJvZHkgPSBleHAucmVwbGFjZShzYXZlUkUsIHNhdmUpLnJlcGxhY2Uod3NSRSwgJycpO1xuICAvLyByZXdyaXRlIGFsbCBwYXRoc1xuICAvLyBwYWQgMSBzcGFjZSBoZXJlIGJlY2F1c2UgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSkucmVwbGFjZShpZGVudFJFLCByZXdyaXRlKS5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSk7XG4gIHJldHVybiBtYWtlR2V0dGVyRm4oYm9keSk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBnZXR0ZXIgZnVuY3Rpb24uIFJlcXVpcmVzIGV2YWwuXG4gKlxuICogV2UgaXNvbGF0ZSB0aGUgdHJ5L2NhdGNoIHNvIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZVxuICogb3B0aW1pemF0aW9uIG9mIHRoZSBwYXJzZSBmdW5jdGlvbiB3aGVuIGl0IGlzIG5vdCBjYWxsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlR2V0dGVyRm4oYm9keSkge1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAncmV0dXJuICcgKyBib2R5ICsgJzsnKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBkZWZhdWx0IGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiBlbnZpcm9ubWVudCAnICsgJ3dpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgKyAnVXNlIHRoZSBDU1AtY29tcGxpYW50IGJ1aWxkIGluc3RlYWQ6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbCNDU1AtY29tcGxpYW50LWJ1aWxkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGV4cHJlc3Npb24uICcgKyAnR2VuZXJhdGVkIGZ1bmN0aW9uIGJvZHk6ICcgKyBib2R5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVNldHRlcihleHApIHtcbiAgdmFyIHBhdGggPSBwYXJzZVBhdGgoZXhwKTtcbiAgaWYgKHBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCB2YWwpIHtcbiAgICAgIHNldFBhdGgoc2NvcGUsIHBhdGgsIHZhbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgc2V0dGVyIGV4cHJlc3Npb246ICcgKyBleHApO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIHJlLXdyaXR0ZW4gZ2V0dGVyL3NldHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBuZWVkU2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oZXhwLCBuZWVkU2V0KSB7XG4gIGV4cCA9IGV4cC50cmltKCk7XG4gIC8vIHRyeSBjYWNoZVxuICB2YXIgaGl0ID0gZXhwcmVzc2lvbkNhY2hlLmdldChleHApO1xuICBpZiAoaGl0KSB7XG4gICAgaWYgKG5lZWRTZXQgJiYgIWhpdC5zZXQpIHtcbiAgICAgIGhpdC5zZXQgPSBjb21waWxlU2V0dGVyKGhpdC5leHApO1xuICAgIH1cbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIHZhciByZXMgPSB7IGV4cDogZXhwIH07XG4gIHJlcy5nZXQgPSBpc1NpbXBsZVBhdGgoZXhwKSAmJiBleHAuaW5kZXhPZignWycpIDwgMFxuICAvLyBvcHRpbWl6ZWQgc3VwZXIgc2ltcGxlIGdldHRlclxuICA/IG1ha2VHZXR0ZXJGbignc2NvcGUuJyArIGV4cClcbiAgLy8gZHluYW1pYyBnZXR0ZXJcbiAgOiBjb21waWxlR2V0dGVyKGV4cCk7XG4gIGlmIChuZWVkU2V0KSB7XG4gICAgcmVzLnNldCA9IGNvbXBpbGVTZXR0ZXIoZXhwKTtcbiAgfVxuICBleHByZXNzaW9uQ2FjaGUucHV0KGV4cCwgcmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1NpbXBsZVBhdGgoZXhwKSB7XG4gIHJldHVybiBwYXRoVGVzdFJFLnRlc3QoZXhwKSAmJlxuICAvLyBkb24ndCB0cmVhdCBsaXRlcmFsIHZhbHVlcyBhcyBwYXRoc1xuICAhbGl0ZXJhbFZhbHVlUkUkMS50ZXN0KGV4cCkgJiZcbiAgLy8gTWF0aCBjb25zdGFudHMgZS5nLiBNYXRoLlBJLCBNYXRoLkUgZXRjLlxuICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLic7XG59XG5cbnZhciBleHByZXNzaW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRXhwcmVzc2lvbjogcGFyc2VFeHByZXNzaW9uLFxuICBpc1NpbXBsZVBhdGg6IGlzU2ltcGxlUGF0aFxufSk7XG5cbi8vIHdlIGhhdmUgdHdvIHNlcGFyYXRlIHF1ZXVlczogb25lIGZvciBkaXJlY3RpdmUgdXBkYXRlc1xuLy8gYW5kIG9uZSBmb3IgdXNlciB3YXRjaGVyIHJlZ2lzdGVyZWQgdmlhICR3YXRjaCgpLlxuLy8gd2Ugd2FudCB0byBndWFyYW50ZWUgZGlyZWN0aXZlIHVwZGF0ZXMgdG8gYmUgY2FsbGVkXG4vLyBiZWZvcmUgdXNlciB3YXRjaGVycyBzbyB0aGF0IHdoZW4gdXNlciB3YXRjaGVycyBhcmVcbi8vIHRyaWdnZXJlZCwgdGhlIERPTSB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiBpbiB1cGRhdGVkXG4vLyBzdGF0ZS5cblxudmFyIHF1ZXVlID0gW107XG52YXIgdXNlclF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG5cbi8qKlxuICogUmVzZXQgdGhlIGJhdGNoZXIncyBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiByZXNldEJhdGNoZXJTdGF0ZSgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgdXNlclF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBjaXJjdWxhciA9IHt9O1xuICB3YWl0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cblxuZnVuY3Rpb24gZmx1c2hCYXRjaGVyUXVldWUoKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKTtcbiAgICBydW5CYXRjaGVyUXVldWUodXNlclF1ZXVlKTtcbiAgICAvLyB1c2VyIHdhdGNoZXJzIHRyaWdnZXJlZCBtb3JlIHdhdGNoZXJzLFxuICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZGVwbGV0ZXNcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH1cbiAgICAvLyBkZXYgdG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG4gICAgcmVzZXRCYXRjaGVyU3RhdGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1biB0aGUgd2F0Y2hlcnMgaW4gYSBzaW5nbGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAqL1xuXG5mdW5jdGlvbiBydW5CYXRjaGVyUXVldWUocXVldWUpIHtcbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArICd3aXRoIGV4cHJlc3Npb24gXCInICsgd2F0Y2hlci5leHByZXNzaW9uICsgJ1wiJywgd2F0Y2hlci52bSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICpcbiAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlclxuICogICBwcm9wZXJ0aWVzOlxuICogICAtIHtOdW1iZXJ9IGlkXG4gKiAgIC0ge0Z1bmN0aW9ufSBydW5cbiAqL1xuXG5mdW5jdGlvbiBwdXNoV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAvLyBwdXNoIHdhdGNoZXIgaW50byBhcHByb3ByaWF0ZSBxdWV1ZVxuICAgIHZhciBxID0gd2F0Y2hlci51c2VyID8gdXNlclF1ZXVlIDogcXVldWU7XG4gICAgaGFzW2lkXSA9IHEubGVuZ3RoO1xuICAgIHEucHVzaCh3YXRjaGVyKTtcbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hCYXRjaGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgIC0ge0FycmF5fSBmaWx0ZXJzXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdHdvV2F5XG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHVzZXJcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBzeW5jXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gbGF6eVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcHJlUHJvY2Vzc11cbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3Bvc3RQcm9jZXNzXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gIC8vIG1peCBpbiBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbic7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm47XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLnByZXZFcnJvciA9IG51bGw7IC8vIGZvciBhc3luYyBlcnJvciBzdGFja3NcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgICB0aGlzLnNldHRlciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cE9yRm4sIHRoaXMudHdvV2F5KTtcbiAgICB0aGlzLmdldHRlciA9IHJlcy5nZXQ7XG4gICAgdGhpcy5zZXR0ZXIgPSByZXMuc2V0O1xuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xuICAvLyBzdGF0ZSBmb3IgYXZvaWRpbmcgZmFsc2UgdHJpZ2dlcnMgZm9yIGRlZXAgYW5kIEFycmF5XG4gIC8vIHdhdGNoZXJzIGR1cmluZyB2bS5fZGlnZXN0KClcbiAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJlZm9yZUdldCgpO1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gIHZhciB2YWx1ZTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgd2FybignRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gJyArICdcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCI6ICcgKyBlLnRvU3RyaW5nKCksIHRoaXMudm0pO1xuICAgIH1cbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHRoaXMucHJlUHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wcmVQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKHZhbHVlLCBudWxsLCB0aGlzLmZpbHRlcnMsIGZhbHNlKTtcbiAgfVxuICBpZiAodGhpcy5wb3N0UHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSk7XG4gIH1cbiAgdGhpcy5hZnRlckdldCgpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSB3aXRoIHRoZSBzZXR0ZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aGlzLnNldHRlci5jYWxsKHNjb3BlLCBzY29wZSwgdmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgc2V0dGVyICcgKyAnXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiOiAnICsgZS50b1N0cmluZygpLCB0aGlzLnZtKTtcbiAgICB9XG4gIH1cbiAgLy8gdHdvLXdheSBzeW5jIGZvciB2LWZvciBhbGlhc1xuICB2YXIgZm9yQ29udGV4dCA9IHNjb3BlLiRmb3JDb250ZXh0O1xuICBpZiAoZm9yQ29udGV4dCAmJiBmb3JDb250ZXh0LmFsaWFzID09PSB0aGlzLmV4cHJlc3Npb24pIHtcbiAgICBpZiAoZm9yQ29udGV4dC5maWx0ZXJzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdHdvLXdheSBiaW5kaW5nIG9uICcgKyAnYSB2LWZvciBhbGlhcyAoJyArIHRoaXMuZXhwcmVzc2lvbiArICcpLCBhbmQgdGhlICcgKyAndi1mb3IgaGFzIGZpbHRlcnMuIFRoaXMgd2lsbCBub3Qgd29yayBwcm9wZXJseS4gJyArICdFaXRoZXIgcmVtb3ZlIHRoZSBmaWx0ZXJzIG9yIHVzZSBhbiBhcnJheSBvZiAnICsgJ29iamVjdHMgYW5kIGJpbmQgdG8gb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yQ29udGV4dC5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjb3BlLiRrZXkpIHtcbiAgICAgICAgLy8gb3JpZ2luYWwgaXMgYW4gb2JqZWN0XG4gICAgICAgIGZvckNvbnRleHQucmF3VmFsdWVbc2NvcGUuJGtleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckNvbnRleHQucmF3VmFsdWUuJHNldChzY29wZS4kaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYmVmb3JlR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0RlcH0gZGVwXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWZ0ZXJHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSBudWxsO1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaGFsbG93XG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNoYWxsb3cpIHtcbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYyB8fCAhY29uZmlnLmFzeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkID8gc2hhbGxvdyA/IHRoaXMuc2hhbGxvdyA6IGZhbHNlIDogISFzaGFsbG93O1xuICAgIHRoaXMucXVldWVkID0gdHJ1ZTtcbiAgICAvLyByZWNvcmQgYmVmb3JlLXB1c2ggZXJyb3Igc3RhY2sgaW4gZGVidWcgbW9kZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5wcmV2RXJyb3IgPSBuZXcgRXJyb3IoJ1t2dWVdIGFzeW5jIHN0YWNrIHRyYWNlJyk7XG4gICAgfVxuICAgIHB1c2hXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhdGNoZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBiYXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgLy8gaGF2ZSBtdXRhdGVkOyBidXQgb25seSBkbyBzbyBpZiB0aGlzIGlzIGFcbiAgICAvLyBub24tc2hhbGxvdyB1cGRhdGUgKGNhdXNlZCBieSBhIHZtIGRpZ2VzdCkuXG4gICAgKGlzT2JqZWN0KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBpbiBkZWJ1ZyArIGFzeW5jIG1vZGUsIHdoZW4gYSB3YXRjaGVyIGNhbGxiYWNrc1xuICAgICAgLy8gdGhyb3dzLCB3ZSBhbHNvIHRocm93IHRoZSBzYXZlZCBiZWZvcmUtcHVzaCBlcnJvclxuICAgICAgLy8gc28gdGhlIGZ1bGwgY3Jvc3MtdGljayBzdGFjayB0cmFjZSBpcyBhdmFpbGFibGUuXG4gICAgICB2YXIgcHJldkVycm9yID0gdGhpcy5wcmV2RXJyb3I7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1ZyAmJiBwcmV2RXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcHJldkVycm9yO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICB2YXIgY3VycmVudCA9IERlcC50YXJnZXQ7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIERlcC50YXJnZXQgPSBjdXJyZW50O1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQgb3IgaXMgcGVyZm9ybWluZyBhIHYtZm9yXG4gICAgLy8gcmUtcmVuZGVyICh0aGUgd2F0Y2hlciBsaXN0IGlzIHRoZW4gZmlsdGVyZWQgYnkgdi1mb3IpLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdGhpcy52bS5fdkZvclJlbW92aW5nKSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3J1c2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgdmFyIGkgPSB1bmRlZmluZWQsXG4gICAgICBrZXlzID0gdW5kZWZpbmVkO1xuICBpZiAoIXNlZW4pIHtcbiAgICBzZWVuID0gc2Vlbk9iamVjdHM7XG4gICAgc2Vlbi5jbGVhcigpO1xuICB9XG4gIHZhciBpc0EgPSBpc0FycmF5KHZhbCk7XG4gIHZhciBpc08gPSBpc09iamVjdCh2YWwpO1xuICBpZiAoKGlzQSB8fCBpc08pICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBKSB7XG4gICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gICAgfSBlbHNlIGlmIChpc08pIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHQkMSA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHRoaXMuYXR0ciA9IHRoaXMuZWwubm9kZVR5cGUgPT09IDMgPyAnZGF0YScgOiAndGV4dENvbnRlbnQnO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5lbFt0aGlzLmF0dHJdID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgfVxufTtcblxudmFyIHRlbXBsYXRlQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgaWRTZWxlY3RvckNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgbWFwID0ge1xuICBlZmF1bHQ6IFswLCAnJywgJyddLFxuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J11cbn07XG5cbm1hcC50ZCA9IG1hcC50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG5tYXAub3B0aW9uID0gbWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9IG1hcC50Ym9keSA9IG1hcC5jb2xncm91cCA9IG1hcC5jYXB0aW9uID0gbWFwLnRmb290ID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG5cbm1hcC5nID0gbWFwLmRlZnMgPSBtYXAuc3ltYm9sID0gbWFwLnVzZSA9IG1hcC5pbWFnZSA9IG1hcC50ZXh0ID0gbWFwLmNpcmNsZSA9IG1hcC5lbGxpcHNlID0gbWFwLmxpbmUgPSBtYXAucGF0aCA9IG1hcC5wb2x5Z29uID0gbWFwLnBvbHlsaW5lID0gbWFwLnJlY3QgPSBbMSwgJzxzdmcgJyArICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnICsgJ3htbG5zOmV2PVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzXCInICsgJ3ZlcnNpb249XCIxLjFcIj4nLCAnPC9zdmc+J107XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgc3VwcG9ydGVkIHRlbXBsYXRlIG5vZGUgd2l0aCBhXG4gKiBEb2N1bWVudEZyYWdtZW50IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVhbFRlbXBsYXRlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVGVtcGxhdGUobm9kZSkgJiYgaXNGcmFnbWVudChub2RlLmNvbnRlbnQpO1xufVxuXG52YXIgdGFnUkUkMSA9IC88KFtcXHc6LV0rKS87XG52YXIgZW50aXR5UkUgPSAvJiM/XFx3Kz87LztcbnZhciBjb21tZW50UkUgPSAvPCEtLS87XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0ZW1wbGF0ZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKiBEZXRlcm1pbmVzIGNvcnJlY3Qgd3JhcHBpbmcgYnkgdGFnIHR5cGVzLiBXcmFwcGluZ1xuICogc3RyYXRlZ3kgZm91bmQgaW4galF1ZXJ5ICYgY29tcG9uZW50L2RvbWlmeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVTdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvRnJhZ21lbnQodGVtcGxhdGVTdHJpbmcsIHJhdykge1xuICAvLyB0cnkgYSBjYWNoZSBoaXQgZmlyc3RcbiAgdmFyIGNhY2hlS2V5ID0gcmF3ID8gdGVtcGxhdGVTdHJpbmcgOiB0ZW1wbGF0ZVN0cmluZy50cmltKCk7XG4gIHZhciBoaXQgPSB0ZW1wbGF0ZUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciB0YWdNYXRjaCA9IHRlbXBsYXRlU3RyaW5nLm1hdGNoKHRhZ1JFJDEpO1xuICB2YXIgZW50aXR5TWF0Y2ggPSBlbnRpdHlSRS50ZXN0KHRlbXBsYXRlU3RyaW5nKTtcbiAgdmFyIGNvbW1lbnRNYXRjaCA9IGNvbW1lbnRSRS50ZXN0KHRlbXBsYXRlU3RyaW5nKTtcblxuICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCAmJiAhY29tbWVudE1hdGNoKSB7XG4gICAgLy8gdGV4dCBvbmx5LCByZXR1cm4gYSBzaW5nbGUgdGV4dCBub2RlLlxuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGVtcGxhdGVTdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gdGFnTWF0Y2ggJiYgdGFnTWF0Y2hbMV07XG4gICAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuZWZhdWx0O1xuICAgIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gICAgdmFyIHN1ZmZpeCA9IHdyYXBbMl07XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcgKyBzdWZmaXg7XG4gICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdykge1xuICAgIHRyaW1Ob2RlKGZyYWcpO1xuICB9XG4gIHRlbXBsYXRlQ2FjaGUucHV0KGNhY2hlS2V5LCBmcmFnKTtcbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHRlbXBsYXRlIG5vZGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBub2RlVG9GcmFnbWVudChub2RlKSB7XG4gIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gIC8vIGl0cyBjb250ZW50IGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudC4gSG93ZXZlciwgaU9TIFNhZmFyaSBoYXNcbiAgLy8gYnVnIHdoZW4gdXNpbmcgZGlyZWN0bHkgY2xvbmVkIHRlbXBsYXRlIGNvbnRlbnQgd2l0aCB0b3VjaFxuICAvLyBldmVudHMgYW5kIGNhbiBjYXVzZSBjcmFzaGVzIHdoZW4gdGhlIG5vZGVzIGFyZSByZW1vdmVkIGZyb20gRE9NLCBzbyB3ZVxuICAvLyBoYXZlIHRvIHRyZWF0IHRlbXBsYXRlIGVsZW1lbnRzIGFzIHN0cmluZyB0ZW1wbGF0ZXMuICgjMjgwNSlcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUuaW5uZXJIVE1MKTtcbiAgfVxuICAvLyBzY3JpcHQgdGVtcGxhdGVcbiAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1NDUklQVCcpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9GcmFnbWVudChub2RlLnRleHRDb250ZW50KTtcbiAgfVxuICAvLyBub3JtYWwgbm9kZSwgY2xvbmUgaXQgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsXG4gIHZhciBjbG9uZWROb2RlID0gY2xvbmVOb2RlKG5vZGUpO1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAoY2hpbGQgPSBjbG9uZWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbiAgdHJpbU5vZGUoZnJhZyk7XG4gIHJldHVybiBmcmFnO1xufVxuXG4vLyBUZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIFNhZmFyaSB0ZW1wbGF0ZSBjbG9uaW5nIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd3VnLmNnaT9pZD0xMzc3NTVcbnZhciBoYXNCcm9rZW5UZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGEuaW5uZXJIVE1MID0gJzx0ZW1wbGF0ZT4xPC90ZW1wbGF0ZT4nO1xuICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vLyBUZXN0IGZvciBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGNsb25lIGJ1Z1xudmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHQucGxhY2Vob2xkZXIgPSAndCc7XG4gICAgcmV0dXJuIHQuY2xvbmVOb2RlKHRydWUpLnZhbHVlID09PSAndCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIDEuIERlYWwgd2l0aCBTYWZhcmkgY2xvbmluZyBuZXN0ZWQgPHRlbXBsYXRlPiBidWcgYnlcbiAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAqIDIuIERlYWwgd2l0aCBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1ZyBieSBzZXR0aW5nXG4gKiAgICB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBjbG9uaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICB2YXIgaSwgb3JpZ2luYWwsIGNsb25lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciB0ZW1wQ2xvbmUgPSByZXM7XG4gICAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgdGVtcENsb25lID0gcmVzLmNvbnRlbnQ7XG4gICAgfVxuICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IHRlbXBDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZU5vZGUob3JpZ2luYWxbaV0pLCBjbG9uZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgICAgY2xvbmVkID0gcmVzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY2xvbmVkW2ldLnZhbHVlID0gb3JpZ2luYWxbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgICAgIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlOlxuICogICAgICAgIC0gRG9jdW1lbnRGcmFnbWVudCBvYmplY3RcbiAqICAgICAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgICAgICAtIGlkIHNlbGVjdG9yOiAnI3NvbWUtdGVtcGxhdGUtaWQnXG4gKiAgICAgICAgLSB0ZW1wbGF0ZSBzdHJpbmc6ICc8ZGl2PjxzcGFuPnt7bXNnfX08L3NwYW4+PC9kaXY+J1xuICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRDbG9uZVxuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqICAgICAgICBpbmxpbmUgSFRNTCBpbnRlcnBvbGF0aW9uLiBEbyBub3QgY2hlY2sgZm9yIGlkXG4gKiAgICAgICAgc2VsZWN0b3IgYW5kIGtlZXAgd2hpdGVzcGFjZSBpbiB0aGUgc3RyaW5nLlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgc2hvdWxkQ2xvbmUsIHJhdykge1xuICB2YXIgbm9kZSwgZnJhZztcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmIChpc0ZyYWdtZW50KHRlbXBsYXRlKSkge1xuICAgIHRyaW1Ob2RlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUodGVtcGxhdGUpIDogdGVtcGxhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlkIHNlbGVjdG9yXG4gICAgaWYgKCFyYXcgJiYgdGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIC8vIGlkIHNlbGVjdG9yIGNhbiBiZSBjYWNoZWQgdG9vXG4gICAgICBmcmFnID0gaWRTZWxlY3RvckNhY2hlLmdldCh0ZW1wbGF0ZSk7XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQobm9kZSk7XG4gICAgICAgICAgLy8gc2F2ZSBzZWxlY3RvciB0byBjYWNoZVxuICAgICAgICAgIGlkU2VsZWN0b3JDYWNoZS5wdXQodGVtcGxhdGUsIGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBzdHJpbmcgdGVtcGxhdGVcbiAgICAgIGZyYWcgPSBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlLCByYXcpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgIC8vIGEgZGlyZWN0IG5vZGVcbiAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQodGVtcGxhdGUpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWcgJiYgc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUoZnJhZykgOiBmcmFnO1xufVxuXG52YXIgdGVtcGxhdGUgPSBPYmplY3QuZnJlZXplKHtcbiAgY2xvbmVOb2RlOiBjbG9uZU5vZGUsXG4gIHBhcnNlVGVtcGxhdGU6IHBhcnNlVGVtcGxhdGVcbn0pO1xuXG52YXIgaHRtbCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGEgY29tbWVudCBub2RlIG1lYW5zIHRoaXMgaXMgYSBiaW5kaW5nIGZvclxuICAgIC8vIHt7eyBpbmxpbmUgdW5lc2NhcGVkIGh0bWwgfX19XG4gICAgaWYgKHRoaXMuZWwubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgIC8vIGhvbGQgbm9kZXNcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggcHJvcGVyIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtaHRtbCcpO1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLnN3YXAodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBzd2FwOiBmdW5jdGlvbiBzd2FwKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVtb3ZlKHRoaXMubm9kZXNbaV0pO1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IG5ldyB2YWx1ZSB0byBhIGZyYWdtZW50XG4gICAgLy8gZG8gbm90IGF0dGVtcHQgdG8gcmV0cmlldmUgZnJvbSBpZCBzZWxlY3RvclxuICAgIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGVzZSBub2RlcyBzbyB3ZSBjYW4gcmVtb3ZlIGxhdGVyXG4gICAgdGhpcy5ub2RlcyA9IHRvQXJyYXkoZnJhZy5jaGlsZE5vZGVzKTtcbiAgICBiZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBhIHBhcnRpYWxseS1jb21waWxlZCBmcmFnbWVudC5cbiAqIENhbiBvcHRpb25hbGx5IGNvbXBpbGUgY29udGVudCB3aXRoIGEgY2hpbGQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtwYXJlbnRGcmFnXVxuICovXG5mdW5jdGlvbiBGcmFnbWVudChsaW5rZXIsIHZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuY2hpbGRGcmFncyA9IFtdO1xuICB0aGlzLnZtID0gdm07XG4gIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnO1xuICBpZiAocGFyZW50RnJhZykge1xuICAgIHBhcmVudEZyYWcuY2hpbGRGcmFncy5wdXNoKHRoaXMpO1xuICB9XG4gIHRoaXMudW5saW5rID0gbGlua2VyKHZtLCBmcmFnLCBob3N0LCBzY29wZSwgdGhpcyk7XG4gIHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSA9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiZcbiAgLy8gZG8gbm90IGdvIHNpbmdsZSBtb2RlIGlmIHRoZSBvbmx5IG5vZGUgaXMgYW4gYW5jaG9yXG4gICFmcmFnLmNoaWxkTm9kZXNbMF0uX192X2FuY2hvcjtcbiAgaWYgKHNpbmdsZSkge1xuICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXTtcbiAgICB0aGlzLmJlZm9yZSA9IHNpbmdsZUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IHNpbmdsZVJlbW92ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUgPSBjcmVhdGVBbmNob3IoJ2ZyYWdtZW50LXN0YXJ0Jyk7XG4gICAgdGhpcy5lbmQgPSBjcmVhdGVBbmNob3IoJ2ZyYWdtZW50LWVuZCcpO1xuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgcHJlcGVuZCh0aGlzLm5vZGUsIGZyYWcpO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIHRoaXMuYmVmb3JlID0gbXVsdGlCZWZvcmU7XG4gICAgdGhpcy5yZW1vdmUgPSBtdWx0aVJlbW92ZTtcbiAgfVxuICB0aGlzLm5vZGUuX192X2ZyYWcgPSB0aGlzO1xufVxuXG4vKipcbiAqIENhbGwgYXR0YWNoL2RldGFjaCBmb3IgYWxsIGNvbXBvbmVudHMgY29udGFpbmVkIHdpdGhpblxuICogdGhpcyBmcmFnbWVudC4gQWxzbyBkbyBzbyByZWN1cnNpdmVseSBmb3IgYWxsIGNoaWxkXG4gKiBmcmFnbWVudHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gIHZhciBpLCBsO1xuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRoaXMuY2hpbGRGcmFnc1tpXS5jYWxsSG9vayhob29rKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBob29rKHRoaXMuY2hpbGRyZW5baV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBzaW5nbGVCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZTtcbiAgdmFyIG1ldGhvZCA9IHdpdGhUcmFuc2l0aW9uICE9PSBmYWxzZSA/IGJlZm9yZVdpdGhUcmFuc2l0aW9uIDogYmVmb3JlO1xuICBtZXRob2QodGhpcy5ub2RlLCB0YXJnZXQsIHRoaXMudm0pO1xuICBpZiAoaW5Eb2ModGhpcy5ub2RlKSkge1xuICAgIHRoaXMuY2FsbEhvb2soYXR0YWNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBmcmFnbWVudCwgc2luZ2xlIG5vZGUgdmVyc2lvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2hvdWxkQ2FsbFJlbW92ZSA9IGluRG9jKHRoaXMubm9kZSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlV2l0aFRyYW5zaXRpb24odGhpcy5ub2RlLCB0aGlzLnZtLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICB9XG4gICAgc2VsZi5kZXN0cm95KCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIG1ldGhvZChub2RlLCB0YXJnZXQsIHZtKTtcbiAgfSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gbXVsdGlSZW1vdmUoKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2hvdWxkQ2FsbFJlbW92ZSA9IGluRG9jKHRoaXMubm9kZSk7XG4gIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gIHJlbW92ZU5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCB0aGlzLnZtLCB0aGlzLmZyYWcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgZnJhZ21lbnQgZm9yIHJlbW92YWwuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmJlZm9yZVJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gY2FsbCB0aGUgc2FtZSBtZXRob2QgcmVjdXJzaXZlbHkgb24gY2hpbGRcbiAgICAvLyBmcmFnbWVudHMsIGRlcHRoLWZpcnN0XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmJlZm9yZVJlbW92ZShmYWxzZSk7XG4gIH1cbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gQ2FsbCBkZXN0cm95IGZvciBhbGwgY29udGFpbmVkIGluc3RhbmNlcyxcbiAgICAvLyB3aXRoIHJlbW92ZTpmYWxzZSBhbmQgZGVmZXI6dHJ1ZS5cbiAgICAvLyBEZWZlciBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8ga2VlcCB0aGUgY2hpbGRyZW4gdG8gY2FsbCBkZXRhY2ggaG9va3NcbiAgICAvLyBvbiB0aGVtLlxuICAgIHRoaXMuY2hpbGRyZW5baV0uJGRlc3Ryb3koZmFsc2UsIHRydWUpO1xuICB9XG4gIHZhciBkaXJzID0gdGhpcy51bmxpbmsuZGlycztcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gZGlzYWJsZSB0aGUgd2F0Y2hlcnMgb24gYWxsIHRoZSBkaXJlY3RpdmVzXG4gICAgLy8gc28gdGhhdCB0aGUgcmVuZGVyZWQgY29udGVudCBzdGF5cyB0aGUgc2FtZVxuICAgIC8vIGR1cmluZyByZW1vdmFsLlxuICAgIGRpcnNbaV0uX3dhdGNoZXIgJiYgZGlyc1tpXS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGZyYWdtZW50LlxuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXJlbnRGcmFnKSB7XG4gICAgdGhpcy5wYXJlbnRGcmFnLmNoaWxkRnJhZ3MuJHJlbW92ZSh0aGlzKTtcbiAgfVxuICB0aGlzLm5vZGUuX192X2ZyYWcgPSBudWxsO1xuICB0aGlzLnVubGluaygpO1xufTtcblxuLyoqXG4gKiBDYWxsIGF0dGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBhdHRhY2goY2hpbGQpIHtcbiAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbCBkZXRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gZGV0YWNoKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgfVxufVxuXG52YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMCk7XG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhXG4gKiBmcmFnbWVudC4gQ2FjaGVzIHRoZSBjb21waWxlZCBsaW5rZXIgaWYgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICovXG5mdW5jdGlvbiBGcmFnbWVudEZhY3Rvcnkodm0sIGVsKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdmFyIHRlbXBsYXRlO1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNTdHJpbmcgfHwgaXNUZW1wbGF0ZShlbCkgJiYgIWVsLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgdGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKGVsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlcjtcbiAgdmFyIGNpZCA9IHZtLmNvbnN0cnVjdG9yLmNpZDtcbiAgaWYgKGNpZCA+IDApIHtcbiAgICB2YXIgY2FjaGVJZCA9IGNpZCArIChpc1N0cmluZyA/IGVsIDogZ2V0T3V0ZXJIVE1MKGVsKSk7XG4gICAgbGlua2VyID0gbGlua2VyQ2FjaGUuZ2V0KGNhY2hlSWQpO1xuICAgIGlmICghbGlua2VyKSB7XG4gICAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBsaW5rZXJDYWNoZS5wdXQoY2FjaGVJZCwgbGlua2VyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlua2VyID0gY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpO1xuICB9XG4gIHRoaXMubGlua2VyID0gbGlua2VyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IGhvc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gcGFyZW50RnJhZ1xuICovXG5cbkZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHZhciBmcmFnID0gY2xvbmVOb2RlKHRoaXMudGVtcGxhdGUpO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMubGlua2VyLCB0aGlzLnZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZyk7XG59O1xuXG52YXIgT04gPSA3MDA7XG52YXIgTU9ERUwgPSA4MDA7XG52YXIgQklORCA9IDg1MDtcbnZhciBUUkFOU0lUSU9OID0gMTEwMDtcbnZhciBFTCA9IDE1MDA7XG52YXIgQ09NUE9ORU5UID0gMTUwMDtcbnZhciBQQVJUSUFMID0gMTc1MDtcbnZhciBJRiA9IDIxMDA7XG52YXIgRk9SID0gMjIwMDtcbnZhciBTTE9UID0gMjMwMDtcblxudmFyIHVpZCQzID0gMDtcblxudmFyIHZGb3IgPSB7XG5cbiAgcHJpb3JpdHk6IEZPUixcbiAgdGVybWluYWw6IHRydWUsXG5cbiAgcGFyYW1zOiBbJ3RyYWNrLWJ5JywgJ3N0YWdnZXInLCAnZW50ZXItc3RhZ2dlcicsICdsZWF2ZS1zdGFnZ2VyJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbi9vZiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopICg/OmlufG9mKSAoLiopLyk7XG4gICAgaWYgKGluTWF0Y2gpIHtcbiAgICAgIHZhciBpdE1hdGNoID0gaW5NYXRjaFsxXS5tYXRjaCgvXFwoKC4qKSwoLiopXFwpLyk7XG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpdE1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFsaWFzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdi1mb3IgZXhwcmVzc2lvbiBcIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2FsaWFzIGlzIHJlcXVpcmVkLicsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVpZCBhcyBhIGNhY2hlIGlkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gJ19fdi1mb3JfXycgKyArK3VpZCQzO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpb24gbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGtub3cgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIDxzZWxlY3Q+J3NcbiAgICAvLyB2LW1vZGVsIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIGJlY2F1c2Ugdi1tb2RlbCBoYXMgYSBsb3dlciBwcmlvcml0eSB0aGFuIHYtZm9yLFxuICAgIC8vIHRoZSB2LW1vZGVsIGlzIG5vdCBib3VuZCBoZXJlIHlldCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHJldHJpdmUgaXQgaW4gdGhlIGFjdHVhbCB1cGRhdGVNb2RlbCgpIGZ1bmN0aW9uLlxuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgdGhpcy5pc09wdGlvbiA9ICh0YWcgPT09ICdPUFRJT04nIHx8IHRhZyA9PT0gJ09QVEdST1VQJykgJiYgdGhpcy5lbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnO1xuXG4gICAgLy8gc2V0dXAgYW5jaG9yIG5vZGVzXG4gICAgdGhpcy5zdGFydCA9IGNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcigndi1mb3ItZW5kJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmVuZCk7XG4gICAgYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBmcmFnbWVudCBmYWN0b3J5XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5kaWZmKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlUmVmKCk7XG4gICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaWZmLCBiYXNlZCBvbiBuZXcgZGF0YSBhbmQgb2xkIGRhdGEsIGRldGVybWluZSB0aGVcbiAgICogbWluaW11bSBhbW91bnQgb2YgRE9NIG1hbmlwdWxhdGlvbnMgbmVlZGVkIHRvIG1ha2UgdGhlXG4gICAqIERPTSByZWZsZWN0IHRoZSBuZXcgZGF0YSBBcnJheS5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBkaWZmcyB0aGUgbmV3IGRhdGEgQXJyYXkgYnkgc3RvcmluZyBhXG4gICAqIGhpZGRlbiByZWZlcmVuY2UgdG8gYW4gb3duZXIgdm0gaW5zdGFuY2Ugb24gcHJldmlvdXNseVxuICAgKiBzZWVuIGRhdGEuIFRoaXMgYWxsb3dzIHVzIHRvIGFjaGlldmUgTyhuKSB3aGljaCBpc1xuICAgKiBiZXR0ZXIgdGhhbiBhIGxldmVuc2h0ZWluIGRpc3RhbmNlIGJhc2VkIGFsZ29yaXRobSxcbiAgICogd2hpY2ggaXMgTyhtICogbikuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICovXG5cbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF07XG4gICAgdmFyIGNvbnZlcnRlZEZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QgPSBpc09iamVjdChpdGVtKSAmJiBoYXNPd24oaXRlbSwgJyRrZXknKSAmJiBoYXNPd24oaXRlbSwgJyR2YWx1ZScpO1xuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBvbGRGcmFncyA9IHRoaXMuZnJhZ3M7XG4gICAgdmFyIGZyYWdzID0gdGhpcy5mcmFncyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpbkRvY3VtZW50ID0gaW5Eb2Moc3RhcnQpO1xuICAgIHZhciBpbml0ID0gIW9sZEZyYWdzO1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmU7XG5cbiAgICAvLyBGaXJzdCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBuZXcgQXJyYXkgYW5kIGZpbGwgdXBcbiAgICAvLyB0aGUgbmV3IGZyYWdzIGFycmF5LiBJZiBhIHBpZWNlIG9mIGRhdGEgaGFzIGEgY2FjaGVkXG4gICAgLy8gaW5zdGFuY2UgZm9yIGl0LCB3ZSByZXVzZSBpdC4gT3RoZXJ3aXNlIGJ1aWxkIGEgbmV3XG4gICAgLy8gaW5zdGFuY2UuXG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgIGtleSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiRrZXkgOiBudWxsO1xuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtO1xuICAgICAgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGZyYWcgPSAhaW5pdCAmJiB0aGlzLmdldENhY2hlZEZyYWcodmFsdWUsIGksIGtleSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWU7XG4gICAgICAgIC8vIHVwZGF0ZSAkaW5kZXhcbiAgICAgICAgZnJhZy5zY29wZS4kaW5kZXggPSBpO1xuICAgICAgICAvLyB1cGRhdGUgJGtleVxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZnJhZy5zY29wZS4ka2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgZm9yIHRyYWNrLWJ5LCBvYmplY3QgcmVwZWF0ICZcbiAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgaWYgKHRyYWNrQnlLZXkgfHwgY29udmVydGVkRnJvbU9iamVjdCB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmcmFnLnNjb3BlW2FsaWFzXSA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaXNudGFuY2VcbiAgICAgICAgZnJhZyA9IHRoaXMuY3JlYXRlKHZhbHVlLCBhbGlhcywgaSwga2V5KTtcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0O1xuICAgICAgfVxuICAgICAgZnJhZ3NbaV0gPSBmcmFnO1xuICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgZnJhZy5iZWZvcmUoZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcywgZ28gdGhyb3VnaCB0aGUgb2xkIGZyYWdtZW50cyBhbmRcbiAgICAvLyBkZXN0cm95IHRob3NlIHdobyBhcmUgbm90IHJldXNlZCAoYW5kIHJlbW92ZSB0aGVtXG4gICAgLy8gZnJvbSBjYWNoZSlcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gMDtcbiAgICB2YXIgdG90YWxSZW1vdmVkID0gb2xkRnJhZ3MubGVuZ3RoIC0gZnJhZ3MubGVuZ3RoO1xuICAgIC8vIHdoZW4gcmVtb3ZpbmcgYSBsYXJnZSBudW1iZXIgb2YgZnJhZ21lbnRzLCB3YXRjaGVyIHJlbW92YWxcbiAgICAvLyB0dXJucyBvdXQgdG8gYmUgYSBwZXJmIGJvdHRsZW5lY2ssIHNvIHdlIGJhdGNoIHRoZSB3YXRjaGVyXG4gICAgLy8gcmVtb3ZhbHMgaW50byBhIHNpbmdsZSBmaWx0ZXIgY2FsbCFcbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXTtcbiAgICAgIGlmICghZnJhZy5yZXVzZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICB0aGlzLnJlbW92ZShmcmFnLCByZW1vdmFsSW5kZXgrKywgdG90YWxSZW1vdmVkLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgaWYgKHJlbW92YWxJbmRleCkge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMgPSB0aGlzLnZtLl93YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIHcuYWN0aXZlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2O1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IGZyYWdzW2ldO1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXTtcbiAgICAgIHByZXZFbCA9IHRhcmdldFByZXYgPyB0YXJnZXRQcmV2LnN0YWdnZXJDYiA/IHRhcmdldFByZXYuc3RhZ2dlckFuY2hvciA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZSA6IHN0YXJ0O1xuICAgICAgaWYgKGZyYWcucmV1c2VkICYmICFmcmFnLnN0YWdnZXJDYikge1xuICAgICAgICBjdXJyZW50UHJldiA9IGZpbmRQcmV2RnJhZyhmcmFnLCBzdGFydCwgdGhpcy5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50UHJldiAhPT0gdGFyZ2V0UHJldiAmJiAoIWN1cnJlbnRQcmV2IHx8XG4gICAgICAgIC8vIG9wdGltaXphdGlvbiBmb3IgbW92aW5nIGEgc2luZ2xlIGl0ZW0uXG4gICAgICAgIC8vIHRoYW5rcyB0byBzdWdnZXN0aW9ucyBieSBAbGl2b3JhcyBpbiAjMTgwN1xuICAgICAgICBmaW5kUHJldkZyYWcoY3VycmVudFByZXYsIHN0YXJ0LCB0aGlzLmlkKSAhPT0gdGFyZ2V0UHJldikpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IGluc3RhbmNlLCBvciBzdGlsbCBpbiBzdGFnZ2VyLlxuICAgICAgICAvLyBpbnNlcnQgd2l0aCB1cGRhdGVkIHN0YWdnZXIgaW5kZXguXG4gICAgICAgIHRoaXMuaW5zZXJ0KGZyYWcsIGluc2VydGlvbkluZGV4KyssIHByZXZFbCwgaW5Eb2N1bWVudCk7XG4gICAgICB9XG4gICAgICBmcmFnLnJldXNlZCA9IGZyYWcuZnJlc2ggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxpYXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIGFsaWFzLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLl9ob3N0O1xuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgIHZhciBzY29wZSA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUpO1xuICAgIC8vIHJlZiBob2xkZXIgZm9yIHRoZSBzY29wZVxuICAgIHNjb3BlLiRyZWZzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kcmVmcyk7XG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscyk7XG4gICAgLy8gbWFrZSBzdXJlIHBvaW50ICRwYXJlbnQgdG8gcGFyZW50IHNjb3BlXG4gICAgc2NvcGUuJHBhcmVudCA9IHBhcmVudFNjb3BlO1xuICAgIC8vIGZvciB0d28td2F5IGJpbmRpbmcgb24gYWxpYXNcbiAgICBzY29wZS4kZm9yQ29udGV4dCA9IHRoaXM7XG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICAvLyBpbXBvcnRhbnQ6IGRlZmluZSB0aGUgc2NvcGUgYWxpYXMgd2l0aG91dCBmb3JjZWQgY29udmVyc2lvblxuICAgIC8vIHNvIHRoYXQgZnJvemVuIGRhdGEgc3RydWN0dXJlcyByZW1haW4gbm9uLXJlYWN0aXZlLlxuICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpO1xuICAgIH0pO1xuICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGluZGV4JywgaW5kZXgpO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGtleScsIGtleSk7XG4gICAgfSBlbHNlIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAvLyBhdm9pZCBhY2NpZGVudGFsIGZhbGxiYWNrXG4gICAgICBkZWYoc2NvcGUsICcka2V5JywgbnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLml0ZXJhdG9yKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgdGhpcy5pdGVyYXRvciwga2V5ICE9PSBudWxsID8ga2V5IDogaW5kZXgpO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIGZyYWcuZm9ySWQgPSB0aGlzLmlkO1xuICAgIHRoaXMuY2FjaGVGcmFnKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KTtcbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2LXJlZiBvbiBvd25lciB2bS5cbiAgICovXG5cbiAgdXBkYXRlUmVmOiBmdW5jdGlvbiB1cGRhdGVSZWYoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuZGVzY3JpcHRvci5yZWY7XG4gICAgaWYgKCFyZWYpIHJldHVybjtcbiAgICB2YXIgaGFzaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmcztcbiAgICB2YXIgcmVmcztcbiAgICBpZiAoIXRoaXMuZnJvbU9iamVjdCkge1xuICAgICAgcmVmcyA9IHRoaXMuZnJhZ3MubWFwKGZpbmRWbUZyb21GcmFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmcyA9IHt9O1xuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhhc2hbcmVmXSA9IHJlZnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKCkge1xuICAgIGlmICh0aGlzLmlzT3B0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5zdGFydC5wYXJlbnROb2RlO1xuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWw7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGZyYWdtZW50LiBIYW5kbGVzIHN0YWdnZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Tm9kZX0gcHJldkVsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChmcmFnLCBpbmRleCwgcHJldkVsLCBpbkRvY3VtZW50KSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKTtcbiAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIG51bGwsICdlbnRlcicpO1xuICAgIGlmIChpbkRvY3VtZW50ICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBhbmNob3IgYW5kIGluc2VydCBpdCBzeW5jaHJvbm91c2x5LFxuICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gcmVzb2x2ZSB0aGUgY29ycmVjdCBvcmRlciB3aXRob3V0XG4gICAgICAvLyB3b3JyeWluZyBhYm91dCBzb21lIGVsZW1lbnRzIG5vdCBpbnNlcnRlZCB5ZXRcbiAgICAgIHZhciBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3I7XG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBjcmVhdGVBbmNob3IoJ3N0YWdnZXItYW5jaG9yJyk7XG4gICAgICAgIGFuY2hvci5fX3ZfZnJhZyA9IGZyYWc7XG4gICAgICB9XG4gICAgICBhZnRlcihhbmNob3IsIHByZXZFbCk7XG4gICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgICBmcmFnLmJlZm9yZShhbmNob3IpO1xuICAgICAgICByZW1vdmUoYW5jaG9yKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSBwcmV2RWwubmV4dFNpYmxpbmc7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIC8vIHJlc2V0IGVuZCBhbmNob3IgcG9zaXRpb24gaW4gY2FzZSB0aGUgcG9zaXRpb24gd2FzIG1lc3NlZCB1cFxuICAgICAgICAvLyBieSBhbiBleHRlcm5hbCBkcmFnLW4tZHJvcCBsaWJyYXJ5LlxuICAgICAgICBhZnRlcih0aGlzLmVuZCwgcHJldkVsKTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBmcmFnLmJlZm9yZSh0YXJnZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgLy8gaXQncyBub3QgcG9zc2libGUgZm9yIHRoZSBzYW1lIGZyYWcgdG8gYmUgcmVtb3ZlZFxuICAgICAgLy8gdHdpY2UsIHNvIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHN0YWdnZXIgY2FsbGJhY2ssXG4gICAgICAvLyBpdCBtZWFucyB0aGlzIGZyYWcgaXMgcXVldWVkIGZvciBlbnRlciBidXQgcmVtb3ZlZFxuICAgICAgLy8gYmVmb3JlIGl0cyB0cmFuc2l0aW9uIHN0YXJ0ZWQuIFNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICAgIC8vIGRlc3Ryb3llZCwgd2UgY2FuIGp1c3QgbGVhdmUgaXQgaW4gZGV0YWNoZWQgc3RhdGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgJ2xlYXZlJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShmcmFnLCBwcmV2RWwpIHtcbiAgICAvLyBmaXggYSBjb21tb24gaXNzdWUgd2l0aCBTb3J0YWJsZTpcbiAgICAvLyBpZiBwcmV2RWwgZG9lc24ndCBoYXZlIG5leHRTaWJsaW5nLCB0aGlzIG1lYW5zIGl0J3NcbiAgICAvLyBiZWVuIGRyYWdnZWQgYWZ0ZXIgdGhlIGVuZCBhbmNob3IuIEp1c3QgcmUtcG9zaXRpb25cbiAgICAvLyB0aGUgZW5kIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBjb250YWluZXIuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFwcmV2RWwubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuZW5kLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIH1cbiAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FjaGUgYSBmcmFnbWVudCB1c2luZyB0cmFjay1ieSBvciB0aGUgb2JqZWN0IGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICovXG5cbiAgY2FjaGVGcmFnOiBmdW5jdGlvbiBjYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgaWQ7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICAgIGNhY2hlW2lkXSA9IGZyYWc7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrQnlLZXkgIT09ICckaW5kZXgnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSB0aGlzLmlkO1xuICAgICAgaWYgKGhhc093bih2YWx1ZSwgaWQpKSB7XG4gICAgICAgIGlmICh2YWx1ZVtpZF0gPT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZVtpZF0gPSBmcmFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgICAgICBkZWYodmFsdWUsIGlkLCBmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdGcm96ZW4gdi1mb3Igb2JqZWN0cyBjYW5ub3QgYmUgYXV0b21hdGljYWxseSB0cmFja2VkLCBtYWtlIHN1cmUgdG8gJyArICdwcm92aWRlIGEgdHJhY2stYnkga2V5LicpO1xuICAgICAgfVxuICAgIH1cbiAgICBmcmFnLnJhdyA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBjYWNoZWQgZnJhZ21lbnQgZnJvbSB0aGUgdmFsdWUvaW5kZXgva2V5XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGdldENhY2hlZEZyYWc6IGZ1bmN0aW9uIGdldENhY2hlZEZyYWcodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgdmFyIGZyYWc7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICBmcmFnID0gdGhpcy5jYWNoZVtpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXTtcbiAgICB9XG4gICAgaWYgKGZyYWcgJiYgKGZyYWcucmV1c2VkIHx8IGZyYWcuZnJlc2gpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqL1xuXG4gIGRlbGV0ZUNhY2hlZEZyYWc6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlZEZyYWcoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3O1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgc2NvcGUgPSBmcmFnLnNjb3BlO1xuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAvLyBmaXggIzk0ODogYXZvaWQgYWNjaWRlbnRhbGx5IGZhbGwgdGhyb3VnaCB0b1xuICAgIC8vIGEgcGFyZW50IHJlcGVhdGVyIHdoaWNoIGhhcHBlbnMgdG8gaGF2ZSAka2V5LlxuICAgIHZhciBrZXkgPSBoYXNPd24oc2NvcGUsICcka2V5JykgJiYgc2NvcGUuJGtleTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICBpZiAodHJhY2tCeUtleSB8fCBrZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVbdGhpcy5pZF0gPSBudWxsO1xuICAgICAgZnJhZy5yYXcgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBzdGFnZ2VyIGFtb3VudCBmb3IgYW4gaW5zZXJ0aW9uL3JlbW92YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKi9cblxuICBnZXRTdGFnZ2VyOiBmdW5jdGlvbiBnZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlICsgJ1N0YWdnZXInO1xuICAgIHZhciB0cmFucyA9IGZyYWcubm9kZS5fX3ZfdHJhbnM7XG4gICAgdmFyIGhvb2tzID0gdHJhbnMgJiYgdHJhbnMuaG9va3M7XG4gICAgdmFyIGhvb2sgPSBob29rcyAmJiAoaG9va3NbdHlwZV0gfHwgaG9va3Muc3RhZ2dlcik7XG4gICAgcmV0dXJuIGhvb2sgPyBob29rLmNhbGwoZnJhZywgaW5kZXgsIHRvdGFsKSA6IGluZGV4ICogcGFyc2VJbnQodGhpcy5wYXJhbXNbdHlwZV0gfHwgdGhpcy5wYXJhbXMuc3RhZ2dlciwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcmUtcHJvY2VzcyB0aGUgdmFsdWUgYmVmb3JlIHBpcGluZyBpdCB0aHJvdWdoIHRoZVxuICAgKiBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKi9cblxuICBfcHJlUHJvY2VzczogZnVuY3Rpb24gX3ByZVByb2Nlc3ModmFsdWUpIHtcbiAgICAvLyByZWdhcmRsZXNzIG9mIHR5cGUsIHN0b3JlIHRoZSB1bi1maWx0ZXJlZCByYXcgdmFsdWUuXG4gICAgdGhpcy5yYXdWYWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIHRoZSB2YWx1ZSBhZnRlciBpdCBoYXMgYmVlbiBwaXBlZCB0aHJvdWdoXG4gICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIHRoaXMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogd2F0Y2hlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICogdGhlIHYtZm9yIHRvIHVwZGF0ZSB3aGVuIHRoZSBzb3VyY2UgT2JqZWN0IGlzIG11dGF0ZWQuXG4gICAqL1xuXG4gIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gX3Bvc3RQcm9jZXNzKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gY29udmVydCBwbGFpbiBvYmplY3QgdG8gYXJyYXkuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGkpO1xuICAgICAgdmFyIGtleTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmVzW2ldID0ge1xuICAgICAgICAgICRrZXk6IGtleSxcbiAgICAgICAgICAkdmFsdWU6IHZhbHVlW2tleV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSByYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgfHwgW107XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNbdGhpcy5kZXNjcmlwdG9yLnJlZl0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFncykge1xuICAgICAgdmFyIGkgPSB0aGlzLmZyYWdzLmxlbmd0aDtcbiAgICAgIHZhciBmcmFnO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXTtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICBmcmFnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGZpbmQgdGhlIHByZXZpb3VzIGVsZW1lbnQgdGhhdCBpcyBhIGZyYWdtZW50XG4gKiBhbmNob3IuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYSBkZXN0cm95ZWQgZnJhZydzXG4gKiBlbGVtZW50IGNvdWxkIHN0aWxsIGJlIGxpbmdlcmluZyBpbiB0aGUgRE9NIGJlZm9yZSBpdHNcbiAqIGxlYXZpbmcgdHJhbnNpdGlvbiBmaW5pc2hlcywgYnV0IGl0cyBpbnNlcnRlZCBmbGFnXG4gKiBzaG91bGQgaGF2ZSBiZWVuIHNldCB0byBmYWxzZSBzbyB3ZSBjYW4gc2tpcCB0aGVtLlxuICpcbiAqIElmIHRoaXMgaXMgYSBibG9jayByZXBlYXQsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIG9ubHlcbiAqIHJldHVybiBmcmFnIHRoYXQgaXMgYm91bmQgdG8gdGhpcyB2LWZvci4gKHNlZSAjOTI5KVxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7Q29tbWVudHxUZXh0fSBhbmNob3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHJldHVybiB7RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFByZXZGcmFnKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZztcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghZWwpIHJldHVybjtcbiAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB3aGlsZSAoKCFmcmFnIHx8IGZyYWcuZm9ySWQgIT09IGlkIHx8ICFmcmFnLmluc2VydGVkKSAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGZyYWcgPSBlbC5fX3ZfZnJhZztcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBGaW5kIGEgdm0gZnJvbSBhIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEByZXR1cm4ge1Z1ZXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFZtRnJvbUZyYWcoZnJhZykge1xuICB2YXIgbm9kZSA9IGZyYWcubm9kZTtcbiAgLy8gaGFuZGxlIG11bHRpLW5vZGUgZnJhZ1xuICBpZiAoZnJhZy5lbmQpIHtcbiAgICB3aGlsZSAoIW5vZGUuX192dWVfXyAmJiBub2RlICE9PSBmcmFnLmVuZCAmJiBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUuX192dWVfXztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByYW5nZSBhcnJheSBmcm9tIGdpdmVuIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gcmFuZ2Uobikge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KE1hdGguZmxvb3IobikpO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHJldFtpXSA9IGk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRyYWNrIGJ5IGtleSBmb3IgYW4gaXRlbS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHJhY2tCeUtleV1cbiAqL1xuXG5mdW5jdGlvbiBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KSB7XG4gIHJldHVybiB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHRyYWNrQnlLZXkuY2hhckF0KDApLm1hdGNoKC9cXHcvKSA/IGdldFBhdGgodmFsdWUsIHRyYWNrQnlLZXkpIDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZGb3Iud2FybkR1cGxpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHdhcm4oJ0R1cGxpY2F0ZSB2YWx1ZSBmb3VuZCBpbiB2LWZvcj1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJy4gVXNlIHRyYWNrLWJ5PVwiJGluZGV4XCIgaWYgJyArICd5b3UgYXJlIGV4cGVjdGluZyBkdXBsaWNhdGUgdmFsdWVzLicsIHRoaXMudm0pO1xuICB9O1xufVxuXG52YXIgdklmID0ge1xuXG4gIHByaW9yaXR5OiBJRixcbiAgdGVybWluYWw6IHRydWUsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICghZWwuX192dWVfXykge1xuICAgICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgICAgdmFyIG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUobmV4dCk7XG4gICAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIG1haW4gYmxvY2tcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWlmJyk7XG4gICAgICByZXBsYWNlKGVsLCB0aGlzLmFuY2hvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1pZj1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgY2Fubm90IGJlICcgKyAndXNlZCBvbiBhbiBpbnN0YW5jZSByb290IGVsZW1lbnQuJywgdGhpcy52bSk7XG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGxhenkgaW5pdCBmYWN0b3J5XG4gICAgaWYgKCF0aGlzLmZhY3RvcnkpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VFbCAmJiAhdGhpcy5lbHNlRnJhZykge1xuICAgICAgaWYgKCF0aGlzLmVsc2VGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZWxzZUZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMuZWxzZUVsLl9jb250ZXh0IHx8IHRoaXMudm0sIHRoaXMuZWxzZUVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxzZUZyYWcgPSB0aGlzLmVsc2VGYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICB0aGlzLmVsc2VGcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaG93ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgIHZhciBuZXh0ID0gdGhpcy5lbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmFwcGx5KHRoaXMuZWwsIHZhbHVlKTtcbiAgICBpZiAodGhpcy5lbHNlRWwpIHtcbiAgICAgIHRoaXMuYXBwbHkodGhpcy5lbHNlRWwsICF2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseShlbCwgdmFsdWUpIHtcbiAgICBpZiAoaW5Eb2MoZWwpKSB7XG4gICAgICBhcHBseVRyYW5zaXRpb24oZWwsIHZhbHVlID8gMSA6IC0xLCB0b2dnbGUsIHRoaXMudm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2dnbGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dCQyID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnO1xuICAgIHZhciBsYXp5ID0gdGhpcy5wYXJhbXMubGF6eTtcbiAgICB2YXIgbnVtYmVyID0gdGhpcy5wYXJhbXMubnVtYmVyO1xuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlO1xuXG4gICAgLy8gaGFuZGxlIGNvbXBvc2l0aW9uIGV2ZW50cy5cbiAgICAvLyAgIGh0dHA6Ly9ibG9nLmV2YW55b3UubWUvMjAxNC8wMS8wMy9jb21wb3NpdGlvbi1ldmVudC9cbiAgICAvLyBza2lwIHRoaXMgZm9yIEFuZHJvaWQgYmVjYXVzZSBpdCBoYW5kbGVzIGNvbXBvc2l0aW9uXG4gICAgLy8gZXZlbnRzIHF1aXRlIGRpZmZlcmVudGx5LiBBbmRyb2lkIGRvZXNuJ3QgdHJpZ2dlclxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyBmb3IgbGFuZ3VhZ2UgaW5wdXQgbWV0aG9kcyBlLmcuXG4gICAgLy8gQ2hpbmVzZSwgYnV0IGluc3RlYWQgdHJpZ2dlcnMgdGhlbSBmb3Igc3BlbGxpbmdcbiAgICAvLyBzdWdnZXN0aW9ucy4uLiAoc2VlIERpc2N1c3Npb24vIzE2MilcbiAgICB2YXIgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgaWYgKCFpc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBtZXNzaW5nIHdpdGggdGhlIGlucHV0IHdoZW4gdXNlciBpcyB0eXBpbmcsXG4gICAgLy8gYW5kIGZvcmNlIHVwZGF0ZSBvbiBibHVyLlxuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICghaXNSYW5nZSAmJiAhbGF6eSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBkbyBub3Qgc3luYyB2YWx1ZSBhZnRlciBmcmFnbWVudCByZW1vdmFsICgjMjAxNylcbiAgICAgICAgaWYgKCFzZWxmLl9mcmFnIHx8IHNlbGYuX2ZyYWcuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBzZWxmLnJhd0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE5vdyBhdHRhY2ggdGhlIG1haW4gbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5yYXdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb21wb3NpbmcgfHwgIXNlbGYuX2JvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZSA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsKTtcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2JvdW5kICYmICFzZWxmLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IGRlYm91bmNlXG4gICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyID0gX2RlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGpRdWVyeSBldmVudHMsIHNpbmNlIGpRdWVyeS50cmlnZ2VyKCkgZG9lc24ndFxuICAgIC8vIHRyaWdnZXIgbmF0aXZlIGV2ZW50cyBpbiBzb21lIGNhc2VzIGFuZCBzb21lIHBsdWdpbnNcbiAgICAvLyByZWx5IG9uICQudHJpZ2dlcigpXG4gICAgLy9cbiAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBpZiBhIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHVzaW5nXG4gICAgLy8galF1ZXJ5LCBpdCBpcyBhbHNvIHJlbW92ZWQgd2l0aCBqUXVlcnksIHRoYXQncyB3aHlcbiAgICAvLyB3ZSBkbyB0aGUgY2hlY2sgZm9yIGVhY2ggZGlyZWN0aXZlIGluc3RhbmNlIGFuZFxuICAgIC8vIHN0b3JlIHRoYXQgY2hlY2sgcmVzdWx0IG9uIGl0c2VsZi4gVGhpcyBhbHNvIGFsbG93c1xuICAgIC8vIGVhc2llciB0ZXN0IGNvdmVyYWdlIGNvbnRyb2wgYnkgdW5zZXR0aW5nIHRoZSBnbG9iYWxcbiAgICAvLyBqUXVlcnkgdmFyaWFibGUgaW4gdGVzdHMuXG4gICAgdGhpcy5oYXNqUXVlcnkgPSB0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vbiA/ICdvbicgOiAnYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgdGhpcy5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIGlzSUU5KSB7XG4gICAgICB0aGlzLm9uKCdjdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKHNlbGYubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQ2IHx8IGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJiBlbC52YWx1ZS50cmltKCkpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICAvLyAjMzAyOSBvbmx5IHVwZGF0ZSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBUaGlzIHByZXZlbnRcbiAgICAvLyBicm93c2VycyBmcm9tIG92ZXJ3cml0aW5nIHZhbHVlcyBsaWtlIHNlbGVjdGlvblN0YXJ0XG4gICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5lbC52YWx1ZSkgdGhpcy5lbC52YWx1ZSA9IHZhbHVlO1xuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICB2YXIgbWV0aG9kID0galF1ZXJ5LmZuLm9mZiA/ICdvZmYnIDogJ3VuYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJhZGlvID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdmFsdWUgb3ZlcndyaXRlIHZpYSB2LWJpbmQ6dmFsdWVcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl92YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBlbC52YWx1ZTtcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gdG9OdW1iZXIodmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNldChzZWxmLmdldFZhbHVlKCkpO1xuICAgIH07XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpO1xuICB9XG59O1xuXG52YXIgc2VsZWN0ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgLy8gbWV0aG9kIHRvIGZvcmNlIHVwZGF0ZSBET00gdXNpbmcgbGF0ZXN0IHZhbHVlLlxuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fd2F0Y2hlcikge1xuICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLmdldCgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdFxuICAgIHZhciBtdWx0aXBsZSA9IHRoaXMubXVsdGlwbGUgPSBlbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJyk7XG5cbiAgICAvLyBhdHRhY2ggbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlKTtcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyID8gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodG9OdW1iZXIpIDogdG9OdW1iZXIodmFsdWUpIDogdmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSk7XG4gICAgaWYgKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGggfHwgIW11bHRpcGxlICYmIGluaXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8vIEFsbCBtYWpvciBicm93c2VycyBleGNlcHQgRmlyZWZveCByZXNldHNcbiAgICAvLyBzZWxlY3RlZEluZGV4IHdpdGggdmFsdWUgLTEgdG8gMCB3aGVuIHRoZSBlbGVtZW50XG4gICAgLy8gaXMgYXBwZW5kZWQgdG8gYSBuZXcgcGFyZW50LCB0aGVyZWZvcmUgd2UgaGF2ZSB0b1xuICAgIC8vIGZvcmNlIGEgRE9NIHVwZGF0ZSB3aGVuZXZlciB0aGF0IGhhcHBlbnMuLi5cbiAgICB0aGlzLnZtLiRvbignaG9vazphdHRhY2hlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG5leHRUaWNrKF90aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9KTtcbiAgICBpZiAoIWluRG9jKGVsKSkge1xuICAgICAgbmV4dFRpY2sodGhpcy5mb3JjZVVwZGF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgdmFyIG11bHRpID0gdGhpcy5tdWx0aXBsZSAmJiBpc0FycmF5KHZhbHVlKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gICAgdmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgICB2YXIgb3AsIHZhbDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV07XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgb3Auc2VsZWN0ZWQgPSBtdWx0aSA/IGluZGV4T2YkMSh2YWx1ZSwgdmFsKSA+IC0xIDogbG9vc2VFcXVhbCh2YWx1ZSwgdmFsKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHNlbGVjdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U2VsZWN0RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QXJyYXl8Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCwgbXVsdGksIGluaXQpIHtcbiAgdmFyIHJlcyA9IG11bHRpID8gW10gOiBudWxsO1xuICB2YXIgb3AsIHZhbCwgc2VsZWN0ZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV07XG4gICAgc2VsZWN0ZWQgPSBpbml0ID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpIDogb3Auc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIGlmIChtdWx0aSkge1xuICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBOYXRpdmUgQXJyYXkuaW5kZXhPZiB1c2VzIHN0cmljdCBlcXVhbCwgYnV0IGluIHRoaXNcbiAqIGNhc2Ugd2UgbmVlZCB0byBtYXRjaCBzdHJpbmcvbnVtYmVycyB3aXRoIGN1c3RvbSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZiQxKGFyciwgdmFsKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIGNoZWNrYm94ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IGVsLl92YWx1ZSA6IHNlbGYucGFyYW1zLm51bWJlciA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUoKSB7XG4gICAgICB2YXIgdmFsID0gZWwuY2hlY2tlZDtcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfZmFsc2VWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fZmFsc2VWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWU7XG4gICAgICBpZiAoaXNBcnJheShtb2RlbCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihtb2RlbCwgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIG1vZGVsLnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwuJHJlbW92ZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBlbC5jaGVja2VkID0gaW5kZXhPZih2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKSA+IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZWwuX3RydWVWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogdGV4dCQyLFxuICByYWRpbzogcmFkaW8sXG4gIHNlbGVjdDogc2VsZWN0LFxuICBjaGVja2JveDogY2hlY2tib3hcbn07XG5cbnZhciBtb2RlbCA9IHtcblxuICBwcmlvcml0eTogTU9ERUwsXG4gIHR3b1dheTogdHJ1ZSxcbiAgaGFuZGxlcnM6IGhhbmRsZXJzLFxuICBwYXJhbXM6IFsnbGF6eScsICdudW1iZXInLCAnZGVib3VuY2UnXSxcblxuICAvKipcbiAgICogUG9zc2libGUgZWxlbWVudHM6XG4gICAqICAgPHNlbGVjdD5cbiAgICogICA8dGV4dGFyZWE+XG4gICAqICAgPGlucHV0IHR5cGU9XCIqXCI+XG4gICAqICAgICAtIHRleHRcbiAgICogICAgIC0gY2hlY2tib3hcbiAgICogICAgIC0gcmFkaW9cbiAgICogICAgIC0gbnVtYmVyXG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKCk7XG4gICAgaWYgKHRoaXMuaGFzUmVhZCAmJiAhdGhpcy5oYXNXcml0ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIGEgcmVhZC1vbmx5IGZpbHRlciB3aXRoICcgKyAndi1tb2RlbD1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiLiAnICsgJ1lvdSBtaWdodCB3YW50IHRvIHVzZSBhIHR3by13YXkgZmlsdGVyIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLicsIHRoaXMudm0pO1xuICAgIH1cbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lO1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmICh0YWcgPT09ICdJTlBVVCcpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tlbC50eXBlXSB8fCBoYW5kbGVycy50ZXh0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnU0VMRUNUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnNlbGVjdDtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGVsZW1lbnQgdHlwZTogJyArIHRhZywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLl9fdl9tb2RlbCA9IHRoaXM7XG4gICAgaGFuZGxlci5iaW5kLmNhbGwodGhpcyk7XG4gICAgdGhpcy51cGRhdGUgPSBoYW5kbGVyLnVwZGF0ZTtcbiAgICB0aGlzLl91bmJpbmQgPSBoYW5kbGVyLnVuYmluZDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgcmVhZC93cml0ZSBmaWx0ZXIgc3RhdHMuXG4gICAqL1xuXG4gIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gY2hlY2tGaWx0ZXJzKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgIGlmICghZmlsdGVycykgcmV0dXJuO1xuICAgIHZhciBpID0gZmlsdGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGZpbHRlciA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlcnNbaV0ubmFtZSk7XG4gICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBmaWx0ZXIucmVhZCkge1xuICAgICAgICB0aGlzLmhhc1JlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICB0aGlzLmhhc1dyaXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5lbC5fX3ZfbW9kZWwgPSBudWxsO1xuICAgIHRoaXMuX3VuYmluZCAmJiB0aGlzLl91bmJpbmQoKTtcbiAgfVxufTtcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiBbOCwgNDZdLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwXG59O1xuXG5mdW5jdGlvbiBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cykge1xuICB2YXIgY29kZXMgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNoYXJDb2RlID0ga2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGNoYXJDb2RlID4gNDcgJiYgY2hhckNvZGUgPCA1OCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2hhckNvZGUgPSBrZXkudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNoYXJDb2RlID4gNjQgJiYgY2hhckNvZGUgPCA5MSkge1xuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlDb2Rlc1trZXldO1xuICB9KTtcbiAgY29kZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGNvZGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleUhhbmRsZXIoZSkge1xuICAgIGlmIChjb2Rlcy5pbmRleE9mKGUua2V5Q29kZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0b3BGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcEhhbmRsZXIoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJldmVudEZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50SGFuZGxlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGZGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZkhhbmRsZXIoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG9uJDEgPSB7XG5cbiAgcHJpb3JpdHk6IE9OLFxuICBhY2NlcHRTdGF0ZW1lbnQ6IHRydWUsXG4gIGtleUNvZGVzOiBrZXlDb2RlcyxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGRlYWwgd2l0aCBpZnJhbWVzXG4gICAgaWYgKHRoaXMuZWwudGFnTmFtZSA9PT0gJ0lGUkFNRScgJiYgdGhpcy5hcmcgIT09ICdsb2FkJykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5pZnJhbWVCaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbihzZWxmLmVsLmNvbnRlbnRXaW5kb3csIHNlbGYuYXJnLCBzZWxmLmhhbmRsZXIsIHNlbGYubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ2xvYWQnLCB0aGlzLmlmcmFtZUJpbmQpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShoYW5kbGVyKSB7XG4gICAgLy8gc3R1YiBhIG5vb3AgZm9yIHYtb24gd2l0aCBubyB2YWx1ZSxcbiAgICAvLyBlLmcuIEBtb3VzZWRvd24ucHJldmVudFxuICAgIGlmICghdGhpcy5kZXNjcmlwdG9yLnJhdykge1xuICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArICdnb3QgJyArIGhhbmRsZXIsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnByZXZlbnQpIHtcbiAgICAgIGhhbmRsZXIgPSBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMuc2VsZikge1xuICAgICAgaGFuZGxlciA9IHNlbGZGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIGtleSBmaWx0ZXJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubW9kaWZpZXJzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnICYmIGtleSAhPT0gJ3NlbGYnICYmIGtleSAhPT0gJ2NhcHR1cmUnO1xuICAgIH0pO1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLmlmcmFtZUJpbmQpIHtcbiAgICAgIHRoaXMuaWZyYW1lQmluZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbih0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyLCB0aGlzLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZCA/IHRoaXMuZWwuY29udGVudFdpbmRvdyA6IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFuZGxlcikge1xuICAgICAgb2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1tcy0nXTtcbnZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG52YXIgaW1wb3J0YW50UkUgPSAvIWltcG9ydGFudDs/JC87XG52YXIgcHJvcENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxudmFyIHRlc3RFbCA9IG51bGw7XG5cbnZhciBzdHlsZSA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlLnJlZHVjZShleHRlbmQsIHt9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiBoYW5kbGVPYmplY3QodmFsdWUpIHtcbiAgICAvLyBjYWNoZSBvYmplY3Qgc3R5bGVzIHNvIHRoYXQgb25seSBjaGFuZ2VkIHByb3BzXG4gICAgLy8gYXJlIGFjdHVhbGx5IHVwZGF0ZWQuXG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSB8fCAodGhpcy5jYWNoZSA9IHt9KTtcbiAgICB2YXIgbmFtZSwgdmFsO1xuICAgIGZvciAobmFtZSBpbiBjYWNoZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgbnVsbCk7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICB2YWwgPSB2YWx1ZVtuYW1lXTtcbiAgICAgIGlmICh2YWwgIT09IGNhY2hlW25hbWVdKSB7XG4gICAgICAgIGNhY2hlW25hbWVdID0gdmFsO1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIGhhbmRsZVNpbmdsZShwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBub3JtYWxpemUocHJvcCk7XG4gICAgaWYgKCFwcm9wKSByZXR1cm47IC8vIHVuc3VwcG9ydGVkIHByb3BcbiAgICAvLyBjYXN0IHBvc3NpYmxlIG51bWJlcnMvYm9vbGVhbnMgaW50byBzdHJpbmdzXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlICs9ICcnO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGlzSW1wb3J0YW50ID0gaW1wb3J0YW50UkUudGVzdCh2YWx1ZSkgPyAnaW1wb3J0YW50JyA6ICcnO1xuICAgICAgaWYgKGlzSW1wb3J0YW50KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ0l0XFwncyBwcm9iYWJseSBhIGJhZCBpZGVhIHRvIHVzZSAhaW1wb3J0YW50IHdpdGggaW5saW5lIHJ1bGVzLiAnICsgJ1RoaXMgZmVhdHVyZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBWdWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3Aua2ViYWIsIHZhbHVlLCBpc0ltcG9ydGFudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsLnN0eWxlW3Byb3AuY2FtZWxdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcC5jYW1lbF0gPSAnJztcbiAgICB9XG4gIH1cblxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBDU1MgcHJvcGVydHkgbmFtZS5cbiAqIC0gY2FjaGUgcmVzdWx0XG4gKiAtIGF1dG8gcHJlZml4XG4gKiAtIGNhbWVsQ2FzZSAtPiBkYXNoLWNhc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShwcm9wKSB7XG4gIGlmIChwcm9wQ2FjaGVbcHJvcF0pIHtcbiAgICByZXR1cm4gcHJvcENhY2hlW3Byb3BdO1xuICB9XG4gIHZhciByZXMgPSBwcmVmaXgocHJvcCk7XG4gIHByb3BDYWNoZVtwcm9wXSA9IHByb3BDYWNoZVtyZXNdID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEF1dG8gZGV0ZWN0IHRoZSBhcHByb3ByaWF0ZSBwcmVmaXggZm9yIGEgQ1NTIHByb3BlcnR5LlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzUyMzY5MlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcHJlZml4KHByb3ApIHtcbiAgcHJvcCA9IGh5cGhlbmF0ZShwcm9wKTtcbiAgdmFyIGNhbWVsID0gY2FtZWxpemUocHJvcCk7XG4gIHZhciB1cHBlciA9IGNhbWVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWwuc2xpY2UoMSk7XG4gIGlmICghdGVzdEVsKSB7XG4gICAgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIH1cbiAgdmFyIGkgPSBwcmVmaXhlcy5sZW5ndGg7XG4gIHZhciBwcmVmaXhlZDtcbiAgaWYgKGNhbWVsICE9PSAnZmlsdGVyJyAmJiBjYW1lbCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2ViYWI6IHByb3AsXG4gICAgICBjYW1lbDogY2FtZWxcbiAgICB9O1xuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBwcmVmaXhlZCA9IGNhbWVsUHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZWJhYjogcHJlZml4ZXNbaV0gKyBwcm9wLFxuICAgICAgICBjYW1lbDogcHJlZml4ZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHhsaW5rXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbnZhciB4bGlua1JFID0gL154bGluazovO1xuXG4vLyBjaGVjayBmb3IgYXR0cmlidXRlcyB0aGF0IHByb2hpYml0IGludGVycG9sYXRpb25zXG52YXIgZGlzYWxsb3dlZEludGVycEF0dHJSRSA9IC9edi18Xjp8XkB8Xig/OmlzfHRyYW5zaXRpb258dHJhbnNpdGlvbi1tb2RlfGRlYm91bmNlfHRyYWNrLWJ5fHN0YWdnZXJ8ZW50ZXItc3RhZ2dlcnxsZWF2ZS1zdGFnZ2VyKSQvO1xuLy8gdGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4vLyBiZWNhdXNlIHRoZXkgb25seSBhZmZlY3QgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbnZhciBhdHRyV2l0aFByb3BzUkUgPSAvXig/OnZhbHVlfGNoZWNrZWR8c2VsZWN0ZWR8bXV0ZWQpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIGV4cGVjdCBlbnVtcmF0ZWQgdmFsdWVzIG9mIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIlxuLy8gYnV0IGFyZSBub3QgYm9vbGVhbiBhdHRyaWJ1dGVzXG52YXIgZW51bWVyYXRlZEF0dHJSRSA9IC9eKD86ZHJhZ2dhYmxlfGNvbnRlbnRlZGl0YWJsZXxzcGVsbGNoZWNrKSQvO1xuXG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBzZXQgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4vLyBiaW5kaW5nIHYtbW9kZWwgdG8gb2JqZWN0IHZhbHVlc1xudmFyIG1vZGVsUHJvcHMgPSB7XG4gIHZhbHVlOiAnX3ZhbHVlJyxcbiAgJ3RydWUtdmFsdWUnOiAnX3RydWVWYWx1ZScsXG4gICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbn07XG5cbnZhciBiaW5kJDEgPSB7XG5cbiAgcHJpb3JpdHk6IEJJTkQsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgLy8gc2hvdWxkIGJlIGRlZXAgd2F0Y2ggb24gb2JqZWN0IG1vZGVcbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIHRoaXMuZGVlcCA9IHRydWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9uIGJpbmRpbmdzXG4gICAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG4gICAgdmFyIHRva2VucyA9IGRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9ucyB3aXRoIG9uZS10aW1lIHRva2Vuc1xuICAgICAgaWYgKGRlc2NyaXB0b3IuaGFzT25lVGltZSkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSB0b2tlbnNUb0V4cCh0b2tlbnMsIHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChkaXNhbGxvd2VkSW50ZXJwQXR0clJFLnRlc3QoYXR0cikgfHwgYXR0ciA9PT0gJ25hbWUnICYmICh0YWcgPT09ICdQQVJUSUFMJyB8fCB0YWcgPT09ICdTTE9UJykpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2F0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIGlzIG5vdCBhbGxvd2VkIGluIFZ1ZS5qcyAnICsgJ2RpcmVjdGl2ZXMgYW5kIHNwZWNpYWwgYXR0cmlidXRlcy4nLCB0aGlzLnZtKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJhdyA9IGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnO1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICB3YXJuKHJhdyArICdpbnRlcnBvbGF0aW9uIGluIFwic3JjXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICdhIDQwNCByZXF1ZXN0LiBVc2Ugdi1iaW5kOnNyYyBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FybiBzdHlsZVxuICAgICAgICBpZiAoYXR0ciA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzdHlsZVwiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgKyAnVXNlIHYtYmluZDpzdHlsZSBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIGlmICh0aGlzLmFyZykge1xuICAgICAgdGhpcy5oYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNoYXJlIG9iamVjdCBoYW5kbGVyIHdpdGggdi1iaW5kOmNsYXNzXG4gIGhhbmRsZU9iamVjdDogc3R5bGUuaGFuZGxlT2JqZWN0LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaW50ZXJwID0gdGhpcy5kZXNjcmlwdG9yLmludGVycDtcbiAgICBpZiAodGhpcy5tb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgIGF0dHIgPSBjYW1lbGl6ZShhdHRyKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnAgJiYgYXR0cldpdGhQcm9wc1JFLnRlc3QoYXR0cikgJiYgYXR0ciBpbiBlbCkge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHIgPT09ICd2YWx1ZScgPyB2YWx1ZSA9PSBudWxsIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgPyAnJyA6IHZhbHVlIDogdmFsdWU7XG5cbiAgICAgIGlmIChlbFthdHRyXSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgIGVsW2F0dHJdID0gYXR0clZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzZXQgbW9kZWwgcHJvcHNcbiAgICB2YXIgbW9kZWxQcm9wID0gbW9kZWxQcm9wc1thdHRyXTtcbiAgICBpZiAoIWludGVycCAmJiBtb2RlbFByb3ApIHtcbiAgICAgIGVsW21vZGVsUHJvcF0gPSB2YWx1ZTtcbiAgICAgIC8vIHVwZGF0ZSB2LW1vZGVsIGlmIHByZXNlbnRcbiAgICAgIHZhciBtb2RlbCA9IGVsLl9fdl9tb2RlbDtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5saXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyBub3Qgc2V0IHZhbHVlIGF0dHJpYnV0ZSBmb3IgdGV4dGFyZWFcbiAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVcbiAgICBpZiAoZW51bWVyYXRlZEF0dHJSRS50ZXN0KGF0dHIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICAvLyBoYW5kbGUgZWRnZSBjYXNlICMxOTYwOlxuICAgICAgICAvLyBjbGFzcyBpbnRlcnBvbGF0aW9uIHNob3VsZCBub3Qgb3ZlcndyaXRlIFZ1ZSB0cmFuc2l0aW9uIGNsYXNzXG4gICAgICAgIGlmIChlbC5fX3ZfdHJhbnMpIHtcbiAgICAgICAgICB2YWx1ZSArPSAnICcgKyBlbC5fX3ZfdHJhbnMuaWQgKyAnLXRyYW5zaXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIHNldENsYXNzKGVsLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBhdHRyLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbCA9IHtcblxuICBwcmlvcml0eTogRUwsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMuYXJnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBjYW1lbGl6ZSh0aGlzLmFyZyk7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAoaGFzT3duKHJlZnMsIGlkKSkge1xuICAgICAgcmVmc1tpZF0gPSB0aGlzLmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShyZWZzLCBpZCwgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgIHJlZnNbdGhpcy5pZF0gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJlZiA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtcmVmOicgKyB0aGlzLmFyZyArICcgbXVzdCBiZSB1c2VkIG9uIGEgY2hpbGQgJyArICdjb21wb25lbnQuIEZvdW5kIG9uIDwnICsgdGhpcy5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPi4nLCB0aGlzLnZtKTtcbiAgfVxufTtcblxudmFyIGNsb2FrID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdGhpcy52bS4kb25jZSgncHJlLWhvb2s6Y29tcGlsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gbXVzdCBleHBvcnQgcGxhaW4gb2JqZWN0XG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgdGV4dDogdGV4dCQxLFxuICBodG1sOiBodG1sLFxuICAnZm9yJzogdkZvcixcbiAgJ2lmJzogdklmLFxuICBzaG93OiBzaG93LFxuICBtb2RlbDogbW9kZWwsXG4gIG9uOiBvbiQxLFxuICBiaW5kOiBiaW5kJDEsXG4gIGVsOiBlbCxcbiAgcmVmOiByZWYsXG4gIGNsb2FrOiBjbG9ha1xufTtcblxudmFyIHZDbGFzcyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNldENsYXNzKHZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDbGFzcyhub3JtYWxpemUkMSh2YWx1ZSkpO1xuICAgIH1cbiAgfSxcblxuICBzZXRDbGFzczogZnVuY3Rpb24gc2V0Q2xhc3ModmFsdWUpIHtcbiAgICB0aGlzLmNsZWFudXAodmFsdWUpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gdmFsdWVbaV07XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGFwcGx5KHRoaXMuZWwsIHZhbCwgYWRkQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZLZXlzID0gdmFsdWU7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cCh2YWx1ZSkge1xuICAgIHZhciBwcmV2S2V5cyA9IHRoaXMucHJldktleXM7XG4gICAgaWYgKCFwcmV2S2V5cykgcmV0dXJuO1xuICAgIHZhciBpID0gcHJldktleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBhcHBseSh0aGlzLmVsLCBrZXksIHJlbW92ZUNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIG9iamVjdHMgYW5kIGFycmF5cyAocG90ZW50aWFsbHkgY29udGFpbmluZyBvYmplY3RzKVxuICogaW50byBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5PFN0cmluZ3xPYmplY3Q+fSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXk8U3RyaW5nPn1cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUkMSh2YWx1ZSkge1xuICB2YXIgcmVzID0gW107XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IHZhbHVlW2ldO1xuICAgICAgaWYgKF9rZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfa2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlcy5wdXNoKF9rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gX2tleSkge1xuICAgICAgICAgICAgaWYgKF9rZXlba10pIHJlcy5wdXNoKGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgYSBjbGFzcy9jbGFzc2VzIG9uIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBjbGFzcyBuYW1lLiBUaGlzIG1heSBvciBtYXkgbm90XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW4gYSBzcGFjZSBjaGFyYWN0ZXIsIGluIHN1Y2ggYVxuICogICAgICAgICAgICAgICAgICAgICBjYXNlIHdlJ2xsIGRlYWwgd2l0aCBtdWx0aXBsZSBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICBuYW1lcyBhdCBvbmNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseShlbCwga2V5LCBmbikge1xuICBrZXkgPSBrZXkudHJpbSgpO1xuICBpZiAoa2V5LmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICBmbihlbCwga2V5KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVGhlIGtleSBjb250YWlucyBvbmUgb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzLlxuICAvLyBTaW5jZSBhIGNsYXNzIG5hbWUgZG9lc24ndCBhY2NlcHQgc3VjaCBjaGFyYWN0ZXJzLCB3ZVxuICAvLyB0cmVhdCBpdCBhcyBtdWx0aXBsZSBjbGFzc2VzLlxuICB2YXIga2V5cyA9IGtleS5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm4oZWwsIGtleXNbaV0pO1xuICB9XG59XG5cbnZhciBjb21wb25lbnQgPSB7XG5cbiAgcHJpb3JpdHk6IENPTVBPTkVOVCxcblxuICBwYXJhbXM6IFsna2VlcC1hbGl2ZScsICd0cmFuc2l0aW9uLW1vZGUnLCAnaW5saW5lLXRlbXBsYXRlJ10sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIGlmICghdGhpcy5lbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGVcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAvLyBleHRyYWN0IGlubGluZSB0ZW1wbGF0ZSBhcyBhIERvY3VtZW50RnJhZ21lbnRcbiAgICAgICAgdGhpcy5pbmxpbmVUZW1wbGF0ZSA9IGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gY29tcG9uZW50IHJlc29sdXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSB0aGlzLkNvbXBvbmVudCA9IG51bGw7XG4gICAgICAvLyB0cmFuc2l0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzID0gMDtcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAvLyBjcmVhdGUgYSByZWYgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgLy8gcmVtb3ZlIGlzIGF0dHJpYnV0ZS5cbiAgICAgIC8vIHRoaXMgaXMgcmVtb3ZlZCBkdXJpbmcgY29tcGlsYXRpb24sIGJ1dCBiZWNhdXNlIGNvbXBpbGF0aW9uIGlzXG4gICAgICAvLyBjYWNoZWQsIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1c2VkIGVsc2V3aGVyZSB0aGlzIGF0dHJpYnV0ZVxuICAgICAgLy8gd2lsbCByZW1haW4gYXQgbGluayB0aW1lLlxuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnOmlzJyk7XG4gICAgICAvLyByZW1vdmUgcmVmLCBzYW1lIGFzIGFib3ZlXG4gICAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJlZikge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgndi1yZWY6JyArIGh5cGhlbmF0ZSh0aGlzLmRlc2NyaXB0b3IucmVmKSk7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGF0aWMsIGJ1aWxkIHJpZ2h0IG5vdy5cbiAgICAgIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgdGhpcy5zZXRDb21wb25lbnQodGhpcy5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICsgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdXBkYXRlLCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIgaW4gdGhlIGR5bmFtaWNcbiAgICogbGl0ZXJhbCBzY2VuYXJpbywgZS5nLiA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMubGl0ZXJhbCkge1xuICAgICAgdGhpcy5zZXRDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAvLyBqdXN0IHJlbW92ZSBjdXJyZW50XG4gICAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkVk0sIGNiKTtcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMucmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm1vdW50Q29tcG9uZW50KGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG4gICAqIHRoZSBjaGlsZCB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHJlc29sdmVDb21wb25lbnQ6IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgc2VsZi5Db21wb25lbnROYW1lID0gQ29tcG9uZW50Lm9wdGlvbnMubmFtZSB8fCAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogbnVsbCk7XG4gICAgICBzZWxmLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgdGhpcy52bS5fcmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UgdXNpbmcgdGhlIGN1cnJlbnQgY29uc3RydWN0b3IgYW5kXG4gICAqIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBkb2Vzbid0IGNhcmVcbiAgICogd2hldGhlciB0aGUgbmV3IGNvbXBvbmVudCBhbmQgdGhlIG9sZCBvbmUgYXJlIGFjdHVhbGx5XG4gICAqIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiBtb3VudENvbXBvbmVudChjYikge1xuICAgIC8vIGFjdHVhbCBtb3VudFxuICAgIHRoaXMudW5idWlsZCh0cnVlKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFjdGl2YXRlSG9va3MgPSB0aGlzLkNvbXBvbmVudC5vcHRpb25zLmFjdGl2YXRlO1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKCk7XG4gICAgaWYgKGFjdGl2YXRlSG9va3MgJiYgIWNhY2hlZCkge1xuICAgICAgdGhpcy53YWl0aW5nRm9yID0gbmV3Q29tcG9uZW50O1xuICAgICAgY2FsbEFjdGl2YXRlSG9va3MoYWN0aXZhdGVIb29rcywgbmV3Q29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLndhaXRpbmdGb3IgIT09IG5ld0NvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLndhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICBzZWxmLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIHJlZiBmb3Iga2VwdC1hbGl2ZSBjb21wb25lbnRcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgbmV3Q29tcG9uZW50Ll91cGRhdGVSZWYoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAqIGNvbnN0cnVjdG9yIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgaXRzXG4gICAqIHBlbmRpbmcgY2FsbGJhY2suXG4gICAqL1xuXG4gIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbiBpbnZhbGlkYXRlUGVuZGluZygpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiLmNhbmNlbCgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUvaW5zZXJ0IGEgbmV3IGNoaWxkIHZtLlxuICAgKiBJZiBrZWVwIGFsaXZlIGFuZCBoYXMgY2FjaGVkIGluc3RhbmNlLCBpbnNlcnQgdGhhdFxuICAgKiBpbnN0YW5jZTsgb3RoZXJ3aXNlIGJ1aWxkIGEgbmV3IG9uZSBhbmQgY2FjaGUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFPcHRpb25zXVxuICAgKiBAcmV0dXJuIHtWdWV9IC0gdGhlIGNyZWF0ZWQgaW5zdGFuY2VcbiAgICovXG5cbiAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGV4dHJhT3B0aW9ucykge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLkNvbXBvbmVudCkge1xuICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5Db21wb25lbnROYW1lLFxuICAgICAgICBlbDogY2xvbmVOb2RlKHRoaXMuZWwpLFxuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFkZCB0aGUgY2hpbGQgd2l0aCBjb3JyZWN0IHBhcmVudFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgdHJhbnNjbHVzaW9uIGhvc3QuXG4gICAgICAgIHBhcmVudDogdGhpcy5faG9zdCB8fCB0aGlzLnZtLFxuICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIF9yZWY6IHRoaXMuZGVzY3JpcHRvci5yZWYsXG4gICAgICAgIF9hc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgX2lzUm91dGVyVmlldzogdGhpcy5faXNSb3V0ZXJWaWV3LFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgICAgIF9jb250ZXh0OiB0aGlzLnZtLFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAgICAgICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgICAgIF9zY29wZTogdGhpcy5fc2NvcGUsXG4gICAgICAgIC8vIHBhc3MgaW4gdGhlIG93bmVyIGZyYWdtZW50IG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBzbyB0aGF0IHRoZSBmcmFnbWVudCBjYW4ga2VlcFxuICAgICAgICAvLyB0cmFjayBvZiBpdHMgY29udGFpbmVkIGNvbXBvbmVudHMgaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gY2FsbCBhdHRhY2gvZGV0YWNoIGhvb2tzIGZvciB0aGVtLlxuICAgICAgICBfZnJhZzogdGhpcy5fZnJhZ1xuICAgICAgfTtcbiAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgIC8vIGluIDEuMC4wIHRoaXMgaXMgdXNlZCBieSB2dWUtcm91dGVyIG9ubHlcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICBleHRlbmQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLkNvbXBvbmVudChvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF0gPSBjaGlsZDtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbC5oYXNBdHRyaWJ1dGUoJ3RyYW5zaXRpb24nKSAmJiBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICB3YXJuKCdUcmFuc2l0aW9ucyB3aWxsIG5vdCB3b3JrIG9uIGEgZnJhZ21lbnQgaW5zdGFuY2UuICcgKyAnVGVtcGxhdGU6ICcgKyBjaGlsZC4kb3B0aW9ucy50ZW1wbGF0ZSwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJ5IHRvIGdldCBhIGNhY2hlZCBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Z1ZXx1bmRlZmluZWR9XG4gICAqL1xuXG4gIGdldENhY2hlZDogZnVuY3Rpb24gZ2V0Q2FjaGVkKCkge1xuICAgIHJldHVybiB0aGlzLmtlZXBBbGl2ZSAmJiB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBjdXJyZW50IGNoaWxkLCBidXQgZGVmZXJzIGNsZWFudXAgc29cbiAgICogdGhhdCB3ZSBjYW4gc2VwYXJhdGUgdGhlIGRlc3Ryb3kgYW5kIHJlbW92YWwgc3RlcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJcbiAgICovXG5cbiAgdW5idWlsZDogZnVuY3Rpb24gdW5idWlsZChkZWZlcikge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3IpIHtcbiAgICAgIGlmICghdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkVk07XG4gICAgaWYgKCFjaGlsZCB8fCB0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIC8vIHJlbW92ZSByZWZcbiAgICAgICAgY2hpbGQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY2hpbGQuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdGhlIHNvbGUgcHVycG9zZSBvZiBgZGVmZXJDbGVhbnVwYCBpcyBzbyB0aGF0IHdlIGNhblxuICAgIC8vIFwiZGVhY3RpdmF0ZVwiIHRoZSB2bSByaWdodCBub3cgYW5kIHBlcmZvcm0gRE9NIHJlbW92YWxcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC4kZGVzdHJveShmYWxzZSwgZGVmZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY3VycmVudCBkZXN0cm95ZWQgY2hpbGQgYW5kIG1hbnVhbGx5IGRvXG4gICAqIHRoZSBjbGVhbnVwIGFmdGVyIHJlbW92YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNoaWxkLCBjYikge1xuICAgIHZhciBrZWVwQWxpdmUgPSB0aGlzLmtlZXBBbGl2ZTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyB0cmFuc2l0aW9uZWQgb3V0LlxuICAgICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9ubHkgb25lIGxhc3Rlc3QgaW5zZXJ0aW9uIGNiXG4gICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscysrO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gY2I7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbHMtLTtcbiAgICAgICAgaWYgKCFrZWVwQWxpdmUpIGNoaWxkLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICghc2VsZi5wZW5kaW5nUmVtb3ZhbHMgJiYgc2VsZi5wZW5kaW5nUmVtb3ZhbENiKSB7XG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiKCk7XG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHN3YXAgdGhlIGNvbXBvbmVudHMsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKHRhcmdldCwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoaWxkVk07XG4gICAgLy8gZm9yIGRldnRvb2wgaW5zcGVjdGlvblxuICAgIGlmIChjdXJyZW50KSBjdXJyZW50Ll9pbmFjdGl2ZSA9IHRydWU7XG4gICAgdGFyZ2V0Ll9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hpbGRWTSA9IHRhcmdldDtcbiAgICBzd2l0Y2ggKHNlbGYucGFyYW1zLnRyYW5zaXRpb25Nb2RlKSB7XG4gICAgICBjYXNlICdpbi1vdXQnOlxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3V0LWluJzpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kLlxuICAgKi9cblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgLy8gRG8gbm90IGRlZmVyIGNsZWFudXAgd2hlbiB1bmJpbmRpbmdcbiAgICB0aGlzLnVuYnVpbGQoKTtcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhY3RpdmF0ZSBob29rcyBpbiBvcmRlciAoYXN5bmNocm9ub3VzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlSG9va3MoaG9va3MsIHZtLCBjYikge1xuICB2YXIgdG90YWwgPSBob29rcy5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSAwO1xuICBob29rc1swXS5jYWxsKHZtLCBuZXh0KTtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoKytjYWxsZWQgPj0gdG90YWwpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzW2NhbGxlZF0uY2FsbCh2bSwgbmV4dCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wQmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xudmFyIGVtcHR5ID0ge307XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFJDEgPSAvXlskX2EtekEtWl0rW1xcdyRdKiQvO1xudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokLztcblxuLyoqXG4gKiBDb21waWxlIHByb3BzIG9uIGEgcm9vdCBlbGVtZW50IGFuZCByZXR1cm5cbiAqIGEgcHJvcHMgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BPcHRpb25zXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVQcm9wcyhlbCwgcHJvcE9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wT3B0aW9ucyk7XG4gIHZhciBpID0gbmFtZXMubGVuZ3RoO1xuICB2YXIgb3B0aW9ucywgbmFtZSwgYXR0ciwgdmFsdWUsIHBhdGgsIHBhcnNlZCwgcHJvcDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBvcHRpb25zID0gcHJvcE9wdGlvbnNbbmFtZV0gfHwgZW1wdHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICB3YXJuKCdEbyBub3QgdXNlICRkYXRhIGFzIHByb3AuJywgdm0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcHJvcHMgY291bGQgY29udGFpbiBkYXNoZXMsIHdoaWNoIHdpbGwgYmVcbiAgICAvLyBpbnRlcnByZXRlZCBhcyBtaW51cyBjYWxjdWxhdGlvbnMgYnkgdGhlIHBhcnNlclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIHBhdGggaGVyZVxuICAgIHBhdGggPSBjYW1lbGl6ZShuYW1lKTtcbiAgICBpZiAoIWlkZW50UkUkMS50ZXN0KHBhdGgpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcCBrZXk6IFwiJyArIG5hbWUgKyAnXCIuIFByb3Aga2V5cyAnICsgJ211c3QgYmUgdmFsaWQgaWRlbnRpZmllcnMuJywgdm0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWSxcbiAgICAgIHJhdzogbnVsbFxuICAgIH07XG5cbiAgICBhdHRyID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgIC8vIGZpcnN0IGNoZWNrIGR5bmFtaWMgdmVyc2lvblxuICAgIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0cikpID09PSBudWxsKSB7XG4gICAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLnN5bmMnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuICAgICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0ciArICcub25jZScpKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBkeW5hbWljIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgICAgdmFsdWUgPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICAgIHByb3AuZmlsdGVycyA9IHBhcnNlZC5maWx0ZXJzO1xuICAgICAgLy8gY2hlY2sgYmluZGluZyB0eXBlXG4gICAgICBpZiAoaXNMaXRlcmFsKHZhbHVlKSAmJiAhcGFyc2VkLmZpbHRlcnMpIHtcbiAgICAgICAgLy8gZm9yIGV4cHJlc3Npb25zIGNvbnRhaW5pbmcgbGl0ZXJhbCBudW1iZXJzIGFuZFxuICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gb3B0aW1pemUgdGhlbSBhcyBhIG9uZS10aW1lIHNldC5cbiAgICAgICAgcHJvcC5vcHRpbWl6ZWRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZHluYW1pYyA9IHRydWU7XG4gICAgICAgIC8vIGNoZWNrIG5vbi1zZXR0YWJsZSBwYXRoIGZvciB0d28td2F5IGJpbmRpbmdzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZICYmICFzZXR0YWJsZVBhdGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWTtcbiAgICAgICAgICB3YXJuKCdDYW5ub3QgYmluZCB0d28td2F5IHByb3Agd2l0aCBub24tc2V0dGFibGUgJyArICdwYXJlbnQgcGF0aDogJyArIHZhbHVlLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AucGFyZW50UGF0aCA9IHZhbHVlO1xuXG4gICAgICAvLyB3YXJuIHJlcXVpcmVkIHR3by13YXlcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMudHdvV2F5ICYmIHByb3AubW9kZSAhPT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZKSB7XG4gICAgICAgIHdhcm4oJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJywgdm0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QXR0cihlbCwgYXR0cikpICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgbGl0ZXJhbCBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGNoZWNrIHBvc3NpYmxlIGNhbWVsQ2FzZSBwcm9wIHVzYWdlXG4gICAgICB2YXIgbG93ZXJDYXNlTmFtZSA9IHBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gL1tBLVpcXC1dLy50ZXN0KG5hbWUpICYmIChlbC5nZXRBdHRyaWJ1dGUobG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcub25jZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLnN5bmMnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuKCdQb3NzaWJsZSB1c2FnZSBlcnJvciBmb3IgcHJvcCBgJyArIGxvd2VyQ2FzZU5hbWUgKyAnYCAtICcgKyAnZGlkIHlvdSBtZWFuIGAnICsgYXR0ciArICdgPyBIVE1MIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHJlbWVtYmVyIHRvIHVzZSAnICsgJ2tlYmFiLWNhc2UgZm9yIHByb3BzIGluIHRlbXBsYXRlcy4nLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogJyArIG5hbWUsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVzaCBwcm9wXG4gICAgcHJvcHMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gbWFrZVByb3BzTGlua0ZuKHByb3BzKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3BzTGlua0ZuKHZtLCBzY29wZSkge1xuICAgIC8vIHN0b3JlIHJlc29sdmVkIHByb3BzIGluZm9cbiAgICB2bS5fcHJvcHMgPSB7fTtcbiAgICB2YXIgaW5saW5lUHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgdmFyIHByb3AsIHBhdGgsIG9wdGlvbnMsIHZhbHVlLCByYXc7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgcmF3ID0gcHJvcC5yYXc7XG4gICAgICBwYXRoID0gcHJvcC5wYXRoO1xuICAgICAgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3A7XG4gICAgICBpZiAoaW5saW5lUHJvcHMgJiYgaGFzT3duKGlubGluZVByb3BzLCBwYXRoKSkge1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgaW5saW5lUHJvcHNbcGF0aF0pO1xuICAgICAgfWlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgLy8gb25lIHRpbWUgYmluZGluZ1xuICAgICAgICAgIHZhbHVlID0gKHNjb3BlIHx8IHZtLl9jb250ZXh0IHx8IHZtKS4kZ2V0KHByb3AucGFyZW50UGF0aCk7XG4gICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYmluZGluZ1xuICAgICAgICAgICAgdm0uX2JpbmREaXIoe1xuICAgICAgICAgICAgICBuYW1lOiAncHJvcCcsXG4gICAgICAgICAgICAgIGRlZjogcHJvcERlZixcbiAgICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgICAgfSwgbnVsbCwgbnVsbCwgc2NvcGUpOyAvLyBlbCwgaG9zdCwgc2NvcGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByb290IGluc3RhbmNlXG4gICAgICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2bS4kZ2V0KHByb3AucGFyZW50UGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhyYXcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmlwcGVkID09PSByYXcgPyB0b0Jvb2xlYW4odG9OdW1iZXIocmF3KSkgOiBzdHJpcHBlZDtcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cmluZyBsaXRlcmFsLCBidXQgd2UgbmVlZCB0byBjYXRlciBmb3JcbiAgICAgICAgLy8gQm9vbGVhbiBwcm9wcyB3aXRoIG5vIHZhbHVlLCBvciB3aXRoIHNhbWVcbiAgICAgICAgLy8gbGl0ZXJhbCB2YWx1ZSAoZS5nLiBkaXNhYmxlZD1cImRpc2FibGVkXCIpXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWxvYWRlci9pc3N1ZXMvMTgyXG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy50eXBlID09PSBCb29sZWFuICYmIChyYXcgPT09ICcnIHx8IHJhdyA9PT0gaHlwaGVuYXRlKHByb3AubmFtZSkpID8gdHJ1ZSA6IHJhdztcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHByb3Agd2l0aCBhIHJhd1ZhbHVlLCBhcHBseWluZyBuZWNlc3NhcnkgY29lcnNpb25zLFxuICogZGVmYXVsdCB2YWx1ZXMgJiBhc3NlcnRpb25zIGFuZCBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayB3aXRoXG4gKiBwcm9jZXNzZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSByYXdWYWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCByYXdWYWx1ZSwgZm4pIHtcbiAgdmFyIGlzU2ltcGxlID0gcHJvcC5keW5hbWljICYmIGlzU2ltcGxlUGF0aChwcm9wLnBhcmVudFBhdGgpO1xuICB2YXIgdmFsdWUgPSByYXdWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3ApO1xuICB9XG4gIHZhbHVlID0gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSwgdm0pO1xuICB2YXIgY29lcmNlZCA9IHZhbHVlICE9PSByYXdWYWx1ZTtcbiAgaWYgKCFhc3NlcnRQcm9wKHByb3AsIHZhbHVlLCB2bSkpIHtcbiAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNTaW1wbGUgJiYgIWNvZXJjZWQpIHtcbiAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICBmbih2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm4odmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcCdzIGluaXRpYWwgdmFsdWUgb24gYSB2bSBhbmQgaXRzIGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgdmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCBwcm9wLnBhdGgsIHZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcCdzIHZhbHVlIG9uIGEgdm0uXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3Aodm0sIHByb3AsIHZhbHVlKSB7XG4gIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2bVtwcm9wLnBhdGhdID0gdmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wKSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gIGlmICghaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0JykpIHtcbiAgICAvLyBhYnNlbnQgYm9vbGVhbiB2YWx1ZSBkZWZhdWx0cyB0byBmYWxzZVxuICAgIHJldHVybiBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGVmID0gb3B0aW9uc1snZGVmYXVsdCddO1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiOiAnICsgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgKyAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLnR5cGUgIT09IEZ1bmN0aW9uID8gZGVmLmNhbGwodm0pIDogZGVmO1xufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFwcm9wLm9wdGlvbnMucmVxdWlyZWQgJiYgKCAvLyBub24tcmVxdWlyZWRcbiAgcHJvcC5yYXcgPT09IG51bGwgfHwgLy8gYWJzY2VudFxuICB2YWx1ZSA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIWlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiLicgKyAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChmb3JtYXRUeXBlKS5qb2luKCcsICcpICsgJywgZ290ICcgKyBmb3JtYXRWYWx1ZSh2YWx1ZSkgKyAnLicsIHZtKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIi4nLCB2bSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEZvcmNlIHBhcnNpbmcgdmFsdWUgd2l0aCBjb2VyY2Ugb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZVByb3AocHJvcCwgdmFsdWUsIHZtKSB7XG4gIHZhciBjb2VyY2UgPSBwcm9wLm9wdGlvbnMuY29lcmNlO1xuICBpZiAoIWNvZXJjZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBjb2VyY2UgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiOiBleHBlY3RlZCBmdW5jdGlvbiwgZ290ICcgKyB0eXBlb2YgY29lcmNlICsgJy4nLCB2bSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mIGEgdmFsdWVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGU7XG4gIGlmICh0eXBlID09PSBTdHJpbmcpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnc3RyaW5nJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdudW1iZXInO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZ1bmN0aW9uKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IE9iamVjdCkge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdvYmplY3QnO1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQXJyYXkpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnYXJyYXknO1xuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdHlwZSBmb3Igb3V0cHV0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSA6ICdjdXN0b20gdHlwZSc7XG59XG5cbi8qKlxuICogRm9ybWF0IHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xufVxuXG52YXIgYmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xuXG52YXIgcHJvcERlZiA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMudm07XG4gICAgdmFyIHBhcmVudCA9IGNoaWxkLl9jb250ZXh0O1xuICAgIC8vIHBhc3NlZCBpbiBmcm9tIGNvbXBpbGVyIGRpcmVjdGx5XG4gICAgdmFyIHByb3AgPSB0aGlzLmRlc2NyaXB0b3IucHJvcDtcbiAgICB2YXIgY2hpbGRLZXkgPSBwcm9wLnBhdGg7XG4gICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aDtcbiAgICB2YXIgdHdvV2F5ID0gcHJvcC5tb2RlID09PSBiaW5kaW5nTW9kZXMuVFdPX1dBWTtcblxuICAgIHZhciBwYXJlbnRXYXRjaGVyID0gdGhpcy5wYXJlbnRXYXRjaGVyID0gbmV3IFdhdGNoZXIocGFyZW50LCBwYXJlbnRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHVwZGF0ZVByb3AoY2hpbGQsIHByb3AsIHZhbCk7XG4gICAgfSwge1xuICAgICAgdHdvV2F5OiB0d29XYXksXG4gICAgICBmaWx0ZXJzOiBwcm9wLmZpbHRlcnMsXG4gICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAvLyB2LWZvciBzY29wZSBpZiBwcmVzZW50XG4gICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICB9KTtcblxuICAgIC8vIHNldCB0aGUgY2hpbGQgaW5pdGlhbCB2YWx1ZS5cbiAgICBpbml0UHJvcChjaGlsZCwgcHJvcCwgcGFyZW50V2F0Y2hlci52YWx1ZSk7XG5cbiAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICBpZiAodHdvV2F5KSB7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGRlZmVyIHRoZSBjaGlsZCB3YXRjaGVyIGNyZWF0aW9uIHVudGlsXG4gICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2hpbGQuJG9uY2UoJ3ByZS1ob29rOmNyZWF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2hpbGRXYXRjaGVyID0gbmV3IFdhdGNoZXIoY2hpbGQsIGNoaWxkS2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcGFyZW50V2F0Y2hlci5zZXQodmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIC8vIGVuc3VyZSBzeW5jIHVwd2FyZCBiZWZvcmUgcGFyZW50IHN5bmMgZG93bi5cbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBpbiBjYXNlcyBlLmcuIHRoZSBjaGlsZFxuICAgICAgICAgIC8vIG11dGF0ZXMgYSBwcm9wIGFycmF5LCB0aGVuIHJlcGxhY2VzIGl0LiAoIzE2ODMpXG4gICAgICAgICAgc3luYzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLnBhcmVudFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICBpZiAodGhpcy5jaGlsZFdhdGNoZXIpIHtcbiAgICAgIHRoaXMuY2hpbGRXYXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUkMSA9IFtdO1xudmFyIHF1ZXVlZCA9IGZhbHNlO1xuXG4vKipcbiAqIFB1c2ggYSBqb2IgaW50byB0aGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gam9iXG4gKi9cblxuZnVuY3Rpb24gcHVzaEpvYihqb2IpIHtcbiAgcXVldWUkMS5wdXNoKGpvYik7XG4gIGlmICghcXVldWVkKSB7XG4gICAgcXVldWVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhmbHVzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCB0aGUgcXVldWUsIGFuZCBkbyBvbmUgZm9yY2VkIHJlZmxvdyBiZWZvcmVcbiAqIHRyaWdnZXJpbmcgdHJhbnNpdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIC8vIEZvcmNlIGxheW91dFxuICB2YXIgZiA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUkMS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlJDFbaV0oKTtcbiAgfVxuICBxdWV1ZSQxID0gW107XG4gIHF1ZXVlZCA9IGZhbHNlO1xuICAvLyBkdW1teSByZXR1cm4sIHNvIGpzIGxpbnRlcnMgZG9uJ3QgY29tcGxhaW4gYWJvdXRcbiAgLy8gdW51c2VkIHZhcmlhYmxlIGZcbiAgcmV0dXJuIGY7XG59XG5cbnZhciBUWVBFX1RSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgVFlQRV9BTklNQVRJT04gPSAnYW5pbWF0aW9uJztcbnZhciB0cmFuc0R1cmF0aW9uUHJvcCA9IHRyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcbnZhciBhbmltRHVyYXRpb25Qcm9wID0gYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbic7XG5cbi8qKlxuICogSWYgYSBqdXN0LWVudGVyZWQgZWxlbWVudCBpcyBhcHBsaWVkIHRoZVxuICogbGVhdmUgY2xhc3Mgd2hpbGUgaXRzIGVudGVyIHRyYW5zaXRpb24gaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICogYW5kIHRoZSB0cmFuc2l0aW9uZWQgcHJvcGVydHkgaGFzIHRoZSBzYW1lIHZhbHVlIGZvciBib3RoXG4gKiBlbnRlci9sZWF2ZSwgdGhlbiB0aGUgbGVhdmUgdHJhbnNpdGlvbiB3aWxsIGJlIHNraXBwZWQgYW5kXG4gKiB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBuZXZlciBmaXJlcy4gVGhpcyBmdW5jdGlvbiBlbnN1cmVzXG4gKiBpdHMgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyIGEgdHJhbnNpdGlvbiBoYXMgc3RhcnRlZFxuICogYnkgd2FpdGluZyBmb3IgZG91YmxlIHJhZi5cbiAqXG4gKiBJdCBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQgb24gZGV2aWNlcyB0aGF0IHN1cHBvcnQgQ1NTXG4gKiB0cmFuc2l0aW9ucyBidXQgbm90IHJhZiAoZS5nLiBBbmRyb2lkIDQuMiBicm93c2VyKSAtIHNpbmNlXG4gKiB0aGVzZSBlbnZpcm9ubWVudHMgYXJlIHVzdWFsbHkgc2xvdywgd2UgYXJlIGdpdmluZyBpdCBhXG4gKiByZWxhdGl2ZWx5IGxhcmdlIHRpbWVvdXQuXG4gKi9cblxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xudmFyIHdhaXRGb3JUcmFuc2l0aW9uU3RhcnQgPSByYWZcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4/IGZ1bmN0aW9uIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICBzZXRUaW1lb3V0KGZuLCA1MCk7XG59O1xuXG4vKipcbiAqIEEgVHJhbnNpdGlvbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIHN0YXRlIGFuZCBsb2dpY1xuICogb2YgdGhlIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGVsLCBpZCwgaG9va3MsIHZtKSB7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmVudGVyQ2xhc3MgPSBob29rcyAmJiBob29rcy5lbnRlckNsYXNzIHx8IGlkICsgJy1lbnRlcic7XG4gIHRoaXMubGVhdmVDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmxlYXZlQ2xhc3MgfHwgaWQgKyAnLWxlYXZlJztcbiAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICB0aGlzLnZtID0gdm07XG4gIC8vIGFzeW5jIHN0YXRlXG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHRoaXMuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5lbnRlcmVkID0gdGhpcy5sZWZ0ID0gZmFsc2U7XG4gIHRoaXMudHlwZUNhY2hlID0ge307XG4gIC8vIGNoZWNrIGNzcyB0cmFuc2l0aW9uIHR5cGVcbiAgdGhpcy50eXBlID0gaG9va3MgJiYgaG9va3MudHlwZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgIT09IFRZUEVfVFJBTlNJVElPTiAmJiB0aGlzLnR5cGUgIT09IFRZUEVfQU5JTUFUSU9OKSB7XG4gICAgICB3YXJuKCdpbnZhbGlkIENTUyB0cmFuc2l0aW9uIHR5cGUgZm9yIHRyYW5zaXRpb249XCInICsgdGhpcy5pZCArICdcIjogJyArIHRoaXMudHlwZSwgdm0pO1xuICAgIH1cbiAgfVxuICAvLyBiaW5kXG4gIHZhciBzZWxmID0gdGhpcztbJ2VudGVyTmV4dFRpY2snLCAnZW50ZXJEb25lJywgJ2xlYXZlTmV4dFRpY2snLCAnbGVhdmVEb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbbV0gPSBiaW5kKHNlbGZbbV0sIHNlbGYpO1xuICB9KTtcbn1cblxudmFyIHAkMSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5lbnRlciA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJyk7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgb3AoKTtcbiAgdGhpcy5lbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2VudGVyJyk7XG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5lbnRlckNhbmNlbGxlZDtcbiAgcHVzaEpvYih0aGlzLmVudGVyTmV4dFRpY2spO1xufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24sIHdoaWNoIGlzXG4gKiB0byBiZSBwdXNoZWQgaW50byBhIHF1ZXVlIGFuZCBleGVjdXRlZCBhZnRlciBhIHJlZmxvdyBzb1xuICogdGhhdCByZW1vdmluZyB0aGUgY2xhc3MgY2FuIHRyaWdnZXIgYSBDU1MgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICAvLyBwcmV2ZW50IHRyYW5zaXRpb24gc2tpcHBpbmdcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IHRydWU7XG4gIHdhaXRGb3JUcmFuc2l0aW9uU3RhcnQoZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIH0pO1xuICB2YXIgZW50ZXJEb25lID0gdGhpcy5lbnRlckRvbmU7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmVudGVyQ2xhc3MpO1xuICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gYnkgcmVtb3ZpbmcgZW50ZXIgY2xhc3Mgbm93XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgICAgdGhpcy5zZXR1cENzc0NiKHRyYW5zaXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfQU5JTUFUSU9OKSB7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IoYW5pbWF0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyRG9uZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlckRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW50ZXJlZCA9IHRydWU7XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyRW50ZXInKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbn07XG5cbi8qKlxuICogU3RhcnQgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gbGVhdmUgdHJhbnNpdGlvbiB0cmlnZ2VyZWQuXG4gKiAyLiBjYWxsIGJlZm9yZUxlYXZlIGhvb2tcbiAqIDMuIGFkZCBsZWF2ZSBjbGFzcyAodHJpZ2dlciBjc3MgdHJhbnNpdGlvbilcbiAqIDQuIGNhbGwgbGVhdmUgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDUuIHJlZmxvdyBpZiBubyBleHBsaWNpdCBqcyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICogNi4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBlbmQgZXZlbnQsIHJlbW92ZSBjbGFzcywgdGhlbiBkb25lIGlmXG4gKiAgICAgICAgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogNy4gd2FpdCBmb3IgZWl0aGVyIGRvbmUgb3IganMgY2FsbGJhY2ssIHRoZW4gY2FsbFxuICogICAgYWZ0ZXJMZWF2ZSBob29rLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gcmVtb3ZlL2hpZGUgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5wJDEubGVhdmUgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpO1xuICB0aGlzLmNhbGxIb29rKCdiZWZvcmVMZWF2ZScpO1xuICB0aGlzLm9wID0gb3A7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgdGhpcy5sZWZ0ID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2xlYXZlJyk7XG4gIGlmICh0aGlzLmxlZnQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5sZWF2ZUNhbmNlbGxlZDtcbiAgLy8gb25seSBuZWVkIHRvIGhhbmRsZSBsZWF2ZURvbmUgaWZcbiAgLy8gMS4gdGhlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBkb25lIChzeW5jaHJvbm91c2x5IGNhbGxlZFxuICAvLyAgICBieSB0aGUgdXNlciwgd2hpY2ggY2F1c2VzIHRoaXMub3Agc2V0IHRvIG51bGwpXG4gIC8vIDIuIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2tcbiAgaWYgKHRoaXMub3AgJiYgIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICAvLyBpZiBhIENTUyB0cmFuc2l0aW9uIGxlYXZlcyBpbW1lZGlhdGVseSBhZnRlciBlbnRlcixcbiAgICAvLyB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBuZXZlciBmaXJlcy4gdGhlcmVmb3JlIHdlXG4gICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGVuZCB0aGUgbGVhdmUgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHRoaXMuanVzdEVudGVyZWQpIHtcbiAgICAgIHRoaXMubGVhdmVEb25lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hKb2IodGhpcy5sZWF2ZU5leHRUaWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwibmV4dFRpY2tcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcyk7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmxlYXZlRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZWZ0ID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgdGhpcy5vcCgpO1xuICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmNhbGxIb29rKCdhZnRlckxlYXZlJyk7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKCk7XG4gIHRoaXMub3AgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYW55IHBlbmRpbmcgY2FsbGJhY2tzIGZyb20gYSBwcmV2aW91c2x5IHJ1bm5pbmdcbiAqIGJ1dCBub3QgZmluaXNoZWQgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB2YXIgaGFzUGVuZGluZyA9IGZhbHNlO1xuICBpZiAodGhpcy5wZW5kaW5nQ3NzQ2IpIHtcbiAgICBoYXNQZW5kaW5nID0gdHJ1ZTtcbiAgICBvZmYodGhpcy5lbCwgdGhpcy5wZW5kaW5nQ3NzRXZlbnQsIHRoaXMucGVuZGluZ0Nzc0NiKTtcbiAgICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMucGVuZGluZ0pzQ2IuY2FuY2VsKCk7XG4gICAgdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIH1cbiAgaWYgKGhhc1BlbmRpbmcpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIH1cbiAgaWYgKHRoaXMuY2FuY2VsKSB7XG4gICAgdGhpcy5jYW5jZWwuY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICB0aGlzLmNhbmNlbCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQgc3luY2hyb25vdXMgaG9vayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5cbnAkMS5jYWxsSG9vayA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdHlwZV0pIHtcbiAgICB0aGlzLmhvb2tzW3R5cGVdLmNhbGwodGhpcy52bSwgdGhpcy5lbCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gKiBXZSBjaGVjayBmb3IgdGhlIGxlbmd0aCBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIHRoZSBob29rXG4gKiBleHBlY3RzIGEgYGRvbmVgIGNhbGxiYWNrLiBJZiB0cnVlLCB0aGUgdHJhbnNpdGlvbidzIGVuZFxuICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAqIG90aGVyd2lzZSwgdGhlIGVuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDU1MgdHJhbnNpdGlvbiBvclxuICogYW5pbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rV2l0aENiID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGhvb2sgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdHlwZV07XG4gIGlmIChob29rKSB7XG4gICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYiA9IGNhbmNlbGxhYmxlKHRoaXNbdHlwZSArICdEb25lJ10pO1xuICAgIH1cbiAgICBob29rLmNhbGwodGhpcy52bSwgdGhpcy5lbCwgdGhpcy5wZW5kaW5nSnNDYik7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyB0cmFuc2l0aW9uIHR5cGUgYmFzZWQgb24gdGhlXG4gKiBjYWxjdWxhdGVkIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxucCQxLmdldENzc1RyYW5zaXRpb25UeXBlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgLy8gc2tpcCBDU1MgdHJhbnNpdGlvbnMgaWYgcGFnZSBpcyBub3QgdmlzaWJsZSAtXG4gIC8vIHRoaXMgc29sdmVzIHRoZSBpc3N1ZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50cyBub3RcbiAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gIC8vIHBhZ2VWaXNpYmlsaXR5IEFQSSBpcyBzdXBwb3J0ZWQgaW4gSUUxMCssIHNhbWUgYXNcbiAgLy8gQ1NTIHRyYW5zaXRpb25zLlxuICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgLy8gZXhwbGljaXQganMtb25seSB0cmFuc2l0aW9uXG4gIHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5jc3MgPT09IGZhbHNlIHx8XG4gIC8vIGVsZW1lbnQgaXMgaGlkZGVuXG4gIGlzSGlkZGVuKHRoaXMuZWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0eXBlID0gdGhpcy50eXBlIHx8IHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV07XG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZTtcbiAgdmFyIGlubGluZVN0eWxlcyA9IHRoaXMuZWwuc3R5bGU7XG4gIHZhciBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpO1xuICB2YXIgdHJhbnNEdXJhdGlvbiA9IGlubGluZVN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdO1xuICBpZiAodHJhbnNEdXJhdGlvbiAmJiB0cmFuc0R1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgdHlwZSA9IFRZUEVfVFJBTlNJVElPTjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5pbUR1cmF0aW9uID0gaW5saW5lU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdO1xuICAgIGlmIChhbmltRHVyYXRpb24gJiYgYW5pbUR1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgICB0eXBlID0gVFlQRV9BTklNQVRJT047XG4gICAgfVxuICB9XG4gIGlmICh0eXBlKSB7XG4gICAgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXSA9IHR5cGU7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIFNldHVwIGEgQ1NTIHRyYW5zaXRpb25lbmQvYW5pbWF0aW9uZW5kIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5wJDEuc2V0dXBDc3NDYiA9IGZ1bmN0aW9uIChldmVudCwgY2IpIHtcbiAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSBldmVudDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWwgPSB0aGlzLmVsO1xuICB2YXIgb25FbmQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgb2ZmKGVsLCBldmVudCwgb25FbmQpO1xuICAgICAgc2VsZi5wZW5kaW5nQ3NzRXZlbnQgPSBzZWxmLnBlbmRpbmdDc3NDYiA9IG51bGw7XG4gICAgICBpZiAoIXNlbGYucGVuZGluZ0pzQ2IgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIG9uKGVsLCBldmVudCwgb25FbmQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGhpZGRlbiAtIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdFxuICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlkZGVuKGVsKSB7XG4gIGlmICgvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgLy8gU1ZHIGVsZW1lbnRzIGRvIG5vdCBoYXZlIG9mZnNldChXaWR0aHxIZWlnaHQpXG4gICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayB0aGUgY2xpZW50IHJlY3RcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiAhKHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24kMSA9IHtcblxuICBwcmlvcml0eTogVFJBTlNJVElPTixcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShpZCwgb2xkSWQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3RyYW5zaXRpb25zJywgaWQpO1xuICAgIGlkID0gaWQgfHwgJ3YnO1xuICAgIG9sZElkID0gb2xkSWQgfHwgJ3YnO1xuICAgIGVsLl9fdl90cmFucyA9IG5ldyBUcmFuc2l0aW9uKGVsLCBpZCwgaG9va3MsIHRoaXMudm0pO1xuICAgIHJlbW92ZUNsYXNzKGVsLCBvbGRJZCArICctdHJhbnNpdGlvbicpO1xuICAgIGFkZENsYXNzKGVsLCBpZCArICctdHJhbnNpdGlvbicpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0ge1xuICBzdHlsZTogc3R5bGUsXG4gICdjbGFzcyc6IHZDbGFzcyxcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIHByb3A6IHByb3BEZWYsXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb24kMVxufTtcblxuLy8gc3BlY2lhbCBiaW5kaW5nIHByZWZpeGVzXG52YXIgYmluZFJFID0gL152LWJpbmQ6fF46LztcbnZhciBvblJFID0gL152LW9uOnxeQC87XG52YXIgZGlyQXR0clJFID0gL152LShbXjpdKykoPzokfDooLiopJCkvO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nO1xudmFyIHRyYW5zaXRpb25SRSA9IC9eKHYtYmluZDp8Oik/dHJhbnNpdGlvbiQvO1xuXG4vLyBkZWZhdWx0IGRpcmVjdGl2ZSBwcmlvcml0eVxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xudmFyIERFRkFVTFRfVEVSTUlOQUxfUFJJT1JJVFkgPSAyMDAwO1xuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgcmV1c2FibGUgY29tcG9zaXRlIGxpbmtcbiAqIGZ1bmN0aW9uLCB3aGljaCByZWN1cnNpdmVseSBjb250YWlucyBtb3JlIGxpbmsgZnVuY3Rpb25zXG4gKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAqIGJlIGNhbGxlZCBvbiBpbnN0YW5jZSByb290IG5vZGVzLCBidXQgY2FuIGFsc28gYmUgdXNlZFxuICogZm9yIHBhcnRpYWwgY29tcGlsYXRpb24gaWYgdGhlIHBhcnRpYWwgYXJndW1lbnQgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY29tcG9zaXRlIGxpbmsgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsXG4gKiByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzXG4gKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcnRpYWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUoZWwsIG9wdGlvbnMsIHBhcnRpYWwpIHtcbiAgLy8gbGluayBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgaXRzZWxmLlxuICB2YXIgbm9kZUxpbmtGbiA9IHBhcnRpYWwgfHwgIW9wdGlvbnMuX2FzQ29tcG9uZW50ID8gY29tcGlsZU5vZGUoZWwsIG9wdGlvbnMpIDogbnVsbDtcbiAgLy8gbGluayBmdW5jdGlvbiBmb3IgdGhlIGNoaWxkTm9kZXNcbiAgdmFyIGNoaWxkTGlua0ZuID0gIShub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwpICYmICFpc1NjcmlwdChlbCkgJiYgZWwuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KGVsLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcblxuICAvKipcbiAgICogQSBjb21wb3NpdGUgbGlua2VyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhIGFscmVhZHlcbiAgICogY29tcGlsZWQgcGllY2Ugb2YgRE9NLCB3aGljaCBpbnN0YW50aWF0ZXMgYWxsIGRpcmVjdGl2ZVxuICAgKiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIGhvc3Qgdm0gb2YgdHJhbnNjbHVkZWQgY29udGVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIGxpbmsgY29udGV4dCBmcmFnbWVudFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21wb3NpdGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShlbC5jaGlsZE5vZGVzKTtcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIoKSB7XG4gICAgICBpZiAobm9kZUxpbmtGbikgbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9LCB2bSk7XG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgZGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQXBwbHkgYSBsaW5rZXIgdG8gYSB2bS9lbGVtZW50IHBhaXIgYW5kIGNhcHR1cmUgdGhlXG4gKiBkaXJlY3RpdmVzIGNyZWF0ZWQgZHVyaW5nIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gbGlua0FuZENhcHR1cmUobGlua2VyLCB2bSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyByZXNldCBkaXJlY3RpdmVzIGJlZm9yZSBldmVyeSBjYXB0dXJlIGluIHByb2R1Y3Rpb25cbiAgICAvLyBtb2RlLCBzbyB0aGF0IHdoZW4gdW5saW5raW5nIHdlIGRvbid0IG5lZWQgdG8gc3BsaWNlXG4gICAgLy8gdGhlbSBvdXQgKHdoaWNoIHR1cm5zIG91dCB0byBiZSBhIHBlcmYgaGl0KS5cbiAgICAvLyB0aGV5IGFyZSBrZXB0IGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSB0aGV5IGFyZVxuICAgIC8vIHVzZWZ1bCBmb3IgVnVlJ3Mgb3duIHRlc3RzLlxuICAgIHZtLl9kaXJlY3RpdmVzID0gW107XG4gIH1cbiAgdmFyIG9yaWdpbmFsRGlyQ291bnQgPSB2bS5fZGlyZWN0aXZlcy5sZW5ndGg7XG4gIGxpbmtlcigpO1xuICB2YXIgZGlycyA9IHZtLl9kaXJlY3RpdmVzLnNsaWNlKG9yaWdpbmFsRGlyQ291bnQpO1xuICBkaXJzLnNvcnQoZGlyZWN0aXZlQ29tcGFyYXRvcik7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXJzW2ldLl9iaW5kKCk7XG4gIH1cbiAgcmV0dXJuIGRpcnM7XG59XG5cbi8qKlxuICogRGlyZWN0aXZlIHByaW9yaXR5IHNvcnQgY29tcGFyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICovXG5cbmZ1bmN0aW9uIGRpcmVjdGl2ZUNvbXBhcmF0b3IoYSwgYikge1xuICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICBiID0gYi5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cblxuLyoqXG4gKiBMaW5rZXIgZnVuY3Rpb25zIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdFxuICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gKiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICogaW5mb3JtYXRpb24gdG8gYXZvaWQgcmV0YWluaW5nIGFkZGl0aW9uYWwgY2xvc3VyZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge1Z1ZX0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVW5saW5rRm4odm0sIGRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKSB7XG4gIGZ1bmN0aW9uIHVubGluayhkZXN0cm95aW5nKSB7XG4gICAgdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0RGlycykge1xuICAgICAgdGVhcmRvd25EaXJzKGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIGxpbmtlZCBkaXJlY3RpdmVzXG4gIHVubGluay5kaXJzID0gZGlycztcbiAgcmV0dXJuIHVubGluaztcbn1cblxuLyoqXG4gKiBUZWFyZG93biBwYXJ0aWFsIGxpbmtlZCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtBcnJheX0gZGlyc1xuICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95aW5nXG4gKi9cblxuZnVuY3Rpb24gdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKSB7XG4gIHZhciBpID0gZGlycy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBkaXJzW2ldLl90ZWFyZG93bigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFkZXN0cm95aW5nKSB7XG4gICAgICB2bS5fZGlyZWN0aXZlcy4kcmVtb3ZlKGRpcnNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRMaW5rUHJvcHModm0sIGVsLCBwcm9wcywgc2NvcGUpIHtcbiAgdmFyIHByb3BzTGlua0ZuID0gY29tcGlsZVByb3BzKGVsLCBwcm9wcywgdm0pO1xuICB2YXIgcHJvcERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHNMaW5rRm4odm0sIHNjb3BlKTtcbiAgfSwgdm0pO1xuICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBwcm9wRGlycyk7XG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgcm9vdCBlbGVtZW50IG9mIGFuIGluc3RhbmNlLlxuICpcbiAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICogMi4gYXR0cnMgb24gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSByb290IG5vZGUsIGlmXG4gKiAgICByZXBsYWNlOnRydWUgKGNoaWxkIHNjb3BlKVxuICpcbiAqIElmIHRoaXMgaXMgYSBmcmFnbWVudCBpbnN0YW5jZSwgd2Ugb25seSBuZWVkIHRvIGNvbXBpbGUgMS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fY29udGFpbmVyQXR0cnM7XG4gIHZhciByZXBsYWNlckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycztcbiAgdmFyIGNvbnRleHRMaW5rRm4sIHJlcGxhY2VyTGlua0ZuO1xuXG4gIC8vIG9ubHkgbmVlZCB0byBjb21waWxlIG90aGVyIGF0dHJpYnV0ZXMgZm9yXG4gIC8vIG5vbi1mcmFnbWVudCBpbnN0YW5jZXNcbiAgaWYgKGVsLm5vZGVUeXBlICE9PSAxMSkge1xuICAgIC8vIGZvciBjb21wb25lbnRzLCBjb250YWluZXIgYW5kIHJlcGxhY2VyIG5lZWQgdG8gYmVcbiAgICAvLyBjb21waWxlZCBzZXBhcmF0ZWx5IGFuZCBsaW5rZWQgaW4gZGlmZmVyZW50IHNjb3Blcy5cbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQpIHtcbiAgICAgIC8vIDIuIGNvbnRhaW5lciBhdHRyaWJ1dGVzXG4gICAgICBpZiAoY29udGFpbmVyQXR0cnMgJiYgY29udGV4dE9wdGlvbnMpIHtcbiAgICAgICAgY29udGV4dExpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGNvbnRhaW5lckF0dHJzLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXJBdHRycykge1xuICAgICAgICAvLyAzLiByZXBsYWNlciBhdHRyaWJ1dGVzXG4gICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vbi1jb21wb25lbnQsIGp1c3QgY29tcGlsZSBhcyBhIG5vcm1hbCBlbGVtZW50LlxuICAgICAgcmVwbGFjZXJMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb250YWluZXJBdHRycykge1xuICAgIC8vIHdhcm4gY29udGFpbmVyIGRpcmVjdGl2ZXMgZm9yIGZyYWdtZW50IGluc3RhbmNlc1xuICAgIHZhciBuYW1lcyA9IGNvbnRhaW5lckF0dHJzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikge1xuICAgICAgLy8gYWxsb3cgdnVlLWxvYWRlci92dWVpZnkgc2NvcGVkIGNzcyBhdHRyaWJ1dGVzXG4gICAgICByZXR1cm4gYXR0ci5uYW1lLmluZGV4T2YoJ192LScpIDwgMCAmJlxuICAgICAgLy8gYWxsb3cgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAhb25SRS50ZXN0KGF0dHIubmFtZSkgJiZcbiAgICAgIC8vIGFsbG93IHNsb3RzXG4gICAgICBhdHRyLm5hbWUgIT09ICdzbG90JztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiAnXCInICsgYXR0ci5uYW1lICsgJ1wiJztcbiAgICB9KTtcbiAgICBpZiAobmFtZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgcGx1cmFsID0gbmFtZXMubGVuZ3RoID4gMTtcbiAgICAgIHdhcm4oJ0F0dHJpYnV0ZScgKyAocGx1cmFsID8gJ3MgJyA6ICcgJykgKyBuYW1lcy5qb2luKCcsICcpICsgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArICc8JyArIG9wdGlvbnMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4gYmVjYXVzZSAnICsgJ3RoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudCBpbnN0YW5jZTogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudC1JbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiByb290TGlua0ZuKHZtLCBlbCwgc2NvcGUpIHtcbiAgICAvLyBsaW5rIGNvbnRleHQgc2NvcGUgZGlyc1xuICAgIHZhciBjb250ZXh0ID0gdm0uX2NvbnRleHQ7XG4gICAgdmFyIGNvbnRleHREaXJzO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHRMaW5rRm4pIHtcbiAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0TGlua0ZuKGNvbnRleHQsIGVsLCBudWxsLCBzY29wZSk7XG4gICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBsaW5rIHNlbGZcbiAgICB2YXIgc2VsZkRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVwbGFjZXJMaW5rRm4pIHJlcGxhY2VyTGlua0ZuKHZtLCBlbCk7XG4gICAgfSwgdm0pO1xuXG4gICAgLy8gcmV0dXJuIHRoZSB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gY29udGV4dFxuICAgIC8vIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHNlbGZEaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4gYmFzZWQgb24gdGhlXG4gKiBub2RlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgaWYgKHR5cGUgPT09IDEgJiYgIWlzU2NyaXB0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVFbGVtZW50KG5vZGUsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgIHJldHVybiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGFuIGVsZW1lbnQgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUVsZW1lbnQoZWwsIG9wdGlvbnMpIHtcbiAgLy8gcHJlcHJvY2VzcyB0ZXh0YXJlYXMuXG4gIC8vIHRleHRhcmVhIHRyZWF0cyBpdHMgdGV4dCBjb250ZW50IGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAvLyBqdXN0IGJpbmQgaXQgYXMgYW4gYXR0ciBkaXJlY3RpdmUgZm9yIHZhbHVlLlxuICBpZiAoZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQoZWwudmFsdWUpO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnOnZhbHVlJywgdG9rZW5zVG9FeHAodG9rZW5zKSk7XG4gICAgICBlbC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgfVxuICB2YXIgbGlua0ZuO1xuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gIHZhciBhdHRycyA9IGhhc0F0dHJzICYmIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIC8vIGNoZWNrIHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGZvciAmIGlmKVxuICBpZiAoaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgYXR0cnMsIG9wdGlvbnMpO1xuICB9XG4gIC8vIGNoZWNrIGVsZW1lbnQgZGlyZWN0aXZlc1xuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIGNoZWNrIGNvbXBvbmVudFxuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICBpZiAoIWxpbmtGbiAmJiBoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbGlua0ZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZXh0Tm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGV4dE5vZGVMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucykge1xuICAvLyBza2lwIG1hcmtlZCB0ZXh0IG5vZGVzXG4gIGlmIChub2RlLl9za2lwKSB7XG4gICAgcmV0dXJuIHJlbW92ZVRleHQ7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KG5vZGUud2hvbGVUZXh0KTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG1hcmsgYWRqYWNlbnQgdGV4dCBub2RlcyBhcyBza2lwcGVkLFxuICAvLyBiZWNhdXNlIHdlIGFyZSB1c2luZyBub2RlLndob2xlVGV4dCB0byBjb21waWxlXG4gIC8vIGFsbCBhZGphY2VudCB0ZXh0IG5vZGVzIHRvZ2V0aGVyLiBUaGlzIGZpeGVzXG4gIC8vIGlzc3VlcyBpbiBJRSB3aGVyZSBzb21ldGltZXMgaXQgc3BsaXRzIHVwIGEgc2luZ2xlXG4gIC8vIHRleHQgbm9kZSBpbnRvIG11bHRpcGxlIG9uZXMuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PT0gMykge1xuICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBlbCwgdG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGVsID0gdG9rZW4udGFnID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIExpbmtlciBmb3IgYW4gc2tpcHBlZCB0ZXh0IG5vZGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVUZXh0KHZtLCBub2RlKSB7XG4gIHJlbW92ZShub2RlKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSB7XG4gIHZhciBlbDtcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd2LWh0bWwnKTtcbiAgICAgIHNldFRva2VuVHlwZSgnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ3RleHQnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0VG9rZW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodG9rZW4uZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh0b2tlbi52YWx1ZSk7XG4gICAgdG9rZW4uZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBkZWY6IGRpcmVjdGl2ZXNbdHlwZV0sXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHRleHROb2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdG9rZW5zXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlKSB7XG4gICAgdmFyIGZyYWdDbG9uZSA9IGZyYWcuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShmcmFnQ2xvbmUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIHRva2VuLCB2YWx1ZSwgbm9kZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGlmICh0b2tlbi50YWcpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgICAgICAgcmVwbGFjZShub2RlLCBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZtLl9iaW5kRGlyKHRva2VuLmRlc2NyaXB0b3IsIG5vZGUsIGhvc3QsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGVsLCBmcmFnQ2xvbmUpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdChub2RlTGlzdCwgb3B0aW9ucykge1xuICB2YXIgbGlua0ZucyA9IFtdO1xuICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgIG5vZGVMaW5rRm4gPSBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKTtcbiAgICBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiBub2RlLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmIG5vZGUuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuICAgIGxpbmtGbnMucHVzaChub2RlTGlua0ZuLCBjaGlsZExpbmtGbik7XG4gIH1cbiAgcmV0dXJuIGxpbmtGbnMubGVuZ3RoID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2hpbGQgbGluayBmdW5jdGlvbiBmb3IgYSBub2RlJ3MgY2hpbGROb2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gbGlua0Zuc1xuICogQHJldHVybiB7RnVuY3Rpb259IGNoaWxkTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoaWxkTGlua0ZuKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2YXIgbm9kZSwgbm9kZUxpbmtGbiwgY2hpbGRyZW5MaW5rRm47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSAwLCBsID0gbGlua0Zucy5sZW5ndGg7IGkgPCBsOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgIG5vZGVMaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICBjaGlsZHJlbkxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRyZW5MaW5rRm4pIHtcbiAgICAgICAgY2hpbGRyZW5MaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gKiBiZSByZXNvdmxlZCBhcyB0ZXJtaW5hbCBkaXJlY3RpdmVzKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGNvbW1vblRhZ1JFLnRlc3QodGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZyk7XG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQuIElmIHllcywgcmV0dXJuXG4gKiBhIGNvbXBvbmVudCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucyk7XG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgcmVmID0gZmluZFJlZihlbCk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiAnY29tcG9uZW50JyxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudExpbmtGbiA9IGZ1bmN0aW9uIGNvbXBvbmVudExpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIHJlZiwgbnVsbCk7XG4gICAgICB9XG4gICAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH07XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgICByZXR1cm4gY29tcG9uZW50TGlua0ZuO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYW4gZWxlbWVudCBmb3IgdGVybWluYWwgZGlyZWN0aXZlcyBpbiBmaXhlZCBvcmRlci5cbiAqIElmIGl0IGZpbmRzIG9uZSwgcmV0dXJuIGEgdGVybWluYWwgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5fSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBhdHRycywgb3B0aW9ucykge1xuICAvLyBza2lwIHYtcHJlXG4gIGlmIChnZXRBdHRyKGVsLCAndi1wcmUnKSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBza2lwO1xuICB9XG4gIC8vIHNraXAgdi1lbHNlIGJsb2NrLCBidXQgb25seSBpZiBmb2xsb3dpbmcgdi1pZlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd2LWVsc2UnKSkge1xuICAgIHZhciBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBpZiAocHJldiAmJiBwcmV2Lmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICByZXR1cm4gc2tpcDtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgbWF0Y2hlZCwgZGlyTmFtZSwgcmF3TmFtZSwgYXJnLCBkZWYsIHRlcm1EZWY7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gYXR0cnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIG5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgaWYgKG1hdGNoZWQgPSBuYW1lLm1hdGNoKGRpckF0dHJSRSkpIHtcbiAgICAgIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIG1hdGNoZWRbMV0pO1xuICAgICAgaWYgKGRlZiAmJiBkZWYudGVybWluYWwpIHtcbiAgICAgICAgaWYgKCF0ZXJtRGVmIHx8IChkZWYucHJpb3JpdHkgfHwgREVGQVVMVF9URVJNSU5BTF9QUklPUklUWSkgPiB0ZXJtRGVmLnByaW9yaXR5KSB7XG4gICAgICAgICAgdGVybURlZiA9IGRlZjtcbiAgICAgICAgICByYXdOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKGF0dHIubmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgIGFyZyA9IG1hdGNoZWRbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGVybURlZikge1xuICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgdGVybURlZiwgcmF3TmFtZSwgYXJnLCBtb2RpZmllcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNraXAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWU7XG5cbi8qKlxuICogQnVpbGQgYSBub2RlIGxpbmsgZnVuY3Rpb24gZm9yIGEgdGVybWluYWwgZGlyZWN0aXZlLlxuICogQSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgdGhlIGN1cnJlbnRcbiAqIGNvbXBpbGF0aW9uIHJlY3Vyc2lvbiBhbmQgaGFuZGxlcyBjb21waWxhdGlvbiBvZiB0aGVcbiAqIHN1YnRyZWUgaW4gdGhlIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGRlZlxuICogQHBhcmFtIHtTdHJpbmd9IFtyYXdOYW1lXVxuICogQHBhcmFtIHtTdHJpbmd9IFthcmddXG4gKiBAcGFyYW0ge09iamVjdH0gW21vZGlmaWVyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCBkZWYsIHJhd05hbWUsIGFyZywgbW9kaWZpZXJzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgYXJnOiBhcmcsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICBhdHRyOiByYXdOYW1lLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgIGRlZjogZGVmXG4gIH07XG4gIC8vIGNoZWNrIHJlZiBmb3Igdi1mb3IgYW5kIHJvdXRlci12aWV3XG4gIGlmIChkaXJOYW1lID09PSAnZm9yJyB8fCBkaXJOYW1lID09PSAncm91dGVyLXZpZXcnKSB7XG4gICAgZGVzY3JpcHRvci5yZWYgPSBmaW5kUmVmKGVsKTtcbiAgfVxuICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIGlmIChkZXNjcmlwdG9yLnJlZikge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoKHNjb3BlIHx8IHZtKS4kcmVmcywgZGVzY3JpcHRvci5yZWYsIG51bGwpO1xuICAgIH1cbiAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICB9O1xuICBmbi50ZXJtaW5hbCA9IHRydWU7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSBkaXJlY3RpdmVzIG9uIGFuIGVsZW1lbnQgYW5kIHJldHVybiBhIGxpbmtlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE5hbWVkTm9kZU1hcH0gYXR0cnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRGlyZWN0aXZlcyhhdHRycywgb3B0aW9ucykge1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIGRpcnMgPSBbXTtcbiAgdmFyIGF0dHIsIG5hbWUsIHZhbHVlLCByYXdOYW1lLCByYXdWYWx1ZSwgZGlyTmFtZSwgYXJnLCBtb2RpZmllcnMsIGRpckRlZiwgdG9rZW5zLCBtYXRjaGVkO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIG5hbWUgPSByYXdOYW1lID0gYXR0ci5uYW1lO1xuICAgIHZhbHVlID0gcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIHRva2VucyA9IHBhcnNlVGV4dCh2YWx1ZSk7XG4gICAgLy8gcmVzZXQgYXJnXG4gICAgYXJnID0gbnVsbDtcbiAgICAvLyBjaGVjayBtb2RpZmllcnNcbiAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcblxuICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHZhbHVlID0gdG9rZW5zVG9FeHAodG9rZW5zKTtcbiAgICAgIGFyZyA9IG5hbWU7XG4gICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kLCB0b2tlbnMpO1xuICAgICAgLy8gd2FybiBhZ2FpbnN0IG1peGluZyBtdXN0YWNoZXMgd2l0aCB2LWJpbmRcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnY2xhc3MnICYmIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIubmFtZSA9PT0gJzpjbGFzcycgfHwgYXR0ci5uYW1lID09PSAndi1iaW5kOmNsYXNzJztcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3YXJuKCdjbGFzcz1cIicgKyByYXdWYWx1ZSArICdcIjogRG8gbm90IG1peCBtdXN0YWNoZSBpbnRlcnBvbGF0aW9uICcgKyAnYW5kIHYtYmluZCBmb3IgXCJjbGFzc1wiIG9uIHRoZSBzYW1lIGVsZW1lbnQuIFVzZSBvbmUgb3IgdGhlIG90aGVyLicsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlXG5cbiAgICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlOiB0cmFuc2l0aW9uXG4gICAgICBpZiAodHJhbnNpdGlvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbW9kaWZpZXJzLmxpdGVyYWwgPSAhYmluZFJFLnRlc3QobmFtZSk7XG4gICAgICAgIHB1c2hEaXIoJ3RyYW5zaXRpb24nLCBpbnRlcm5hbERpcmVjdGl2ZXMudHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2VcblxuICAgICAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgYXJnID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgICBwdXNoRGlyKCdvbicsIGRpcmVjdGl2ZXMub24pO1xuICAgICAgICB9IGVsc2VcblxuICAgICAgICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICAgICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnc3R5bGUnIHx8IGRpck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBpbnRlcm5hbERpcmVjdGl2ZXNbZGlyTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJnID0gZGlyTmFtZTtcbiAgICAgICAgICAgICAgcHVzaERpcignYmluZCcsIGRpcmVjdGl2ZXMuYmluZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgICAgICAgICBkaXJOYW1lID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgICAgYXJnID0gbWF0Y2hlZFsyXTtcblxuICAgICAgICAgICAgICAvLyBza2lwIHYtZWxzZSAod2hlbiB1c2VkIHdpdGggdi1zaG93KVxuICAgICAgICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaXJEZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXJOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICAgICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgZGlyRGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBkaXJlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBkZWZcbiAgICogQHBhcmFtIHtBcnJheX0gW2ludGVycFRva2Vuc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcHVzaERpcihkaXJOYW1lLCBkZWYsIGludGVycFRva2Vucykge1xuICAgIHZhciBoYXNPbmVUaW1lVG9rZW4gPSBpbnRlcnBUb2tlbnMgJiYgaGFzT25lVGltZShpbnRlcnBUb2tlbnMpO1xuICAgIHZhciBwYXJzZWQgPSAhaGFzT25lVGltZVRva2VuICYmIHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICBkaXJzLnB1c2goe1xuICAgICAgbmFtZTogZGlyTmFtZSxcbiAgICAgIGF0dHI6IHJhd05hbWUsXG4gICAgICByYXc6IHJhd1ZhbHVlLFxuICAgICAgZGVmOiBkZWYsXG4gICAgICBhcmc6IGFyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgLy8gY29udmVyc2lvbiBmcm9tIGludGVycG9sYXRpb24gc3RyaW5ncyB3aXRoIG9uZS10aW1lIHRva2VuXG4gICAgICAvLyB0byBleHByZXNzaW9uIGlzIGRpZmZlcmVkIHVudGlsIGRpcmVjdGl2ZSBiaW5kIHRpbWUgc28gdGhhdCB3ZVxuICAgICAgLy8gaGF2ZSBhY2Nlc3MgdG8gdGhlIGFjdHVhbCB2bSBjb250ZXh0IGZvciBvbmUtdGltZSBiaW5kaW5ncy5cbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZCAmJiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZCAmJiBwYXJzZWQuZmlsdGVycyxcbiAgICAgIGludGVycDogaW50ZXJwVG9rZW5zLFxuICAgICAgaGFzT25lVGltZTogaGFzT25lVGltZVRva2VuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGlycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVMaW5rRm4oZGlycyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyhuYW1lKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZXNbbWF0Y2hbaV0uc2xpY2UoMSldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGxpbmsgZnVuY3Rpb24gZm9yIGFsbCBkaXJlY3RpdmVzIG9uIGEgc2luZ2xlIG5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlyZWN0aXZlc1xuICogQHJldHVybiB7RnVuY3Rpb259IGRpcmVjdGl2ZXNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTm9kZUxpbmtGbihkaXJlY3RpdmVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAvLyByZXZlcnNlIGFwcGx5IGJlY2F1c2UgaXQncyBzb3J0ZWQgbG93IHRvIGhpZ2hcbiAgICB2YXIgaSA9IGRpcmVjdGl2ZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGludGVycG9sYXRpb24gc3RyaW5nIGNvbnRhaW5zIG9uZS10aW1lIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT25lVGltZSh0b2tlbnMpIHtcbiAgdmFyIGkgPSB0b2tlbnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHRva2Vuc1tpXS5vbmVUaW1lKSByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NjcmlwdChlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZSA9PT0gJ1NDUklQVCcgJiYgKCFlbC5oYXNBdHRyaWJ1dGUoJ3R5cGUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpO1xufVxuXG52YXIgc3BlY2lhbENoYXJSRSA9IC9bXlxcd1xcLTpcXC5dLztcblxuLyoqXG4gKiBQcm9jZXNzIGFuIGVsZW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IGJhc2VkIG9uIGFcbiAqIGluc3RhbmNlIG9wdGlvbiBvYmplY3QuIFRoaXMgYWxsb3dzIHVzIHRvIHRyYW5zY2x1ZGVcbiAqIGEgdGVtcGxhdGUgbm9kZS9mcmFnbWVudCBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQsXG4gKiBzbyB0aGUgcHJvY2Vzc2VkIGZyYWdtZW50IGNhbiB0aGVuIGJlIGNsb25lZCBhbmQgcmV1c2VkXG4gKiBpbiB2LWZvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zY2x1ZGUoZWwsIG9wdGlvbnMpIHtcbiAgLy8gZXh0cmFjdCBjb250YWluZXIgYXR0cmlidXRlcyB0byBwYXNzIHRoZW0gZG93blxuICAvLyB0byBjb21waWxlciwgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgY29tcGlsZWQgaW5cbiAgLy8gcGFyZW50IHNjb3BlLiB3ZSBhcmUgbXV0YXRpbmcgdGhlIG9wdGlvbnMgb2JqZWN0IGhlcmVcbiAgLy8gYXNzdW1pbmcgdGhlIHNhbWUgb2JqZWN0IHdpbGwgYmUgdXNlZCBmb3IgY29tcGlsZVxuICAvLyByaWdodCBhZnRlciB0aGlzLlxuICBpZiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gZXh0cmFjdEF0dHJzKGVsKTtcbiAgfVxuICAvLyBmb3IgdGVtcGxhdGUgdGFncywgd2hhdCB3ZSB3YW50IGlzIGl0cyBjb250ZW50IGFzXG4gIC8vIGEgZG9jdW1lbnRGcmFnbWVudCAoZm9yIGZyYWdtZW50IGluc3RhbmNlcylcbiAgaWYgKGlzVGVtcGxhdGUoZWwpKSB7XG4gICAgZWwgPSBwYXJzZVRlbXBsYXRlKGVsKTtcbiAgfVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCAmJiAhb3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy50ZW1wbGF0ZSA9ICc8c2xvdD48L3Nsb3Q+JztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMuX2NvbnRlbnQgPSBleHRyYWN0Q29udGVudChlbCk7XG4gICAgICBlbCA9IHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgIC8vIGFuY2hvcnMgZm9yIGZyYWdtZW50IGluc3RhbmNlXG4gICAgLy8gcGFzc2luZyBpbiBgcGVyc2lzdDogdHJ1ZWAgdG8gYXZvaWQgdGhlbSBiZWluZ1xuICAgIC8vIGRpc2NhcmRlZCBieSBJRSBkdXJpbmcgdGVtcGxhdGUgY2xvbmluZ1xuICAgIHByZXBlbmQoY3JlYXRlQW5jaG9yKCd2LXN0YXJ0JywgdHJ1ZSksIGVsKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjcmVhdGVBbmNob3IoJ3YtZW5kJywgdHJ1ZSkpO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24uXG4gKiBJZiB0aGUgcmVwbGFjZSBvcHRpb24gaXMgdHJ1ZSB0aGlzIHdpbGwgc3dhcCB0aGUgJGVsLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSk7XG4gIGlmIChmcmFnKSB7XG4gICAgdmFyIHJlcGxhY2VyID0gZnJhZy5maXJzdENoaWxkO1xuICAgIHZhciB0YWcgPSByZXBsYWNlci50YWdOYW1lICYmIHJlcGxhY2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1lvdSBhcmUgbW91bnRpbmcgYW4gaW5zdGFuY2Ugd2l0aCBhIHRlbXBsYXRlIHRvICcgKyAnPGJvZHk+LiBUaGlzIHdpbGwgcmVwbGFjZSA8Ym9keT4gZW50aXJlbHkuIFlvdSAnICsgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLicpO1xuICAgICAgfVxuICAgICAgLy8gdGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgdGhlIGluc3RhbmNlIG11c3RcbiAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgLy8gY2FuIGNyZWF0ZSBtb3JlIHRoYW4gMSByb290IG5vZGVzLlxuICAgICAgaWYgKFxuICAgICAgLy8gbXVsdGktY2hpbGRyZW4gdGVtcGxhdGVcbiAgICAgIGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPiAxIHx8XG4gICAgICAvLyBub24tZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgcmVwbGFjZXIubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgIC8vIHNpbmdsZSBuZXN0ZWQgY29tcG9uZW50XG4gICAgICB0YWcgPT09ICdjb21wb25lbnQnIHx8IHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykgfHwgaGFzQmluZEF0dHIocmVwbGFjZXIsICdpcycpIHx8XG4gICAgICAvLyBlbGVtZW50IGRpcmVjdGl2ZVxuICAgICAgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZykgfHxcbiAgICAgIC8vIGZvciBibG9ja1xuICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWZvcicpIHx8XG4gICAgICAvLyBpZiBibG9ja1xuICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gZXh0cmFjdEF0dHJzKHJlcGxhY2VyKTtcbiAgICAgICAgbWVyZ2VBdHRycyhlbCwgcmVwbGFjZXIpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiAnICsgdGVtcGxhdGUpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGV4dHJhY3QgYSBjb21wb25lbnQgY29udGFpbmVyJ3MgYXR0cmlidXRlc1xuICogaW50byBhIHBsYWluIG9iamVjdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0QXR0cnMoZWwpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGVsLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHJldHVybiB0b0FycmF5KGVsLmF0dHJpYnV0ZXMpO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgb2YgdHdvIGVsZW1lbnRzLCBhbmQgbWFrZSBzdXJlXG4gKiB0aGUgY2xhc3MgbmFtZXMgYXJlIG1lcmdlZCBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21cbiAqIEBwYXJhbSB7RWxlbWVudH0gdG9cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUF0dHJzKGZyb20sIHRvKSB7XG4gIHZhciBhdHRycyA9IGZyb20uYXR0cmlidXRlcztcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gIHZhciBuYW1lLCB2YWx1ZTtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWU7XG4gICAgaWYgKCF0by5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgIXNwZWNpYWxDaGFyUkUudGVzdChuYW1lKSkge1xuICAgICAgdG8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIXBhcnNlVGV4dCh2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUudHJpbSgpKSkge1xuICAgICAgdmFsdWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgYWRkQ2xhc3ModG8sIGNscyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTY2FuIGFuZCBkZXRlcm1pbmUgc2xvdCBjb250ZW50IGRpc3RyaWJ1dGlvbi5cbiAqIFdlIGRvIHRoaXMgZHVyaW5nIHRyYW5zY2x1c2lvbiBpbnN0ZWFkIGF0IGNvbXBpbGUgdGltZSBzbyB0aGF0XG4gKiB0aGUgZGlzdHJpYnV0aW9uIGlzIGRlY291cGxlZCBmcm9tIHRoZSBjb21waWxhdGlvbiBvcmRlciBvZlxuICogdGhlIHNsb3RzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZW50XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2xvdHModm0sIGNvbnRlbnQpIHtcbiAgaWYgKCFjb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb250ZW50cyA9IHZtLl9zbG90Q29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgZWwsIG5hbWU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY29udGVudC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlbCA9IGNvbnRlbnQuY2hpbGRyZW5baV07XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpZiAobmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAoY29udGVudHNbbmFtZV0gfHwgKGNvbnRlbnRzW25hbWVdID0gW10pKS5wdXNoKGVsKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldEJpbmRBdHRyKGVsLCAnc2xvdCcpKSB7XG4gICAgICB3YXJuKCdUaGUgXCJzbG90XCIgYXR0cmlidXRlIG11c3QgYmUgc3RhdGljLicsIHZtLiRwYXJlbnQpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gY29udGVudHMpIHtcbiAgICBjb250ZW50c1tuYW1lXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50c1tuYW1lXSwgY29udGVudCk7XG4gIH1cbiAgaWYgKGNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdmFyIG5vZGVzID0gY29udGVudC5jaGlsZE5vZGVzO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0ubm9kZVR5cGUgPT09IDMgJiYgIW5vZGVzWzBdLmRhdGEudHJpbSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnRzWydkZWZhdWx0J10gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudC5jaGlsZE5vZGVzLCBjb250ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcXVhbGlmaWVkIGNvbnRlbnQgbm9kZXMgZnJvbSBhIG5vZGUgbGlzdC5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2Rlc1xuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0RnJhZ21lbnQobm9kZXMsIHBhcmVudCkge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgbm9kZXMgPSB0b0FycmF5KG5vZGVzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChpc1RlbXBsYXRlKG5vZGUpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1pZicpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1mb3InKSkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgbm9kZSA9IHBhcnNlVGVtcGxhdGUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH1cbiAgcmV0dXJuIGZyYWc7XG59XG5cblxuXG52YXIgY29tcGlsZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Y29tcGlsZTogY29tcGlsZSxcblx0Y29tcGlsZUFuZExpbmtQcm9wczogY29tcGlsZUFuZExpbmtQcm9wcyxcblx0Y29tcGlsZVJvb3Q6IGNvbXBpbGVSb290LFxuXHR0cmFuc2NsdWRlOiB0cmFuc2NsdWRlLFxuXHRyZXNvbHZlU2xvdHM6IHJlc29sdmVTbG90c1xufSk7XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogQWNjZXNzb3IgZm9yIGAkZGF0YWAgcHJvcGVydHksIHNpbmNlIHNldHRpbmcgJGRhdGFcbiAgICogcmVxdWlyZXMgb2JzZXJ2aW5nIHRoZSBuZXcgb2JqZWN0IGFuZCB1cGRhdGluZ1xuICAgKiBwcm94aWVkIHByb3BlcnRpZXMuXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcbiAgICAgIGlmIChuZXdEYXRhICE9PSB0aGlzLl9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNjb3BlIG9mIGFuIGluc3RhbmNlLCB3aGljaCBjb250YWluczpcbiAgICogLSBvYnNlcnZlZCBkYXRhXG4gICAqIC0gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgKiAtIHVzZXIgbWV0aG9kc1xuICAgKiAtIG1ldGEgcHJvcGVydGllc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdFByb3BzKCk7XG4gICAgdGhpcy5faW5pdE1ldGEoKTtcbiAgICB0aGlzLl9pbml0TWV0aG9kcygpO1xuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgdGhpcy5faW5pdENvbXB1dGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcHJvcHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgdmFyIGVsID0gb3B0aW9ucy5lbDtcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChwcm9wcyAmJiAhZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArICdwcm92aWRlZCBhdCBpbnN0YW50aWF0aW9uLicsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gY29udmVydCBzdHJpbmcgc2VsZWN0b3JzIGludG8gZWxlbWVudCBub3dcbiAgICBlbCA9IG9wdGlvbnMuZWwgPSBxdWVyeShlbCk7XG4gICAgdGhpcy5fcHJvcHNVbmxpbmtGbiA9IGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIHByb3BzXG4gICAgLy8gcHJvcHMgbXVzdCBiZSBsaW5rZWQgaW4gcHJvcGVyIHNjb3BlIGlmIGluc2lkZSB2LWZvclxuICAgID8gY29tcGlsZUFuZExpbmtQcm9wcyh0aGlzLCBlbCwgcHJvcHMsIHRoaXMuX3Njb3BlKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRhdGEuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGE7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhID0gZGF0YUZuID8gZGF0YUZuKCkgOiB7fTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuJywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBpLCBrZXk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAvLyB0aGVyZSBhcmUgdHdvIHNjZW5hcmlvcyB3aGVyZSB3ZSBjYW4gcHJveHkgYSBkYXRhIGtleTpcbiAgICAgIC8vIDEuIGl0J3Mgbm90IGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3BcbiAgICAgIC8vIDIuIGl0J3MgcHJvdmlkZWQgdmlhIGEgaW5zdGFudGlhdGlvbiBvcHRpb24gQU5EIHRoZXJlIGFyZSBub1xuICAgICAgLy8gICAgdGVtcGxhdGUgcHJvcCBwcmVzZW50XG4gICAgICBpZiAoIXByb3BzIHx8ICFoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdEYXRhIGZpZWxkIFwiJyArIGtleSArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQgJyArICdhcyBhIHByb3AuIFRvIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZSBmb3IgYSBwcm9wLCB1c2UgdGhlIFwiZGVmYXVsdFwiICcgKyAncHJvcCBvcHRpb247IGlmIHlvdSB3YW50IHRvIHBhc3MgcHJvcCB2YWx1ZXMgdG8gYW4gaW5zdGFudGlhdGlvbiAnICsgJ2NhbGwsIHVzZSB0aGUgXCJwcm9wc0RhdGFcIiBvcHRpb24uJywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIGluc3RhbmNlJ3MgJGRhdGEuIENhbGxlZCBpbiAkZGF0YSdzIHNldHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld0RhdGFcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fc2V0RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHRoaXMuX2RhdGEgPSBuZXdEYXRhO1xuICAgIHZhciBrZXlzLCBrZXksIGk7XG4gICAgLy8gdW5wcm94eSBrZXlzIG5vdCBwcmVzZW50IGluIG5ldyBkYXRhXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKG9sZERhdGEpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICAgIHRoaXMuX3VucHJveHkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuICAgIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZSBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobmV3RGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIWhhc093bih0aGlzLCBrZXkpKSB7XG4gICAgICAgIC8vIG5ldyBwcm9wZXJ0eVxuICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbGREYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICBvYnNlcnZlKG5ld0RhdGEsIHRoaXMpO1xuICAgIHRoaXMuX2RpZ2VzdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhIHByb3BlcnR5LCBzbyB0aGF0XG4gICAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgLy8gbmVlZCB0byBzdG9yZSByZWYgdG8gc2VsZiBoZXJlXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGdldHRlci9zZXR0ZXJzIG1pZ2h0XG4gICAgICAvLyBiZSBjYWxsZWQgYnkgY2hpbGQgc2NvcGVzIHZpYVxuICAgICAgLy8gcHJvdG90eXBlIGluaGVyaXRhbmNlLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX2RhdGFba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcbiAgICAgICAgICBzZWxmLl9kYXRhW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5wcm94eSBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3VucHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSB1cGRhdGUgb24gZXZlcnkgd2F0Y2hlciBpbiBzY29wZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLl93YXRjaGVyc1tpXS51cGRhdGUodHJ1ZSk7IC8vIHNoYWxsb3cgdXBkYXRlc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAgICogc3BlY2lhbCBnZXR0ZXIvc2V0dGVyc1xuICAgKi9cblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgVnVlLnByb3RvdHlwZS5faW5pdENvbXB1dGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgICAgICB2YXIgZGVmID0ge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdGhpcyk7XG4gICAgICAgICAgZGVmLnNldCA9IG5vb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmLmdldCA9IHVzZXJEZWYuZ2V0ID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2UgPyBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZi5nZXQsIHRoaXMpIDogYmluZCh1c2VyRGVmLmdldCwgdGhpcykgOiBub29wO1xuICAgICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldCA/IGJpbmQodXNlckRlZi5zZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIoZ2V0dGVyLCBvd25lcikge1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIob3duZXIsIGdldHRlciwgbnVsbCwge1xuICAgICAgbGF6eTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAgICogaW5zdGFuY2Ugc2luY2UgdGhleSBtaWdodCBiZSBwYXNzZWQgZG93biBhcyBhIHByb3AgdG9cbiAgICogY2hpbGQgY29tcG9uZW50cy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGJpbmQobWV0aG9kc1trZXldLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YTtcbiAgICBpZiAobWV0YXMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRhcykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh0aGlzLCBrZXksIG1ldGFzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGV2ZW50UkUgPSAvXnYtb246fF5ALztcblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIHdlIHB1bGwgaXQgZnJvbSB0aGVcbiAgICogaW5zdGFuY2UncyBtZXRob2RzIGJ5IG5hbWUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgcmVnaXN0ZXJDb21wb25lbnRFdmVudHModGhpcywgb3B0aW9ucy5lbCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckb24nLCBvcHRpb25zLmV2ZW50cyk7XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyR3YXRjaCcsIG9wdGlvbnMud2F0Y2gpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB2LW9uIGV2ZW50cyBvbiBhIGNoaWxkIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh2bSwgZWwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgIHZhciBuYW1lLCB2YWx1ZSwgaGFuZGxlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZXZlbnRSRSwgJycpO1xuICAgICAgICAvLyBmb3JjZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGEgc3RhdGVtZW50IHNvIHRoYXRcbiAgICAgICAgLy8gaXQgYWx3YXlzIGR5bmFtaWNhbGx5IHJlc29sdmVzIHRoZSBtZXRob2QgdG8gY2FsbCAoIzI2NzApXG4gICAgICAgIC8vIGtpbmRhIHVnbHkgaGFjaywgYnV0IGRvZXMgdGhlIGpvYi5cbiAgICAgICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICAgICAgaWYgKGlzU2ltcGxlUGF0aCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSArPSAnLmFwcGx5KHRoaXMsICRhcmd1bWVudHMpJztcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyID0gKHZtLl9zY29wZSB8fCB2bS5fY29udGV4dCkuJGV2YWwodmFsdWUsIHRydWUpO1xuICAgICAgICBoYW5kbGVyLl9mcm9tUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrcyBmb3Igb3B0aW9uIGV2ZW50cyBhbmQgd2F0Y2hlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2tzKHZtLCBhY3Rpb24sIGhhc2gpIHtcbiAgICBpZiAoIWhhc2gpIHJldHVybjtcbiAgICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgajtcbiAgICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgICBoYW5kbGVycyA9IGhhc2hba2V5XTtcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gcmVnaXN0ZXIgYW4gZXZlbnQvd2F0Y2ggY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlcjtcbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm1bYWN0aW9uXShrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzICYmIG1ldGhvZHNbaGFuZGxlcl07XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdVbmtub3duIG1ldGhvZDogXCInICsgaGFuZGxlciArICdcIiB3aGVuICcgKyAncmVnaXN0ZXJpbmcgY2FsbGJhY2sgZm9yICcgKyBhY3Rpb24gKyAnOiBcIicgKyBrZXkgKyAnXCIuJywgdm0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLmhhbmRsZXIsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCByZWN1cnNpdmUgYXR0YWNoZWQvZGV0YWNoZWQgY2FsbHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJG9uKCdob29rOmF0dGFjaGVkJywgb25BdHRhY2hlZCk7XG4gICAgdGhpcy4kb24oJ2hvb2s6ZGV0YWNoZWQnLCBvbkRldGFjaGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gcmVjdXJzaXZlbHkgY2FsbCBhdHRhY2hlZCBob29rIG9uIGNoaWxkcmVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQXR0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbEF0dGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdG9yIHRvIGNhbGwgYXR0YWNoZWQgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbEF0dGFjaChjaGlsZCkge1xuICAgIGlmICghY2hpbGQuX2lzQXR0YWNoZWQgJiYgaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGRldGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25EZXRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsRGV0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBkZXRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsRGV0YWNoKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYWxsIGhhbmRsZXJzIGZvciBhIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvb2tcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHRoaXMuJGVtaXQoJ3ByZS1ob29rOicgKyBob29rKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLiRvcHRpb25zW2hvb2tdO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gW21vZGlmaWVyc11cbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsaXRlcmFsXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhdHRyXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhcmdcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gW3JlZl1cbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheTxPYmplY3Q+fSBbaW50ZXJwXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtoYXNPbmVUaW1lXVxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge05vZGV9IGVsXG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGl2ZShkZXNjcmlwdG9yLCB2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5lbCA9IGVsO1xuICAvLyBjb3B5IGRlc2NyaXB0b3IgcHJvcGVydGllc1xuICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICB0aGlzLm5hbWUgPSBkZXNjcmlwdG9yLm5hbWU7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvbjtcbiAgdGhpcy5hcmcgPSBkZXNjcmlwdG9yLmFyZztcbiAgdGhpcy5tb2RpZmllcnMgPSBkZXNjcmlwdG9yLm1vZGlmaWVycztcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzO1xuICB0aGlzLmxpdGVyYWwgPSB0aGlzLm1vZGlmaWVycyAmJiB0aGlzLm1vZGlmaWVycy5saXRlcmFsO1xuICAvLyBwcml2YXRlXG4gIHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAvLyBsaW5rIGNvbnRleHRcbiAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gIHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gIHRoaXMuX2ZyYWcgPSBmcmFnO1xuICAvLyBzdG9yZSBkaXJlY3RpdmVzIG9uIG5vZGUgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbCkge1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzID0gdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgfHwgW107XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGRpcmVjdGl2ZSwgbWl4aW4gZGVmaW5pdGlvbiBwcm9wZXJ0aWVzLFxuICogc2V0dXAgdGhlIHdhdGNoZXIsIGNhbGwgZGVmaW5pdGlvbiBiaW5kKCkgYW5kIHVwZGF0ZSgpXG4gKiBpZiBwcmVzZW50LlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcblxuICAvLyByZW1vdmUgYXR0cmlidXRlXG4gIGlmICgobmFtZSAhPT0gJ2Nsb2FrJyB8fCB0aGlzLnZtLl9pc0NvbXBpbGVkKSAmJiB0aGlzLmVsICYmIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgdmFyIGF0dHIgPSBkZXNjcmlwdG9yLmF0dHIgfHwgJ3YtJyArIG5hbWU7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gIH1cblxuICAvLyBjb3B5IGRlZiBwcm9wZXJ0aWVzXG4gIHZhciBkZWYgPSBkZXNjcmlwdG9yLmRlZjtcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IGRlZjtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQodGhpcywgZGVmKTtcbiAgfVxuXG4gIC8vIHNldHVwIGRpcmVjdGl2ZSBwYXJhbXNcbiAgdGhpcy5fc2V0dXBQYXJhbXMoKTtcblxuICAvLyBpbml0aWFsIGJpbmRcbiAgaWYgKHRoaXMuYmluZCkge1xuICAgIHRoaXMuYmluZCgpO1xuICB9XG4gIHRoaXMuX2JvdW5kID0gdHJ1ZTtcblxuICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgdGhpcy51cGRhdGUgJiYgdGhpcy51cGRhdGUoZGVzY3JpcHRvci5yYXcpO1xuICB9IGVsc2UgaWYgKCh0aGlzLmV4cHJlc3Npb24gfHwgdGhpcy5tb2RpZmllcnMpICYmICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiYgIXRoaXMuX2NoZWNrU3RhdGVtZW50KCkpIHtcbiAgICAvLyB3cmFwcGVkIHVwZGF0ZXIgZm9yIGNvbnRleHRcbiAgICB2YXIgZGlyID0gdGhpcztcbiAgICBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAoIWRpci5fbG9ja2VkKSB7XG4gICAgICAgICAgZGlyLnVwZGF0ZSh2YWwsIG9sZFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IG5vb3AkMTtcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzID8gYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgdmFyIHBvc3RQcm9jZXNzID0gdGhpcy5fcG9zdFByb2Nlc3MgPyBiaW5kKHRoaXMuX3Bvc3RQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodGhpcy52bSwgdGhpcy5leHByZXNzaW9uLCB0aGlzLl91cGRhdGUsIC8vIGNhbGxiYWNrXG4gICAge1xuICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAgdHdvV2F5OiB0aGlzLnR3b1dheSxcbiAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgIHByZVByb2Nlc3M6IHByZVByb2Nlc3MsXG4gICAgICBwb3N0UHJvY2VzczogcG9zdFByb2Nlc3MsXG4gICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICB9KTtcbiAgICAvLyB2LW1vZGVsIHdpdGggaW5pdGFsIGlubGluZSB2YWx1ZSBuZWVkIHRvIHN5bmMgYmFjayB0b1xuICAgIC8vIG1vZGVsIGluc3RlYWQgb2YgdXBkYXRlIHRvIERPTSBvbiBpbml0LiBUaGV5IHdvdWxkXG4gICAgLy8gc2V0IHRoZSBhZnRlckJpbmQgaG9vayB0byBpbmRpY2F0ZSB0aGF0LlxuICAgIGlmICh0aGlzLmFmdGVyQmluZCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZSh3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYWxsIHBhcmFtIGF0dHJpYnV0ZXMsIGUuZy4gdHJhY2stYnksXG4gKiB0cmFuc2l0aW9uLW1vZGUsIGV0Yy4uLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGFyYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gIHRoaXMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGkgPSBwYXJhbXMubGVuZ3RoO1xuICB2YXIga2V5LCB2YWwsIG1hcHBlZEtleTtcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGh5cGhlbmF0ZShwYXJhbXNbaV0pO1xuICAgIG1hcHBlZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgdmFsID0gZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIC8vIGR5bmFtaWNcbiAgICAgIHRoaXMuX3NldHVwUGFyYW1XYXRjaGVyKG1hcHBlZEtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RhdGljXG4gICAgICB2YWwgPSBnZXRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJhbXNbbWFwcGVkS2V5XSA9IHZhbCA9PT0gJycgPyB0cnVlIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHVud2F0Y2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHdhdGNoKGV4cHJlc3Npb24sIGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgIHNlbGYucGFyYW1zW2tleV0gPSB2YWw7XG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XTtcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhbCwgb2xkVmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgdXNlcjogZmFsc2VcbiAgfSk7KHRoaXMuX3BhcmFtVW53YXRjaEZucyB8fCAodGhpcy5fcGFyYW1VbndhdGNoRm5zID0gW10pKS5wdXNoKHVud2F0Y2gpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGlyZWN0aXZlIGlzIGEgZnVuY3Rpb24gY2FsbGVyXG4gKiBhbmQgaWYgdGhlIGV4cHJlc3Npb24gaXMgYSBjYWxsYWJsZSBvbmUuIElmIGJvdGggdHJ1ZSxcbiAqIHdlIHdyYXAgdXAgdGhlIGV4cHJlc3Npb24gYW5kIHVzZSBpdCBhcyB0aGUgZXZlbnRcbiAqIGhhbmRsZXIuXG4gKlxuICogZS5nLiBvbi1jbGljaz1cImErK1wiXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb247XG4gIGlmIChleHByZXNzaW9uICYmIHRoaXMuYWNjZXB0U3RhdGVtZW50ICYmICFpc1NpbXBsZVBhdGgoZXhwcmVzc2lvbikpIHtcbiAgICB2YXIgZm4gPSBwYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbikuZ2V0O1xuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgIHNjb3BlLiRldmVudCA9IGU7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSk7XG4gICAgICBzY29wZS4kZXZlbnQgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0d28td2F5IGRpcmVjdGl2ZXNcbiAqIGUuZy4gdi1tb2RlbC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHVibGljXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMudHdvV2F5KSB7XG4gICAgdGhpcy5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fd2F0Y2hlci5zZXQodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKCdEaXJlY3RpdmUuc2V0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdHdvV2F5JyArICdkaXJlY3RpdmVzLicpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9sb2NrZWQgPSB0cnVlO1xuICBmbi5jYWxsKHNlbGYpO1xuICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fbG9ja2VkID0gZmFsc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdHRhY2hlcyBhIERPTSBldmVudCBsaXN0ZW5lclxuICogdG8gdGhlIGRpcmVjdGl2ZSBlbGVtZW50IGFuZCBhdXRvbWV0aWNhbGx5IHRlYXJzIGl0IGRvd25cbiAqIGR1cmluZyB1bmJpbmQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgb24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpOyh0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSkucHVzaChbZXZlbnQsIGhhbmRsZXJdKTtcbn07XG5cbi8qKlxuICogVGVhcmRvd24gdGhlIHdhdGNoZXIgYW5kIGNhbGwgdW5iaW5kLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYm91bmQpIHtcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgb2ZmKHRoaXMuZWwsIGxpc3RlbmVyc1tpXVswXSwgbGlzdGVuZXJzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnM7XG4gICAgaWYgKHVud2F0Y2hGbnMpIHtcbiAgICAgIGkgPSB1bndhdGNoRm5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdW53YXRjaEZuc1tpXSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnZtID0gdGhpcy5lbCA9IHRoaXMuX3dhdGNoZXIgPSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgdi1yZWYgZm9yIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlUmVmID0gZnVuY3Rpb24gKHJlbW92ZSkge1xuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWY7XG4gICAgaWYgKHJlZikge1xuICAgICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy5fY29udGV4dCkuJHJlZnM7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGlmIChyZWZzW3JlZl0gPT09IHRoaXMpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW3JlZl0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNjbHVkZSwgY29tcGlsZSBhbmQgbGluayBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICAgKiBwYXNzZWQgaW4gZWxlbWVudCB3aWxsIGJlIHByZS10cmFuc2NsdWRlZCBhbmQgY29tcGlsZWRcbiAgICogYXMgd2VsbCAtIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGNhbGwgdGhlIGxpbmtlci5cbiAgICpcbiAgICogT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2FsbCB0cmFuc2NsdWRlL2NvbXBpbGUvbGluayBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAvLyB0cmFuc2NsdWRlIGFuZCBpbml0IGVsZW1lbnRcbiAgICAvLyB0cmFuc2NsdWRlIGNhbiBwb3RlbnRpYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAgIC8vIHRoZSB0ZW1wbGF0ZSBhbmQgY2FjaGVzIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gICAgLy8gb24gdGhlIGNvbnRhaW5lciBub2RlIGFuZCByZXBsYWNlciBub2RlLlxuICAgIHZhciBvcmlnaW5hbCA9IGVsO1xuICAgIGVsID0gdHJhbnNjbHVkZShlbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdEVsZW1lbnQoZWwpO1xuXG4gICAgLy8gaGFuZGxlIHYtcHJlIG9uIHJvb3Qgbm9kZSAoIzIwMjYpXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gICAgLy8gY29udGFpbmVyIGF0dHJzIGFuZCBwcm9wcyBjYW4gYmUgZGlmZmVyZW50IGV2ZXJ5IHRpbWUuXG4gICAgdmFyIGNvbnRleHRPcHRpb25zID0gdGhpcy5fY29udGV4dCAmJiB0aGlzLl9jb250ZXh0LiRvcHRpb25zO1xuICAgIHZhciByb290TGlua2VyID0gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKTtcblxuICAgIC8vIHJlc29sdmUgc2xvdCBkaXN0cmlidXRpb25cbiAgICByZXNvbHZlU2xvdHModGhpcywgb3B0aW9ucy5fY29udGVudCk7XG5cbiAgICAvLyBjb21waWxlIGFuZCBsaW5rIHRoZSByZXN0XG4gICAgdmFyIGNvbnRlbnRMaW5rRm47XG4gICAgdmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNvbXBvbmVudCBjb21waWxhdGlvbiBjYW4gYmUgY2FjaGVkXG4gICAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAob3B0aW9ucy5fbGlua2VyQ2FjaGFibGUpIHtcbiAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlcjtcbiAgICAgIGlmICghY29udGVudExpbmtGbikge1xuICAgICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlKGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaW5rIHBoYXNlXG4gICAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gICAgdmFyIHJvb3RVbmxpbmtGbiA9IHJvb3RMaW5rZXIodGhpcywgZWwsIHRoaXMuX3Njb3BlKTtcbiAgICB2YXIgY29udGVudFVubGlua0ZuID0gY29udGVudExpbmtGbiA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpIDogY29tcGlsZShlbCwgb3B0aW9ucykodGhpcywgZWwpO1xuXG4gICAgLy8gcmVnaXN0ZXIgY29tcG9zaXRlIHVubGluayBmdW5jdGlvblxuICAgIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgICB0aGlzLl91bmxpbmtGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3RVbmxpbmtGbigpO1xuICAgICAgLy8gcGFzc2luZyBkZXN0cm95aW5nOiB0cnVlIHRvIGF2b2lkIHNlYXJjaGluZyBhbmRcbiAgICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgICBjb250ZW50VW5saW5rRm4odHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIGZpbmFsbHkgcmVwbGFjZSBvcmlnaW5hbFxuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIHJlcGxhY2Uob3JpZ2luYWwsIGVsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBpbnN0YW5jZSBlbGVtZW50LiBDYWxsZWQgaW4gdGhlIHB1YmxpY1xuICAgKiAkbW91bnQoKSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNGcmFnbWVudChlbCkpIHtcbiAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgdGhpcy4kZWwgPSB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gZWwubGFzdENoaWxkO1xuICAgICAgLy8gc2V0IHBlcnNpc3RlZCB0ZXh0IGFuY2hvcnMgdG8gZW1wdHlcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudFN0YXJ0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsID0gZWw7XG4gICAgfVxuICAgIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzO1xuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYmluZCBhIGRpcmVjdGl2ZSB0byBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciAtIHBhcnNlZCBkaXJlY3RpdmUgZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9iaW5kRGlyID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IsIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdGhpcy5fZGlyZWN0aXZlcy5wdXNoKG5ldyBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdGhpcywgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVhcmRvd24gYW4gaW5zdGFuY2UsIHVub2JzZXJ2ZXMgdGhlIGRhdGEsIHVuYmluZCBhbGwgdGhlXG4gICAqIGRpcmVjdGl2ZXMsIHR1cm4gb2ZmIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIC0gd2hldGhlciB0byByZW1vdmUgdGhlIERPTSBub2RlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cCAtIGlmIHRydWUsIGRlZmVyIGNsZWFudXAgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgbGF0ZXJcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgIGlmICh0aGlzLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc3Ryb3lSZWFkeTtcbiAgICB2YXIgcGVuZGluZ1JlbW92YWw7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gQ2xlYW51cCBzaG91bGQgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm95c2x5IGFzXG4gICAgLy8gY2FsbGJhY2sgb2YgdGhpcy4kcmVtb3ZlKCksIG9yIGlmIHJlbW92ZSBhbmQgZGVmZXJDbGVhbnVwIGFyZSBmYWxzZS5cbiAgICAvLyBJbiBhbnkgY2FzZSBpdCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFsbCBvdGhlciByZW1vdmluZywgdW5iaW5kaW5nIGFuZFxuICAgIC8vIHR1cm5pbmcgb2YgaXMgZG9uZVxuICAgIHZhciBjbGVhbnVwSWZQb3NzaWJsZSA9IGZ1bmN0aW9uIGNsZWFudXBJZlBvc3NpYmxlKCkge1xuICAgICAgaWYgKGRlc3Ryb3lSZWFkeSAmJiAhcGVuZGluZ1JlbW92YWwgJiYgIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlbW92ZSBET00gZWxlbWVudFxuICAgIGlmIChyZW1vdmUgJiYgdGhpcy4kZWwpIHtcbiAgICAgIHBlbmRpbmdSZW1vdmFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmFsID0gZmFsc2U7XG4gICAgICAgIGNsZWFudXBJZlBvc3NpYmxlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlRGVzdHJveScpO1xuICAgIHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIHZhciBpO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50LiBvbmx5IG5lY2Vzc2FyeVxuICAgIC8vIGlmIHBhcmVudCBpcyBub3QgYmVpbmcgZGVzdHJveWVkIGFzIHdlbGwuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHBhcmVudC4kY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICAgIC8vIHVucmVnaXN0ZXIgcmVmIChyZW1vdmU6IHRydWUpXG4gICAgICB0aGlzLl91cGRhdGVSZWYodHJ1ZSk7XG4gICAgfVxuICAgIC8vIGRlc3Ryb3kgYWxsIGNoaWxkcmVuLlxuICAgIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy4kY2hpbGRyZW5baV0uJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gcHJvcHNcbiAgICBpZiAodGhpcy5fcHJvcHNVbmxpbmtGbikge1xuICAgICAgdGhpcy5fcHJvcHNVbmxpbmtGbigpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBhbGwgZGlyZWN0aXZlcy4gdGhpcyBhbHNvIHRlYXJzZG93biBhbGxcbiAgICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gICAgaWYgKHRoaXMuX3VubGlua0ZuKSB7XG4gICAgICB0aGlzLl91bmxpbmtGbigpO1xuICAgIH1cbiAgICBpID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gc2VsZiBvbiAkZWxcbiAgICBpZiAodGhpcy4kZWwpIHtcbiAgICAgIHRoaXMuJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3lSZWFkeSA9IHRydWU7XG4gICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgdG8gZW5zdXJlIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGxlYXZlIHRyYW5zaXRpb24gaWYgdGhlcmVcbiAgICogaXMgYW55LlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gICAgLy8gZG8gaXQgaW4gY2xlYW51cCBzbyB0aGF0IHdlIGNhbiBjYWxsICRkZXN0cm95IHdpdGhcbiAgICAvLyBkZWZlciByaWdodCB3aGVuIGEgZnJhZ21lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5fZnJhZykge1xuICAgICAgdGhpcy5fZnJhZy5jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuX19vYl9fKSB7XG4gICAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgcmVmZXJlbmNlcyB0byBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG90aGVyXG4gICAgLy8gaW5zdGFuY2VzLiBwcmVzZXJ2ZSByZWZlcmVuY2UgdG8gX2RhdGEgc28gdGhhdCBwcm94eVxuICAgIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgICAvLyBoZXJlIGlzIHRoYXQgbXV0YXRpbmcgdGhlIGluc3RhbmNlIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gICAgLy8gbWF5IGFmZmVjdCB0aGUgc3RhdGUgb2Ygb3RoZXIgY29tcG9uZW50cyB0aGF0IGFyZSBzdGlsbFxuICAgIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgICAvLyByZWFzb25hYmxlIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXNlciByYXRoZXIgdGhhblxuICAgIC8vIGFsd2F5cyB0aHJvd2luZyBhbiBlcnJvciBvbiB0aGVtLlxuICAgIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbDtcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy4kb2ZmKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1pc2NNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAgICogVXNpbmcgcGxhaW4gZm9yIGxvb3BzIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgY2FsbGVkIGluXG4gICAqIHRoZSBnZXR0ZXIgb2YgYW55IHdhdGNoZXIgd2l0aCBmaWx0ZXJzIHNvIGl0IGlzIHZlcnlcbiAgICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd3JpdGVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSwgZmlsdGVycywgd3JpdGUpIHtcbiAgICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGs7XG4gICAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmaWx0ZXIgPSBmaWx0ZXJzW3dyaXRlID8gbCAtIGkgLSAxIDogaV07XG4gICAgICBmbiA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlci5uYW1lLCB0cnVlKTtcbiAgICAgIGlmICghZm4pIGNvbnRpbnVlO1xuICAgICAgZm4gPSB3cml0ZSA/IGZuLndyaXRlIDogZm4ucmVhZCB8fCBmbjtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdO1xuICAgICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMTtcbiAgICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgICBmb3IgKGogPSAwLCBrID0gZmlsdGVyLmFyZ3MubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgYXJnID0gZmlsdGVyLmFyZ3Nbal07XG4gICAgICAgICAgYXJnc1tqICsgb2Zmc2V0XSA9IGFyZy5keW5hbWljID8gdGhpcy4kZ2V0KGFyZy52YWx1ZSkgOiBhcmcudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZSBhIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGNvbXBvbmVudFxuICAgKiBpcyBkZWZpbmVkIG5vcm1hbGx5IG9yIHVzaW5nIGFuIGFzeW5jIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gICAqIHJlc29sdmVzIGFzeW5jaHJvbm91c2x5IGFuZCBjYWNoZXMgdGhlIHJlc29sdmVkXG4gICAqIGNvbnN0cnVjdG9yIG9uIHRoZSBmYWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgZmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmYWN0b3J5ID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhY3RvcnkgPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeVxuICAgIGlmICghZmFjdG9yeS5vcHRpb25zKSB7XG4gICAgICBpZiAoZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgICAvLyBjYWNoZWRcbiAgICAgICAgY2IoZmFjdG9yeS5yZXNvbHZlZCk7XG4gICAgICB9IGVsc2UgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgICAgIGZhY3RvcnkuY2FsbCh0aGlzLCBmdW5jdGlvbiByZXNvbHZlKHJlcykge1xuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IFZ1ZS5leHRlbmQocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFja3NcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50JyArICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJzogJyArIHZhbHVlIDogJycpICsgJy4gJyArIChyZWFzb24gPyAnXFxuUmVhc29uOiAnICsgcmVhc29uIDogJycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBjb21wb25lbnRcbiAgICAgIGNiKGZhY3RvcnkpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGZpbHRlclJFJDEgPSAvW158XVxcfFtefF0vO1xuXG5mdW5jdGlvbiBkYXRhQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGdldCA9IGZ1bmN0aW9uIChleHAsIGFzU3RhdGVtZW50KSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmIChhc1N0YXRlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyKCkge1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy5nZXQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAgICogZXhwcmVzc2lvbiBpbiBhbiBhc3NpZ25tZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwLCB0cnVlKTtcbiAgICBpZiAocmVzICYmIHJlcy5zZXQpIHtcbiAgICAgIHJlcy5zZXQuY2FsbCh0aGlzLCB0aGlzLCB2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgb24gdGhlIFZNXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbCh0aGlzLl9kYXRhLCBrZXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gICAqIHZhbHVlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGltbWVkaWF0ZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB1bndhdGNoRm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwYXJzZWQ7XG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUoZXhwT3JGbik7XG4gICAgICBleHBPckZuID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgfVxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCB7XG4gICAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICAgIHN5bmM6IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW5jLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgdXNlcjogIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VyICE9PSBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhIHRleHQgZGlyZWN0aXZlLCBpbmNsdWRpbmcgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZXZhbCA9IGZ1bmN0aW9uICh0ZXh0LCBhc1N0YXRlbWVudCkge1xuICAgIC8vIGNoZWNrIGZvciBmaWx0ZXJzLlxuICAgIGlmIChmaWx0ZXJSRSQxLnRlc3QodGV4dCkpIHtcbiAgICAgIHZhciBkaXIgPSBwYXJzZURpcmVjdGl2ZSh0ZXh0KTtcbiAgICAgIC8vIHRoZSBmaWx0ZXIgcmVnZXggY2hlY2sgbWlnaHQgZ2l2ZSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgLy8gZm9yIHBpcGVzIGluc2lkZSBzdHJpbmdzLCBzbyBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IGdldCBhbnkgZmlsdGVycyBoZXJlXG4gICAgICB2YXIgdmFsID0gdGhpcy4kZ2V0KGRpci5leHByZXNzaW9uLCBhc1N0YXRlbWVudCk7XG4gICAgICByZXR1cm4gZGlyLmZpbHRlcnMgPyB0aGlzLl9hcHBseUZpbHRlcnModmFsLCBudWxsLCBkaXIuZmlsdGVycykgOiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGZpbHRlclxuICAgICAgcmV0dXJuIHRoaXMuJGdldCh0ZXh0LCBhc1N0YXRlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBhIHBpZWNlIG9mIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQodGV4dCk7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdm0uJGV2YWwodG9rZW5zWzBdLnZhbHVlKSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLnRhZyA/IHZtLiRldmFsKHRva2VuLnZhbHVlKSA6IHRva2VuLnZhbHVlO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2cgaW5zdGFuY2UgZGF0YSBhcyBhIHBsYWluIEpTIG9iamVjdFxuICAgKiBzbyB0aGF0IGl0IGlzIGVhc2llciB0byBpbnNwZWN0IGluIGNvbnNvbGUuXG4gICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbG9nID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZGF0YSA9IHBhdGggPyBnZXRQYXRoKHRoaXMuX2RhdGEsIHBhdGgpIDogdGhpcy5fZGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGF0YSA9IGNsZWFuKGRhdGEpO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICAgIGlmICghcGF0aCkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcm9wcykge1xuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgIGRhdGFba2V5XSA9IGNsZWFuKHRoaXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAgICogb2JqZWN0IGNvcHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBvbi1pbnN0YW5jZSBuZXh0VGljay4gVGhlIGNhbGxiYWNrIGlzXG4gICAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gICAqIG1vZHVsZXMgaGF2aW5nIHRvIHJlbHkgb24gdGhlIGdsb2JhbCBWdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgbmV4dFRpY2soZm4sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBpbnNlcnQodGhpcywgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIGFwcGVuZCwgYXBwZW5kV2l0aFRyYW5zaXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGluc3RhbmNlIHRvIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcHJlcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy4kYmVmb3JlKHRhcmdldC5maXJzdENoaWxkLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgaW5zdGFuY2UgYmVmb3JlIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYmVmb3JlID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYmVmb3JlV2l0aENiLCBiZWZvcmVXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0Lm5leHRTaWJsaW5nLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpbnN0YW5jZSBmcm9tIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcmVtb3ZlID0gZnVuY3Rpb24gKGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfVxuICAgIHZhciBpbkRvY3VtZW50ID0gdGhpcy5faXNBdHRhY2hlZCAmJiBpbkRvYyh0aGlzLiRlbCk7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBpbiBkb2N1bWVudCwgbm8gbmVlZCB0byBjaGVja1xuICAgIC8vIGZvciB0cmFuc2l0aW9uc1xuICAgIGlmICghaW5Eb2N1bWVudCkgd2l0aFRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlYWxDYiA9IGZ1bmN0aW9uIHJlYWxDYigpIHtcbiAgICAgIGlmIChpbkRvY3VtZW50KSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgICByZW1vdmVOb2RlUmFuZ2UodGhpcy5fZnJhZ21lbnRTdGFydCwgdGhpcy5fZnJhZ21lbnRFbmQsIHRoaXMsIHRoaXMuX2ZyYWdtZW50LCByZWFsQ2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3AgPSB3aXRoVHJhbnNpdGlvbiA9PT0gZmFsc2UgPyByZW1vdmVXaXRoQ2IgOiByZW1vdmVXaXRoVHJhbnNpdGlvbjtcbiAgICAgIG9wKHRoaXMuJGVsLCB0aGlzLCByZWFsQ2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMiAtIG9wIGZvciB0cmFuc2l0aW9uIGluc2VydFxuICAgKiBAcmV0dXJuIHZtXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluc2VydCh2bSwgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIG9wMSwgb3AyKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFpbkRvYyh0YXJnZXQpO1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSB8fCB0YXJnZXRJc0RldGFjaGVkID8gb3AxIDogb3AyO1xuICAgIHZhciBzaG91bGRDYWxsSG9vayA9ICF0YXJnZXRJc0RldGFjaGVkICYmICF2bS5faXNBdHRhY2hlZCAmJiAhaW5Eb2Modm0uJGVsKTtcbiAgICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICAgIG1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBvcChub2RlLCB0YXJnZXQsIHZtKTtcbiAgICAgIH0pO1xuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aodm0uJGVsLCB0YXJnZXQsIHZtLCBjYik7XG4gICAgfVxuICAgIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgICAgdm0uX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHNlbGVjdG9yc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBhcHBlbmQoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYmVmb3JlV2l0aENiKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlV2l0aENiKGVsLCB2bSwgY2IpIHtcbiAgICByZW1vdmUoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudHNBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICh0aGlzLl9ldmVudHNbZXZlbnRdIHx8ICh0aGlzLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIHNlbGYuJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB0aGlzLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgY2JzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgICBmb3IgKGV2ZW50IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKTtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLTEpO1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnQgb24gc2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBzaG91bGRQcm9wYWdhdGVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpc1NvdXJjZSA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZyc7XG4gICAgZXZlbnQgPSBpc1NvdXJjZSA/IGV2ZW50IDogZXZlbnQubmFtZTtcbiAgICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gaXNTb3VyY2UgfHwgIWNicztcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBoYWNreSBzb2x1dGlvbiB0byB0aGUgcXVlc3Rpb24gcmFpc2VkXG4gICAgICAvLyBpbiAjMjEwMjogZm9yIGFuIGlubGluZSBjb21wb25lbnQgbGlzdGVuZXIgbGlrZSA8Y29tcCBAdGVzdD1cImRvVGhpc1wiPixcbiAgICAgIC8vIHRoZSBwcm9wYWdhdGlvbiBoYW5kbGluZyBpcyBzb21ld2hhdCBicm9rZW4uIFRoZXJlZm9yZSB3ZVxuICAgICAgLy8gbmVlZCB0byB0cmVhdCB0aGVzZSBpbmxpbmUgY2FsbGJhY2tzIGRpZmZlcmVudGx5LlxuICAgICAgdmFyIGhhc1BhcmVudENicyA9IGlzU291cmNlICYmIGNicy5zb21lKGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gY2IuX2Zyb21QYXJlbnQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNQYXJlbnRDYnMpIHtcbiAgICAgICAgc2hvdWxkUHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2IgPSBjYnNbaV07XG4gICAgICAgIHZhciByZXMgPSBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSAmJiAoIWhhc1BhcmVudENicyB8fCBjYi5fZnJvbVBhcmVudCkpIHtcbiAgICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRQcm9wYWdhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGJyb2FkY2FzdCBhbiBldmVudCB0byBhbGwgY2hpbGRyZW4gaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYnJvYWRjYXN0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIC8vIGlmIG5vIGNoaWxkIGhhcyByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50LFxuICAgIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c0NvdW50W2V2ZW50XSkgcmV0dXJuO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJGNoaWxkcmVuO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGlmIChpc1NvdXJjZSkge1xuICAgICAgLy8gdXNlIG9iamVjdCBldmVudCB0byBpbmRpY2F0ZSBub24tc291cmNlIGVtaXRcbiAgICAgIC8vIG9uIGNoaWxkcmVuXG4gICAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBjaGlsZC4kZW1pdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICBpZiAoc2hvdWxkUHJvcGFnYXRlKSB7XG4gICAgICAgIGNoaWxkLiRicm9hZGNhc3QuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcHJvcGFnYXRlIGFuIGV2ZW50IHVwIHRoZSBwYXJlbnQgY2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0gey4uLip9IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRpc3BhdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IHRoaXMuJGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXNob3VsZFByb3BhZ2F0ZSkgcmV0dXJuO1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgLy8gdXNlIG9iamVjdCBldmVudCB0byBpbmRpY2F0ZSBub24tc291cmNlIGVtaXRcbiAgICAvLyBvbiBwYXJlbnRzXG4gICAgYXJnc1swXSA9IHsgbmFtZTogZXZlbnQsIHNvdXJjZTogdGhpcyB9O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHBhcmVudC4kZW1pdC5hcHBseShwYXJlbnQsIGFyZ3MpO1xuICAgICAgcGFyZW50ID0gc2hvdWxkUHJvcGFnYXRlID8gcGFyZW50LiRwYXJlbnQgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBsaXN0ZW5lciBjb3VudHMgb24gYWxsIHBhcmVudHMuXG4gICAqIFRoaXMgYm9va2tlZXBpbmcgYWxsb3dzICRicm9hZGNhc3QgdG8gcmV0dXJuIGVhcmx5IHdoZW5cbiAgICogbm8gY2hpbGQgaGFzIGxpc3RlbmVkIHRvIGEgY2VydGFpbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAgICovXG5cbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBmdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50KHZtLCBldmVudCwgY291bnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAvLyBob29rcyBkbyBub3QgZ2V0IGJyb2FkY2FzdGVkIHNvIG5vIG5lZWRcbiAgICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICAgIGlmICghcGFyZW50IHx8ICFjb3VudCB8fCBob29rUkUudGVzdChldmVudCkpIHJldHVybjtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSA9IChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXQgaW5zdGFuY2UgdGFyZ2V0IGVsZW1lbnQgYW5kIGtpY2sgb2ZmIHRoZSBjb21waWxhdGlvblxuICAgKiBwcm9jZXNzLiBUaGUgcGFzc2VkIGluIGBlbGAgY2FuIGJlIGEgc2VsZWN0b3Igc3RyaW5nLCBhblxuICAgKiBleGlzdGluZyBFbGVtZW50LCBvciBhIERvY3VtZW50RnJhZ21lbnQgKGZvciBibG9ja1xuICAgKiBpbnN0YW5jZXMpLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxzdHJpbmd9IGVsXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCckbW91bnQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwgPSBxdWVyeShlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB9XG4gICAgdGhpcy5fY29tcGlsZShlbCk7XG4gICAgdGhpcy5faW5pdERPTUhvb2tzKCk7XG4gICAgaWYgKGluRG9jKHRoaXMuJGVsKSkge1xuICAgICAgdGhpcy5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgICByZWFkeS5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRvbmNlKCdob29rOmF0dGFjaGVkJywgcmVhZHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTWFyayBhbiBpbnN0YW5jZSBhcyByZWFkeS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ3JlYWR5Jyk7XG4gIH1cblxuICAvKipcbiAgICogVGVhcmRvd24gdGhlIGluc3RhbmNlLCBzaW1wbHkgZGVsZWdhdGUgdG8gdGhlIGludGVybmFsXG4gICAqIF9kZXN0cm95LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgdGhpcy5fZGVzdHJveShyZW1vdmUsIGRlZmVyQ2xlYW51cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICAgKiBkZWNvbXBpbGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICByZXR1cm4gY29tcGlsZShlbCwgdGhpcy4kb3B0aW9ucywgdHJ1ZSkodGhpcywgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgJGBcbiAqIC0gaW50ZXJuYWwgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGBfYFxuICogLSBub24tcHJlZml4ZWQgcHJvcGVydGllcyBhcmUgYXNzdW1lZCB0byBiZSBwcm94aWVkIHVzZXJcbiAqICAgZGF0YS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG4vLyBpbnN0YWxsIGludGVybmFsc1xuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbm1pc2NNaXhpbihWdWUpO1xuXG4vLyBpbnN0YWxsIGluc3RhbmNlIEFQSXNcbmRhdGFBUEkoVnVlKTtcbmRvbUFQSShWdWUpO1xuZXZlbnRzQVBJKFZ1ZSk7XG5saWZlY3ljbGVBUEkoVnVlKTtcblxudmFyIHNsb3QgPSB7XG5cbiAgcHJpb3JpdHk6IFNMT1QsXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyB0aGlzIHdhcyByZXNvbHZlZCBkdXJpbmcgY29tcG9uZW50IHRyYW5zY2x1c2lvblxuICAgIHZhciBuYW1lID0gdGhpcy5wYXJhbXMubmFtZSB8fCAnZGVmYXVsdCc7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnZtLl9zbG90Q29udGVudHMgJiYgdGhpcy52bS5fc2xvdENvbnRlbnRzW25hbWVdO1xuICAgIGlmICghY29udGVudCB8fCAhY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21waWxlKGNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLCB0aGlzLnZtLl9jb250ZXh0LCB0aGlzLnZtKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KSB7XG4gICAgaWYgKGNvbnRlbnQgJiYgY29udGV4dCkge1xuICAgICAgaWYgKHRoaXMuZWwuaGFzQ2hpbGROb2RlcygpICYmIGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICAvLyBpZiB0aGUgaW5zZXJ0ZWQgc2xvdCBoYXMgdi1pZlxuICAgICAgICAvLyBpbmplY3QgZmFsbGJhY2sgY29udGVudCBhcyB0aGUgdi1lbHNlXG4gICAgICAgIHZhciBlbHNlQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBlbHNlQmxvY2suc2V0QXR0cmlidXRlKCd2LWVsc2UnLCAnJyk7XG4gICAgICAgIGVsc2VCbG9jay5pbm5lckhUTUwgPSB0aGlzLmVsLmlubmVySFRNTDtcbiAgICAgICAgLy8gdGhlIGVsc2UgYmxvY2sgc2hvdWxkIGJlIGNvbXBpbGVkIGluIGNoaWxkIHNjb3BlXG4gICAgICAgIGVsc2VCbG9jay5fY29udGV4dCA9IHRoaXMudm07XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxzZUJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHZhciBzY29wZSA9IGhvc3QgPyBob3N0Ll9zY29wZSA6IHRoaXMuX3Njb3BlO1xuICAgICAgdGhpcy51bmxpbmsgPSBjb250ZXh0LiRjb21waWxlKGNvbnRlbnQsIGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSh0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgIHRoaXMuY29tcGlsZShleHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKSwgdGhpcy52bSk7XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMudW5saW5rKSB7XG4gICAgICB0aGlzLnVubGluaygpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBhcnRpYWwgPSB7XG5cbiAgcHJpb3JpdHk6IFBBUlRJQUwsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICAvLyB3YXRjaCBjaGFuZ2VzIHRvIG5hbWUgZm9yIGR5bmFtaWMgcGFydGlhbHNcbiAgcGFyYW1XYXRjaGVyczoge1xuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmluc2VydCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtcGFydGlhbCcpO1xuICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMucGFyYW1zLm5hbWUpO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGlkKSB7XG4gICAgdmFyIHBhcnRpYWwgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQsIHRydWUpO1xuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHBhcnRpYWwpO1xuICAgICAgdklmLmluc2VydC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsZW1lbnREaXJlY3RpdmVzID0ge1xuICBzbG90OiBzbG90LFxuICBwYXJ0aWFsOiBwYXJ0aWFsXG59O1xuXG52YXIgY29udmVydEFycmF5ID0gdkZvci5fcG9zdFByb2Nlc3M7XG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAoRGVjaW1hbCBleHBlY3RlZClcbiAqL1xuXG5mdW5jdGlvbiBsaW1pdEJ5KGFyciwgbiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCwgMTApIDogMDtcbiAgbiA9IHRvTnVtYmVyKG4pO1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInID8gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikgOiBhcnI7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWxpbWl0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gLi4uZGF0YUtleXNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJCeShhcnIsIHNlYXJjaCwgZGVsaW1pdGVyKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoc2VhcmNoKTtcbiAgfVxuICAvLyBjYXN0IHRvIGxvd2VyY2FzZSBzdHJpbmdcbiAgc2VhcmNoID0gKCcnICsgc2VhcmNoKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMjtcbiAgLy8gZXh0cmFjdCBhbmQgZmxhdHRlbiBrZXlzXG4gIHZhciBrZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdG9BcnJheShhcmd1bWVudHMsIG4pKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaXRlbSwga2V5LCB2YWwsIGo7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgdmFsID0gaXRlbSAmJiBpdGVtLiR2YWx1ZSB8fCBpdGVtO1xuICAgIGogPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaikge1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoa2V5ID09PSAnJGtleScgJiYgY29udGFpbnMoaXRlbS4ka2V5LCBzZWFyY2gpIHx8IGNvbnRhaW5zKGdldFBhdGgodmFsLCBrZXkpLCBzZWFyY2gpKSB7XG4gICAgICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PFN0cmluZz58RnVuY3Rpb259IC4uLnNvcnRLZXlzXG4gKiBAcGFyYW0ge051bWJlcn0gW29yZGVyXVxuICovXG5cbmZ1bmN0aW9uIG9yZGVyQnkoYXJyKSB7XG4gIHZhciBjb21wYXJhdG9yID0gbnVsbDtcbiAgdmFyIHNvcnRLZXlzID0gdW5kZWZpbmVkO1xuICBhcnIgPSBjb252ZXJ0QXJyYXkoYXJyKTtcblxuICAvLyBkZXRlcm1pbmUgb3JkZXIgKGxhc3QgYXJndW1lbnQpXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICB2YXIgb3JkZXIgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInKSB7XG4gICAgb3JkZXIgPSBvcmRlciA8IDAgPyAtMSA6IDE7XG4gICAgYXJncyA9IGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3Muc2xpY2UoMCwgLTEpIDogYXJncztcbiAgfSBlbHNlIHtcbiAgICBvcmRlciA9IDE7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgc29ydEtleXMgJiBjb21wYXJhdG9yXG4gIHZhciBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGlmICghZmlyc3RBcmcpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGN1c3RvbSBjb21wYXJhdG9yXG4gICAgY29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZmlyc3RBcmcoYSwgYikgKiBvcmRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHN0cmluZyBrZXlzLiBmbGF0dGVuIGZpcnN0XG4gICAgc29ydEtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmdzKTtcbiAgICBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIsIGkpIHtcbiAgICAgIGkgPSBpIHx8IDA7XG4gICAgICByZXR1cm4gaSA+PSBzb3J0S2V5cy5sZW5ndGggLSAxID8gYmFzZUNvbXBhcmUoYSwgYiwgaSkgOiBiYXNlQ29tcGFyZShhLCBiLCBpKSB8fCBjb21wYXJhdG9yKGEsIGIsIGkgKyAxKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmUoYSwgYiwgc29ydEtleUluZGV4KSB7XG4gICAgdmFyIHNvcnRLZXkgPSBzb3J0S2V5c1tzb3J0S2V5SW5kZXhdO1xuICAgIGlmIChzb3J0S2V5KSB7XG4gICAgICBpZiAoc29ydEtleSAhPT0gJyRrZXknKSB7XG4gICAgICAgIGlmIChpc09iamVjdChhKSAmJiAnJHZhbHVlJyBpbiBhKSBhID0gYS4kdmFsdWU7XG4gICAgICAgIGlmIChpc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWU7XG4gICAgICB9XG4gICAgICBhID0gaXNPYmplY3QoYSkgPyBnZXRQYXRoKGEsIHNvcnRLZXkpIDogYTtcbiAgICAgIGIgPSBpc09iamVjdChiKSA/IGdldFBhdGgoYiwgc29ydEtleSkgOiBiO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IG9yZGVyIDogLW9yZGVyO1xuICB9XG5cbiAgLy8gc29ydCBvbiBhIGNvcHkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgYXJyYXlcbiAgcmV0dXJuIGFyci5zbGljZSgpLnNvcnQoY29tcGFyYXRvcik7XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnRhaW4gaGVscGVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcbiAqL1xuXG5mdW5jdGlvbiBjb250YWlucyh2YWwsIHNlYXJjaCkge1xuICB2YXIgaTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zKHZhbFtrZXlzW2ldXSwgc2VhcmNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zKHZhbFtpXSwgc2VhcmNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaCkgPiAtMTtcbiAgfVxufVxuXG52YXIgZGlnaXRzUkUgPSAvKFxcZHszfSkoPz1cXGQpL2c7XG5cbi8vIGFzc2V0IGNvbGxlY3Rpb25zIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuXG52YXIgZmlsdGVycyA9IHtcblxuICBvcmRlckJ5OiBvcmRlckJ5LFxuICBmaWx0ZXJCeTogZmlsdGVyQnksXG4gIGxpbWl0Qnk6IGxpbWl0QnksXG5cbiAgLyoqXG4gICAqIFN0cmluZ2lmeSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGVudFxuICAgKi9cblxuICBqc29uOiB7XG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZCh2YWx1ZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gaW5kZW50IDogMik7XG4gICAgfSxcbiAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FiYydcbiAgICovXG5cbiAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdhYmMnID0+ICdBQkMnXG4gICAqL1xuXG4gIHVwcGVyY2FzZTogZnVuY3Rpb24gdXBwZXJjYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpIDogJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdBYkMnID0+ICdhYmMnXG4gICAqL1xuXG4gIGxvd2VyY2FzZTogZnVuY3Rpb24gbG93ZXJjYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIDEyMzQ1ID0+ICQxMiwzNDUuMDBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpZ25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxzIERlY2ltYWwgcGxhY2VzXG4gICAqL1xuXG4gIGN1cnJlbmN5OiBmdW5jdGlvbiBjdXJyZW5jeSh2YWx1ZSwgX2N1cnJlbmN5LCBkZWNpbWFscykge1xuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgX2N1cnJlbmN5ID0gX2N1cnJlbmN5ICE9IG51bGwgPyBfY3VycmVuY3kgOiAnJCc7XG4gICAgZGVjaW1hbHMgPSBkZWNpbWFscyAhPSBudWxsID8gZGVjaW1hbHMgOiAyO1xuICAgIHZhciBzdHJpbmdpZmllZCA9IE1hdGguYWJzKHZhbHVlKS50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgICB2YXIgX2ludCA9IGRlY2ltYWxzID8gc3RyaW5naWZpZWQuc2xpY2UoMCwgLTEgLSBkZWNpbWFscykgOiBzdHJpbmdpZmllZDtcbiAgICB2YXIgaSA9IF9pbnQubGVuZ3RoICUgMztcbiAgICB2YXIgaGVhZCA9IGkgPiAwID8gX2ludC5zbGljZSgwLCBpKSArIChfaW50Lmxlbmd0aCA+IDMgPyAnLCcgOiAnJykgOiAnJztcbiAgICB2YXIgX2Zsb2F0ID0gZGVjaW1hbHMgPyBzdHJpbmdpZmllZC5zbGljZSgtMSAtIGRlY2ltYWxzKSA6ICcnO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgcmV0dXJuIHNpZ24gKyBfY3VycmVuY3kgKyBoZWFkICsgX2ludC5zbGljZShpKS5yZXBsYWNlKGRpZ2l0c1JFLCAnJDEsJykgKyBfZmxvYXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdpdGVtJyA9PiAnaXRlbXMnXG4gICAqXG4gICAqIEBwYXJhbXNcbiAgICogIGFuIGFycmF5IG9mIHN0cmluZ3MgY29ycmVzcG9uZGluZyB0b1xuICAgKiAgdGhlIHNpbmdsZSwgZG91YmxlLCB0cmlwbGUgLi4uIGZvcm1zIG9mIHRoZSB3b3JkIHRvXG4gICAqICBiZSBwbHVyYWxpemVkLiBXaGVuIHRoZSBudW1iZXIgdG8gYmUgcGx1cmFsaXplZFxuICAgKiAgZXhjZWVkcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcmdzLCBpdCB3aWxsIHVzZSB0aGUgbGFzdFxuICAgKiAgZW50cnkgaW4gdGhlIGFycmF5LlxuICAgKlxuICAgKiAgZS5nLiBbJ3NpbmdsZScsICdkb3VibGUnLCAndHJpcGxlJywgJ211bHRpcGxlJ11cbiAgICovXG5cbiAgcGx1cmFsaXplOiBmdW5jdGlvbiBwbHVyYWxpemUodmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IHZhbHVlICUgMTAgLSAxO1xuICAgICAgcmV0dXJuIGluZGV4IGluIGFyZ3MgPyBhcmdzW2luZGV4XSA6IGFyZ3NbbGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcmdzWzBdICsgKHZhbHVlID09PSAxID8gJycgOiAncycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGhhbmRsZXIsIGRlbGF5KSB7XG4gICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgaWYgKCFkZWxheSkge1xuICAgICAgZGVsYXkgPSAzMDA7XG4gICAgfVxuICAgIHJldHVybiBfZGVib3VuY2UoaGFuZGxlciwgZGVsYXkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbnN0YWxsR2xvYmFsQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFZ1ZSBhbmQgZXZlcnkgY29uc3RydWN0b3IgdGhhdCBleHRlbmRzIFZ1ZSBoYXMgYW5cbiAgICogYXNzb2NpYXRlZCBvcHRpb25zIG9iamVjdCwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGR1cmluZ1xuICAgKiBjb21waWxhdGlvbiBzdGVwcyBhcyBgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zYC5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHNlZW4gYXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBvZiBldmVyeVxuICAgKiBWdWUgaW5zdGFuY2UuXG4gICAqL1xuXG4gIFZ1ZS5vcHRpb25zID0ge1xuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgZWxlbWVudERpcmVjdGl2ZXM6IGVsZW1lbnREaXJlY3RpdmVzLFxuICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgdHJhbnNpdGlvbnM6IHt9LFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIHBhcnRpYWxzOiB7fSxcbiAgICByZXBsYWNlOiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gICAqL1xuXG4gIFZ1ZS51dGlsID0gdXRpbDtcbiAgVnVlLmNvbmZpZyA9IGNvbmZpZztcbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlWydkZWxldGUnXSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzYWdlIC8gcGx1Z2luc1xuICAgKi9cblxuICBWdWUuY29tcGlsZXIgPSBjb21waWxlcjtcbiAgVnVlLkZyYWdtZW50RmFjdG9yeSA9IEZyYWdtZW50RmFjdG9yeTtcbiAgVnVlLmludGVybmFsRGlyZWN0aXZlcyA9IGludGVybmFsRGlyZWN0aXZlcztcbiAgVnVlLnBhcnNlcnMgPSB7XG4gICAgcGF0aDogcGF0aCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBkaXJlY3RpdmU6IGRpcmVjdGl2ZSxcbiAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gIH07XG5cbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cblxuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gICAqL1xuXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIGlzRmlyc3RFeHRlbmQgPSBTdXBlci5jaWQgPT09IDA7XG4gICAgaWYgKGlzRmlyc3RFeHRlbmQgJiYgZXh0ZW5kT3B0aW9ucy5fQ3Rvcikge1xuICAgICAgcmV0dXJuIGV4dGVuZE9wdGlvbnMuX0N0b3I7XG4gICAgfVxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybignSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgKyAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjYXRlcnMgYW5kIHRoZSBoeXBoZW4uJyk7XG4gICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50Jyk7XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvblxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGlmIChpc0ZpcnN0RXh0ZW5kKSB7XG4gICAgICBleHRlbmRPcHRpb25zLl9DdG9yID0gU3ViO1xuICAgIH1cbiAgICByZXR1cm4gU3ViO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN1Yi1jbGFzcyBjb25zdHJ1Y3RvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBuYW1lLiBUaGlzIGdpdmVzIHVzIG11Y2ggbmljZXIgb3V0cHV0IHdoZW5cbiAgICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhuYW1lKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24gJyArIGNsYXNzaWZ5KG5hbWUpICsgJyAob3B0aW9ucykgeyB0aGlzLl9pbml0KG9wdGlvbnMpIH0nKSgpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBQbHVnaW4gc3lzdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5cbiAgICovXG5cbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gICAqIG9wdGlvbnMuXG4gICAqL1xuXG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIFZ1ZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFZ1ZS5vcHRpb25zLCBtaXhpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogc2lnbmF0dXJlOlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogQHBhcmFtIHsqfSBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgKGNvbW1vblRhZ1JFLnRlc3QoaWQpIHx8IHJlc2VydmVkVGFnUkUudGVzdChpZCkpKSB7XG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgaWYgKCFkZWZpbml0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZpbml0aW9uID0gVnVlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZXhwb3NlIGludGVybmFsIHRyYW5zaXRpb24gQVBJXG4gIGV4dGVuZChWdWUudHJhbnNpdGlvbiwgdHJhbnNpdGlvbik7XG59XG5cbmluc3RhbGxHbG9iYWxBUEkoVnVlKTtcblxuVnVlLnZlcnNpb24gPSAnMS4wLjI2JztcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluQnJvd3NlciAmJiAvQ2hyb21lXFwvXFxkKy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgKyAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICAgIH1cbiAgfVxufSwgMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxyXG4gKiBLZWVuIFVJIHYwLjguOSAoaHR0cHM6Ly9naXRodWIuY29tL0pvc2VwaHVzUGF5ZS9rZWVuLXVpKVxyXG4gKiAoYykgMjAxNiBKb3NlcGh1cyBQYXllIElJXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIktlZW5cIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIktlZW5cIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxyXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcclxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxyXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcclxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcclxuLyoqKioqKi8gXHR9XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cdFxyXG5cdHZhciBfVWlBbGVydCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0XHJcblx0dmFyIF9VaUFsZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQWxlcnQpO1xyXG5cdFxyXG5cdHZhciBfVWlBdXRvY29tcGxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcclxuXHRcclxuXHR2YXIgX1VpQXV0b2NvbXBsZXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQXV0b2NvbXBsZXRlKTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlCdXR0b24pO1xyXG5cdFxyXG5cdHZhciBfVWlDaGVja2JveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcclxuXHRcclxuXHR2YXIgX1VpQ2hlY2tib3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlDaGVja2JveCk7XHJcblx0XHJcblx0dmFyIF9VaUNvbGxhcHNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpO1xyXG5cdFxyXG5cdHZhciBfVWlDb2xsYXBzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUNvbGxhcHNpYmxlKTtcclxuXHRcclxuXHR2YXIgX1VpQ29uZmlybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIxKTtcclxuXHRcclxuXHR2YXIgX1VpQ29uZmlybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUNvbmZpcm0pO1xyXG5cdFxyXG5cdHZhciBfVWlGYWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOSk7XHJcblx0XHJcblx0dmFyIF9VaUZhYjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUZhYik7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaUljb25CdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb25CdXR0b24pO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNZW51KTtcclxuXHRcclxuXHR2YXIgX1VpTWVudU9wdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51T3B0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTWVudU9wdGlvbik7XHJcblx0XHJcblx0dmFyIF9VaU1vZGFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpO1xyXG5cdFxyXG5cdHZhciBfVWlNb2RhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaU1vZGFsKTtcclxuXHRcclxuXHR2YXIgX1VpUG9wb3ZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUG9wb3Zlcik7XHJcblx0XHJcblx0dmFyIF9VaVByZWxvYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMzKTtcclxuXHRcclxuXHR2YXIgX1VpUHJlbG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJlbG9hZGVyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NDaXJjdWxhciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NDaXJjdWxhcik7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzTGluZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0xpbmVhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVByb2dyZXNzTGluZWFyKTtcclxuXHRcclxuXHR2YXIgX1VpUmFkaW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MSk7XHJcblx0XHJcblx0dmFyIF9VaVJhZGlvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmFkaW8pO1xyXG5cdFxyXG5cdHZhciBfVWlSYWRpb0dyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpO1xyXG5cdFxyXG5cdHZhciBfVWlSYWRpb0dyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmFkaW9Hcm91cCk7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ5KTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmF0aW5nKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTtcclxuXHRcclxuXHR2YXIgX1VpUmF0aW5nSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVJhdGluZ0ljb24pO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmdQcmV2aWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTcpO1xyXG5cdFxyXG5cdHZhciBfVWlSYXRpbmdQcmV2aWV3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmF0aW5nUHJldmlldyk7XHJcblx0XHJcblx0dmFyIF9VaVJpcHBsZUluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5cdFxyXG5cdHZhciBfVWlSaXBwbGVJbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSaXBwbGVJbmspO1xyXG5cdFxyXG5cdHZhciBfVWlTZWxlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MSk7XHJcblx0XHJcblx0dmFyIF9VaVNlbGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVNlbGVjdCk7XHJcblx0XHJcblx0dmFyIF9VaVNsaWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcyKTtcclxuXHRcclxuXHR2YXIgX1VpU2xpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU2xpZGVyKTtcclxuXHRcclxuXHR2YXIgX1VpU25hY2tiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NCk7XHJcblx0XHJcblx0dmFyIF9VaVNuYWNrYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU25hY2tiYXIpO1xyXG5cdFxyXG5cdHZhciBfVWlTbmFja2JhckNvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMTg4KTtcclxuXHRcclxuXHR2YXIgX1VpU25hY2tiYXJDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlTbmFja2JhckNvbnRhaW5lcik7XHJcblx0XHJcblx0dmFyIF9VaVN3aXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkyKTtcclxuXHRcclxuXHR2YXIgX1VpU3dpdGNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU3dpdGNoKTtcclxuXHRcclxuXHR2YXIgX1VpVGFiID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTYpO1xyXG5cdFxyXG5cdHZhciBfVWlUYWIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUYWIpO1xyXG5cdFxyXG5cdHZhciBfVWlUYWJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDApO1xyXG5cdFxyXG5cdHZhciBfVWlUYWJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpVGFicyk7XHJcblx0XHJcblx0dmFyIF9VaVRleHRib3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOCk7XHJcblx0XHJcblx0dmFyIF9VaVRleHRib3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUZXh0Ym94KTtcclxuXHRcclxuXHR2YXIgX1VpVG9vbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcclxuXHRcclxuXHR2YXIgX1VpVG9vbGJhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVRvb2xiYXIpO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XHJcblx0XHJcblx0dmFyIF9VaVRvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUb29sdGlwKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdHZhciBLZWVuID0ge1xyXG5cdCAgICBVaUFsZXJ0OiBfVWlBbGVydDIuZGVmYXVsdCxcclxuXHQgICAgVWlBdXRvY29tcGxldGU6IF9VaUF1dG9jb21wbGV0ZTIuZGVmYXVsdCxcclxuXHQgICAgVWlCdXR0b246IF9VaUJ1dHRvbjIuZGVmYXVsdCxcclxuXHQgICAgVWlDaGVja2JveDogX1VpQ2hlY2tib3gyLmRlZmF1bHQsXHJcblx0ICAgIFVpQ29sbGFwc2libGU6IF9VaUNvbGxhcHNpYmxlMi5kZWZhdWx0LFxyXG5cdCAgICBVaUNvbmZpcm06IF9VaUNvbmZpcm0yLmRlZmF1bHQsXHJcblx0ICAgIFVpRmFiOiBfVWlGYWIyLmRlZmF1bHQsXHJcblx0ICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdCxcclxuXHQgICAgVWlJY29uQnV0dG9uOiBfVWlJY29uQnV0dG9uMi5kZWZhdWx0LFxyXG5cdCAgICBVaU1lbnU6IF9VaU1lbnUyLmRlZmF1bHQsXHJcblx0ICAgIFVpTWVudU9wdGlvbjogX1VpTWVudU9wdGlvbjIuZGVmYXVsdCxcclxuXHQgICAgVWlNb2RhbDogX1VpTW9kYWwyLmRlZmF1bHQsXHJcblx0ICAgIFVpUG9wb3ZlcjogX1VpUG9wb3ZlcjIuZGVmYXVsdCxcclxuXHQgICAgVWlQcmVsb2FkZXI6IF9VaVByZWxvYWRlcjIuZGVmYXVsdCxcclxuXHQgICAgVWlQcm9ncmVzc0NpcmN1bGFyOiBfVWlQcm9ncmVzc0NpcmN1bGFyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVByb2dyZXNzTGluZWFyOiBfVWlQcm9ncmVzc0xpbmVhcjIuZGVmYXVsdCxcclxuXHQgICAgVWlSYWRpbzogX1VpUmFkaW8yLmRlZmF1bHQsXHJcblx0ICAgIFVpUmFkaW9Hcm91cDogX1VpUmFkaW9Hcm91cDIuZGVmYXVsdCxcclxuXHQgICAgVWlSYXRpbmc6IF9VaVJhdGluZzIuZGVmYXVsdCxcclxuXHQgICAgVWlSYXRpbmdJY29uOiBfVWlSYXRpbmdJY29uMi5kZWZhdWx0LFxyXG5cdCAgICBVaVJhdGluZ1ByZXZpZXc6IF9VaVJhdGluZ1ByZXZpZXcyLmRlZmF1bHQsXHJcblx0ICAgIFVpUmlwcGxlSW5rOiBfVWlSaXBwbGVJbmsyLmRlZmF1bHQsXHJcblx0ICAgIFVpU2VsZWN0OiBfVWlTZWxlY3QyLmRlZmF1bHQsXHJcblx0ICAgIFVpU2xpZGVyOiBfVWlTbGlkZXIyLmRlZmF1bHQsXHJcblx0ICAgIFVpU25hY2tiYXI6IF9VaVNuYWNrYmFyMi5kZWZhdWx0LFxyXG5cdCAgICBVaVNuYWNrYmFyQ29udGFpbmVyOiBfVWlTbmFja2JhckNvbnRhaW5lcjIuZGVmYXVsdCxcclxuXHQgICAgVWlTd2l0Y2g6IF9VaVN3aXRjaDIuZGVmYXVsdCxcclxuXHQgICAgVWlUYWI6IF9VaVRhYjIuZGVmYXVsdCxcclxuXHQgICAgVWlUYWJzOiBfVWlUYWJzMi5kZWZhdWx0LFxyXG5cdCAgICBVaVRleHRib3g6IF9VaVRleHRib3gyLmRlZmF1bHQsXHJcblx0ICAgIFVpVG9vbGJhcjogX1VpVG9vbGJhcjIuZGVmYXVsdCxcclxuXHQgICAgVWlUb29sdGlwOiBfVWlUb29sdGlwMi5kZWZhdWx0LFxyXG5cdFxyXG5cdCAgICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKFZ1ZSkge1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktYWxlcnQnLCBfVWlBbGVydDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1hdXRvY29tcGxldGUnLCBfVWlBdXRvY29tcGxldGUyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktYnV0dG9uJywgX1VpQnV0dG9uMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLWNoZWNrYm94JywgX1VpQ2hlY2tib3gyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktY29sbGFwc2libGUnLCBfVWlDb2xsYXBzaWJsZTIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1jb25maXJtJywgX1VpQ29uZmlybTIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1mYWInLCBfVWlGYWIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktaWNvbicsIF9VaUljb24yLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktaWNvbi1idXR0b24nLCBfVWlJY29uQnV0dG9uMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLW1lbnUnLCBfVWlNZW51Mi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLW1lbnUtb3B0aW9uJywgX1VpTWVudU9wdGlvbjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1tb2RhbCcsIF9VaU1vZGFsMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXBvcG92ZXInLCBfVWlQb3BvdmVyMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXByZWxvYWRlcicsIF9VaVByZWxvYWRlcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1wcm9ncmVzcy1jaXJjdWxhcicsIF9VaVByb2dyZXNzQ2lyY3VsYXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcHJvZ3Jlc3MtbGluZWFyJywgX1VpUHJvZ3Jlc3NMaW5lYXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcmFkaW8nLCBfVWlSYWRpbzIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yYWRpby1ncm91cCcsIF9VaVJhZGlvR3JvdXAyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcmF0aW5nJywgX1VpUmF0aW5nMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXJhdGluZy1pY29uJywgX1VpUmF0aW5nSWNvbjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1yYXRpbmctcHJldmlldycsIF9VaVJhdGluZ1ByZXZpZXcyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktcmlwcGxlLWluaycsIF9VaVJpcHBsZUluazIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS1zZWxlY3QnLCBfVWlTZWxlY3QyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktc2xpZGVyJywgX1VpU2xpZGVyMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXNuYWNrYmFyJywgX1VpU25hY2tiYXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktc25hY2tiYXItY29udGFpbmVyJywgX1VpU25hY2tiYXJDb250YWluZXIyLmRlZmF1bHQpO1xyXG5cdCAgICAgICAgVnVlLmNvbXBvbmVudCgndWktc3dpdGNoJywgX1VpU3dpdGNoMi5kZWZhdWx0KTtcclxuXHQgICAgICAgIFZ1ZS5jb21wb25lbnQoJ3VpLXRhYicsIF9VaVRhYjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS10YWJzJywgX1VpVGFiczIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS10ZXh0Ym94JywgX1VpVGV4dGJveDIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS10b29sYmFyJywgX1VpVG9vbGJhcjIuZGVmYXVsdCk7XHJcblx0ICAgICAgICBWdWUuY29tcG9uZW50KCd1aS10b29sdGlwJywgX1VpVG9vbHRpcDIuZGVmYXVsdCk7XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gS2VlbjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICB2YXIgaGFkS2V5Ym9hcmRFdmVudCA9IGZhbHNlO1xyXG5cdCAgICB2YXIga2V5Ym9hcmRNb2RhbGl0eVdoaXRlbGlzdCA9IFsnaW5wdXQ6bm90KFt0eXBlXSknLCAnaW5wdXRbdHlwZT10ZXh0XScsICdpbnB1dFt0eXBlPW51bWJlcl0nLCAnaW5wdXRbdHlwZT1kYXRlXScsICdpbnB1dFt0eXBlPXRpbWVdJywgJ2lucHV0W3R5cGU9ZGF0ZXRpbWVdJywgJ3RleHRhcmVhJywgJ1tyb2xlPXRleHRib3hdJywgJ1tzdXBwb3J0cy1tb2RhbGl0eT1rZXlib2FyZF0nXS5qb2luKCcsJyk7XHJcblx0XHJcblx0ICAgIHZhciBpc0hhbmRsaW5nS2V5Ym9hcmRUaHJvdHRsZTtcclxuXHRcclxuXHQgICAgdmFyIG1hdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5ib2R5O1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKGVsLm1hdGNoZXNTZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBlbC5tYXRjaGVzU2VsZWN0b3I7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmIChlbC5tb3pNYXRjaGVzU2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZWwubW96TWF0Y2hlc1NlbGVjdG9yO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKGVsLm1zTWF0Y2hlc1NlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgY29uc29sZS5lcnJvcignQ291bGRuXFwndCBmaW5kIGFueSBtYXRjaGVzU2VsZWN0b3IgbWV0aG9kIG9uIGRvY3VtZW50LmJvZHkuJyk7XHJcblx0ICAgIH0oKTtcclxuXHRcclxuXHQgICAgdmFyIGRpc2FibGVGb2N1c1JpbmdCeURlZmF1bHQgPSBmdW5jdGlvbiBkaXNhYmxlRm9jdXNSaW5nQnlEZWZhdWx0KCkge1xyXG5cdCAgICAgICAgdmFyIGNzcyA9ICdib2R5Om5vdChbbW9kYWxpdHk9a2V5Ym9hcmRdKSA6Zm9jdXMgeyBvdXRsaW5lOiBub25lOyB9JztcclxuXHQgICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG5cdCAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuXHRcclxuXHQgICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xyXG5cdCAgICAgICAgc3R5bGUuaWQgPSAnZGlzYWJsZS1mb2N1cy1yaW5nJztcclxuXHRcclxuXHQgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XHJcblx0ICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICB2YXIgZm9jdXNUcmlnZ2Vyc0tleWJvYXJkTW9kYWxpdHkgPSBmdW5jdGlvbiBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eShlbCkge1xyXG5cdCAgICAgICAgdmFyIHRyaWdnZXJzID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICBpZiAobWF0Y2hlcikge1xyXG5cdCAgICAgICAgICAgIHRyaWdnZXJzID0gbWF0Y2hlci5jYWxsKGVsLCBrZXlib2FyZE1vZGFsaXR5V2hpdGVsaXN0KSAmJiBtYXRjaGVyLmNhbGwoZWwsICc6bm90KFtyZWFkb25seV0pJyk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gdHJpZ2dlcnM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIGRpc2FibGVGb2N1c1JpbmdCeURlZmF1bHQoKTtcclxuXHRcclxuXHQgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XHJcblx0XHJcblx0ICAgICAgICBpZiAoaXNIYW5kbGluZ0tleWJvYXJkVGhyb3R0bGUpIHtcclxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQoaXNIYW5kbGluZ0tleWJvYXJkVGhyb3R0bGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaXNIYW5kbGluZ0tleWJvYXJkVGhyb3R0bGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICBoYWRLZXlib2FyZEV2ZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9LCAxMDApO1xyXG5cdCAgICB9LCB0cnVlKTtcclxuXHRcclxuXHQgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICBpZiAoaGFkS2V5Ym9hcmRFdmVudCB8fCBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eShlLnRhcmdldCkpIHtcclxuXHQgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnbW9kYWxpdHknLCAna2V5Ym9hcmQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSwgdHJ1ZSk7XHJcblx0XHJcblx0ICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCdtb2RhbGl0eScpO1xyXG5cdCAgICB9LCB0cnVlKTtcclxuXHR9KTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUFsZXJ0LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODApXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlBbGVydC52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDQgKi8sXHJcbi8qIDUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbkJ1dHRvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1hbGVydCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBzaG93OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnaW5mbycgfSxcclxuXHQgICAgICAgIHRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc21pc3NpYmxlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBpY29uTmFtZTogZnVuY3Rpb24gaWNvbk5hbWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaWNvbikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pY29uO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgaWNvbiA9IHRoaXMudHlwZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoaWNvbiA9PT0gJ3N1Y2Nlc3MnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGljb24gPSAnY2hlY2tfY2lyY2xlJztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGljb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGlzbWlzc2VkJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdCxcclxuXHQgICAgICAgIFVpSWNvbkJ1dHRvbjogX1VpSWNvbkJ1dHRvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oNylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOClcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUljb24udnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpSWNvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1pY29uJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZW1vdmVUZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48aVxcbiAgICBjbGFzcz1cXFwidWktaWNvbiBtYXRlcmlhbC1pY29uc1xcXCIgOmNsYXNzPVxcXCJbaWNvbl1cXFwiIHYtdGV4dD1cXFwicmVtb3ZlVGV4dCA/IG51bGwgOiBpY29uXFxcIlxcbiAgICBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCJcXG4+PC9pPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTEpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpSWNvbkJ1dHRvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpSWNvbkJ1dHRvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlNZW51KTtcclxuXHRcclxuXHR2YXIgX1VpUG9wb3ZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUG9wb3Zlcik7XHJcblx0XHJcblx0dmFyIF9VaVByb2dyZXNzQ2lyY3VsYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NDaXJjdWxhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVByb2dyZXNzQ2lyY3VsYXIpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX0hhc0Ryb3Bkb3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XHJcblx0XHJcblx0dmFyIF9IYXNEcm9wZG93bjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IYXNEcm9wZG93bik7XHJcblx0XHJcblx0dmFyIF9TaG93c1Rvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1Rvb2x0aXApO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzUmlwcGxlSW5rKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWljb24tYnV0dG9uJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd1aS1pY29uLWJ1dHRvbi0nICsgdHlwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYnV0dG9uVHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnYnV0dG9uJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhcmlhTGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGxvYWRpbmc6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzdHlsZUNsYXNzZXM6IGZ1bmN0aW9uIHN0eWxlQ2xhc3NlcygpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFt0aGlzLnR5cGUsIHRoaXMuY29sb3JdO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhhc0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgndWktZHJvcGRvd24nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3Bpbm5lckNvbG9yOiBmdW5jdGlvbiBzcGlubmVyQ29sb3IoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IgPT09ICdjb2xvci1kZWZhdWx0JyB8fCB0aGlzLmNvbG9yID09PSAnY29sb3ItYmxhY2snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnYmxhY2snO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gJ3doaXRlJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlNZW51OiBfVWlNZW51Mi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlQb3BvdmVyOiBfVWlQb3BvdmVyMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlQcm9ncmVzc0NpcmN1bGFyOiBfVWlQcm9ncmVzc0NpcmN1bGFyMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19IYXNEcm9wZG93bjIuZGVmYXVsdCwgX1Nob3dzVG9vbHRpcDIuZGVmYXVsdCwgX1Nob3dzUmlwcGxlSW5rMi5kZWZhdWx0XSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaU1lbnUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaU1lbnUudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpTWVudU9wdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5cdFxyXG5cdHZhciBfVWlNZW51T3B0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTWVudU9wdGlvbik7XHJcblx0XHJcblx0dmFyIF9TaG93c0Ryb3Bkb3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcblx0XHJcblx0dmFyIF9TaG93c0Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nob3dzRHJvcGRvd24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktbWVudScsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd0ljb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dTZWNvbmRhcnlUZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhpZGVSaXBwbGVJbms6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VPblNlbGVjdDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLW1lbnUtZGVmYXVsdCdcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAnZHJvcGRvd24tb3BlbmVkJzogZnVuY3Rpb24gZHJvcGRvd25PcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbkZvY3VzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZXN0cmljdEZvY3VzLCB0cnVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ29wZW5lZCcpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICdkcm9wZG93bi1jbG9zZWQnOiBmdW5jdGlvbiBkcm9wZG93bkNsb3NlZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250YWluRm9jdXMpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xvc2VkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIG9wdGlvblNlbGVjdDogZnVuY3Rpb24gb3B0aW9uU2VsZWN0KG9wdGlvbikge1xyXG5cdCAgICAgICAgICAgIGlmICghKG9wdGlvbi5kaXNhYmxlZCB8fCBvcHRpb24udHlwZSA9PT0gJ2RpdmlkZXInKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3B0aW9uLXNlbGVjdGVkJywgb3B0aW9uKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VPblNlbGVjdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcmVzdHJpY3RGb2N1czogZnVuY3Rpb24gcmVzdHJpY3RGb2N1cyhlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRlbHMuZHJvcGRvd24uY29udGFpbnMoZS50YXJnZXQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGVscy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yKCcudWktbWVudS1vcHRpb24nKS5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZWRpcmVjdEZvY3VzOiBmdW5jdGlvbiByZWRpcmVjdEZvY3VzKGUpIHtcclxuXHQgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGVscy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yKCcudWktbWVudS1vcHRpb24nKS5mb2N1cygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaU1lbnVPcHRpb246IF9VaU1lbnVPcHRpb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1Nob3dzRHJvcGRvd24yLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOClcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaU1lbnVPcHRpb24udnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NylcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaU1lbnVPcHRpb24udnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0XHJcblx0dmFyIF9VaUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlJY29uKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1JpcHBsZUluayk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1tZW51LW9wdGlvbicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICB0ZXh0OiBTdHJpbmcsXHJcblx0ICAgICAgICBpY29uOiBTdHJpbmcsXHJcblx0ICAgICAgICBzaG93SWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWNvbmRhcnlUZXh0OiBTdHJpbmcsXHJcblx0ICAgICAgICBzaG93U2Vjb25kYXJ5VGV4dDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJ0aWFsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd1aS1tZW51LWRlZmF1bHQnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3B0aW9uOiBPYmplY3RcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGlzRGl2aWRlcjogZnVuY3Rpb24gaXNEaXZpZGVyKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdkaXZpZGVyJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHBhcnRpYWxzOiB7XHJcblx0ICAgICAgICAndWktbWVudS1kZWZhdWx0JzogJ1xcbiAgICAgICAgICAgIDx1aS1pY29uXFxuICAgICAgICAgICAgICAgIGNsYXNzPVwidWktbWVudS1vcHRpb24taWNvblwiIDppY29uPVwiaWNvblwiIHYtaWY9XCJzaG93SWNvbiAmJiAhaXNEaXZpZGVyICYmIGljb25cIlxcbiAgICAgICAgICAgID48L3VpLWljb24+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLW1lbnUtb3B0aW9uLXRleHRcIiB2LXRleHQ9XCJ0ZXh0XCIgdi1pZj1cIiFpc0RpdmlkZXJcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVwidWktbWVudS1vcHRpb24tc2Vjb25kYXJ5LXRleHRcIiB2LXRleHQ9XCJzZWNvbmRhcnlUZXh0XCJcXG4gICAgICAgICAgICAgICAgdi1pZj1cInNob3dTZWNvbmRhcnlUZXh0ICYmICFpc0RpdmlkZXIgJiYgc2Vjb25kYXJ5VGV4dFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgJ1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaVJpcHBsZUluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5cdFxyXG5cdHZhciBfVWlSaXBwbGVJbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSaXBwbGVJbmspO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaGlkZVJpcHBsZUluazoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlSaXBwbGVJbms6IF9VaVJpcHBsZUluazIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMilcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVJpcHBsZUluay52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmlwcGxlSW5rLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc2xpc3QpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0dmFyIHN0YXJ0UmlwcGxlID0gZnVuY3Rpb24gc3RhcnRSaXBwbGUoZXZlbnRUeXBlLCBldmVudCkge1xyXG5cdCAgICB2YXIgaG9sZGVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuXHRcclxuXHQgICAgaWYgKCFfY2xhc3NsaXN0Mi5kZWZhdWx0Lmhhcyhob2xkZXIsICd1aS1yaXBwbGUtaW5rJykpIHtcclxuXHQgICAgICAgIGhvbGRlciA9IGhvbGRlci5xdWVyeVNlbGVjdG9yKCcudWktcmlwcGxlLWluaycpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKCFob2xkZXIpIHtcclxuXHQgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIHByZXYgPSBob2xkZXIuZ2V0QXR0cmlidXRlKCdkYXRhLXVpLWV2ZW50Jyk7XHJcblx0XHJcblx0ICAgIGlmIChwcmV2ICYmIHByZXYgIT09IGV2ZW50VHlwZSkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGhvbGRlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdWktZXZlbnQnLCBldmVudFR5cGUpO1xyXG5cdFxyXG5cdCAgICB2YXIgcmVjdCA9IGhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHQgICAgdmFyIHggPSBldmVudC5vZmZzZXRYO1xyXG5cdCAgICB2YXIgeTtcclxuXHRcclxuXHQgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgeSA9IGV2ZW50Lm9mZnNldFk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcclxuXHQgICAgICAgIHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIHJpcHBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgICB2YXIgbWF4O1xyXG5cdFxyXG5cdCAgICBpZiAocmVjdC53aWR0aCA9PT0gcmVjdC5oZWlnaHQpIHtcclxuXHQgICAgICAgIG1heCA9IHJlY3Qud2lkdGggKiAxLjQxMjtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIG1heCA9IE1hdGguc3FydChyZWN0LndpZHRoICogcmVjdC53aWR0aCArIHJlY3QuaGVpZ2h0ICogcmVjdC5oZWlnaHQpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBkaW0gPSBtYXggKiAyICsgJ3B4JztcclxuXHRcclxuXHQgICAgcmlwcGxlLnN0eWxlLndpZHRoID0gZGltO1xyXG5cdCAgICByaXBwbGUuc3R5bGUuaGVpZ2h0ID0gZGltO1xyXG5cdCAgICByaXBwbGUuc3R5bGUubWFyZ2luTGVmdCA9IC1tYXggKyB4ICsgJ3B4JztcclxuXHQgICAgcmlwcGxlLnN0eWxlLm1hcmdpblRvcCA9IC1tYXggKyB5ICsgJ3B4JztcclxuXHRcclxuXHQgICAgcmlwcGxlLmNsYXNzTmFtZSA9ICdyaXBwbGUnO1xyXG5cdCAgICBob2xkZXIuYXBwZW5kQ2hpbGQocmlwcGxlKTtcclxuXHRcclxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LmFkZChyaXBwbGUsICdoZWxkJyk7XHJcblx0ICAgIH0sIDApO1xyXG5cdFxyXG5cdCAgICB2YXIgcmVsZWFzZUV2ZW50ID0gZXZlbnRUeXBlID09PSAnbW91c2Vkb3duJyA/ICdtb3VzZXVwJyA6ICd0b3VjaGVuZCc7XHJcblx0XHJcblx0ICAgIHZhciByZWxlYXNlID0gZnVuY3Rpb24gcmVsZWFzZSgpIHtcclxuXHQgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIocmVsZWFzZUV2ZW50LCByZWxlYXNlKTtcclxuXHRcclxuXHQgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQuYWRkKHJpcHBsZSwgJ2RvbmUnKTtcclxuXHRcclxuXHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIGhvbGRlci5yZW1vdmVDaGlsZChyaXBwbGUpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghaG9sZGVyLmNoaWxkcmVuLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LnJlbW92ZShob2xkZXIsICdhY3RpdmUnKTtcclxuXHQgICAgICAgICAgICAgICAgaG9sZGVyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS11aS1ldmVudCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sIDQ1MCk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIocmVsZWFzZUV2ZW50LCByZWxlYXNlKTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZSkge1xyXG5cdCAgICBpZiAoZS5idXR0b24gPT09IDApIHtcclxuXHQgICAgICAgIHN0YXJ0UmlwcGxlKGUudHlwZSwgZSk7XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cdFxyXG5cdHZhciBoYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChlKSB7XHJcblx0ICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzKSB7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICBzdGFydFJpcHBsZShlLnR5cGUsIGUuY2hhbmdlZFRvdWNoZXNbaV0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1yaXBwbGUtaW5rJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHRyaWdnZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBFbGVtZW50LFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdG9yeTogZnVuY3Rpb24gYmVmb3JlRGVzdG9yeSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKTtcclxuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoU3RhcnQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcblx0XHJcblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHR2YXIgdHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xyXG5cdHZhciB3aGl0ZXNwYWNlID0gL1xccysvZztcclxuXHRcclxuXHRmdW5jdGlvbiBpbnRlcnByZXQoaW5wdXQpIHtcclxuXHQgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dC5yZXBsYWNlKHRyaW0sICcnKS5zcGxpdCh3aGl0ZXNwYWNlKSA6IGlucHV0O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBjbGFzc2VzKGVsKSB7XHJcblx0ICAgIGlmIChpc0VsZW1lbnQoZWwpKSB7XHJcblx0ICAgICAgICByZXR1cm4gZWwuY2xhc3NOYW1lLnJlcGxhY2UodHJpbSwgJycpLnNwbGl0KHdoaXRlc3BhY2UpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBbXTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gc2V0KGVsLCBpbnB1dCkge1xyXG5cdCAgICBpZiAoaXNFbGVtZW50KGVsKSkge1xyXG5cdCAgICAgICAgZWwuY2xhc3NOYW1lID0gaW50ZXJwcmV0KGlucHV0KS5qb2luKCcgJyk7XHJcblx0ICAgIH1cclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gYWRkKGVsLCBpbnB1dCkge1xyXG5cdCAgICB2YXIgY3VycmVudCA9IHJlbW92ZShlbCwgaW5wdXQpO1xyXG5cdCAgICB2YXIgdmFsdWVzID0gaW50ZXJwcmV0KGlucHV0KTtcclxuXHRcclxuXHQgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIHZhbHVlcyk7XHJcblx0ICAgIHNldChlbCwgY3VycmVudCk7XHJcblx0XHJcblx0ICAgIHJldHVybiBjdXJyZW50O1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiByZW1vdmUoZWwsIGlucHV0KSB7XHJcblx0ICAgIHZhciBjdXJyZW50ID0gY2xhc3NlcyhlbCk7XHJcblx0ICAgIHZhciB2YWx1ZXMgPSBpbnRlcnByZXQoaW5wdXQpO1xyXG5cdFxyXG5cdCAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciBpID0gY3VycmVudC5pbmRleE9mKHZhbHVlKTtcclxuXHQgICAgICAgIGlmIChpICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgc2V0KGVsLCBjdXJyZW50KTtcclxuXHRcclxuXHQgICAgcmV0dXJuIGN1cnJlbnQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGNvbnRhaW5zKGVsLCBpbnB1dCkge1xyXG5cdCAgICB2YXIgY3VycmVudCA9IGNsYXNzZXMoZWwpO1xyXG5cdCAgICB2YXIgdmFsdWVzID0gaW50ZXJwcmV0KGlucHV0KTtcclxuXHRcclxuXHQgICAgcmV0dXJuIHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiBjdXJyZW50LmluZGV4T2YodmFsdWUpICE9PSAtMTtcclxuXHQgICAgfSk7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XHJcblx0ICAgIHZhciBlbGVtZW50T2JqZWN0cyA9ICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoSFRNTEVsZW1lbnQpKSA9PT0gJ29iamVjdCc7XHJcblx0XHJcblx0ICAgIHJldHVybiBlbGVtZW50T2JqZWN0cyA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IGlzRWxlbWVudE9iamVjdChvKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gaXNFbGVtZW50T2JqZWN0KG8pIHtcclxuXHQgICAgcmV0dXJuIG8gJiYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKG8pKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmIG8ubm9kZVR5cGUgPT09IDE7XHJcblx0fVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgYWRkOiBhZGQsXHJcblx0ICAgIHJlbW92ZTogcmVtb3ZlLFxyXG5cdCAgICBjb250YWluczogY29udGFpbnMsXHJcblx0ICAgIGhhczogY29udGFpbnMsXHJcblx0ICAgIHNldDogc2V0LFxyXG5cdCAgICBnZXQ6IGNsYXNzZXNcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdHZhciBfU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSlbXCJkZWZhdWx0XCJdO1xyXG5cdFxyXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKG9iaikge1xyXG5cdCAgcmV0dXJuIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9TeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcclxuXHR9O1xyXG5cdFxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCkuU3ltYm9sO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHQvLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXHJcblx0dmFyICQgICAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOClcclxuXHQgICwgZ2xvYmFsICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxyXG5cdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXHJcblx0ICAsIERFU0NSSVBUT1JTICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSlcclxuXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKVxyXG5cdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpXHJcblx0ICAsICRmYWlscyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMilcclxuXHQgICwgc2hhcmVkICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKVxyXG5cdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpXHJcblx0ICAsIHVpZCAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MylcclxuXHQgICwgd2tzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKVxyXG5cdCAgLCBrZXlPZiAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpXHJcblx0ICAsICRuYW1lcyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSlcclxuXHQgICwgZW51bUtleXMgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKVxyXG5cdCAgLCBpc0FycmF5ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpXHJcblx0ICAsIGFuT2JqZWN0ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MilcclxuXHQgICwgdG9JT2JqZWN0ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KVxyXG5cdCAgLCBjcmVhdGVEZXNjICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpXHJcblx0ICAsIGdldERlc2MgICAgICAgID0gJC5nZXREZXNjXHJcblx0ICAsIHNldERlc2MgICAgICAgID0gJC5zZXREZXNjXHJcblx0ICAsIF9jcmVhdGUgICAgICAgID0gJC5jcmVhdGVcclxuXHQgICwgZ2V0TmFtZXMgICAgICAgPSAkbmFtZXMuZ2V0XHJcblx0ICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxyXG5cdCAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXHJcblx0ICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XHJcblx0ICAsIHNldHRlciAgICAgICAgID0gZmFsc2VcclxuXHQgICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxyXG5cdCAgLCBpc0VudW0gICAgICAgICA9ICQuaXNFbnVtXHJcblx0ICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxyXG5cdCAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXHJcblx0ICAsIHVzZU5hdGl2ZSAgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xyXG5cdCAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdC5wcm90b3R5cGU7XHJcblx0XHJcblx0Ly8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XHJcblx0dmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcclxuXHQgIHJldHVybiBfY3JlYXRlKHNldERlc2Moe30sICdhJywge1xyXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBzZXREZXNjKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxyXG5cdCAgfSkpLmEgIT0gNztcclxuXHR9KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xyXG5cdCAgdmFyIHByb3RvRGVzYyA9IGdldERlc2MoT2JqZWN0UHJvdG8sIGtleSk7XHJcblx0ICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XHJcblx0ICBzZXREZXNjKGl0LCBrZXksIEQpO1xyXG5cdCAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylzZXREZXNjKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XHJcblx0fSA6IHNldERlc2M7XHJcblx0XHJcblx0dmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xyXG5cdCAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbC5wcm90b3R5cGUpO1xyXG5cdCAgc3ltLl9rID0gdGFnO1xyXG5cdCAgREVTQ1JJUFRPUlMgJiYgc2V0dGVyICYmIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge1xyXG5cdCAgICBjb25maWd1cmFibGU6IHRydWUsXHJcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xyXG5cdCAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcclxuXHQgICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xyXG5cdCAgICB9XHJcblx0ICB9KTtcclxuXHQgIHJldHVybiBzeW07XHJcblx0fTtcclxuXHRcclxuXHR2YXIgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xyXG5cdH07XHJcblx0XHJcblx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xyXG5cdCAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSl7XHJcblx0ICAgIGlmKCFELmVudW1lcmFibGUpe1xyXG5cdCAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XHJcblx0ICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xyXG5cdCAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xyXG5cdCAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xyXG5cdCAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcclxuXHR9O1xyXG5cdHZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xyXG5cdCAgYW5PYmplY3QoaXQpO1xyXG5cdCAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxyXG5cdCAgICAsIGkgICAgPSAwXHJcblx0ICAgICwgbCA9IGtleXMubGVuZ3RoXHJcblx0ICAgICwga2V5O1xyXG5cdCAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XHJcblx0ICByZXR1cm4gaXQ7XHJcblx0fTtcclxuXHR2YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XHJcblx0ICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XHJcblx0fTtcclxuXHR2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcclxuXHQgIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5KTtcclxuXHQgIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cclxuXHQgICAgPyBFIDogdHJ1ZTtcclxuXHR9O1xyXG5cdHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xyXG5cdCAgdmFyIEQgPSBnZXREZXNjKGl0ID0gdG9JT2JqZWN0KGl0KSwga2V5KTtcclxuXHQgIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xyXG5cdCAgcmV0dXJuIEQ7XHJcblx0fTtcclxuXHR2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcclxuXHQgIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxyXG5cdCAgICAsIHJlc3VsdCA9IFtdXHJcblx0ICAgICwgaSAgICAgID0gMFxyXG5cdCAgICAsIGtleTtcclxuXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOKXJlc3VsdC5wdXNoKGtleSk7XHJcblx0ICByZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblx0dmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xyXG5cdCAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXHJcblx0ICAgICwgcmVzdWx0ID0gW11cclxuXHQgICAgLCBpICAgICAgPSAwXHJcblx0ICAgICwga2V5O1xyXG5cdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcclxuXHQgIHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHR2YXIgJHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XHJcblx0ICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcclxuXHQgIHZhciBhcmdzID0gW2l0XVxyXG5cdCAgICAsIGkgICAgPSAxXHJcblx0ICAgICwgJCQgICA9IGFyZ3VtZW50c1xyXG5cdCAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XHJcblx0ICB3aGlsZSgkJC5sZW5ndGggPiBpKWFyZ3MucHVzaCgkJFtpKytdKTtcclxuXHQgIHJlcGxhY2VyID0gYXJnc1sxXTtcclxuXHQgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xyXG5cdCAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG5cdCAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuXHQgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XHJcblx0ICB9O1xyXG5cdCAgYXJnc1sxXSA9IHJlcGxhY2VyO1xyXG5cdCAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xyXG5cdH07XHJcblx0dmFyIGJ1Z2d5SlNPTiA9ICRmYWlscyhmdW5jdGlvbigpe1xyXG5cdCAgdmFyIFMgPSAkU3ltYm9sKCk7XHJcblx0ICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxyXG5cdCAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXHJcblx0ICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xyXG5cdCAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9JztcclxuXHR9KTtcclxuXHRcclxuXHQvLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcclxuXHRpZighdXNlTmF0aXZlKXtcclxuXHQgICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcclxuXHQgICAgaWYoaXNTeW1ib2wodGhpcykpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcclxuXHQgICAgcmV0dXJuIHdyYXAodWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKSk7XHJcblx0ICB9O1xyXG5cdCAgcmVkZWZpbmUoJFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcblx0ICAgIHJldHVybiB0aGlzLl9rO1xyXG5cdCAgfSk7XHJcblx0XHJcblx0ICBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgICAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcclxuXHQgIH07XHJcblx0XHJcblx0ICAkLmNyZWF0ZSAgICAgPSAkY3JlYXRlO1xyXG5cdCAgJC5pc0VudW0gICAgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG5cdCAgJC5nZXREZXNjICAgID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHQgICQuc2V0RGVzYyAgICA9ICRkZWZpbmVQcm9wZXJ0eTtcclxuXHQgICQuc2V0RGVzY3MgICA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xyXG5cdCAgJC5nZXROYW1lcyAgID0gJG5hbWVzLmdldCA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xyXG5cdCAgJC5nZXRTeW1ib2xzID0gJGdldE93blByb3BlcnR5U3ltYm9scztcclxuXHRcclxuXHQgIGlmKERFU0NSSVBUT1JTICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSl7XHJcblx0ICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHR2YXIgc3ltYm9sU3RhdGljcyA9IHtcclxuXHQgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxyXG5cdCAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XHJcblx0ICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcclxuXHQgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cclxuXHQgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XHJcblx0ICB9LFxyXG5cdCAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXHJcblx0ICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xyXG5cdCAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XHJcblx0ICB9LFxyXG5cdCAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxyXG5cdCAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxyXG5cdH07XHJcblx0Ly8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXHJcblx0Ly8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxyXG5cdC8vIDE5LjQuMi40IFN5bWJvbC5pdGVyYXRvclxyXG5cdC8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxyXG5cdC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXHJcblx0Ly8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxyXG5cdC8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xyXG5cdC8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcclxuXHQvLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXHJcblx0Ly8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xyXG5cdC8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcclxuXHQkLmVhY2guY2FsbCgoXHJcblx0ICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xyXG5cdCAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXHJcblx0KS5zcGxpdCgnLCcpLCBmdW5jdGlvbihpdCl7XHJcblx0ICB2YXIgc3ltID0gd2tzKGl0KTtcclxuXHQgIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xyXG5cdH0pO1xyXG5cdFxyXG5cdHNldHRlciA9IHRydWU7XHJcblx0XHJcblx0JGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcclxuXHRcclxuXHQkZXhwb3J0KCRleHBvcnQuUywgJ1N5bWJvbCcsIHN5bWJvbFN0YXRpY3MpO1xyXG5cdFxyXG5cdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXVzZU5hdGl2ZSwgJ09iamVjdCcsIHtcclxuXHQgIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxuXHQgIGNyZWF0ZTogJGNyZWF0ZSxcclxuXHQgIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxyXG5cdCAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcclxuXHQgIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXHJcblx0ICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcclxuXHQgIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcclxuXHQgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcclxuXHQgIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXHJcblx0ICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcclxuXHQgIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcclxuXHQgIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xyXG5cdH0pO1xyXG5cdFxyXG5cdC8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxyXG5cdCRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCF1c2VOYXRpdmUgfHwgYnVnZ3lKU09OKSwgJ0pTT04nLCB7c3RyaW5naWZ5OiAkc3RyaW5naWZ5fSk7XHJcblx0XHJcblx0Ly8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxyXG5cdHNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcclxuXHQvLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXHJcblx0c2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcclxuXHQvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxyXG5cdHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciAkT2JqZWN0ID0gT2JqZWN0O1xyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXHJcblx0ICBnZXRQcm90bzogICAkT2JqZWN0LmdldFByb3RvdHlwZU9mLFxyXG5cdCAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXHJcblx0ICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcclxuXHQgIHNldERlc2M6ICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHksXHJcblx0ICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXHJcblx0ICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXHJcblx0ICBnZXROYW1lczogICAkT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXHJcblx0ICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcclxuXHQgIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XHJcblx0dmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXHJcblx0ICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcblx0aWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xyXG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XHJcblx0bW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygzMikoZnVuY3Rpb24oKXtcclxuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcblx0fSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcclxuXHQgIHRyeSB7XHJcblx0ICAgIHJldHVybiAhIWV4ZWMoKTtcclxuXHQgIH0gY2F0Y2goZSl7XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIGdsb2JhbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXHJcblx0ICAsIGNvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpXHJcblx0ICAsIGN0eCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpXHJcblx0ICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xyXG5cdFxyXG5cdHZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcclxuXHQgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXHJcblx0ICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xyXG5cdCAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcclxuXHQgICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXHJcblx0ICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxyXG5cdCAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcclxuXHQgICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxyXG5cdCAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cclxuXHQgICAgLCBrZXksIG93biwgb3V0O1xyXG5cdCAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XHJcblx0ICBmb3Ioa2V5IGluIHNvdXJjZSl7XHJcblx0ICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxyXG5cdCAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xyXG5cdCAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XHJcblx0ICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXHJcblx0ICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XHJcblx0ICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xyXG5cdCAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxyXG5cdCAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxyXG5cdCAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxyXG5cdCAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxyXG5cdCAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xyXG5cdCAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBDID8gbmV3IEMocGFyYW0pIDogQyhwYXJhbSk7XHJcblx0ICAgICAgfTtcclxuXHQgICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XHJcblx0ICAgICAgcmV0dXJuIEY7XHJcblx0ICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xyXG5cdCAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XHJcblx0ICAgIGlmKElTX1BST1RPKShleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KSlba2V5XSA9IG91dDtcclxuXHQgIH1cclxuXHR9O1xyXG5cdC8vIHR5cGUgYml0bWFwXHJcblx0JGV4cG9ydC5GID0gMTsgIC8vIGZvcmNlZFxyXG5cdCRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcclxuXHQkZXhwb3J0LlMgPSA0OyAgLy8gc3RhdGljXHJcblx0JGV4cG9ydC5QID0gODsgIC8vIHByb3RvXHJcblx0JGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcclxuXHQkZXhwb3J0LlcgPSAzMjsgLy8gd3JhcFxyXG5cdG1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcxLjIuNid9O1xyXG5cdGlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG5cclxuLyoqKi8gfSxcclxuLyogMzUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xyXG5cdHZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xyXG5cdCAgYUZ1bmN0aW9uKGZuKTtcclxuXHQgIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XHJcblx0ICBzd2l0Y2gobGVuZ3RoKXtcclxuXHQgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XHJcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XHJcblx0ICAgIH07XHJcblx0ICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xyXG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcclxuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcclxuXHQgICAgfTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuXHQgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XHJcblx0ICB9O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xyXG5cdCAgcmV0dXJuIGl0O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDM4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgJCAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXHJcblx0ICAsIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcclxuXHQgIHJldHVybiAkLnNldERlc2Mob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcclxuXHR9IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcclxuXHQgIG9iamVjdFtrZXldID0gdmFsdWU7XHJcblx0ICByZXR1cm4gb2JqZWN0O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAzOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcclxuXHQgIHJldHVybiB7XHJcblx0ICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcclxuXHQgICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxyXG5cdCAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXHJcblx0ICAgIHZhbHVlICAgICAgIDogdmFsdWVcclxuXHQgIH07XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDQwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcclxuXHQgICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcclxuXHQgICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuXHQgIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIGRlZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLnNldERlc2NcclxuXHQgICwgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcclxuXHQgICwgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MikoJ3RvU3RyaW5nVGFnJyk7XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcclxuXHQgIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBzdG9yZSAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSgnd2tzJylcclxuXHQgICwgdWlkICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MylcclxuXHQgICwgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSkuU3ltYm9sO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcblx0ICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cclxuXHQgICAgU3ltYm9sICYmIFN5bWJvbFtuYW1lXSB8fCAoU3ltYm9sIHx8IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIGlkID0gMFxyXG5cdCAgLCBweCA9IE1hdGgucmFuZG9tKCk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG5cdCAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciAkICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxyXG5cdCAgLCB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xyXG5cdCAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXHJcblx0ICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXHJcblx0ICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuXHQgICAgLCBpbmRleCAgPSAwXHJcblx0ICAgICwga2V5O1xyXG5cdCAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xyXG5cdHZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NilcclxuXHQgICwgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcclxuXHR2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcclxuXHQgIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xyXG5cdCAgcmV0dXJuIGl0O1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA0OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xyXG5cdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KVxyXG5cdCAgLCBnZXROYW1lcyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KS5nZXROYW1lc1xyXG5cdCAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcclxuXHRcclxuXHR2YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcblx0ICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcclxuXHRcclxuXHR2YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICB0cnkge1xyXG5cdCAgICByZXR1cm4gZ2V0TmFtZXMoaXQpO1xyXG5cdCAgfSBjYXRjaChlKXtcclxuXHQgICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcclxuXHQgIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XHJcblx0ICByZXR1cm4gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDUwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xyXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICB2YXIga2V5cyAgICAgICA9ICQuZ2V0S2V5cyhpdClcclxuXHQgICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzO1xyXG5cdCAgaWYoZ2V0U3ltYm9scyl7XHJcblx0ICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcclxuXHQgICAgICAsIGlzRW51bSAgPSAkLmlzRW51bVxyXG5cdCAgICAgICwgaSAgICAgICA9IDBcclxuXHQgICAgICAsIGtleTtcclxuXHQgICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKWtleXMucHVzaChrZXkpO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGtleXM7XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDUxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxyXG5cdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJnKXtcclxuXHQgIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcclxuXHQgIHJldHVybiBpdDtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDU1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA1NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXJpcHBsZS1pbmtcXFwiPjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48YVxcbiAgICBjbGFzcz1cXFwidWktbWVudS1vcHRpb25cXFwiIHJvbGU9XFxcIm1lbnUtaXRlbVxcXCIgOnRhYmluZGV4PVxcXCIoaXNEaXZpZGVyIHx8IGRpc2FibGVkKSA/IG51bGwgOiAnMCdcXFwiXFxuICAgIDpjbGFzcz1cXFwieyAnZGl2aWRlcic6IGlzRGl2aWRlciwgJ2Rpc2FibGVkJyA6IGRpc2FibGVkIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tZW51LW9wdGlvbi1jb250ZW50XFxcIiA6Y2xhc3M9XFxcIltwYXJ0aWFsXVxcXCI+XFxuICAgICAgICA8cGFydGlhbCA6bmFtZT1cXFwicGFydGlhbFxcXCI+PC9wYXJ0aWFsPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPHVpLXJpcHBsZS1pbmtcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxcXFwiIHYtaWY9XFxcIiFoaWRlUmlwcGxlSW5rICYmICFkaXNhYmxlZCAmJiAhaXNEaXZpZGVyXFxcIlxcbiAgICA+PC91aS1yaXBwbGUtaW5rPlxcbjwvYT5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDU4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF90ZXRoZXJEcm9wID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XHJcblx0XHJcblx0dmFyIF90ZXRoZXJEcm9wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RldGhlckRyb3ApO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NsaXN0KTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nLFxyXG5cdCAgICAgICAgdHJpZ2dlcjogRWxlbWVudCxcclxuXHQgICAgICAgIGNvbnRhaW5Gb2N1czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRyb3Bkb3duUG9zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2JvdHRvbSBsZWZ0J1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW5Pbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnY2xpY2snIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgZHJvcDogbnVsbCxcclxuXHQgICAgICAgICAgICBsYXN0Rm9jdXNzZWRFbGVtZW50OiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmlnZ2VyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRHJvcGRvd24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyb3AucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wLmRlc3Ryb3koKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAndWktZHJvcGRvd246Om9wZW4nOiBmdW5jdGlvbiB1aURyb3Bkb3duT3BlbihpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5vcGVuRHJvcGRvd24oKTtcclxuXHQgICAgICAgIH0sXHJcblx0XHJcblx0ICAgICAgICAndWktZHJvcGRvd246OmNsb3NlJzogZnVuY3Rpb24gdWlEcm9wZG93bkNsb3NlKGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuXHQgICAgICAgIH0sXHJcblx0XHJcblx0ICAgICAgICAndWktZHJvcGRvd246OnRvZ2dsZSc6IGZ1bmN0aW9uIHVpRHJvcGRvd25Ub2dnbGUoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudG9nZ2xlRHJvcGRvd24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgaW5pdGlhbGl6ZURyb3Bkb3duOiBmdW5jdGlvbiBpbml0aWFsaXplRHJvcGRvd24oKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wID0gbmV3IF90ZXRoZXJEcm9wMi5kZWZhdWx0KHtcclxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRyaWdnZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuJGVscy5kcm9wZG93bixcclxuXHQgICAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMuZHJvcGRvd25Qb3NpdGlvbixcclxuXHQgICAgICAgICAgICAgICAgY29uc3RyYWluVG9XaW5kb3c6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgIG9wZW5PbjogdGhpcy5vcGVuT25cclxuXHQgICAgICAgICAgICB9KTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kcm9wZG93blBvc2l0aW9uICE9PSAnYm90dG9tIGxlZnQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5vcGVuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5jbG9zZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyb3Aub3BlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyb3AuY2xvc2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5kcm9wLm9uKCdvcGVuJywgdGhpcy5wb3NpdGlvbkRyb3ApO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJvcC5vbignb3BlbicsIHRoaXMuZHJvcGRvd25PcGVuZWQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZHJvcC5vbignY2xvc2UnLCB0aGlzLmRyb3Bkb3duQ2xvc2VkKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcGVuRHJvcGRvd246IGZ1bmN0aW9uIG9wZW5Ecm9wZG93bigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kcm9wKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5vcGVuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBvc2l0aW9uRHJvcDogZnVuY3Rpb24gcG9zaXRpb25Ecm9wKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBkcm9wID0gdGhpcy5kcm9wO1xyXG5cdCAgICAgICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBkcm9wV2lkdGggPSBkcm9wLmRyb3AuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBkcm9wLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xyXG5cdCAgICAgICAgICAgIHZhciBhdmFpbGFibGVTcGFjZSA9IHdpbmRvd1dpZHRoIC0gbGVmdDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoZHJvcFdpZHRoID4gYXZhaWxhYmxlU3BhY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRyb3BXaWR0aCA+IGF2YWlsYWJsZVNwYWNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgZHJvcC50ZXRoZXIuYXR0YWNobWVudC5sZWZ0ID0gZGlyZWN0aW9uO1xyXG5cdCAgICAgICAgICAgICAgICBkcm9wLnRldGhlci50YXJnZXRBdHRhY2htZW50LmxlZnQgPSBkaXJlY3Rpb247XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGRyb3AucG9zaXRpb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VEcm9wZG93bjogZnVuY3Rpb24gY2xvc2VEcm9wZG93bigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kcm9wKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJvcC5jbG9zZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0b2dnbGVEcm9wZG93bjogZnVuY3Rpb24gdG9nZ2xlRHJvcGRvd24oZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRyb3ApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wLnRvZ2dsZShlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHJvcGRvd25PcGVuZWQ6IGZ1bmN0aW9uIGRyb3Bkb3duT3BlbmVkKCkge1xyXG5cdCAgICAgICAgICAgIF9jbGFzc2xpc3QyLmRlZmF1bHQuYWRkKHRoaXMudHJpZ2dlciwgJ2Ryb3Bkb3duLW9wZW4nKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RGb2N1c3NlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGVscy5kcm9wZG93bi5mb2N1cygpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkcm9wZG93bi1vcGVuZWQnKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkcm9wZG93bkNsb3NlZDogZnVuY3Rpb24gZHJvcGRvd25DbG9zZWQoKSB7XHJcblx0ICAgICAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5yZW1vdmUodGhpcy50cmlnZ2VyLCAnZHJvcGRvd24tb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxhc3RGb2N1c3NlZEVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5sYXN0Rm9jdXNzZWRFbGVtZW50LmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkcm9wZG93bi1jbG9zZWQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qISB0ZXRoZXItZHJvcCAxLjQuMSAqL1xyXG5cdFxyXG5cdChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0ICBpZiAodHJ1ZSkge1xyXG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXyg2MCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCd0ZXRoZXInKSk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICByb290LkRyb3AgPSBmYWN0b3J5KHJvb3QuVGV0aGVyKTtcclxuXHQgIH1cclxuXHR9KHRoaXMsIGZ1bmN0aW9uKFRldGhlcikge1xyXG5cdFxyXG5cdC8qIGdsb2JhbCBUZXRoZXIgKi9cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9iaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XHJcblx0XHJcblx0dmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XHJcblx0XHJcblx0dmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcclxuXHRcclxuXHR2YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDIsIF94MywgX3g0KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MiwgcHJvcGVydHkgPSBfeDMsIHJlY2VpdmVyID0gX3g0OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MiA9IHBhcmVudDsgX3gzID0gcHJvcGVydHk7IF94NCA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XHJcblx0XHJcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XHJcblx0XHJcblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cclxuXHRcclxuXHR2YXIgX1RldGhlciRVdGlscyA9IFRldGhlci5VdGlscztcclxuXHR2YXIgZXh0ZW5kID0gX1RldGhlciRVdGlscy5leHRlbmQ7XHJcblx0dmFyIGFkZENsYXNzID0gX1RldGhlciRVdGlscy5hZGRDbGFzcztcclxuXHR2YXIgcmVtb3ZlQ2xhc3MgPSBfVGV0aGVyJFV0aWxzLnJlbW92ZUNsYXNzO1xyXG5cdHZhciBoYXNDbGFzcyA9IF9UZXRoZXIkVXRpbHMuaGFzQ2xhc3M7XHJcblx0dmFyIEV2ZW50ZWQgPSBfVGV0aGVyJFV0aWxzLkV2ZW50ZWQ7XHJcblx0XHJcblx0ZnVuY3Rpb24gc29ydEF0dGFjaChzdHIpIHtcclxuXHQgIHZhciBfc3RyJHNwbGl0ID0gc3RyLnNwbGl0KCcgJyk7XHJcblx0XHJcblx0ICB2YXIgX3N0ciRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfc3RyJHNwbGl0LCAyKTtcclxuXHRcclxuXHQgIHZhciBmaXJzdCA9IF9zdHIkc3BsaXQyWzBdO1xyXG5cdCAgdmFyIHNlY29uZCA9IF9zdHIkc3BsaXQyWzFdO1xyXG5cdFxyXG5cdCAgaWYgKFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZmlyc3QpID49IDApIHtcclxuXHQgICAgdmFyIF9yZWYgPSBbc2Vjb25kLCBmaXJzdF07XHJcblx0ICAgIGZpcnN0ID0gX3JlZlswXTtcclxuXHQgICAgc2Vjb25kID0gX3JlZlsxXTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBbZmlyc3QsIHNlY29uZF0uam9pbignICcpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyLCBpdGVtKSB7XHJcblx0ICB2YXIgaW5kZXggPSB1bmRlZmluZWQ7XHJcblx0ICB2YXIgcmVzdWx0cyA9IFtdO1xyXG5cdCAgd2hpbGUgKChpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pKSAhPT0gLTEpIHtcclxuXHQgICAgcmVzdWx0cy5wdXNoKGFyci5zcGxpY2UoaW5kZXgsIDEpKTtcclxuXHQgIH1cclxuXHQgIHJldHVybiByZXN1bHRzO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgY2xpY2tFdmVudHMgPSBbJ2NsaWNrJ107XHJcblx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG5cdCAgY2xpY2tFdmVudHMucHVzaCgndG91Y2hzdGFydCcpO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgdHJhbnNpdGlvbkVuZEV2ZW50cyA9IHtcclxuXHQgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxyXG5cdCAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXHJcblx0ICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnLFxyXG5cdCAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCdcclxuXHR9O1xyXG5cdFxyXG5cdHZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnJztcclxuXHRmb3IgKHZhciBfbmFtZSBpbiB0cmFuc2l0aW9uRW5kRXZlbnRzKSB7XHJcblx0ICBpZiAoKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyYW5zaXRpb25FbmRFdmVudHMsIF9uYW1lKSkge1xyXG5cdCAgICB2YXIgdGVtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG5cdCAgICBpZiAodHlwZW9mIHRlbXBFbC5zdHlsZVtfbmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gdHJhbnNpdGlvbkVuZEV2ZW50c1tfbmFtZV07XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9XHJcblx0XHJcblx0dmFyIE1JUlJPUl9BVFRBQ0ggPSB7XHJcblx0ICBsZWZ0OiAncmlnaHQnLFxyXG5cdCAgcmlnaHQ6ICdsZWZ0JyxcclxuXHQgIHRvcDogJ2JvdHRvbScsXHJcblx0ICBib3R0b206ICd0b3AnLFxyXG5cdCAgbWlkZGxlOiAnbWlkZGxlJyxcclxuXHQgIGNlbnRlcjogJ2NlbnRlcidcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBhbGxEcm9wcyA9IHt9O1xyXG5cdFxyXG5cdC8vIERyb3AgY2FuIGJlIGluY2x1ZGVkIGluIGV4dGVybmFsIGxpYnJhcmllcy4gIENhbGxpbmcgY3JlYXRlQ29udGV4dCBnaXZlcyB5b3UgYSBmcmVzaFxyXG5cdC8vIGNvcHkgb2YgZHJvcCB3aGljaCB3b24ndCBpbnRlcmFjdCB3aXRoIG90aGVyIGNvcGllcyBvbiB0aGUgcGFnZSAoYmV5b25kIGNhbGxpbmcgdGhlIGRvY3VtZW50IGV2ZW50cykuXHJcblx0XHJcblx0ZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcclxuXHQgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XHJcblx0XHJcblx0ICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoKSB7XHJcblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gbmV3IChfYmluZC5hcHBseShEcm9wSW5zdGFuY2UsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xyXG5cdCAgfTtcclxuXHRcclxuXHQgIGV4dGVuZChkcm9wLCB7XHJcblx0ICAgIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXHJcblx0ICAgIGRyb3BzOiBbXSxcclxuXHQgICAgZGVmYXVsdHM6IHt9XHJcblx0ICB9KTtcclxuXHRcclxuXHQgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuXHQgICAgY2xhc3NQcmVmaXg6ICdkcm9wJyxcclxuXHQgICAgZGVmYXVsdHM6IHtcclxuXHQgICAgICBwb3NpdGlvbjogJ2JvdHRvbSBsZWZ0JyxcclxuXHQgICAgICBvcGVuT246ICdjbGljaycsXHJcblx0ICAgICAgYmVmb3JlQ2xvc2U6IG51bGwsXHJcblx0ICAgICAgY29uc3RyYWluVG9TY3JvbGxQYXJlbnQ6IHRydWUsXHJcblx0ICAgICAgY29uc3RyYWluVG9XaW5kb3c6IHRydWUsXHJcblx0ICAgICAgY2xhc3NlczogJycsXHJcblx0ICAgICAgcmVtb3ZlOiBmYWxzZSxcclxuXHQgICAgICBvcGVuRGVsYXk6IDAsXHJcblx0ICAgICAgY2xvc2VEZWxheTogNTAsXHJcblx0ICAgICAgLy8gaW5oZXJpdGVkIGZyb20gb3BlbkRlbGF5IGFuZCBjbG9zZURlbGF5IGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuXHQgICAgICBmb2N1c0RlbGF5OiBudWxsLFxyXG5cdCAgICAgIGJsdXJEZWxheTogbnVsbCxcclxuXHQgICAgICBob3Zlck9wZW5EZWxheTogbnVsbCxcclxuXHQgICAgICBob3ZlckNsb3NlRGVsYXk6IG51bGwsXHJcblx0ICAgICAgdGV0aGVyT3B0aW9uczoge31cclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHRcclxuXHQgIGV4dGVuZChkcm9wLCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XHJcblx0ICBleHRlbmQoZHJvcC5kZWZhdWx0cywgZGVmYXVsdE9wdGlvbnMuZGVmYXVsdHMsIG9wdGlvbnMuZGVmYXVsdHMpO1xyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiBhbGxEcm9wc1tkcm9wLmNsYXNzUHJlZml4XSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgYWxsRHJvcHNbZHJvcC5jbGFzc1ByZWZpeF0gPSBbXTtcclxuXHQgIH1cclxuXHRcclxuXHQgIGRyb3AudXBkYXRlQm9keUNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIGJvZHksIHNvIGRlc3BpdGUgdGhlIGNvbnRleHQgY29uY2VwdCwgd2Ugc3RpbGwgaXRlcmF0ZSB0aHJvdWdoIGFsbFxyXG5cdCAgICAvLyBkcm9wcyB3aGljaCBzaGFyZSBvdXIgY2xhc3NQcmVmaXguXHJcblx0XHJcblx0ICAgIHZhciBhbnlPcGVuID0gZmFsc2U7XHJcblx0ICAgIHZhciBkcm9wcyA9IGFsbERyb3BzW2Ryb3AuY2xhc3NQcmVmaXhdO1xyXG5cdCAgICB2YXIgbGVuID0gZHJvcHMubGVuZ3RoO1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcblx0ICAgICAgaWYgKGRyb3BzW2ldLmlzT3BlbmVkKCkpIHtcclxuXHQgICAgICAgIGFueU9wZW4gPSB0cnVlO1xyXG5cdCAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmIChhbnlPcGVuKSB7XHJcblx0ICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIGRyb3AuY2xhc3NQcmVmaXggKyAnLW9wZW4nKTtcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHRcclxuXHQgIHZhciBEcm9wSW5zdGFuY2UgPSAoZnVuY3Rpb24gKF9FdmVudGVkKSB7XHJcblx0ICAgIF9pbmhlcml0cyhEcm9wSW5zdGFuY2UsIF9FdmVudGVkKTtcclxuXHRcclxuXHQgICAgZnVuY3Rpb24gRHJvcEluc3RhbmNlKG9wdHMpIHtcclxuXHQgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcEluc3RhbmNlKTtcclxuXHRcclxuXHQgICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihEcm9wSW5zdGFuY2UucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcclxuXHQgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRyb3AuZGVmYXVsdHMsIG9wdHMpO1xyXG5cdCAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5vcHRpb25zLnRhcmdldDtcclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMudGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wIEVycm9yOiBZb3UgbXVzdCBwcm92aWRlIGEgdGFyZ2V0LicpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgZGF0YVByZWZpeCA9ICdkYXRhLScgKyBkcm9wLmNsYXNzUHJlZml4O1xyXG5cdFxyXG5cdCAgICAgIHZhciBjb250ZW50QXR0ciA9IHRoaXMudGFyZ2V0LmdldEF0dHJpYnV0ZShkYXRhUHJlZml4KTtcclxuXHQgICAgICBpZiAoY29udGVudEF0dHIgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnQgPT0gbnVsbCkge1xyXG5cdCAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnQgPSBjb250ZW50QXR0cjtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgdmFyIGF0dHJzT3ZlcnJpZGUgPSBbJ3Bvc2l0aW9uJywgJ29wZW5PbiddO1xyXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnNPdmVycmlkZS5sZW5ndGg7ICsraSkge1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIG92ZXJyaWRlID0gdGhpcy50YXJnZXQuZ2V0QXR0cmlidXRlKGRhdGFQcmVmaXggKyAnLScgKyBhdHRyc092ZXJyaWRlW2ldKTtcclxuXHQgICAgICAgIGlmIChvdmVycmlkZSAmJiB0aGlzLm9wdGlvbnNbYXR0cnNPdmVycmlkZVtpXV0gPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICB0aGlzLm9wdGlvbnNbYXR0cnNPdmVycmlkZVtpXV0gPSBvdmVycmlkZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGFzc2VzICYmIHRoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzICE9PSBmYWxzZSkge1xyXG5cdCAgICAgICAgYWRkQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMub3B0aW9ucy5jbGFzc2VzKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgZHJvcC5kcm9wcy5wdXNoKHRoaXMpO1xyXG5cdCAgICAgIGFsbERyb3BzW2Ryb3AuY2xhc3NQcmVmaXhdLnB1c2godGhpcyk7XHJcblx0XHJcblx0ICAgICAgdGhpcy5fYm91bmRFdmVudHMgPSBbXTtcclxuXHQgICAgICB0aGlzLmJpbmRNZXRob2RzKCk7XHJcblx0ICAgICAgdGhpcy5zZXR1cEVsZW1lbnRzKCk7XHJcblx0ICAgICAgdGhpcy5zZXR1cEV2ZW50cygpO1xyXG5cdCAgICAgIHRoaXMuc2V0dXBUZXRoZXIoKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBfY3JlYXRlQ2xhc3MoRHJvcEluc3RhbmNlLCBbe1xyXG5cdCAgICAgIGtleTogJ19vbicsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbihlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xyXG5cdCAgICAgICAgdGhpcy5fYm91bmRFdmVudHMucHVzaCh7IGVsZW1lbnQ6IGVsZW1lbnQsIGV2ZW50OiBldmVudCwgaGFuZGxlcjogaGFuZGxlciB9KTtcclxuXHQgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnYmluZE1ldGhvZHMnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kTWV0aG9kcygpIHtcclxuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXIgPSB0aGlzLl90cmFuc2l0aW9uRW5kSGFuZGxlci5iaW5kKHRoaXMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3NldHVwRWxlbWVudHMnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEVsZW1lbnRzKCkge1xyXG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgIHRoaXMuZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgICAgICAgYWRkQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4KTtcclxuXHRcclxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xhc3Nlcykge1xyXG5cdCAgICAgICAgICBhZGRDbGFzcyh0aGlzLmRyb3AsIHRoaXMub3B0aW9ucy5jbGFzc2VzKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgICAgICAgYWRkQ2xhc3ModGhpcy5jb250ZW50LCBkcm9wLmNsYXNzUHJlZml4ICsgJy1jb250ZW50Jyk7XHJcblx0XHJcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgIHZhciBnZW5lcmF0ZUFuZFNldENvbnRlbnQgPSBmdW5jdGlvbiBnZW5lcmF0ZUFuZFNldENvbnRlbnQoKSB7XHJcblx0ICAgICAgICAgICAgLy8gY29udGVudCBmdW5jdGlvbiBtaWdodCByZXR1cm4gYSBzdHJpbmcgb3IgYW4gZWxlbWVudFxyXG5cdCAgICAgICAgICAgIHZhciBjb250ZW50RWxlbWVudE9ySFRNTCA9IF90aGlzLm9wdGlvbnMuY29udGVudC5jYWxsKF90aGlzLCBfdGhpcyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50RWxlbWVudE9ySFRNTCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gY29udGVudEVsZW1lbnRPckhUTUw7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudEVsZW1lbnRPckhUTUwgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgICAgICAgICBfdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgX3RoaXMuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50RWxlbWVudE9ySFRNTCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcCBFcnJvcjogQ29udGVudCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIG9yIEhUTUxFbGVtZW50LicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgZ2VuZXJhdGVBbmRTZXRDb250ZW50KCk7XHJcblx0ICAgICAgICAgIHRoaXMub24oJ29wZW4nLCBnZW5lcmF0ZUFuZFNldENvbnRlbnQuYmluZCh0aGlzKSk7XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29udGVudCA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMub3B0aW9ucy5jb250ZW50KTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuY29udGVudDtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMuZHJvcC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3NldHVwVGV0aGVyJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBUZXRoZXIoKSB7XHJcblx0ICAgICAgICAvLyBUZXRoZXIgZXhwZWN0cyB0d28gYXR0YWNobWVudCBwb2ludHMsIG9uZSBpbiB0aGUgdGFyZ2V0IGVsZW1lbnQsIG9uZSBpbiB0aGVcclxuXHQgICAgICAgIC8vIGRyb3AuICBXZSB1c2UgYSBzaW5nbGUgb25lLCBhbmQgdXNlIHRoZSBvcmRlciBhcyB3ZWxsLCB0byBhbGxvdyB1cyB0byBwdXRcclxuXHQgICAgICAgIC8vIHRoZSBkcm9wIG9uIGVpdGhlciBzaWRlIG9mIGFueSBvZiB0aGUgZm91ciBjb3JuZXJzLiAgVGhpcyBtYWdpYyBjb252ZXJ0cyBiZXR3ZWVuXHJcblx0ICAgICAgICAvLyB0aGUgdHdvOlxyXG5cdCAgICAgICAgdmFyIGRyb3BBdHRhY2ggPSB0aGlzLm9wdGlvbnMucG9zaXRpb24uc3BsaXQoJyAnKTtcclxuXHQgICAgICAgIGRyb3BBdHRhY2hbMF0gPSBNSVJST1JfQVRUQUNIW2Ryb3BBdHRhY2hbMF1dO1xyXG5cdCAgICAgICAgZHJvcEF0dGFjaCA9IGRyb3BBdHRhY2guam9pbignICcpO1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpblRvU2Nyb2xsUGFyZW50KSB7XHJcblx0ICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xyXG5cdCAgICAgICAgICAgIHRvOiAnc2Nyb2xsUGFyZW50JyxcclxuXHQgICAgICAgICAgICBwaW46ICd0b3AsIGJvdHRvbScsXHJcblx0ICAgICAgICAgICAgYXR0YWNobWVudDogJ3RvZ2V0aGVyIG5vbmUnXHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgLy8gVG8gZ2V0ICdvdXQgb2YgYm91bmRzJyBjbGFzc2VzXHJcblx0ICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xyXG5cdCAgICAgICAgICAgIHRvOiAnc2Nyb2xsUGFyZW50J1xyXG5cdCAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWluVG9XaW5kb3cgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xyXG5cdCAgICAgICAgICAgIHRvOiAnd2luZG93JyxcclxuXHQgICAgICAgICAgICBhdHRhY2htZW50OiAndG9nZXRoZXInXHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgLy8gVG8gZ2V0ICdvdXQgb2YgYm91bmRzJyBjbGFzc2VzXHJcblx0ICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xyXG5cdCAgICAgICAgICAgIHRvOiAnd2luZG93J1xyXG5cdCAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHZhciBvcHRzID0ge1xyXG5cdCAgICAgICAgICBlbGVtZW50OiB0aGlzLmRyb3AsXHJcblx0ICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXHJcblx0ICAgICAgICAgIGF0dGFjaG1lbnQ6IHNvcnRBdHRhY2goZHJvcEF0dGFjaCksXHJcblx0ICAgICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6IHNvcnRBdHRhY2godGhpcy5vcHRpb25zLnBvc2l0aW9uKSxcclxuXHQgICAgICAgICAgY2xhc3NQcmVmaXg6IGRyb3AuY2xhc3NQcmVmaXgsXHJcblx0ICAgICAgICAgIG9mZnNldDogJzAgMCcsXHJcblx0ICAgICAgICAgIHRhcmdldE9mZnNldDogJzAgMCcsXHJcblx0ICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludHMsXHJcblx0ICAgICAgICAgIGFkZFRhcmdldENsYXNzZXM6IHRoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzXHJcblx0ICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXRoZXJPcHRpb25zICE9PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICB0aGlzLnRldGhlciA9IG5ldyBUZXRoZXIoZXh0ZW5kKHt9LCBvcHRzLCB0aGlzLm9wdGlvbnMudGV0aGVyT3B0aW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3NldHVwRXZlbnRzJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBFdmVudHMoKSB7XHJcblx0ICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm9wZW5Pbikge1xyXG5cdCAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5PbiA9PT0gJ2Fsd2F5cycpIHtcclxuXHQgICAgICAgICAgc2V0VGltZW91dCh0aGlzLm9wZW4uYmluZCh0aGlzKSk7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHZhciBldmVudHMgPSB0aGlzLm9wdGlvbnMub3Blbk9uLnNwbGl0KCcgJyk7XHJcblx0XHJcblx0ICAgICAgICBpZiAoZXZlbnRzLmluZGV4T2YoJ2NsaWNrJykgPj0gMCkge1xyXG5cdCAgICAgICAgICB2YXIgb3BlbkhhbmRsZXIgPSBmdW5jdGlvbiBvcGVuSGFuZGxlcihldmVudCkge1xyXG5cdCAgICAgICAgICAgIF90aGlzMi50b2dnbGUoZXZlbnQpO1xyXG5cdCAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0ICAgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBjbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoZXZlbnQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIV90aGlzMi5pc09wZW5lZCgpKSB7XHJcblx0ICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIC8vIENsaWNraW5nIGluc2lkZSBkcm9wZG93blxyXG5cdCAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IF90aGlzMi5kcm9wIHx8IF90aGlzMi5kcm9wLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcclxuXHQgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgLy8gQ2xpY2tpbmcgdGFyZ2V0XHJcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMyLnRhcmdldCB8fCBfdGhpczIudGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcclxuXHQgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgX3RoaXMyLmNsb3NlKGV2ZW50KTtcclxuXHQgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlja0V2ZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbGlja0V2ZW50ID0gY2xpY2tFdmVudHNbaV07XHJcblx0ICAgICAgICAgICAgdGhpcy5fb24odGhpcy50YXJnZXQsIGNsaWNrRXZlbnQsIG9wZW5IYW5kbGVyKTtcclxuXHQgICAgICAgICAgICB0aGlzLl9vbihkb2N1bWVudCwgY2xpY2tFdmVudCwgY2xvc2VIYW5kbGVyKTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdmFyIGluVGltZW91dCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgb3V0VGltZW91dCA9IG51bGw7XHJcblx0XHJcblx0ICAgICAgICB2YXIgaW5IYW5kbGVyID0gZnVuY3Rpb24gaW5IYW5kbGVyKGV2ZW50KSB7XHJcblx0ICAgICAgICAgIGlmIChvdXRUaW1lb3V0ICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG91dFRpbWVvdXQpO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGluVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgX3RoaXMyLm9wZW4oZXZlbnQpO1xyXG5cdCAgICAgICAgICAgICAgaW5UaW1lb3V0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICB9LCAoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyA/IF90aGlzMi5vcHRpb25zLmZvY3VzRGVsYXkgOiBfdGhpczIub3B0aW9ucy5ob3Zlck9wZW5EZWxheSkgfHwgX3RoaXMyLm9wdGlvbnMub3BlbkRlbGF5KTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgIHZhciBvdXRIYW5kbGVyID0gZnVuY3Rpb24gb3V0SGFuZGxlcihldmVudCkge1xyXG5cdCAgICAgICAgICBpZiAoaW5UaW1lb3V0ICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGluVGltZW91dCk7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgb3V0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgX3RoaXMyLmNsb3NlKGV2ZW50KTtcclxuXHQgICAgICAgICAgICAgIG91dFRpbWVvdXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIH0sIChldmVudC50eXBlID09PSAnYmx1cicgPyBfdGhpczIub3B0aW9ucy5ibHVyRGVsYXkgOiBfdGhpczIub3B0aW9ucy5ob3ZlckNsb3NlRGVsYXkpIHx8IF90aGlzMi5vcHRpb25zLmNsb3NlRGVsYXkpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKGV2ZW50cy5pbmRleE9mKCdob3ZlcicpID49IDApIHtcclxuXHQgICAgICAgICAgdGhpcy5fb24odGhpcy50YXJnZXQsICdtb3VzZW92ZXInLCBpbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLmRyb3AsICdtb3VzZW92ZXInLCBpbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgJ21vdXNlb3V0Jywgb3V0SGFuZGxlcik7XHJcblx0ICAgICAgICAgIHRoaXMuX29uKHRoaXMuZHJvcCwgJ21vdXNlb3V0Jywgb3V0SGFuZGxlcik7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoZXZlbnRzLmluZGV4T2YoJ2ZvY3VzJykgPj0gMCkge1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgJ2ZvY3VzJywgaW5IYW5kbGVyKTtcclxuXHQgICAgICAgICAgdGhpcy5fb24odGhpcy5kcm9wLCAnZm9jdXMnLCBpbkhhbmRsZXIpO1xyXG5cdCAgICAgICAgICB0aGlzLl9vbih0aGlzLnRhcmdldCwgJ2JsdXInLCBvdXRIYW5kbGVyKTtcclxuXHQgICAgICAgICAgdGhpcy5fb24odGhpcy5kcm9wLCAnYmx1cicsIG91dEhhbmRsZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ2lzT3BlbmVkJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcGVuZWQoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5kcm9wKSB7XHJcblx0ICAgICAgICAgIHJldHVybiBoYXNDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLW9wZW4nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH0sIHtcclxuXHQgICAgICBrZXk6ICd0b2dnbGUnLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoZXZlbnQpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmlzT3BlbmVkKCkpIHtcclxuXHQgICAgICAgICAgdGhpcy5jbG9zZShldmVudCk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICB0aGlzLm9wZW4oZXZlbnQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ29wZW4nLFxyXG5cdCAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGV2ZW50KSB7XHJcblx0ICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtdmFyczogMCAqL1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaXNPcGVuZWQoKSkge1xyXG5cdCAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZHJvcC5wYXJlbnROb2RlKSB7XHJcblx0ICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kcm9wKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0eXBlb2YgdGhpcy50ZXRoZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgIHRoaXMudGV0aGVyLmVuYWJsZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgYWRkQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1vcGVuJyk7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLmRyb3AsIGRyb3AuY2xhc3NQcmVmaXggKyAnLW9wZW4tdHJhbnNpdGlvbmVuZCcpO1xyXG5cdFxyXG5cdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgIGlmIChfdGhpczMuZHJvcCkge1xyXG5cdCAgICAgICAgICAgIGFkZENsYXNzKF90aGlzMy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1hZnRlci1vcGVuJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIucG9zaXRpb24oKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHRoaXMudHJpZ2dlcignb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgZHJvcC51cGRhdGVCb2R5Q2xhc3NlcygpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ190cmFuc2l0aW9uRW5kSGFuZGxlcicsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2l0aW9uRW5kSGFuZGxlcihlKSB7XHJcblx0ICAgICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoIWhhc0NsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpKSB7XHJcblx0ICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3Blbi10cmFuc2l0aW9uZW5kJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmRyb3AucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ2JlZm9yZUNsb3NlSGFuZGxlcicsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUNsb3NlSGFuZGxlcihldmVudCkge1xyXG5cdCAgICAgICAgdmFyIHNob3VsZENsb3NlID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5pc0Nsb3NpbmcgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5iZWZvcmVDbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICB0aGlzLmlzQ2xvc2luZyA9IHRydWU7XHJcblx0ICAgICAgICAgIHNob3VsZENsb3NlID0gdGhpcy5vcHRpb25zLmJlZm9yZUNsb3NlKGV2ZW50LCB0aGlzKSAhPT0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB0aGlzLmlzQ2xvc2luZyA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHNob3VsZENsb3NlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ2Nsb3NlJyxcclxuXHQgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoZXZlbnQpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5pc09wZW5lZCgpKSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5iZWZvcmVDbG9zZUhhbmRsZXIoZXZlbnQpKSB7XHJcblx0ICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZHJvcCwgZHJvcC5jbGFzc1ByZWZpeCArICctb3BlbicpO1xyXG5cdCAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcm9wLCBkcm9wLmNsYXNzUHJlZml4ICsgJy1hZnRlci1vcGVuJyk7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLmRyb3AuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy50cmlnZ2VyKCdjbG9zZScpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIuZGlzYWJsZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgZHJvcC51cGRhdGVCb2R5Q2xhc3NlcygpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmUpIHtcclxuXHQgICAgICAgICAgdGhpcy5yZW1vdmUoZXZlbnQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSwge1xyXG5cdCAgICAgIGtleTogJ3JlbW92ZScsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCkge1xyXG5cdCAgICAgICAgdGhpcy5jbG9zZShldmVudCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5kcm9wLnBhcmVudE5vZGUpIHtcclxuXHQgICAgICAgICAgdGhpcy5kcm9wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kcm9wKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH0sIHtcclxuXHQgICAgICBrZXk6ICdwb3NpdGlvbicsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaXNPcGVuZWQoKSAmJiB0eXBlb2YgdGhpcy50ZXRoZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgIHRoaXMudGV0aGVyLnBvc2l0aW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LCB7XHJcblx0ICAgICAga2V5OiAnZGVzdHJveScsXHJcblx0ICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcblx0ICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRldGhlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhpcy50ZXRoZXIuZGVzdHJveSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ib3VuZEV2ZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICB2YXIgX2JvdW5kRXZlbnRzJGkgPSB0aGlzLl9ib3VuZEV2ZW50c1tpXTtcclxuXHQgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfYm91bmRFdmVudHMkaS5lbGVtZW50O1xyXG5cdCAgICAgICAgICB2YXIgX2V2ZW50ID0gX2JvdW5kRXZlbnRzJGkuZXZlbnQ7XHJcblx0ICAgICAgICAgIHZhciBoYW5kbGVyID0gX2JvdW5kRXZlbnRzJGkuaGFuZGxlcjtcclxuXHRcclxuXHQgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKF9ldmVudCwgaGFuZGxlcik7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB0aGlzLl9ib3VuZEV2ZW50cyA9IFtdO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy50ZXRoZXIgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5kcm9wID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XHJcblx0XHJcblx0ICAgICAgICByZW1vdmVGcm9tQXJyYXkoYWxsRHJvcHNbZHJvcC5jbGFzc1ByZWZpeF0sIHRoaXMpO1xyXG5cdCAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGRyb3AuZHJvcHMsIHRoaXMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfV0pO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gRHJvcEluc3RhbmNlO1xyXG5cdCAgfSkoRXZlbnRlZCk7XHJcblx0XHJcblx0ICByZXR1cm4gZHJvcDtcclxuXHR9XHJcblx0XHJcblx0dmFyIERyb3AgPSBjcmVhdGVDb250ZXh0KCk7XHJcblx0XHJcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcclxuXHQgIERyb3AudXBkYXRlQm9keUNsYXNzZXMoKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gRHJvcDtcclxuXHRcclxuXHR9KSk7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogNjAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qISB0ZXRoZXIgMS4yLjAgKi9cclxuXHRcclxuXHQoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdCAgaWYgKHRydWUpIHtcclxuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XHJcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJvb3QuVGV0aGVyID0gZmFjdG9yeSgpO1xyXG5cdCAgfVxyXG5cdH0odGhpcywgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdHZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XHJcblx0XHJcblx0dmFyIFRldGhlckJhc2UgPSB1bmRlZmluZWQ7XHJcblx0aWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgVGV0aGVyQmFzZSA9IHsgbW9kdWxlczogW10gfTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsKSB7XHJcblx0ICAvLyBJbiBmaXJlZm94IGlmIHRoZSBlbCBpcyBpbnNpZGUgYW4gaWZyYW1lIHdpdGggZGlzcGxheTogbm9uZTsgd2luZG93LmdldENvbXB1dGVkU3R5bGUoKSB3aWxsIHJldHVybiBudWxsO1xyXG5cdCAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XHJcblx0ICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpIHx8IHt9O1xyXG5cdCAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbjtcclxuXHRcclxuXHQgIGlmIChwb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xyXG5cdCAgICByZXR1cm4gZWw7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgcGFyZW50ID0gZWw7XHJcblx0ICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcclxuXHQgICAgdmFyIHN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdCAgICB0cnkge1xyXG5cdCAgICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xyXG5cdCAgICB9IGNhdGNoIChlcnIpIHt9XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICd1bmRlZmluZWQnIHx8IHN0eWxlID09PSBudWxsKSB7XHJcblx0ICAgICAgcmV0dXJuIHBhcmVudDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgX3N0eWxlID0gc3R5bGU7XHJcblx0ICAgIHZhciBvdmVyZmxvdyA9IF9zdHlsZS5vdmVyZmxvdztcclxuXHQgICAgdmFyIG92ZXJmbG93WCA9IF9zdHlsZS5vdmVyZmxvd1g7XHJcblx0ICAgIHZhciBvdmVyZmxvd1kgPSBfc3R5bGUub3ZlcmZsb3dZO1xyXG5cdFxyXG5cdCAgICBpZiAoLyhhdXRvfHNjcm9sbCkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XHJcblx0ICAgICAgaWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnIHx8IFsncmVsYXRpdmUnLCAnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKHN0eWxlLnBvc2l0aW9uKSA+PSAwKSB7XHJcblx0ICAgICAgICByZXR1cm4gcGFyZW50O1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdFxyXG5cdCAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciB1bmlxdWVJZCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICB2YXIgaWQgPSAwO1xyXG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgcmV0dXJuICsraWQ7XHJcblx0ICB9O1xyXG5cdH0pKCk7XHJcblx0XHJcblx0dmFyIHplcm9Qb3NDYWNoZSA9IHt9O1xyXG5cdHZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiBnZXRPcmlnaW4oZG9jKSB7XHJcblx0ICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdW5mb3J0dW5hdGVseSB0b28gYWNjdXJhdGUuICBJdCBpbnRyb2R1Y2VzIGEgcGl4ZWwgb3IgdHdvIG9mXHJcblx0ICAvLyBqaXR0ZXIgYXMgdGhlIHVzZXIgc2Nyb2xscyB0aGF0IG1lc3NlcyB3aXRoIG91ciBhYmlsaXR5IHRvIGRldGVjdCBpZiB0d28gcG9zaXRpb25zXHJcblx0ICAvLyBhcmUgZXF1aXZpbGFudCBvciBub3QuICBXZSBwbGFjZSBhbiBlbGVtZW50IGF0IHRoZSB0b3AgbGVmdCBvZiB0aGUgcGFnZSB0aGF0IHdpbGxcclxuXHQgIC8vIGdldCB0aGUgc2FtZSBqaXR0ZXIsIHNvIHdlIGNhbiBjYW5jZWwgdGhlIHR3byBvdXQuXHJcblx0ICB2YXIgbm9kZSA9IGRvYy5fdGV0aGVyWmVyb0VsZW1lbnQ7XHJcblx0ICBpZiAodHlwZW9mIG5vZGUgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIG5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXRldGhlci1pZCcsIHVuaXF1ZUlkKCkpO1xyXG5cdCAgICBleHRlbmQobm9kZS5zdHlsZSwge1xyXG5cdCAgICAgIHRvcDogMCxcclxuXHQgICAgICBsZWZ0OiAwLFxyXG5cdCAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcclxuXHRcclxuXHQgICAgZG9jLl90ZXRoZXJaZXJvRWxlbWVudCA9IG5vZGU7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgaWQgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS10ZXRoZXItaWQnKTtcclxuXHQgIGlmICh0eXBlb2YgemVyb1Bvc0NhY2hlW2lkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgemVyb1Bvc0NhY2hlW2lkXSA9IHt9O1xyXG5cdFxyXG5cdCAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0ICAgIGZvciAodmFyIGsgaW4gcmVjdCkge1xyXG5cdCAgICAgIC8vIENhbid0IHVzZSBleHRlbmQsIGFzIG9uIElFOSwgZWxlbWVudHMgZG9uJ3QgcmVzb2x2ZSB0byBiZSBoYXNPd25Qcm9wZXJ0eVxyXG5cdCAgICAgIHplcm9Qb3NDYWNoZVtpZF1ba10gPSByZWN0W2tdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIC8vIENsZWFyIHRoZSBjYWNoZSB3aGVuIHRoaXMgcG9zaXRpb24gY2FsbCBpcyBkb25lXHJcblx0ICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICBkZWxldGUgemVyb1Bvc0NhY2hlW2lkXTtcclxuXHQgICAgfSk7XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gemVyb1Bvc0NhY2hlW2lkXTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldEJvdW5kcyhlbCkge1xyXG5cdCAgdmFyIGRvYyA9IHVuZGVmaW5lZDtcclxuXHQgIGlmIChlbCA9PT0gZG9jdW1lbnQpIHtcclxuXHQgICAgZG9jID0gZG9jdW1lbnQ7XHJcblx0ICAgIGVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgZG9jID0gZWwub3duZXJEb2N1bWVudDtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBkb2NFbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHJcblx0ICB2YXIgYm94ID0ge307XHJcblx0ICAvLyBUaGUgb3JpZ2luYWwgb2JqZWN0IHJldHVybmVkIGJ5IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBpbW11dGFibGUsIHNvIHdlIGNsb25lIGl0XHJcblx0ICAvLyBXZSBjYW4ndCB1c2UgZXh0ZW5kIGJlY2F1c2UgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIG9iamVjdCBieSBoYXNPd25Qcm9wZXJ0eSBpbiBJRTlcclxuXHQgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0ICBmb3IgKHZhciBrIGluIHJlY3QpIHtcclxuXHQgICAgYm94W2tdID0gcmVjdFtrXTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBvcmlnaW4gPSBnZXRPcmlnaW4oZG9jKTtcclxuXHRcclxuXHQgIGJveC50b3AgLT0gb3JpZ2luLnRvcDtcclxuXHQgIGJveC5sZWZ0IC09IG9yaWdpbi5sZWZ0O1xyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiBib3gud2lkdGggPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIGJveC53aWR0aCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGggLSBib3gubGVmdCAtIGJveC5yaWdodDtcclxuXHQgIH1cclxuXHQgIGlmICh0eXBlb2YgYm94LmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgYm94LmhlaWdodCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gYm94LnRvcCAtIGJveC5ib3R0b207XHJcblx0ICB9XHJcblx0XHJcblx0ICBib3gudG9wID0gYm94LnRvcCAtIGRvY0VsLmNsaWVudFRvcDtcclxuXHQgIGJveC5sZWZ0ID0gYm94LmxlZnQgLSBkb2NFbC5jbGllbnRMZWZ0O1xyXG5cdCAgYm94LnJpZ2h0ID0gZG9jLmJvZHkuY2xpZW50V2lkdGggLSBib3gud2lkdGggLSBib3gubGVmdDtcclxuXHQgIGJveC5ib3R0b20gPSBkb2MuYm9keS5jbGllbnRIZWlnaHQgLSBib3guaGVpZ2h0IC0gYm94LnRvcDtcclxuXHRcclxuXHQgIHJldHVybiBib3g7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbCkge1xyXG5cdCAgcmV0dXJuIGVsLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldFNjcm9sbEJhclNpemUoKSB7XHJcblx0ICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHQgIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG5cdCAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcclxuXHRcclxuXHQgIHZhciBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgZXh0ZW5kKG91dGVyLnN0eWxlLCB7XHJcblx0ICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG5cdCAgICB0b3A6IDAsXHJcblx0ICAgIGxlZnQ6IDAsXHJcblx0ICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcclxuXHQgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXHJcblx0ICAgIHdpZHRoOiAnMjAwcHgnLFxyXG5cdCAgICBoZWlnaHQ6ICcxNTBweCcsXHJcblx0ICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG5cdCAgfSk7XHJcblx0XHJcblx0ICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XHJcblx0XHJcblx0ICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcclxuXHRcclxuXHQgIHZhciB3aWR0aENvbnRhaW5lZCA9IGlubmVyLm9mZnNldFdpZHRoO1xyXG5cdCAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcclxuXHQgIHZhciB3aWR0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xyXG5cdFxyXG5cdCAgaWYgKHdpZHRoQ29udGFpbmVkID09PSB3aWR0aFNjcm9sbCkge1xyXG5cdCAgICB3aWR0aFNjcm9sbCA9IG91dGVyLmNsaWVudFdpZHRoO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XHJcblx0XHJcblx0ICB2YXIgd2lkdGggPSB3aWR0aENvbnRhaW5lZCAtIHdpZHRoU2Nyb2xsO1xyXG5cdFxyXG5cdCAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IHdpZHRoIH07XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGV4dGVuZCgpIHtcclxuXHQgIHZhciBvdXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcclxuXHRcclxuXHQgIHZhciBhcmdzID0gW107XHJcblx0XHJcblx0ICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xyXG5cdFxyXG5cdCAgYXJncy5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuXHQgICAgaWYgKG9iaikge1xyXG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuXHQgICAgICAgIGlmICgoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcblx0ICAgICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9KTtcclxuXHRcclxuXHQgIHJldHVybiBvdXQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0ICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICAgIGlmIChjbHMudHJpbSgpKSB7XHJcblx0ICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJyhefCApJyArIG5hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKCB8JCknLCAnZ2knKTtcclxuXHQgICAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCkucmVwbGFjZShyZWdleCwgJyAnKTtcclxuXHQgICAgc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpO1xyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdCAgaWYgKHR5cGVvZiBlbC5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcclxuXHQgICAgICBpZiAoY2xzLnRyaW0oKSkge1xyXG5cdCAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICByZW1vdmVDbGFzcyhlbCwgbmFtZSk7XHJcblx0ICAgIHZhciBjbHMgPSBnZXRDbGFzc05hbWUoZWwpICsgKCcgJyArIG5hbWUpO1xyXG5cdCAgICBzZXRDbGFzc05hbWUoZWwsIGNscyk7XHJcblx0ICB9XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0ICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHQgIH1cclxuXHQgIHZhciBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUoZWwpO1xyXG5cdCAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefCApJyArIG5hbWUgKyAnKCB8JCknLCAnZ2knKS50ZXN0KGNsYXNzTmFtZSk7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldENsYXNzTmFtZShlbCkge1xyXG5cdCAgaWYgKGVsLmNsYXNzTmFtZSBpbnN0YW5jZW9mIFNWR0FuaW1hdGVkU3RyaW5nKSB7XHJcblx0ICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuXHQgIH1cclxuXHQgIHJldHVybiBlbC5jbGFzc05hbWU7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHNldENsYXNzTmFtZShlbCwgY2xhc3NOYW1lKSB7XHJcblx0ICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyhlbCwgYWRkLCBhbGwpIHtcclxuXHQgIC8vIE9mIHRoZSBzZXQgb2YgJ2FsbCcgY2xhc3Nlcywgd2UgbmVlZCB0aGUgJ2FkZCcgY2xhc3NlcywgYW5kIG9ubHkgdGhlXHJcblx0ICAvLyAnYWRkJyBjbGFzc2VzIHRvIGJlIHNldC5cclxuXHQgIGFsbC5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcclxuXHQgICAgaWYgKGFkZC5pbmRleE9mKGNscykgPT09IC0xICYmIGhhc0NsYXNzKGVsLCBjbHMpKSB7XHJcblx0ICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdFxyXG5cdCAgYWRkLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICBpZiAoIWhhc0NsYXNzKGVsLCBjbHMpKSB7XHJcblx0ICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZGVmZXJyZWQgPSBbXTtcclxuXHRcclxuXHR2YXIgZGVmZXIgPSBmdW5jdGlvbiBkZWZlcihmbikge1xyXG5cdCAgZGVmZXJyZWQucHVzaChmbik7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcclxuXHQgIHZhciBmbiA9IHVuZGVmaW5lZDtcclxuXHQgIHdoaWxlIChmbiA9IGRlZmVycmVkLnBvcCgpKSB7XHJcblx0ICAgIGZuKCk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHR2YXIgRXZlbnRlZCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICBmdW5jdGlvbiBFdmVudGVkKCkge1xyXG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRlZCk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBfY3JlYXRlQ2xhc3MoRXZlbnRlZCwgW3tcclxuXHQgICAga2V5OiAnb24nLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIGN0eCkge1xyXG5cdCAgICAgIHZhciBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbM107XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3NbZXZlbnRdID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0gPSBbXTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0ucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIsIGN0eDogY3R4LCBvbmNlOiBvbmNlIH0pO1xyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ29uY2UnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudCwgaGFuZGxlciwgY3R4KSB7XHJcblx0ICAgICAgdGhpcy5vbihldmVudCwgaGFuZGxlciwgY3R4LCB0cnVlKTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdvZmYnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5iaW5kaW5nc1tldmVudF0gIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdmFyIGkgPSAwO1xyXG5cdCAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbZXZlbnRdW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgKytpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ3RyaWdnZXInLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdHJpZ2dlcihldmVudCkge1xyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5ncyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5iaW5kaW5nc1tldmVudF0pIHtcclxuXHQgICAgICAgIHZhciBpID0gMDtcclxuXHRcclxuXHQgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG5cdCAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHdoaWxlIChpIDwgdGhpcy5iaW5kaW5nc1tldmVudF0ubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgIHZhciBfYmluZGluZ3MkZXZlbnQkaSA9IHRoaXMuYmluZGluZ3NbZXZlbnRdW2ldO1xyXG5cdCAgICAgICAgICB2YXIgaGFuZGxlciA9IF9iaW5kaW5ncyRldmVudCRpLmhhbmRsZXI7XHJcblx0ICAgICAgICAgIHZhciBjdHggPSBfYmluZGluZ3MkZXZlbnQkaS5jdHg7XHJcblx0ICAgICAgICAgIHZhciBvbmNlID0gX2JpbmRpbmdzJGV2ZW50JGkub25jZTtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIGNvbnRleHQgPSBjdHg7XHJcblx0ICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAob25jZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICArK2k7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH1dKTtcclxuXHRcclxuXHQgIHJldHVybiBFdmVudGVkO1xyXG5cdH0pKCk7XHJcblx0XHJcblx0VGV0aGVyQmFzZS5VdGlscyA9IHtcclxuXHQgIGdldFNjcm9sbFBhcmVudDogZ2V0U2Nyb2xsUGFyZW50LFxyXG5cdCAgZ2V0Qm91bmRzOiBnZXRCb3VuZHMsXHJcblx0ICBnZXRPZmZzZXRQYXJlbnQ6IGdldE9mZnNldFBhcmVudCxcclxuXHQgIGV4dGVuZDogZXh0ZW5kLFxyXG5cdCAgYWRkQ2xhc3M6IGFkZENsYXNzLFxyXG5cdCAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxyXG5cdCAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxyXG5cdCAgdXBkYXRlQ2xhc3NlczogdXBkYXRlQ2xhc3NlcyxcclxuXHQgIGRlZmVyOiBkZWZlcixcclxuXHQgIGZsdXNoOiBmbHVzaCxcclxuXHQgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcclxuXHQgIEV2ZW50ZWQ6IEV2ZW50ZWQsXHJcblx0ICBnZXRTY3JvbGxCYXJTaXplOiBnZXRTY3JvbGxCYXJTaXplXHJcblx0fTtcclxuXHQvKiBnbG9iYWxzIFRldGhlckJhc2UsIHBlcmZvcm1hbmNlICovXHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdHZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xyXG5cdFxyXG5cdHZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XHJcblx0XHJcblx0aWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBpbmNsdWRlIHRoZSB1dGlscy5qcyBmaWxlIGJlZm9yZSB0ZXRoZXIuanMnKTtcclxuXHR9XHJcblx0XHJcblx0dmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcclxuXHR2YXIgZ2V0U2Nyb2xsUGFyZW50ID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0U2Nyb2xsUGFyZW50O1xyXG5cdHZhciBnZXRCb3VuZHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRCb3VuZHM7XHJcblx0dmFyIGdldE9mZnNldFBhcmVudCA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldE9mZnNldFBhcmVudDtcclxuXHR2YXIgZXh0ZW5kID0gX1RldGhlckJhc2UkVXRpbHMuZXh0ZW5kO1xyXG5cdHZhciBhZGRDbGFzcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmFkZENsYXNzO1xyXG5cdHZhciByZW1vdmVDbGFzcyA9IF9UZXRoZXJCYXNlJFV0aWxzLnJlbW92ZUNsYXNzO1xyXG5cdHZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcclxuXHR2YXIgZGVmZXIgPSBfVGV0aGVyQmFzZSRVdGlscy5kZWZlcjtcclxuXHR2YXIgZmx1c2ggPSBfVGV0aGVyQmFzZSRVdGlscy5mbHVzaDtcclxuXHR2YXIgZ2V0U2Nyb2xsQmFyU2l6ZSA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldFNjcm9sbEJhclNpemU7XHJcblx0XHJcblx0ZnVuY3Rpb24gd2l0aGluKGEsIGIpIHtcclxuXHQgIHZhciBkaWZmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1syXTtcclxuXHRcclxuXHQgIHJldHVybiBhICsgZGlmZiA+PSBiICYmIGIgPj0gYSAtIGRpZmY7XHJcblx0fVxyXG5cdFxyXG5cdHZhciB0cmFuc2Zvcm1LZXkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgcmV0dXJuICcnO1xyXG5cdCAgfVxyXG5cdCAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHJcblx0ICB2YXIgdHJhbnNmb3JtcyA9IFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddO1xyXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgIHZhciBrZXkgPSB0cmFuc2Zvcm1zW2ldO1xyXG5cdCAgICBpZiAoZWwuc3R5bGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgcmV0dXJuIGtleTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH0pKCk7XHJcblx0XHJcblx0dmFyIHRldGhlcnMgPSBbXTtcclxuXHRcclxuXHR2YXIgcG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbigpIHtcclxuXHQgIHRldGhlcnMuZm9yRWFjaChmdW5jdGlvbiAodGV0aGVyKSB7XHJcblx0ICAgIHRldGhlci5wb3NpdGlvbihmYWxzZSk7XHJcblx0ICB9KTtcclxuXHQgIGZsdXNoKCk7XHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBub3coKSB7XHJcblx0ICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gK25ldyBEYXRlKCk7XHJcblx0fVxyXG5cdFxyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICB2YXIgbGFzdENhbGwgPSBudWxsO1xyXG5cdCAgdmFyIGxhc3REdXJhdGlvbiA9IG51bGw7XHJcblx0ICB2YXIgcGVuZGluZ1RpbWVvdXQgPSBudWxsO1xyXG5cdFxyXG5cdCAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xyXG5cdCAgICBpZiAodHlwZW9mIGxhc3REdXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgbGFzdER1cmF0aW9uID4gMTYpIHtcclxuXHQgICAgICAvLyBXZSB2b2x1bnRhcmlseSB0aHJvdHRsZSBvdXJzZWx2ZXMgaWYgd2UgY2FuJ3QgbWFuYWdlIDYwZnBzXHJcblx0ICAgICAgbGFzdER1cmF0aW9uID0gTWF0aC5taW4obGFzdER1cmF0aW9uIC0gMTYsIDI1MCk7XHJcblx0XHJcblx0ICAgICAgLy8gSnVzdCBpbiBjYXNlIHRoaXMgaXMgdGhlIGxhc3QgZXZlbnQsIHJlbWVtYmVyIHRvIHBvc2l0aW9uIGp1c3Qgb25jZSBtb3JlXHJcblx0ICAgICAgcGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDI1MCk7XHJcblx0ICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0eXBlb2YgbGFzdENhbGwgIT09ICd1bmRlZmluZWQnICYmIG5vdygpIC0gbGFzdENhbGwgPCAxMCkge1xyXG5cdCAgICAgIC8vIFNvbWUgYnJvd3NlcnMgY2FsbCBldmVudHMgYSBsaXR0bGUgdG9vIGZyZXF1ZW50bHksIHJlZnVzZSB0byBydW4gbW9yZSB0aGFuIGlzIHJlYXNvbmFibGVcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHR5cGVvZiBwZW5kaW5nVGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICBjbGVhclRpbWVvdXQocGVuZGluZ1RpbWVvdXQpO1xyXG5cdCAgICAgIHBlbmRpbmdUaW1lb3V0ID0gbnVsbDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBsYXN0Q2FsbCA9IG5vdygpO1xyXG5cdCAgICBwb3NpdGlvbigpO1xyXG5cdCAgICBsYXN0RHVyYXRpb24gPSBub3coKSAtIGxhc3RDYWxsO1xyXG5cdCAgfTtcclxuXHRcclxuXHQgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICBbJ3Jlc2l6ZScsICdzY3JvbGwnLCAndG91Y2htb3ZlJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHQgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGljayk7XHJcblx0ICAgIH0pO1xyXG5cdCAgfVxyXG5cdH0pKCk7XHJcblx0XHJcblx0dmFyIE1JUlJPUl9MUiA9IHtcclxuXHQgIGNlbnRlcjogJ2NlbnRlcicsXHJcblx0ICBsZWZ0OiAncmlnaHQnLFxyXG5cdCAgcmlnaHQ6ICdsZWZ0J1xyXG5cdH07XHJcblx0XHJcblx0dmFyIE1JUlJPUl9UQiA9IHtcclxuXHQgIG1pZGRsZTogJ21pZGRsZScsXHJcblx0ICB0b3A6ICdib3R0b20nLFxyXG5cdCAgYm90dG9tOiAndG9wJ1xyXG5cdH07XHJcblx0XHJcblx0dmFyIE9GRlNFVF9NQVAgPSB7XHJcblx0ICB0b3A6IDAsXHJcblx0ICBsZWZ0OiAwLFxyXG5cdCAgbWlkZGxlOiAnNTAlJyxcclxuXHQgIGNlbnRlcjogJzUwJScsXHJcblx0ICBib3R0b206ICcxMDAlJyxcclxuXHQgIHJpZ2h0OiAnMTAwJSdcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBhdXRvVG9GaXhlZEF0dGFjaG1lbnQgPSBmdW5jdGlvbiBhdXRvVG9GaXhlZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgcmVsYXRpdmVUb0F0dGFjaG1lbnQpIHtcclxuXHQgIHZhciBsZWZ0ID0gYXR0YWNobWVudC5sZWZ0O1xyXG5cdCAgdmFyIHRvcCA9IGF0dGFjaG1lbnQudG9wO1xyXG5cdFxyXG5cdCAgaWYgKGxlZnQgPT09ICdhdXRvJykge1xyXG5cdCAgICBsZWZ0ID0gTUlSUk9SX0xSW3JlbGF0aXZlVG9BdHRhY2htZW50LmxlZnRdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgaWYgKHRvcCA9PT0gJ2F1dG8nKSB7XHJcblx0ICAgIHRvcCA9IE1JUlJPUl9UQltyZWxhdGl2ZVRvQXR0YWNobWVudC50b3BdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBhdHRhY2htZW50VG9PZmZzZXQgPSBmdW5jdGlvbiBhdHRhY2htZW50VG9PZmZzZXQoYXR0YWNobWVudCkge1xyXG5cdCAgdmFyIGxlZnQgPSBhdHRhY2htZW50LmxlZnQ7XHJcblx0ICB2YXIgdG9wID0gYXR0YWNobWVudC50b3A7XHJcblx0XHJcblx0ICBpZiAodHlwZW9mIE9GRlNFVF9NQVBbYXR0YWNobWVudC5sZWZ0XSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgbGVmdCA9IE9GRlNFVF9NQVBbYXR0YWNobWVudC5sZWZ0XTtcclxuXHQgIH1cclxuXHRcclxuXHQgIGlmICh0eXBlb2YgT0ZGU0VUX01BUFthdHRhY2htZW50LnRvcF0gIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgIHRvcCA9IE9GRlNFVF9NQVBbYXR0YWNobWVudC50b3BdO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGFkZE9mZnNldCgpIHtcclxuXHQgIHZhciBvdXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xyXG5cdFxyXG5cdCAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9mZnNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuXHQgICAgb2Zmc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuXHQgIH1cclxuXHRcclxuXHQgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xyXG5cdCAgICB2YXIgdG9wID0gX3JlZi50b3A7XHJcblx0ICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHRvcCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICB0b3AgPSBwYXJzZUZsb2F0KHRvcCwgMTApO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICBsZWZ0ID0gcGFyc2VGbG9hdChsZWZ0LCAxMCk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgb3V0LnRvcCArPSB0b3A7XHJcblx0ICAgIG91dC5sZWZ0ICs9IGxlZnQ7XHJcblx0ICB9KTtcclxuXHRcclxuXHQgIHJldHVybiBvdXQ7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIG9mZnNldFRvUHgob2Zmc2V0LCBzaXplKSB7XHJcblx0ICBpZiAodHlwZW9mIG9mZnNldC5sZWZ0ID09PSAnc3RyaW5nJyAmJiBvZmZzZXQubGVmdC5pbmRleE9mKCclJykgIT09IC0xKSB7XHJcblx0ICAgIG9mZnNldC5sZWZ0ID0gcGFyc2VGbG9hdChvZmZzZXQubGVmdCwgMTApIC8gMTAwICogc2l6ZS53aWR0aDtcclxuXHQgIH1cclxuXHQgIGlmICh0eXBlb2Ygb2Zmc2V0LnRvcCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LnRvcC5pbmRleE9mKCclJykgIT09IC0xKSB7XHJcblx0ICAgIG9mZnNldC50b3AgPSBwYXJzZUZsb2F0KG9mZnNldC50b3AsIDEwKSAvIDEwMCAqIHNpemUuaGVpZ2h0O1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgcmV0dXJuIG9mZnNldDtcclxuXHR9XHJcblx0XHJcblx0dmFyIHBhcnNlT2Zmc2V0ID0gZnVuY3Rpb24gcGFyc2VPZmZzZXQodmFsdWUpIHtcclxuXHQgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgnICcpO1xyXG5cdFxyXG5cdCAgdmFyIF92YWx1ZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfdmFsdWUkc3BsaXQsIDIpO1xyXG5cdFxyXG5cdCAgdmFyIHRvcCA9IF92YWx1ZSRzcGxpdDJbMF07XHJcblx0ICB2YXIgbGVmdCA9IF92YWx1ZSRzcGxpdDJbMV07XHJcblx0XHJcblx0ICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xyXG5cdH07XHJcblx0dmFyIHBhcnNlQXR0YWNobWVudCA9IHBhcnNlT2Zmc2V0O1xyXG5cdFxyXG5cdHZhciBUZXRoZXJDbGFzcyA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICBmdW5jdGlvbiBUZXRoZXJDbGFzcyhvcHRpb25zKSB7XHJcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0XHJcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXRoZXJDbGFzcyk7XHJcblx0XHJcblx0ICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmJpbmQodGhpcyk7XHJcblx0XHJcblx0ICAgIHRldGhlcnMucHVzaCh0aGlzKTtcclxuXHRcclxuXHQgICAgdGhpcy5oaXN0b3J5ID0gW107XHJcblx0XHJcblx0ICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLCBmYWxzZSk7XHJcblx0XHJcblx0ICAgIFRldGhlckJhc2UubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuXHQgICAgICBpZiAodHlwZW9mIG1vZHVsZS5pbml0aWFsaXplICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgbW9kdWxlLmluaXRpYWxpemUuY2FsbChfdGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgdGhpcy5wb3NpdGlvbigpO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgX2NyZWF0ZUNsYXNzKFRldGhlckNsYXNzLCBbe1xyXG5cdCAgICBrZXk6ICdnZXRDbGFzcycsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGFzcygpIHtcclxuXHQgICAgICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMF07XHJcblx0ICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLm9wdGlvbnMuY2xhc3NlcztcclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIGNsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXNba2V5XSkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc2VzW2tleV07XHJcblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXggKyAnLScgKyBrZXk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldHVybiBrZXk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ3NldE9wdGlvbnMnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcblx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblx0XHJcblx0ICAgICAgdmFyIHBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XHJcblx0XHJcblx0ICAgICAgdmFyIGRlZmF1bHRzID0ge1xyXG5cdCAgICAgICAgb2Zmc2V0OiAnMCAwJyxcclxuXHQgICAgICAgIHRhcmdldE9mZnNldDogJzAgMCcsXHJcblx0ICAgICAgICB0YXJnZXRBdHRhY2htZW50OiAnYXV0byBhdXRvJyxcclxuXHQgICAgICAgIGNsYXNzUHJlZml4OiAndGV0aGVyJ1xyXG5cdCAgICAgIH07XHJcblx0XHJcblx0ICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcclxuXHRcclxuXHQgICAgICB2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0ICAgICAgdmFyIGVsZW1lbnQgPSBfb3B0aW9ucy5lbGVtZW50O1xyXG5cdCAgICAgIHZhciB0YXJnZXQgPSBfb3B0aW9ucy50YXJnZXQ7XHJcblx0ICAgICAgdmFyIHRhcmdldE1vZGlmaWVyID0gX29wdGlvbnMudGFyZ2V0TW9kaWZpZXI7XHJcblx0XHJcblx0ICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuXHQgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHQgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gdGFyZ2V0TW9kaWZpZXI7XHJcblx0XHJcblx0ICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSAndmlld3BvcnQnKSB7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LmJvZHk7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Zpc2libGUnO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPT09ICdzY3JvbGwtaGFuZGxlJykge1xyXG5cdCAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xyXG5cdCAgICAgICAgdGhpcy50YXJnZXRNb2RpZmllciA9ICdzY3JvbGwtaGFuZGxlJztcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgWydlbGVtZW50JywgJ3RhcmdldCddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBfdGhpczJba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXRoZXIgRXJyb3I6IEJvdGggZWxlbWVudCBhbmQgdGFyZ2V0IG11c3QgYmUgZGVmaW5lZCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBfdGhpczJba2V5XS5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgIF90aGlzMltrZXldID0gX3RoaXMyW2tleV1bMF07XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhpczJba2V5XSA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgX3RoaXMyW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90aGlzMltrZXldKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHRcclxuXHQgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQnKSk7XHJcblx0ICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xyXG5cdCAgICAgICAgYWRkQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldCcpKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXR0YWNobWVudCkge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXRoZXIgRXJyb3I6IFlvdSBtdXN0IHByb3ZpZGUgYW4gYXR0YWNobWVudCcpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB0aGlzLnRhcmdldEF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQodGhpcy5vcHRpb25zLnRhcmdldEF0dGFjaG1lbnQpO1xyXG5cdCAgICAgIHRoaXMuYXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudCh0aGlzLm9wdGlvbnMuYXR0YWNobWVudCk7XHJcblx0ICAgICAgdGhpcy5vZmZzZXQgPSBwYXJzZU9mZnNldCh0aGlzLm9wdGlvbnMub2Zmc2V0KTtcclxuXHQgICAgICB0aGlzLnRhcmdldE9mZnNldCA9IHBhcnNlT2Zmc2V0KHRoaXMub3B0aW9ucy50YXJnZXRPZmZzZXQpO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5zY3JvbGxQYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLmRpc2FibGUoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xyXG5cdCAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldDtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQodGhpcy50YXJnZXQpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpKSB7XHJcblx0ICAgICAgICB0aGlzLmVuYWJsZShwb3MpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdnZXRUYXJnZXRCb3VuZHMnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0Qm91bmRzKCkge1xyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXRNb2RpZmllciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRhcmdldE1vZGlmaWVyID09PSAndmlzaWJsZScpIHtcclxuXHQgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiBwYWdlWU9mZnNldCwgbGVmdDogcGFnZVhPZmZzZXQsIGhlaWdodDogaW5uZXJIZWlnaHQsIHdpZHRoOiBpbm5lcldpZHRoIH07XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIG91dCA9IHtcclxuXHQgICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcclxuXHQgICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXHJcblx0ICAgICAgICAgICAgICB0b3A6IGJvdW5kcy50b3AsXHJcblx0ICAgICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKG91dC5oZWlnaHQsIGJvdW5kcy5oZWlnaHQgLSAocGFnZVlPZmZzZXQgLSBib3VuZHMudG9wKSk7XHJcblx0ICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKG91dC5oZWlnaHQsIGJvdW5kcy5oZWlnaHQgLSAoYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQgLSAocGFnZVlPZmZzZXQgKyBpbm5lckhlaWdodCkpKTtcclxuXHQgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4oaW5uZXJIZWlnaHQsIG91dC5oZWlnaHQpO1xyXG5cdCAgICAgICAgICAgIG91dC5oZWlnaHQgLT0gMjtcclxuXHRcclxuXHQgICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihvdXQud2lkdGgsIGJvdW5kcy53aWR0aCAtIChwYWdlWE9mZnNldCAtIGJvdW5kcy5sZWZ0KSk7XHJcblx0ICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4ob3V0LndpZHRoLCBib3VuZHMud2lkdGggLSAoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSAocGFnZVhPZmZzZXQgKyBpbm5lcldpZHRoKSkpO1xyXG5cdCAgICAgICAgICAgIG91dC53aWR0aCA9IE1hdGgubWluKGlubmVyV2lkdGgsIG91dC53aWR0aCk7XHJcblx0ICAgICAgICAgICAgb3V0LndpZHRoIC09IDI7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKG91dC50b3AgPCBwYWdlWU9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgb3V0LnRvcCA9IHBhZ2VZT2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAob3V0LmxlZnQgPCBwYWdlWE9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgb3V0LmxlZnQgPSBwYWdlWE9mZnNldDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldE1vZGlmaWVyID09PSAnc2Nyb2xsLWhhbmRsZScpIHtcclxuXHQgICAgICAgICAgdmFyIGJvdW5kcyA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG5cdCAgICAgICAgICBpZiAodGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0ICAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGJvdW5kcyA9IHtcclxuXHQgICAgICAgICAgICAgIGxlZnQ6IHBhZ2VYT2Zmc2V0LFxyXG5cdCAgICAgICAgICAgICAgdG9wOiBwYWdlWU9mZnNldCxcclxuXHQgICAgICAgICAgICAgIGhlaWdodDogaW5uZXJIZWlnaHQsXHJcblx0ICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgYm91bmRzID0gZ2V0Qm91bmRzKHRhcmdldCk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgaGFzQm90dG9tU2Nyb2xsID0gdGFyZ2V0LnNjcm9sbFdpZHRoID4gdGFyZ2V0LmNsaWVudFdpZHRoIHx8IFtzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYXS5pbmRleE9mKCdzY3JvbGwnKSA+PSAwIHx8IHRoaXMudGFyZ2V0ICE9PSBkb2N1bWVudC5ib2R5O1xyXG5cdFxyXG5cdCAgICAgICAgICB2YXIgc2Nyb2xsQm90dG9tID0gMDtcclxuXHQgICAgICAgICAgaWYgKGhhc0JvdHRvbVNjcm9sbCkge1xyXG5cdCAgICAgICAgICAgIHNjcm9sbEJvdHRvbSA9IDE1O1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSAtIHNjcm9sbEJvdHRvbTtcclxuXHRcclxuXHQgICAgICAgICAgdmFyIG91dCA9IHtcclxuXHQgICAgICAgICAgICB3aWR0aDogMTUsXHJcblx0ICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjk3NSAqIChoZWlnaHQgLyB0YXJnZXQuc2Nyb2xsSGVpZ2h0KSxcclxuXHQgICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSAtIDE1XHJcblx0ICAgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBmaXRBZGogPSAwO1xyXG5cdCAgICAgICAgICBpZiAoaGVpZ2h0IDwgNDA4ICYmIHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0ICAgICAgICAgICAgZml0QWRqID0gLTAuMDAwMTEgKiBNYXRoLnBvdyhoZWlnaHQsIDIpIC0gMC4wMDcyNyAqIGhlaWdodCArIDIyLjU4O1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGlmICh0aGlzLnRhcmdldCAhPT0gZG9jdW1lbnQuYm9keSkge1xyXG5cdCAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1heChvdXQuaGVpZ2h0LCAyNCk7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSB0aGlzLnRhcmdldC5zY3JvbGxUb3AgLyAodGFyZ2V0LnNjcm9sbEhlaWdodCAtIGhlaWdodCk7XHJcblx0ICAgICAgICAgIG91dC50b3AgPSBzY3JvbGxQZXJjZW50YWdlICogKGhlaWdodCAtIG91dC5oZWlnaHQgLSBmaXRBZGopICsgYm91bmRzLnRvcCArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xyXG5cdFxyXG5cdCAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHQgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5tYXgob3V0LmhlaWdodCwgMjQpO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIHJldHVybiBvdXQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldHVybiBnZXRCb3VuZHModGhpcy50YXJnZXQpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdjbGVhckNhY2hlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XHJcblx0ICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdjYWNoZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjYWNoZShrLCBnZXR0ZXIpIHtcclxuXHQgICAgICAvLyBNb3JlIHRoYW4gb25lIG1vZHVsZSB3aWxsIG9mdGVuIG5lZWQgdGhlIHNhbWUgRE9NIGluZm8sIHNvXHJcblx0ICAgICAgLy8gd2Uga2VlcCBhIGNhY2hlIHdoaWNoIGlzIGNsZWFyZWQgb24gZWFjaCBwb3NpdGlvbiBjYWxsXHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHRoaXMuX2NhY2hlID0ge307XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2FjaGVba10gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aGlzLl9jYWNoZVtrXSA9IGdldHRlci5jYWxsKHRoaXMpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICByZXR1cm4gdGhpcy5fY2FjaGVba107XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnZW5hYmxlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuXHQgICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcclxuXHRcclxuXHQgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XHJcblx0ICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xyXG5cdCAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblx0XHJcblx0ICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5wb3NpdGlvbik7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmIChwb3MpIHtcclxuXHQgICAgICAgIHRoaXMucG9zaXRpb24oKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnZGlzYWJsZScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xyXG5cdCAgICAgIHJlbW92ZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xyXG5cdCAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcclxuXHQgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuc2Nyb2xsUGFyZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5wb3NpdGlvbik7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ2Rlc3Ryb3knLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuXHQgICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHRcclxuXHQgICAgICB0aGlzLmRpc2FibGUoKTtcclxuXHRcclxuXHQgICAgICB0ZXRoZXJzLmZvckVhY2goZnVuY3Rpb24gKHRldGhlciwgaSkge1xyXG5cdCAgICAgICAgaWYgKHRldGhlciA9PT0gX3RoaXMzKSB7XHJcblx0ICAgICAgICAgIHRldGhlcnMuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAndXBkYXRlQXR0YWNoQ2xhc3NlcycsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBdHRhY2hDbGFzc2VzKGVsZW1lbnRBdHRhY2gsIHRhcmdldEF0dGFjaCkge1xyXG5cdCAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG5cdFxyXG5cdCAgICAgIGVsZW1lbnRBdHRhY2ggPSBlbGVtZW50QXR0YWNoIHx8IHRoaXMuYXR0YWNobWVudDtcclxuXHQgICAgICB0YXJnZXRBdHRhY2ggPSB0YXJnZXRBdHRhY2ggfHwgdGhpcy50YXJnZXRBdHRhY2htZW50O1xyXG5cdCAgICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ21pZGRsZScsICdjZW50ZXInXTtcclxuXHRcclxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAvLyB1cGRhdGVBdHRhY2hDbGFzc2VzIGNhbiBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgaW4gYSBwb3NpdGlvbiBjYWxsLCBzb1xyXG5cdCAgICAgICAgLy8gd2UgbmVlZCB0byBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMgc3VjaCB0aGF0IHdoZW4gdGhlIGxhc3QgZGVmZXIgZ2V0c1xyXG5cdCAgICAgICAgLy8gcmFuIGl0IGRvZXNuJ3QgYWRkIGFueSBleHRyYSBjbGFzc2VzIGZyb20gcHJldmlvdXMgY2FsbHMuXHJcblx0ICAgICAgICB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzLnNwbGljZSgwLCB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzLmxlbmd0aCk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgPSBbXTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdmFyIGFkZCA9IHRoaXMuX2FkZEF0dGFjaENsYXNzZXM7XHJcblx0XHJcblx0ICAgICAgaWYgKGVsZW1lbnRBdHRhY2gudG9wKSB7XHJcblx0ICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykgKyAnLScgKyBlbGVtZW50QXR0YWNoLnRvcCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChlbGVtZW50QXR0YWNoLmxlZnQpIHtcclxuXHQgICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIGVsZW1lbnRBdHRhY2gubGVmdCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0YXJnZXRBdHRhY2gudG9wKSB7XHJcblx0ICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHRhcmdldEF0dGFjaC50b3ApO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodGFyZ2V0QXR0YWNoLmxlZnQpIHtcclxuXHQgICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgdGFyZ2V0QXR0YWNoLmxlZnQpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgYWxsID0gW107XHJcblx0ICAgICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xyXG5cdCAgICAgICAgYWxsLnB1c2goX3RoaXM0LmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgICAgIGFsbC5wdXNoKF90aGlzNC5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyBzaWRlKTtcclxuXHQgICAgICB9KTtcclxuXHRcclxuXHQgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoISh0eXBlb2YgX3RoaXM0Ll9hZGRBdHRhY2hDbGFzc2VzICE9PSAndW5kZWZpbmVkJykpIHtcclxuXHQgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpczQuZWxlbWVudCwgX3RoaXM0Ll9hZGRBdHRhY2hDbGFzc2VzLCBhbGwpO1xyXG5cdCAgICAgICAgaWYgKCEoX3RoaXM0Lm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XHJcblx0ICAgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXM0LnRhcmdldCwgX3RoaXM0Ll9hZGRBdHRhY2hDbGFzc2VzLCBhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgZGVsZXRlIF90aGlzNC5fYWRkQXR0YWNoQ2xhc3NlcztcclxuXHQgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdCAgfSwge1xyXG5cdCAgICBrZXk6ICdwb3NpdGlvbicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcclxuXHQgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcclxuXHRcclxuXHQgICAgICB2YXIgZmx1c2hDaGFuZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcclxuXHRcclxuXHQgICAgICAvLyBmbHVzaENoYW5nZXMgY29tbWl0cyB0aGUgY2hhbmdlcyBpbW1lZGlhdGVseSwgbGVhdmUgdHJ1ZSB1bmxlc3MgeW91IGFyZSBwb3NpdGlvbmluZyBtdWx0aXBsZVxyXG5cdCAgICAgIC8vIHRldGhlcnMgKGluIHdoaWNoIGNhc2UgY2FsbCBUZXRoZXIuVXRpbHMuZmx1c2ggeW91cnNlbGYgd2hlbiB5b3UncmUgZG9uZSlcclxuXHRcclxuXHQgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcclxuXHRcclxuXHQgICAgICAvLyBUdXJuICdhdXRvJyBhdHRhY2htZW50cyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBjb3JuZXIgb3IgZWRnZVxyXG5cdCAgICAgIHZhciB0YXJnZXRBdHRhY2htZW50ID0gYXV0b1RvRml4ZWRBdHRhY2htZW50KHRoaXMudGFyZ2V0QXR0YWNobWVudCwgdGhpcy5hdHRhY2htZW50KTtcclxuXHRcclxuXHQgICAgICB0aGlzLnVwZGF0ZUF0dGFjaENsYXNzZXModGhpcy5hdHRhY2htZW50LCB0YXJnZXRBdHRhY2htZW50KTtcclxuXHRcclxuXHQgICAgICB2YXIgZWxlbWVudFBvcyA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpczUuZWxlbWVudCk7XHJcblx0ICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgdmFyIHdpZHRoID0gZWxlbWVudFBvcy53aWR0aDtcclxuXHQgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudFBvcy5oZWlnaHQ7XHJcblx0XHJcblx0ICAgICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCAmJiB0eXBlb2YgdGhpcy5sYXN0U2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIHZhciBfbGFzdFNpemUgPSB0aGlzLmxhc3RTaXplO1xyXG5cdFxyXG5cdCAgICAgICAgLy8gV2UgY2FjaGUgdGhlIGhlaWdodCBhbmQgd2lkdGggdG8gbWFrZSBpdCBwb3NzaWJsZSB0byBwb3NpdGlvbiBlbGVtZW50cyB0aGF0IGFyZVxyXG5cdCAgICAgICAgLy8gZ2V0dGluZyBoaWRkZW4uXHJcblx0ICAgICAgICB3aWR0aCA9IF9sYXN0U2l6ZS53aWR0aDtcclxuXHQgICAgICAgIGhlaWdodCA9IF9sYXN0U2l6ZS5oZWlnaHQ7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMubGFzdFNpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgdmFyIHRhcmdldFBvcyA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3RoaXM1LmdldFRhcmdldEJvdW5kcygpO1xyXG5cdCAgICAgIH0pO1xyXG5cdCAgICAgIHZhciB0YXJnZXRTaXplID0gdGFyZ2V0UG9zO1xyXG5cdFxyXG5cdCAgICAgIC8vIEdldCBhbiBhY3R1YWwgcHggb2Zmc2V0IGZyb20gdGhlIGF0dGFjaG1lbnRcclxuXHQgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0VG9QeChhdHRhY2htZW50VG9PZmZzZXQodGhpcy5hdHRhY2htZW50KSwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG5cdCAgICAgIHZhciB0YXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0YXJnZXRBdHRhY2htZW50KSwgdGFyZ2V0U2l6ZSk7XHJcblx0XHJcblx0ICAgICAgdmFyIG1hbnVhbE9mZnNldCA9IG9mZnNldFRvUHgodGhpcy5vZmZzZXQsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuXHQgICAgICB2YXIgbWFudWFsVGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLnRhcmdldE9mZnNldCwgdGFyZ2V0U2l6ZSk7XHJcblx0XHJcblx0ICAgICAgLy8gQWRkIHRoZSBtYW51YWxseSBwcm92aWRlZCBvZmZzZXRcclxuXHQgICAgICBvZmZzZXQgPSBhZGRPZmZzZXQob2Zmc2V0LCBtYW51YWxPZmZzZXQpO1xyXG5cdCAgICAgIHRhcmdldE9mZnNldCA9IGFkZE9mZnNldCh0YXJnZXRPZmZzZXQsIG1hbnVhbFRhcmdldE9mZnNldCk7XHJcblx0XHJcblx0ICAgICAgLy8gSXQncyBub3cgb3VyIGdvYWwgdG8gbWFrZSAoZWxlbWVudCBwb3NpdGlvbiArIG9mZnNldCkgPT0gKHRhcmdldCBwb3NpdGlvbiArIHRhcmdldCBvZmZzZXQpXHJcblx0ICAgICAgdmFyIGxlZnQgPSB0YXJnZXRQb3MubGVmdCArIHRhcmdldE9mZnNldC5sZWZ0IC0gb2Zmc2V0LmxlZnQ7XHJcblx0ICAgICAgdmFyIHRvcCA9IHRhcmdldFBvcy50b3AgKyB0YXJnZXRPZmZzZXQudG9wIC0gb2Zmc2V0LnRvcDtcclxuXHRcclxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRldGhlckJhc2UubW9kdWxlcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgdmFyIF9tb2R1bGUyID0gVGV0aGVyQmFzZS5tb2R1bGVzW2ldO1xyXG5cdCAgICAgICAgdmFyIHJldCA9IF9tb2R1bGUyLnBvc2l0aW9uLmNhbGwodGhpcywge1xyXG5cdCAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG5cdCAgICAgICAgICB0b3A6IHRvcCxcclxuXHQgICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogdGFyZ2V0QXR0YWNobWVudCxcclxuXHQgICAgICAgICAgdGFyZ2V0UG9zOiB0YXJnZXRQb3MsXHJcblx0ICAgICAgICAgIGVsZW1lbnRQb3M6IGVsZW1lbnRQb3MsXHJcblx0ICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG5cdCAgICAgICAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCxcclxuXHQgICAgICAgICAgbWFudWFsT2Zmc2V0OiBtYW51YWxPZmZzZXQsXHJcblx0ICAgICAgICAgIG1hbnVhbFRhcmdldE9mZnNldDogbWFudWFsVGFyZ2V0T2Zmc2V0LFxyXG5cdCAgICAgICAgICBzY3JvbGxiYXJTaXplOiBzY3JvbGxiYXJTaXplLFxyXG5cdCAgICAgICAgICBhdHRhY2htZW50OiB0aGlzLmF0dGFjaG1lbnRcclxuXHQgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcclxuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcmV0ICE9PSAnb2JqZWN0Jykge1xyXG5cdCAgICAgICAgICBjb250aW51ZTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHRvcCA9IHJldC50b3A7XHJcblx0ICAgICAgICAgIGxlZnQgPSByZXQubGVmdDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgLy8gV2UgZGVzY3JpYmUgdGhlIHBvc2l0aW9uIHRocmVlIGRpZmZlcmVudCB3YXlzIHRvIGdpdmUgdGhlIG9wdGltaXplclxyXG5cdCAgICAgIC8vIGEgY2hhbmNlIHRvIGRlY2lkZSB0aGUgYmVzdCBwb3NzaWJsZSB3YXkgdG8gcG9zaXRpb24gdGhlIGVsZW1lbnRcclxuXHQgICAgICAvLyB3aXRoIHRoZSBmZXdlc3QgcmVwYWludHMuXHJcblx0ICAgICAgdmFyIG5leHQgPSB7XHJcblx0ICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYWdlIChhYnNvbHV0ZSBwb3NpdGlvbmluZyB3aGVuXHJcblx0ICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHRoZSBib2R5KVxyXG5cdCAgICAgICAgcGFnZToge1xyXG5cdCAgICAgICAgICB0b3A6IHRvcCxcclxuXHQgICAgICAgICAgbGVmdDogbGVmdFxyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IChmaXhlZCBwb3NpdGlvbmluZylcclxuXHQgICAgICAgIHZpZXdwb3J0OiB7XHJcblx0ICAgICAgICAgIHRvcDogdG9wIC0gcGFnZVlPZmZzZXQsXHJcblx0ICAgICAgICAgIGJvdHRvbTogcGFnZVlPZmZzZXQgLSB0b3AgLSBoZWlnaHQgKyBpbm5lckhlaWdodCxcclxuXHQgICAgICAgICAgbGVmdDogbGVmdCAtIHBhZ2VYT2Zmc2V0LFxyXG5cdCAgICAgICAgICByaWdodDogcGFnZVhPZmZzZXQgLSBsZWZ0IC0gd2lkdGggKyBpbm5lcldpZHRoXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfTtcclxuXHRcclxuXHQgICAgICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IHVuZGVmaW5lZDtcclxuXHQgICAgICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XHJcblx0ICAgICAgICBzY3JvbGxiYXJTaXplID0gdGhpcy5jYWNoZSgnc2Nyb2xsYmFyLXNpemUnLCBnZXRTY3JvbGxCYXJTaXplKTtcclxuXHQgICAgICAgIG5leHQudmlld3BvcnQuYm90dG9tIC09IHNjcm9sbGJhclNpemUuaGVpZ2h0O1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcclxuXHQgICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xyXG5cdCAgICAgICAgbmV4dC52aWV3cG9ydC5yaWdodCAtPSBzY3JvbGxiYXJTaXplLndpZHRoO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoWycnLCAnc3RhdGljJ10uaW5kZXhPZihkb2N1bWVudC5ib2R5LnN0eWxlLnBvc2l0aW9uKSA9PT0gLTEgfHwgWycnLCAnc3RhdGljJ10uaW5kZXhPZihkb2N1bWVudC5ib2R5LnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24pID09PSAtMSkge1xyXG5cdCAgICAgICAgLy8gQWJzb2x1dGUgcG9zaXRpb25pbmcgaW4gdGhlIGJvZHkgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGUgcGFnZSwgbm90IHRoZSAnaW5pdGlhbCBjb250YWluaW5nIGJsb2NrJ1xyXG5cdCAgICAgICAgbmV4dC5wYWdlLmJvdHRvbSA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gdG9wIC0gaGVpZ2h0O1xyXG5cdCAgICAgICAgbmV4dC5wYWdlLnJpZ2h0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCAtIGxlZnQgLSB3aWR0aDtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub3B0aW1pemF0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcHRpb25zLm9wdGltaXphdGlvbnMubW92ZUVsZW1lbnQgIT09IGZhbHNlICYmICEodHlwZW9mIHRoaXMudGFyZ2V0TW9kaWZpZXIgIT09ICd1bmRlZmluZWQnKSkge1xyXG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IF90aGlzNS5jYWNoZSgndGFyZ2V0LW9mZnNldHBhcmVudCcsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KF90aGlzNS50YXJnZXQpO1xyXG5cdCAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgdmFyIG9mZnNldFBvc2l0aW9uID0gX3RoaXM1LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKG9mZnNldFBhcmVudCk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCk7XHJcblx0ICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTaXplID0gb2Zmc2V0UG9zaXRpb247XHJcblx0XHJcblx0ICAgICAgICAgIHZhciBvZmZzZXRCb3JkZXIgPSB7fTtcclxuXHQgICAgICAgICAgWydUb3AnLCAnTGVmdCcsICdCb3R0b20nLCAnUmlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICAgICAgb2Zmc2V0Qm9yZGVyW3NpZGUudG9Mb3dlckNhc2UoKV0gPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudFN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcclxuXHQgICAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICAgIG9mZnNldFBvc2l0aW9uLnJpZ2h0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCAtIG9mZnNldFBvc2l0aW9uLmxlZnQgLSBvZmZzZXRQYXJlbnRTaXplLndpZHRoICsgb2Zmc2V0Qm9yZGVyLnJpZ2h0O1xyXG5cdCAgICAgICAgICBvZmZzZXRQb3NpdGlvbi5ib3R0b20gPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIG9mZnNldFBvc2l0aW9uLnRvcCAtIG9mZnNldFBhcmVudFNpemUuaGVpZ2h0ICsgb2Zmc2V0Qm9yZGVyLmJvdHRvbTtcclxuXHRcclxuXHQgICAgICAgICAgaWYgKG5leHQucGFnZS50b3AgPj0gb2Zmc2V0UG9zaXRpb24udG9wICsgb2Zmc2V0Qm9yZGVyLnRvcCAmJiBuZXh0LnBhZ2UuYm90dG9tID49IG9mZnNldFBvc2l0aW9uLmJvdHRvbSkge1xyXG5cdCAgICAgICAgICAgIGlmIChuZXh0LnBhZ2UubGVmdCA+PSBvZmZzZXRQb3NpdGlvbi5sZWZ0ICsgb2Zmc2V0Qm9yZGVyLmxlZnQgJiYgbmV4dC5wYWdlLnJpZ2h0ID49IG9mZnNldFBvc2l0aW9uLnJpZ2h0KSB7XHJcblx0ICAgICAgICAgICAgICAvLyBXZSdyZSB3aXRoaW4gdGhlIHZpc2libGUgcGFydCBvZiB0aGUgdGFyZ2V0J3Mgc2Nyb2xsIHBhcmVudFxyXG5cdCAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IG9mZnNldFBhcmVudC5zY3JvbGxUb3A7XHJcblx0ICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0J3Mgb2Zmc2V0IHBhcmVudCAoYWJzb2x1dGUgcG9zaXRpb25pbmcgd2hlblxyXG5cdCAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbW92ZWQgdG8gYmUgYSBjaGlsZCBvZiB0aGUgdGFyZ2V0J3Mgb2Zmc2V0IHBhcmVudCkuXHJcblx0ICAgICAgICAgICAgICBuZXh0Lm9mZnNldCA9IHtcclxuXHQgICAgICAgICAgICAgICAgdG9wOiBuZXh0LnBhZ2UudG9wIC0gb2Zmc2V0UG9zaXRpb24udG9wICsgc2Nyb2xsVG9wIC0gb2Zmc2V0Qm9yZGVyLnRvcCxcclxuXHQgICAgICAgICAgICAgICAgbGVmdDogbmV4dC5wYWdlLmxlZnQgLSBvZmZzZXRQb3NpdGlvbi5sZWZ0ICsgc2Nyb2xsTGVmdCAtIG9mZnNldEJvcmRlci5sZWZ0XHJcblx0ICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSkoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgLy8gV2UgY291bGQgYWxzbyB0cmF2ZWwgdXAgdGhlIERPTSBhbmQgdHJ5IGVhY2ggY29udGFpbmluZyBjb250ZXh0LCByYXRoZXIgdGhhbiBvbmx5XHJcblx0ICAgICAgLy8gbG9va2luZyBhdCB0aGUgYm9keSwgYnV0IHdlJ3JlIGdvbm5hIGdldCBkaW1pbmlzaGluZyByZXR1cm5zLlxyXG5cdFxyXG5cdCAgICAgIHRoaXMubW92ZShuZXh0KTtcclxuXHRcclxuXHQgICAgICB0aGlzLmhpc3RvcnkudW5zaGlmdChuZXh0KTtcclxuXHRcclxuXHQgICAgICBpZiAodGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDMpIHtcclxuXHQgICAgICAgIHRoaXMuaGlzdG9yeS5wb3AoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKGZsdXNoQ2hhbmdlcykge1xyXG5cdCAgICAgICAgZmx1c2goKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgLy8gVEhFIElTU1VFXHJcblx0ICB9LCB7XHJcblx0ICAgIGtleTogJ21vdmUnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShwb3MpIHtcclxuXHQgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcclxuXHRcclxuXHQgICAgICBpZiAoISh0eXBlb2YgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgIT09ICd1bmRlZmluZWQnKSkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgc2FtZSA9IHt9O1xyXG5cdFxyXG5cdCAgICAgIGZvciAodmFyIHR5cGUgaW4gcG9zKSB7XHJcblx0ICAgICAgICBzYW1lW3R5cGVdID0ge307XHJcblx0XHJcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gcG9zW3R5cGVdKSB7XHJcblx0ICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGlzdG9yeS5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuaGlzdG9yeVtpXTtcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50W3R5cGVdICE9PSAndW5kZWZpbmVkJyAmJiAhd2l0aGluKHBvaW50W3R5cGVdW2tleV0sIHBvc1t0eXBlXVtrZXldKSkge1xyXG5cdCAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGlmICghZm91bmQpIHtcclxuXHQgICAgICAgICAgICBzYW1lW3R5cGVdW2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHZhciBjc3MgPSB7IHRvcDogJycsIGxlZnQ6ICcnLCByaWdodDogJycsIGJvdHRvbTogJycgfTtcclxuXHRcclxuXHQgICAgICB2YXIgdHJhbnNjcmliZSA9IGZ1bmN0aW9uIHRyYW5zY3JpYmUoX3NhbWUsIF9wb3MpIHtcclxuXHQgICAgICAgIHZhciBoYXNPcHRpbWl6YXRpb25zID0gdHlwZW9mIF90aGlzNi5vcHRpb25zLm9wdGltaXphdGlvbnMgIT09ICd1bmRlZmluZWQnO1xyXG5cdCAgICAgICAgdmFyIGdwdSA9IGhhc09wdGltaXphdGlvbnMgPyBfdGhpczYub3B0aW9ucy5vcHRpbWl6YXRpb25zLmdwdSA6IG51bGw7XHJcblx0ICAgICAgICBpZiAoZ3B1ICE9PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICB2YXIgeVBvcyA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgICAgICAgIHhQb3MgPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgIGlmIChfc2FtZS50b3ApIHtcclxuXHQgICAgICAgICAgICBjc3MudG9wID0gMDtcclxuXHQgICAgICAgICAgICB5UG9zID0gX3Bvcy50b3A7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgY3NzLmJvdHRvbSA9IDA7XHJcblx0ICAgICAgICAgICAgeVBvcyA9IC1fcG9zLmJvdHRvbTtcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICBpZiAoX3NhbWUubGVmdCkge1xyXG5cdCAgICAgICAgICAgIGNzcy5sZWZ0ID0gMDtcclxuXHQgICAgICAgICAgICB4UG9zID0gX3Bvcy5sZWZ0O1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNzcy5yaWdodCA9IDA7XHJcblx0ICAgICAgICAgICAgeFBvcyA9IC1fcG9zLnJpZ2h0O1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGNzc1t0cmFuc2Zvcm1LZXldID0gJ3RyYW5zbGF0ZVgoJyArIE1hdGgucm91bmQoeFBvcykgKyAncHgpIHRyYW5zbGF0ZVkoJyArIE1hdGgucm91bmQoeVBvcykgKyAncHgpJztcclxuXHRcclxuXHQgICAgICAgICAgaWYgKHRyYW5zZm9ybUtleSAhPT0gJ21zVHJhbnNmb3JtJykge1xyXG5cdCAgICAgICAgICAgIC8vIFRoZSBaIHRyYW5zZm9ybSB3aWxsIGtlZXAgdGhpcyBpbiB0aGUgR1BVIChmYXN0ZXIsIGFuZCBwcmV2ZW50cyBhcnRpZmFjdHMpLFxyXG5cdCAgICAgICAgICAgIC8vIGJ1dCBJRTkgZG9lc24ndCBzdXBwb3J0IDNkIHRyYW5zZm9ybXMgYW5kIHdpbGwgY2hva2UuXHJcblx0ICAgICAgICAgICAgY3NzW3RyYW5zZm9ybUtleV0gKz0gXCIgdHJhbnNsYXRlWigwKVwiO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICBpZiAoX3NhbWUudG9wKSB7XHJcblx0ICAgICAgICAgICAgY3NzLnRvcCA9IF9wb3MudG9wICsgJ3B4JztcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBjc3MuYm90dG9tID0gX3Bvcy5ib3R0b20gKyAncHgnO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGlmIChfc2FtZS5sZWZ0KSB7XHJcblx0ICAgICAgICAgICAgY3NzLmxlZnQgPSBfcG9zLmxlZnQgKyAncHgnO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNzcy5yaWdodCA9IF9wb3MucmlnaHQgKyAncHgnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfTtcclxuXHRcclxuXHQgICAgICB2YXIgbW92ZWQgPSBmYWxzZTtcclxuXHQgICAgICBpZiAoKHNhbWUucGFnZS50b3AgfHwgc2FtZS5wYWdlLmJvdHRvbSkgJiYgKHNhbWUucGFnZS5sZWZ0IHx8IHNhbWUucGFnZS5yaWdodCkpIHtcclxuXHQgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblx0ICAgICAgICB0cmFuc2NyaWJlKHNhbWUucGFnZSwgcG9zLnBhZ2UpO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAoKHNhbWUudmlld3BvcnQudG9wIHx8IHNhbWUudmlld3BvcnQuYm90dG9tKSAmJiAoc2FtZS52aWV3cG9ydC5sZWZ0IHx8IHNhbWUudmlld3BvcnQucmlnaHQpKSB7XHJcblx0ICAgICAgICBjc3MucG9zaXRpb24gPSAnZml4ZWQnO1xyXG5cdCAgICAgICAgdHJhbnNjcmliZShzYW1lLnZpZXdwb3J0LCBwb3Mudmlld3BvcnQpO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNhbWUub2Zmc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBzYW1lLm9mZnNldC50b3AgJiYgc2FtZS5vZmZzZXQubGVmdCkge1xyXG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHQgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IF90aGlzNi5jYWNoZSgndGFyZ2V0LW9mZnNldHBhcmVudCcsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KF90aGlzNi50YXJnZXQpO1xyXG5cdCAgICAgICAgICB9KTtcclxuXHRcclxuXHQgICAgICAgICAgaWYgKGdldE9mZnNldFBhcmVudChfdGhpczYuZWxlbWVudCkgIT09IG9mZnNldFBhcmVudCkge1xyXG5cdCAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgIF90aGlzNi5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXM2LmVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50LmFwcGVuZENoaWxkKF90aGlzNi5lbGVtZW50KTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICB0cmFuc2NyaWJlKHNhbWUub2Zmc2V0LCBwb3Mub2Zmc2V0KTtcclxuXHQgICAgICAgICAgbW92ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgfSkoKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHQgICAgICAgIHRyYW5zY3JpYmUoeyB0b3A6IHRydWUsIGxlZnQ6IHRydWUgfSwgcG9zLnBhZ2UpO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoIW1vdmVkKSB7XHJcblx0ICAgICAgICB2YXIgb2Zmc2V0UGFyZW50SXNCb2R5ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdCAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLnRhZ05hbWUgIT09ICdCT0RZJykge1xyXG5cdCAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XHJcblx0ICAgICAgICAgICAgb2Zmc2V0UGFyZW50SXNCb2R5ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKCFvZmZzZXRQYXJlbnRJc0JvZHkpIHtcclxuXHQgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcclxuXHQgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICAvLyBBbnkgY3NzIGNoYW5nZSB3aWxsIHRyaWdnZXIgYSByZXBhaW50LCBzbyBsZXQncyBhdm9pZCBvbmUgaWYgbm90aGluZyBjaGFuZ2VkXHJcblx0ICAgICAgdmFyIHdyaXRlQ1NTID0ge307XHJcblx0ICAgICAgdmFyIHdyaXRlID0gZmFsc2U7XHJcblx0ICAgICAgZm9yICh2YXIga2V5IGluIGNzcykge1xyXG5cdCAgICAgICAgdmFyIHZhbCA9IGNzc1trZXldO1xyXG5cdCAgICAgICAgdmFyIGVsVmFsID0gdGhpcy5lbGVtZW50LnN0eWxlW2tleV07XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWxWYWwgIT09ICcnICYmIHZhbCAhPT0gJycgJiYgWyd0b3AnLCAnbGVmdCcsICdib3R0b20nLCAncmlnaHQnXS5pbmRleE9mKGtleSkgPj0gMCkge1xyXG5cdCAgICAgICAgICBlbFZhbCA9IHBhcnNlRmxvYXQoZWxWYWwpO1xyXG5cdCAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAoZWxWYWwgIT09IHZhbCkge1xyXG5cdCAgICAgICAgICB3cml0ZSA9IHRydWU7XHJcblx0ICAgICAgICAgIHdyaXRlQ1NTW2tleV0gPSB2YWw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGlmICh3cml0ZSkge1xyXG5cdCAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICBleHRlbmQoX3RoaXM2LmVsZW1lbnQuc3R5bGUsIHdyaXRlQ1NTKTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfV0pO1xyXG5cdFxyXG5cdCAgcmV0dXJuIFRldGhlckNsYXNzO1xyXG5cdH0pKCk7XHJcblx0XHJcblx0VGV0aGVyQ2xhc3MubW9kdWxlcyA9IFtdO1xyXG5cdFxyXG5cdFRldGhlckJhc2UucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHRcclxuXHR2YXIgVGV0aGVyID0gZXh0ZW5kKFRldGhlckNsYXNzLCBUZXRoZXJCYXNlKTtcclxuXHQvKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XHJcblx0XHJcblx0dmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcclxuXHR2YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xyXG5cdHZhciBleHRlbmQgPSBfVGV0aGVyQmFzZSRVdGlscy5leHRlbmQ7XHJcblx0dmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xyXG5cdHZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xyXG5cdFxyXG5cdHZhciBCT1VORFNfRk9STUFUID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcclxuXHRcclxuXHRmdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV0aGVyLCB0bykge1xyXG5cdCAgaWYgKHRvID09PSAnc2Nyb2xsUGFyZW50Jykge1xyXG5cdCAgICB0byA9IHRldGhlci5zY3JvbGxQYXJlbnQ7XHJcblx0ICB9IGVsc2UgaWYgKHRvID09PSAnd2luZG93Jykge1xyXG5cdCAgICB0byA9IFtwYWdlWE9mZnNldCwgcGFnZVlPZmZzZXQsIGlubmVyV2lkdGggKyBwYWdlWE9mZnNldCwgaW5uZXJIZWlnaHQgKyBwYWdlWU9mZnNldF07XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAodG8gPT09IGRvY3VtZW50KSB7XHJcblx0ICAgIHRvID0gdG8uZG9jdW1lbnRFbGVtZW50O1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgaWYgKHR5cGVvZiB0by5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICB2YXIgc2l6ZSA9IGdldEJvdW5kcyh0byk7XHJcblx0ICAgICAgdmFyIHBvcyA9IHNpemU7XHJcblx0ICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0byk7XHJcblx0XHJcblx0ICAgICAgdG8gPSBbcG9zLmxlZnQsIHBvcy50b3AsIHNpemUud2lkdGggKyBwb3MubGVmdCwgc2l6ZS5oZWlnaHQgKyBwb3MudG9wXTtcclxuXHRcclxuXHQgICAgICBCT1VORFNfRk9STUFULmZvckVhY2goZnVuY3Rpb24gKHNpZGUsIGkpIHtcclxuXHQgICAgICAgIHNpZGUgPSBzaWRlWzBdLnRvVXBwZXJDYXNlKCkgKyBzaWRlLnN1YnN0cigxKTtcclxuXHQgICAgICAgIGlmIChzaWRlID09PSAnVG9wJyB8fCBzaWRlID09PSAnTGVmdCcpIHtcclxuXHQgICAgICAgICAgdG9baV0gKz0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICB0b1tpXSAtPSBwYXJzZUZsb2F0KHN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgfSkoKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB0bztcclxuXHR9XHJcblx0XHJcblx0VGV0aGVyQmFzZS5tb2R1bGVzLnB1c2goe1xyXG5cdCAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgdmFyIHRvcCA9IF9yZWYudG9wO1xyXG5cdCAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcclxuXHQgICAgdmFyIHRhcmdldEF0dGFjaG1lbnQgPSBfcmVmLnRhcmdldEF0dGFjaG1lbnQ7XHJcblx0XHJcblx0ICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIF9jYWNoZSA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB2YXIgaGVpZ2h0ID0gX2NhY2hlLmhlaWdodDtcclxuXHQgICAgdmFyIHdpZHRoID0gX2NhY2hlLndpZHRoO1xyXG5cdFxyXG5cdCAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgIHZhciBfbGFzdFNpemUgPSB0aGlzLmxhc3RTaXplO1xyXG5cdFxyXG5cdCAgICAgIC8vIEhhbmRsZSB0aGUgaXRlbSBnZXR0aW5nIGhpZGRlbiBhcyBhIHJlc3VsdCBvZiBvdXIgcG9zaXRpb25pbmcgd2l0aG91dCBnbGl0Y2hpbmdcclxuXHQgICAgICAvLyB0aGUgY2xhc3NlcyBpbiBhbmQgb3V0XHJcblx0ICAgICAgd2lkdGggPSBfbGFzdFNpemUud2lkdGg7XHJcblx0ICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgdGFyZ2V0U2l6ZSA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIF90aGlzLmdldFRhcmdldEJvdW5kcygpO1xyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgdmFyIHRhcmdldEhlaWdodCA9IHRhcmdldFNpemUuaGVpZ2h0O1xyXG5cdCAgICB2YXIgdGFyZ2V0V2lkdGggPSB0YXJnZXRTaXplLndpZHRoO1xyXG5cdFxyXG5cdCAgICB2YXIgYWxsQ2xhc3NlcyA9IFt0aGlzLmdldENsYXNzKCdwaW5uZWQnKSwgdGhpcy5nZXRDbGFzcygnb3V0LW9mLWJvdW5kcycpXTtcclxuXHRcclxuXHQgICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuXHQgICAgICB2YXIgb3V0T2ZCb3VuZHNDbGFzcyA9IGNvbnN0cmFpbnQub3V0T2ZCb3VuZHNDbGFzcztcclxuXHQgICAgICB2YXIgcGlubmVkQ2xhc3MgPSBjb25zdHJhaW50LnBpbm5lZENsYXNzO1xyXG5cdFxyXG5cdCAgICAgIGlmIChvdXRPZkJvdW5kc0NsYXNzKSB7XHJcblx0ICAgICAgICBhbGxDbGFzc2VzLnB1c2gob3V0T2ZCb3VuZHNDbGFzcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChwaW5uZWRDbGFzcykge1xyXG5cdCAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBhbGxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG5cdCAgICAgIFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xyXG5cdCAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKGNscyArICctJyArIHNpZGUpO1xyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcclxuXHRcclxuXHQgICAgdmFyIHRBdHRhY2htZW50ID0gZXh0ZW5kKHt9LCB0YXJnZXRBdHRhY2htZW50KTtcclxuXHQgICAgdmFyIGVBdHRhY2htZW50ID0gZXh0ZW5kKHt9LCB0aGlzLmF0dGFjaG1lbnQpO1xyXG5cdFxyXG5cdCAgICB0aGlzLm9wdGlvbnMuY29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG5cdCAgICAgIHZhciB0byA9IGNvbnN0cmFpbnQudG87XHJcblx0ICAgICAgdmFyIGF0dGFjaG1lbnQgPSBjb25zdHJhaW50LmF0dGFjaG1lbnQ7XHJcblx0ICAgICAgdmFyIHBpbiA9IGNvbnN0cmFpbnQucGluO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgYXR0YWNobWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgIGF0dGFjaG1lbnQgPSAnJztcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgdmFyIGNoYW5nZUF0dGFjaFggPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICAgIGNoYW5nZUF0dGFjaFkgPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgaWYgKGF0dGFjaG1lbnQuaW5kZXhPZignICcpID49IDApIHtcclxuXHQgICAgICAgIHZhciBfYXR0YWNobWVudCRzcGxpdCA9IGF0dGFjaG1lbnQuc3BsaXQoJyAnKTtcclxuXHRcclxuXHQgICAgICAgIHZhciBfYXR0YWNobWVudCRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfYXR0YWNobWVudCRzcGxpdCwgMik7XHJcblx0XHJcblx0ICAgICAgICBjaGFuZ2VBdHRhY2hZID0gX2F0dGFjaG1lbnQkc3BsaXQyWzBdO1xyXG5cdCAgICAgICAgY2hhbmdlQXR0YWNoWCA9IF9hdHRhY2htZW50JHNwbGl0MlsxXTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgY2hhbmdlQXR0YWNoWCA9IGNoYW5nZUF0dGFjaFkgPSBhdHRhY2htZW50O1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRpbmdSZWN0KF90aGlzLCB0byk7XHJcblx0XHJcblx0ICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICd0YXJnZXQnIHx8IGNoYW5nZUF0dGFjaFkgPT09ICdib3RoJykge1xyXG5cdCAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XHJcblx0ICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XHJcblx0ICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgIHRvcCAtPSB0YXJnZXRIZWlnaHQ7XHJcblx0ICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ3RvZ2V0aGVyJykge1xyXG5cdCAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcclxuXHRcclxuXHQgICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgICB0b3AgKz0gdGFyZ2V0SGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdEF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xyXG5cdCAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xyXG5cdCAgICAgICAgICAgIHRvcCAtPSB0YXJnZXRIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XHJcblx0XHJcblx0ICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcclxuXHQgICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcclxuXHRcclxuXHQgICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAodEF0dGFjaG1lbnQudG9wID09PSAnbWlkZGxlJykge1xyXG5cdCAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcclxuXHQgICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RhcmdldCcgfHwgY2hhbmdlQXR0YWNoWCA9PT0gJ2JvdGgnKSB7XHJcblx0ICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcclxuXHQgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcclxuXHQgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICd0b2dldGhlcicpIHtcclxuXHQgICAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gdGFyZ2V0V2lkdGg7XHJcblx0ICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0XHJcblx0ICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gdGFyZ2V0V2lkdGg7XHJcblx0ICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcclxuXHQgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XHJcblx0ICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHRcclxuXHQgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH0gZWxzZSBpZiAodEF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcclxuXHQgICAgICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xyXG5cdCAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ2VsZW1lbnQnIHx8IGNoYW5nZUF0dGFjaFkgPT09ICdib3RoJykge1xyXG5cdCAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XHJcblx0ICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XHJcblx0ICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcblx0ICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ2VsZW1lbnQnIHx8IGNoYW5nZUF0dGFjaFggPT09ICdib3RoJykge1xyXG5cdCAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0pIHtcclxuXHQgICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcclxuXHQgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcclxuXHQgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoIC8gMjtcclxuXHQgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XHJcblx0ICAgICAgICAgIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcclxuXHQgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG5cdCAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdjZW50ZXInKSB7XHJcblx0ICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XHJcblx0ICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHR5cGVvZiBwaW4gPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICBwaW4gPSBwaW4uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHApIHtcclxuXHQgICAgICAgICAgcmV0dXJuIHAudHJpbSgpO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgfSBlbHNlIGlmIChwaW4gPT09IHRydWUpIHtcclxuXHQgICAgICAgIHBpbiA9IFsndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJ107XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIHBpbiA9IHBpbiB8fCBbXTtcclxuXHRcclxuXHQgICAgICB2YXIgcGlubmVkID0gW107XHJcblx0ICAgICAgdmFyIG9vYiA9IFtdO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0b3AgPCBib3VuZHNbMV0pIHtcclxuXHQgICAgICAgIGlmIChwaW4uaW5kZXhPZigndG9wJykgPj0gMCkge1xyXG5cdCAgICAgICAgICB0b3AgPSBib3VuZHNbMV07XHJcblx0ICAgICAgICAgIHBpbm5lZC5wdXNoKCd0b3AnKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIG9vYi5wdXNoKCd0b3AnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSkge1xyXG5cdCAgICAgICAgaWYgKHBpbi5pbmRleE9mKCdib3R0b20nKSA+PSAwKSB7XHJcblx0ICAgICAgICAgIHRvcCA9IGJvdW5kc1szXSAtIGhlaWdodDtcclxuXHQgICAgICAgICAgcGlubmVkLnB1c2goJ2JvdHRvbScpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgb29iLnB1c2goJ2JvdHRvbScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSkge1xyXG5cdCAgICAgICAgaWYgKHBpbi5pbmRleE9mKCdsZWZ0JykgPj0gMCkge1xyXG5cdCAgICAgICAgICBsZWZ0ID0gYm91bmRzWzBdO1xyXG5cdCAgICAgICAgICBwaW5uZWQucHVzaCgnbGVmdCcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgb29iLnB1c2goJ2xlZnQnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSkge1xyXG5cdCAgICAgICAgaWYgKHBpbi5pbmRleE9mKCdyaWdodCcpID49IDApIHtcclxuXHQgICAgICAgICAgbGVmdCA9IGJvdW5kc1syXSAtIHdpZHRoO1xyXG5cdCAgICAgICAgICBwaW5uZWQucHVzaCgncmlnaHQnKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIG9vYi5wdXNoKCdyaWdodCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAocGlubmVkLmxlbmd0aCkge1xyXG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgdmFyIHBpbm5lZENsYXNzID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMucGlubmVkQ2xhc3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgcGlubmVkQ2xhc3MgPSBfdGhpcy5vcHRpb25zLnBpbm5lZENsYXNzO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHBpbm5lZENsYXNzID0gX3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGFkZENsYXNzZXMucHVzaChwaW5uZWRDbGFzcyk7XHJcblx0ICAgICAgICAgIHBpbm5lZC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzICsgJy0nICsgc2lkZSk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSkoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKG9vYi5sZW5ndGgpIHtcclxuXHQgICAgICAgIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgIHZhciBvb2JDbGFzcyA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5vcHRpb25zLm91dE9mQm91bmRzQ2xhc3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgb29iQ2xhc3MgPSBfdGhpcy5vcHRpb25zLm91dE9mQm91bmRzQ2xhc3M7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgb29iQ2xhc3MgPSBfdGhpcy5nZXRDbGFzcygnb3V0LW9mLWJvdW5kcycpO1xyXG5cdCAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgIGFkZENsYXNzZXMucHVzaChvb2JDbGFzcyk7XHJcblx0ICAgICAgICAgIG9vYi5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKG9vYkNsYXNzICsgJy0nICsgc2lkZSk7XHJcblx0ICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSkoKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgaWYgKHBpbm5lZC5pbmRleE9mKCdsZWZ0JykgPj0gMCB8fCBwaW5uZWQuaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XHJcblx0ICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gdEF0dGFjaG1lbnQubGVmdCA9IGZhbHNlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAocGlubmVkLmluZGV4T2YoJ3RvcCcpID49IDAgfHwgcGlubmVkLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcclxuXHQgICAgICAgIGVBdHRhY2htZW50LnRvcCA9IHRBdHRhY2htZW50LnRvcCA9IGZhbHNlO1xyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICBpZiAodEF0dGFjaG1lbnQudG9wICE9PSB0YXJnZXRBdHRhY2htZW50LnRvcCB8fCB0QXR0YWNobWVudC5sZWZ0ICE9PSB0YXJnZXRBdHRhY2htZW50LmxlZnQgfHwgZUF0dGFjaG1lbnQudG9wICE9PSBfdGhpcy5hdHRhY2htZW50LnRvcCB8fCBlQXR0YWNobWVudC5sZWZ0ICE9PSBfdGhpcy5hdHRhY2htZW50LmxlZnQpIHtcclxuXHQgICAgICAgIF90aGlzLnVwZGF0ZUF0dGFjaENsYXNzZXMoZUF0dGFjaG1lbnQsIHRBdHRhY2htZW50KTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBkZWZlcihmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgaWYgKCEoX3RoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcclxuXHQgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcclxuXHQgICAgfSk7XHJcblx0XHJcblx0ICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XHJcblx0ICB9XHJcblx0fSk7XHJcblx0LyogZ2xvYmFscyBUZXRoZXJCYXNlICovXHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdHZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XHJcblx0dmFyIGdldEJvdW5kcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldEJvdW5kcztcclxuXHR2YXIgdXBkYXRlQ2xhc3NlcyA9IF9UZXRoZXJCYXNlJFV0aWxzLnVwZGF0ZUNsYXNzZXM7XHJcblx0dmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XHJcblx0XHJcblx0VGV0aGVyQmFzZS5tb2R1bGVzLnB1c2goe1xyXG5cdCAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgdmFyIHRvcCA9IF9yZWYudG9wO1xyXG5cdCAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcclxuXHRcclxuXHQgICAgdmFyIF9jYWNoZSA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICB2YXIgaGVpZ2h0ID0gX2NhY2hlLmhlaWdodDtcclxuXHQgICAgdmFyIHdpZHRoID0gX2NhY2hlLndpZHRoO1xyXG5cdFxyXG5cdCAgICB2YXIgdGFyZ2V0UG9zID0gdGhpcy5nZXRUYXJnZXRCb3VuZHMoKTtcclxuXHRcclxuXHQgICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcclxuXHQgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xyXG5cdFxyXG5cdCAgICB2YXIgYWJ1dHRlZCA9IFtdO1xyXG5cdCAgICBpZiAodG9wIDw9IHRhcmdldFBvcy5ib3R0b20gJiYgYm90dG9tID49IHRhcmdldFBvcy50b3ApIHtcclxuXHQgICAgICBbJ2xlZnQnLCAncmlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcclxuXHQgICAgICAgIGlmICh0YXJnZXRQb3NTaWRlID09PSBsZWZ0IHx8IHRhcmdldFBvc1NpZGUgPT09IHJpZ2h0KSB7XHJcblx0ICAgICAgICAgIGFidXR0ZWQucHVzaChzaWRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAobGVmdCA8PSB0YXJnZXRQb3MucmlnaHQgJiYgcmlnaHQgPj0gdGFyZ2V0UG9zLmxlZnQpIHtcclxuXHQgICAgICBbJ3RvcCcsICdib3R0b20nXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XHJcblx0ICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcclxuXHQgICAgICAgIGlmICh0YXJnZXRQb3NTaWRlID09PSB0b3AgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gYm90dG9tKSB7XHJcblx0ICAgICAgICAgIGFidXR0ZWQucHVzaChzaWRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgYWxsQ2xhc3NlcyA9IFtdO1xyXG5cdCAgICB2YXIgYWRkQ2xhc3NlcyA9IFtdO1xyXG5cdFxyXG5cdCAgICB2YXIgc2lkZXMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xyXG5cdCAgICBhbGxDbGFzc2VzLnB1c2godGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpKTtcclxuXHQgICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xyXG5cdCAgICAgIGFsbENsYXNzZXMucHVzaChfdGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpICsgJy0nICsgc2lkZSk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICBpZiAoYWJ1dHRlZC5sZW5ndGgpIHtcclxuXHQgICAgICBhZGRDbGFzc2VzLnB1c2godGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBhYnV0dGVkLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcclxuXHQgICAgICBhZGRDbGFzc2VzLnB1c2goX3RoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSArICctJyArIHNpZGUpO1xyXG5cdCAgICB9KTtcclxuXHRcclxuXHQgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIGlmICghKF90aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XHJcblx0ICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzLnRhcmdldCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMuZWxlbWVudCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XHJcblx0ICAgIH0pO1xyXG5cdFxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH1cclxuXHR9KTtcclxuXHQvKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XHJcblx0XHJcblx0VGV0aGVyQmFzZS5tb2R1bGVzLnB1c2goe1xyXG5cdCAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcclxuXHQgICAgdmFyIHRvcCA9IF9yZWYudG9wO1xyXG5cdCAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hpZnQpIHtcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdmFyIHNoaWZ0ID0gdGhpcy5vcHRpb25zLnNoaWZ0O1xyXG5cdCAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zaGlmdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgIHNoaWZ0ID0gdGhpcy5vcHRpb25zLnNoaWZ0LmNhbGwodGhpcywgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9KTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgc2hpZnRUb3AgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBzaGlmdExlZnQgPSB1bmRlZmluZWQ7XHJcblx0ICAgIGlmICh0eXBlb2Ygc2hpZnQgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgc2hpZnQgPSBzaGlmdC5zcGxpdCgnICcpO1xyXG5cdCAgICAgIHNoaWZ0WzFdID0gc2hpZnRbMV0gfHwgc2hpZnRbMF07XHJcblx0XHJcblx0ICAgICAgdmFyIF9zaGlmdCA9IHNoaWZ0O1xyXG5cdFxyXG5cdCAgICAgIHZhciBfc2hpZnQyID0gX3NsaWNlZFRvQXJyYXkoX3NoaWZ0LCAyKTtcclxuXHRcclxuXHQgICAgICBzaGlmdFRvcCA9IF9zaGlmdDJbMF07XHJcblx0ICAgICAgc2hpZnRMZWZ0ID0gX3NoaWZ0MlsxXTtcclxuXHRcclxuXHQgICAgICBzaGlmdFRvcCA9IHBhcnNlRmxvYXQoc2hpZnRUb3AsIDEwKTtcclxuXHQgICAgICBzaGlmdExlZnQgPSBwYXJzZUZsb2F0KHNoaWZ0TGVmdCwgMTApO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHNoaWZ0VG9wID0gc2hpZnQudG9wO1xyXG5cdCAgICAgIHNoaWZ0TGVmdCA9IHNoaWZ0LmxlZnQ7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdG9wICs9IHNoaWZ0VG9wO1xyXG5cdCAgICBsZWZ0ICs9IHNoaWZ0TGVmdDtcclxuXHRcclxuXHQgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuXHQgIH1cclxuXHR9KTtcclxuXHRyZXR1cm4gVGV0aGVyO1xyXG5cdFxyXG5cdH0pKTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA2MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZ1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBldmVudFRhcmdldHNDb21wb25lbnQ6IGZ1bmN0aW9uIGV2ZW50VGFyZ2V0c0NvbXBvbmVudChldmVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgIGlmIChldmVudFRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaWQgPT09IGV2ZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNjIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48dWxcXG4gICAgY2xhc3M9XFxcInVpLW1lbnVcXFwiIHJvbGU9XFxcIm1lbnVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgQGtleWRvd24uZXNjPVxcXCJjbG9zZURyb3Bkb3duXFxcIiB2LWVsOmRyb3Bkb3duXFxuICAgIDpjbGFzcz1cXFwieyAnaGFzLWljb25zJzogc2hvd0ljb25zLCAnaGFzLXNlY29uZGFyeS10ZXh0Jzogc2hvd1NlY29uZGFyeVRleHQgfVxcXCJcXG4+XFxuICAgIDx1aS1tZW51LW9wdGlvblxcbiAgICAgICAgOnR5cGU9XFxcIm9wdGlvbi50eXBlXFxcIiA6aWNvbj1cXFwib3B0aW9uLmljb25cXFwiIDp0ZXh0PVxcXCJvcHRpb24udGV4dFxcXCIgOmRpc2FibGVkPVxcXCJvcHRpb24uZGlzYWJsZWRcXFwiXFxuICAgICAgICA6c2Vjb25kYXJ5LXRleHQ9XFxcIm9wdGlvbi5zZWNvbmRhcnlUZXh0XFxcIiA6b3B0aW9uPVxcXCJvcHRpb25cXFwiIDpzaG93LWljb249XFxcInNob3dJY29uc1xcXCJcXG4gICAgICAgIDpzaG93LXNlY29uZGFyeS10ZXh0PVxcXCJzaG93U2Vjb25kYXJ5VGV4dFxcXCIgOmhpZGUtcmlwcGxlLWluaz1cXFwiaGlkZVJpcHBsZUlua1xcXCJcXG4gICAgICAgIDpwYXJ0aWFsPVxcXCJvcHRpb24ucGFydGlhbCB8fCBwYXJ0aWFsXFxcIlxcblxcbiAgICAgICAgQGtleWRvd24uZW50ZXIucHJldmVudD1cXFwib3B0aW9uU2VsZWN0KG9wdGlvbilcXFwiIEBjbGljaz1cXFwib3B0aW9uU2VsZWN0KG9wdGlvbilcXFwiXFxuXFxuICAgICAgICB2LWZvcj1cXFwib3B0aW9uIGluIG9wdGlvbnNcXFwiXFxuICAgID48L3VpLW1lbnUtb3B0aW9uPlxcblxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktbWVudS1mb2N1cy1yZWRpcmVjdG9yXFxcIiBAZm9jdXM9XFxcInJlZGlyZWN0Rm9jdXNcXFwiIHRhYmluZGV4PVxcXCIwXFxcIlxcbiAgICA+PC9kaXY+XFxuPC91bD5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDYzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVBvcG92ZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVBvcG92ZXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDY0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogNjUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzRHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxuXHRcclxuXHR2YXIgX1Nob3dzRHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NEcm9wZG93bik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1wb3BvdmVyJyxcclxuXHRcclxuXHQgICAgZXZlbnRzOiB7XHJcblx0ICAgICAgICAnZHJvcGRvd24tb3BlbmVkJzogZnVuY3Rpb24gZHJvcGRvd25PcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbkZvY3VzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZXN0cmljdEZvY3VzLCB0cnVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ29wZW5lZCcpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICdkcm9wZG93bi1jbG9zZWQnOiBmdW5jdGlvbiBkcm9wZG93bkNsb3NlZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250YWluRm9jdXMpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlc3RyaWN0Rm9jdXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xvc2VkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIHJlc3RyaWN0Rm9jdXM6IGZ1bmN0aW9uIHJlc3RyaWN0Rm9jdXMoZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy4kZWxzLmRyb3Bkb3duLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRlbHMuZHJvcGRvd24uZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c0Ryb3Bkb3duMi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA2NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXBvcG92ZXJcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBAa2V5ZG93bi5lc2M9XFxcImNsb3NlRHJvcGRvd25cXFwiIHYtZWw6ZHJvcGRvd25cXG4+XFxuICAgIDxzbG90Pjwvc2xvdD5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDY3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVByb2dyZXNzQ2lyY3VsYXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVByb2dyZXNzQ2lyY3VsYXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDY4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogNjkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1wcm9ncmVzcy1jaXJjdWxhcicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBzaG93OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2luZGV0ZXJtaW5hdGUnIH0sXHJcblx0ICAgICAgICBjb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeScgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDBcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaXplOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDMyXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3Ryb2tlOiBOdW1iZXIsXHJcblx0ICAgICAgICBhdXRvU3Ryb2tlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZVRyYW5zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzdHJva2VEYXNoQXJyYXk6IGZ1bmN0aW9uIHN0cm9rZURhc2hBcnJheSgpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5yYWRpdXM7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoY2lyY3VtZmVyZW5jZSAqIDEwMDApIC8gMTAwMDtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdHJva2VEYXNoT2Zmc2V0OiBmdW5jdGlvbiBzdHJva2VEYXNoT2Zmc2V0KCkge1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZXJhdGVWYWx1ZSh0aGlzLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB2YXIgY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5yYWRpdXM7XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICgxMDAgLSB2YWx1ZSkgLyAxMDAgKiBjaXJjdW1mZXJlbmNlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJhZGl1czogZnVuY3Rpb24gcmFkaXVzKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiAodGhpcy5zaXplIC0gdGhpcy5zdHJva2UpIC8gMjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5zdHJva2UpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5hdXRvU3Ryb2tlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gcGFyc2VJbnQodGhpcy5zaXplIC8gOCwgMTApO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gNDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIG1vZGVyYXRlVmFsdWU6IGZ1bmN0aW9uIG1vZGVyYXRlVmFsdWUodmFsdWUpIHtcclxuXHQgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID4gMTAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxMDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyXFxcIiA6c3R5bGU9XFxcInsgJ3dpZHRoJzogc2l6ZSArICdweCcsICdoZWlnaHQnOiBzaXplICsgJ3B4JyB9XFxcIlxcbiAgICB2LXNob3c9XFxcInNob3dcXFwiIDp0cmFuc2l0aW9uPVxcXCJkaXNhYmxlVHJhbnNpdGlvbiA/IG51bGwgOiAndWktcHJvZ3Jlc3MtY2lyY3VsYXItdG9nZ2xlJ1xcXCJcXG4+XFxuICAgIDxzdmdcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1wcm9ncmVzcy1jaXJjdWxhci1kZXRlcm1pbmF0ZVxcXCIgOndpZHRoPVxcXCJzaXplXFxcIiA6aGVpZ2h0PVxcXCJzaXplXFxcIlxcbiAgICAgICAgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIiA6YXJpYS12YWx1ZW5vdz1cXFwidmFsdWVcXFwiXFxuICAgICAgICB2LWlmPVxcXCJ0eXBlID09PSAnZGV0ZXJtaW5hdGUnXFxcIlxcbiAgICA+XFxuICAgICAgICA8Y2lyY2xlXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyLWRldGVybWluYXRlLXBhdGhcXFwiIDpjbGFzcz1cXFwiW2NvbG9yXVxcXCIgOnI9XFxcInJhZGl1c1xcXCJcXG4gICAgICAgICAgICA6Y3g9XFxcInNpemUgLyAyXFxcIiA6Y3k9XFxcInNpemUgLyAyXFxcIiBmaWxsPVxcXCJ0cmFuc3BhcmVudFxcXCIgOnN0cm9rZS1kYXNoYXJyYXk9XFxcInN0cm9rZURhc2hBcnJheVxcXCJcXG4gICAgICAgICAgICBzdHJva2UtZGFzaG9mZnNldD1cXFwiMFxcXCJcXG5cXG4gICAgICAgICAgICA6c3R5bGU9XFxcInsgJ3N0cm9rZS1kYXNob2Zmc2V0Jzogc3Ryb2tlRGFzaE9mZnNldCwgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZSB9XFxcIlxcbiAgICAgICAgPjwvY2lyY2xlPlxcbiAgICA8L3N2Zz5cXG5cXG4gICAgPHN2Z1xcbiAgICAgICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWNpcmN1bGFyLWluZGV0ZXJtaW5hdGVcXFwiIHZpZXdCb3g9XFxcIjI1IDI1IDUwIDUwXFxcIlxcbiAgICAgICAgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIiB2LWVsc2VcXG4gICAgPlxcbiAgICAgICAgPGNpcmNsZVxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1wcm9ncmVzcy1jaXJjdWxhci1pbmRldGVybWluYXRlLXBhdGhcXFwiIDpjbGFzcz1cXFwiW2NvbG9yXVxcXCIgY3g9XFxcIjUwXFxcIiBjeT1cXFwiNTBcXFwiXFxuICAgICAgICAgICAgcj1cXFwiMjBcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZS1taXRlcmxpbWl0PVxcXCIxMFxcXCIgOnN0cm9rZS13aWR0aD1cXFwic3Ryb2tlXFxcIlxcbiAgICAgICAgPlxcbiAgICA8L3N2Zz5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDcxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgdGhpcy5lbC5kaXNhYmxlZCA9IEJvb2xlYW4odmFsdWUpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG9wZW5Ecm9wZG93bk9uOiBTdHJpbmcsXHJcblx0ICAgICAgICBkcm9wZG93blBvc2l0aW9uOiBTdHJpbmcsXHJcblx0ICAgICAgICBoYXNQb3BvdmVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhhc0Ryb3Bkb3duTWVudToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBtZW51T3B0aW9uczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEFycmF5LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dNZW51SWNvbnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd01lbnVTZWNvbmRhcnlUZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBtZW51T3B0aW9uU2VsZWN0OiBmdW5jdGlvbiBtZW51T3B0aW9uU2VsZWN0KG9wdGlvbikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtZW51LW9wdGlvbi1zZWxlY3RlZCcsIG9wdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogNzMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX1VpVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xyXG5cdFxyXG5cdHZhciBfVWlUb29sdGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpVG9vbHRpcCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0b29sdGlwOiBTdHJpbmcsXHJcblx0ICAgICAgICBvcGVuVG9vbHRpcE9uOiBTdHJpbmcsXHJcblx0ICAgICAgICB0b29sdGlwUG9zaXRpb246IFN0cmluZ1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVRvb2x0aXA6IF9VaVRvb2x0aXAyLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3NSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlUb29sdGlwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlUb29sdGlwLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDc2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF90ZXRoZXJUb29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XHJcblx0XHJcblx0dmFyIF90ZXRoZXJUb29sdGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RldGhlclRvb2x0aXApO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktdG9vbHRpcCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBjb250ZW50OiBTdHJpbmcsXHJcblx0ICAgICAgICB0cmlnZ2VyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogRWxlbWVudCxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBvc2l0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdib3R0b20gY2VudGVyJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW5Pbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnaG92ZXIgZm9jdXMnXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHRvb2x0aXA6IG51bGxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy50b29sdGlwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGJlZm9yZURlc3Rvcnk6IGZ1bmN0aW9uIGJlZm9yZURlc3RvcnkoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy50b29sdGlwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b29sdGlwLnJlbW92ZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9vbHRpcC5kZXN0cm95KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgX3RldGhlclRvb2x0aXAyLmRlZmF1bHQoe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRyaWdnZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLiRlbHMudG9vbHRpcCxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6ICd1aS10b29sdGlwLXRoZW1lJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb3Blbk9uOiAnaG92ZXIgZm9jdXMnXHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA3NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIHRldGhlci10b29sdGlwIDEuMS4wICovXHJcblx0XHJcblx0KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHQgIGlmICh0cnVlKSB7XHJcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3RldGhlci1kcm9wJyksIHJlcXVpcmUoJ3RldGhlcicpKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJvb3QuVG9vbHRpcCA9IGZhY3Rvcnkocm9vdC5Ecm9wLCByb290LlRldGhlcik7XHJcblx0ICB9XHJcblx0fSh0aGlzLCBmdW5jdGlvbihEcm9wLCBUZXRoZXIpIHtcclxuXHRcclxuXHQvKiBnbG9iYWwgVGV0aGVyIERyb3AgKi9cclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cclxuXHRcclxuXHR2YXIgZXh0ZW5kID0gVGV0aGVyLlV0aWxzLmV4dGVuZDtcclxuXHRcclxuXHR2YXIgX0Ryb3AgPSBEcm9wLmNyZWF0ZUNvbnRleHQoe1xyXG5cdCAgY2xhc3NQcmVmaXg6ICd0b29sdGlwJ1xyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBkZWZhdWx0cyA9IHtcclxuXHQgIHBvc2l0aW9uOiAndG9wIGNlbnRlcicsXHJcblx0ICBvcGVuT246ICdob3ZlcicsXHJcblx0ICBjbGFzc2VzOiAndG9vbHRpcC10aGVtZS1hcnJvd3MnLFxyXG5cdCAgY29uc3RyYWluVG9XaW5kb3c6IHRydWUsXHJcblx0ICBjb25zdHJhaW5Ub1Njcm9sbFBhcmVudDogZmFsc2VcclxuXHR9O1xyXG5cdFxyXG5cdHZhciB0b29sdGlwQ291bnQgPSAwO1xyXG5cdFxyXG5cdHZhciBUb29sdGlwID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgIGZ1bmN0aW9uIFRvb2x0aXAob3B0aW9ucykge1xyXG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XHJcblx0XHJcblx0ICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHJcblx0ICAgIGlmICghdGhpcy5vcHRpb25zLnRhcmdldCkge1xyXG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbHRpcCBFcnJvcjogWW91IG11c3QgcHJvdmlkZSBhIHRhcmdldCBmb3IgVG9vbHRpcCB0byBhdHRhY2ggdG8nKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXBvc2l0aW9uJyk7XHJcblx0ICAgIGlmIChwb3NpdGlvbikge1xyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHZhciBjb250ZW50ID0gdGhpcy5vcHRpb25zLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcCcpO1xyXG5cdFxyXG5cdCAgICBpZiAoY29udGVudCkge1xyXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvbnRlbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB2YXIgY29udGVudEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ICAgICAgICBjb250ZW50RWwuaW5uZXJIVE1MID0gY29udGVudDtcclxuXHRcclxuXHQgICAgICAgIC8vIEFkZCBBUklBIGF0dHJpYnV0ZXMgKHNlZSAjNTApXHJcblx0ICAgICAgICBjb250ZW50RWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcclxuXHQgICAgICAgIGNvbnRlbnRFbC5pZCA9ICdkcm9wLXRvb2x0aXAtJyArIHRvb2x0aXBDb3VudDtcclxuXHQgICAgICAgIHRoaXMub3B0aW9ucy50YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgY29udGVudEVsLmlkKTtcclxuXHQgICAgICAgIHRvb2x0aXBDb3VudCArPSAxO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnQgPSBjb250ZW50RWw7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb2x0aXAgRXJyb3I6IFlvdSBtdXN0IHByb3ZpZGUgY29udGVudCBmb3IgVG9vbHRpcCB0byBkaXNwbGF5Jyk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgdGhpcy5vcHRpb25zKTtcclxuXHRcclxuXHQgICAgdGhpcy5kcm9wID0gbmV3IF9Ecm9wKHRoaXMub3B0aW9ucyk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcclxuXHQgICAga2V5OiAnY2xvc2UnLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XHJcblx0ICAgICAgdGhpcy5kcm9wLmNsb3NlKCk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnb3BlbicsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xyXG5cdCAgICAgIHRoaXMuZHJvcC5vcGVuKCk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAndG9nZ2xlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcclxuXHQgICAgICB0aGlzLmRyb3AudG9nZ2xlKCk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAncmVtb3ZlJyxcclxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcclxuXHQgICAgICB0aGlzLmRyb3AucmVtb3ZlKCk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAnZGVzdHJveScsXHJcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG5cdCAgICAgIHRoaXMuZHJvcC5kZXN0cm95KCk7XHJcblx0ICAgIH1cclxuXHQgIH0sIHtcclxuXHQgICAga2V5OiAncG9zaXRpb24nLFxyXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XHJcblx0ICAgICAgdGhpcy5kcm9wLnBvc2l0aW9uKCk7XHJcblx0ICAgIH1cclxuXHQgIH1dKTtcclxuXHRcclxuXHQgIHJldHVybiBUb29sdGlwO1xyXG5cdH0pKCk7XHJcblx0XHJcblx0dmFyIGluaXRpYWxpemVkID0gW107XHJcblx0XHJcblx0VG9vbHRpcC5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgdmFyIHRvb2x0aXBFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRvb2x0aXBdJyk7XHJcblx0ICB2YXIgbGVuID0gdG9vbHRpcEVsZW1lbnRzLmxlbmd0aDtcclxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgdmFyIGVsID0gdG9vbHRpcEVsZW1lbnRzW2ldO1xyXG5cdCAgICBpZiAoaW5pdGlhbGl6ZWQuaW5kZXhPZihlbCkgPT09IC0xKSB7XHJcblx0ICAgICAgbmV3IFRvb2x0aXAoe1xyXG5cdCAgICAgICAgdGFyZ2V0OiBlbFxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICAgIGluaXRpYWxpemVkLnB1c2goZWwpO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgaWYgKFRvb2x0aXAuYXV0b2luaXQgIT09IGZhbHNlKSB7XHJcblx0ICAgIFRvb2x0aXAuaW5pdCgpO1xyXG5cdCAgfVxyXG5cdH0pO1xyXG5cdHJldHVybiBUb29sdGlwO1xyXG5cdFxyXG5cdH0pKTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA3OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXRvb2x0aXBcXFwiIHYtdGV4dD1cXFwiY29udGVudFxcXCIgdi1lbDp0b29sdGlwPjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNzkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48YnV0dG9uXFxuICAgIGNsYXNzPVxcXCJ1aS1pY29uLWJ1dHRvblxcXCIgOmNsYXNzPVxcXCJzdHlsZUNsYXNzZXNcXFwiIDphcmlhLWxhYmVsPVxcXCJhcmlhTGFiZWwgfHwgdG9vbHRpcFxcXCJcXG4gICAgOnR5cGU9XFxcImJ1dHRvblR5cGVcXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkIHx8IGxvYWRpbmdcXFwiIHYtZWw6YnV0dG9uXFxuPlxcbiAgICA8dWktaWNvblxcbiAgICAgICAgY2xhc3M9XFxcInVpLWljb24tYnV0dG9uLWljb25cXFwiIDppY29uPVxcXCJpY29uXFxcIiB2LXNob3c9XFxcIiFsb2FkaW5nXFxcIlxcbiAgICA+PC91aS1pY29uPlxcblxcbiAgICA8dWktcHJvZ3Jlc3MtY2lyY3VsYXJcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1pY29uLWJ1dHRvbi1zcGlubmVyXFxcIiA6Y29sb3I9XFxcInNwaW5uZXJDb2xvclxcXCIgOnNpemU9XFxcIjI0XFxcIiA6c3Ryb2tlPVxcXCI0LjVcXFwiXFxuICAgICAgICBkaXNhYmxlLXRyYW5zaXRpb24gdi1zaG93PVxcXCJsb2FkaW5nXFxcIlxcbiAgICA+PC91aS1wcm9ncmVzcy1jaXJjdWxhcj5cXG5cXG4gICAgPHVpLXJpcHBsZS1pbmsgdi1pZj1cXFwiIWhpZGVSaXBwbGVJbmsgJiYgIWRpc2FibGVkXFxcIiA6dHJpZ2dlcj1cXFwiJGVscy5idXR0b25cXFwiPjwvdWktcmlwcGxlLWluaz5cXG5cXG4gICAgPHVpLXRvb2x0aXBcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOmNvbnRlbnQ9XFxcInRvb2x0aXBcXFwiIDpwb3NpdGlvbj1cXFwidG9vbHRpcFBvc2l0aW9uXFxcIiB2LWlmPVxcXCJ0b29sdGlwXFxcIlxcbiAgICAgICAgOm9wZW4tb249XFxcIm9wZW5Ub29sdGlwT25cXFwiXFxuICAgID48L3VpLXRvb2x0aXA+XFxuXFxuICAgIDx1aS1tZW51XFxuICAgICAgICBjbGFzcz1cXFwidWktYnV0dG9uLWRyb3Bkb3duLW1lbnVcXFwiIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOm9wdGlvbnM9XFxcIm1lbnVPcHRpb25zXFxcIlxcbiAgICAgICAgOnNob3ctaWNvbnM9XFxcInNob3dNZW51SWNvbnNcXFwiIDpzaG93LXNlY29uZGFyeS10ZXh0PVxcXCJzaG93TWVudVNlY29uZGFyeVRleHRcXFwiXFxuICAgICAgICA6b3Blbi1vbj1cXFwib3BlbkRyb3Bkb3duT25cXFwiIEBvcHRpb24tc2VsZWN0ZWQ9XFxcIm1lbnVPcHRpb25TZWxlY3RcXFwiXFxuICAgICAgICA6ZHJvcGRvd24tcG9zaXRpb249XFxcImRyb3Bkb3duUG9zaXRpb25cXFwiIHYtaWY9XFxcImhhc0Ryb3Bkb3duTWVudVxcXCJcXG4gICAgPjwvdWktbWVudT5cXG5cXG4gICAgPHVpLXBvcG92ZXJcXG4gICAgICAgIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgOm9wZW4tb249XFxcIm9wZW5Ecm9wZG93bk9uXFxcIiA6ZHJvcGRvd24tcG9zaXRpb249XFxcImRyb3Bkb3duUG9zaXRpb25cXFwiXFxuICAgICAgICB2LWlmPVxcXCJoYXNQb3BvdmVyXFxcIlxcbiAgICA+XFxuICAgICAgICA8c2xvdCBuYW1lPVxcXCJwb3BvdmVyXFxcIj48L3Nsb3Q+XFxuICAgIDwvdWktcG9wb3Zlcj5cXG48L2J1dHRvbj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDgwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktYWxlcnRcXFwiPlxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktYWxlcnQtYm9keVxcXCIgOmNsYXNzPVxcXCJbdHlwZV1cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIiB2LXNob3c9XFxcInNob3dcXFwiXFxuICAgICAgICB0cmFuc2l0aW9uPVxcXCJ1aS1hbGVydC10b2dnbGVcXFwiXFxuICAgID5cXG4gICAgICAgIDx1aS1pY29uIGNsYXNzPVxcXCJ1aS1hbGVydC1pY29uXFxcIiA6aWNvbj1cXFwiaWNvbk5hbWVcXFwiIHYtaWY9XFxcIiFoaWRlSWNvblxcXCI+PC91aS1pY29uPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktYWxlcnQtdGV4dFxcXCI+XFxuICAgICAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cXFwidGV4dFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvc2xvdD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLWFsZXJ0LWNsb3NlLWJ1dHRvblxcXCIgdHlwZT1cXFwiY2xlYXJcXFwiIGljb249XFxcIiYjeEU1Q0RcXFwiIGFyaWEtbGFiZWw9XFxcIkNsb3NlXFxcIlxcbiAgICAgICAgICAgIEBjbGljaz1cXFwiY2xvc2VcXFwiIHYtaWY9XFxcImRpc21pc3NpYmxlXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogODEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oODIpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQXV0b2NvbXBsZXRlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA4KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQXV0b2NvbXBsZXRlLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiA4MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDgzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9mdXp6eXNlYXJjaCA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xyXG5cdFxyXG5cdHZhciBfZnV6enlzZWFyY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnV6enlzZWFyY2gpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfVWlBdXRvY29tcGxldGVTdWdnZXN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XHJcblx0XHJcblx0dmFyIF9VaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlBdXRvY29tcGxldGVTdWdnZXN0aW9uKTtcclxuXHRcclxuXHR2YXIgX2F1dG9mb2N1cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xyXG5cdFxyXG5cdHZhciBfYXV0b2ZvY3VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F1dG9mb2N1cyk7XHJcblx0XHJcblx0dmFyIF9IYXNUZXh0SW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IYXNUZXh0SW5wdXQpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcclxuXHRcclxuXHR2YXIgX1ZhbGlkYXRlc0lucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRlc0lucHV0KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWF1dG9jb21wbGV0ZScsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBzdWdnZXN0aW9uczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEFycmF5LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IFtdXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGltaXQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogOFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnRpYWw6IFN0cmluZyxcclxuXHQgICAgICAgIGFwcGVuZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhcHBlbmREZWxpbWl0ZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJywgJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1pbkNoYXJzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDJcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93T25VcERvd246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhdXRvZm9jdXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZmlsdGVyOiBGdW5jdGlvbixcclxuXHQgICAgICAgIGF1dG9IaWdobGlnaHRGaXJzdE1hdGNoOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY3ljbGVIaWdobGlnaHQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBrZXlzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3RleHQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd2YWx1ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbWFnZTogJ2ltYWdlJ1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2hvd0Ryb3Bkb3duOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBoaWdobGlnaHRlZEl0ZW06IC0xLFxyXG5cdCAgICAgICAgICAgIGlnbm9yZVZhbHVlQ2hhbmdlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHNob3dJY29uOiBmdW5jdGlvbiBzaG93SWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmljb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1pbnB1dDo6cmVzZXQnOiBmdW5jdGlvbiB1aUlucHV0UmVzZXQoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRlbHMuaW5wdXQpIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmluaXRpYWxWYWx1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmlnbm9yZVZhbHVlQ2hhbmdlICYmIHRoaXMudmFsdWUubGVuZ3RoID49IHRoaXMubWluQ2hhcnMpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gdGhpcy5hdXRvSGlnaGxpZ2h0Rmlyc3RNYXRjaCA/IDAgOiAtMTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayk7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKGl0ZW0pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGl0ZW0sIHRoaXMudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgdGV4dCA9IGl0ZW1bdGhpcy5rZXlzLnRleHRdIHx8IGl0ZW07XHJcblx0ICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy52YWx1ZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgX2Z1enp5c2VhcmNoMi5kZWZhdWx0KShxdWVyeSwgdGV4dC50b0xvd2VyQ2FzZSgpKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChpdGVtKSB7XHJcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSArPSB0aGlzLmFwcGVuZERlbGltaXRlciArIChpdGVtW3RoaXMua2V5cy52YWx1ZV0gfHwgaXRlbSk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGl0ZW1bdGhpcy5rZXlzLnZhbHVlXSB8fCBpdGVtO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2VsZWN0ZWQnLCBpdGVtKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBfdGhpcy4kZWxzLmlucHV0LmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiBoaWdobGlnaHQoaW5kZXgpIHtcclxuXHQgICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IDA7XHJcblx0ICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuJHJlZnMuaXRlbXMubGVuZ3RoIC0gMTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0yKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCBmaXJzdEluZGV4KSB7XHJcblx0ICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5jeWNsZUhpZ2hsaWdodCA/IGxhc3RJbmRleCA6IGluZGV4O1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmN5Y2xlSGlnaGxpZ2h0ID8gZmlyc3RJbmRleCA6IC0xO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSXRlbSA9IGluZGV4O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNob3dPblVwRG93bikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGluZGV4IDwgZmlyc3RJbmRleCB8fCBpbmRleCA+IGxhc3RJbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnaGlnaGxpZ2h0LW92ZXJmbG93JywgaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdoaWdobGlnaHRlZCcsIHRoaXMuJHJlZnMuaXRlbXNbaW5kZXhdLml0ZW0sIGluZGV4KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VsZWN0SGlnaGxpZ2h0ZWQ6IGZ1bmN0aW9uIHNlbGVjdEhpZ2hsaWdodGVkKGluZGV4LCBlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duICYmIHRoaXMuJHJlZnMuaXRlbXMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy4kcmVmcy5pdGVtc1tpbmRleF0uaXRlbSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsZWFyU2VhcmNoOiBmdW5jdGlvbiBjbGVhclNlYXJjaCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ29wZW5lZCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gLTE7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbG9zZWQnKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbG9zZU9uRXh0ZXJuYWxDbGljazogZnVuY3Rpb24gY2xvc2VPbkV4dGVybmFsQ2xpY2soZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy4kZWxzLmF1dG9jb21wbGV0ZS5jb250YWlucyhlLnRhcmdldCkgJiYgdGhpcy5zaG93RHJvcGRvd24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZGlydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb246IF9VaUF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgYXV0b2ZvY3VzOiBfYXV0b2ZvY3VzMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19IYXNUZXh0SW5wdXQyLmRlZmF1bHQsIF9WYWxpZGF0ZXNJbnB1dDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogODQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRmdW5jdGlvbiBmdXp6eXNlYXJjaCAobmVlZGxlLCBoYXlzdGFjaykge1xyXG5cdCAgdmFyIHRsZW4gPSBoYXlzdGFjay5sZW5ndGg7XHJcblx0ICB2YXIgcWxlbiA9IG5lZWRsZS5sZW5ndGg7XHJcblx0ICBpZiAocWxlbiA+IHRsZW4pIHtcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfVxyXG5cdCAgaWYgKHFsZW4gPT09IHRsZW4pIHtcclxuXHQgICAgcmV0dXJuIG5lZWRsZSA9PT0gaGF5c3RhY2s7XHJcblx0ICB9XHJcblx0ICBvdXRlcjogZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgcWxlbjsgaSsrKSB7XHJcblx0ICAgIHZhciBuY2ggPSBuZWVkbGUuY2hhckNvZGVBdChpKTtcclxuXHQgICAgd2hpbGUgKGogPCB0bGVuKSB7XHJcblx0ICAgICAgaWYgKGhheXN0YWNrLmNoYXJDb2RlQXQoaisrKSA9PT0gbmNoKSB7XHJcblx0ICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnV6enlzZWFyY2g7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogODUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oODYpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogODYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiA4NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfdXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG5cdFxyXG5cdHZhciBfdXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dWlkKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3V1aWQyLmRlZmF1bHQuc2hvcnQoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaXRlbToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJ0aWFsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd1aS1hdXRvY29tcGxldGUtc2ltcGxlJyB9LFxyXG5cdCAgICAgICAgaGlnaGxpZ2h0ZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAga2V5czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd0ZXh0JyxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndmFsdWUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW1hZ2U6ICdpbWFnZSdcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHBhcnRpYWxzOiB7XHJcblx0ICAgICAgICAndWktYXV0b2NvbXBsZXRlLXNpbXBsZSc6ICdcXG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJ1aS1hdXRvY29tcGxldGUtc3VnZ2VzdGlvbi1pdGVtXCIgdi10ZXh0PVwiaXRlbVtrZXlzLnRleHRdIHx8IGl0ZW1cIj48L2xpPlxcbiAgICAgICAgJyxcclxuXHRcclxuXHQgICAgICAgICd1aS1hdXRvY29tcGxldGUtaW1hZ2UnOiAnXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cImltYWdlXCIgOnN0eWxlPVwieyBcXCdiYWNrZ3JvdW5kLWltYWdlXFwnOiBcXCd1cmwoXFwnICsgaXRlbVtrZXlzLmltYWdlXSArIFxcJylcXCcgfVwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0XCIgdi10ZXh0PVwiaXRlbVtrZXlzLnRleHRdXCI+PC9kaXY+XFxuICAgICAgICAnXHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogODggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHQvKipcclxuXHQgKiBGYXN0IFVVSUQgZ2VuZXJhdG9yLCBSRkM0MTIyIHZlcnNpb24gNCBjb21wbGlhbnQuXHJcblx0ICogQGF1dGhvciBKZWZmIFdhcmQgKGpjd2FyZC5jb20pLlxyXG5cdCAqIEBsaWNlbnNlIE1JVCBsaWNlbnNlXHJcblx0ICogQGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XHJcblx0ICoqL1xyXG5cdFxyXG5cdHZhciBsdXQgPSBbXTtcclxuXHRcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcblx0ICAgIGx1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XHJcblx0ICAgIHZhciBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHQgICAgdmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdCAgICB2YXIgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0ICAgIHZhciBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHRcclxuXHQgICAgcmV0dXJuIGx1dFtkMCAmIDB4ZmZdICsgbHV0W2QwID4+IDggJiAweGZmXSArIGx1dFtkMCA+PiAxNiAmIDB4ZmZdICsgbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgKyBsdXRbZDEgJiAweGZmXSArIGx1dFtkMSA+PiA4ICYgMHhmZl0gKyAnLScgKyBsdXRbZDEgPj4gMTYgJiAweDBmIHwgMHg0MF0gKyBsdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArIGx1dFtkMiAmIDB4M2YgfCAweDgwXSArIGx1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBsdXRbZDIgPj4gMTYgJiAweGZmXSArIGx1dFtkMiA+PiAyNCAmIDB4ZmZdICsgbHV0W2QzICYgMHhmZl0gKyBsdXRbZDMgPj4gOCAmIDB4ZmZdICsgbHV0W2QzID4+IDE2ICYgMHhmZl0gKyBsdXRbZDMgPj4gMjQgJiAweGZmXTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBzaG9ydCA9IGZ1bmN0aW9uIHNob3J0KHByZWZpeCkge1xyXG5cdCAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XHJcblx0XHJcblx0ICAgIHZhciB1dWlkID0gZ2VuZXJhdGUoKTtcclxuXHRcclxuXHQgICAgcmV0dXJuIHByZWZpeCArIHV1aWQuc3BsaXQoJy0nKVswXTtcclxuXHR9O1xyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgZ2VuZXJhdGU6IGdlbmVyYXRlLFxyXG5cdCAgICBzaG9ydDogc2hvcnRcclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogODkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGlcXG4gICAgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uXFxcIiA6Y2xhc3M9XFxcIltwYXJ0aWFsLCB7ICdoaWdobGlnaHRlZCc6IGhpZ2hsaWdodGVkIH1dXFxcIlxcbiAgICA6aWQ9XFxcImlkXFxcIlxcbj5cXG4gICAgPHBhcnRpYWwgOm5hbWU9XFxcInBhcnRpYWxcXFwiPjwvcGFydGlhbD5cXG48L2xpPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogOTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICB0aGlzLmVsLmF1dG9mb2N1cyA9IEJvb2xlYW4odmFsdWUpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA5MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nLFxyXG5cdCAgICAgICAgbmFtZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXHJcblx0ICAgICAgICB2YWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJycsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaWNvbjogU3RyaW5nLFxyXG5cdCAgICAgICAgaWNvblJpZ2h0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBoaWRlTGFiZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGVscFRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlYm91bmNlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbml0aWFsVmFsdWU6ICcnXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ZlZWRiYWNrOiBmdW5jdGlvbiBzaG93RmVlZGJhY2soKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNhbkJlVmFsaWRhdGVkID0gQm9vbGVhbih0aGlzLnZhbGlkYXRpb25SdWxlcyk7XHJcblx0ICAgICAgICAgICAgdmFyIGhhc0hlbHBUZXh0ID0gQm9vbGVhbih0aGlzLmhlbHBUZXh0KTtcclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gY2FuQmVWYWxpZGF0ZWQgfHwgaGFzSGVscFRleHQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogOTIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3ZhbGlkYXRvcmpzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Myk7XHJcblx0XHJcblx0dmFyIF92YWxpZGF0b3JqczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZGF0b3Jqcyk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB2YWxpZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXJ0eToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZVZhbGlkYXRpb25FcnJvcnM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdmFsaWRhdGlvblJ1bGVzOiBbU3RyaW5nLCBBcnJheV0sXHJcblx0ICAgICAgICB2YWxpZGF0aW9uTWVzc2FnZXM6IE9iamVjdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3I6ICcnXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1pbnB1dDo6c2V0LXZhbGlkaXR5JzogZnVuY3Rpb24gdWlJbnB1dFNldFZhbGlkaXR5KHZhbGlkLCBlcnJvciwgaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsaWRpdHkodmFsaWQsIGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0aW9uUnVsZXMgfHwgIXRoaXMuZGlydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuXHQgICAgICAgICAgICB9O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBydWxlcyA9IHtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsaWRhdGlvblJ1bGVzXHJcblx0ICAgICAgICAgICAgfTtcclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbiA9IG5ldyBfdmFsaWRhdG9yanMyLmRlZmF1bHQoZGF0YSwgcnVsZXMsIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzKTtcclxuXHRcclxuXHQgICAgICAgICAgICB2YWxpZGF0aW9uLnNldEF0dHJpYnV0ZU5hbWVzKHsgdmFsdWU6IHRoaXMubmFtZS5yZXBsYWNlKC9fL2csICcgJykgfSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWxpZGl0eSh2YWxpZGF0aW9uLnBhc3NlcygpLCB2YWxpZGF0aW9uLmVycm9ycy5maXJzdCgndmFsdWUnKSk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2V0VmFsaWRpdHk6IGZ1bmN0aW9uIHNldFZhbGlkaXR5KHZhbGlkLCBlcnJvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWQgPSB2YWxpZDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXZhbGlkICYmIGVycm9yICYmIGVycm9yLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvciA9IGVycm9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiA5MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIFJ1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XHJcblx0dmFyIExhbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcclxuXHR2YXIgRXJyb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDYpO1xyXG5cdHZhciBBdHRyaWJ1dGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XHJcblx0dmFyIEFzeW5jUmVzb2x2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xyXG5cdFxyXG5cdHZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbihpbnB1dCwgcnVsZXMsIGN1c3RvbU1lc3NhZ2VzKSB7XHJcblx0ICB2YXIgbGFuZyA9IFZhbGlkYXRvci5nZXREZWZhdWx0TGFuZygpO1xyXG5cdCAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG5cdCAgdGhpcy5tZXNzYWdlcyA9IExhbmcuX21ha2UobGFuZyk7XHJcblx0ICB0aGlzLm1lc3NhZ2VzLl9zZXRDdXN0b20oY3VzdG9tTWVzc2FnZXMpO1xyXG5cdCAgdGhpcy5zZXRBdHRyaWJ1dGVGb3JtYXR0ZXIoVmFsaWRhdG9yLnByb3RvdHlwZS5hdHRyaWJ1dGVGb3JtYXR0ZXIpO1xyXG5cdFxyXG5cdCAgdGhpcy5lcnJvcnMgPSBuZXcgRXJyb3JzKCk7XHJcblx0ICB0aGlzLmVycm9yQ291bnQgPSAwO1xyXG5cdFxyXG5cdCAgdGhpcy5oYXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgdGhpcy5ydWxlcyA9IHRoaXMuX3BhcnNlUnVsZXMocnVsZXMpO1xyXG5cdH07XHJcblx0XHJcblx0VmFsaWRhdG9yLnByb3RvdHlwZSA9IHtcclxuXHRcclxuXHQgIGNvbnN0cnVjdG9yOiBWYWxpZGF0b3IsXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERlZmF1bHQgbGFuZ3VhZ2VcclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAgICovXHJcblx0ICBsYW5nOiAnZW4nLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBOdW1lcmljIGJhc2VkIHJ1bGVzXHJcblx0ICAgKlxyXG5cdCAgICogQHR5cGUge2FycmF5fVxyXG5cdCAgICovXHJcblx0ICBudW1lcmljUnVsZXM6IFsnaW50ZWdlcicsICdudW1lcmljJ10sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEF0dHJpYnV0ZSBmb3JtYXR0ZXIuXHJcblx0ICAgKlxyXG5cdCAgICogQHR5cGUge2Z1bmN0aW9ufVxyXG5cdCAgICovXHJcblx0ICBhdHRyaWJ1dGVGb3JtYXR0ZXI6IEF0dHJpYnV0ZXMuZm9ybWF0dGVyLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSdW4gdmFsaWRhdG9yXHJcblx0ICAgKlxyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBpdCBwYXNzZXM7IHRydWUgPSBwYXNzZXMsIGZhbHNlID0gZmFpbHNcclxuXHQgICAqL1xyXG5cdCAgY2hlY2s6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHJcblx0ICAgIGZvciAodmFyIGF0dHJpYnV0ZSBpbiB0aGlzLnJ1bGVzKSB7XHJcblx0ICAgICAgdmFyIGF0dHJpYnV0ZVJ1bGVzID0gdGhpcy5ydWxlc1thdHRyaWJ1dGVdO1xyXG5cdCAgICAgIHZhciBpbnB1dFZhbHVlID0gdGhpcy5pbnB1dFthdHRyaWJ1dGVdOyAvLyBpZiBpdCBkb2VzbnQgZXhpc3QgaW4gaW5wdXQsIGl0IHdpbGwgYmUgdW5kZWZpbmVkXHJcblx0XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF0dHJpYnV0ZVJ1bGVzLmxlbmd0aCwgcnVsZSwgcnVsZU9wdGlvbnMsIHJ1bGVQYXNzZWQ7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgICAgcnVsZU9wdGlvbnMgPSBhdHRyaWJ1dGVSdWxlc1tpXTtcclxuXHQgICAgICAgIHJ1bGUgPSB0aGlzLmdldFJ1bGUocnVsZU9wdGlvbnMubmFtZSk7XHJcblx0XHJcblx0ICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRhdGFibGUocnVsZSwgaW5wdXRWYWx1ZSkpIHtcclxuXHQgICAgICAgICAgY29udGludWU7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICBydWxlUGFzc2VkID0gcnVsZS52YWxpZGF0ZShpbnB1dFZhbHVlLCBydWxlT3B0aW9ucy52YWx1ZSwgYXR0cmlidXRlKTtcclxuXHQgICAgICAgIGlmICghcnVsZVBhc3NlZCkge1xyXG5cdCAgICAgICAgICB0aGlzLl9hZGRGYWlsdXJlKHJ1bGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFN0b3BWYWxpZGF0aW5nKGF0dHJpYnV0ZSwgcnVsZVBhc3NlZCkpIHtcclxuXHQgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0aGlzLmVycm9yQ291bnQgPT09IDA7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSdW4gYXN5bmMgdmFsaWRhdG9yXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtmdW5jdGlvbn0gcGFzc2VzXHJcblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWlsc1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgY2hlY2tBc3luYzogZnVuY3Rpb24ocGFzc2VzLCBmYWlscykge1xyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdCAgICBwYXNzZXMgPSBwYXNzZXMgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHQgICAgZmFpbHMgPSBmYWlscyB8fCBmdW5jdGlvbigpIHt9O1xyXG5cdFxyXG5cdCAgICB2YXIgZmFpbHNPbmUgPSBmdW5jdGlvbihydWxlLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgX3RoaXMuX2FkZEZhaWx1cmUocnVsZSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIHZhciByZXNvbHZlZEFsbCA9IGZ1bmN0aW9uKGFsbFBhc3NlZCkge1xyXG5cdCAgICAgIGlmIChhbGxQYXNzZWQpIHtcclxuXHQgICAgICAgIHBhc3NlcygpO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBmYWlscygpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgdmFyIHZhbGlkYXRlUnVsZSA9IGZ1bmN0aW9uKGlucHV0VmFsdWUsIHJ1bGVPcHRpb25zLCBhdHRyaWJ1dGUsIHJ1bGUpIHtcclxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICB2YXIgcmVzb2x2ZXJJbmRleCA9IGFzeW5jUmVzb2x2ZXJzLmFkZChydWxlKTtcclxuXHQgICAgICAgIHJ1bGUudmFsaWRhdGUoaW5wdXRWYWx1ZSwgcnVsZU9wdGlvbnMudmFsdWUsIGF0dHJpYnV0ZSwgZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgIGFzeW5jUmVzb2x2ZXJzLnJlc29sdmUocmVzb2x2ZXJJbmRleCk7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICB2YXIgYXN5bmNSZXNvbHZlcnMgPSBuZXcgQXN5bmNSZXNvbHZlcnMoZmFpbHNPbmUsIHJlc29sdmVkQWxsKTtcclxuXHRcclxuXHQgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIHRoaXMucnVsZXMpIHtcclxuXHQgICAgICB2YXIgYXR0cmlidXRlUnVsZXMgPSB0aGlzLnJ1bGVzW2F0dHJpYnV0ZV07XHJcblx0ICAgICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLmlucHV0W2F0dHJpYnV0ZV07IC8vIGlmIGl0IGRvZXNudCBleGlzdCBpbiBpbnB1dCwgaXQgd2lsbCBiZSB1bmRlZmluZWRcclxuXHRcclxuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXR0cmlidXRlUnVsZXMubGVuZ3RoLCBydWxlLCBydWxlT3B0aW9uczsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgICBydWxlT3B0aW9ucyA9IGF0dHJpYnV0ZVJ1bGVzW2ldO1xyXG5cdFxyXG5cdCAgICAgICAgcnVsZSA9IHRoaXMuZ2V0UnVsZShydWxlT3B0aW9ucy5uYW1lKTtcclxuXHRcclxuXHQgICAgICAgIGlmICghdGhpcy5faXNWYWxpZGF0YWJsZShydWxlLCBpbnB1dFZhbHVlKSkge1xyXG5cdCAgICAgICAgICBjb250aW51ZTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHZhbGlkYXRlUnVsZShpbnB1dFZhbHVlLCBydWxlT3B0aW9ucywgYXR0cmlidXRlLCBydWxlKSgpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBhc3luY1Jlc29sdmVycy5lbmFibGVGaXJpbmcoKTtcclxuXHQgICAgYXN5bmNSZXNvbHZlcnMuZmlyZSgpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQWRkIGZhaWx1cmUgYW5kIGVycm9yIG1lc3NhZ2UgZm9yIGdpdmVuIHJ1bGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1J1bGV9IHJ1bGVcclxuXHQgICAqL1xyXG5cdCAgX2FkZEZhaWx1cmU6IGZ1bmN0aW9uKHJ1bGUpIHtcclxuXHQgICAgdmFyIG1zZyA9IHRoaXMubWVzc2FnZXMucmVuZGVyKHJ1bGUpO1xyXG5cdCAgICB0aGlzLmVycm9ycy5hZGQocnVsZS5hdHRyaWJ1dGUsIG1zZyk7XHJcblx0ICAgIHRoaXMuZXJyb3JDb3VudCsrO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUGFyc2UgcnVsZXMsIG5vcm1hbGl6aW5nIGZvcm1hdCBpbnRvOiB7IGF0dHJpYnV0ZTogW3sgbmFtZTogJ2FnZScsIHZhbHVlOiAzIH1dIH1cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtvYmplY3R9IHJ1bGVzXHJcblx0ICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcblx0ICAgKi9cclxuXHQgIF9wYXJzZVJ1bGVzOiBmdW5jdGlvbihydWxlcykge1xyXG5cdCAgICB2YXIgcGFyc2VkUnVsZXMgPSB7fTtcclxuXHQgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIHJ1bGVzKSB7XHJcblx0ICAgICAgdmFyIHJ1bGVzQXJyYXkgPSBydWxlc1thdHRyaWJ1dGVdO1xyXG5cdCAgICAgIHZhciBhdHRyaWJ1dGVSdWxlcyA9IFtdO1xyXG5cdFxyXG5cdCAgICAgIGlmICh0eXBlb2YgcnVsZXNBcnJheSA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIHJ1bGVzQXJyYXkgPSBydWxlc0FycmF5LnNwbGl0KCd8Jyk7XHJcblx0ICAgICAgfVxyXG5cdFxyXG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBydWxlc0FycmF5Lmxlbmd0aCwgcnVsZTsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgICBydWxlID0gdGhpcy5fZXh0cmFjdFJ1bGVBbmRSdWxlVmFsdWUocnVsZXNBcnJheVtpXSk7XHJcblx0ICAgICAgICBpZiAoUnVsZXMuaXNBc3luYyhydWxlLm5hbWUpKSB7XHJcblx0ICAgICAgICAgIHRoaXMuaGFzQXN5bmMgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgYXR0cmlidXRlUnVsZXMucHVzaChydWxlKTtcclxuXHQgICAgICB9XHJcblx0XHJcblx0ICAgICAgcGFyc2VkUnVsZXNbYXR0cmlidXRlXSA9IGF0dHJpYnV0ZVJ1bGVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBwYXJzZWRSdWxlcztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEV4dHJhY3QgYSBydWxlIGFuZCBhIHZhbHVlIGZyb20gYSBydWxlU3RyaW5nIChpLmUuIG1pbjozKSwgcnVsZSA9IG1pbiwgdmFsdWUgPSAzXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBydWxlU3RyaW5nIG1pbjozXHJcblx0ICAgKiBAcmV0dXJuIHtvYmplY3R9IG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBydWxlIGFuZCB2YWx1ZVxyXG5cdCAgICovXHJcblx0ICBfZXh0cmFjdFJ1bGVBbmRSdWxlVmFsdWU6IGZ1bmN0aW9uKHJ1bGVTdHJpbmcpIHtcclxuXHQgICAgdmFyIHJ1bGUgPSB7fSxcclxuXHQgICAgICBydWxlQXJyYXk7XHJcblx0XHJcblx0ICAgIHJ1bGUubmFtZSA9IHJ1bGVTdHJpbmc7XHJcblx0XHJcblx0ICAgIGlmIChydWxlU3RyaW5nLmluZGV4T2YoJzonKSA+PSAwKSB7XHJcblx0ICAgICAgcnVsZUFycmF5ID0gcnVsZVN0cmluZy5zcGxpdCgnOicpO1xyXG5cdCAgICAgIHJ1bGUubmFtZSA9IHJ1bGVBcnJheVswXTtcclxuXHQgICAgICBydWxlLnZhbHVlID0gcnVsZUFycmF5LnNsaWNlKDEpLmpvaW4oXCI6XCIpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBydWxlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIGF0dHJpYnV0ZSBoYXMgYW55IG9mIHRoZSBnaXZlbiBydWxlc1xyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gIGF0dHJpYnV0ZVxyXG5cdCAgICogQHBhcmFtICB7YXJyYXl9ICAgZmluZFJ1bGVzXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfaGFzUnVsZTogZnVuY3Rpb24oYXR0cmlidXRlLCBmaW5kUnVsZXMpIHtcclxuXHQgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlc1thdHRyaWJ1dGVdIHx8IFtdO1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcnVsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICBpZiAoZmluZFJ1bGVzLmluZGV4T2YocnVsZXNbaV0ubmFtZSkgPiAtMSkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBmYWxzZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiBhdHRyaWJ1dGUgaGFzIGFueSBudW1lcmljLWJhc2VkIHJ1bGVzLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gIGF0dHJpYnV0ZVxyXG5cdCAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgICAqL1xyXG5cdCAgX2hhc051bWVyaWNSdWxlOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMuX2hhc1J1bGUoYXR0cmlidXRlLCB0aGlzLm51bWVyaWNSdWxlcyk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgcnVsZSBpcyB2YWxpZGF0YWJsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9ICAgcnVsZVxyXG5cdCAgICogQHBhcmFtICB7bWl4ZWR9ICB2YWx1ZVxyXG5cdCAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuXHQgICAqL1xyXG5cdCAgX2lzVmFsaWRhdGFibGU6IGZ1bmN0aW9uKHJ1bGUsIHZhbHVlKSB7XHJcblx0ICAgIGlmIChSdWxlcy5pc0ltcGxpY2l0KHJ1bGUubmFtZSkpIHtcclxuXHQgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdGhpcy5nZXRSdWxlKCdyZXF1aXJlZCcpLnZhbGlkYXRlKHZhbHVlKTtcclxuXHQgIH0sXHJcblx0XHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiB3ZSBzaG91bGQgc3RvcCB2YWxpZGF0aW5nLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0cmlidXRlXHJcblx0ICAgKiBAcGFyYW0gIHtib29sZWFufSBydWxlUGFzc2VkXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfc2hvdWxkU3RvcFZhbGlkYXRpbmc6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgcnVsZVBhc3NlZCkge1xyXG5cdFxyXG5cdCAgICB2YXIgc3RvcE9uQXR0cmlidXRlcyA9IHRoaXMuc3RvcE9uQXR0cmlidXRlcztcclxuXHQgICAgaWYgKHN0b3BPbkF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IHJ1bGVQYXNzZWQgPT09IHRydWUpIHtcclxuXHQgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHN0b3BPbkF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdCAgICAgIHJldHVybiBzdG9wT25BdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlKSA+IC0xO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IGN1c3RvbSBhdHRyaWJ1dGUgbmFtZXMuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXNcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIHNldEF0dHJpYnV0ZU5hbWVzOiBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XHJcblx0ICAgIHRoaXMubWVzc2FnZXMuX3NldEF0dHJpYnV0ZU5hbWVzKGF0dHJpYnV0ZXMpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IHRoZSBhdHRyaWJ1dGUgZm9ybWF0dGVyLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7ZnVjdGlvbn0gZnVuY1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgc2V0QXR0cmlidXRlRm9ybWF0dGVyOiBmdW5jdGlvbihmdW5jKSB7XHJcblx0ICAgIHRoaXMubWVzc2FnZXMuX3NldEF0dHJpYnV0ZUZvcm1hdHRlcihmdW5jKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCB2YWxpZGF0aW9uIHJ1bGVcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcclxuXHQgICAqIEByZXR1cm4ge1J1bGV9XHJcblx0ICAgKi9cclxuXHQgIGdldFJ1bGU6IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHQgICAgcmV0dXJuIFJ1bGVzLm1ha2UobmFtZSwgdGhpcyk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTdG9wIG9uIGZpcnN0IGVycm9yLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge2Jvb2xlYW58YXJyYXl9IEFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgb3IgYm9vbGVhbiB0cnVlL2ZhbHNlIGZvciBhbGwgYXR0cmlidXRlcy5cclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIHN0b3BPbkVycm9yOiBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XHJcblx0ICAgIHRoaXMuc3RvcE9uQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgdmFsaWRhdGlvbiBwYXNzZXNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXNzZXNcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxyXG5cdCAgICovXHJcblx0ICBwYXNzZXM6IGZ1bmN0aW9uKHBhc3Nlcykge1xyXG5cdCAgICB2YXIgYXN5bmMgPSB0aGlzLl9jaGVja0FzeW5jKCdwYXNzZXMnLCBwYXNzZXMpO1xyXG5cdCAgICBpZiAoYXN5bmMpIHtcclxuXHQgICAgICByZXR1cm4gdGhpcy5jaGVja0FzeW5jKHBhc3Nlcyk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIERldGVybWluZSBpZiB2YWxpZGF0aW9uIGZhaWxzXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtmdW5jdGlvbn0gZmFpbHNcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxyXG5cdCAgICovXHJcblx0ICBmYWlsczogZnVuY3Rpb24oZmFpbHMpIHtcclxuXHQgICAgdmFyIGFzeW5jID0gdGhpcy5fY2hlY2tBc3luYygnZmFpbHMnLCBmYWlscyk7XHJcblx0ICAgIGlmIChhc3luYykge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmNoZWNrQXN5bmMoZnVuY3Rpb24oKSB7fSwgZmFpbHMpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiAhdGhpcy5jaGVjaygpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQ2hlY2sgaWYgdmFsaWRhdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5XHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgIGZ1bmNOYW1lIE5hbWUgb2YgdGhlIGNhbGxlclxyXG5cdCAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBfY2hlY2tBc3luYzogZnVuY3Rpb24oZnVuY05hbWUsIGNhbGxiYWNrKSB7XHJcblx0ICAgIHZhciBoYXNDYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJztcclxuXHQgICAgaWYgKHRoaXMuaGFzQXN5bmMgJiYgIWhhc0NhbGxiYWNrKSB7XHJcblx0ICAgICAgdGhyb3cgZnVuY05hbWUgKyAnIGV4cGVjdHMgYSBjYWxsYmFjayB3aGVuIGFzeW5jIHJ1bGVzIGFyZSBiZWluZyB0ZXN0ZWQuJztcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdGhpcy5oYXNBc3luYyB8fCBoYXNDYWxsYmFjaztcclxuXHQgIH1cclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFNldCBtZXNzYWdlcyBmb3IgbGFuZ3VhZ2VcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG1lc3NhZ2VzXHJcblx0ICogQHJldHVybiB7dGhpc31cclxuXHQgKi9cclxuXHRWYWxpZGF0b3Iuc2V0TWVzc2FnZXMgPSBmdW5jdGlvbihsYW5nLCBtZXNzYWdlcykge1xyXG5cdCAgTGFuZy5fc2V0KGxhbmcsIG1lc3NhZ2VzKTtcclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogR2V0IG1lc3NhZ2VzIGZvciBnaXZlbiBsYW5ndWFnZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSBsYW5nXHJcblx0ICogQHJldHVybiB7TWVzc2FnZXN9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24obGFuZykge1xyXG5cdCAgcmV0dXJuIExhbmcuX2dldChsYW5nKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFNldCBkZWZhdWx0IGxhbmd1YWdlIHRvIHVzZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcclxuXHQgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci51c2VMYW5nID0gZnVuY3Rpb24obGFuZykge1xyXG5cdCAgdGhpcy5wcm90b3R5cGUubGFuZyA9IGxhbmc7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBHZXQgZGVmYXVsdCBsYW5ndWFnZVxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci5nZXREZWZhdWx0TGFuZyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgcmV0dXJuIHRoaXMucHJvdG90eXBlLmxhbmc7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIGF0dHJpYnV0ZSBmb3JtYXR0ZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge2Z1Y3Rpb259IGZ1bmNcclxuXHQgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci5zZXRBdHRyaWJ1dGVGb3JtYXR0ZXIgPSBmdW5jdGlvbihmdW5jKSB7XHJcblx0ICB0aGlzLnByb3RvdHlwZS5hdHRyaWJ1dGVGb3JtYXR0ZXIgPSBmdW5jO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU3RvcCBvbiBmaXJzdCBlcnJvci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW58YXJyYXl9IEFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgb3IgYm9vbGVhbiB0cnVlL2ZhbHNlIGZvciBhbGwgYXR0cmlidXRlcy5cclxuXHQgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci5zdG9wT25FcnJvciA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcclxuXHQgIHRoaXMucHJvdG90eXBlLnN0b3BPbkF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXIgY3VzdG9tIHZhbGlkYXRpb24gcnVsZVxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcclxuXHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm5cclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWVzc2FnZVxyXG5cdCAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICovXHJcblx0VmFsaWRhdG9yLnJlZ2lzdGVyID0gZnVuY3Rpb24obmFtZSwgZm4sIG1lc3NhZ2UpIHtcclxuXHQgIHZhciBsYW5nID0gVmFsaWRhdG9yLmdldERlZmF1bHRMYW5nKCk7XHJcblx0ICBSdWxlcy5yZWdpc3RlcihuYW1lLCBmbik7XHJcblx0ICBMYW5nLl9zZXRSdWxlTWVzc2FnZShsYW5nLCBuYW1lLCBtZXNzYWdlKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVyIGFzeW5jaHJvbm91cyB2YWxpZGF0aW9uIHJ1bGVcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lXHJcblx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGZuXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgIG1lc3NhZ2VcclxuXHQgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAqL1xyXG5cdFZhbGlkYXRvci5yZWdpc3RlckFzeW5jID0gZnVuY3Rpb24obmFtZSwgZm4sIG1lc3NhZ2UpIHtcclxuXHQgIHZhciBsYW5nID0gVmFsaWRhdG9yLmdldERlZmF1bHRMYW5nKCk7XHJcblx0ICBSdWxlcy5yZWdpc3RlckFzeW5jKG5hbWUsIGZuKTtcclxuXHQgIExhbmcuX3NldFJ1bGVNZXNzYWdlKGxhbmcsIG5hbWUsIG1lc3NhZ2UpO1xyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0b3I7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogOTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciBydWxlcyA9IHtcclxuXHRcclxuXHQgIHJlcXVpcmVkOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgdmFyIHN0cjtcclxuXHRcclxuXHQgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xyXG5cdCAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBzdHIgPSBTdHJpbmcodmFsKS5yZXBsYWNlKC9cXHMvZywgXCJcIik7XHJcblx0ICAgIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IHRydWUgOiBmYWxzZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICByZXF1aXJlZF9pZjogZnVuY3Rpb24odmFsLCByZXEsIGF0dHJpYnV0ZSkge1xyXG5cdCAgICByZXEgPSB0aGlzLmdldFBhcmFtZXRlcnMoKTtcclxuXHQgICAgaWYgKHRoaXMudmFsaWRhdG9yLmlucHV0W3JlcVswXV0gPT09IHJlcVsxXSkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvci5nZXRSdWxlKCdyZXF1aXJlZCcpLnZhbGlkYXRlKHZhbCk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLy8gY29tcGFyZXMgdGhlIHNpemUgb2Ygc3RyaW5nc1xyXG5cdCAgLy8gd2l0aCBudW1iZXJzLCBjb21wYXJlcyB0aGUgdmFsdWVcclxuXHQgIHNpemU6IGZ1bmN0aW9uKHZhbCwgcmVxLCBhdHRyaWJ1dGUpIHtcclxuXHQgICAgaWYgKHZhbCkge1xyXG5cdCAgICAgIHJlcSA9IHBhcnNlRmxvYXQocmVxKTtcclxuXHRcclxuXHQgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFxyXG5cdCAgICAgIHJldHVybiBzaXplID09PSByZXE7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgc3RyaW5nOiBmdW5jdGlvbih2YWwsIHJlcSwgYXR0cmlidXRlKSB7XHJcblx0ICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIENvbXBhcmVzIHRoZSBzaXplIG9mIHN0cmluZ3Mgb3IgdGhlIHZhbHVlIG9mIG51bWJlcnMgaWYgdGhlcmUgaXMgYSB0cnV0aHkgdmFsdWVcclxuXHQgICAqL1xyXG5cdCAgbWluOiBmdW5jdGlvbih2YWwsIHJlcSwgYXR0cmlidXRlKSB7XHJcblx0ICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0ICAgIHJldHVybiBzaXplID49IHJlcTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIENvbXBhcmVzIHRoZSBzaXplIG9mIHN0cmluZ3Mgb3IgdGhlIHZhbHVlIG9mIG51bWJlcnMgaWYgdGhlcmUgaXMgYSB0cnV0aHkgdmFsdWVcclxuXHQgICAqL1xyXG5cdCAgbWF4OiBmdW5jdGlvbih2YWwsIHJlcSwgYXR0cmlidXRlKSB7XHJcblx0ICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0ICAgIHJldHVybiBzaXplIDw9IHJlcTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBiZXR3ZWVuOiBmdW5jdGlvbih2YWwsIHJlcSwgYXR0cmlidXRlKSB7XHJcblx0ICAgIHJlcSA9IHRoaXMuZ2V0UGFyYW1ldGVycygpO1xyXG5cdCAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdCAgICB2YXIgbWluID0gcGFyc2VGbG9hdChyZXFbMF0sIDEwKTtcclxuXHQgICAgdmFyIG1heCA9IHBhcnNlRmxvYXQocmVxWzFdLCAxMCk7XHJcblx0ICAgIHJldHVybiBzaXplID49IG1pbiAmJiBzaXplIDw9IG1heDtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBlbWFpbDogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHZhciByZSA9IC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvO1xyXG5cdCAgICByZXR1cm4gcmUudGVzdCh2YWwpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIG51bWVyaWM6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICB2YXIgbnVtO1xyXG5cdFxyXG5cdCAgICBudW0gPSBOdW1iZXIodmFsKTsgLy8gdHJpZXMgdG8gY29udmVydCB2YWx1ZSB0byBhIG51bWJlci4gdXNlZnVsIGlmIHZhbHVlIGlzIGNvbWluZyBmcm9tIGZvcm0gZWxlbWVudFxyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSkgJiYgdHlwZW9mIHZhbCAhPT0gJ2Jvb2xlYW4nKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgYXJyYXk6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQXJyYXk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgdXJsOiBmdW5jdGlvbih1cmwpIHtcclxuXHQgICAgcmV0dXJuICgvXmh0dHBzPzpcXC9cXC9cXFMrLykudGVzdCh1cmwpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGFscGhhOiBmdW5jdGlvbih2YWwpIHtcclxuXHQgICAgcmV0dXJuICgvXlthLXpBLVpdKyQvKS50ZXN0KHZhbCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgYWxwaGFfZGFzaDogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIHJldHVybiAoL15bYS16QS1aMC05X1xcLV0rJC8pLnRlc3QodmFsKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBhbHBoYV9udW06IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICByZXR1cm4gKC9eW2EtekEtWjAtOV0rJC8pLnRlc3QodmFsKTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBzYW1lOiBmdW5jdGlvbih2YWwsIHJlcSkge1xyXG5cdCAgICB2YXIgdmFsMSA9IHRoaXMudmFsaWRhdG9yLmlucHV0W3JlcV07XHJcblx0ICAgIHZhciB2YWwyID0gdmFsO1xyXG5cdFxyXG5cdCAgICBpZiAodmFsMSA9PT0gdmFsMikge1xyXG5cdCAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBmYWxzZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBkaWZmZXJlbnQ6IGZ1bmN0aW9uKHZhbCwgcmVxKSB7XHJcblx0ICAgIHZhciB2YWwxID0gdGhpcy52YWxpZGF0b3IuaW5wdXRbcmVxXTtcclxuXHQgICAgdmFyIHZhbDIgPSB2YWw7XHJcblx0XHJcblx0ICAgIGlmICh2YWwxICE9PSB2YWwyKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIFwiaW5cIjogZnVuY3Rpb24odmFsLCByZXEpIHtcclxuXHQgICAgdmFyIGxpc3QsIGk7XHJcblx0XHJcblx0ICAgIGlmICh2YWwpIHtcclxuXHQgICAgICBsaXN0ID0gcmVxLnNwbGl0KCcsJyk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHZhbCAmJiAhKHZhbCBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG5cdCAgICAgIHZhbCA9IFN0cmluZyh2YWwpOyAvLyBpZiBpdCBpcyBhIG51bWJlclxyXG5cdFxyXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICBpZiAodmFsID09PSBsaXN0W2ldKSB7XHJcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHRcclxuXHQgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgaWYgKHZhbCAmJiB2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgIGlmIChsaXN0LmluZGV4T2YodmFsW2ldKSA8IDApIHtcclxuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBub3RfaW46IGZ1bmN0aW9uKHZhbCwgcmVxKSB7XHJcblx0ICAgIHZhciBsaXN0ID0gcmVxLnNwbGl0KCcsJyk7XHJcblx0ICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcclxuXHQgICAgdmFyIHJldHVyblZhbCA9IHRydWU7XHJcblx0XHJcblx0ICAgIHZhbCA9IFN0cmluZyh2YWwpOyAvLyBjb252ZXJ0IHZhbCB0byBhIHN0cmluZyBpZiBpdCBpcyBhIG51bWJlclxyXG5cdFxyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgaWYgKHZhbCA9PT0gbGlzdFtpXSkge1xyXG5cdCAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XHJcblx0ICAgICAgICBicmVhaztcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHJldHVyblZhbDtcclxuXHQgIH0sXHJcblx0XHJcblx0ICBhY2NlcHRlZDogZnVuY3Rpb24odmFsKSB7XHJcblx0ICAgIGlmICh2YWwgPT09ICdvbicgfHwgdmFsID09PSAneWVzJyB8fCB2YWwgPT09IDEgfHwgdmFsID09PSAnMScgfHwgdmFsID09PSB0cnVlKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGNvbmZpcm1lZDogZnVuY3Rpb24odmFsLCByZXEsIGtleSkge1xyXG5cdCAgICB2YXIgY29uZmlybWVkS2V5ID0ga2V5ICsgJ19jb25maXJtYXRpb24nO1xyXG5cdFxyXG5cdCAgICBpZiAodGhpcy52YWxpZGF0b3IuaW5wdXRbY29uZmlybWVkS2V5XSA9PT0gdmFsKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIGludGVnZXI6IGZ1bmN0aW9uKHZhbCkge1xyXG5cdCAgICByZXR1cm4gU3RyaW5nKHBhcnNlSW50KHZhbCwgMTApKSA9PT0gU3RyaW5nKHZhbCk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgZGlnaXRzOiBmdW5jdGlvbih2YWwsIHJlcSkge1xyXG5cdCAgICB2YXIgbnVtZXJpY1J1bGUgPSB0aGlzLnZhbGlkYXRvci5nZXRSdWxlKCdudW1lcmljJyk7XHJcblx0ICAgIGlmIChudW1lcmljUnVsZS52YWxpZGF0ZSh2YWwpICYmIFN0cmluZyh2YWwpLmxlbmd0aCA9PT0gcGFyc2VJbnQocmVxKSkge1xyXG5cdCAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBmYWxzZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICByZWdleDogZnVuY3Rpb24odmFsLCByZXEpIHtcclxuXHQgICAgdmFyIG1vZCA9IC9bZ3xpfG1dezEsM30kLztcclxuXHQgICAgdmFyIGZsYWcgPSByZXEubWF0Y2gobW9kKTtcclxuXHQgICAgZmxhZyA9IGZsYWcgPyBmbGFnWzBdIDogXCJpXCI7XHJcblx0ICAgIHJlcSA9IHJlcS5yZXBsYWNlKG1vZCwgXCJcIikuc2xpY2UoMSwgLTEpO1xyXG5cdCAgICByZXEgPSBuZXcgUmVnRXhwKHJlcSwgZmxhZyk7XHJcblx0ICAgIHJldHVybiAhIXZhbC5tYXRjaChyZXEpO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gUnVsZShuYW1lLCBmbiwgYXN5bmMpIHtcclxuXHQgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICB0aGlzLmZuID0gZm47XHJcblx0ICB0aGlzLnBhc3NlcyA9IG51bGw7XHJcblx0ICB0aGlzLmN1c3RvbU1lc3NhZ2UgPSB1bmRlZmluZWQ7XHJcblx0ICB0aGlzLmFzeW5jID0gYXN5bmM7XHJcblx0fVxyXG5cdFxyXG5cdFJ1bGUucHJvdG90eXBlID0ge1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBWYWxpZGF0ZSBydWxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7bWl4ZWR9IGlucHV0VmFsdWVcclxuXHQgICAqIEBwYXJhbSAge21peGVkfSBydWxlVmFsdWVcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0cmlidXRlXHJcblx0ICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxyXG5cdCAgICovXHJcblx0ICB2YWxpZGF0ZTogZnVuY3Rpb24oaW5wdXRWYWx1ZSwgcnVsZVZhbHVlLCBhdHRyaWJ1dGUsIGNhbGxiYWNrKSB7XHJcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICAgIHRoaXMuX3NldFZhbGlkYXRpbmdEYXRhKGF0dHJpYnV0ZSwgaW5wdXRWYWx1ZSwgcnVsZVZhbHVlKTtcclxuXHQgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHQgICAgICB2YXIgaGFuZGxlUmVzcG9uc2UgPSBmdW5jdGlvbihwYXNzZXMsIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIF90aGlzLnJlc3BvbnNlKHBhc3NlcywgbWVzc2FnZSk7XHJcblx0ICAgICAgfTtcclxuXHRcclxuXHQgICAgICBpZiAodGhpcy5hc3luYykge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZm4uYXBwbHkodGhpcywgW2lucHV0VmFsdWUsIHJ1bGVWYWx1ZSwgYXR0cmlidXRlLCBoYW5kbGVSZXNwb25zZV0pO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2UodGhpcy5mbi5hcHBseSh0aGlzLCBbaW5wdXRWYWx1ZSwgcnVsZVZhbHVlLCBhdHRyaWJ1dGVdKSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiB0aGlzLmZuLmFwcGx5KHRoaXMsIFtpbnB1dFZhbHVlLCBydWxlVmFsdWUsIGF0dHJpYnV0ZV0pO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IHZhbGlkYXRpbmcgZGF0YVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSB7bWl4ZWR9IGlucHV0VmFsdWVcclxuXHQgICAqIEBwYXJhbSB7bWl4ZWR9IHJ1bGVWYWx1ZVxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgX3NldFZhbGlkYXRpbmdEYXRhOiBmdW5jdGlvbihhdHRyaWJ1dGUsIGlucHV0VmFsdWUsIHJ1bGVWYWx1ZSkge1xyXG5cdCAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcclxuXHQgICAgdGhpcy5pbnB1dFZhbHVlID0gaW5wdXRWYWx1ZTtcclxuXHQgICAgdGhpcy5ydWxlVmFsdWUgPSBydWxlVmFsdWU7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgcGFyYW1ldGVyc1xyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge2FycmF5fVxyXG5cdCAgICovXHJcblx0ICBnZXRQYXJhbWV0ZXJzOiBmdW5jdGlvbigpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMucnVsZVZhbHVlID8gdGhpcy5ydWxlVmFsdWUuc3BsaXQoJywnKSA6IFtdO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHRydWUgc2l6ZSBvZiB2YWx1ZVxyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge2ludGVnZXJ8ZmxvYXR9XHJcblx0ICAgKi9cclxuXHQgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0VmFsdWU7XHJcblx0XHJcblx0ICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0ICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAgIHJldHVybiB2YWx1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodGhpcy52YWxpZGF0b3IuX2hhc051bWVyaWNSdWxlKHRoaXMuYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCB0aGUgdHlwZSBvZiB2YWx1ZSBiZWluZyBjaGVja2VkOyBudW1lcmljIG9yIHN0cmluZy5cclxuXHQgICAqXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIF9nZXRWYWx1ZVR5cGU6IGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHRoaXMuaW5wdXRWYWx1ZSA9PT0gJ251bWJlcicgfHwgdGhpcy52YWxpZGF0b3IuX2hhc051bWVyaWNSdWxlKHRoaXMuYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiAnbnVtZXJpYyc7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuICdzdHJpbmcnO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IHRoZSBhc3luYyBjYWxsYmFjayByZXNwb25zZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge2Jvb2xlYW58dW5kZWZpbmVkfSBwYXNzZXMgIFdoZXRoZXIgdmFsaWRhdGlvbiBwYXNzZWRcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ3x1bmRlZmluZWR9IG1lc3NhZ2UgQ3VzdG9tIGVycm9yIG1lc3NhZ2VcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIHJlc3BvbnNlOiBmdW5jdGlvbihwYXNzZXMsIG1lc3NhZ2UpIHtcclxuXHQgICAgdGhpcy5wYXNzZXMgPSAocGFzc2VzID09PSB1bmRlZmluZWQgfHwgcGFzc2VzID09PSB0cnVlKTtcclxuXHQgICAgdGhpcy5jdXN0b21NZXNzYWdlID0gbWVzc2FnZTtcclxuXHQgICAgdGhpcy5jYWxsYmFjayh0aGlzLnBhc3NlcywgbWVzc2FnZSk7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdmFsaWRhdG9yIGluc3RhbmNlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtWYWxpZGF0b3J9IHZhbGlkYXRvclxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgc2V0VmFsaWRhdG9yOiBmdW5jdGlvbih2YWxpZGF0b3IpIHtcclxuXHQgICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XHJcblx0ICB9XHJcblx0XHJcblx0fTtcclxuXHRcclxuXHR2YXIgbWFuYWdlciA9IHtcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogTGlzdCBvZiBhc3luYyBydWxlIG5hbWVzXHJcblx0ICAgKlxyXG5cdCAgICogQHR5cGUge0FycmF5fVxyXG5cdCAgICovXHJcblx0ICBhc3luY1J1bGVzOiBbXSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogSW1wbGljaXQgcnVsZXMgKHJ1bGVzIHRvIGFsd2F5cyB2YWxpZGF0ZSlcclxuXHQgICAqXHJcblx0ICAgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICAgKi9cclxuXHQgIGltcGxpY2l0UnVsZXM6IFsncmVxdWlyZWQnLCAncmVxdWlyZWRfaWYnLCAnYWNjZXB0ZWQnXSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHJ1bGUgYnkgbmFtZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxyXG5cdCAgICogQHBhcmFtIHtWYWxpZGF0b3J9XHJcblx0ICAgKiBAcmV0dXJuIHtSdWxlfVxyXG5cdCAgICovXHJcblx0ICBtYWtlOiBmdW5jdGlvbihuYW1lLCB2YWxpZGF0b3IpIHtcclxuXHQgICAgdmFyIGFzeW5jID0gdGhpcy5pc0FzeW5jKG5hbWUpO1xyXG5cdCAgICB2YXIgcnVsZSA9IG5ldyBSdWxlKG5hbWUsIHJ1bGVzW25hbWVdLCBhc3luYyk7XHJcblx0ICAgIHJ1bGUuc2V0VmFsaWRhdG9yKHZhbGlkYXRvcik7XHJcblx0ICAgIHJldHVybiBydWxlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIGdpdmVuIHJ1bGUgaXMgYXN5bmNcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBpc0FzeW5jOiBmdW5jdGlvbihuYW1lKSB7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFzeW5jUnVsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICBpZiAodGhpcy5hc3luY1J1bGVzW2ldID09PSBuYW1lKSB7XHJcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIHJ1bGUgaXMgaW1wbGljaXQgKHNob3VsZCBhbHdheXMgdmFsaWRhdGUpXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIGlzSW1wbGljaXQ6IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMuaW1wbGljaXRSdWxlcy5pbmRleE9mKG5hbWUpID4gLTE7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBSZWdpc3RlciBuZXcgcnVsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lXHJcblx0ICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm5cclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIHJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xyXG5cdCAgICBydWxlc1tuYW1lXSA9IGZuO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVnaXN0ZXIgYXN5bmMgcnVsZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lXHJcblx0ICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm5cclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIHJlZ2lzdGVyQXN5bmM6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XHJcblx0ICAgIHRoaXMucmVnaXN0ZXIobmFtZSwgZm4pO1xyXG5cdCAgICB0aGlzLmFzeW5jUnVsZXMucHVzaChuYW1lKTtcclxuXHQgIH1cclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gbWFuYWdlcjtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA5NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIE1lc3NhZ2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XHJcblx0XHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XHJcblx0XHJcblx0dmFyIGNvbnRhaW5lciA9IHtcclxuXHRcclxuXHQgIG1lc3NhZ2VzOiB7fSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogU2V0IG1lc3NhZ2VzIGZvciBsYW5ndWFnZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nXHJcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gcmF3TWVzc2FnZXNcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIF9zZXQ6IGZ1bmN0aW9uKGxhbmcsIHJhd01lc3NhZ2VzKSB7XHJcblx0ICAgIHRoaXMubWVzc2FnZXNbbGFuZ10gPSByYXdNZXNzYWdlcztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFNldCBtZXNzYWdlIGZvciBnaXZlbiBsYW5ndWFnZSdzIHJ1bGUuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcclxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbWVzc2FnZVxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgX3NldFJ1bGVNZXNzYWdlOiBmdW5jdGlvbihsYW5nLCBhdHRyaWJ1dGUsIG1lc3NhZ2UpIHtcclxuXHQgICAgdGhpcy5fbG9hZChsYW5nKTtcclxuXHQgICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2xhbmddLmRlZjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB0aGlzLm1lc3NhZ2VzW2xhbmddW2F0dHJpYnV0ZV0gPSBtZXNzYWdlO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogTG9hZCBtZXNzYWdlcyAoaWYgbm90IGFscmVhZHkgbG9hZGVkKVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gbGFuZ1xyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgX2xvYWQ6IGZ1bmN0aW9uKGxhbmcpIHtcclxuXHQgICAgaWYgKCF0aGlzLm1lc3NhZ2VzW2xhbmddKSB7XHJcblx0ICAgICAgdmFyIHJhd01lc3NhZ2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSkoXCIuL1wiICsgbGFuZyk7XHJcblx0ICAgICAgdGhpcy5fc2V0KGxhbmcsIHJhd01lc3NhZ2VzKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogR2V0IHJhdyBtZXNzYWdlcyBmb3IgbGFuZ3VhZ2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxhbmdcclxuXHQgICAqIEByZXR1cm4ge29iamVjdH1cclxuXHQgICAqL1xyXG5cdCAgX2dldDogZnVuY3Rpb24obGFuZykge1xyXG5cdCAgICB0aGlzLl9sb2FkKGxhbmcpO1xyXG5cdCAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1tsYW5nXTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIE1ha2UgbWVzc2FnZXMgZm9yIGdpdmVuIGxhbmd1YWdlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBsYW5nXHJcblx0ICAgKiBAcmV0dXJuIHtNZXNzYWdlc31cclxuXHQgICAqL1xyXG5cdCAgX21ha2U6IGZ1bmN0aW9uKGxhbmcpIHtcclxuXHQgICAgdGhpcy5fbG9hZChsYW5nKTtcclxuXHQgICAgcmV0dXJuIG5ldyBNZXNzYWdlcyhsYW5nLCB0aGlzLm1lc3NhZ2VzW2xhbmddKTtcclxuXHQgIH1cclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gY29udGFpbmVyO1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDk2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgQXR0cmlidXRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpO1xyXG5cdFxyXG5cdHZhciBNZXNzYWdlcyA9IGZ1bmN0aW9uKGxhbmcsIG1lc3NhZ2VzKSB7XHJcblx0ICB0aGlzLmxhbmcgPSBsYW5nO1xyXG5cdCAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xyXG5cdCAgdGhpcy5jdXN0b21NZXNzYWdlcyA9IHt9O1xyXG5cdCAgdGhpcy5hdHRyaWJ1dGVOYW1lcyA9IHt9O1xyXG5cdH07XHJcblx0XHJcblx0TWVzc2FnZXMucHJvdG90eXBlID0ge1xyXG5cdCAgY29uc3RydWN0b3I6IE1lc3NhZ2VzLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgY3VzdG9tIG1lc3NhZ2VzXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtvYmplY3R9IGN1c3RvbU1lc3NhZ2VzXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfc2V0Q3VzdG9tOiBmdW5jdGlvbihjdXN0b21NZXNzYWdlcykge1xyXG5cdCAgICB0aGlzLmN1c3RvbU1lc3NhZ2VzID0gY3VzdG9tTWVzc2FnZXMgfHwge307XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgY3VzdG9tIGF0dHJpYnV0ZSBuYW1lcy5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xyXG5cdCAgICovXHJcblx0ICBfc2V0QXR0cmlidXRlTmFtZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgdGhpcy5hdHRyaWJ1dGVOYW1lcyA9IGF0dHJpYnV0ZXM7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBTZXQgdGhlIGF0dHJpYnV0ZSBmb3JtYXR0ZXIuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtmdWN0aW9ufSBmdW5jXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBfc2V0QXR0cmlidXRlRm9ybWF0dGVyOiBmdW5jdGlvbihmdW5jKSB7XHJcblx0ICAgIHRoaXMuYXR0cmlidXRlRm9ybWF0dGVyID0gZnVuYztcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCBhdHRyaWJ1dGUgbmFtZSB0byBkaXNwbGF5LlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0cmlidXRlXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIF9nZXRBdHRyaWJ1dGVOYW1lOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcclxuXHQgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGU7XHJcblx0ICAgIGlmICh0aGlzLmF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcclxuXHQgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVOYW1lc1thdHRyaWJ1dGVdO1xyXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubWVzc2FnZXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgbmFtZSA9IHRoaXMubWVzc2FnZXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGlmICh0aGlzLmF0dHJpYnV0ZUZvcm1hdHRlcikge1xyXG5cdCAgICAgIG5hbWUgPSB0aGlzLmF0dHJpYnV0ZUZvcm1hdHRlcihuYW1lKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gbmFtZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCBhbGwgbWVzc2FnZXNcclxuXHQgICAqXHJcblx0ICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcblx0ICAgKi9cclxuXHQgIGFsbDogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmVuZGVyIG1lc3NhZ2VcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtSdWxlfSBydWxlXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIHJlbmRlcjogZnVuY3Rpb24ocnVsZSkge1xyXG5cdCAgICBpZiAocnVsZS5jdXN0b21NZXNzYWdlKSB7XHJcblx0ICAgICAgcmV0dXJuIHJ1bGUuY3VzdG9tTWVzc2FnZTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLl9nZXRUZW1wbGF0ZShydWxlKTtcclxuXHRcclxuXHQgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgIGlmIChBdHRyaWJ1dGVzLnJlcGxhY2VtZW50c1tydWxlLm5hbWVdKSB7XHJcblx0ICAgICAgbWVzc2FnZSA9IEF0dHJpYnV0ZXMucmVwbGFjZW1lbnRzW3J1bGUubmFtZV0uYXBwbHkodGhpcywgW3RlbXBsYXRlLCBydWxlXSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgbWVzc2FnZSA9IHRoaXMuX3JlcGxhY2VQbGFjZWhvbGRlcnMocnVsZSwgdGVtcGxhdGUsIHt9KTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gbWVzc2FnZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIEdldCB0aGUgdGVtcGxhdGUgdG8gdXNlIGZvciBnaXZlbiBydWxlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7UnVsZX0gcnVsZVxyXG5cdCAgICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAgICovXHJcblx0ICBfZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uKHJ1bGUpIHtcclxuXHRcclxuXHQgICAgdmFyIG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcclxuXHQgICAgdmFyIHRlbXBsYXRlID0gbWVzc2FnZXMuZGVmO1xyXG5cdCAgICB2YXIgY3VzdG9tTWVzc2FnZXMgPSB0aGlzLmN1c3RvbU1lc3NhZ2VzO1xyXG5cdCAgICB2YXIgZm9ybWF0cyA9IFtydWxlLm5hbWUgKyAnLicgKyBydWxlLmF0dHJpYnV0ZSwgcnVsZS5uYW1lXTtcclxuXHRcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGZvcm1hdDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICBmb3JtYXQgPSBmb3JtYXRzW2ldO1xyXG5cdCAgICAgIGlmIChjdXN0b21NZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpKSB7XHJcblx0ICAgICAgICB0ZW1wbGF0ZSA9IGN1c3RvbU1lc3NhZ2VzW2Zvcm1hdF07XHJcblx0ICAgICAgICBicmVhaztcclxuXHQgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2VzLmhhc093blByb3BlcnR5KGZvcm1hdCkpIHtcclxuXHQgICAgICAgIHRlbXBsYXRlID0gbWVzc2FnZXNbZm9ybWF0XTtcclxuXHQgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVbcnVsZS5fZ2V0VmFsdWVUeXBlKCldO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJlcGxhY2UgcGxhY2Vob2xkZXJzIGluIHRoZSB0ZW1wbGF0ZSB1c2luZyB0aGUgZGF0YSBvYmplY3RcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtSdWxlfSBydWxlXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRlbXBsYXRlXHJcblx0ICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGFcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgX3JlcGxhY2VQbGFjZWhvbGRlcnM6IGZ1bmN0aW9uKHJ1bGUsIHRlbXBsYXRlLCBkYXRhKSB7XHJcblx0ICAgIHZhciBtZXNzYWdlLCBhdHRyaWJ1dGU7XHJcblx0XHJcblx0ICAgIGRhdGEuYXR0cmlidXRlID0gdGhpcy5fZ2V0QXR0cmlidXRlTmFtZShydWxlLmF0dHJpYnV0ZSk7XHJcblx0ICAgIGRhdGFbcnVsZS5uYW1lXSA9IHJ1bGUuZ2V0UGFyYW1ldGVycygpLmpvaW4oJywnKTtcclxuXHRcclxuXHQgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgbWVzc2FnZSA9IHRlbXBsYXRlO1xyXG5cdFxyXG5cdCAgICAgIGZvciAoYXR0cmlidXRlIGluIGRhdGEpIHtcclxuXHQgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UobmV3IFJlZ0V4cCgnOicgKyBhdHRyaWJ1dGUsICdnJyksIGRhdGFbYXR0cmlidXRlXSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBtZXNzYWdlO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlcztcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiA5NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIHJlcGxhY2VtZW50cyA9IHtcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQmV0d2VlbiByZXBsYWNlbWVudCAocmVwbGFjZXMgOm1pbiBhbmQgOm1heClcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRlbXBsYXRlXHJcblx0ICAgKiBAcGFyYW0gIHtSdWxlfSBydWxlXHJcblx0ICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICAgKi9cclxuXHQgIGJldHdlZW46IGZ1bmN0aW9uKHRlbXBsYXRlLCBydWxlKSB7XHJcblx0ICAgIHZhciBwYXJhbWV0ZXJzID0gcnVsZS5nZXRQYXJhbWV0ZXJzKCk7XHJcblx0ICAgIHJldHVybiB0aGlzLl9yZXBsYWNlUGxhY2Vob2xkZXJzKHJ1bGUsIHRlbXBsYXRlLCB7XHJcblx0ICAgICAgbWluOiBwYXJhbWV0ZXJzWzBdLFxyXG5cdCAgICAgIG1heDogcGFyYW1ldGVyc1sxXVxyXG5cdCAgICB9KTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJlcXVpcmVkX2lmIHJlcGxhY2VtZW50LlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gdGVtcGxhdGVcclxuXHQgICAqIEBwYXJhbSAge1J1bGV9IHJ1bGVcclxuXHQgICAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgICAqL1xyXG5cdCAgcmVxdWlyZWRfaWY6IGZ1bmN0aW9uKHRlbXBsYXRlLCBydWxlKSB7XHJcblx0ICAgIHZhciBwYXJhbWV0ZXJzID0gcnVsZS5nZXRQYXJhbWV0ZXJzKCk7XHJcblx0ICAgIHJldHVybiB0aGlzLl9yZXBsYWNlUGxhY2Vob2xkZXJzKHJ1bGUsIHRlbXBsYXRlLCB7XHJcblx0ICAgICAgb3RoZXI6IHBhcmFtZXRlcnNbMF0sXHJcblx0ICAgICAgdmFsdWU6IHBhcmFtZXRlcnNbMV1cclxuXHQgICAgfSk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBmb3JtYXR0ZXIoYXR0cmlidXRlKSB7XHJcblx0ICByZXR1cm4gYXR0cmlidXRlLnJlcGxhY2UoL1tfXFxbXS9nLCAnICcpLnJlcGxhY2UoL10vZywgJycpO1xyXG5cdH1cclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIHJlcGxhY2VtZW50czogcmVwbGFjZW1lbnRzLFxyXG5cdCAgZm9ybWF0dGVyOiBmb3JtYXR0ZXJcclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDk4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGFjY2VwdGVkOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSBhY2NlcHRlZC4nLFxyXG5cdCAgYWxwaGE6ICdUaGUgOmF0dHJpYnV0ZSBmaWVsZCBtdXN0IGNvbnRhaW4gb25seSBhbHBoYWJldGljIGNoYXJhY3RlcnMuJyxcclxuXHQgIGFscGhhX2Rhc2g6ICdUaGUgOmF0dHJpYnV0ZSBmaWVsZCBtYXkgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBkYXNoZXMgYW5kIHVuZGVyc2NvcmVzLicsXHJcblx0ICBhbHBoYV9udW06ICdUaGUgOmF0dHJpYnV0ZSBmaWVsZCBtdXN0IGJlIGFscGhhbnVtZXJpYy4nLFxyXG5cdCAgYmV0d2VlbjogJ1RoZSA6YXR0cmlidXRlIGZpZWxkIG11c3QgYmUgYmV0d2VlbiA6bWluIGFuZCA6bWF4LicsXHJcblx0ICBjb25maXJtZWQ6ICdUaGUgOmF0dHJpYnV0ZSBjb25maXJtYXRpb24gZG9lcyBub3QgbWF0Y2guJyxcclxuXHQgIGVtYWlsOiAnVGhlIDphdHRyaWJ1dGUgZm9ybWF0IGlzIGludmFsaWQuJyxcclxuXHQgIGRlZjogJ1RoZSA6YXR0cmlidXRlIGF0dHJpYnV0ZSBoYXMgZXJyb3JzLicsXHJcblx0ICBkaWdpdHM6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIDpkaWdpdHMgZGlnaXRzLicsXHJcblx0ICBkaWZmZXJlbnQ6ICdUaGUgOmF0dHJpYnV0ZSBhbmQgOmRpZmZlcmVudCBtdXN0IGJlIGRpZmZlcmVudC4nLFxyXG5cdCAgJ2luJzogJ1RoZSBzZWxlY3RlZCA6YXR0cmlidXRlIGlzIGludmFsaWQuJyxcclxuXHQgIGludGVnZXI6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGFuIGludGVnZXIuJyxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSBhdCBsZWFzdCA6bWluLicsXHJcblx0ICAgIHN0cmluZzogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgYXQgbGVhc3QgOm1pbiBjaGFyYWN0ZXJzLidcclxuXHQgIH0sXHJcblx0ICBtYXg6IHtcclxuXHQgICAgbnVtZXJpYzogJ1RoZSA6YXR0cmlidXRlIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDptYXguJyxcclxuXHQgICAgc3RyaW5nOiAnVGhlIDphdHRyaWJ1dGUgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gOm1heCBjaGFyYWN0ZXJzLidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICdUaGUgc2VsZWN0ZWQgOmF0dHJpYnV0ZSBpcyBpbnZhbGlkLicsXHJcblx0ICBudW1lcmljOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSBhIG51bWJlci4nLFxyXG5cdCAgcmVxdWlyZWQ6ICdUaGUgOmF0dHJpYnV0ZSBmaWVsZCBpcyByZXF1aXJlZC4nLFxyXG5cdCAgcmVxdWlyZWRfaWY6ICdUaGUgOmF0dHJpYnV0ZSBmaWVsZCBpcyByZXF1aXJlZCB3aGVuIDpvdGhlciBpcyA6dmFsdWUuJyxcclxuXHQgIHNhbWU6ICdUaGUgOmF0dHJpYnV0ZSBhbmQgOnNhbWUgZmllbGRzIG11c3QgbWF0Y2guJyxcclxuXHQgIHNpemU6IHtcclxuXHQgICAgbnVtZXJpYzogJ1RoZSA6YXR0cmlidXRlIG11c3QgYmUgOnNpemUuJyxcclxuXHQgICAgc3RyaW5nOiAnVGhlIDphdHRyaWJ1dGUgbXVzdCBiZSA6c2l6ZSBjaGFyYWN0ZXJzLidcclxuXHQgIH0sXHJcblx0ICBzdHJpbmc6ICdUaGUgOmF0dHJpYnV0ZSBtdXN0IGJlIGEgc3RyaW5nLicsXHJcblx0ICB1cmw6ICdUaGUgOmF0dHJpYnV0ZSBmb3JtYXQgaXMgaW52YWxpZC4nLFxyXG5cdCAgcmVnZXg6ICdUaGUgOmF0dHJpYnV0ZSBmb3JtYXQgaXMgaW52YWxpZCcsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fVxyXG5cdH07XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogOTkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBtYXAgPSB7XHJcblx0XHRcIi4vZW5cIjogOTgsXHJcblx0XHRcIi4vZW4uanNcIjogOTgsXHJcblx0XHRcIi4vZXNcIjogMTAwLFxyXG5cdFx0XCIuL2VzLmpzXCI6IDEwMCxcclxuXHRcdFwiLi9mclwiOiAxMDEsXHJcblx0XHRcIi4vZnIuanNcIjogMTAxLFxyXG5cdFx0XCIuL2l0XCI6IDEwMixcclxuXHRcdFwiLi9pdC5qc1wiOiAxMDIsXHJcblx0XHRcIi4vamFcIjogMTAzLFxyXG5cdFx0XCIuL2phLmpzXCI6IDEwMyxcclxuXHRcdFwiLi9wbFwiOiAxMDQsXHJcblx0XHRcIi4vcGwuanNcIjogMTA0LFxyXG5cdFx0XCIuL3J1XCI6IDEwNSxcclxuXHRcdFwiLi9ydS5qc1wiOiAxMDVcclxuXHR9O1xyXG5cdGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xyXG5cdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xyXG5cdH07XHJcblx0ZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xyXG5cdFx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIikgfSgpKTtcclxuXHR9O1xyXG5cdHdlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XHJcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcclxuXHR9O1xyXG5cdHdlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcclxuXHR3ZWJwYWNrQ29udGV4dC5pZCA9IDk5O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBhY2NlcHRlZDogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBzZXIgYWNlcHRhZG8uJyxcclxuXHQgIGFscGhhOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBzb2xvIGRlYmUgY29udGVuZXIgbGV0cmFzLicsXHJcblx0ICBhbHBoYV9kYXNoOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBzb2xvIGRlYmUgY29udGVuZXIgbGV0cmFzLCBuw7ptZXJvcyB5IGd1aW9uZXMuJyxcclxuXHQgIGFscGhhX251bTogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgc29sbyBkZWJlIGNvbnRlbmVyIGxldHJhcyB5IG7Dum1lcm9zLicsXHJcblx0ICBhdHRyaWJ1dGVzOiB7fSxcclxuXHQgIGJldHdlZW46ICdFbCBjYW1wbyA6YXR0cmlidXRlIHRpZW5lIHF1ZSBlc3RhciBlbnRyZSA6bWluIC0gOm1heC4nLFxyXG5cdCAgY29uZmlybWVkOiAnTGEgY29uZmlybWFjacOzbiBkZSA6YXR0cmlidXRlIG5vIGNvaW5jaWRlLicsXHJcblx0ICBkaWZmZXJlbnQ6ICdFbCBjYW1wbyA6YXR0cmlidXRlIHkgOm90aGVyIGRlYmVuIHNlciBkaWZlcmVudGVzLicsXHJcblx0ICBkaWdpdHM6ICdFbCBjYW1wbyA6YXR0cmlidXRlIGRlYmUgdGVuZXIgOmRpZ2l0cyBkw61naXRvcy4nLFxyXG5cdCAgZW1haWw6ICdFbCBjYW1wbyA6YXR0cmlidXRlIG5vIGVzIHVuIGNvcnJlbyB2w6FsaWRvJyxcclxuXHQgICdpbic6ICdFbCBjYW1wbyA6YXR0cmlidXRlIGVzIGludsOhbGlkby4nLFxyXG5cdCAgaW50ZWdlcjogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBzZXIgdW4gbsO6bWVybyBlbnRlcm8uJyxcclxuXHQgIG1heDoge1xyXG5cdCAgICBudW1lcmljOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBubyBkZWJlIHNlciBtYXlvciBhIDptYXguJyxcclxuXHQgICAgc3RyaW5nOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBubyBkZWJlIHNlciBtYXlvciBxdWUgOm1heCBjYXJhY3RlcmVzLidcclxuXHQgIH0sXHJcblx0ICBtaW46IHtcclxuXHQgICAgbnVtZXJpYzogJ0VsIHRhbWHDsW8gZGVsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBzZXIgZGUgYWwgbWVub3MgOm1pbi4nLFxyXG5cdCAgICBzdHJpbmc6ICdFbCBjYW1wbyA6YXR0cmlidXRlIGRlYmUgY29udGVuZXIgYWwgbWVub3MgOm1pbiBjYXJhY3RlcmVzLidcclxuXHQgIH0sXHJcblx0ICBub3RfaW46ICdFbCBjYW1wbyA6YXR0cmlidXRlIGVzIGludsOhbGlkby4nLFxyXG5cdCAgbnVtZXJpYzogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBzZXIgbnVtw6lyaWNvLicsXHJcblx0ICByZWdleDogJ0VsIGZvcm1hdG8gZGVsIGNhbXBvIDphdHRyaWJ1dGUgZXMgaW52w6FsaWRvLicsXHJcblx0ICByZXF1aXJlZDogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZXMgb2JsaWdhdG9yaW8uJyxcclxuXHQgIHJlcXVpcmVkX2lmOiAnRWwgY2FtcG8gOmF0dHJpYnV0ZSBlcyBvYmxpZ2F0b3JpbyBjdWFuZG8gOm90aGVyIGVzIDp2YWx1ZS4nLFxyXG5cdCAgc2FtZTogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgeSA6b3RoZXIgZGViZW4gY29pbmNpZGlyLicsXHJcblx0ICBzaXplOiB7XHJcblx0ICAgIG51bWVyaWM6ICdFbCB0YW1hw7FvIGRlbCBjYW1wbyA6YXR0cmlidXRlIGRlYmUgc2VyIDpzaXplLicsXHJcblx0ICAgIHN0cmluZzogJ0VsIGNhbXBvIDphdHRyaWJ1dGUgZGViZSBjb250ZW5lciA6c2l6ZSBjYXJhY3RlcmVzLidcclxuXHQgIH0sXHJcblx0ICB1cmw6ICdFbCBmb3JtYXRvIGRlIDphdHRyaWJ1dGUgZXMgaW52w6FsaWRvLidcclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBhY2NlcHRlZDogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgYWNjZXB0w6kuJyxcclxuXHQgIGFscGhhOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgbmUgcGV1dCBjb250ZW5pciBxdWUgZGVzIGNhcmFjdMOocmVzIGFscGhhYsOpdGlxdWVzLicsXHJcblx0ICBhbHBoYV9kYXNoOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgbmUgcGV1dCBjb250ZW5pciBxdWUgZGVzIGNhcmFjdMOocmVzIGFscGhhbnVtw6lyaXF1ZXMsIGRlcyB0aXJldHMgZXQgdW5kZXJzY29yZXMuJyxcclxuXHQgIGFscGhhX251bTogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgYWxwaGFudW3DqXJpcXVlLicsXHJcblx0ICBiZXR3ZWVuOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBjb21wcmlzIGVudHJlIDptaW4gYW5kIDptYXguJyxcclxuXHQgIGNvbmZpcm1lZDogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIG5lIGNvcnJlc3BvbmQgcGFzLicsXHJcblx0ICBlbWFpbDogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGNvbnRpZW50IHVuIGZvcm1hdCBpbnZhbGlkZS4nLFxyXG5cdCAgZGVmOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgY29udGllbnQgdW4gYXR0cmlidXQgZXJyb27DqS4nLFxyXG5cdCAgZGlnaXRzOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSBkZSA6ZGlnaXRzIGNoaWZmcmVzLicsXHJcblx0ICBkaWZmZXJlbnQ6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBldCA6ZGlmZmVyZW50IGRvaXZlbnQgw6p0cmUgZGlmZmVyZW50cy4nLFxyXG5cdCAgJ2luJzogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGVzdCBpbnZhbGlkZS4nLFxyXG5cdCAgaW50ZWdlcjogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgdW4gZW50aWVyLicsXHJcblx0ICBtaW46IHtcclxuXHQgICAgbnVtZXJpYzogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgY29udGVuaXIgYXUgbW9pbnMgOm1pbi4nLFxyXG5cdCAgICBzdHJpbmc6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBkb2l0IMOqdHJlIGNvbnRlbmlyIGF1IG1vaW5zIDptaW4gY2FyYWN0w6hyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIG1heDoge1xyXG5cdCAgICBudW1lcmljOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgbmUgZG9pdCDDqnRyZSBzdXDDqXJpZXVyIMOgIDptYXguJyxcclxuXHQgICAgc3RyaW5nOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgbmUgZG9pdCDDqnRyZSBwbHVzIGRlIDptYXggY2hhcmFjdGVycy4nXHJcblx0ICB9LFxyXG5cdCAgbm90X2luOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZXN0IGludmFsaWRlLicsXHJcblx0ICBudW1lcmljOiAnTGUgY2hhbXBzIDphdHRyaWJ1dGUgZG9pdCDDqnRyZSB1biBudW3DqXJvLicsXHJcblx0ICByZXF1aXJlZDogJ0xlIGNoYW1wcyA6YXR0cmlidXRlIGVzdCBvYmxpZ2F0b2lyZS4nLFxyXG5cdCAgcmVxdWlyZWRfaWY6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBlc3Qgb2JsaWdhdG9pcmUgcXVhbmQgOm90aGVyIGVzdCA6dmFsdWUuJyxcclxuXHQgIHNhbWU6ICdMZSBjaGFtcHMgOmF0dHJpYnV0ZSBldCA6c2FtZSBkb2l2ZW50IGNvcnJlc3BvbmRyZS4nLFxyXG5cdCAgc2l6ZToge1xyXG5cdCAgICBudW1lcmljOiAnTGEgdGFpbGxlIGR1IGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgOnNpemUuJyxcclxuXHQgICAgc3RyaW5nOiAnTGEgdGFpbGxlIGR1IGNoYW1wcyA6YXR0cmlidXRlIGRvaXQgw6p0cmUgZGUgOnNpemUgY2FyYWN0w6hyZXMuJ1xyXG5cdCAgfSxcclxuXHQgIHVybDogJ0xlIGZvcm1hdCBkdSBjaGFtcHMgOmF0dHJpYnV0ZSBlc3QgaW52YWxpZGUuJyxcclxuXHQgIHJlZ2V4OiAnTGUgZm9ybWF0IGR1IGNoYW1wcyA6YXR0cmlidXRlIGVzdCBpbnZhbGlkZS4nLFxyXG5cdCAgYXR0cmlidXRlczoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICBhY2NlcHRlZDogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgYWNjZXR0YXRvLicsXHJcblx0ICBhbHBoYTogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBjb250ZW5lcmUgc29ubyBjYXJhdHRlcmkgYWxmYWJldGljaS4nLFxyXG5cdCAgYWxwaGFfZGFzaDogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgcHXDsiBjb250ZW5lcmUgc29sbyBjYXJhdHRlcmkgYWxmYW51bWVyaWNpIG9sdHJlIGEgdHJhdHRpbmkgZSB0cmF0dGluaSBiYXNzaS4nLFxyXG5cdCAgYWxwaGFfbnVtOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSBhbGZhbnVtZXJpY28uJyxcclxuXHQgIGJldHdlZW46ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIGNvbXByZXNvIHRyYSA6bWluIGUgOm1heC4nLFxyXG5cdCAgY29uZmlybWVkOiAnSWwgY2FtcG8gY29uZmVybWEgOmF0dHJpYnV0ZSBub24gw6ggdWd1YWxlLicsXHJcblx0ICBlbWFpbDogJ0lsIGZvcm1hdG8gZGVsbFxcJ2F0dHJpYnV0byA6YXR0cmlidXRlIG5vbiDDqCB2YWxpZG8uJyxcclxuXHQgIGRlZjogJ0dsaSBhdHRyaWJ1dGkgZGVsIGNhbXBvIDphdHRyaWJ1dGUgY29udGVuZ29ubyBkZWdsaSBlcnJvcmkuJyxcclxuXHQgIGRpZ2l0czogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgZGkgOmRpZ2l0cyBjaWZyZS4nLFxyXG5cdCAgZGlmZmVyZW50OiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBlIDpkaWZmZXJlbnQgZGV2byBlc3NlcmUgZGl2ZXJzaS4nLFxyXG5cdCAgJ2luJzogJ0lsIHZhbG9yZSBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBub24gw6ggdmFsaWRvLicsXHJcblx0ICBpbnRlZ2VyOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSB1biB2YWxvcmUgaW50ZXJvLicsXHJcblx0ICBtaW46IHtcclxuXHQgICAgbnVtZXJpYzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgbyB1Z3VhbGUgZGkgOm1pbi4nLFxyXG5cdCAgICBzdHJpbmc6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIGNvbXBvc3RvIGRhIGFsbWVubyA6bWluIGNhcmF0dGVyaS4nXHJcblx0ICB9LFxyXG5cdCAgbWF4OiB7XHJcblx0ICAgIG51bWVyaWM6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIG1pbm9yZSBvIHVndWFsZSBkaSA6bWF4LicsXHJcblx0ICAgIHN0cmluZzogJ0lsIGNhbXBvIDphdHRyaWJ1dGUgZGV2ZSBlc3NlcmUgY29tcG9zdG8gZGEgbWFzc2ltbyA6bWF4IGNhcmF0dGVyaS4nXHJcblx0ICB9LFxyXG5cdCAgbm90X2luOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBub24gw6ggdmFsaWRvLicsXHJcblx0ICBudW1lcmljOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSB1biBudW1lcm8uJyxcclxuXHQgIHJlcXVpcmVkOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSDDqCByaWNoaWVzdG8uJyxcclxuXHQgIHJlcXVpcmVkX2lmOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSDDqCByaWNoaWVzdG8gcXVhbmRvIGlsIGNhbXBvIDpvdGhlciDDqCB1Z3VhbGUgYSA6dmFsdWUuJyxcclxuXHQgIHNhbWU6ICdJIGNhbXBpIDphdHRyaWJ1dGUgZSA6c2FtZSBkZXZvbm8gZXNzZXJlIHVndWFsaS4nLFxyXG5cdCAgc2l6ZToge1xyXG5cdCAgICBudW1lcmljOiAnTGEgZGltZW5zaW9uZSBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSB1Z3VhbGUgYSA6c2l6ZS4nLFxyXG5cdCAgICBzdHJpbmc6ICdJbCBjYW1wbyA6YXR0cmlidXRlIGRldmUgZXNzZXJlIGRpIDpzaXplIGNhcmF0dGVyaS4nXHJcblx0ICB9LFxyXG5cdCAgc3RyaW5nOiAnSWwgY2FtcG8gOmF0dHJpYnV0ZSBkZXZlIGVzc2VyZSB1bmEgc3RyaW5nYS4nLFxyXG5cdCAgdXJsOiAnSWwgZm9ybWF0byBkZWwgY2FtcG8gOmF0dHJpYnV0ZSBub24gw6ggdmFsaWRvLicsXHJcblx0ICByZWdleDogJ0lsIGZvcm1hdG8gZGVsIGNhbXBvIDphdHRyaWJ1dGUgbm9uIMOoIHZhbGlkby4nLFxyXG5cdCAgYXR0cmlidXRlczoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGFjY2VwdGVkOiAnOmF0dHJpYnV0ZeOCkueiuuiqjeOBl+OBpuOBj+OBoOOBleOBhOOAgicsXHJcblx0ICAgIGFscGhhOiAnOmF0dHJpYnV0ZeOBr+iLseWtl+OBruOBv+OBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAgicsXHJcblx0ICAgIGFscGhhX2Rhc2g6ICc6YXR0cmlidXRl44Gv6Iux5a2X44Go44OA44OD44K344Ol44Go5LiL57ea44Gu44G/44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgYWxwaGFfbnVtOiAnOmF0dHJpYnV0ZeOBr+iLseaVsOWtl+OBruOBv+OBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAgicsXHJcblx0ICAgIGJldHdlZW46ICc6YXR0cmlidXRl44GvOm1pbuOAnDptYXjmloflrZfjgaflhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIInLFxyXG5cdCAgICBjb25maXJtZWQ6ICc6YXR0cmlidXRl44Gv56K66KqN44GM5LiA6Ie044GX44G+44Gb44KT44CCJyxcclxuXHQgICAgZW1haWw6ICc6YXR0cmlidXRl44Gv5q2j44GX44GE44Oh44O844Or44Ki44OJ44Os44K544KS5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgZGVmOiAnOmF0dHJpYnV0ZeOBr+aknOiovOOCqOODqeODvOOBjOWQq+OBvuOCjOOBpuOBhOOBvuOBmeOAgicsXHJcblx0ICAgIGRpZ2l0czogJzphdHRyaWJ1dGXjga86ZGlnaXRz44Gu5pWw5a2X44Gu44G/44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgZGlmZmVyZW50OiAnOmF0dHJpYnV0ZeOBqDpkaWZmZXJlbnTjga/lkIzjgZjjgafjgYLjgaPjgabjga/jgarjgorjgb7jgZvjgpPjgIInLFxyXG5cdCAgICAnaW4nOiAn6YG45oqe44GV44KM44GfOmF0dHJpYnV0ZeOBr+eEoeWKueOBp+OBmeOAgicsXHJcblx0ICAgIGludGVnZXI6ICc6YXR0cmlidXRl44Gv5pW05pWw44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcclxuXHQgICAgbWluICAgICAgICA6IHtcclxuXHQgICAgICAgIG51bWVyaWMgOiBcIjphdHRyaWJ1dGXjga86bWlu5Lul5LiK44KS5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCIsXHJcblx0ICAgICAgICBzdHJpbmcgIDogXCI6YXR0cmlidXRl44GvOm1pbuaWh+Wtl+S7peS4iuOBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiXHJcblx0ICAgIH0sXHJcblx0ICAgIG1heCA6IHtcclxuXHQgICAgICAgIG51bWVyaWMgOiBcIjphdHRyaWJ1dGXjga86bWF45Lul5LiL44KS5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCIsXHJcblx0ICAgICAgICBzdHJpbmcgIDogXCI6YXR0cmlidXRl44GvOm1heOaWh+Wtl+S7peS4iuOBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiXHJcblx0ICAgIH0sXHJcblx0ICAgIG5vdF9pbiAgICAgIDogXCLpgbjmip7jgZXjgozjgZ86YXR0cmlidXRl44Gv54Sh5Yq544Gn44GZ44CCXCIsXHJcblx0ICAgIG51bWVyaWMgICAgIDogXCI6YXR0cmlidXRl44Gv5pWw5YCk44Gn5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCXCIsXHJcblx0ICAgIHJlcXVpcmVkICAgIDogXCI6YXR0cmlidXRl44Gv5b+F6aCI44Gn44GZ44CCXCIsXHJcblx0ICAgIHJlcXVpcmVkX2lmIDogXCI6b3RoZXLjga86dmFsdWXjgavjgarjgaPjgZ/jgok6YXR0cmlidXRl44Gv5b+F6aCI44Gn44GZ44CCXCIsXHJcblx0ICAgIHNhbWUgICAgICAgIDogXCI6YXR0cmlidXRl44GoOnNhbWXjga/lkIzjgZjjgafjgarjgZHjgozjgbDjgarjgorjgb7jgZvjgpPjgIJcIixcclxuXHQgICAgc2l6ZSAgICAgICAgOiB7XHJcblx0ICAgICAgICBudW1lcmljIDogXCI6YXR0cmlidXRl44GvOnNpemXjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgICAgIHN0cmluZyAgOiBcIjphdHRyaWJ1dGXjga86c2l6ZeaWh+Wtl+OBp+WFpeWKm+OBl+OBpuOBj+OBoOOBleOBhOOAglwiXHJcblx0ICAgIH0sXHJcblx0ICAgIHVybCAgICAgICAgOiBcIjphdHRyaWJ1dGXjga9VUknjgpLlhaXlipvjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcclxuXHQgICAgcmVnZXggICAgICA6IFwiOmF0dHJpYnV0ZeOBruWApCBcXFwiOnZhbHVlXFxcIiDjga/jg5Hjgr/jg7zjg7Pjgavjg57jg4Pjg4HjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcIixcclxuXHQgICAgYXR0cmlidXRlcyA6IHt9XHJcblx0fTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMDQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBhY2NlcHRlZDogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIGJ5xIcgemFha2NlcHRvd2FuZS4nLFxyXG5cdCAgICBhbHBoYTogJ1BvbGUgOmF0dHJpYnV0ZSBtb8W8ZSB6YXdpZXJhxIcgdHlsa28gbGl0ZXJ5LicsXHJcblx0ICAgIGFscGhhX2Rhc2g6ICdQb2xlIDphdHRyaWJ1dGUgbW96ZSB6YXdpZXJhxIcgdHlsa28gbGl0ZXJ5LCBtecWbbG5payBpIHBvZHJrZcWbbGVuaWUuJyxcclxuXHQgICAgYWxwaGFfbnVtOiAnUG9sZSA6YXR0cmlidXRlIG1vemUgemF3aWVyYWMgdHlsa28gem5ha2kgYWxmYW51bWVyeWN6bmUuJyxcclxuXHQgICAgYmV0d2VlbjogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIG1pZcSHIGTFgnVnb8WbxIcgb2QgOm1pbiBkbyA6bWF4LicsXHJcblx0ICAgIGNvbmZpcm1lZDogJ1BvbGUgOmF0dHJpYnV0ZSBuaWUgc3BlxYJuaWEgd2FydW5rdSBwb3R3aWVyZHplbmlhLicsXHJcblx0ICAgIGVtYWlsOiAnUG9sZSA6YXR0cmlidXRlIG1hIG5pZXBvcHJhd255IGZvcm1hdCBhZHJlc3UgZW1haWwuJyxcclxuXHQgICAgZGVmOiAnUG9sZSA6YXR0cmlidXRlIHphd2llcmEgYsWCxJlkeS4nLFxyXG5cdCAgICBkaWdpdHM6ICdQb2xlIDphdHRyaWJ1dGUgbW/FvGUgemF3aWVyYcSHIHR5bGtvIGN5ZnJ5IHplIHpiaW9ydSA6ZGlnaXRzLicsXHJcblx0ICAgIGRpZmZlcmVudDogJ1BvbGEgOmF0dHJpYnV0ZSBpIDpkaWZmZXJlbnQgbXVzesSFIHNpxJkgcsOzxbxuacSHLicsXHJcblx0ICAgICdpbic6ICdQb2xlIDphdHRyaWJ1dGUgbXVzaSBuYWxlxbxlxIcgZG8gemJpb3J1IDppbi4nLFxyXG5cdCAgICBpbnRlZ2VyOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyBsaWN6YsSFIGNhxYJrb3dpdMSFLicsXHJcblx0ICAgIG1pbjoge1xyXG5cdCAgICAgICAgbnVtZXJpYzogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIGJ5xIcgcsOzd25lIGNvbmFqbW5pZWogOm1pbi4nLFxyXG5cdCAgICAgICAgc3RyaW5nOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgemF3aWVyYcSHIGNvbmFqbW5pZWogOm1pbiB6bmFrw7N3LidcclxuXHQgICAgfSxcclxuXHQgICAgbWF4OiB7XHJcblx0ICAgICAgICBudW1lcmljOiAnUG9sZSA6YXR0cmlidXRlIG5pZSBtb3plIGJ5xIcgd2nEmWtzemUgOm1heC4nLFxyXG5cdCAgICAgICAgc3RyaW5nOiAnUG9sZSA6YXR0cmlidXRlIG5pZSBtb3plIGJ5xIcgZMWCdcW8c3plIG5pxbwgOm1heCB6bmFrw7N3LidcclxuXHQgICAgfSxcclxuXHQgICAgbm90X2luOiAnUG9sZSA6YXR0cmlidXRlIG5pZSBtb8W8ZSBuYWxlxbxlxIcgZG8gemJpb3J1IDpub3RfaW4uJyxcclxuXHQgICAgbnVtZXJpYzogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIGJ5xIcgbGljemLEhS4nLFxyXG5cdCAgICByZXF1aXJlZDogJ1BvbGUgOmF0dHJpYnV0ZSBqZXN0IHd5bWFnYW5lLicsXHJcblx0ICAgIHJlcXVpcmVkX2lmOiAnUG9sZSA6YXR0cmlidXRlIGplc3Qgd3ltYWdhbmUgamXFm2xpIHBvbGUgOm90aGVyIGplc3QgcsOzd25lIDp2YWx1ZS4nLFxyXG5cdCAgICBzYW1lOiAnUG9sYSA6YXR0cmlidXRlIGkgOnNhbWUgbXVzesSFIGJ5xIcgdGFraWUgc2FtZS4nLFxyXG5cdCAgICBzaXplOiB7XHJcblx0ICAgICAgICBudW1lcmljOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyByw7N3bmUgOnNpemUuJyxcclxuXHQgICAgICAgIHN0cmluZzogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIHphd2llcmHEhyA6c2l6ZSB6bmFrw7N3LidcclxuXHQgICAgfSxcclxuXHQgICAgc3RyaW5nOiAnUG9sZSA6YXR0cmlidXRlIG11c2kgYnnEhyBjacSFZ2llbSB6bmFrw7N3LicsXHJcblx0ICAgIHVybDogJ1BvbGUgOmF0dHJpYnV0ZSBtdXNpIGJ5xIcgcG9wcmF3bnltIGFkcmVzZW0gVVJMLicsXHJcblx0ICAgIHJlZ2V4OiAnUG9sZSA6YXR0cmlidXRlIG5pZSBzcGXFgm5pYSB3YXJ1bmt1LicsXHJcblx0ICAgIGF0dHJpYnV0ZXM6IHt9XHJcblx0fTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMDUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgYWNjZXB0ZWQ6ICfQktGLINC00L7Qu9C20L3RiyDQv9GA0LjQvdGP0YLRjCA6YXR0cmlidXRlLicsXHJcblx0ICBhbHBoYTogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LzQvtC20LXRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCx0YPQutCy0YsuJyxcclxuXHQgIGFscGhhX2Rhc2g6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC80L7QttC10YIg0YHQvtC00LXRgNC20LDRgtGMINGC0L7Qu9GM0LrQviDQsdGD0LrQstGLLCDRhtC40YTRgNGLLCDQtNC10YTQuNGB0Ysg0Lgg0YHQuNC80LLQvtC70Ysg0L/QvtC00YfRkdGA0LrQuNCy0LDQvdC40Y8uJyxcclxuXHQgIGFscGhhX251bTogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LzQvtC20LXRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCx0YPQutCy0Ysg0Lgg0YbQuNGE0YDRiy4nLFxyXG5cdCAgYmV0d2VlbjogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINC80LXQttC00YMgOm1pbiDQuCA6bWF4LicsXHJcblx0ICBjb25maXJtZWQ6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC90LUg0YHQvtCy0L/QsNC00LDQtdGCINGBINC/0L7QtNGC0LLQtdGA0LbQtNC10L3QuNC10LwuJyxcclxuXHQgIGVtYWlsOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LTQtdC50YHRgtCy0LjRgtC10LvRjNC90YvQvCDRjdC70LXQutGC0YDQvtC90L3Ri9C8INCw0LTRgNC10YHQvtC8LicsXHJcblx0ICBkZWY6ICfQn9C+0LvQtSA6YXR0cmlidXRlINGB0L7QtNC10YDQttC40YIg0L7RiNC40LHQutC4LicsXHJcblx0ICBkaWdpdHM6ICfQlNC70LjQvdCwINGG0LjRhNGA0L7QstC+0LPQviDQv9C+0LvRjyA6YXR0cmlidXRlINC00L7Qu9C20L3QsCDQsdGL0YLRjCA6ZGlnaXRzLicsXHJcblx0ICBkaWZmZXJlbnQ6ICfQn9C+0LvRjyA6YXR0cmlidXRlINC4IDpkaWZmZXJlbnQg0LTQvtC70LbQvdGLINGA0LDQt9C70LjRh9Cw0YLRjNGB0Y8uJyxcclxuXHQgICdpbic6ICfQktGL0LHRgNCw0L3QvdC+0LUg0LfQvdCw0YfQtdC90LjQtSDQtNC70Y8gOmF0dHJpYnV0ZSDQvtGI0LjQsdC+0YfQvdC+LicsXHJcblx0ICBpbnRlZ2VyOiAn0J/QvtC70LUgOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YbQtdC70YvQvCDRh9C40YHQu9C+0LwuJyxcclxuXHQgIG1pbjoge1xyXG5cdCAgICBudW1lcmljOiAn0JfQvdCw0YfQtdC90LjQtSDQv9C+0LvRjyA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDQsdC+0LvRjNGI0LUg0LjQu9C4INGA0LDQstC90L4gOm1pbi4nLFxyXG5cdCAgICBzdHJpbmc6ICfQmtC+0LvQuNGH0LXRgdGC0LLQviDRgdC40LzQstC+0LvQvtCyINCyINC/0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINC90LUg0LzQtdC90LXQtSA6bWluLidcclxuXHQgIH0sXHJcblx0ICBtYXg6IHtcclxuXHQgICAgbnVtZXJpYzogJ9CX0L3QsNGH0LXQvdC40LUg0L/QvtC70Y8gOmF0dHJpYnV0ZSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LzQtdC90YzRiNC1INC40LvQuCDRgNCw0LLQvdC+IDptYXguJyxcclxuXHQgICAgc3RyaW5nOiAn0JrQvtC70LjRh9C10YHRgtCy0L4g0YHQuNC80LLQvtC70L7QsiDQsiDQv9C+0LvQtSA6YXR0cmlidXRlINC90LUg0LzQvtC20LXRgiDQv9GA0LXQstGL0YjQsNGC0YwgOm1heC4nXHJcblx0ICB9LFxyXG5cdCAgbm90X2luOiAn0JLRi9Cx0YDQsNC90L3QvtC1INC30L3QsNGH0LXQvdC40LUg0LTQu9GPIDphdHRyaWJ1dGUg0L7RiNC40LHQvtGH0L3Qvi4nLFxyXG5cdCAgbnVtZXJpYzogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INCx0YvRgtGMINGH0LjRgdC70L7QvC4nLFxyXG5cdCAgcmVxdWlyZWQ6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC+0LHRj9C30LDRgtC10LvRjNC90L4g0LTQu9GPINC30LDQv9C+0LvQvdC10L3QuNGPLicsXHJcblx0ICByZXF1aXJlZF9pZjogJ9Cf0L7Qu9C1IDphdHRyaWJ1dGUg0YLRgNC10LHRg9C10YLRgdGPINC60L7Qs9C00LAg0LfQvdCw0YfQtdC90LjRjyDQv9C+0LvRjyA6b3RoZXIg0YDQsNCy0L3QviA6dmFsdWUuJyxcclxuXHQgIHNhbWU6ICfQl9C90LDRh9C10L3QuNC1IDphdHRyaWJ1dGUg0LTQvtC70LbQvdC+INGB0L7QstC/0LDQtNCw0YLRjCDRgSA6c2FtZS4nLFxyXG5cdCAgc2l6ZToge1xyXG5cdCAgICBudW1lcmljOiAn0JfQvdCw0YfQtdC90LjQtSDQv9C+0LvRjyA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDRgNCw0LLQvdGL0LwgOnNpemUuJyxcclxuXHQgICAgc3RyaW5nOiAn0JrQvtC70LjRh9C10YHRgtCy0L4g0YHQuNC80LLQvtC70L7QsiDQsiDQv9C+0LvQtSA6YXR0cmlidXRlINC00L7Qu9C20L3QviDQsdGL0YLRjCDRgNCw0LLQvdC+IDpzaXplLidcclxuXHQgIH0sXHJcblx0ICB1cmw6ICfQn9C+0LvQtSA6YXR0cmlidXRlINC00L7Qu9C20L3QviDRgdC+0LTQtdGA0LbQsNGC0Ywg0LLQsNC70LjQtNC90YvQuSBVUkwuJyxcclxuXHQgIHJlZ2V4OiAn0J3QtdCy0LXRgNC90YvQuSDRhNC+0YDQvNCw0YIg0L/QvtC70Y8gOmF0dHJpYnV0ZS4nLFxyXG5cdCAgYXR0cmlidXRlczoge31cclxuXHR9O1xyXG5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIEVycm9ycyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5lcnJvcnMgPSB7fTtcclxuXHR9O1xyXG5cdFxyXG5cdEVycm9ycy5wcm90b3R5cGUgPSB7XHJcblx0ICBjb25zdHJ1Y3RvcjogRXJyb3JzLFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBBZGQgbmV3IGVycm9yIG1lc3NhZ2UgZm9yIGdpdmVuIGF0dHJpYnV0ZVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0cmlidXRlXHJcblx0ICAgKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2VcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIGFkZDogZnVuY3Rpb24oYXR0cmlidXRlLCBtZXNzYWdlKSB7XHJcblx0ICAgIGlmICghdGhpcy5oYXMoYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHRoaXMuZXJyb3JzW2F0dHJpYnV0ZV0gPSBbXTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodGhpcy5lcnJvcnNbYXR0cmlidXRlXS5pbmRleE9mKG1lc3NhZ2UpID09PSAtMSkge1xyXG5cdCAgICAgIHRoaXMuZXJyb3JzW2F0dHJpYnV0ZV0ucHVzaChtZXNzYWdlKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogUmV0dXJucyBhbiBhcnJheSBvZiBlcnJvciBtZXNzYWdlcyBmb3IgYW4gYXR0cmlidXRlLCBvciBhbiBlbXB0eSBhcnJheVxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0cmlidXRlIEEga2V5IGluIHRoZSBkYXRhIG9iamVjdCBiZWluZyB2YWxpZGF0ZWRcclxuXHQgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBlcnJvciBtZXNzYWdlc1xyXG5cdCAgICovXHJcblx0ICBnZXQ6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xyXG5cdCAgICBpZiAodGhpcy5oYXMoYXR0cmlidXRlKSkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLmVycm9yc1thdHRyaWJ1dGVdO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHJldHVybiBbXTtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJldHVybnMgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgZm9yIGFuIGF0dHJpYnV0ZSwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGUgQSBrZXkgaW4gdGhlIGRhdGEgb2JqZWN0IGJlaW5nIHZhbGlkYXRlZFxyXG5cdCAgICogQHJldHVybiB7c3RyaW5nfGZhbHNlfSBGaXJzdCBlcnJvciBtZXNzYWdlIG9yIGZhbHNlXHJcblx0ICAgKi9cclxuXHQgIGZpcnN0OiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcclxuXHQgICAgaWYgKHRoaXMuaGFzKGF0dHJpYnV0ZSkpIHtcclxuXHQgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbYXR0cmlidXRlXVswXTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBHZXQgYWxsIGVycm9yIG1lc3NhZ2VzIGZyb20gYWxsIGZhaWxpbmcgYXR0cmlidXRlc1xyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge09iamVjdH0gRmFpbGVkIGF0dHJpYnV0ZSBuYW1lcyBmb3Iga2V5cyBhbmQgYW4gYXJyYXkgb2YgbWVzc2FnZXMgZm9yIHZhbHVlc1xyXG5cdCAgICovXHJcblx0ICBhbGw6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5lcnJvcnM7XHJcblx0ICB9LFxyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBEZXRlcm1pbmUgaWYgdGhlcmUgYXJlIGFueSBlcnJvciBtZXNzYWdlcyBmb3IgYW4gYXR0cmlidXRlXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlIEEga2V5IGluIHRoZSBkYXRhIG9iamVjdCBiZWluZyB2YWxpZGF0ZWRcclxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICAgKi9cclxuXHQgIGhhczogZnVuY3Rpb24oYXR0cmlidXRlKSB7XHJcblx0ICAgIGlmICh0aGlzLmVycm9ycy5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XHJcblx0ICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH1cclxuXHRcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBFcnJvcnM7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTA3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRmdW5jdGlvbiBBc3luY1Jlc29sdmVycyhvbkZhaWxlZE9uZSwgb25SZXNvbHZlZEFsbCkge1xyXG5cdCAgdGhpcy5vblJlc29sdmVkQWxsID0gb25SZXNvbHZlZEFsbDtcclxuXHQgIHRoaXMub25GYWlsZWRPbmUgPSBvbkZhaWxlZE9uZTtcclxuXHQgIHRoaXMucmVzb2x2ZXJzID0ge307XHJcblx0ICB0aGlzLnJlc29sdmVyc0NvdW50ID0gMDtcclxuXHQgIHRoaXMucGFzc2VkID0gW107XHJcblx0ICB0aGlzLmZhaWxlZCA9IFtdO1xyXG5cdCAgdGhpcy5maXJpbmcgPSBmYWxzZTtcclxuXHR9XHJcblx0XHJcblx0QXN5bmNSZXNvbHZlcnMucHJvdG90eXBlID0ge1xyXG5cdFxyXG5cdCAgLyoqXHJcblx0ICAgKiBBZGQgcmVzb2x2ZXJcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1J1bGV9IHJ1bGVcclxuXHQgICAqIEByZXR1cm4ge2ludGVnZXJ9XHJcblx0ICAgKi9cclxuXHQgIGFkZDogZnVuY3Rpb24ocnVsZSkge1xyXG5cdCAgICB2YXIgaW5kZXggPSB0aGlzLnJlc29sdmVyc0NvdW50O1xyXG5cdCAgICB0aGlzLnJlc29sdmVyc1tpbmRleF0gPSBydWxlO1xyXG5cdCAgICB0aGlzLnJlc29sdmVyc0NvdW50Kys7XHJcblx0ICAgIHJldHVybiBpbmRleDtcclxuXHQgIH0sXHJcblx0XHJcblx0ICAvKipcclxuXHQgICAqIFJlc29sdmUgZ2l2ZW4gaW5kZXhcclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBpbmRleFxyXG5cdCAgICogQHJldHVybiB7dm9pZH1cclxuXHQgICAqL1xyXG5cdCAgcmVzb2x2ZTogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHQgICAgdmFyIHJ1bGUgPSB0aGlzLnJlc29sdmVyc1tpbmRleF07XHJcblx0ICAgIGlmIChydWxlLnBhc3NlcyA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgIHRoaXMucGFzc2VkLnB1c2gocnVsZSk7XHJcblx0ICAgIH0gZWxzZSBpZiAocnVsZS5wYXNzZXMgPT09IGZhbHNlKSB7XHJcblx0ICAgICAgdGhpcy5mYWlsZWQucHVzaChydWxlKTtcclxuXHQgICAgICB0aGlzLm9uRmFpbGVkT25lKHJ1bGUpO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIHRoaXMuZmlyZSgpO1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRGV0ZXJtaW5lIGlmIGFsbCBoYXZlIGJlZW4gcmVzb2x2ZWRcclxuXHQgICAqXHJcblx0ICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAgICovXHJcblx0ICBpc0FsbFJlc29sdmVkOiBmdW5jdGlvbigpIHtcclxuXHQgICAgcmV0dXJuICh0aGlzLnBhc3NlZC5sZW5ndGggKyB0aGlzLmZhaWxlZC5sZW5ndGgpID09PSB0aGlzLnJlc29sdmVyc0NvdW50O1xyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogQXR0ZW1wdCB0byBmaXJlIGZpbmFsIGFsbCByZXNvbHZlZCBjYWxsYmFjayBpZiBjb21wbGV0ZWRcclxuXHQgICAqXHJcblx0ICAgKiBAcmV0dXJuIHt2b2lkfVxyXG5cdCAgICovXHJcblx0ICBmaXJlOiBmdW5jdGlvbigpIHtcclxuXHRcclxuXHQgICAgaWYgKCF0aGlzLmZpcmluZykge1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAodGhpcy5pc0FsbFJlc29sdmVkKCkpIHtcclxuXHQgICAgICB0aGlzLm9uUmVzb2x2ZWRBbGwodGhpcy5mYWlsZWQubGVuZ3RoID09PSAwKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgfSxcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogRW5hYmxlIGZpcmluZ1xyXG5cdCAgICpcclxuXHQgICAqIEByZXR1cm4ge3ZvaWR9XHJcblx0ICAgKi9cclxuXHQgIGVuYWJsZUZpcmluZzogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHRoaXMuZmlyaW5nID0gdHJ1ZTtcclxuXHQgIH1cclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gQXN5bmNSZXNvbHZlcnM7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTA4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlXFxcIiB2LWVsOmF1dG9jb21wbGV0ZVxcbiAgICA6Y2xhc3M9XFxcIntcXG4gICAgICAgICdkaXNhYmxlZCc6IGRpc2FibGVkLCAnaW52YWxpZCc6ICF2YWxpZCwgJ2RpcnR5JzogZGlydHksICdhY3RpdmUnOiBhY3RpdmUsXFxuICAgICAgICAnaGFzLWxhYmVsJzogIWhpZGVMYWJlbCwgJ2ljb24tcmlnaHQnOiBpY29uUmlnaHRcXG4gICAgfVxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1pY29uLXdyYXBwZXJcXFwiIHYtaWY9XFxcInNob3dJY29uXFxcIj5cXG4gICAgICAgIDx1aS1pY29uIDppY29uPVxcXCJpY29uXFxcIiBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWljb25cXFwiPjwvdWktaWNvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1jb250ZW50XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWxhYmVsXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtbGFiZWwtdGV4dFxcXCIgdi10ZXh0PVxcXCJsYWJlbFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPHVpLWljb25cXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1jbGVhci1idXR0b25cXFwiIGljb249XFxcIiYjeEU1Q0RcXFwiIHRpdGxlPVxcXCJDbGVhclxcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJjbGVhclNlYXJjaFxcXCIgdi1zaG93PVxcXCIhZGlzYWJsZWQgJiYgdmFsdWUubGVuZ3RoXFxcIlxcbiAgICAgICAgICAgID48L3VpLWljb24+XFxuXFxuICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcXFwiIDpwbGFjZWhvbGRlcj1cXFwicGxhY2Vob2xkZXJcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICA6aWQ9XFxcImlkXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgdi1hdXRvZm9jdXM9XFxcImF1dG9mb2N1c1xcXCIgOmRlYm91bmNlPVxcXCJkZWJvdW5jZVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgQGZvY3VzPVxcXCJmb2N1c1xcXCIgQGJsdXI9XFxcImJsdXJcXFwiIEBrZXlkb3duLnVwLnByZXZlbnQ9XFxcImhpZ2hsaWdodChoaWdobGlnaHRlZEl0ZW0gLSAxKVxcXCJcXG4gICAgICAgICAgICAgICAgQGtleWRvd24uZG93bi5wcmV2ZW50PVxcXCJoaWdobGlnaHQoaGlnaGxpZ2h0ZWRJdGVtICsgMSlcXFwiIEBrZXlkb3duLnRhYj1cXFwiY2xvc2VcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVudGVyPVxcXCJzZWxlY3RIaWdobGlnaHRlZChoaWdobGlnaHRlZEl0ZW0sICRldmVudClcXFwiXFxuXFxuICAgICAgICAgICAgICAgIHYtbW9kZWw9XFxcInZhbHVlXFxcIiB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdi1lbDppbnB1dFxcbiAgICAgICAgICAgID5cXG5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uc1xcXCIgdi1zaG93PVxcXCJzaG93RHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgICAgICA8dWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb25cXG4gICAgICAgICAgICAgICAgICAgIDpoaWdobGlnaHRlZD1cXFwiaGlnaGxpZ2h0ZWRJdGVtID09PSBpbmRleFxcXCIgOml0ZW09XFxcIml0ZW1cXFwiIDpwYXJ0aWFsPVxcXCJwYXJ0aWFsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgOmtleXM9XFxcImtleXNcXFwiXFxuXFxuICAgICAgICAgICAgICAgICAgICB2LWZvcj1cXFwiKGluZGV4LCBpdGVtKSBpbiBzdWdnZXN0aW9ucyB8IGZpbHRlckJ5IHNlYXJjaCB8IGxpbWl0QnkgbGltaXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICB2LXJlZjppdGVtcyBAY2xpY2s9XFxcInNlbGVjdChpdGVtKVxcXCJcXG4gICAgICAgICAgICAgICAgPjwvdWktYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvbGFiZWw+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtZmVlZGJhY2tcXFwiIHYtaWY9XFxcInNob3dGZWVkYmFja1xcXCI+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWVycm9yLXRleHRcXFwiIHYtdGV4dD1cXFwidmFsaWRhdGlvbkVycm9yXFxcIlxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPVxcXCJ1aS1hdXRvY29tcGxldGUtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICAgICAgICAgICAgICB2LXNob3c9XFxcIiFoaWRlVmFsaWRhdGlvbkVycm9ycyAmJiAhdmFsaWRcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1oZWxwLXRleHRcXFwiIHRyYW5zaXRpb249XFxcInVpLWF1dG9jb21wbGV0ZS1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiaGVscFRleHRcXFwiIHYtZWxzZVxcbiAgICAgICAgICAgID48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMTApXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUJ1dHRvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaUJ1dHRvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTEwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTExICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaU1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHRcclxuXHR2YXIgX1VpTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaU1lbnUpO1xyXG5cdFxyXG5cdHZhciBfVWlQb3BvdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcblx0XHJcblx0dmFyIF9VaVBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQb3BvdmVyKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NDaXJjdWxhciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NDaXJjdWxhcik7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfSGFzRHJvcGRvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcclxuXHRcclxuXHR2YXIgX0hhc0Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc0Ryb3Bkb3duKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1JpcHBsZUluayk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1idXR0b24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3VpLWJ1dHRvbi0nICsgdHlwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYnV0dG9uVHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnc3VibWl0JyB9LFxyXG5cdCAgICAgICAgY29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcmFpc2VkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRleHQ6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGljb25SaWdodDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dEcm9wZG93bkljb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHN0eWxlQ2xhc3NlczogZnVuY3Rpb24gc3R5bGVDbGFzc2VzKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW3RoaXMudHlwZSwgdGhpcy5jb2xvcl07XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMucmFpc2VkKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgndWktYnV0dG9uLXJhaXNlZCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5oYXNEcm9wZG93bk1lbnUgfHwgdGhpcy5oYXNQb3BvdmVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnaGFzLWRyb3Bkb3duJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNwaW5uZXJDb2xvcjogZnVuY3Rpb24gc3Bpbm5lckNvbG9yKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yID09PSAnY29sb3ItZGVmYXVsdCcgfHwgdGhpcy50eXBlID09PSAndWktYnV0dG9uLWZsYXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnYmxhY2snO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gJ3doaXRlJztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93SWNvbjogZnVuY3Rpb24gc2hvd0ljb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pY29uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlNZW51OiBfVWlNZW51Mi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlQb3BvdmVyOiBfVWlQb3BvdmVyMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlQcm9ncmVzc0NpcmN1bGFyOiBfVWlQcm9ncmVzc0NpcmN1bGFyMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19IYXNEcm9wZG93bjIuZGVmYXVsdCwgX1Nob3dzUmlwcGxlSW5rMi5kZWZhdWx0XSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDExMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxidXR0b25cXG4gICAgY2xhc3M9XFxcInVpLWJ1dHRvblxcXCIgOmNsYXNzPVxcXCJzdHlsZUNsYXNzZXNcXFwiIDp0eXBlPVxcXCJidXR0b25UeXBlXFxcIiB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZCB8fCBsb2FkaW5nXFxcIlxcbiAgICB2LWVsOmJ1dHRvblxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktYnV0dG9uLWNvbnRlbnRcXFwiIDpjbGFzcz1cXFwieyAnaW52aXNpYmxlJzogbG9hZGluZyB9XFxcIj5cXG4gICAgICAgIDx1aS1pY29uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLWJ1dHRvbi1pY29uXFxcIiA6Y2xhc3M9XFxcInsgJ3Bvc2l0aW9uLXJpZ2h0JzogaWNvblJpZ2h0IH1cXFwiIDppY29uPVxcXCJpY29uXFxcIlxcbiAgICAgICAgICAgIHYtaWY9XFxcInNob3dJY29uXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWJ1dHRvbi10ZXh0XFxcIj5cXG4gICAgICAgICAgICA8c2xvdD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJ0ZXh0XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8dWktaWNvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1idXR0b24tZHJvcGRvd24taWNvblxcXCIgaWNvbj1cXFwiJiN4RTVDNTtcXFwiXFxuICAgICAgICAgICAgdi1pZj1cXFwiIWljb25SaWdodCAmJiBzaG93RHJvcGRvd25JY29uICYmIChoYXNEcm9wZG93bk1lbnUgfHwgaGFzUG9wb3ZlcilcXFwiXFxuICAgICAgICA+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPHVpLXByb2dyZXNzLWNpcmN1bGFyXFxuICAgICAgICBjbGFzcz1cXFwidWktYnV0dG9uLXNwaW5uZXJcXFwiIDpjb2xvcj1cXFwic3Bpbm5lckNvbG9yXFxcIiA6c2l6ZT1cXFwiMThcXFwiIDpzdHJva2U9XFxcIjQuNVxcXCJcXG4gICAgICAgIGRpc2FibGUtdHJhbnNpdGlvbiB2LXNob3c9XFxcImxvYWRpbmdcXFwiXFxuICAgID48L3VpLXByb2dyZXNzLWNpcmN1bGFyPlxcblxcbiAgICA8dWktcmlwcGxlLWluayB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWRcXFwiIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCI+PC91aS1yaXBwbGUtaW5rPlxcblxcbiAgICA8dWktbWVudVxcbiAgICAgICAgY2xhc3M9XFxcInVpLWJ1dHRvbi1kcm9wZG93bi1tZW51XFxcIiA6dHJpZ2dlcj1cXFwiJGVscy5idXR0b25cXFwiIDpvcHRpb25zPVxcXCJtZW51T3B0aW9uc1xcXCJcXG4gICAgICAgIDpzaG93LWljb25zPVxcXCJzaG93TWVudUljb25zXFxcIiA6c2hvdy1zZWNvbmRhcnktdGV4dD1cXFwic2hvd01lbnVTZWNvbmRhcnlUZXh0XFxcIlxcbiAgICAgICAgOm9wZW4tb249XFxcIm9wZW5Ecm9wZG93bk9uXFxcIiBAb3B0aW9uLXNlbGVjdGVkPVxcXCJtZW51T3B0aW9uU2VsZWN0XFxcIlxcbiAgICAgICAgOmRyb3Bkb3duLXBvc2l0aW9uPVxcXCJkcm9wZG93blBvc2l0aW9uXFxcIiB2LWlmPVxcXCJoYXNEcm9wZG93bk1lbnVcXFwiXFxuICAgID48L3VpLW1lbnU+XFxuXFxuICAgIDx1aS1wb3BvdmVyXFxuICAgICAgICA6dHJpZ2dlcj1cXFwiJGVscy5idXR0b25cXFwiIDpvcGVuLW9uPVxcXCJvcGVuRHJvcGRvd25PblxcXCIgOmRyb3Bkb3duLXBvc2l0aW9uPVxcXCJkcm9wZG93blBvc2l0aW9uXFxcIlxcbiAgICAgICAgdi1pZj1cXFwiaGFzUG9wb3ZlclxcXCJcXG4gICAgPlxcbiAgICAgICAgPHNsb3QgbmFtZT1cXFwicG9wb3ZlclxcXCI+PC9zbG90PlxcbiAgICA8L3VpLXBvcG92ZXI+XFxuPC9idXR0b24+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTE0KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlDaGVja2JveC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaUNoZWNrYm94LnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktY2hlY2tib3gnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgbmFtZTogU3RyaW5nLFxyXG5cdCAgICAgICAgbW9kZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBbQXJyYXksIFN0cmluZywgQm9vbGVhbl0sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdmFsdWU6IFN0cmluZyxcclxuXHQgICAgICAgIGxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBoaWRlTGFiZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGFiZWxMZWZ0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBpc0NoZWNrZWQ6IGZ1bmN0aW9uIGlzQ2hlY2tlZCgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5pbmRleE9mKHRoaXMudmFsdWUpID4gLTE7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xyXG5cdCAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLm1vZGVsO1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1pbnB1dDo6cmVzZXQnOiBmdW5jdGlvbiB1aUlucHV0UmVzZXQoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLmluaXRpYWxWYWx1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTE2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGxhYmVsXFxuICAgIGNsYXNzPVxcXCJ1aS1jaGVja2JveFxcXCJcXG4gICAgOmNsYXNzPVxcXCJ7XFxuICAgICAgICAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ2NoZWNrZWQnOiBpc0NoZWNrZWQsICdhY3RpdmUnOiBhY3RpdmUsICdsYWJlbC1sZWZ0JzogbGFiZWxMZWZ0XFxuICAgIH1cXFwiXFxuPlxcbiAgICA8aW5wdXRcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1jaGVja2JveC1pbnB1dFxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIiBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCJcXG4gICAgICAgIDp2YWx1ZT1cXFwidmFsdWUgPyB2YWx1ZSA6IG51bGxcXFwiIHYtbW9kZWw9XFxcIm1vZGVsXFxcIiB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGVja2JveC1jaGVja21hcmtcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hlY2tib3gtZm9jdXMtcmluZ1xcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGVja2JveC1sYWJlbC10ZXh0XFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj5cXG4gICAgICAgIDxzbG90PlxcbiAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cXFwibGFiZWxcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvc2xvdD5cXG4gICAgPC9kaXY+XFxuPC9sYWJlbD5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDExNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMTgpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUNvbGxhcHNpYmxlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIwKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpQ29sbGFwc2libGUudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDExOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDExOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfdXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG5cdFxyXG5cdHZhciBfdXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dWlkKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluayA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NSaXBwbGVJbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NSaXBwbGVJbmspO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLWNvbGxhcHNpYmxlJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBvcGVuOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhlYWRlcjogU3RyaW5nLFxyXG5cdCAgICAgICAgdHJhbnNpdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAndWktY29sbGFwc2libGUtdG9nZ2xlJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhpZGVJY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBoZWlnaHQ6IDAsXHJcblx0ICAgICAgICAgICAgaXNSZWFkeTogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBpY29uOiBmdW5jdGlvbiBpY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW4gPyAna2V5Ym9hcmRfYXJyb3dfdXAnIDogJ2tleWJvYXJkX2Fycm93X2Rvd24nO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQ6IGZ1bmN0aW9uIGNhbGN1bGF0ZWRIZWlnaHQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnaW5pdGlhbCc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCArICdweCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCBfdXVpZDIuZGVmYXVsdC5zaG9ydCgndWktY29sbGFwc2libGUtJyk7XHJcblx0ICAgIH0sXHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLnNldEhlaWdodCgpO1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1jb2xsYXBzaWJsZTo6cmVmcmVzaC1oZWlnaHQnOiBmdW5jdGlvbiB1aUNvbGxhcHNpYmxlUmVmcmVzaEhlaWdodChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5zZXRIZWlnaHQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICB0b2dnbGVNZW51OiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uIHNldEhlaWdodCgpIHtcclxuXHQgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMuJGVscy5ib2R5O1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGJvZHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBib2R5LnNjcm9sbEhlaWdodDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMub3Blbikge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHQsIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyLmRlZmF1bHRdLFxyXG5cdFxyXG5cdCAgICB0cmFuc2l0aW9uczoge1xyXG5cdCAgICAgICAgJ3VpLWNvbGxhcHNpYmxlLXRvZ2dsZSc6IHtcclxuXHQgICAgICAgICAgICBhZnRlckVudGVyOiBmdW5jdGlvbiBhZnRlckVudGVyKCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnb3BlbmVkJyk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCk7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBhZnRlckxlYXZlOiBmdW5jdGlvbiBhZnRlckxlYXZlKCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xvc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlXFxcIj5cXG4gICAgPGJ1dHRvblxcbiAgICAgICAgY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlLWhlYWRlclxcXCIgOmNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6IGRpc2FibGVkIH1cXFwiIDphcmlhLWNvbnRyb2xzPVxcXCJpZFxcXCJcXG4gICAgICAgIDphcmlhLWV4cGFuZGVkPVxcXCJvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJ1xcXCIgQGNsaWNrPVxcXCJ0b2dnbGVNZW51XFxcIiB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgIHYtZWw6YnV0dG9uXFxuICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNvbGxhcHNpYmxlLWhlYWRlci1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVxcXCJoZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IHYtdGV4dD1cXFwiaGVhZGVyXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDx1aS1pY29uIGNsYXNzPVxcXCJ1aS1jb2xsYXBzaWJsZS1oZWFkZXItaWNvblxcXCIgOmljb249XFxcImljb25cXFwiIHYtaWY9XFxcIiFoaWRlSWNvblxcXCI+PC91aS1pY29uPlxcblxcbiAgICAgICAgPHVpLXJpcHBsZS1pbmtcXG4gICAgICAgICAgICB2LWlmPVxcXCIhaGlkZVJpcHBsZUluayAmJiAhZGlzYWJsZWQgJiYgaXNSZWFkeVxcXCIgOnRyaWdnZXI9XFxcIiRlbHMuYnV0dG9uXFxcIlxcbiAgICAgICAgPjwvdWktcmlwcGxlLWluaz5cXG4gICAgPC9idXR0b24+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1jb2xsYXBzaWJsZS1ib2R5LXdyYXBwZXJcXFwiIDp0cmFuc2l0aW9uPVxcXCJ0cmFuc2l0aW9uXFxcIlxcbiAgICAgICAgOnN0eWxlPVxcXCJ7ICdoZWlnaHQnOiBjYWxjdWxhdGVkSGVpZ2h0IH1cXFwiIHYtc2hvdz1cXFwib3BlblxcXCJ2LWVsOmJvZHlcXG4gICAgPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY29sbGFwc2libGUtYm9keVxcXCIgOmlkPVxcXCJpZFxcXCIgOmFyaWEtaGlkZGVuPVxcXCJvcGVuID8gbnVsbCA6ICd0cnVlJ1xcXCI+XFxuICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTIxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIzKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpQ29uZmlybS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaUNvbmZpcm0udnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblx0XHJcblx0dmFyIF9jbGFzc2xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NsaXN0KTtcclxuXHRcclxuXHR2YXIgX1VpTW9kYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XHJcblx0XHJcblx0dmFyIF9VaU1vZGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpTW9kYWwpO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUJ1dHRvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1jb25maXJtJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknIH0sXHJcblx0ICAgICAgICBoZWFkZXI6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ1VpQ29uZmlybSdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjb25maXJtQnV0dG9uVGV4dDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnT0snXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY29uZmlybUJ1dHRvbkljb246IFN0cmluZyxcclxuXHQgICAgICAgIGRlbnlCdXR0b25UZXh0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdDYW5jZWwnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVueUJ1dHRvbkljb246IFN0cmluZyxcclxuXHQgICAgICAgIGF1dG9mb2N1czoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGVueS1idXR0b24nIH0sXHJcblx0ICAgICAgICBjbG9zZU9uQ29uZmlybToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBiYWNrZHJvcERpc21pc3NpYmxlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbG9hZGluZzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgY29uZmlybTogZnVuY3Rpb24gY29uZmlybSgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY29uZmlybWVkJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkNvbmZpcm0pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlbnk6IGZ1bmN0aW9uIGRlbnkoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RlbmllZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW5lZDogZnVuY3Rpb24gb3BlbmVkKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBidXR0b24gPSB2b2lkIDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYXV0b2ZvY3VzID09PSAnY29uZmlybS1idXR0b24nKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbiA9IHRoaXMuJGVscy5jb25maXJtQnV0dG9uO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvZm9jdXMgPT09ICdkZW55LWJ1dHRvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgYnV0dG9uID0gdGhpcy4kZWxzLmRlbnlCdXR0b247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChidXR0b24pIHtcclxuXHQgICAgICAgICAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5hZGQoYnV0dG9uLCAnYXV0b2ZvY3VzJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5yZW1vdmVBdXRvRm9jdXMpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBidXR0b24uZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcmVtb3ZlQXV0b0ZvY3VzOiBmdW5jdGlvbiByZW1vdmVBdXRvRm9jdXMoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHZvaWQgMDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5hdXRvZm9jdXMgPT09ICdjb25maXJtLWJ1dHRvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgYnV0dG9uID0gdGhpcy4kZWxzLmNvbmZpcm1CdXR0b247XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9mb2N1cyA9PT0gJ2RlbnktYnV0dG9uJykge1xyXG5cdCAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLiRlbHMuZGVueUJ1dHRvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGJ1dHRvbikge1xyXG5cdCAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMucmVtb3ZlQXV0b0ZvY3VzKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5yZW1vdmUoYnV0dG9uLCAnYXV0b2ZvY3VzJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaU1vZGFsOiBfVWlNb2RhbDIuZGVmYXVsdCxcclxuXHQgICAgICAgIFVpQnV0dG9uOiBfVWlCdXR0b24yLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMjQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTI1KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjYpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlNb2RhbC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNylcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaU1vZGFsLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMjUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMjYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2NsYXNzbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cdFxyXG5cdHZhciBfY2xhc3NsaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbGlzdCk7XHJcblx0XHJcblx0dmFyIF9VaUljb25CdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb25CdXR0b24pO1xyXG5cdFxyXG5cdHZhciBfVWlCdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUJ1dHRvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1tb2RhbCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBzaG93OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndWktbW9kYWwtJyArIHR5cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhlYWRlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnVWlNb2RhbCBIZWFkZXInXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYm9keToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnVWlNb2RhbCBib2R5J1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHJvbGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RpYWxvZycgfSxcclxuXHQgICAgICAgIHRyYW5zaXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3VpLW1vZGFsLXNjYWxlJyB9LFxyXG5cdCAgICAgICAgc2hvd0Nsb3NlQnV0dG9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZUZvb3Rlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNtaXNzaWJsZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJhY2tkcm9wRGlzbWlzc2libGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgbGFzdEZvY3Vzc2VkRWxlbWVudDogbnVsbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgd2F0Y2g6IHtcclxuXHQgICAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XHJcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zaG93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuZWQoKTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlZCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5zaG93KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50ZWFyRG93bigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXNtaXNzaWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPT09IHRoaXMuJGVscy5tb2RhbE1hc2sgJiYgZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPT09IHRoaXMuJGVscy5tb2RhbE1hc2sgJiYgIXRoaXMuYmFja2Ryb3BEaXNtaXNzaWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW5lZDogZnVuY3Rpb24gb3BlbmVkKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdEZvY3Vzc2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZWxzLm1vZGFsQ29udGFpbmVyLmZvY3VzKCk7XHJcblx0XHJcblx0ICAgICAgICAgICAgX2NsYXNzbGlzdDIuZGVmYXVsdC5hZGQoZG9jdW1lbnQuYm9keSwgJ3VpLW1vZGFsLW9wZW4nKTtcclxuXHRcclxuXHQgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMucmVzdHJpY3RGb2N1cywgdHJ1ZSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ29wZW5lZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsb3NlZDogZnVuY3Rpb24gY2xvc2VkKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGVhckRvd24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xvc2VkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcmVkaXJlY3RGb2N1czogZnVuY3Rpb24gcmVkaXJlY3RGb2N1cyhlKSB7XHJcblx0ICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRlbHMubW9kYWxDb250YWluZXIuZm9jdXMoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByZXN0cmljdEZvY3VzOiBmdW5jdGlvbiByZXN0cmljdEZvY3VzKGUpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuJGVscy5tb2RhbENvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHtcclxuXHQgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZWxzLm1vZGFsQ29udGFpbmVyLmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRlYXJEb3duOiBmdW5jdGlvbiB0ZWFyRG93bigpIHtcclxuXHQgICAgICAgICAgICBfY2xhc3NsaXN0Mi5kZWZhdWx0LnJlbW92ZShkb2N1bWVudC5ib2R5LCAndWktbW9kYWwtb3BlbicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZXN0cmljdEZvY3VzLCB0cnVlKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sYXN0Rm9jdXNzZWRFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGFzdEZvY3Vzc2VkRWxlbWVudC5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0cmFuc2l0aW9uRW5kOiBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNob3cpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3JldmVhbGVkJyk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2hpZGRlbicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uQnV0dG9uOiBfVWlJY29uQnV0dG9uMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlCdXR0b246IF9VaUJ1dHRvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLW1vZGFsIHVpLW1vZGFsLW1hc2tcXFwiIHYtc2hvdz1cXFwic2hvd1xcXCIgOnRyYW5zaXRpb249XFxcInRyYW5zaXRpb25cXFwiIDpjbGFzcz1cXFwiW3R5cGVdXFxcIlxcbiAgICA6cm9sZT1cXFwicm9sZVxcXCIgQHRyYW5zaXRpb25lbmQ9XFxcInRyYW5zaXRpb25FbmQgfCBkZWJvdW5jZSAxMDBcXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tb2RhbC13cmFwcGVyXFxcIiBAY2xpY2s9XFxcImNsb3NlXFxcIiB2LWVsOm1vZGFsLW1hc2s+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLW1vZGFsLWNvbnRhaW5lclxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBAa2V5ZG93bi5lc2M9XFxcImNsb3NlXFxcIlxcbiAgICAgICAgICAgIHYtZWw6bW9kYWwtY29udGFpbmVyXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktbW9kYWwtaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cXFwiaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxoMSB2LXRleHQ9XFxcImhlYWRlclxcXCIgY2xhc3M9XFxcInVpLW1vZGFsLWhlYWRlci10ZXh0XFxcIj48L2gxPlxcbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XFxuXFxuICAgICAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIGljb249XFxcIiYjeEU1Q0RcXFwiIGNsYXNzPVxcXCJ1aS1tb2RhbC1jbG9zZS1idXR0b25cXFwiIEBjbGljaz1cXFwiY2xvc2VcXFwiXFxuICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XFxcIiFkaXNtaXNzaWJsZVxcXCIgdi1pZj1cXFwic2hvd0Nsb3NlQnV0dG9uXFxcIiB2LWVsOmNsb3NlLWJ1dHRvblxcbiAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tb2RhbC1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtdGV4dD1cXFwiYm9keVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvc2xvdD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tb2RhbC1mb290ZXJcXFwiIHYtaWY9XFxcIiFoaWRlRm9vdGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cXFwiZm9vdGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVxcXCJjbG9zZVxcXCIgdi1pZj1cXFwiZGlzbWlzc2libGVcXFwiPkNsb3NlPC91aS1idXR0b24+XFxuICAgICAgICAgICAgICAgIDwvc2xvdD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb2N1cy1yZWRpcmVjdG9yXFxcIiBAZm9jdXM9XFxcInJlZGlyZWN0Rm9jdXNcXFwiIHRhYmluZGV4PVxcXCIwXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLWNvbmZpcm1cXFwiPlxcbiAgICA8dWktbW9kYWxcXG4gICAgICAgIDpzaG93LnN5bmM9XFxcInNob3dcXFwiIHJvbGU9XFxcImFsZXJ0ZGlhbG9nXFxcIiA6aGVhZGVyPVxcXCJoZWFkZXJcXFwiIEBvcGVuZWQ9XFxcIm9wZW5lZFxcXCIgc2hvdy1jbG9zZS1idXR0b25cXG4gICAgICAgIDpkaXNtaXNzaWJsZT1cXFwiIWxvYWRpbmdcXFwiIDpiYWNrZHJvcC1kaXNtaXNzaWJsZT1cXFwiYmFja2Ryb3BEaXNtaXNzaWJsZVxcXCJcXG4gICAgPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY29uZmlybS1tZXNzYWdlXFxcIj5cXG4gICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgc2xvdD1cXFwiZm9vdGVyXFxcIj5cXG4gICAgICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgICAgIDpjb2xvcj1cXFwidHlwZVxcXCIgOnRleHQ9XFxcImNvbmZpcm1CdXR0b25UZXh0XFxcIiA6aWNvbj1cXFwiY29uZmlybUJ1dHRvbkljb25cXFwiXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwiY29uZmlybVxcXCIgOmxvYWRpbmc9XFxcImxvYWRpbmdcXFwiIHYtZWw6Y29uZmlybS1idXR0b25cXG4gICAgICAgICAgICA+PC91aS1idXR0b24+XFxuXFxuICAgICAgICAgICAgPHVpLWJ1dHRvblxcbiAgICAgICAgICAgICAgICA6dGV4dD1cXFwiZGVueUJ1dHRvblRleHRcXFwiIDppY29uPVxcXCJkZW55QnV0dG9uSWNvblxcXCIgQGNsaWNrPVxcXCJkZW55XFxcIlxcbiAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XFxcImxvYWRpbmdcXFwiIHYtZWw6ZGVueS1idXR0b25cXG4gICAgICAgICAgICA+PC91aS1idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC91aS1tb2RhbD5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEyOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMzApXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaUZhYi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaUZhYi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTMwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTMxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfU2hvd3NUb29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XHJcblx0XHJcblx0dmFyIF9TaG93c1Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hvd3NUb29sdGlwKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1JpcHBsZUluayk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1mYWInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJyxcclxuXHQgICAgICAgICAgICBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAndWktZmFiLScgKyB0eXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsIGNvZXJjZTogZnVuY3Rpb24gY29lcmNlKGNvbG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpY29uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYXJpYUxhYmVsOiBTdHJpbmcsXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19TaG93c1Rvb2x0aXAyLmRlZmF1bHQsIF9TaG93c1JpcHBsZUluazIuZGVmYXVsdF0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48YnV0dG9uXFxuICAgIGNsYXNzPVxcXCJ1aS1mYWJcXFwiIDpjbGFzcz1cXFwiW3RoaXMudHlwZSwgdGhpcy5jb2xvcl1cXFwiIDphcmlhLWxhYmVsPVxcXCJhcmlhTGFiZWwgfHwgdG9vbHRpcFxcXCJcXG4gICAgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHYtZWw6YnV0dG9uXFxuPlxcbiAgICA8dWktaWNvbiBjbGFzcz1cXFwidWktZmFiLWljb25cXFwiIDppY29uPVxcXCJpY29uXFxcIj48L3VpLWljb24+XFxuXFxuICAgIDx1aS1yaXBwbGUtaW5rIDp0cmlnZ2VyPVxcXCIkZWxzLmJ1dHRvblxcXCIgdi1pZj1cXFwiIWhpZGVSaXBwbGVJbmsgJiYgIWRpc2FibGVkXFxcIj48L3VpLXJpcHBsZS1pbms+XFxuXFxuICAgIDx1aS10b29sdGlwXFxuICAgICAgICA6dHJpZ2dlcj1cXFwiJGVscy5idXR0b25cXFwiIDpjb250ZW50PVxcXCJ0b29sdGlwXFxcIiA6cG9zaXRpb249XFxcInRvb2x0aXBQb3NpdGlvblxcXCIgdi1pZj1cXFwidG9vbHRpcFxcXCJcXG4gICAgICAgIDpvcGVuLW9uPVxcXCJvcGVuVG9vbHRpcE9uXFxcIlxcbiAgICA+PC91aS10b29sdGlwPlxcbjwvYnV0dG9uPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTMzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUHJlbG9hZGVyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM2KVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUHJlbG9hZGVyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1wcmVsb2FkZXInLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgc2hvdzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMzYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ1aS1wcmVsb2FkZXJcXFwiPlxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktcHJlbG9hZGVyLXByb2dyZXNzYmFyXFxcIiA6Y2xhc3M9XFxcInsgJ2xvYWRpbmcnIDogc2hvdyB9XFxcIlxcbiAgICAgICAgOmFyaWEtYnVzeT1cXFwic2hvdyA/ICd0cnVlJyA6IGZhbHNlXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCJcXG4gICAgPjwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTM3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM5KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUHJvZ3Jlc3NMaW5lYXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlQcm9ncmVzc0xpbmVhci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTM4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTM5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktcHJvZ3Jlc3MtbGluZWFyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHNob3c6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnaW5kZXRlcm1pbmF0ZScgfSxcclxuXHQgICAgICAgIGNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDBcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcygpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID4gMTAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxMDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXByb2dyZXNzLWxpbmVhclxcXCIgOmNsYXNzPVxcXCJbY29sb3JdXFxcIiB2LXNob3c9XFxcInNob3dcXFwiXFxuICAgIHRyYW5zaXRpb249XFxcInVpLXByb2dyZXNzLWxpbmVhci10b2dnbGVcXFwiXFxuPlxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtbGluZWFyLWRldGVybWluYXRlXFxcIiA6c3R5bGU9XFxcInsgJ3dpZHRoJzogcHJvZ3Jlc3MgKyAnJScgfVxcXCJcXG4gICAgICAgIHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIiA6YXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgOmFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCIgOmFyaWEtdmFsdWVub3c9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgdi1pZj1cXFwidHlwZSA9PT0gJ2RldGVybWluYXRlJ1xcXCJcXG4gICAgPjwvZGl2PlxcblxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktcHJvZ3Jlc3MtbGluZWFyLWluZGV0ZXJtaW5hdGVcXFwiIHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIiA6YXJpYS12YWx1ZW1pbj1cXFwiMFxcXCJcXG4gICAgICAgIDphcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIHYtZWxzZVxcbiAgICA+PC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTQyKVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDMpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlSYWRpby52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVJhZGlvLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1yYWRpbycsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBpZDogU3RyaW5nLFxyXG5cdCAgICAgICAgbmFtZTogU3RyaW5nLFxyXG5cdCAgICAgICAgbW9kZWw6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJycsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2hlY2tlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB2YWx1ZTogU3RyaW5nLFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbExlZnQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFjdGl2ZTogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2ZvY3Vzc2VkJyk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdibHVycmVkJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGFiZWxcXG4gICAgY2xhc3M9XFxcInVpLXJhZGlvXFxcIlxcbiAgICA6Y2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdjaGVja2VkJzogYWN0aXZlLCAnbGFiZWwtbGVmdCc6IGxhYmVsTGVmdCB9XFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktcmFkaW8taW5wdXQtd3JhcHBlclxcXCI+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktcmFkaW8taW5wdXRcXFwiIHR5cGU9XFxcInJhZGlvXFxcIiA6aWQ9XFxcImlkXFxcIiA6bmFtZT1cXFwibmFtZVxcXCIgOnZhbHVlPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICA6Y2hlY2tlZD1cXFwiY2hlY2tlZFxcXCIgQGZvY3VzPVxcXCJmb2N1c1xcXCIgQGJsdXI9XFxcImJsdXJcXFwiIHYtbW9kZWw9XFxcIm1vZGVsXFxcIiB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgID5cXG5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1yYWRpby1ib3JkZXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1yYWRpby1pbm5lci1kb3RcXFwiPjwvc3Bhbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhZGlvLWxhYmVsLXRleHRcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPlxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPHNwYW4gdi10ZXh0PVxcXCJsYWJlbFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9zbG90PlxcbiAgICA8L2Rpdj5cXG48L2xhYmVsPlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTQ1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ3KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUmFkaW9Hcm91cC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVJhZGlvR3JvdXAudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1VpUmFkaW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MSk7XHJcblx0XHJcblx0dmFyIF9VaVJhZGlvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUmFkaW8pO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJhZGlvLWdyb3VwJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG5hbWU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB2YWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnJyxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhlbHBUZXh0OiBTdHJpbmcsXHJcblx0ICAgICAgICB2ZXJ0aWNhbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNhYmxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbml0aWFsVmFsdWU6ICcnXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdCAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xyXG5cdCAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ZlZWRiYWNrOiBmdW5jdGlvbiBzaG93RmVlZGJhY2soKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5oZWxwVGV4dCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlSYWRpbzogX1VpUmFkaW8yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGlyZWN0aXZlczoge1xyXG5cdCAgICAgICAgZGlzYWJsZWQ6IF9kaXNhYmxlZDIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1yYWRpby1ncm91cFxcXCIgOmlkPVxcXCJpZFxcXCJcXG4gICAgOmNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6IGRpc2FibGVkLCAnYWN0aXZlJzogYWN0aXZlLCAndmVydGljYWwnOiB2ZXJ0aWNhbCB9XFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktcmFkaW8tZ3JvdXAtbGFiZWxcXFwiIHYtdGV4dD1cXFwibGFiZWxcXFwiIHYtaWY9XFxcIiFoaWRlTGFiZWxcXFwiPjwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpby1ncm91cC1vcHRpb25zLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPHVpLXJhZGlvXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXJhZGlvLWdyb3VwLXJhZGlvXFxcIiB2LWZvcj1cXFwib3B0aW9uIGluIG9wdGlvbnNcXFwiIDptb2RlbC5zeW5jPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICA6bmFtZT1cXFwibmFtZVxcXCIgOmxhYmVsPVxcXCJvcHRpb24udGV4dCB8fCBvcHRpb25cXFwiIDp2YWx1ZT1cXFwib3B0aW9uLnZhbHVlIHx8IG9wdGlvblxcXCJcXG4gICAgICAgICAgICA6ZGlzYWJsZWQ9XFxcImRpc2FibGVkIHx8IG9wdGlvbi5kaXNhYmxlZFxcXCIgQGZvY3Vzc2VkPVxcXCJmb2N1c1xcXCIgQGJsdXJyZWQ9XFxcImJsdXJcXFwiXFxuICAgICAgICA+PC91aS1yYWRpbz5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1yYWRpby1ncm91cC1mZWVkYmFja1xcXCIgdi1pZj1cXFwic2hvd0ZlZWRiYWNrXFxcIlxcbiAgICAgICAgdHJhbnNpdGlvbj1cXFwidWktcmFkaW8tZ3JvdXAtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpby1ncm91cC1oZWxwLXRleHRcXFwiIHYtdGV4dD1cXFwiaGVscFRleHRcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNTApXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVJhdGluZy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVJhdGluZy52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTUwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTUxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ0ljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Mik7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ0ljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYXRpbmdJY29uKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudCk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1yYXRpbmcnLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnc3RhcicgfSxcclxuXHQgICAgICAgIHZhbHVlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRvdGFsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoZWxwVGV4dDogU3RyaW5nLFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiAwLFxyXG5cdCAgICAgICAgICAgIHByZXZpZXdWYWx1ZTogMCxcclxuXHQgICAgICAgICAgICBwcmV2aWV3aW5nOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHNob3dGZWVkYmFjazogZnVuY3Rpb24gc2hvd0ZlZWRiYWNrKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaGVscFRleHQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICB3YXRjaDoge1xyXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucHJldmlld1ZhbHVlID0gdGhpcy52YWx1ZTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwcmV2aWV3VmFsdWU6IGZ1bmN0aW9uIHByZXZpZXdWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgncHJldmlldy12YWx1ZS1jaGFuZ2VkJywgdGhpcy5wcmV2aWV3VmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xyXG5cdCAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5wcmV2aWV3VmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1pbnB1dDo6cmVzZXQnOiBmdW5jdGlvbiB1aUlucHV0UmVzZXQoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmluaXRpYWxWYWx1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgc3RhcnRQcmV2aWV3OiBmdW5jdGlvbiBzdGFydFByZXZpZXcoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnByZXZpZXdpbmcgPSB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGVuZFByZXZpZXc6IGZ1bmN0aW9uIGVuZFByZXZpZXcoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnByZXZpZXdpbmcgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLnByZXZpZXdWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcHJldmlldzogZnVuY3Rpb24gcHJldmlldyhuKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnByZXZpZXdWYWx1ZSA9IG4gKyAxO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNvbW1pdFZhbHVlOiBmdW5jdGlvbiBjb21taXRWYWx1ZSh2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiB2YWx1ZSA8PSB0aGlzLnRvdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaW5jcmVtZW50UHJldmlld1ZhbHVlOiBmdW5jdGlvbiBpbmNyZW1lbnRQcmV2aWV3VmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgcHJvcG9zZWRWYWx1ZSA9IHRoaXMucHJldmlld1ZhbHVlICsgMTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAocHJvcG9zZWRWYWx1ZSA8PSB0aGlzLnRvdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucHJldmlld1ZhbHVlID0gcHJvcG9zZWRWYWx1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVjcmVtZW50UHJldmlld1ZhbHVlOiBmdW5jdGlvbiBkZWNyZW1lbnRQcmV2aWV3VmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgcHJvcG9zZWRWYWx1ZSA9IHRoaXMucHJldmlld1ZhbHVlIC0gMTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAocHJvcG9zZWRWYWx1ZSA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wcmV2aWV3VmFsdWUgPSBwcm9wb3NlZFZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRQcmV2aWV3KCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuY29tbWl0VmFsdWUodGhpcy5wcmV2aWV3VmFsdWUpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZW5kUHJldmlldygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVJhdGluZ0ljb246IF9VaVJhdGluZ0ljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTUyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTU0KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpUmF0aW5nSWNvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NSlcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVJhdGluZ0ljb24udnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1MyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDE1NCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktcmF0aW5nLWljb24nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnc3RhcicgfSxcclxuXHQgICAgICAgIHNlbGVjdGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZpbGxlZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGljb246IGZ1bmN0aW9uIGljb24oKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZmlsbGVkIHx8IHRoaXMuc2VsZWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3N0YXInID8gJ3N0YXInIDogJ2Zhdm9yaXRlJztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3N0YXInID8gJ3N0YXJfYm9yZGVyJyA6ICdmYXZvcml0ZV9ib3JkZXInO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ1aS1yYXRpbmctaWNvblxcXCI+XFxuICAgIDx1aS1pY29uXFxuICAgICAgICBjbGFzcz1cXFwidWktcmF0aW5nLWljb24taWNvblxcXCIgOmljb249XFxcImljb25cXFwiXFxuICAgICAgICA6Y2xhc3M9XFxcInsgJ3NlbGVjdGVkJzogc2VsZWN0ZWQsICdmaWxsZWQnIDogZmlsbGVkIH1cXFwiXFxuICAgID48L3VpLWljb24+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1yYXRpbmdcXFwiIDpjbGFzcz1cXFwieyAnZGlzYWJsZWQnOiBkaXNhYmxlZCwgJ3ByZXZpZXcnOiBwcmV2aWV3aW5nLCAnYWN0aXZlJzogYWN0aXZlIH1cXFwiXFxuXFxuICAgIDp0YWJpbmRleD1cXFwiZGlzYWJsZWQgPyBudWxsIDogMFxcXCIgcm9sZT1cXFwic2xpZGVyXFxcIiA6YXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgOmFyaWEtdmFsdWVtYXg9XFxcInRvdGFsXFxcIlxcbiAgICA6YXJpYS12YWx1ZW5vdz1cXFwicHJldmlld1ZhbHVlXFxcIlxcblxcbiAgICBAa2V5ZG93bi51cC5wcmV2ZW50PVxcXCJpbmNyZW1lbnRQcmV2aWV3VmFsdWVcXFwiIEBrZXlkb3duLmRvd24ucHJldmVudD1cXFwiZGVjcmVtZW50UHJldmlld1ZhbHVlXFxcIlxcbiAgICBAa2V5ZG93bi5yaWdodC5wcmV2ZW50PVxcXCJpbmNyZW1lbnRQcmV2aWV3VmFsdWVcXFwiIEBrZXlkb3duLmxlZnQucHJldmVudD1cXFwiZGVjcmVtZW50UHJldmlld1ZhbHVlXFxcIlxcbiAgICBAa2V5ZG93bi5lbnRlci5wcmV2ZW50PVxcXCJjb21taXRWYWx1ZShwcmV2aWV3VmFsdWUpXFxcIiBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCJcXG4+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhdGluZy1sYWJlbFxcXCIgdi10ZXh0PVxcXCJsYWJlbFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+PC9kaXY+XFxuXFxuICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1yYXRpbmctaWNvbnMtd3JhcHBlclxcXCIgQG1vdXNlZW50ZXI9XFxcInN0YXJ0UHJldmlld1xcXCIgQG1vdXNlbGVhdmU9XFxcImVuZFByZXZpZXdcXFwiXFxuICAgID5cXG4gICAgICAgIDx1aS1yYXRpbmctaWNvblxcbiAgICAgICAgICAgIDp0eXBlPVxcXCJ0eXBlXFxcIiB2LWZvcj1cXFwibiBpbiB0b3RhbFxcXCIgOnNlbGVjdGVkPVxcXCIobiArIDEpIDw9IHZhbHVlXFxcIiBAbW91c2VvdmVyPVxcXCJwcmV2aWV3KG4pXFxcIlxcbiAgICAgICAgICAgIDpmaWxsZWQ9XFxcIihuICsgMSkgPD0gcHJldmlld1ZhbHVlXFxcIiBAY2xpY2s9XFxcImNvbW1pdFZhbHVlKG4gKyAxKVxcXCJcXG4gICAgICAgID48L3VpLXJhdGluZy1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInVpLXJhdGluZy1mZWVkYmFja1xcXCIgdi1pZj1cXFwic2hvd0ZlZWRiYWNrXFxcIiB0cmFuc2l0aW9uPVxcXCJ1aS1yYXRpbmctZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYXRpbmctaGVscC10ZXh0XFxcIiB2LXRleHQ9XFxcImhlbHBUZXh0XFxcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNTcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTU4KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkpXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlSYXRpbmdQcmV2aWV3LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpUmF0aW5nUHJldmlldy52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTU4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTU5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ0ljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Mik7XHJcblx0XHJcblx0dmFyIF9VaVJhdGluZ0ljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlSYXRpbmdJY29uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXJhdGluZy1wcmV2aWV3JyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3N0YXInIH0sXHJcblx0ICAgICAgICB2YWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuXHQgICAgICAgICAgICBjb2VyY2U6IE51bWJlcixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRvdGFsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpUmF0aW5nSWNvbjogX1VpUmF0aW5nSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2MCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcInVpLXJhdGluZy1wcmV2aWV3XFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIDphcmlhLXZhbHVlbWluPVxcXCIwXFxcIiA6YXJpYS12YWx1ZW1heD1cXFwidG90YWxcXFwiXFxuICAgIDphcmlhLXZhbHVlbm93PVxcXCJ2YWx1ZVxcXCJcXG4+XFxuICAgIDx1aS1yYXRpbmctaWNvblxcbiAgICAgICAgOnR5cGU9XFxcInR5cGVcXFwiIHYtZm9yPVxcXCJuIGluIHRvdGFsXFxcIiA6c2VsZWN0ZWQ9XFxcIihuICsgMSkgPD0gdmFsdWVcXFwiXFxuICAgID48L3VpLXJhdGluZy1pY29uPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTYxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MilcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYzKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU2VsZWN0LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcxKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU2VsZWN0LnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX21lcmdlT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY0KTtcclxuXHRcclxuXHR2YXIgX21lcmdlT3B0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXJnZU9wdGlvbnMpO1xyXG5cdFxyXG5cdHZhciBfZnV6enlzZWFyY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcclxuXHRcclxuXHR2YXIgX2Z1enp5c2VhcmNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Z1enp5c2VhcmNoKTtcclxuXHRcclxuXHR2YXIgX2VsZW1lbnRTY3JvbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2Nik7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0dmFyIF9VaVNlbGVjdE9wdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTY3KTtcclxuXHRcclxuXHR2YXIgX1VpU2VsZWN0T3B0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpU2VsZWN0T3B0aW9uKTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NDaXJjdWxhciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0NpcmN1bGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpUHJvZ3Jlc3NDaXJjdWxhcik7XHJcblx0XHJcblx0dmFyIF9IYXNUZXh0SW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IYXNUZXh0SW5wdXQpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcclxuXHRcclxuXHR2YXIgX1ZhbGlkYXRlc0lucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRlc0lucHV0KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXNlbGVjdCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB2YWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFtPYmplY3QsIEFycmF5LCBTdHJpbmcsIE51bWJlcl0sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZWZhdWx0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogW09iamVjdCwgQXJyYXksIFN0cmluZywgTnVtYmVyXSxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBudWxsXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3B0aW9uczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEFycmF5LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IFtdXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGFydGlhbDogU3RyaW5nLFxyXG5cdCAgICAgICAgc2hvd1NlYXJjaDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWFyY2hQbGFjZWhvbGRlcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnU2VhcmNoJ1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG11bHRpcGxlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG11bHRpcGxlRGVsaW1pdGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICcsICdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb25zRHluYW1pYzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBvcHRpb25zTG9hZGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbG9hZGluZzoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBrZXlzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3RleHQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd2YWx1ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbWFnZTogJ2ltYWdlJ1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmaWx0ZXI6IEZ1bmN0aW9uXHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHF1ZXJ5OiAnJyxcclxuXHQgICAgICAgICAgICBzZWxlY3RlZEluZGV4OiAtMSxcclxuXHQgICAgICAgICAgICBoaWdobGlnaHRlZEluZGV4OiAtMSxcclxuXHQgICAgICAgICAgICBzaG93RHJvcGRvd246IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGlnbm9yZVF1ZXJ5Q2hhbmdlOiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIGZpbHRlcmVkT3B0aW9uczogZnVuY3Rpb24gZmlsdGVyZWRPcHRpb25zKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNEeW5hbWljKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmlsdGVyKHRoaXMuc2VhcmNoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkaXNwbGF5VGV4dDogZnVuY3Rpb24gZGlzcGxheVRleHQoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbX3RoaXMua2V5cy50ZXh0XSB8fCB2YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbHMuam9pbih0aGlzLm11bHRpcGxlRGVsaW1pdGVyKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlW3RoaXMua2V5cy50ZXh0XSB8fCB0aGlzLnZhbHVlIDogJyc7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGFzRGlzcGxheVRleHQ6IGZ1bmN0aW9uIGhhc0Rpc3BsYXlUZXh0KCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlUZXh0ICYmIEJvb2xlYW4odGhpcy5kaXNwbGF5VGV4dC5sZW5ndGgpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3dJY29uOiBmdW5jdGlvbiBzaG93SWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmljb24pO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG5vdGhpbmdGb3VuZDogZnVuY3Rpb24gbm90aGluZ0ZvdW5kKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNEeW5hbWljICYmICF0aGlzLm9wdGlvbnNMb2FkZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sZW5ndGggJiYgIXRoaXMubG9hZGluZykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIUJvb2xlYW4odGhpcy5maWx0ZXJlZE9wdGlvbnMubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICB3YXRjaDoge1xyXG5cdCAgICAgICAgZmlsdGVyZWRPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJlZE9wdGlvbnMoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gMDtcclxuXHQgICAgICAgICAgICAoMCwgX2VsZW1lbnRTY3JvbGwucmVzZXRTY3JvbGwpKHRoaXMuJGVscy5vcHRpb25zTGlzdCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2hvd0Ryb3Bkb3duOiBmdW5jdGlvbiBzaG93RHJvcGRvd24oKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMub3BlbmVkKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdvcGVuZWQnKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xvc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHF1ZXJ5OiBmdW5jdGlvbiBxdWVyeSgpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaWdub3JlUXVlcnlDaGFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3F1ZXJ5LWNoYW5nZWQnLCB0aGlzLnF1ZXJ5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRWYWx1ZSgpO1xyXG5cdFxyXG5cdCAgICAgICAgdmFyIGVycm9yTWVzc2FnZXMgPSB7XHJcblx0ICAgICAgICAgICAgbWluOiAnWW91IG11c3Qgc2VsZWN0IGF0IGxlYXN0IDptaW4gb3B0aW9ucy4nLFxyXG5cdCAgICAgICAgICAgIG1heDogJ1lvdSBtdXN0IHNlbGVjdCBubyBtb3JlIHRoYW4gOm1heCBvcHRpb25zLicsXHJcblx0ICAgICAgICAgICAgYmV0d2VlbjogJ1lvdSBtdXN0IHNlbGVjdCBhdCBsZWFzdCA6bWluIGJ1dCBubyBtb3JlIHRoYW4gOm1heCBvcHRpb25zLidcclxuXHQgICAgICAgIH07XHJcblx0XHJcblx0ICAgICAgICBpZiAodGhpcy52YWxpZGF0aW9uUnVsZXMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRpb25NZXNzYWdlcyA9ICgwLCBfbWVyZ2VPcHRpb25zMi5kZWZhdWx0KShlcnJvck1lc3NhZ2VzLCB0aGlzLnZhbGlkYXRpb25NZXNzYWdlcyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcclxuXHQgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XHJcblx0ICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2spO1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1zZWxlY3Q6OnNldC1zZWxlY3RlZCc6IGZ1bmN0aW9uIHVpU2VsZWN0U2V0U2VsZWN0ZWQodmFsdWUsIGlkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmRlZmF1bHQgPSB2YWx1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLmluaXRWYWx1ZSgpO1xyXG5cdCAgICAgICAgfSxcclxuXHRcclxuXHQgICAgICAgICd1aS1pbnB1dDo6cmVzZXQnOiBmdW5jdGlvbiB1aUlucHV0UmVzZXQoaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuY2xlYXJRdWVyeSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IC0xO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBpbml0VmFsdWU6IGZ1bmN0aW9uIGluaXRWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5tdWx0aXBsZSA/IFtdIDogbnVsbDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IEFycmF5LmlzQXJyYXkodGhpcy5kZWZhdWx0KSA/IHRoaXMuZGVmYXVsdCA6IFt0aGlzLmRlZmF1bHRdO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdHMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNldERlZmF1bHRWYWx1ZShkZWZhdWx0cyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2gob3B0aW9uKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihvcHRpb24sIHRoaXMucXVlcnkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5LnRvTG93ZXJDYXNlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRleHQgPSBvcHRpb25bdGhpcy5rZXlzLnRleHRdIHx8IG9wdGlvbjtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgX2Z1enp5c2VhcmNoMi5kZWZhdWx0KShxdWVyeSwgdGV4dCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xlYXJRdWVyeTogZnVuY3Rpb24gY2xlYXJRdWVyeSgpIHtcclxuXHQgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmlnbm9yZVF1ZXJ5Q2hhbmdlID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzMi5xdWVyeSA9ICcnO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBfdGhpczIuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMi5pZ25vcmVRdWVyeUNoYW5nZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChvcHRpb24sIGluZGV4KSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsb3NlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1syXTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKG9wdGlvbikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3Qob3B0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChvcHRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzZWxlY3RlZCcsIG9wdGlvbik7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5jbGVhclF1ZXJ5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSAmJiBjbG9zZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChvcHRpb24pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlLiRyZW1vdmUob3B0aW9uKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiBpc1NlbGVjdGVkKG9wdGlvbikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmluZGV4T2Yob3B0aW9uKSA+IC0xO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3B0aW9uO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdEhpZ2hsaWdodGVkOiBmdW5jdGlvbiBzZWxlY3RIaWdobGlnaHRlZChpbmRleCwgZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzLm9wdGlvbnMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy4kcmVmcy5vcHRpb25zW2luZGV4XS5vcHRpb24sIGluZGV4KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiBoaWdobGlnaHQoaW5kZXgsIHByZXZlbnRTY3JvbGwpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZEluZGV4ID09PSBpbmRleCB8fCB0aGlzLiRyZWZzLm9wdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSAwO1xyXG5cdCAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSB0aGlzLiRyZWZzLm9wdGlvbnMubGVuZ3RoIC0gMTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoaW5kZXggPCBmaXJzdEluZGV4KSB7XHJcblx0ICAgICAgICAgICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBmaXJzdEluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSBpbmRleDtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXByZXZlbnRTY3JvbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxPcHRpb25JbnRvVmlldyh0aGlzLiRyZWZzLm9wdGlvbnNbaW5kZXhdLiRlbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNob3dEcm9wZG93bikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNob3dEcm9wZG93bikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgb3BlbmVkOiBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLnNob3dTZWFyY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMy4kZWxzLnNlYXJjaElucHV0LmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpczMuJGVscy5kcm9wZG93bi5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIF90aGlzMy5zY3JvbGxPcHRpb25JbnRvVmlldyhfdGhpczMuJGVscy5vcHRpb25zTGlzdC5xdWVyeVNlbGVjdG9yKCcuc2VsZWN0ZWQnKSk7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGRlYWN0aXZhdGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IGZhbHNlO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKGRlYWN0aXZhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRlbHMubGFiZWwuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgY2xvc2VPbkV4dGVybmFsQ2xpY2s6IGZ1bmN0aW9uIGNsb3NlT25FeHRlcm5hbENsaWNrKGUpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuJGVsLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiAodGhpcy5zaG93RHJvcGRvd24gfHwgdGhpcy5hY3RpdmUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UodHJ1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNsb3NlZDogZnVuY3Rpb24gY2xvc2VkKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSAtMTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNldERlZmF1bHRWYWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKGRlZmF1bHRzKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG9wdGlvblZhbHVlID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uVmFsdWUgPSB2b2lkIDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uVmFsdWUgPSBkZWZhdWx0c1tpXVt0aGlzLmtleXMudmFsdWVdIHx8IGRlZmF1bHRzW2ldO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMub3B0aW9ucy5sZW5ndGg7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9uVmFsdWUgPSB0aGlzLm9wdGlvbnNbal1bdGhpcy5rZXlzLnZhbHVlXSB8fCB0aGlzLm9wdGlvbnNbal07XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT09IGRlZmF1bHRPcHRpb25WYWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMub3B0aW9uc1tqXSwgaiwgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNjcm9sbE9wdGlvbkludG9WaWV3OiBmdW5jdGlvbiBzY3JvbGxPcHRpb25JbnRvVmlldyhvcHRpb25FbCkge1xyXG5cdCAgICAgICAgICAgICgwLCBfZWxlbWVudFNjcm9sbC5zY3JvbGxJbnRvVmlldykob3B0aW9uRWwsIHRoaXMuJGVscy5vcHRpb25zTGlzdCwgODApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHQsXHJcblx0ICAgICAgICBVaVNlbGVjdE9wdGlvbjogX1VpU2VsZWN0T3B0aW9uMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlQcm9ncmVzc0NpcmN1bGFyOiBfVWlQcm9ncmVzc0NpcmN1bGFyMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19IYXNUZXh0SW5wdXQyLmRlZmF1bHQsIF9WYWxpZGF0ZXNJbnB1dDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTY0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0dmFyIGlzT3B0aW9uT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjUpO1xyXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcblx0dmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGU7XHJcblx0dmFyIGdsb2JhbFRoaXMgPSB0aGlzO1xyXG5cdHZhciBkZWZhdWx0TWVyZ2VPcHRzID0ge1xyXG5cdFx0Y29uY2F0QXJyYXlzOiBmYWxzZVxyXG5cdH07XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyh2YWx1ZSkge1xyXG5cdFx0dmFyIGtleXMgPSBbXTtcclxuXHRcclxuXHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xyXG5cdFx0XHRcdGtleXMucHVzaChrZXkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHJcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xyXG5cdFx0XHR2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xyXG5cdFxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCBzeW1ib2xzW2ldKSkge1xyXG5cdFx0XHRcdFx0a2V5cy5wdXNoKHN5bWJvbHNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFxyXG5cdFx0cmV0dXJuIGtleXM7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0cmV0dXJuIGNsb25lQXJyYXkodmFsdWUpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0aWYgKGlzT3B0aW9uT2JqZWN0KHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gY2xvbmVPcHRpb25PYmplY3QodmFsdWUpO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5KSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgMCk7XHJcblx0XHJcblx0XHRnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdFx0cmVzdWx0W2tleV0gPSBjbG9uZShhcnJheVtrZXldKTtcclxuXHRcdH0pO1xyXG5cdFxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gY2xvbmVPcHRpb25PYmplY3Qob2JqKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XHJcblx0XHJcblx0XHRnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHRcdHJlc3VsdFtrZXldID0gY2xvbmUob2JqW2tleV0pO1xyXG5cdFx0fSk7XHJcblx0XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gbWVyZ2VkIHthbHJlYWR5IGNsb25lZH1cclxuXHQgKiBAcmV0dXJuIHtjbG9uZWQgT2JqZWN0fVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIG1lcmdlS2V5cyhtZXJnZWQsIHNvdXJjZSwga2V5cywgbWVyZ2VPcHRzKSB7XHJcblx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRpZiAoa2V5IGluIG1lcmdlZCkge1xyXG5cdFx0XHRcdG1lcmdlZFtrZXldID0gbWVyZ2UobWVyZ2VkW2tleV0sIHNvdXJjZVtrZXldLCBtZXJnZU9wdHMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lcmdlZFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcclxuXHRcdHJldHVybiBtZXJnZWQ7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBtZXJnZWQge2FscmVhZHkgY2xvbmVkfVxyXG5cdCAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XHJcblx0ICpcclxuXHQgKiBzZWUgW0FycmF5LnByb3RvdHlwZS5jb25jYXQgKCAuLi5hcmd1bWVudHMgKV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXQpXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gY29uY2F0QXJyYXlzKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpIHtcclxuXHRcdHZhciByZXN1bHQgPSBtZXJnZWQuc2xpY2UoMCwgMCk7XHJcblx0XHR2YXIgcmVzdWx0SW5kZXggPSAwO1xyXG5cdFxyXG5cdFx0W21lcmdlZCwgc291cmNlXS5mb3JFYWNoKGZ1bmN0aW9uIChhcnJheSkge1xyXG5cdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cdFxyXG5cdFx0XHQvLyByZXN1bHQuY29uY2F0KGFycmF5KSB3aXRoIGNsb25pbmdcclxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBhcnJheS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdGlmICghaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaykpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goU3RyaW5nKGspKTtcclxuXHRcclxuXHRcdFx0XHRpZiAoYXJyYXkgPT09IG1lcmdlZCkge1xyXG5cdFx0XHRcdFx0Ly8gYWxyZWFkeSBjbG9uZWRcclxuXHRcdFx0XHRcdHJlc3VsdFtyZXN1bHRJbmRleCsrXSA9IGFycmF5W2tdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXN1bHRbcmVzdWx0SW5kZXgrK10gPSBjbG9uZShhcnJheVtrXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHJcblx0XHRcdC8vIG1lcmdlIG5vbi1pbmRleCBrZXlzXHJcblx0XHRcdHJlc3VsdCA9IG1lcmdlS2V5cyhyZXN1bHQsIGFycmF5LCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRcdHJldHVybiBpbmRpY2VzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XHJcblx0XHRcdH0pLCBtZXJnZU9wdHMpO1xyXG5cdFx0fSk7XHJcblx0XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gbWVyZ2VkIHthbHJlYWR5IGNsb25lZH1cclxuXHQgKiBAcmV0dXJuIHtjbG9uZWQgT2JqZWN0fVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIG1lcmdlKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpIHtcclxuXHRcdGlmIChtZXJnZU9wdHMuY29uY2F0QXJyYXlzICYmIEFycmF5LmlzQXJyYXkobWVyZ2VkKSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmNhdEFycmF5cyhtZXJnZWQsIHNvdXJjZSwgbWVyZ2VPcHRzKTtcclxuXHRcdH1cclxuXHRcclxuXHRcdGlmICghaXNPcHRpb25PYmplY3Qoc291cmNlKSB8fCAhaXNPcHRpb25PYmplY3QobWVyZ2VkKSkge1xyXG5cdFx0XHRyZXR1cm4gY2xvbmUoc291cmNlKTtcclxuXHRcdH1cclxuXHRcclxuXHRcdHJldHVybiBtZXJnZUtleXMobWVyZ2VkLCBzb3VyY2UsIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoc291cmNlKSwgbWVyZ2VPcHRzKTtcclxuXHR9XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWVyZ2VPcHRzID0gbWVyZ2UoY2xvbmUoZGVmYXVsdE1lcmdlT3B0cyksICh0aGlzICE9PSBnbG9iYWxUaGlzICYmIHRoaXMpIHx8IHt9LCBkZWZhdWx0TWVyZ2VPcHRzKTtcclxuXHRcdHZhciBtZXJnZWQgPSB7fTtcclxuXHRcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBvcHRpb24gPSBhcmd1bWVudHNbaV07XHJcblx0XHJcblx0XHRcdGlmIChvcHRpb24gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHJcblx0XHRcdGlmICghaXNPcHRpb25PYmplY3Qob3B0aW9uKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2AnICsgb3B0aW9uICsgJ2AgaXMgbm90IGFuIE9wdGlvbiBPYmplY3QnKTtcclxuXHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRtZXJnZWQgPSBtZXJnZShtZXJnZWQsIG9wdGlvbiwgbWVyZ2VPcHRzKTtcclxuXHRcdH1cclxuXHRcclxuXHRcdHJldHVybiBtZXJnZWQ7XHJcblx0fTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjUgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcclxuXHRcdHZhciBwcm90b3R5cGU7XHJcblx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgKHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSwgcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSk7XHJcblx0fTtcclxuXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNjYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdGV4cG9ydHMuaW5WaWV3ID0gaW5WaWV3O1xyXG5cdGV4cG9ydHMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcclxuXHRleHBvcnRzLnJlc2V0U2Nyb2xsID0gcmVzZXRTY3JvbGw7XHJcblx0ZnVuY3Rpb24gaW5WaWV3KGVsZW1lbnQsIGNvbnRhaW5lcikge1xyXG5cdCAgICBpZiAoIWVsZW1lbnQpIHtcclxuXHQgICAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG5cdFxyXG5cdCAgICB2YXIgdG9wID0gZWxlbWVudC5vZmZzZXRUb3A7XHJcblx0ICAgIHZhciBwYXJlbnRUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xyXG5cdCAgICB2YXIgYm90dG9tID0gdG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcblx0ICAgIHZhciBwYXJlbnRCb3R0b20gPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cdFxyXG5cdCAgICByZXR1cm4gdG9wID49IHBhcmVudFRvcCAmJiBib3R0b20gPD0gcGFyZW50Qm90dG9tO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtZW50LCBjb250YWluZXIpIHtcclxuXHQgICAgdmFyIG1hcmdpblRvcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMl07XHJcblx0XHJcblx0ICAgIGlmICghZWxlbWVudCB8fCBpblZpZXcoZWxlbWVudCwgY29udGFpbmVyKSkge1xyXG5cdCAgICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblx0XHJcblx0ICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcCAtIG1hcmdpblRvcDtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gcmVzZXRTY3JvbGwoZWxlbWVudCkge1xyXG5cdCAgICBpZiAoIWVsZW1lbnQpIHtcclxuXHQgICAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XHJcblx0fVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgaW5WaWV3OiBpblZpZXcsXHJcblx0ICAgIHNjcm9sbEludG9WaWV3OiBzY3JvbGxJbnRvVmlldyxcclxuXHQgICAgcmVzZXRTY3JvbGw6IHJlc2V0U2Nyb2xsXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE2NyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNjgpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSlcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVNlbGVjdE9wdGlvbi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MClcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVNlbGVjdE9wdGlvbi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTY4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTY5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpSWNvbik7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS1zZWxlY3Qtb3B0aW9uJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIG9wdGlvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJ0aWFsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd1aS1zZWxlY3Qtc2ltcGxlJyB9LFxyXG5cdCAgICAgICAgc2hvd0NoZWNrYm94OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhpZ2hsaWdodGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleXM6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAndGV4dCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIGltYWdlOiAnaW1hZ2UnXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgaWNvbjogZnVuY3Rpb24gaWNvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCA/ICdjaGVja19ib3gnIDogJ2NoZWNrX2JveF9vdXRsaW5lX2JsYW5rJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlJY29uOiBfVWlJY29uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHBhcnRpYWxzOiB7XHJcblx0ICAgICAgICAndWktc2VsZWN0LXNpbXBsZSc6ICdcXG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJ1aS1zZWxlY3QtaXRlbS10ZXh0XCIgdi10ZXh0PVwib3B0aW9uW2tleXMudGV4dF0gfHwgb3B0aW9uXCI+PC9saT5cXG4gICAgICAgICcsXHJcblx0XHJcblx0ICAgICAgICAndWktc2VsZWN0LWltYWdlJzogJ1xcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ1aS1zZWxlY3QtaXRlbS1pbWFnZVwiXFxuICAgICAgICAgICAgICAgIDpzdHlsZT1cInsgXFwnYmFja2dyb3VuZC1pbWFnZVxcJzogXFwndXJsKFxcJyArIG9wdGlvbltrZXlzLmltYWdlXSArIFxcJylcXCcgfVwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1zZWxlY3QtaXRlbS10ZXh0XCIgdi10ZXh0PVwib3B0aW9uW2tleXMudGV4dF1cIj48L2Rpdj5cXG4gICAgICAgICdcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48bGlcXG4gICAgY2xhc3M9XFxcInVpLXNlbGVjdC1vcHRpb25cXFwiIDpjbGFzcz1cXFwieyBoaWdobGlnaHRlZDogaGlnaGxpZ2h0ZWQsIHNlbGVjdGVkOiBzZWxlY3RlZCB9XFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LW9wdGlvbi1jb250ZW50XFxcIiA6Y2xhc3M9XFxcIltwYXJ0aWFsXVxcXCI+XFxuICAgICAgICA8cGFydGlhbCA6bmFtZT1cXFwicGFydGlhbFxcXCI+PC9wYXJ0aWFsPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPHVpLWljb25cXG4gICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtb3B0aW9uLWNoZWNrYm94XFxcIiA6aWNvbj1cXFwiaWNvblxcXCIgdi1pZj1cXFwic2hvd0NoZWNrYm94XFxcIlxcbiAgICA+PC91aS1pY29uPlxcbjwvbGk+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3RcXFwiIDppZD1cXFwiaWRcXFwiIDpjbGFzcz1cXFwie1xcbiAgICAgICAgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdpbnZhbGlkJzogIXZhbGlkLCAnZGlydHknOiBkaXJ0eSwgJ2FjdGl2ZSc6IGFjdGl2ZSxcXG4gICAgICAgICdoYXMtbGFiZWwnOiAhaGlkZUxhYmVsLCAnaWNvbi1yaWdodCc6IGljb25SaWdodFxcbiAgICB9XFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWljb24td3JhcHBlclxcXCIgdi1pZj1cXFwic2hvd0ljb25cXFwiPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtaWNvblxcXCI+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbGFiZWxcXFwiIDp0YWJpbmRleD1cXFwiZGlzYWJsZWQgPyBudWxsIDogJzAnXFxcIiB2LWVsOmxhYmVsXFxuICAgICAgICAgICAgQGZvY3VzPVxcXCJmb2N1c1xcXCIgQGtleWRvd24udGFiPVxcXCJibHVyXFxcIiBAY2xpY2s9XFxcInRvZ2dsZVxcXCIgQGtleWRvd24uc3BhY2UucHJldmVudD1cXFwib3BlblxcXCJcXG4gICAgICAgICAgICBAa2V5ZG93bi5lbnRlci5wcmV2ZW50PVxcXCJvcGVuXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1sYWJlbC10ZXh0XFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtZGlzcGxheVxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3QtdmFsdWVcXFwiIDpjbGFzcz1cXFwieyBwbGFjZWhvbGRlcjogIWhhc0Rpc3BsYXlUZXh0IH1cXFwiXFxuICAgICAgICAgICAgICAgICAgICB2LXRleHQ9XFxcImhhc0Rpc3BsYXlUZXh0ID8gZGlzcGxheVRleHQgOiBwbGFjZWhvbGRlclxcXCJcXG4gICAgICAgICAgICAgICAgPjwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8dWktaWNvbiBpY29uPVxcXCJhcnJvd19kcm9wX2Rvd25cXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtZHJvcGRvd24taWNvblxcXCI+PC91aS1pY29uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXNlbGVjdC1kcm9wZG93blxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiB2LXNob3c9XFxcInNob3dEcm9wZG93blxcXCIgdi1lbDpkcm9wZG93blxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi5lc2MucHJldmVudD1cXFwiY2xvc2UoKVxcXCIgQGtleWRvd24udGFiPVxcXCJjbG9zZSgpXFxcIlxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi51cC5wcmV2ZW50PVxcXCJoaWdobGlnaHQoaGlnaGxpZ2h0ZWRJbmRleCAtIDEpXFxcIlxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi5kb3duLnByZXZlbnQ9XFxcImhpZ2hsaWdodChoaWdobGlnaHRlZEluZGV4ICsgMSlcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLmVudGVyLnByZXZlbnQuc3RvcD1cXFwic2VsZWN0SGlnaGxpZ2h0ZWQoaGlnaGxpZ2h0ZWRJbmRleCwgJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1zZWFyY2hcXFwiIHYtaWY9XFxcInNob3dTZWFyY2hcXFwiIEBjbGljay5zdG9wIEBrZXlkb3duLnNwYWNlLnN0b3A+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktc2VsZWN0LXNlYXJjaC1pbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1lbDpzZWFyY2gtaW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICA6cGxhY2Vob2xkZXI9XFxcInNlYXJjaFBsYWNlaG9sZGVyXFxcIiB2LW1vZGVsPVxcXCJxdWVyeVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiXFxuICAgICAgICAgICAgICAgICAgICA+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8dWktcHJvZ3Jlc3MtY2lyY3VsYXJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktc2VsZWN0LXNlYXJjaC1zcGlubmVyXFxcIiA6c2l6ZT1cXFwiMjRcXFwiIDpzdHJva2U9XFxcIjRcXFwiIDpzaG93PVxcXCJsb2FkaW5nXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgPjwvdWktcHJvZ3Jlc3MtY2lyY3VsYXI+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcInVpLXNlbGVjdC1vcHRpb25zXFxcIiB2LWVsOm9wdGlvbnMtbGlzdD5cXG4gICAgICAgICAgICAgICAgICAgIDx1aS1zZWxlY3Qtb3B0aW9uXFxuICAgICAgICAgICAgICAgICAgICAgICAgOm9wdGlvbj1cXFwib3B0aW9uXFxcIiA6cGFydGlhbD1cXFwicGFydGlhbFxcXCIgOnNob3ctY2hlY2tib3g9XFxcIm11bHRpcGxlXFxcIiA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgOmtleXM9XFxcImtleXNcXFwiIEBjbGljay5zdG9wLnByZXZlbnQ9XFxcInNlbGVjdChvcHRpb24sIGluZGV4KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBAbW91c2VvdmVyLnN0b3A9XFxcImhpZ2hsaWdodChpbmRleCwgdHJ1ZSlcXFwiXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgOmhpZ2hsaWdodGVkPVxcXCJoaWdobGlnaHRlZEluZGV4ID09PSBpbmRleFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICA6c2VsZWN0ZWQ9XFxcImlzU2VsZWN0ZWQob3B0aW9uKVxcXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2LWZvcj1cXFwiKGluZGV4LCBvcHRpb24pIGluIGZpbHRlcmVkT3B0aW9uc1xcXCIgdi1yZWY6b3B0aW9uc1xcbiAgICAgICAgICAgICAgICAgICAgPjwvdWktc2VsZWN0LW9wdGlvbj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktc2VsZWN0LW5vLXJlc3VsdHNcXFwiIHYtaWY9XFxcIm5vdGhpbmdGb3VuZFxcXCI+Tm8gcmVzdWx0cyBmb3VuZDwvbGk+XFxuICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1mZWVkYmFja1xcXCIgdi1pZj1cXFwic2hvd0ZlZWRiYWNrXFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zZWxlY3QtZXJyb3ItdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktc2VsZWN0LWZlZWRiYWNrLXRvZ2dsZVxcXCJcXG4gICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJ2YWxpZGF0aW9uRXJyb3JcXFwiIHYtc2hvdz1cXFwiIWhpZGVWYWxpZGF0aW9uRXJyb3JzICYmICF2YWxpZFxcXCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktc2VsZWN0LWhlbHAtdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktc2VsZWN0LWZlZWRiYWNrLXRvZ2dsZVxcXCJcXG4gICAgICAgICAgICAgICAgdi10ZXh0PVxcXCJoZWxwVGV4dFxcXCIgdi1lbHNlXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTcyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTc0KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU2xpZGVyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XHJcblx0X192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgzKVxyXG5cdG1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cclxuXHRpZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XHJcblx0aWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcclxuXHQodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0fVxyXG5cdGlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXHJcblx0ICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxyXG5cdCAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcclxuXHQgIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxyXG5cdCAgdmFyIGlkID0gXCJDOlxcXFxjb2RlXFxcXHBhY2thZ2VzXFxcXGtlZW4tdWlcXFxcc3JjXFxcXFVpU2xpZGVyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzQgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX2RyYWdnYWJpbGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzUpO1xyXG5cdFxyXG5cdHZhciBfZHJhZ2dhYmlsbHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZHJhZ2dhYmlsbHkpO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXNsaWRlcicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBuYW1lOiBTdHJpbmcsXHJcblx0ICAgICAgICB2YWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuXHQgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdGVwOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpY29uOiBTdHJpbmcsXHJcblx0ICAgICAgICBsYWJlbDogU3RyaW5nLFxyXG5cdCAgICAgICAgaGlkZUxhYmVsOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogMCxcclxuXHQgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXHJcblx0ICAgICAgICAgICAgZHJhZ2dhYmxlOiBudWxsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9LFxyXG5cdFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc2hvd0ljb246IGZ1bmN0aW9uIHNob3dJY29uKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaWNvbik7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGFzTGFiZWw6IGZ1bmN0aW9uIGhhc0xhYmVsKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhpZGVMYWJlbCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5sYWJlbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGVscy50aHVtYi5zdHlsZS5sZWZ0ID0gdGhpcy52YWx1ZSArICclJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uIGRpc2FibGVkKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmRpc2FibGUoKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5lbmFibGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLiRlbHMudGh1bWIuc3R5bGUubGVmdCA9IHRoaXMudmFsdWUgKyAnJSc7XHJcblx0XHJcblx0ICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG5ldyBfZHJhZ2dhYmlsbHkyLmRlZmF1bHQodGhpcy4kZWxzLnRodW1iLCB7XHJcblx0ICAgICAgICAgICAgY29udGFpbm1lbnQ6IHRoaXMuJGVscy5jb250YWlubWVudCxcclxuXHQgICAgICAgICAgICBheGlzOiAneCdcclxuXHQgICAgICAgIH0pO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdTdGFydCcsIHRoaXMuZHJhZ1N0YXJ0KTtcclxuXHQgICAgICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnTW92ZScsIHRoaXMuZHJhZ01vdmUpO1xyXG5cdCAgICAgICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdFbmQnLCB0aGlzLmRyYWdFbmQpO1xyXG5cdFxyXG5cdCAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kaXNhYmxlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0ICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5kcmFnZ2FibGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNsaWRlckNsaWNrOiBmdW5jdGlvbiBzbGlkZXJDbGljayhlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgc2xpZGVyUG9zaXRpb24gPSB0aGlzLiRlbHMuc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IChlLmNsaWVudFggLSBzbGlkZXJQb3NpdGlvbi5sZWZ0KSAvIHNsaWRlclBvc2l0aW9uLndpZHRoICogMTAwO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUobmV3VmFsdWUpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcy4kZWxzLnRodW1iKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLl9wb2ludGVyRG93bihlLCBlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kZWwuZm9jdXMoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGRyYWdNb3ZlOiBmdW5jdGlvbiBkcmFnTW92ZSgpIHtcclxuXHQgICAgICAgICAgICB2YXIgeCA9IHRoaXMuZHJhZ2dhYmxlLnBvc2l0aW9uLng7XHJcblx0ICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0geCAvIHRoaXMuJGVscy5zbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKiAxMDA7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZHJhZ0VuZDogZnVuY3Rpb24gZHJhZ0VuZCgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaW5jcmVtZW50OiBmdW5jdGlvbiBpbmNyZW1lbnQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IDEwMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZSArIHRoaXMuc3RlcCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGVjcmVtZW50OiBmdW5jdGlvbiBkZWNyZW1lbnQoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMudmFsdWUgLSB0aGlzLnN0ZXApO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBtb2RlcmF0ZWRWYWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChtb2RlcmF0ZWRWYWx1ZSA+PSAxMDApIHtcclxuXHQgICAgICAgICAgICAgICAgbW9kZXJhdGVkVmFsdWUgPSAxMDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChtb2RlcmF0ZWRWYWx1ZSA8PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIG1vZGVyYXRlZFZhbHVlID0gMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1vZGVyYXRlZFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUljb246IF9VaUljb24yLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTc1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXHJcblx0dmFyIGRlZmluZSA9IGZhbHNlO1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvKiFcclxuXHQgKiBEcmFnZ2FiaWxseSB2MS4yLjRcclxuXHQgKiBNYWtlIHRoYXQgc2hpeiBkcmFnZ2FibGVcclxuXHQgKiBodHRwOi8vZHJhZ2dhYmlsbHkuZGVzYW5kcm8uY29tXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XHJcblx0ICAndXNlIHN0cmljdCc7XHJcblx0XHJcblx0ICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgICAvLyBBTURcclxuXHQgICAgZGVmaW5lKCBbXHJcblx0ICAgICAgICAnY2xhc3NpZS9jbGFzc2llJyxcclxuXHQgICAgICAgICdnZXQtc3R5bGUtcHJvcGVydHkvZ2V0LXN0eWxlLXByb3BlcnR5JyxcclxuXHQgICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZScsXHJcblx0ICAgICAgICAndW5pZHJhZ2dlci91bmlkcmFnZ2VyJ1xyXG5cdCAgICAgIF0sXHJcblx0ICAgICAgZnVuY3Rpb24oIGNsYXNzaWUsIGdldFN0eWxlUHJvcGVydHksIGdldFNpemUsIFVuaWRyYWdnZXIgKSB7XHJcblx0ICAgICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBjbGFzc2llLCBnZXRTdHlsZVByb3BlcnR5LCBnZXRTaXplLCBVbmlkcmFnZ2VyICk7XHJcblx0ICAgICAgfSk7XHJcblx0ICB9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgICAvLyBDb21tb25KU1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXHJcblx0ICAgICAgd2luZG93LFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTc2KSxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NyksXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxNzgpLFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTc5KVxyXG5cdCAgICApO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgICAgd2luZG93LkRyYWdnYWJpbGx5ID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgd2luZG93LmNsYXNzaWUsXHJcblx0ICAgICAgd2luZG93LmdldFN0eWxlUHJvcGVydHksXHJcblx0ICAgICAgd2luZG93LmdldFNpemUsXHJcblx0ICAgICAgd2luZG93LlVuaWRyYWdnZXJcclxuXHQgICAgKTtcclxuXHQgIH1cclxuXHRcclxuXHR9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgY2xhc3NpZSwgZ2V0U3R5bGVQcm9wZXJ0eSwgZ2V0U2l6ZSwgVW5pZHJhZ2dlciApIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0Ly8gdmFyc1xyXG5cdHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcclxuXHRcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0Ly8gZXh0ZW5kIG9iamVjdHNcclxuXHRmdW5jdGlvbiBleHRlbmQoIGEsIGIgKSB7XHJcblx0ICBmb3IgKCB2YXIgcHJvcCBpbiBiICkge1xyXG5cdCAgICBhWyBwcm9wIF0gPSBiWyBwcm9wIF07XHJcblx0ICB9XHJcblx0ICByZXR1cm4gYTtcclxuXHR9XHJcblx0XHJcblx0Ly8gLS0tLS0gZ2V0IHN0eWxlIC0tLS0tIC8vXHJcblx0XHJcblx0dmFyIGRlZlZpZXcgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcclxuXHRcclxuXHR2YXIgZ2V0U3R5bGUgPSBkZWZWaWV3ICYmIGRlZlZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSA/XHJcblx0ICBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgICAgcmV0dXJuIGRlZlZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApO1xyXG5cdCAgfSA6XHJcblx0ICBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgICAgcmV0dXJuIGVsZW0uY3VycmVudFN0eWxlO1xyXG5cdCAgfTtcclxuXHRcclxuXHRcclxuXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zODQzODAvMTgyMTgzXHJcblx0dmFyIGlzRWxlbWVudCA9ICggdHlwZW9mIEhUTUxFbGVtZW50ID09ICdvYmplY3QnICkgP1xyXG5cdCAgZnVuY3Rpb24gaXNFbGVtZW50RE9NMiggb2JqICkge1xyXG5cdCAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcblx0ICB9IDpcclxuXHQgIGZ1bmN0aW9uIGlzRWxlbWVudFF1aXJreSggb2JqICkge1xyXG5cdCAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgJiZcclxuXHQgICAgICBvYmoubm9kZVR5cGUgPT0gMSAmJiB0eXBlb2Ygb2JqLm5vZGVOYW1lID09ICdzdHJpbmcnO1xyXG5cdCAgfTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xODY2NDc0XHJcblx0XHJcblx0dmFyIGxhc3RUaW1lID0gMDtcclxuXHR2YXIgcHJlZml4ZXMgPSAnd2Via2l0IG1veiBtcyBvJy5zcGxpdCgnICcpO1xyXG5cdC8vIGdldCB1bnByZWZpeGVkIHJBRiBhbmQgY0FGLCBpZiBwcmVzZW50XHJcblx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblx0dmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG5cdC8vIGxvb3AgdGhyb3VnaCB2ZW5kb3IgcHJlZml4ZXMgYW5kIGdldCBwcmVmaXhlZCByQUYgYW5kIGNBRlxyXG5cdHZhciBwcmVmaXg7XHJcblx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKyApIHtcclxuXHQgIGlmICggcmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lICkge1xyXG5cdCAgICBicmVhaztcclxuXHQgIH1cclxuXHQgIHByZWZpeCA9IHByZWZpeGVzW2ldO1xyXG5cdCAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvd1sgcHJlZml4ICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcclxuXHQgIGNhbmNlbEFuaW1hdGlvbkZyYW1lICA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lICB8fCB3aW5kb3dbIHByZWZpeCArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dbIHByZWZpeCArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XHJcblx0fVxyXG5cdFxyXG5cdC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXQgYW5kIGNsZWFyVGltZW91dCBpZiBlaXRoZXIgcmVxdWVzdC9jYW5jZWwgaXMgbm90IHN1cHBvcnRlZFxyXG5cdGlmICggIXJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSAge1xyXG5cdCAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xyXG5cdCAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHQgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xyXG5cdCAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgY2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xyXG5cdCAgICB9LCB0aW1lVG9DYWxsICk7XHJcblx0ICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdCAgICByZXR1cm4gaWQ7XHJcblx0ICB9O1xyXG5cdFxyXG5cdCAgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggaWQgKSB7XHJcblx0ICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoIGlkICk7XHJcblx0ICB9O1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzdXBwb3J0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0dmFyIHRyYW5zZm9ybVByb3BlcnR5ID0gZ2V0U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XHJcblx0Ly8gVE9ETyBmaXggcXVpY2sgJiBkaXJ0eSBjaGVjayBmb3IgM0Qgc3VwcG9ydFxyXG5cdHZhciBpczNkID0gISFnZXRTdHlsZVByb3BlcnR5KCdwZXJzcGVjdGl2ZScpO1xyXG5cdFxyXG5cdHZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdGZ1bmN0aW9uIERyYWdnYWJpbGx5KCBlbGVtZW50LCBvcHRpb25zICkge1xyXG5cdCAgLy8gcXVlcnlTZWxlY3RvciBpZiBzdHJpbmdcclxuXHQgIHRoaXMuZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID9cclxuXHQgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbWVudCApIDogZWxlbWVudDtcclxuXHRcclxuXHQgIGlmICggalF1ZXJ5ICkge1xyXG5cdCAgICB0aGlzLiRlbGVtZW50ID0galF1ZXJ5KCB0aGlzLmVsZW1lbnQgKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIC8vIG9wdGlvbnNcclxuXHQgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCgge30sIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHMgKTtcclxuXHQgIHRoaXMub3B0aW9uKCBvcHRpb25zICk7XHJcblx0XHJcblx0ICB0aGlzLl9jcmVhdGUoKTtcclxuXHR9XHJcblx0XHJcblx0Ly8gaW5oZXJpdCBVbmlkcmFnZ2VyIG1ldGhvZHNcclxuXHRleHRlbmQoIERyYWdnYWJpbGx5LnByb3RvdHlwZSwgVW5pZHJhZ2dlci5wcm90b3R5cGUgKTtcclxuXHRcclxuXHREcmFnZ2FiaWxseS5kZWZhdWx0cyA9IHtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHNldCBvcHRpb25zXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24oIG9wdHMgKSB7XHJcblx0ICBleHRlbmQoIHRoaXMub3B0aW9ucywgb3B0cyApO1xyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRcclxuXHQgIC8vIHByb3BlcnRpZXNcclxuXHQgIHRoaXMucG9zaXRpb24gPSB7fTtcclxuXHQgIHRoaXMuX2dldFBvc2l0aW9uKCk7XHJcblx0XHJcblx0ICB0aGlzLnN0YXJ0UG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHQgIHRoaXMuZHJhZ1BvaW50ID0geyB4OiAwLCB5OiAwIH07XHJcblx0XHJcblx0ICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBleHRlbmQoIHt9LCB0aGlzLnBvc2l0aW9uICk7XHJcblx0XHJcblx0ICAvLyBzZXQgcmVsYXRpdmUgcG9zaXRpb25pbmdcclxuXHQgIHZhciBzdHlsZSA9IGdldFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcclxuXHQgIGlmICggc3R5bGUucG9zaXRpb24gIT0gJ3JlbGF0aXZlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPSAnYWJzb2x1dGUnICkge1xyXG5cdCAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdGhpcy5lbmFibGUoKTtcclxuXHQgIHRoaXMuc2V0SGFuZGxlcygpO1xyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogc2V0IHRoaXMuaGFuZGxlcyBhbmQgYmluZCBzdGFydCBldmVudHMgdG8gJ2VtXHJcblx0ICovXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnNldEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuaGFuZGxlcyA9IHRoaXMub3B0aW9ucy5oYW5kbGUgP1xyXG5cdCAgICB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggdGhpcy5vcHRpb25zLmhhbmRsZSApIDogWyB0aGlzLmVsZW1lbnQgXTtcclxuXHRcclxuXHQgIHRoaXMuYmluZEhhbmRsZXMoKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGVtaXRzIGV2ZW50cyB2aWEgZXZlbnRFbWl0dGVyIGFuZCBqUXVlcnkgZXZlbnRzXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBuYW1lIG9mIGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBvcmlnaW5hbCBldmVudFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBleHRyYSBhcmd1bWVudHNcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgYXJncyApIHtcclxuXHQgIHZhciBlbWl0QXJncyA9IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKTtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCB0eXBlLCBlbWl0QXJncyApO1xyXG5cdCAgdmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XHJcblx0ICAvLyB0cmlnZ2VyIGpRdWVyeSBldmVudFxyXG5cdCAgaWYgKCBqUXVlcnkgJiYgdGhpcy4kZWxlbWVudCApIHtcclxuXHQgICAgaWYgKCBldmVudCApIHtcclxuXHQgICAgICAvLyBjcmVhdGUgalF1ZXJ5IGV2ZW50XHJcblx0ICAgICAgdmFyICRldmVudCA9IGpRdWVyeS5FdmVudCggZXZlbnQgKTtcclxuXHQgICAgICAkZXZlbnQudHlwZSA9IHR5cGU7XHJcblx0ICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCAkZXZlbnQsIGFyZ3MgKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAvLyBqdXN0IHRyaWdnZXIgd2l0aCB0eXBlIGlmIG5vIGV2ZW50IGF2YWlsYWJsZVxyXG5cdCAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggdHlwZSwgYXJncyApO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwb3NpdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdC8vIGdldCBsZWZ0L3RvcCBwb3NpdGlvbiBmcm9tIHN0eWxlXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLl9nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgLy8gcHJvcGVydGllc1xyXG5cdCAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIHRoaXMuZWxlbWVudCApO1xyXG5cdFxyXG5cdCAgdmFyIHggPSBwYXJzZUludCggc3R5bGUubGVmdCwgMTAgKTtcclxuXHQgIHZhciB5ID0gcGFyc2VJbnQoIHN0eWxlLnRvcCwgMTAgKTtcclxuXHRcclxuXHQgIC8vIGNsZWFuIHVwICdhdXRvJyBvciBvdGhlciBub24taW50ZWdlciB2YWx1ZXNcclxuXHQgIHRoaXMucG9zaXRpb24ueCA9IGlzTmFOKCB4ICkgPyAwIDogeDtcclxuXHQgIHRoaXMucG9zaXRpb24ueSA9IGlzTmFOKCB5ICkgPyAwIDogeTtcclxuXHRcclxuXHQgIHRoaXMuX2FkZFRyYW5zZm9ybVBvc2l0aW9uKCBzdHlsZSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gYWRkIHRyYW5zZm9ybTogdHJhbnNsYXRlKCB4LCB5ICkgdG8gcG9zaXRpb25cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuX2FkZFRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24oIHN0eWxlICkge1xyXG5cdCAgaWYgKCAhdHJhbnNmb3JtUHJvcGVydHkgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIHZhciB0cmFuc2Zvcm0gPSBzdHlsZVsgdHJhbnNmb3JtUHJvcGVydHkgXTtcclxuXHQgIC8vIGJhaWwgb3V0IGlmIHZhbHVlIGlzICdub25lJ1xyXG5cdCAgaWYgKCB0cmFuc2Zvcm0uaW5kZXhPZignbWF0cml4JykgIT09IDAgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIC8vIHNwbGl0IG1hdHJpeCgxLCAwLCAwLCAxLCB4LCB5KVxyXG5cdCAgdmFyIG1hdHJpeFZhbHVlcyA9IHRyYW5zZm9ybS5zcGxpdCgnLCcpO1xyXG5cdCAgLy8gdHJhbnNsYXRlIFggdmFsdWUgaXMgaW4gMTJ0aCBvciA0dGggcG9zaXRpb25cclxuXHQgIHZhciB4SW5kZXggPSB0cmFuc2Zvcm0uaW5kZXhPZignbWF0cml4M2QnKSA9PT0gMCA/IDEyIDogNDtcclxuXHQgIHZhciB0cmFuc2xhdGVYID0gcGFyc2VJbnQoIG1hdHJpeFZhbHVlc1sgeEluZGV4IF0sIDEwICk7XHJcblx0ICAvLyB0cmFuc2xhdGUgWSB2YWx1ZSBpcyBpbiAxM3RoIG9yIDV0aCBwb3NpdGlvblxyXG5cdCAgdmFyIHRyYW5zbGF0ZVkgPSBwYXJzZUludCggbWF0cml4VmFsdWVzWyB4SW5kZXggKyAxIF0sIDEwICk7XHJcblx0ICB0aGlzLnBvc2l0aW9uLnggKz0gdHJhbnNsYXRlWDtcclxuXHQgIHRoaXMucG9zaXRpb24ueSArPSB0cmFuc2xhdGVZO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0LyoqXHJcblx0ICogcG9pbnRlciBzdGFydFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuX2RyYWdQb2ludGVyRG93biggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIC8vIGtsdWRnZSB0byBibHVyIGZvY3VzZWQgaW5wdXRzIGluIGRyYWdnZXJcclxuXHQgIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuXHQgIGlmICggZm9jdXNlZCAmJiBmb2N1c2VkLmJsdXIgKSB7XHJcblx0ICAgIGZvY3VzZWQuYmx1cigpO1xyXG5cdCAgfVxyXG5cdCAgLy8gYmluZCBtb3ZlIGFuZCBlbmQgZXZlbnRzXHJcblx0ICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xyXG5cdCAgY2xhc3NpZS5hZGQoIHRoaXMuZWxlbWVudCwgJ2lzLXBvaW50ZXItZG93bicgKTtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3BvaW50ZXJEb3duJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBkcmFnIG1vdmVcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB2YXIgbW92ZVZlY3RvciA9IHRoaXMuX2RyYWdQb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3BvaW50ZXJNb3ZlJywgZXZlbnQsIFsgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XHJcblx0ICB0aGlzLl9kcmFnTW92ZSggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIGRyYWcgc3RhcnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIHRoaXMuX2dldFBvc2l0aW9uKCk7XHJcblx0ICB0aGlzLm1lYXN1cmVDb250YWlubWVudCgpO1xyXG5cdCAgLy8gcG9zaXRpb24gX3doZW5fIGRyYWcgYmVnYW5cclxuXHQgIHRoaXMuc3RhcnRQb3NpdGlvbi54ID0gdGhpcy5wb3NpdGlvbi54O1xyXG5cdCAgdGhpcy5zdGFydFBvc2l0aW9uLnkgPSB0aGlzLnBvc2l0aW9uLnk7XHJcblx0ICAvLyByZXNldCBsZWZ0L3RvcCBzdHlsZVxyXG5cdCAgdGhpcy5zZXRMZWZ0VG9wKCk7XHJcblx0XHJcblx0ICB0aGlzLmRyYWdQb2ludC54ID0gMDtcclxuXHQgIHRoaXMuZHJhZ1BvaW50LnkgPSAwO1xyXG5cdFxyXG5cdCAgLy8gcmVzZXQgaXNEcmFnZ2luZyBmbGFnXHJcblx0ICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG5cdCAgY2xhc3NpZS5hZGQoIHRoaXMuZWxlbWVudCwgJ2lzLWRyYWdnaW5nJyApO1xyXG5cdCAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ1N0YXJ0JywgZXZlbnQsIFsgcG9pbnRlciBdICk7XHJcblx0ICAvLyBzdGFydCBhbmltYXRpb25cclxuXHQgIHRoaXMuYW5pbWF0ZSgpO1xyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLm1lYXN1cmVDb250YWlubWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdmFyIGNvbnRhaW5tZW50ID0gdGhpcy5vcHRpb25zLmNvbnRhaW5tZW50O1xyXG5cdCAgaWYgKCAhY29udGFpbm1lbnQgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHRcclxuXHQgIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xyXG5cdCAgdmFyIGVsZW1SZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFxyXG5cdCAgLy8gdXNlIGVsZW1lbnQgaWYgZWxlbWVudFxyXG5cdCAgdmFyIGNvbnRhaW5lciA9IGlzRWxlbWVudCggY29udGFpbm1lbnQgKSA/IGNvbnRhaW5tZW50IDpcclxuXHQgICAgLy8gZmFsbGJhY2sgdG8gcXVlcnlTZWxlY3RvciBpZiBzdHJpbmdcclxuXHQgICAgdHlwZW9mIGNvbnRhaW5tZW50ID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggY29udGFpbm1lbnQgKSA6XHJcblx0ICAgIC8vIG90aGVyd2lzZSBqdXN0IGB0cnVlYCwgdXNlIHRoZSBwYXJlbnRcclxuXHQgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XHJcblx0XHJcblx0ICB0aGlzLmNvbnRhaW5lclNpemUgPSBnZXRTaXplKCBjb250YWluZXIgKTtcclxuXHQgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFxyXG5cdCAgdGhpcy5yZWxhdGl2ZVN0YXJ0UG9zaXRpb24gPSB7XHJcblx0ICAgIHg6IGVsZW1SZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQsXHJcblx0ICAgIHk6IGVsZW1SZWN0LnRvcCAgLSBjb250YWluZXJSZWN0LnRvcFxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHQvKipcclxuXHQgKiBkcmFnIG1vdmVcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XHJcblx0ICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdCAgdmFyIGRyYWdYID0gbW92ZVZlY3Rvci54O1xyXG5cdCAgdmFyIGRyYWdZID0gbW92ZVZlY3Rvci55O1xyXG5cdFxyXG5cdCAgdmFyIGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcclxuXHQgIHZhciBncmlkWCA9IGdyaWQgJiYgZ3JpZFswXTtcclxuXHQgIHZhciBncmlkWSA9IGdyaWQgJiYgZ3JpZFsxXTtcclxuXHRcclxuXHQgIGRyYWdYID0gYXBwbHlHcmlkKCBkcmFnWCwgZ3JpZFggKTtcclxuXHQgIGRyYWdZID0gYXBwbHlHcmlkKCBkcmFnWSwgZ3JpZFkgKTtcclxuXHRcclxuXHQgIGRyYWdYID0gdGhpcy5jb250YWluRHJhZyggJ3gnLCBkcmFnWCwgZ3JpZFggKTtcclxuXHQgIGRyYWdZID0gdGhpcy5jb250YWluRHJhZyggJ3knLCBkcmFnWSwgZ3JpZFkgKTtcclxuXHRcclxuXHQgIC8vIGNvbnN0cmFpbiB0byBheGlzXHJcblx0ICBkcmFnWCA9IHRoaXMub3B0aW9ucy5heGlzID09ICd5JyA/IDAgOiBkcmFnWDtcclxuXHQgIGRyYWdZID0gdGhpcy5vcHRpb25zLmF4aXMgPT0gJ3gnID8gMCA6IGRyYWdZO1xyXG5cdFxyXG5cdCAgdGhpcy5wb3NpdGlvbi54ID0gdGhpcy5zdGFydFBvc2l0aW9uLnggKyBkcmFnWDtcclxuXHQgIHRoaXMucG9zaXRpb24ueSA9IHRoaXMuc3RhcnRQb3NpdGlvbi55ICsgZHJhZ1k7XHJcblx0ICAvLyBzZXQgZHJhZ1BvaW50IHByb3BlcnRpZXNcclxuXHQgIHRoaXMuZHJhZ1BvaW50LnggPSBkcmFnWDtcclxuXHQgIHRoaXMuZHJhZ1BvaW50LnkgPSBkcmFnWTtcclxuXHRcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdNb3ZlJywgZXZlbnQsIFsgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XHJcblx0fTtcclxuXHRcclxuXHRmdW5jdGlvbiBhcHBseUdyaWQoIHZhbHVlLCBncmlkLCBtZXRob2QgKSB7XHJcblx0ICBtZXRob2QgPSBtZXRob2QgfHwgJ3JvdW5kJztcclxuXHQgIHJldHVybiBncmlkID8gTWF0aFsgbWV0aG9kIF0oIHZhbHVlIC8gZ3JpZCApICogZ3JpZCA6IHZhbHVlO1xyXG5cdH1cclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuY29udGFpbkRyYWcgPSBmdW5jdGlvbiggYXhpcywgZHJhZywgZ3JpZCApIHtcclxuXHQgIGlmICggIXRoaXMub3B0aW9ucy5jb250YWlubWVudCApIHtcclxuXHQgICAgcmV0dXJuIGRyYWc7XHJcblx0ICB9XHJcblx0ICB2YXIgbWVhc3VyZSA9IGF4aXMgPT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xyXG5cdFxyXG5cdCAgdmFyIHJlbCA9IHRoaXMucmVsYXRpdmVTdGFydFBvc2l0aW9uWyBheGlzIF07XHJcblx0ICB2YXIgbWluID0gYXBwbHlHcmlkKCAtcmVsLCBncmlkLCAnY2VpbCcgKTtcclxuXHQgIHZhciBtYXggPSB0aGlzLmNvbnRhaW5lclNpemVbIG1lYXN1cmUgXSAtIHJlbCAtIHRoaXMuc2l6ZVsgbWVhc3VyZSBdO1xyXG5cdCAgbWF4ID0gYXBwbHlHcmlkKCBtYXgsIGdyaWQsICdmbG9vcicgKTtcclxuXHQgIHJldHVybiAgTWF0aC5taW4oIG1heCwgTWF0aC5tYXgoIG1pbiwgZHJhZyApICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHQvKipcclxuXHQgKiBwb2ludGVyIHVwXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIGNsYXNzaWUucmVtb3ZlKCB0aGlzLmVsZW1lbnQsICdpcy1wb2ludGVyLWRvd24nICk7XHJcblx0ICB0aGlzLmRpc3BhdGNoRXZlbnQoICdwb2ludGVyVXAnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcclxuXHQgIHRoaXMuX2RyYWdQb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBkcmFnIGVuZFxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqL1xyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cdCAgLy8gdXNlIHRvcCBsZWZ0IHBvc2l0aW9uIHdoZW4gY29tcGxldGVcclxuXHQgIGlmICggdHJhbnNmb3JtUHJvcGVydHkgKSB7XHJcblx0ICAgIHRoaXMuZWxlbWVudC5zdHlsZVsgdHJhbnNmb3JtUHJvcGVydHkgXSA9ICcnO1xyXG5cdCAgICB0aGlzLnNldExlZnRUb3AoKTtcclxuXHQgIH1cclxuXHQgIGNsYXNzaWUucmVtb3ZlKCB0aGlzLmVsZW1lbnQsICdpcy1kcmFnZ2luZycgKTtcclxuXHQgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdFbmQnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGFuaW1hdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0ICAvLyBvbmx5IHJlbmRlciBhbmQgYW5pbWF0ZSBpZiBkcmFnZ2luZ1xyXG5cdCAgaWYgKCAhdGhpcy5pc0RyYWdnaW5nICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0XHJcblx0ICB0aGlzLnBvc2l0aW9uRHJhZygpO1xyXG5cdFxyXG5cdCAgdmFyIF90aGlzID0gdGhpcztcclxuXHQgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24gYW5pbWF0ZUZyYW1lKCkge1xyXG5cdCAgICBfdGhpcy5hbmltYXRlKCk7XHJcblx0ICB9KTtcclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHRyYW5zZm9ybSB0cmFuc2xhdGUgZnVuY3Rpb25cclxuXHR2YXIgdHJhbnNsYXRlID0gaXMzZCA/XHJcblx0ICBmdW5jdGlvbiggeCwgeSApIHtcclxuXHQgICAgcmV0dXJuICd0cmFuc2xhdGUzZCggJyArIHggKyAncHgsICcgKyB5ICsgJ3B4LCAwKSc7XHJcblx0ICB9IDpcclxuXHQgIGZ1bmN0aW9uKCB4LCB5ICkge1xyXG5cdCAgICByZXR1cm4gJ3RyYW5zbGF0ZSggJyArIHggKyAncHgsICcgKyB5ICsgJ3B4KSc7XHJcblx0ICB9O1xyXG5cdFxyXG5cdC8vIGxlZnQvdG9wIHBvc2l0aW9uaW5nXHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLnNldExlZnRUb3AgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi54ICsgJ3B4JztcclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgID0gdGhpcy5wb3NpdGlvbi55ICsgJ3B4JztcclxuXHR9O1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5wb3NpdGlvbkRyYWcgPSB0cmFuc2Zvcm1Qcm9wZXJ0eSA/XHJcblx0ICBmdW5jdGlvbigpIHtcclxuXHQgICAgLy8gcG9zaXRpb24gd2l0aCB0cmFuc2Zvcm1cclxuXHQgICAgdGhpcy5lbGVtZW50LnN0eWxlWyB0cmFuc2Zvcm1Qcm9wZXJ0eSBdID0gdHJhbnNsYXRlKCB0aGlzLmRyYWdQb2ludC54LCB0aGlzLmRyYWdQb2ludC55ICk7XHJcblx0ICB9IDogRHJhZ2dhYmlsbHkucHJvdG90eXBlLnNldExlZnRUb3A7XHJcblx0XHJcblx0Ly8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cclxuXHRcclxuXHREcmFnZ2FiaWxseS5wcm90b3R5cGUuc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmRpc3BhdGNoRXZlbnQoICdzdGF0aWNDbGljaycsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gbWV0aG9kcyAtLS0tLSAvL1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0ICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xyXG5cdCAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XHJcblx0ICAgIHRoaXMuZHJhZ0VuZCgpO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0RHJhZ2dhYmlsbHkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuZGlzYWJsZSgpO1xyXG5cdCAgLy8gcmVzZXQgc3R5bGVzXHJcblx0ICBpZiAoIHRyYW5zZm9ybVByb3BlcnR5ICkge1xyXG5cdCAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIHRyYW5zZm9ybVByb3BlcnR5IF0gPSAnJztcclxuXHQgIH1cclxuXHQgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gJyc7XHJcblx0ICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gJyc7XHJcblx0ICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnJztcclxuXHQgIC8vIHVuYmluZCBoYW5kbGVzXHJcblx0ICB0aGlzLnVuYmluZEhhbmRsZXMoKTtcclxuXHQgIC8vIHJlbW92ZSBqUXVlcnkgZGF0YVxyXG5cdCAgaWYgKCB0aGlzLiRlbGVtZW50ICkge1xyXG5cdCAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ2RyYWdnYWJpbGx5Jyk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBqUXVlcnkgYnJpZGdldCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8vIHJlcXVpcmVkIGZvciBqUXVlcnkgYnJpZGdldFxyXG5cdERyYWdnYWJpbGx5LnByb3RvdHlwZS5faW5pdCA9IG5vb3A7XHJcblx0XHJcblx0aWYgKCBqUXVlcnkgJiYgalF1ZXJ5LmJyaWRnZXQgKSB7XHJcblx0ICBqUXVlcnkuYnJpZGdldCggJ2RyYWdnYWJpbGx5JywgRHJhZ2dhYmlsbHkgKTtcclxuXHR9XHJcblx0XHJcblx0Ly8gLS0tLS0gIC0tLS0tIC8vXHJcblx0XHJcblx0cmV0dXJuIERyYWdnYWJpbGx5O1xyXG5cdFxyXG5cdH0pKTtcclxuXHRcclxuXHR9LmNhbGwod2luZG93KSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIGNsYXNzaWUgdjEuMC4xXHJcblx0ICogY2xhc3MgaGVscGVyIGZ1bmN0aW9uc1xyXG5cdCAqIGZyb20gYm9uem8gaHR0cHM6Ly9naXRodWIuY29tL2RlZC9ib256b1xyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICogXHJcblx0ICogY2xhc3NpZS5oYXMoIGVsZW0sICdteS1jbGFzcycgKSAtPiB0cnVlL2ZhbHNlXHJcblx0ICogY2xhc3NpZS5hZGQoIGVsZW0sICdteS1uZXctY2xhc3MnIClcclxuXHQgKiBjbGFzc2llLnJlbW92ZSggZWxlbSwgJ215LXVud2FudGVkLWNsYXNzJyApXHJcblx0ICogY2xhc3NpZS50b2dnbGUoIGVsZW0sICdteS1jbGFzcycgKVxyXG5cdCAqL1xyXG5cdFxyXG5cdC8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG5cdC8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIG1vZHVsZTogZmFsc2UgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XHJcblx0XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdC8vIGNsYXNzIGhlbHBlciBmdW5jdGlvbnMgZnJvbSBib256byBodHRwczovL2dpdGh1Yi5jb20vZGVkL2JvbnpvXHJcblx0XHJcblx0ZnVuY3Rpb24gY2xhc3NSZWcoIGNsYXNzTmFtZSApIHtcclxuXHQgIHJldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHMrKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHMrfCQpXCIpO1xyXG5cdH1cclxuXHRcclxuXHQvLyBjbGFzc0xpc3Qgc3VwcG9ydCBmb3IgY2xhc3MgbWFuYWdlbWVudFxyXG5cdC8vIGFsdGhvIHRvIGJlIGZhaXIsIHRoZSBhcGkgc3Vja3MgYmVjYXVzZSBpdCB3b24ndCBhY2NlcHQgbXVsdGlwbGUgY2xhc3NlcyBhdCBvbmNlXHJcblx0dmFyIGhhc0NsYXNzLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3M7XHJcblx0XHJcblx0aWYgKCAnY2xhc3NMaXN0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XHJcblx0ICBoYXNDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoIGMgKTtcclxuXHQgIH07XHJcblx0ICBhZGRDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICBlbGVtLmNsYXNzTGlzdC5hZGQoIGMgKTtcclxuXHQgIH07XHJcblx0ICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoIGMgKTtcclxuXHQgIH07XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdCAgaGFzQ2xhc3MgPSBmdW5jdGlvbiggZWxlbSwgYyApIHtcclxuXHQgICAgcmV0dXJuIGNsYXNzUmVnKCBjICkudGVzdCggZWxlbS5jbGFzc05hbWUgKTtcclxuXHQgIH07XHJcblx0ICBhZGRDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG5cdCAgICBpZiAoICFoYXNDbGFzcyggZWxlbSwgYyApICkge1xyXG5cdCAgICAgIGVsZW0uY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUgKyAnICcgKyBjO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdCAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiggZWxlbSwgYyApIHtcclxuXHQgICAgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5yZXBsYWNlKCBjbGFzc1JlZyggYyApLCAnICcgKTtcclxuXHQgIH07XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKCBlbGVtLCBjICkge1xyXG5cdCAgdmFyIGZuID0gaGFzQ2xhc3MoIGVsZW0sIGMgKSA/IHJlbW92ZUNsYXNzIDogYWRkQ2xhc3M7XHJcblx0ICBmbiggZWxlbSwgYyApO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgY2xhc3NpZSA9IHtcclxuXHQgIC8vIGZ1bGwgbmFtZXNcclxuXHQgIGhhc0NsYXNzOiBoYXNDbGFzcyxcclxuXHQgIGFkZENsYXNzOiBhZGRDbGFzcyxcclxuXHQgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcclxuXHQgIHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcclxuXHQgIC8vIHNob3J0IG5hbWVzXHJcblx0ICBoYXM6IGhhc0NsYXNzLFxyXG5cdCAgYWRkOiBhZGRDbGFzcyxcclxuXHQgIHJlbW92ZTogcmVtb3ZlQ2xhc3MsXHJcblx0ICB0b2dnbGU6IHRvZ2dsZUNsYXNzXHJcblx0fTtcclxuXHRcclxuXHQvLyB0cmFuc3BvcnRcclxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHQgIC8vIEFNRFxyXG5cdCAgZGVmaW5lKCBjbGFzc2llICk7XHJcblx0fSBlbHNlIGlmICggdHJ1ZSApIHtcclxuXHQgIC8vIENvbW1vbkpTXHJcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGNsYXNzaWU7XHJcblx0fSBlbHNlIHtcclxuXHQgIC8vIGJyb3dzZXIgZ2xvYmFsXHJcblx0ICB3aW5kb3cuY2xhc3NpZSA9IGNsYXNzaWU7XHJcblx0fVxyXG5cdFxyXG5cdH0pKCB3aW5kb3cgKTtcclxuXHRcclxuXHR9LmNhbGwod2luZG93KSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNzcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIGdldFN0eWxlUHJvcGVydHkgdjEuMC40XHJcblx0ICogb3JpZ2luYWwgYnkga2FuZ2F4XHJcblx0ICogaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vZmVhdHVyZS10ZXN0aW5nLWNzcy1wcm9wZXJ0aWVzL1xyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSAqL1xyXG5cdC8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIGV4cG9ydHM6IGZhbHNlLCBtb2R1bGU6IGZhbHNlICovXHJcblx0XHJcblx0KCBmdW5jdGlvbiggd2luZG93ICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHR2YXIgcHJlZml4ZXMgPSAnV2Via2l0IE1veiBtcyBNcyBPJy5zcGxpdCgnICcpO1xyXG5cdHZhciBkb2NFbGVtU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0U3R5bGVQcm9wZXJ0eSggcHJvcE5hbWUgKSB7XHJcblx0ICBpZiAoICFwcm9wTmFtZSApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gdGVzdCBzdGFuZGFyZCBwcm9wZXJ0eSBmaXJzdFxyXG5cdCAgaWYgKCB0eXBlb2YgZG9jRWxlbVN0eWxlWyBwcm9wTmFtZSBdID09PSAnc3RyaW5nJyApIHtcclxuXHQgICAgcmV0dXJuIHByb3BOYW1lO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gY2FwaXRhbGl6ZVxyXG5cdCAgcHJvcE5hbWUgPSBwcm9wTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BOYW1lLnNsaWNlKDEpO1xyXG5cdFxyXG5cdCAgLy8gdGVzdCB2ZW5kb3Igc3BlY2lmaWMgcHJvcGVydGllc1xyXG5cdCAgdmFyIHByZWZpeGVkO1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gcHJlZml4ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0ICAgIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBwcm9wTmFtZTtcclxuXHQgICAgaWYgKCB0eXBlb2YgZG9jRWxlbVN0eWxlWyBwcmVmaXhlZCBdID09PSAnc3RyaW5nJyApIHtcclxuXHQgICAgICByZXR1cm4gcHJlZml4ZWQ7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9XHJcblx0XHJcblx0Ly8gdHJhbnNwb3J0XHJcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblx0ICAvLyBBTURcclxuXHQgIGRlZmluZSggZnVuY3Rpb24oKSB7XHJcblx0ICAgIHJldHVybiBnZXRTdHlsZVByb3BlcnR5O1xyXG5cdCAgfSk7XHJcblx0fSBlbHNlIGlmICggdHJ1ZSApIHtcclxuXHQgIC8vIENvbW1vbkpTIGZvciBDb21wb25lbnRcclxuXHQgIG1vZHVsZS5leHBvcnRzID0gZ2V0U3R5bGVQcm9wZXJ0eTtcclxuXHR9IGVsc2Uge1xyXG5cdCAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgIHdpbmRvdy5nZXRTdHlsZVByb3BlcnR5ID0gZ2V0U3R5bGVQcm9wZXJ0eTtcclxuXHR9XHJcblx0XHJcblx0fSkoIHdpbmRvdyApO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3OCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogZ2V0U2l6ZSB2MS4yLjJcclxuXHQgKiBtZWFzdXJlIHNpemUgb2YgZWxlbWVudHNcclxuXHQgKiBNSVQgbGljZW5zZVxyXG5cdCAqL1xyXG5cdFxyXG5cdC8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG5cdC8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIGV4cG9ydHM6IGZhbHNlLCByZXF1aXJlOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cclxuXHRcclxuXHQoIGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdC8vIGdldCBhIG51bWJlciBmcm9tIGEgc3RyaW5nLCBub3QgYSBwZXJjZW50YWdlXHJcblx0ZnVuY3Rpb24gZ2V0U3R5bGVTaXplKCB2YWx1ZSApIHtcclxuXHQgIHZhciBudW0gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xyXG5cdCAgLy8gbm90IGEgcGVyY2VudCBsaWtlICcxMDAlJywgYW5kIGEgbnVtYmVyXHJcblx0ICB2YXIgaXNWYWxpZCA9IHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gLTEgJiYgIWlzTmFOKCBudW0gKTtcclxuXHQgIHJldHVybiBpc1ZhbGlkICYmIG51bTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XHJcblx0XHJcblx0dmFyIGxvZ0Vycm9yID0gdHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnID8gbm9vcCA6XHJcblx0ICBmdW5jdGlvbiggbWVzc2FnZSApIHtcclxuXHQgICAgY29uc29sZS5lcnJvciggbWVzc2FnZSApO1xyXG5cdCAgfTtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZWFzdXJlbWVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHR2YXIgbWVhc3VyZW1lbnRzID0gW1xyXG5cdCAgJ3BhZGRpbmdMZWZ0JyxcclxuXHQgICdwYWRkaW5nUmlnaHQnLFxyXG5cdCAgJ3BhZGRpbmdUb3AnLFxyXG5cdCAgJ3BhZGRpbmdCb3R0b20nLFxyXG5cdCAgJ21hcmdpbkxlZnQnLFxyXG5cdCAgJ21hcmdpblJpZ2h0JyxcclxuXHQgICdtYXJnaW5Ub3AnLFxyXG5cdCAgJ21hcmdpbkJvdHRvbScsXHJcblx0ICAnYm9yZGVyTGVmdFdpZHRoJyxcclxuXHQgICdib3JkZXJSaWdodFdpZHRoJyxcclxuXHQgICdib3JkZXJUb3BXaWR0aCcsXHJcblx0ICAnYm9yZGVyQm90dG9tV2lkdGgnXHJcblx0XTtcclxuXHRcclxuXHRmdW5jdGlvbiBnZXRaZXJvU2l6ZSgpIHtcclxuXHQgIHZhciBzaXplID0ge1xyXG5cdCAgICB3aWR0aDogMCxcclxuXHQgICAgaGVpZ2h0OiAwLFxyXG5cdCAgICBpbm5lcldpZHRoOiAwLFxyXG5cdCAgICBpbm5lckhlaWdodDogMCxcclxuXHQgICAgb3V0ZXJXaWR0aDogMCxcclxuXHQgICAgb3V0ZXJIZWlnaHQ6IDBcclxuXHQgIH07XHJcblx0ICBmb3IgKCB2YXIgaT0wLCBsZW4gPSBtZWFzdXJlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0ICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcclxuXHQgICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9IDA7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gc2l6ZTtcclxuXHR9XHJcblx0XHJcblx0XHJcblx0XHJcblx0ZnVuY3Rpb24gZGVmaW5lR2V0U2l6ZSggZ2V0U3R5bGVQcm9wZXJ0eSApIHtcclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzZXR1cCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdHZhciBpc1NldHVwID0gZmFsc2U7XHJcblx0XHJcblx0dmFyIGdldFN0eWxlLCBib3hTaXppbmdQcm9wLCBpc0JveFNpemVPdXRlcjtcclxuXHRcclxuXHQvKipcclxuXHQgKiBzZXR1cCB2YXJzIGFuZCBmdW5jdGlvbnNcclxuXHQgKiBkbyBpdCBvbiBpbml0aWFsIGdldFNpemUoKSwgcmF0aGVyIHRoYW4gb24gc2NyaXB0IGxvYWRcclxuXHQgKiBGb3IgRmlyZWZveCBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gc2V0dXAoKSB7XHJcblx0ICAvLyBzZXR1cCBvbmNlXHJcblx0ICBpZiAoIGlzU2V0dXAgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIGlzU2V0dXAgPSB0cnVlO1xyXG5cdFxyXG5cdCAgdmFyIGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZTtcclxuXHQgIGdldFN0eWxlID0gKCBmdW5jdGlvbigpIHtcclxuXHQgICAgdmFyIGdldFN0eWxlRm4gPSBnZXRDb21wdXRlZFN0eWxlID9cclxuXHQgICAgICBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQgICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XHJcblx0ICAgICAgfSA6XHJcblx0ICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0ICAgICAgICByZXR1cm4gZWxlbS5jdXJyZW50U3R5bGU7XHJcblx0ICAgICAgfTtcclxuXHRcclxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0U3R5bGUoIGVsZW0gKSB7XHJcblx0ICAgICAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZUZuKCBlbGVtICk7XHJcblx0ICAgICAgICBpZiAoICFzdHlsZSApIHtcclxuXHQgICAgICAgICAgbG9nRXJyb3IoICdTdHlsZSByZXR1cm5lZCAnICsgc3R5bGUgK1xyXG5cdCAgICAgICAgICAgICcuIEFyZSB5b3UgcnVubmluZyB0aGlzIGNvZGUgaW4gYSBoaWRkZW4gaWZyYW1lIG9uIEZpcmVmb3g/ICcgK1xyXG5cdCAgICAgICAgICAgICdTZWUgaHR0cDovL2JpdC5seS9nZXRzaXplYnVnMScgKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdHlsZTtcclxuXHQgICAgICB9O1xyXG5cdCAgfSkoKTtcclxuXHRcclxuXHQgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGJveCBzaXppbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHRcclxuXHQgIGJveFNpemluZ1Byb3AgPSBnZXRTdHlsZVByb3BlcnR5KCdib3hTaXppbmcnKTtcclxuXHRcclxuXHQgIC8qKlxyXG5cdCAgICogV2ViS2l0IG1lYXN1cmVzIHRoZSBvdXRlci13aWR0aCBvbiBzdHlsZS53aWR0aCBvbiBib3JkZXItYm94IGVsZW1zXHJcblx0ICAgKiBJRSAmIEZpcmVmb3ggbWVhc3VyZXMgdGhlIGlubmVyLXdpZHRoXHJcblx0ICAgKi9cclxuXHQgIGlmICggYm94U2l6aW5nUHJvcCApIHtcclxuXHQgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdCAgICBkaXYuc3R5bGUud2lkdGggPSAnMjAwcHgnO1xyXG5cdCAgICBkaXYuc3R5bGUucGFkZGluZyA9ICcxcHggMnB4IDNweCA0cHgnO1xyXG5cdCAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xyXG5cdCAgICBkaXYuc3R5bGUuYm9yZGVyV2lkdGggPSAnMXB4IDJweCAzcHggNHB4JztcclxuXHQgICAgZGl2LnN0eWxlWyBib3hTaXppbmdQcm9wIF0gPSAnYm9yZGVyLWJveCc7XHJcblx0XHJcblx0ICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0ICAgIGJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xyXG5cdCAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZGl2ICk7XHJcblx0XHJcblx0ICAgIGlzQm94U2l6ZU91dGVyID0gZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApID09PSAyMDA7XHJcblx0ICAgIGJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXRTaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0ZnVuY3Rpb24gZ2V0U2l6ZSggZWxlbSApIHtcclxuXHQgIHNldHVwKCk7XHJcblx0XHJcblx0ICAvLyB1c2UgcXVlcnlTZWxldG9yIGlmIGVsZW0gaXMgc3RyaW5nXHJcblx0ICBpZiAoIHR5cGVvZiBlbGVtID09PSAnc3RyaW5nJyApIHtcclxuXHQgICAgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW0gKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIC8vIGRvIG5vdCBwcm9jZWVkIG9uIG5vbi1vYmplY3RzXHJcblx0ICBpZiAoICFlbGVtIHx8IHR5cGVvZiBlbGVtICE9PSAnb2JqZWN0JyB8fCAhZWxlbS5ub2RlVHlwZSApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGVsZW0gKTtcclxuXHRcclxuXHQgIC8vIGlmIGhpZGRlbiwgZXZlcnl0aGluZyBpcyAwXHJcblx0ICBpZiAoIHN0eWxlLmRpc3BsYXkgPT09ICdub25lJyApIHtcclxuXHQgICAgcmV0dXJuIGdldFplcm9TaXplKCk7XHJcblx0ICB9XHJcblx0XHJcblx0ICB2YXIgc2l6ZSA9IHt9O1xyXG5cdCAgc2l6ZS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XHJcblx0ICBzaXplLmhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xyXG5cdFxyXG5cdCAgdmFyIGlzQm9yZGVyQm94ID0gc2l6ZS5pc0JvcmRlckJveCA9ICEhKCBib3hTaXppbmdQcm9wICYmXHJcblx0ICAgIHN0eWxlWyBib3hTaXppbmdQcm9wIF0gJiYgc3R5bGVbIGJveFNpemluZ1Byb3AgXSA9PT0gJ2JvcmRlci1ib3gnICk7XHJcblx0XHJcblx0ICAvLyBnZXQgYWxsIG1lYXN1cmVtZW50c1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdCAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XHJcblx0ICAgIHZhciB2YWx1ZSA9IHN0eWxlWyBtZWFzdXJlbWVudCBdO1xyXG5cdCAgICB2YWx1ZSA9IG11bmdlTm9uUGl4ZWwoIGVsZW0sIHZhbHVlICk7XHJcblx0ICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xyXG5cdCAgICAvLyBhbnkgJ2F1dG8nLCAnbWVkaXVtJyB2YWx1ZSB3aWxsIGJlIDBcclxuXHQgICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9ICFpc05hTiggbnVtICkgPyBudW0gOiAwO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIHBhZGRpbmdXaWR0aCA9IHNpemUucGFkZGluZ0xlZnQgKyBzaXplLnBhZGRpbmdSaWdodDtcclxuXHQgIHZhciBwYWRkaW5nSGVpZ2h0ID0gc2l6ZS5wYWRkaW5nVG9wICsgc2l6ZS5wYWRkaW5nQm90dG9tO1xyXG5cdCAgdmFyIG1hcmdpbldpZHRoID0gc2l6ZS5tYXJnaW5MZWZ0ICsgc2l6ZS5tYXJnaW5SaWdodDtcclxuXHQgIHZhciBtYXJnaW5IZWlnaHQgPSBzaXplLm1hcmdpblRvcCArIHNpemUubWFyZ2luQm90dG9tO1xyXG5cdCAgdmFyIGJvcmRlcldpZHRoID0gc2l6ZS5ib3JkZXJMZWZ0V2lkdGggKyBzaXplLmJvcmRlclJpZ2h0V2lkdGg7XHJcblx0ICB2YXIgYm9yZGVySGVpZ2h0ID0gc2l6ZS5ib3JkZXJUb3BXaWR0aCArIHNpemUuYm9yZGVyQm90dG9tV2lkdGg7XHJcblx0XHJcblx0ICB2YXIgaXNCb3JkZXJCb3hTaXplT3V0ZXIgPSBpc0JvcmRlckJveCAmJiBpc0JveFNpemVPdXRlcjtcclxuXHRcclxuXHQgIC8vIG92ZXJ3cml0ZSB3aWR0aCBhbmQgaGVpZ2h0IGlmIHdlIGNhbiBnZXQgaXQgZnJvbSBzdHlsZVxyXG5cdCAgdmFyIHN0eWxlV2lkdGggPSBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICk7XHJcblx0ICBpZiAoIHN0eWxlV2lkdGggIT09IGZhbHNlICkge1xyXG5cdCAgICBzaXplLndpZHRoID0gc3R5bGVXaWR0aCArXHJcblx0ICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxyXG5cdCAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcclxuXHQgIH1cclxuXHRcclxuXHQgIHZhciBzdHlsZUhlaWdodCA9IGdldFN0eWxlU2l6ZSggc3R5bGUuaGVpZ2h0ICk7XHJcblx0ICBpZiAoIHN0eWxlSGVpZ2h0ICE9PSBmYWxzZSApIHtcclxuXHQgICAgc2l6ZS5oZWlnaHQgPSBzdHlsZUhlaWdodCArXHJcblx0ICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxyXG5cdCAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ0hlaWdodCArIGJvcmRlckhlaWdodCApO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgc2l6ZS5pbm5lcldpZHRoID0gc2l6ZS53aWR0aCAtICggcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcclxuXHQgIHNpemUuaW5uZXJIZWlnaHQgPSBzaXplLmhlaWdodCAtICggcGFkZGluZ0hlaWdodCArIGJvcmRlckhlaWdodCApO1xyXG5cdFxyXG5cdCAgc2l6ZS5vdXRlcldpZHRoID0gc2l6ZS53aWR0aCArIG1hcmdpbldpZHRoO1xyXG5cdCAgc2l6ZS5vdXRlckhlaWdodCA9IHNpemUuaGVpZ2h0ICsgbWFyZ2luSGVpZ2h0O1xyXG5cdFxyXG5cdCAgcmV0dXJuIHNpemU7XHJcblx0fVxyXG5cdFxyXG5cdC8vIElFOCByZXR1cm5zIHBlcmNlbnQgdmFsdWVzLCBub3QgcGl4ZWxzXHJcblx0Ly8gdGFrZW4gZnJvbSBqUXVlcnkncyBjdXJDU1NcclxuXHRmdW5jdGlvbiBtdW5nZU5vblBpeGVsKCBlbGVtLCB2YWx1ZSApIHtcclxuXHQgIC8vIElFOCBhbmQgaGFzIHBlcmNlbnQgdmFsdWVcclxuXHQgIGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgdmFsdWUuaW5kZXhPZignJScpID09PSAtMSApIHtcclxuXHQgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgfVxyXG5cdCAgdmFyIHN0eWxlID0gZWxlbS5zdHlsZTtcclxuXHQgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcclxuXHQgIHZhciBsZWZ0ID0gc3R5bGUubGVmdDtcclxuXHQgIHZhciBycyA9IGVsZW0ucnVudGltZVN0eWxlO1xyXG5cdCAgdmFyIHJzTGVmdCA9IHJzICYmIHJzLmxlZnQ7XHJcblx0XHJcblx0ICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XHJcblx0ICBpZiAoIHJzTGVmdCApIHtcclxuXHQgICAgcnMubGVmdCA9IGVsZW0uY3VycmVudFN0eWxlLmxlZnQ7XHJcblx0ICB9XHJcblx0ICBzdHlsZS5sZWZ0ID0gdmFsdWU7XHJcblx0ICB2YWx1ZSA9IHN0eWxlLnBpeGVsTGVmdDtcclxuXHRcclxuXHQgIC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcclxuXHQgIHN0eWxlLmxlZnQgPSBsZWZ0O1xyXG5cdCAgaWYgKCByc0xlZnQgKSB7XHJcblx0ICAgIHJzLmxlZnQgPSByc0xlZnQ7XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gdmFsdWU7XHJcblx0fVxyXG5cdFxyXG5cdHJldHVybiBnZXRTaXplO1xyXG5cdFxyXG5cdH1cclxuXHRcclxuXHQvLyB0cmFuc3BvcnRcclxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHQgIC8vIEFNRCBmb3IgUmVxdWlyZUpTXHJcblx0ICBkZWZpbmUoIFsgJ2dldC1zdHlsZS1wcm9wZXJ0eS9nZXQtc3R5bGUtcHJvcGVydHknIF0sIGRlZmluZUdldFNpemUgKTtcclxuXHR9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgLy8gQ29tbW9uSlMgZm9yIENvbXBvbmVudFxyXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVHZXRTaXplKCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NykgKTtcclxuXHR9IGVsc2Uge1xyXG5cdCAgLy8gYnJvd3NlciBnbG9iYWxcclxuXHQgIHdpbmRvdy5nZXRTaXplID0gZGVmaW5lR2V0U2l6ZSggd2luZG93LmdldFN0eWxlUHJvcGVydHkgKTtcclxuXHR9XHJcblx0XHJcblx0fSkoIHdpbmRvdyApO1xyXG5cdFxyXG5cdH0uY2FsbCh3aW5kb3cpKTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE3OSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xyXG5cdHZhciBkZWZpbmUgPSBmYWxzZTtcclxuXHQoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0LyohXHJcblx0ICogVW5pZHJhZ2dlciB2MS4xLjVcclxuXHQgKiBEcmFnZ2FibGUgYmFzZSBjbGFzc1xyXG5cdCAqIE1JVCBsaWNlbnNlXHJcblx0ICovXHJcblx0XHJcblx0Lypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW51c2VkOiB0cnVlLCB1bmRlZjogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXHJcblx0XHJcblx0KCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xyXG5cdCAgLypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSwgcmVxdWlyZTogZmFsc2UgKi9cclxuXHQgICd1c2Ugc3RyaWN0JztcclxuXHQgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxyXG5cdFxyXG5cdCAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHQgICAgLy8gQU1EXHJcblx0ICAgIGRlZmluZSggW1xyXG5cdCAgICAgICdldmVudGllL2V2ZW50aWUnLFxyXG5cdCAgICAgICd1bmlwb2ludGVyL3VuaXBvaW50ZXInXHJcblx0ICAgIF0sIGZ1bmN0aW9uKCBldmVudGllLCBVbmlwb2ludGVyICkge1xyXG5cdCAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGV2ZW50aWUsIFVuaXBvaW50ZXIgKTtcclxuXHQgICAgfSk7XHJcblx0ICB9IGVsc2UgaWYgKCB0cnVlICkge1xyXG5cdCAgICAvLyBDb21tb25KU1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXHJcblx0ICAgICAgd2luZG93LFxyXG5cdCAgICAgIF9fd2VicGFja19yZXF1aXJlX18oMTgwKSxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MSlcclxuXHQgICAgKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIC8vIGJyb3dzZXIgZ2xvYmFsXHJcblx0ICAgIHdpbmRvdy5VbmlkcmFnZ2VyID0gZmFjdG9yeShcclxuXHQgICAgICB3aW5kb3csXHJcblx0ICAgICAgd2luZG93LmV2ZW50aWUsXHJcblx0ICAgICAgd2luZG93LlVuaXBvaW50ZXJcclxuXHQgICAgKTtcclxuXHQgIH1cclxuXHRcclxuXHR9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgZXZlbnRpZSwgVW5pcG9pbnRlciApIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0Ly8gLS0tLS0gIC0tLS0tIC8vXHJcblx0XHJcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XHJcblx0XHJcblx0Ly8gaGFuZGxlIElFOCBwcmV2ZW50IGRlZmF1bHRcclxuXHRmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdEV2ZW50KCBldmVudCApIHtcclxuXHQgIGlmICggZXZlbnQucHJldmVudERlZmF1bHQgKSB7XHJcblx0ICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdCAgfVxyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVbmlkcmFnZ2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblx0XHJcblx0ZnVuY3Rpb24gVW5pZHJhZ2dlcigpIHt9XHJcblx0XHJcblx0Ly8gaW5oZXJpdCBVbmlwb2ludGVyICYgRXZlbnRFbWl0dGVyXHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUgPSBuZXcgVW5pcG9pbnRlcigpO1xyXG5cdFxyXG5cdC8vIC0tLS0tIGJpbmQgc3RhcnQgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgdGhpcy5fYmluZEhhbmRsZXMoIHRydWUgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnVuYmluZEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuXHQgIHRoaXMuX2JpbmRIYW5kbGVzKCBmYWxzZSApO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XHJcblx0LyoqXHJcblx0ICogd29ya3MgYXMgdW5iaW5kZXIsIGFzIHlvdSBjYW4gLmJpbmRIYW5kbGVzKCBmYWxzZSApIHRvIHVuYmluZFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5kIC0gd2lsbCB1bmJpbmQgaWYgZmFsc2V5XHJcblx0ICovXHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2JpbmRIYW5kbGVzID0gZnVuY3Rpb24oIGlzQmluZCApIHtcclxuXHQgIC8vIG11bmdlIGlzQmluZCwgZGVmYXVsdCB0byB0cnVlXHJcblx0ICBpc0JpbmQgPSBpc0JpbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWlzQmluZDtcclxuXHQgIC8vIGV4dHJhIGJpbmQgbG9naWNcclxuXHQgIHZhciBiaW5kZXJFeHRyYTtcclxuXHQgIGlmICggbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICkge1xyXG5cdCAgICBiaW5kZXJFeHRyYSA9IGZ1bmN0aW9uKCBoYW5kbGUgKSB7XHJcblx0ICAgICAgLy8gZGlzYWJsZSBzY3JvbGxpbmcgb24gdGhlIGVsZW1lbnRcclxuXHQgICAgICBoYW5kbGUuc3R5bGUudG91Y2hBY3Rpb24gPSBpc0JpbmQgPyAnbm9uZScgOiAnJztcclxuXHQgICAgfTtcclxuXHQgIH0gZWxzZSBpZiAoIG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkICkge1xyXG5cdCAgICBiaW5kZXJFeHRyYSA9IGZ1bmN0aW9uKCBoYW5kbGUgKSB7XHJcblx0ICAgICAgLy8gZGlzYWJsZSBzY3JvbGxpbmcgb24gdGhlIGVsZW1lbnRcclxuXHQgICAgICBoYW5kbGUuc3R5bGUubXNUb3VjaEFjdGlvbiA9IGlzQmluZCA/ICdub25lJyA6ICcnO1xyXG5cdCAgICB9O1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgYmluZGVyRXh0cmEgPSBmdW5jdGlvbigpIHtcclxuXHQgICAgICAvLyBUT0RPIHJlLWVuYWJsZSBpbWcub25kcmFnc3RhcnQgd2hlbiB1bmJpbmRpbmdcclxuXHQgICAgICBpZiAoIGlzQmluZCApIHtcclxuXHQgICAgICAgIGRpc2FibGVJbWdPbmRyYWdzdGFydCggaGFuZGxlICk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgfVxyXG5cdCAgLy8gYmluZCBlYWNoIGhhbmRsZVxyXG5cdCAgdmFyIGJpbmRNZXRob2QgPSBpc0JpbmQgPyAnYmluZCcgOiAndW5iaW5kJztcclxuXHQgIGZvciAoIHZhciBpPTAsIGxlbiA9IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIGhhbmRsZSA9IHRoaXMuaGFuZGxlc1tpXTtcclxuXHQgICAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIGhhbmRsZSwgaXNCaW5kICk7XHJcblx0ICAgIGJpbmRlckV4dHJhKCBoYW5kbGUgKTtcclxuXHQgICAgZXZlbnRpZVsgYmluZE1ldGhvZCBdKCBoYW5kbGUsICdjbGljaycsIHRoaXMgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIHJlbW92ZSBkZWZhdWx0IGRyYWdnaW5nIGludGVyYWN0aW9uIG9uIGFsbCBpbWFnZXMgaW4gSUU4XHJcblx0Ly8gSUU4IGRvZXMgaXRzIG93biBkcmFnIHRoaW5nIG9uIGltYWdlcywgd2hpY2ggbWVzc2VzIHN0dWZmIHVwXHJcblx0XHJcblx0ZnVuY3Rpb24gbm9EcmFnU3RhcnQoKSB7XHJcblx0ICByZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFRPRE8gcmVwbGFjZSB0aGlzIHdpdGggYSBJRTggdGVzdFxyXG5cdHZhciBpc0lFOCA9ICdhdHRhY2hFdmVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cdFxyXG5cdC8vIElFOCBvbmx5XHJcblx0dmFyIGRpc2FibGVJbWdPbmRyYWdzdGFydCA9ICFpc0lFOCA/IG5vb3AgOiBmdW5jdGlvbiggaGFuZGxlICkge1xyXG5cdFxyXG5cdCAgaWYgKCBoYW5kbGUubm9kZU5hbWUgPT0gJ0lNRycgKSB7XHJcblx0ICAgIGhhbmRsZS5vbmRyYWdzdGFydCA9IG5vRHJhZ1N0YXJ0O1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgdmFyIGltYWdlcyA9IGhhbmRsZS5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTtcclxuXHQgIGZvciAoIHZhciBpPTAsIGxlbiA9IGltYWdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIGltZyA9IGltYWdlc1tpXTtcclxuXHQgICAgaW1nLm9uZHJhZ3N0YXJ0ID0gbm9EcmFnU3RhcnQ7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgc3RhcnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIC8vIGRpc21pc3MgcmFuZ2Ugc2xpZGVyc1xyXG5cdCAgaWYgKCBldmVudC50YXJnZXQubm9kZU5hbWUgPT0gJ0lOUFVUJyAmJiBldmVudC50YXJnZXQudHlwZSA9PSAncmFuZ2UnICkge1xyXG5cdCAgICAvLyByZXNldCBwb2ludGVyRG93biBsb2dpY1xyXG5cdCAgICB0aGlzLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcclxuXHQgICAgZGVsZXRlIHRoaXMucG9pbnRlcklkZW50aWZpZXI7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHRcclxuXHQgIHRoaXMuX2RyYWdQb2ludGVyRG93biggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIC8vIGtsdWRnZSB0byBibHVyIGZvY3VzZWQgaW5wdXRzIGluIGRyYWdnZXJcclxuXHQgIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuXHQgIGlmICggZm9jdXNlZCAmJiBmb2N1c2VkLmJsdXIgKSB7XHJcblx0ICAgIGZvY3VzZWQuYmx1cigpO1xyXG5cdCAgfVxyXG5cdCAgLy8gYmluZCBtb3ZlIGFuZCBlbmQgZXZlbnRzXHJcblx0ICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xyXG5cdCAgLy8gdHJhY2sgc2Nyb2xsaW5nXHJcblx0ICB0aGlzLnBvaW50ZXJEb3duU2Nyb2xsID0gVW5pZHJhZ2dlci5nZXRTY3JvbGxQb3NpdGlvbigpO1xyXG5cdCAgZXZlbnRpZS5iaW5kKCB3aW5kb3csICdzY3JvbGwnLCB0aGlzICk7XHJcblx0XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJEb3duJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBiYXNlIHBvaW50ZXIgZG93biBsb2dpY1xyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnUG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICAvLyB0cmFjayB0byBzZWUgd2hlbiBkcmFnZ2luZyBzdGFydHNcclxuXHQgIHRoaXMucG9pbnRlckRvd25Qb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50KCBwb2ludGVyICk7XHJcblx0XHJcblx0ICAvLyBwcmV2ZW50IGRlZmF1bHQsIHVubGVzcyB0b3VjaHN0YXJ0IG9yIDxzZWxlY3Q+XHJcblx0ICB2YXIgaXNUb3VjaHN0YXJ0ID0gZXZlbnQudHlwZSA9PSAndG91Y2hzdGFydCc7XHJcblx0ICB2YXIgdGFyZ2V0Tm9kZU5hbWUgPSBldmVudC50YXJnZXQubm9kZU5hbWU7XHJcblx0ICBpZiAoICFpc1RvdWNoc3RhcnQgJiYgdGFyZ2V0Tm9kZU5hbWUgIT0gJ1NFTEVDVCcgKSB7XHJcblx0ICAgIHByZXZlbnREZWZhdWx0RXZlbnQoIGV2ZW50ICk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0LyoqXHJcblx0ICogZHJhZyBtb3ZlXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB2YXIgbW92ZVZlY3RvciA9IHRoaXMuX2RyYWdQb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcclxuXHQgIHRoaXMuX2RyYWdNb3ZlKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gYmFzZSBwb2ludGVyIG1vdmUgbG9naWNcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5fZHJhZ1BvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdmFyIG1vdmVQb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50KCBwb2ludGVyICk7XHJcblx0ICB2YXIgbW92ZVZlY3RvciA9IHtcclxuXHQgICAgeDogbW92ZVBvaW50LnggLSB0aGlzLnBvaW50ZXJEb3duUG9pbnQueCxcclxuXHQgICAgeTogbW92ZVBvaW50LnkgLSB0aGlzLnBvaW50ZXJEb3duUG9pbnQueVxyXG5cdCAgfTtcclxuXHQgIC8vIHN0YXJ0IGRyYWcgaWYgcG9pbnRlciBoYXMgbW92ZWQgZmFyIGVub3VnaCB0byBzdGFydCBkcmFnXHJcblx0ICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5oYXNEcmFnU3RhcnRlZCggbW92ZVZlY3RvciApICkge1xyXG5cdCAgICB0aGlzLl9kcmFnU3RhcnQoIGV2ZW50LCBwb2ludGVyICk7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gbW92ZVZlY3RvcjtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIGNvbmRpdGlvbiBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5oYXNEcmFnU3RhcnRlZCA9IGZ1bmN0aW9uKCBtb3ZlVmVjdG9yICkge1xyXG5cdCAgcmV0dXJuIE1hdGguYWJzKCBtb3ZlVmVjdG9yLnggKSA+IDMgfHwgTWF0aC5hYnMoIG1vdmVWZWN0b3IueSApID4gMztcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdC8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgdXBcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKi9cclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJVcCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdCAgdGhpcy5fZHJhZ1BvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnUG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XHJcblx0ICAgIHRoaXMuX2RyYWdFbmQoIGV2ZW50LCBwb2ludGVyICk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICAvLyBwb2ludGVyIGRpZG4ndCBtb3ZlIGVub3VnaCBmb3IgZHJhZyB0byBzdGFydFxyXG5cdCAgICB0aGlzLl9zdGF0aWNDbGljayggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJEb25lID0gZnVuY3Rpb24oKSB7XHJcblx0ICBldmVudGllLnVuYmluZCggd2luZG93LCAnc2Nyb2xsJywgdGhpcyApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZHJhZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cdFxyXG5cdC8vIGRyYWdTdGFydFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9kcmFnU3RhcnQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG5cdCAgdGhpcy5kcmFnU3RhcnRQb2ludCA9IFVuaWRyYWdnZXIuZ2V0UG9pbnRlclBvaW50KCBwb2ludGVyICk7XHJcblx0ICAvLyBwcmV2ZW50IGNsaWNrc1xyXG5cdCAgdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgPSB0cnVlO1xyXG5cdFxyXG5cdCAgdGhpcy5kcmFnU3RhcnQoIGV2ZW50LCBwb2ludGVyICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ2RyYWdTdGFydCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gZHJhZ01vdmVcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5fZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XHJcblx0ICAvLyBkbyBub3QgZHJhZyBpZiBub3QgZHJhZ2dpbmcgeWV0XHJcblx0ICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHRcclxuXHQgIHRoaXMuZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcclxuXHQgIHByZXZlbnREZWZhdWx0RXZlbnQoIGV2ZW50ICk7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ2RyYWdNb3ZlJywgWyBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBkcmFnRW5kXHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUuX2RyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICAvLyBzZXQgZmxhZ3NcclxuXHQgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cdCAgLy8gcmUtZW5hYmxlIGNsaWNraW5nIGFzeW5jXHJcblx0ICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdCAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0ICAgIGRlbGV0ZSBfdGhpcy5pc1ByZXZlbnRpbmdDbGlja3M7XHJcblx0ICB9KTtcclxuXHRcclxuXHQgIHRoaXMuZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ2RyYWdFbmQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnBvaW50ZXJEb25lID0gZnVuY3Rpb24oKSB7XHJcblx0ICBldmVudGllLnVuYmluZCggd2luZG93LCAnc2Nyb2xsJywgdGhpcyApO1xyXG5cdCAgZGVsZXRlIHRoaXMucG9pbnRlckRvd25TY3JvbGw7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBvbmNsaWNrIC0tLS0tIC8vXHJcblx0XHJcblx0Ly8gaGFuZGxlIGFsbCBjbGlja3MgYW5kIHByZXZlbnQgY2xpY2tzIHdoZW4gZHJhZ2dpbmdcclxuXHRVbmlkcmFnZ2VyLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCB0aGlzLmlzUHJldmVudGluZ0NsaWNrcyApIHtcclxuXHQgICAgcHJldmVudERlZmF1bHRFdmVudCggZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIHN0YXRpY0NsaWNrIC0tLS0tIC8vXHJcblx0XHJcblx0Ly8gdHJpZ2dlcmVkIGFmdGVyIHBvaW50ZXIgZG93biAmIHVwIHdpdGggbm8vdGlueSBtb3ZlbWVudFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLl9zdGF0aWNDbGljayA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIC8vIGlnbm9yZSBlbXVsYXRlZCBtb3VzZSB1cCBjbGlja3NcclxuXHQgIGlmICggdGhpcy5pc0lnbm9yaW5nTW91c2VVcCAmJiBldmVudC50eXBlID09ICdtb3VzZXVwJyApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgLy8gYWxsb3cgY2xpY2sgaW4gPGlucHV0PnMgYW5kIDx0ZXh0YXJlYT5zXHJcblx0ICB2YXIgbm9kZU5hbWUgPSBldmVudC50YXJnZXQubm9kZU5hbWU7XHJcblx0ICBpZiAoIG5vZGVOYW1lID09ICdJTlBVVCcgfHwgbm9kZU5hbWUgPT0gJ1RFWFRBUkVBJyApIHtcclxuXHQgICAgZXZlbnQudGFyZ2V0LmZvY3VzKCk7XHJcblx0ICB9XHJcblx0ICB0aGlzLnN0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xyXG5cdFxyXG5cdCAgLy8gc2V0IGZsYWcgZm9yIGVtdWxhdGVkIGNsaWNrcyAzMDBtcyBhZnRlciB0b3VjaGVuZFxyXG5cdCAgaWYgKCBldmVudC50eXBlICE9ICdtb3VzZXVwJyApIHtcclxuXHQgICAgdGhpcy5pc0lnbm9yaW5nTW91c2VVcCA9IHRydWU7XHJcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICAgIC8vIHJlc2V0IGZsYWcgYWZ0ZXIgMzAwbXNcclxuXHQgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgZGVsZXRlIF90aGlzLmlzSWdub3JpbmdNb3VzZVVwO1xyXG5cdCAgICB9LCA0MDAgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdFVuaWRyYWdnZXIucHJvdG90eXBlLnN0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoICdzdGF0aWNDbGljaycsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gc2Nyb2xsIC0tLS0tIC8vXHJcblx0XHJcblx0VW5pZHJhZ2dlci5wcm90b3R5cGUub25zY3JvbGwgPSBmdW5jdGlvbigpIHtcclxuXHQgIHZhciBzY3JvbGwgPSBVbmlkcmFnZ2VyLmdldFNjcm9sbFBvc2l0aW9uKCk7XHJcblx0ICB2YXIgc2Nyb2xsTW92ZVggPSB0aGlzLnBvaW50ZXJEb3duU2Nyb2xsLnggLSBzY3JvbGwueDtcclxuXHQgIHZhciBzY3JvbGxNb3ZlWSA9IHRoaXMucG9pbnRlckRvd25TY3JvbGwueSAtIHNjcm9sbC55O1xyXG5cdCAgLy8gY2FuY2VsIGNsaWNrL3RhcCBpZiBzY3JvbGwgaXMgdG9vIG11Y2hcclxuXHQgIGlmICggTWF0aC5hYnMoIHNjcm9sbE1vdmVYICkgPiAzIHx8IE1hdGguYWJzKCBzY3JvbGxNb3ZlWSApID4gMyApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlckRvbmUoKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIHV0aWxzIC0tLS0tIC8vXHJcblx0XHJcblx0VW5pZHJhZ2dlci5nZXRQb2ludGVyUG9pbnQgPSBmdW5jdGlvbiggcG9pbnRlciApIHtcclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHg6IHBvaW50ZXIucGFnZVggIT09IHVuZGVmaW5lZCA/IHBvaW50ZXIucGFnZVggOiBwb2ludGVyLmNsaWVudFgsXHJcblx0ICAgIHk6IHBvaW50ZXIucGFnZVkgIT09IHVuZGVmaW5lZCA/IHBvaW50ZXIucGFnZVkgOiBwb2ludGVyLmNsaWVudFlcclxuXHQgIH07XHJcblx0fTtcclxuXHRcclxuXHR2YXIgaXNQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XHJcblx0XHJcblx0Ly8gZ2V0IHNjcm9sbCBpbiB7IHgsIHkgfVxyXG5cdFVuaWRyYWdnZXIuZ2V0U2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHg6IGlzUGFnZU9mZnNldCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcclxuXHQgICAgeTogaXNQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BcclxuXHQgIH07XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSAgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50O1xyXG5cdFxyXG5cdHJldHVybiBVbmlkcmFnZ2VyO1xyXG5cdFxyXG5cdH0pKTtcclxuXHRcclxuXHR9LmNhbGwod2luZG93KSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIVxyXG5cdCAqIGV2ZW50aWUgdjEuMC42XHJcblx0ICogZXZlbnQgYmluZGluZyBoZWxwZXJcclxuXHQgKiAgIGV2ZW50aWUuYmluZCggZWxlbSwgJ2NsaWNrJywgbXlGbiApXHJcblx0ICogICBldmVudGllLnVuYmluZCggZWxlbSwgJ2NsaWNrJywgbXlGbiApXHJcblx0ICogTUlUIGxpY2Vuc2VcclxuXHQgKi9cclxuXHRcclxuXHQvKmpzaGludCBicm93c2VyOiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcblx0LypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSAqL1xyXG5cdFxyXG5cdCggZnVuY3Rpb24oIHdpbmRvdyApIHtcclxuXHRcclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0dmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHJcblx0dmFyIGJpbmQgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFxyXG5cdGZ1bmN0aW9uIGdldElFRXZlbnQoIG9iaiApIHtcclxuXHQgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudDtcclxuXHQgIC8vIGFkZCBldmVudC50YXJnZXRcclxuXHQgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50IHx8IG9iajtcclxuXHQgIHJldHVybiBldmVudDtcclxuXHR9XHJcblx0XHJcblx0aWYgKCBkb2NFbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XHJcblx0ICBiaW5kID0gZnVuY3Rpb24oIG9iaiwgdHlwZSwgZm4gKSB7XHJcblx0ICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBmbiwgZmFsc2UgKTtcclxuXHQgIH07XHJcblx0fSBlbHNlIGlmICggZG9jRWxlbS5hdHRhY2hFdmVudCApIHtcclxuXHQgIGJpbmQgPSBmdW5jdGlvbiggb2JqLCB0eXBlLCBmbiApIHtcclxuXHQgICAgb2JqWyB0eXBlICsgZm4gXSA9IGZuLmhhbmRsZUV2ZW50ID9cclxuXHQgICAgICBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgIHZhciBldmVudCA9IGdldElFRXZlbnQoIG9iaiApO1xyXG5cdCAgICAgICAgZm4uaGFuZGxlRXZlbnQuY2FsbCggZm4sIGV2ZW50ICk7XHJcblx0ICAgICAgfSA6XHJcblx0ICAgICAgZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICB2YXIgZXZlbnQgPSBnZXRJRUV2ZW50KCBvYmogKTtcclxuXHQgICAgICAgIGZuLmNhbGwoIG9iaiwgZXZlbnQgKTtcclxuXHQgICAgICB9O1xyXG5cdCAgICBvYmouYXR0YWNoRXZlbnQoIFwib25cIiArIHR5cGUsIG9ialsgdHlwZSArIGZuIF0gKTtcclxuXHQgIH07XHJcblx0fVxyXG5cdFxyXG5cdHZhciB1bmJpbmQgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFxyXG5cdGlmICggZG9jRWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xyXG5cdCAgdW5iaW5kID0gZnVuY3Rpb24oIG9iaiwgdHlwZSwgZm4gKSB7XHJcblx0ICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBmbiwgZmFsc2UgKTtcclxuXHQgIH07XHJcblx0fSBlbHNlIGlmICggZG9jRWxlbS5kZXRhY2hFdmVudCApIHtcclxuXHQgIHVuYmluZCA9IGZ1bmN0aW9uKCBvYmosIHR5cGUsIGZuICkge1xyXG5cdCAgICBvYmouZGV0YWNoRXZlbnQoIFwib25cIiArIHR5cGUsIG9ialsgdHlwZSArIGZuIF0gKTtcclxuXHQgICAgdHJ5IHtcclxuXHQgICAgICBkZWxldGUgb2JqWyB0eXBlICsgZm4gXTtcclxuXHQgICAgfSBjYXRjaCAoIGVyciApIHtcclxuXHQgICAgICAvLyBjYW4ndCBkZWxldGUgd2luZG93IG9iamVjdCBwcm9wZXJ0aWVzXHJcblx0ICAgICAgb2JqWyB0eXBlICsgZm4gXSA9IHVuZGVmaW5lZDtcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGV2ZW50aWUgPSB7XHJcblx0ICBiaW5kOiBiaW5kLFxyXG5cdCAgdW5iaW5kOiB1bmJpbmRcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG1vZHVsZSBkZWZpbml0aW9uIC0tLS0tIC8vXHJcblx0XHJcblx0aWYgKCB0cnVlICkge1xyXG5cdCAgLy8gQU1EXHJcblx0ICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChldmVudGllKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XHJcblx0ICAvLyBDb21tb25KU1xyXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBldmVudGllO1xyXG5cdH0gZWxzZSB7XHJcblx0ICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgd2luZG93LmV2ZW50aWUgPSBldmVudGllO1xyXG5cdH1cclxuXHRcclxuXHR9KSggd2luZG93ICk7XHJcblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTgxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXHJcblx0dmFyIGRlZmluZSA9IGZhbHNlO1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvKiFcclxuXHQgKiBVbmlwb2ludGVyIHYxLjEuMFxyXG5cdCAqIGJhc2UgY2xhc3MgZm9yIGRvaW5nIG9uZSB0aGluZyB3aXRoIHBvaW50ZXIgZXZlbnRcclxuXHQgKiBNSVQgbGljZW5zZVxyXG5cdCAqL1xyXG5cdFxyXG5cdC8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xyXG5cdC8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIG1vZHVsZTogZmFsc2UsIHJlcXVpcmU6IGZhbHNlICovXHJcblx0XHJcblx0KCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xyXG5cdCAgJ3VzZSBzdHJpY3QnO1xyXG5cdCAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXHJcblx0XHJcblx0ICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cdCAgICAvLyBBTURcclxuXHQgICAgZGVmaW5lKCBbXHJcblx0ICAgICAgJ2V2ZW50RW1pdHRlci9FdmVudEVtaXR0ZXInLFxyXG5cdCAgICAgICdldmVudGllL2V2ZW50aWUnXHJcblx0ICAgIF0sIGZ1bmN0aW9uKCBFdmVudEVtaXR0ZXIsIGV2ZW50aWUgKSB7XHJcblx0ICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZlbnRFbWl0dGVyLCBldmVudGllICk7XHJcblx0ICAgIH0pO1xyXG5cdCAgfSBlbHNlIGlmICggdHJ1ZSApIHtcclxuXHQgICAgLy8gQ29tbW9uSlNcclxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxyXG5cdCAgICAgIHdpbmRvdyxcclxuXHQgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MiksXHJcblx0ICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxODApXHJcblx0ICAgICk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICAvLyBicm93c2VyIGdsb2JhbFxyXG5cdCAgICB3aW5kb3cuVW5pcG9pbnRlciA9IGZhY3RvcnkoXHJcblx0ICAgICAgd2luZG93LFxyXG5cdCAgICAgIHdpbmRvdy5FdmVudEVtaXR0ZXIsXHJcblx0ICAgICAgd2luZG93LmV2ZW50aWVcclxuXHQgICAgKTtcclxuXHQgIH1cclxuXHRcclxuXHR9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZlbnRFbWl0dGVyLCBldmVudGllICkge1xyXG5cdFxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRcclxuXHRmdW5jdGlvbiBVbmlwb2ludGVyKCkge31cclxuXHRcclxuXHQvLyBpbmhlcml0IEV2ZW50RW1pdHRlclxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLmJpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0ICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgdHJ1ZSApO1xyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUudW5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdCAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIGVsZW0sIGZhbHNlICk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiB3b3JrcyBhcyB1bmJpbmRlciwgYXMgeW91IGNhbiAuX2JpbmRTdGFydCggZmFsc2UgKSB0byB1bmJpbmRcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluZCAtIHdpbGwgdW5iaW5kIGlmIGZhbHNleVxyXG5cdCAqL1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl9iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCBpc0JpbmQgKSB7XHJcblx0ICAvLyBtdW5nZSBpc0JpbmQsIGRlZmF1bHQgdG8gdHJ1ZVxyXG5cdCAgaXNCaW5kID0gaXNCaW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFpc0JpbmQ7XHJcblx0ICB2YXIgYmluZE1ldGhvZCA9IGlzQmluZCA/ICdiaW5kJyA6ICd1bmJpbmQnO1xyXG5cdFxyXG5cdCAgaWYgKCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICkge1xyXG5cdCAgICAvLyBXM0MgUG9pbnRlciBFdmVudHMsIElFMTEuIFNlZSBodHRwczovL2NvZGVyd2FsbC5jb20vcC9tZnJlY2FcclxuXHQgICAgZXZlbnRpZVsgYmluZE1ldGhvZCBdKCBlbGVtLCAncG9pbnRlcmRvd24nLCB0aGlzICk7XHJcblx0ICB9IGVsc2UgaWYgKCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XHJcblx0ICAgIC8vIElFMTAgUG9pbnRlciBFdmVudHNcclxuXHQgICAgZXZlbnRpZVsgYmluZE1ldGhvZCBdKCBlbGVtLCAnTVNQb2ludGVyRG93bicsIHRoaXMgKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIC8vIGxpc3RlbiBmb3IgYm90aCwgZm9yIGRldmljZXMgbGlrZSBDaHJvbWUgUGl4ZWxcclxuXHQgICAgZXZlbnRpZVsgYmluZE1ldGhvZCBdKCBlbGVtLCAnbW91c2Vkb3duJywgdGhpcyApO1xyXG5cdCAgICBldmVudGllWyBiaW5kTWV0aG9kIF0oIGVsZW0sICd0b3VjaHN0YXJ0JywgdGhpcyApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0Ly8gdHJpZ2dlciBoYW5kbGVyIG1ldGhvZHMgZm9yIGV2ZW50c1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xyXG5cdCAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcclxuXHQgICAgdGhpc1sgbWV0aG9kIF0oIGV2ZW50ICk7XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyByZXR1cm5zIHRoZSB0b3VjaCB0aGF0IHdlJ3JlIGtlZXBpbmcgdHJhY2sgb2ZcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5nZXRUb3VjaCA9IGZ1bmN0aW9uKCB0b3VjaGVzICkge1xyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcclxuXHQgICAgaWYgKCB0b3VjaC5pZGVudGlmaWVyID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XHJcblx0ICAgICAgcmV0dXJuIHRvdWNoO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgLy8gZGlzbWlzcyBjbGlja3MgZnJvbSByaWdodCBvciBtaWRkbGUgYnV0dG9uc1xyXG5cdCAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcclxuXHQgIGlmICggYnV0dG9uICYmICggYnV0dG9uICE9PSAwICYmIGJ1dHRvbiAhPT0gMSApICkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblx0ICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbk1TUG9pbnRlckRvd24gPVxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9ucG9pbnRlcmRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBwb2ludGVyIHN0YXJ0XHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICovXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX3BvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgLy8gZGlzbWlzcyBvdGhlciBwb2ludGVyc1xyXG5cdCAgaWYgKCB0aGlzLmlzUG9pbnRlckRvd24gKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHRcclxuXHQgIHRoaXMuaXNQb2ludGVyRG93biA9IHRydWU7XHJcblx0ICAvLyBzYXZlIHBvaW50ZXIgaWRlbnRpZmllciB0byBtYXRjaCB1cCB0b3VjaCBldmVudHNcclxuXHQgIHRoaXMucG9pbnRlcklkZW50aWZpZXIgPSBwb2ludGVyLnBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkID9cclxuXHQgICAgLy8gcG9pbnRlcklkIGZvciBwb2ludGVyIGV2ZW50cywgdG91Y2guaW5kZW50aWZpZXIgZm9yIHRvdWNoIGV2ZW50c1xyXG5cdCAgICBwb2ludGVyLnBvaW50ZXJJZCA6IHBvaW50ZXIuaWRlbnRpZmllcjtcclxuXHRcclxuXHQgIHRoaXMucG9pbnRlckRvd24oIGV2ZW50LCBwb2ludGVyICk7XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJEb3duJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBoYXNoIG9mIGV2ZW50cyB0byBiZSBib3VuZCBhZnRlciBzdGFydCBldmVudFxyXG5cdHZhciBwb3N0U3RhcnRFdmVudHMgPSB7XHJcblx0ICBtb3VzZWRvd246IFsgJ21vdXNlbW92ZScsICdtb3VzZXVwJyBdLFxyXG5cdCAgdG91Y2hzdGFydDogWyAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJyBdLFxyXG5cdCAgcG9pbnRlcmRvd246IFsgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVyY2FuY2VsJyBdLFxyXG5cdCAgTVNQb2ludGVyRG93bjogWyAnTVNQb2ludGVyTW92ZScsICdNU1BvaW50ZXJVcCcsICdNU1BvaW50ZXJDYW5jZWwnIF1cclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl9iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCAhZXZlbnQgKSB7XHJcblx0ICAgIHJldHVybjtcclxuXHQgIH1cclxuXHQgIC8vIGdldCBwcm9wZXIgZXZlbnRzIHRvIG1hdGNoIHN0YXJ0IGV2ZW50XHJcblx0ICB2YXIgZXZlbnRzID0gcG9zdFN0YXJ0RXZlbnRzWyBldmVudC50eXBlIF07XHJcblx0ICAvLyBJRTggbmVlZHMgdG8gYmUgYm91bmQgdG8gZG9jdW1lbnRcclxuXHQgIHZhciBub2RlID0gZXZlbnQucHJldmVudERlZmF1bHQgPyB3aW5kb3cgOiBkb2N1bWVudDtcclxuXHQgIC8vIGJpbmQgZXZlbnRzIHRvIG5vZGVcclxuXHQgIGZvciAoIHZhciBpPTAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHQgICAgdmFyIGV2bnQgPSBldmVudHNbaV07XHJcblx0ICAgIGV2ZW50aWUuYmluZCggbm9kZSwgZXZudCwgdGhpcyApO1xyXG5cdCAgfVxyXG5cdCAgLy8gc2F2ZSB0aGVzZSBhcmd1bWVudHNcclxuXHQgIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cyA9IHtcclxuXHQgICAgZXZlbnRzOiBldmVudHMsXHJcblx0ICAgIG5vZGU6IG5vZGVcclxuXHQgIH07XHJcblx0fTtcclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oKSB7XHJcblx0ICB2YXIgYXJncyA9IHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cztcclxuXHQgIC8vIElFOCBjYW4gdHJpZ2dlciBkcmFnRW5kIHR3aWNlLCBjaGVjayBmb3IgX2JvdW5kRXZlbnRzXHJcblx0ICBpZiAoICFhcmdzIHx8ICFhcmdzLmV2ZW50cyApIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgZm9yICggdmFyIGk9MCwgbGVuID0gYXJncy5ldmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0ICAgIHZhciBldmVudCA9IGFyZ3MuZXZlbnRzW2ldO1xyXG5cdCAgICBldmVudGllLnVuYmluZCggYXJncy5ub2RlLCBldmVudCwgdGhpcyApO1xyXG5cdCAgfVxyXG5cdCAgZGVsZXRlIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cclxuXHRcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9uTVNQb2ludGVyTW92ZSA9XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25wb2ludGVybW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XHJcblx0ICAgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9udG91Y2htb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdmFyIHRvdWNoID0gdGhpcy5nZXRUb3VjaCggZXZlbnQuY2hhbmdlZFRvdWNoZXMgKTtcclxuXHQgIGlmICggdG91Y2ggKSB7XHJcblx0ICAgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgdG91Y2ggKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgbW92ZVxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUuX3BvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5wb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHB1YmxpY1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLnBvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gZW5kIGV2ZW50IC0tLS0tIC8vXHJcblx0XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25tb3VzZXVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9uTVNQb2ludGVyVXAgPVxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9ucG9pbnRlcnVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdCAgaWYgKCBldmVudC5wb2ludGVySWQgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9udG91Y2hlbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0ICB2YXIgdG91Y2ggPSB0aGlzLmdldFRvdWNoKCBldmVudC5jaGFuZ2VkVG91Y2hlcyApO1xyXG5cdCAgaWYgKCB0b3VjaCApIHtcclxuXHQgICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgdG91Y2ggKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgdXBcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl9wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLl9wb2ludGVyRG9uZSgpO1xyXG5cdCAgdGhpcy5wb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBwdWJsaWNcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XHJcblx0ICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJVcCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gLS0tLS0gcG9pbnRlciBkb25lIC0tLS0tIC8vXHJcblx0XHJcblx0Ly8gdHJpZ2dlcmVkIG9uIHBvaW50ZXIgdXAgJiBwb2ludGVyIGNhbmNlbFxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLl9wb2ludGVyRG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgLy8gcmVzZXQgcHJvcGVydGllc1xyXG5cdCAgdGhpcy5pc1BvaW50ZXJEb3duID0gZmFsc2U7XHJcblx0ICBkZWxldGUgdGhpcy5wb2ludGVySWRlbnRpZmllcjtcclxuXHQgIC8vIHJlbW92ZSBldmVudHNcclxuXHQgIHRoaXMuX3VuYmluZFBvc3RTdGFydEV2ZW50cygpO1xyXG5cdCAgdGhpcy5wb2ludGVyRG9uZSgpO1xyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUucG9pbnRlckRvbmUgPSBub29wO1xyXG5cdFxyXG5cdC8vIC0tLS0tIHBvaW50ZXIgY2FuY2VsIC0tLS0tIC8vXHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub25NU1BvaW50ZXJDYW5jZWwgPVxyXG5cdFVuaXBvaW50ZXIucHJvdG90eXBlLm9ucG9pbnRlcmNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XHJcblx0ICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwoIGV2ZW50LCBldmVudCApO1xyXG5cdCAgfVxyXG5cdH07XHJcblx0XHJcblx0VW5pcG9pbnRlci5wcm90b3R5cGUub250b3VjaGNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHQgIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XHJcblx0ICBpZiAoIHRvdWNoICkge1xyXG5cdCAgICB0aGlzLl9wb2ludGVyQ2FuY2VsKCBldmVudCwgdG91Y2ggKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIHBvaW50ZXIgY2FuY2VsXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5fcG9pbnRlckNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcclxuXHQgIHRoaXMuX3BvaW50ZXJEb25lKCk7XHJcblx0ICB0aGlzLnBvaW50ZXJDYW5jZWwoIGV2ZW50LCBwb2ludGVyICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBwdWJsaWNcclxuXHRVbmlwb2ludGVyLnByb3RvdHlwZS5wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xyXG5cdCAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyQ2FuY2VsJywgWyBldmVudCwgcG9pbnRlciBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyAtLS0tLSAgLS0tLS0gLy9cclxuXHRcclxuXHQvLyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBnZXR0aW5nIHgveSBjb29yaWRpbmF0ZXMgZnJvbSBldmVudCwgYmVjYXVzZSBJRThcclxuXHRVbmlwb2ludGVyLmdldFBvaW50ZXJQb2ludCA9IGZ1bmN0aW9uKCBwb2ludGVyICkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgeDogcG9pbnRlci5wYWdlWCAhPT0gdW5kZWZpbmVkID8gcG9pbnRlci5wYWdlWCA6IHBvaW50ZXIuY2xpZW50WCxcclxuXHQgICAgeTogcG9pbnRlci5wYWdlWSAhPT0gdW5kZWZpbmVkID8gcG9pbnRlci5wYWdlWSA6IHBvaW50ZXIuY2xpZW50WVxyXG5cdCAgfTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIC0tLS0tICAtLS0tLSAvL1xyXG5cdFxyXG5cdHJldHVybiBVbmlwb2ludGVyO1xyXG5cdFxyXG5cdH0pKTtcclxuXHRcclxuXHR9LmNhbGwod2luZG93KSk7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cclxuXHR2YXIgZGVmaW5lID0gZmFsc2U7XHJcblx0KGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8qIVxyXG5cdCAqIEV2ZW50RW1pdHRlciB2NC4yLjExIC0gZ2l0LmlvL2VlXHJcblx0ICogVW5saWNlbnNlIC0gaHR0cDovL3VubGljZW5zZS5vcmcvXHJcblx0ICogT2xpdmVyIENhbGR3ZWxsIC0gaHR0cDovL29saS5tZS51ay9cclxuXHQgKiBAcHJlc2VydmVcclxuXHQgKi9cclxuXHRcclxuXHQ7KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgJ3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cy5cclxuXHQgICAgICogQ2FuIGJlIGV4dGVuZGVkIHRvIHByb3ZpZGUgZXZlbnQgZnVuY3Rpb25hbGl0eSBpbiBvdGhlciBjbGFzc2VzLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAY2xhc3MgRXZlbnRFbWl0dGVyIE1hbmFnZXMgZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGVtaXR0aW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cclxuXHRcclxuXHQgICAgLy8gU2hvcnRjdXRzIHRvIGltcHJvdmUgc3BlZWQgYW5kIHNpemVcclxuXHQgICAgdmFyIHByb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcclxuXHQgICAgdmFyIGV4cG9ydHMgPSB0aGlzO1xyXG5cdCAgICB2YXIgb3JpZ2luYWxHbG9iYWxWYWx1ZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50IGluIGl0cyBzdG9yYWdlIGFycmF5LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IGxpc3RlbmVycyBBcnJheSBvZiBsaXN0ZW5lcnMgdG8gc2VhcmNoIHRocm91Z2guXHJcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBsb29rIGZvci5cclxuXHQgICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyLCAtMSBpZiBub3QgZm91bmRcclxuXHQgICAgICogQGFwaSBwcml2YXRlXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xyXG5cdCAgICAgICAgdmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG5cdCAgICAgICAgd2hpbGUgKGktLSkge1xyXG5cdCAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiAtMTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWxpYXMgYSBtZXRob2Qgd2hpbGUga2VlcGluZyB0aGUgY29udGV4dCBjb3JyZWN0LCB0byBhbGxvdyBmb3Igb3ZlcndyaXRpbmcgb2YgdGFyZ2V0IG1ldGhvZC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhcmdldCBtZXRob2QuXHJcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgYWxpYXNlZCBtZXRob2RcclxuXHQgICAgICogQGFwaSBwcml2YXRlXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBhbGlhcyhuYW1lKSB7XHJcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gYWxpYXNDbG9zdXJlKCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgICAgICogV2lsbCBpbml0aWFsaXNlIHRoZSBldmVudCBvYmplY3QgYW5kIGxpc3RlbmVyIGFycmF5cyBpZiByZXF1aXJlZC5cclxuXHQgICAgICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxyXG5cdCAgICAgKiBFYWNoIHByb3BlcnR5IGluIHRoZSBvYmplY3QgcmVzcG9uc2UgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfE9iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgdGhlIGV2ZW50LlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xyXG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2dldEV2ZW50cygpO1xyXG5cdCAgICAgICAgdmFyIHJlc3BvbnNlO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHRcclxuXHQgICAgICAgIC8vIFJldHVybiBhIGNvbmNhdGVuYXRlZCBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgZXZlbnRzIGlmXHJcblx0ICAgICAgICAvLyB0aGUgc2VsZWN0b3IgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXHJcblx0ICAgICAgICBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcblx0ICAgICAgICAgICAgcmVzcG9uc2UgPSB7fTtcclxuXHQgICAgICAgICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2tleV0gPSBldmVudHNba2V5XTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHJlc3BvbnNlID0gZXZlbnRzW2V2dF0gfHwgKGV2ZW50c1tldnRdID0gW10pO1xyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogVGFrZXMgYSBsaXN0IG9mIGxpc3RlbmVyIG9iamVjdHMgYW5kIGZsYXR0ZW5zIGl0IGludG8gYSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtPYmplY3RbXX0gbGlzdGVuZXJzIFJhdyBsaXN0ZW5lciBvYmplY3RzLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfSBKdXN0IHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5mbGF0dGVuTGlzdGVuZXJzID0gZnVuY3Rpb24gZmxhdHRlbkxpc3RlbmVycyhsaXN0ZW5lcnMpIHtcclxuXHQgICAgICAgIHZhciBmbGF0TGlzdGVuZXJzID0gW107XHJcblx0ICAgICAgICB2YXIgaTtcclxuXHRcclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHQgICAgICAgICAgICBmbGF0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzW2ldLmxpc3RlbmVyKTtcclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiBmbGF0TGlzdGVuZXJzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogRmV0Y2hlcyB0aGUgcmVxdWVzdGVkIGxpc3RlbmVycyB2aWEgZ2V0TGlzdGVuZXJzIGJ1dCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHJlc3VsdHMgaW5zaWRlIGFuIG9iamVjdC4gVGhpcyBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSBidXQgb3RoZXJzIG1heSBmaW5kIGl0IHVzZWZ1bC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBpbiBhbiBvYmplY3QuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5nZXRMaXN0ZW5lcnNBc09iamVjdCA9IGZ1bmN0aW9uIGdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCkge1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XHJcblx0ICAgICAgICB2YXIgcmVzcG9uc2U7XHJcblx0XHJcblx0ICAgICAgICBpZiAobGlzdGVuZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHQgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xyXG5cdCAgICAgICAgICAgIHJlc3BvbnNlW2V2dF0gPSBsaXN0ZW5lcnM7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gcmVzcG9uc2UgfHwgbGlzdGVuZXJzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICAgICAqIFRoZSBsaXN0ZW5lciB3aWxsIG5vdCBiZSBhZGRlZCBpZiBpdCBpcyBhIGR1cGxpY2F0ZS5cclxuXHQgICAgICogSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBjYWxsZWQuXHJcblx0ICAgICAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcclxuXHQgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XHJcblx0ICAgICAgICB2YXIgbGlzdGVuZXJJc1dyYXBwZWQgPSB0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHRcclxuXHQgICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKSA9PT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcklzV3JhcHBlZCA/IGxpc3RlbmVyIDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBvZiBhZGRMaXN0ZW5lclxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ub24gPSBhbGlhcygnYWRkTGlzdGVuZXInKTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNlbWktYWxpYXMgb2YgYWRkTGlzdGVuZXIuIEl0IHdpbGwgYWRkIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlXHJcblx0ICAgICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciBpdHMgZmlyc3QgZXhlY3V0aW9uLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5hZGRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRPbmNlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZ0LCB7XHJcblx0ICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxyXG5cdCAgICAgICAgICAgIG9uY2U6IHRydWVcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWxpYXMgb2YgYWRkT25jZUxpc3RlbmVyLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ub25jZSA9IGFsaWFzKCdhZGRPbmNlTGlzdGVuZXInKTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIERlZmluZXMgYW4gZXZlbnQgbmFtZS4gVGhpcyBpcyByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSByZWdleCB0byBhZGQgYSBsaXN0ZW5lciB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gSWYgeW91IGRvbid0IGRvIHRoaXMgdGhlbiBob3cgZG8geW91IGV4cGVjdCBpdCB0byBrbm93IHdoYXQgZXZlbnQgdG8gYWRkIHRvPyBTaG91bGQgaXQganVzdCBhZGQgdG8gZXZlcnkgcG9zc2libGUgbWF0Y2ggZm9yIGEgcmVnZXg/IE5vLiBUaGF0IGlzIHNjYXJ5IGFuZCBiYWQuXHJcblx0ICAgICAqIFlvdSBuZWVkIHRvIHRlbGwgaXQgd2hhdCBldmVudCBuYW1lcyBzaG91bGQgYmUgbWF0Y2hlZCBieSBhIHJlZ2V4LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50KGV2dCkge1xyXG5cdCAgICAgICAgdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogVXNlcyBkZWZpbmVFdmVudCB0byBkZWZpbmUgbXVsdGlwbGUgZXZlbnRzLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBldnRzIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRlZmluZS5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5kZWZpbmVFdmVudHMgPSBmdW5jdGlvbiBkZWZpbmVFdmVudHMoZXZ0cykge1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSArPSAxKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5kZWZpbmVFdmVudChldnRzW2ldKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgICAgICogV2hlbiBwYXNzZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUsIGl0IHdpbGwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50LlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcclxuXHQgICAgICAgIHZhciBpbmRleDtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0XHJcblx0ICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcclxuXHQgICAgICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWxpYXMgb2YgcmVtb3ZlTGlzdGVuZXJcclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLm9mZiA9IGFsaWFzKCdyZW1vdmVMaXN0ZW5lcicpO1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWRkcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXHJcblx0ICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYWRkIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKiBZZWFoLCB0aGlzIGZ1bmN0aW9uIGRvZXMgcXVpdGUgYSBiaXQuIFRoYXQncyBwcm9iYWJseSBhIGJhZCB0aGluZy5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cclxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnMoZmFsc2UsIGV2dCwgbGlzdGVuZXJzKTtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFJlbW92ZXMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxyXG5cdCAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXHJcblx0ICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSByZW1vdmVkLlxyXG5cdCAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmUgdGhlIGxpc3RlbmVycyBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byByZW1vdmUuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XHJcblx0ICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyh0cnVlLCBldnQsIGxpc3RlbmVycyk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBFZGl0cyBsaXN0ZW5lcnMgaW4gYnVsay4gVGhlIGFkZExpc3RlbmVycyBhbmQgcmVtb3ZlTGlzdGVuZXJzIG1ldGhvZHMgYm90aCB1c2UgdGhpcyB0byBkbyB0aGVpciBqb2IuIFlvdSBzaG91bGQgcmVhbGx5IHVzZSB0aG9zZSBpbnN0ZWFkLCB0aGlzIGlzIGEgbGl0dGxlIGxvd2VyIGxldmVsLlxyXG5cdCAgICAgKiBUaGUgZmlyc3QgYXJndW1lbnQgd2lsbCBkZXRlcm1pbmUgaWYgdGhlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCAodHJ1ZSkgb3IgYWRkZWQgKGZhbHNlKS5cclxuXHQgICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkL3JlbW92ZWQuXHJcblx0ICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hbmlwdWxhdGUgdGhlIGxpc3RlbmVycyBvZiBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIFRydWUgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVycywgZmFsc2UgaWYgeW91IHdhbnQgdG8gYWRkLlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQvcmVtb3ZlLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLm1hbmlwdWxhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBtYW5pcHVsYXRlTGlzdGVuZXJzKHJlbW92ZSwgZXZ0LCBsaXN0ZW5lcnMpIHtcclxuXHQgICAgICAgIHZhciBpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgdmFyIHNpbmdsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyO1xyXG5cdCAgICAgICAgdmFyIG11bHRpcGxlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lcnMgOiB0aGlzLmFkZExpc3RlbmVycztcclxuXHRcclxuXHQgICAgICAgIC8vIElmIGV2dCBpcyBhbiBvYmplY3QgdGhlbiBwYXNzIGVhY2ggb2YgaXRzIHByb3BlcnRpZXMgdG8gdGhpcyBtZXRob2RcclxuXHQgICAgICAgIGlmICh0eXBlb2YgZXZ0ID09PSAnb2JqZWN0JyAmJiAhKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcclxuXHQgICAgICAgICAgICBmb3IgKGkgaW4gZXZ0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkgJiYgKHZhbHVlID0gZXZ0W2ldKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgc2luZ2xlIGxpc3RlbmVyIHN0cmFpZ2h0IHRocm91Z2ggdG8gdGhlIHNpbmd1bGFyIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXNzIGJhY2sgdG8gdGhlIG11bHRpcGxlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUuY2FsbCh0aGlzLCBpLCB2YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAvLyBTbyBldnQgbXVzdCBiZSBhIHN0cmluZ1xyXG5cdCAgICAgICAgICAgIC8vIEFuZCBsaXN0ZW5lcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBsaXN0ZW5lcnNcclxuXHQgICAgICAgICAgICAvLyBMb29wIG92ZXIgaXQgYW5kIHBhc3MgZWFjaCBvbmUgdG8gdGhlIG11bHRpcGxlIG1ldGhvZFxyXG5cdCAgICAgICAgICAgIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuXHQgICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICAgICAqIElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbiBldmVudCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAgICAgKiBUaGF0IG1lYW5zIGV2ZXJ5IGV2ZW50IHdpbGwgYmUgZW1wdGllZC5cclxuXHQgICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWdleCB0byByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IFtldnRdIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci4gV2lsbCByZW1vdmUgZnJvbSBldmVyeSBldmVudCBpZiBub3QgcGFzc2VkLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZXZ0KSB7XHJcblx0ICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBldnQ7XHJcblx0ICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdFxyXG5cdCAgICAgICAgLy8gUmVtb3ZlIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZiBldnRcclxuXHQgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XHJcblx0ICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tldnRdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIHJlZ2V4LlxyXG5cdCAgICAgICAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1trZXldO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gYWxsIGV2ZW50c1xyXG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFsaWFzIG9mIHJlbW92ZUV2ZW50LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBBZGRlZCB0byBtaXJyb3IgdGhlIG5vZGUgQVBJLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gYWxpYXMoJ3JlbW92ZUV2ZW50Jyk7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBFbWl0cyBhbiBldmVudCBvZiB5b3VyIGNob2ljZS5cclxuXHQgICAgICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXHJcblx0ICAgICAqIElmIHlvdSBwYXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBhcnJheSB0aGVuIHRob3NlIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBldmVyeSBsaXN0ZW5lciB1cG9uIGV4ZWN1dGlvbi5cclxuXHQgICAgICogQmVjYXVzZSBpdCB1c2VzIGBhcHBseWAsIHlvdXIgYXJyYXkgb2YgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIGlmIHlvdSB3cm90ZSB0aGVtIG91dCBzZXBhcmF0ZWx5LlxyXG5cdCAgICAgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXHJcblx0ICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXHJcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSBPcHRpb25hbCBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXHJcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxyXG5cdCAgICAgKi9cclxuXHQgICAgcHJvdG8uZW1pdEV2ZW50ID0gZnVuY3Rpb24gZW1pdEV2ZW50KGV2dCwgYXJncykge1xyXG5cdCAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcclxuXHQgICAgICAgIHZhciBsaXN0ZW5lcjtcclxuXHQgICAgICAgIHZhciBpO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHZhciByZXNwb25zZTtcclxuXHRcclxuXHQgICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xyXG5cdCAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBpID0gbGlzdGVuZXJzW2tleV0ubGVuZ3RoO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgc2hhbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGVpdGhlciB3aXRoIGEgYmFzaWMgY2FsbCBvciBhbiBhcHBseSBpZiB0aGVyZSBpcyBhbiBhcmdzIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1trZXldW2ldO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UgPT09IHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIubGlzdGVuZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBsaXN0ZW5lci5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdGhpcy5fZ2V0T25jZVJldHVyblZhbHVlKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIubGlzdGVuZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGlhcyBvZiBlbWl0RXZlbnRcclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLnRyaWdnZXIgPSBhbGlhcygnZW1pdEV2ZW50Jyk7XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBTdWJ0bHkgZGlmZmVyZW50IGZyb20gZW1pdEV2ZW50IGluIHRoYXQgaXQgd2lsbCBwYXNzIGl0cyBhcmd1bWVudHMgb24gdG8gdGhlIGxpc3RlbmVycywgYXMgb3Bwb3NlZCB0byB0YWtpbmcgYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3Mgb24uXHJcblx0ICAgICAqIEFzIHdpdGggZW1pdEV2ZW50LCB5b3UgY2FuIHBhc3MgYSByZWdleCBpbiBwbGFjZSBvZiB0aGUgZXZlbnQgbmFtZSB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdCBhbmQgZXhlY3V0ZSBsaXN0ZW5lcnMgZm9yLlxyXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IE9wdGlvbmFsIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZW1pdEV2ZW50KGV2dCwgYXJncyk7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZiBhXHJcblx0ICAgICAqIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGUgb25lIHNldCBoZXJlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkXHJcblx0ICAgICAqIGFmdGVyIGV4ZWN1dGlvbi4gVGhpcyB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gY2hlY2sgZm9yIHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy5cclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5zZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBzZXRPbmNlUmV0dXJuVmFsdWUodmFsdWUpIHtcclxuXHQgICAgICAgIHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBGZXRjaGVzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZlxyXG5cdCAgICAgKiB0aGUgbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoaXMgb25lIHRoZW4gaXQgc2hvdWxkIGJlIHJlbW92ZWRcclxuXHQgICAgICogYXV0b21hdGljYWxseS4gSXQgd2lsbCByZXR1cm4gdHJ1ZSBieSBkZWZhdWx0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJuIHsqfEJvb2xlYW59IFRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGZvciBvciB0aGUgZGVmYXVsdCwgdHJ1ZS5cclxuXHQgICAgICogQGFwaSBwcml2YXRlXHJcblx0ICAgICAqL1xyXG5cdCAgICBwcm90by5fZ2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gX2dldE9uY2VSZXR1cm5WYWx1ZSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KCdfb25jZVJldHVyblZhbHVlJykpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25jZVJldHVyblZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBGZXRjaGVzIHRoZSBldmVudHMgb2JqZWN0IGFuZCBjcmVhdGVzIG9uZSBpZiByZXF1aXJlZC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXZlbnRzIHN0b3JhZ2Ugb2JqZWN0LlxyXG5cdCAgICAgKiBAYXBpIHByaXZhdGVcclxuXHQgICAgICovXHJcblx0ICAgIHByb3RvLl9nZXRFdmVudHMgPSBmdW5jdGlvbiBfZ2V0RXZlbnRzKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xyXG5cdCAgICB9O1xyXG5cdFxyXG5cdCAgICAvKipcclxuXHQgICAgICogUmV2ZXJ0cyB0aGUgZ2xvYmFsIHtAbGluayBFdmVudEVtaXR0ZXJ9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHZlcnNpb24uXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBOb24gY29uZmxpY3RpbmcgRXZlbnRFbWl0dGVyIGNsYXNzLlxyXG5cdCAgICAgKi9cclxuXHQgICAgRXZlbnRFbWl0dGVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xyXG5cdCAgICAgICAgZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBvcmlnaW5hbEdsb2JhbFZhbHVlO1xyXG5cdCAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcclxuXHQgICAgfTtcclxuXHRcclxuXHQgICAgLy8gRXhwb3NlIHRoZSBjbGFzcyBlaXRoZXIgdmlhIEFNRCwgQ29tbW9uSlMgb3IgdGhlIGdsb2JhbCBvYmplY3RcclxuXHQgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdCAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xyXG5cdCAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSB7XHJcblx0ICAgICAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcclxuXHQgICAgfVxyXG5cdH0uY2FsbCh0aGlzKSk7XHJcblx0XHJcblx0fS5jYWxsKHdpbmRvdykpO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTgzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktc2xpZGVyXFxcIiA6aWQ9XFxcImlkXFxcIlxcbiAgICA6Y2xhc3M9XFxcIntcXG4gICAgICAgIG1pbjogdmFsdWUgPT09IDAsIG1heDogdmFsdWUgPT09IDEwMCwgZHJhZ2dpbmc6IGRyYWdnaW5nLCBkaXNhYmxlZDogZGlzYWJsZWQsXFxuICAgICAgICBhY3RpdmU6IGFjdGl2ZSwgJ2hhcy1sYWJlbCc6IGhhc0xhYmVsXFxuICAgIH1cXFwiXFxuXFxuICAgIDp0YWJpbmRleD1cXFwiZGlzYWJsZWQgPyBudWxsIDogMFxcXCIgcm9sZT1cXFwic2xpZGVyXFxcIiA6YXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgOmFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCJcXG4gICAgOmFyaWEtdmFsdWVub3c9XFxcInZhbHVlXFxcIlxcblxcbiAgICBAa2V5ZG93bi5sZWZ0LnByZXZlbnQ9XFxcImRlY3JlbWVudFxcXCIgQGtleWRvd24ucmlnaHQucHJldmVudD1cXFwiaW5jcmVtZW50XFxcIlxcbiAgICBAa2V5ZG93bi5kb3duLnByZXZlbnQ9XFxcImRlY3JlbWVudFxcXCIgQGtleWRvd24udXAucHJldmVudD1cXFwiaW5jcmVtZW50XFxcIlxcbiAgICBAZm9jdXM9XFxcImZvY3VzXFxcIiBAYmx1cj1cXFwiYmx1clxcXCJcXG4+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIDp2YWx1ZT1cXFwidmFsdWVcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLWljb24td3JhcHBlclxcXCIgdi1pZj1cXFwic2hvd0ljb25cXFwiPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiIGNsYXNzPVxcXCJ1aS1zbGlkZXItaWNvblxcXCI+PC91aS1pY29uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLWxhYmVsXFxcIiB2LXRleHQ9XFxcImxhYmVsXFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNsaWRlci13cmFwcGVyXFxcIiB2LWVsOnNsaWRlciBAbW91c2Vkb3duPVxcXCJzbGlkZXJDbGlja1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLWNvbnRhaW5tZW50XFxcIiB2LWVsOmNvbnRhaW5tZW50PjwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNsaWRlci10cmFja1xcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNsaWRlci10cmFjay1maWxsXFxcIiA6c3R5bGU9XFxcInsgd2lkdGg6IHZhbHVlICsgJyUnfVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLXRodW1iLWNvbnRhaW5lclxcXCIgdi1lbDp0aHVtYj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVyLWZvY3VzLXJpbmdcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbGlkZXItdGh1bWJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTg0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTg2KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpU25hY2tiYXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODcpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlTbmFja2Jhci52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTg1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTg2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9VaUJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcclxuXHRcclxuXHR2YXIgX1VpQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1VpQnV0dG9uKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXNuYWNrYmFyJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBzaG93OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICB0d29XYXk6IHRydWVcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBtZXNzYWdlOiBTdHJpbmcsXHJcblx0ICAgICAgICBhY3Rpb246IFN0cmluZyxcclxuXHQgICAgICAgIGFjdGlvbkNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdhY2NlbnQnIH0sXHJcblx0ICAgICAgICBwZXJzaXN0ZW50OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGR1cmF0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDUwMDBcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhdXRvSGlkZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBoZWlnaHQ6IDAsXHJcblx0ICAgICAgICAgICAgdGltZW91dDogbnVsbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHQgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcclxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbGlja2VkJyk7XHJcblx0ICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgYWN0aW9uQ2xpY2s6IGZ1bmN0aW9uIGFjdGlvbkNsaWNrKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdhY3Rpb24tY2xpY2tlZCcpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaUJ1dHRvbjogX1VpQnV0dG9uMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHRyYW5zaXRpb25zOiB7XHJcblx0ICAgICAgICAndWktc25hY2tiYXItdG9nZ2xlJzoge1xyXG5cdCAgICAgICAgICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93bicpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvSGlkZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmhpZGUsIHRoaXMuZHVyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBhZnRlckxlYXZlOiBmdW5jdGlvbiBhZnRlckxlYXZlKCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnaGlkZGVuJyk7XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS1zbmFja2JhclxcXCIgOmlkPVxcXCJpZFxcXCIgdHJhbnNpdGlvbj1cXFwidWktc25hY2tiYXItdG9nZ2xlXFxcIiBAY2xpY2s9XFxcImNsaWNrXFxcIiB2LXNob3c9XFxcInNob3dcXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zbmFja2Jhci10ZXh0XFxcIj5cXG4gICAgICAgIDxzbG90PlxcbiAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cXFwibWVzc2FnZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9zbG90PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktc25hY2tiYXItYWN0aW9uXFxcIj5cXG4gICAgICAgIDx1aS1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwidWktc25hY2tiYXItYWN0aW9uLWJ1dHRvblxcXCIgdHlwZT1cXFwiZmxhdFxcXCIgOmNvbG9yPVxcXCJhY3Rpb25Db2xvclxcXCJcXG4gICAgICAgICAgICA6dGV4dD1cXFwiYWN0aW9uXFxcIiBAY2xpY2suc3RvcD1cXFwiYWN0aW9uQ2xpY2tcXFwiIHYtaWY9XFxcImFjdGlvblxcXCJcXG4gICAgICAgID48L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTg5KVxyXG5cdF9fdnVlX3NjcmlwdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTApXHJcblx0aWYgKF9fdnVlX3NjcmlwdF9fICYmXHJcblx0ICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcclxuXHQgICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcclxuXHQgIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcVWlTbmFja2JhckNvbnRhaW5lci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MSlcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVNuYWNrYmFyQ29udGFpbmVyLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxODkgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOTAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3V1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcclxuXHRcclxuXHR2YXIgX3V1aWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXVpZCk7XHJcblx0XHJcblx0dmFyIF9VaVNuYWNrYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODQpO1xyXG5cdFxyXG5cdHZhciBfVWlTbmFja2JhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaVNuYWNrYmFyKTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXNuYWNrYmFyLWNvbnRhaW5lcicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBxdWV1ZVNuYWNrYmFyczoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBkZWZhdWx0RHVyYXRpb246IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogNTAwMFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBvc2l0aW9uOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UocG9zaXRpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdwb3NpdGlvbi0nICsgcG9zaXRpb247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBldmVudHM6IHtcclxuXHQgICAgICAgICd1aS1zbmFja2Jhcjo6Y3JlYXRlJzogZnVuY3Rpb24gdWlTbmFja2JhckNyZWF0ZShzbmFja2Jhcikge1xyXG5cdCAgICAgICAgICAgIHNuYWNrYmFyLnNob3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICBzbmFja2Jhci5pZCA9IHNuYWNrYmFyLmlkIHx8IF91dWlkMi5kZWZhdWx0LnNob3J0KCd1aS1zbmFja2Jhci0nKTtcclxuXHQgICAgICAgICAgICBzbmFja2Jhci5kdXJhdGlvbiA9IHNuYWNrYmFyLmR1cmF0aW9uIHx8IHRoaXMuZGVmYXVsdER1cmF0aW9uO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChzbmFja2Jhcik7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2hvd05leHQoKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMucXVldWVTbmFja2JhcnMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWVbMF0uc2hvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBxdWV1ZTogW10gfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgbWV0aG9kczoge1xyXG5cdCAgICAgICAgc2hvd05leHQ6IGZ1bmN0aW9uIHNob3dOZXh0KCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnF1ZXVlWzBdLnNob3cgPSB0cnVlO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNob3duOiBmdW5jdGlvbiBzaG93bihzbmFja2Jhcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzbmFja2Jhci1zaG93bicsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNhbGxIb29rKCdvblNob3cnLCBzbmFja2Jhcik7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZGVuOiBmdW5jdGlvbiBoaWRkZW4oc25hY2tiYXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc25hY2tiYXItaGlkZGVuJywgc25hY2tiYXIpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY2FsbEhvb2soJ29uSGlkZScsIHNuYWNrYmFyKTtcclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnF1ZXVlLiRyZW1vdmUoc25hY2tiYXIpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2hvd05leHQoKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjbGlja2VkOiBmdW5jdGlvbiBjbGlja2VkKHNuYWNrYmFyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jYWxsSG9vaygnb25DbGljaycsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBhY3Rpb25DbGlja2VkOiBmdW5jdGlvbiBhY3Rpb25DbGlja2VkKHNuYWNrYmFyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jYWxsSG9vaygnb25BY3Rpb25DbGljaycsIHNuYWNrYmFyKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBjYWxsSG9vazogZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgc25hY2tiYXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHNuYWNrYmFyW2hvb2tdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgIHNuYWNrYmFyW2hvb2tdLmNhbGwodW5kZWZpbmVkLCBzbmFja2Jhcik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wb25lbnRzOiB7XHJcblx0ICAgICAgICBVaVNuYWNrYmFyOiBfVWlTbmFja2JhcjIuZGVmYXVsdFxyXG5cdCAgICB9XHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5MSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXNuYWNrYmFyLWNvbnRhaW5lclxcXCIgOmNsYXNzPVxcXCJbcG9zaXRpb25dXFxcIj5cXG4gICAgPHVpLXNuYWNrYmFyXFxuICAgICAgICA6ZHVyYXRpb249XFxcInMuZHVyYXRpb25cXFwiIDpzaG93LnN5bmM9XFxcInMuc2hvd1xcXCIgOmFjdGlvbj1cXFwicy5hY3Rpb25cXFwiXFxuICAgICAgICA6YWN0aW9uLWNvbG9yPVxcXCJzLmFjdGlvbkNvbG9yXFxcIiA6cGVyc2lzdGVudD1cXFwicy5wZXJzaXN0ZW50XFxcIiA6aWQ9XFxcInMuaWRcXFwiIGF1dG8taGlkZVxcblxcbiAgICAgICAgQHNob3duPVxcXCJzaG93bihzKVxcXCIgQGhpZGRlbj1cXFwiaGlkZGVuKHMpXFxcIiBAY2xpY2tlZD1cXFwiY2xpY2tlZChzKVxcXCJcXG4gICAgICAgIEBhY3Rpb24tY2xpY2tlZD1cXFwiYWN0aW9uQ2xpY2tlZChzKVxcXCJcXG5cXG4gICAgICAgIHYtZm9yPVxcXCJzIGluIHF1ZXVlXFxcIlxcbiAgICA+XFxuICAgICAgICA8ZGl2IHYtaHRtbD1cXFwicy5tZXNzYWdlXFxcIiB2LWlmPVxcXCJzLmFsbG93SHRtbFxcXCI+PC9kaXY+XFxuICAgICAgICA8c3BhbiB2LXRleHQ9XFxcInMubWVzc2FnZVxcXCIgdi1lbHNlPjwvc3Bhbj5cXG4gICAgPC91aS1zbmFja2Jhcj5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5MiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxOTMpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5NClcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVN3aXRjaC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5NSlcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVN3aXRjaC52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTkzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTk0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cdFxyXG5cdHZhciBfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjZWl2ZXNUYXJnZXRlZEV2ZW50KTtcclxuXHRcclxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cdFxyXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcclxuXHQgICAgbmFtZTogJ3VpLXN3aXRjaCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICBuYW1lOiBTdHJpbmcsXHJcblx0ICAgICAgICB2YWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgdHdvV2F5OiB0cnVlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGFiZWw6IFN0cmluZyxcclxuXHQgICAgICAgIGhpZGVMYWJlbDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsYWJlbExlZnQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XHJcblx0ICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFRhcmdldHNDb21wb25lbnQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1peGluczogW19SZWNlaXZlc1RhcmdldGVkRXZlbnQyLmRlZmF1bHRdXHJcblx0fTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5NSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxsYWJlbFxcbiAgICBjbGFzcz1cXFwidWktc3dpdGNoXFxcIlxcbiAgICA6Y2xhc3M9XFxcInsgJ2NoZWNrZWQnOiB2YWx1ZSwgJ2Rpc2FibGVkJzogZGlzYWJsZWQsICdsYWJlbC1sZWZ0JzogbGFiZWxMZWZ0IH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zd2l0Y2gtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1zd2l0Y2gtaW5wdXRcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiA6bmFtZT1cXFwibmFtZVxcXCIgOmlkPVxcXCJpZFxcXCIgdi1tb2RlbD1cXFwidmFsdWVcXFwiXFxuICAgICAgICAgICAgdi1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICA+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zd2l0Y2gtdHJhY2tcXFwiPjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc3dpdGNoLXRodW1iXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXN3aXRjaC1mb2N1cy1yaW5nXFxcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXN3aXRjaC1sYWJlbC10ZXh0XFxcIiB2LWlmPVxcXCIhaGlkZUxhYmVsXFxcIj5cXG4gICAgICAgIDxzbG90PlxcbiAgICAgICAgICAgIDxzcGFuIHYtdGV4dD1cXFwibGFiZWxcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvc2xvdD5cXG4gICAgPC9kaXY+XFxuPC9sYWJlbD5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE5NiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxOTcpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5OClcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVRhYi52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5OSlcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRhYi52dWVcIlxyXG5cdCAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcclxuXHQgICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcclxuXHQgIH1cclxuXHR9KSgpfVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTk3ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxyXG5cclxuLyoqKi8gfSxcclxuLyogMTk4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblx0XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcblx0ICAgIHZhbHVlOiB0cnVlXHJcblx0fSk7XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktdGFiJyxcclxuXHRcclxuXHQgICAgcHJvcHM6IHtcclxuXHQgICAgICAgIGlkOiBTdHJpbmcsXHJcblx0ICAgICAgICBoZWFkZXI6IFN0cmluZyxcclxuXHQgICAgICAgIGljb246IFN0cmluZyxcclxuXHQgICAgICAgIGRpc2FibGVkOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC5hY3RpdmVUYWIgPT09IHRoaXMuaWQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3NlbGVjdGVkJywgdGhpcy5pZCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2Rlc2VsZWN0ZWQnLCB0aGlzLmlkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMTk5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdlxcbiAgICBjbGFzcz1cXFwidWktdGFiXFxcIiA6aWQ9XFxcImlkXFxcIiByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgOnRhYmluZGV4PVxcXCJhY3RpdmUgPyAnMCcgOiBudWxsXFxcIlxcbiAgICA6YXJpYS1oaWRkZW49XFxcIiFhY3RpdmUgPyAndHJ1ZScgOiBudWxsXFxcIiB2LXNob3c9XFxcImFjdGl2ZVxcXCJcXG4+XFxuICAgIDxzbG90Pjwvc2xvdD5cXG48L2Rpdj5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygyMDEpXHJcblx0X192dWVfc2NyaXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMilcclxuXHRpZiAoX192dWVfc2NyaXB0X18gJiZcclxuXHQgICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxyXG5cdCAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xyXG5cdCAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxVaVRhYnMudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cclxuXHRfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDcpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxyXG5cdGlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcclxuXHRpZiAoX192dWVfdGVtcGxhdGVfXykge1xyXG5cdCh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cclxuXHR9XHJcblx0aWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcclxuXHQgIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXHJcblx0ICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxyXG5cdCAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXHJcblx0ICB2YXIgaWQgPSBcIkM6XFxcXGNvZGVcXFxccGFja2FnZXNcXFxca2Vlbi11aVxcXFxzcmNcXFxcVWlUYWJzLnZ1ZVwiXHJcblx0ICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xyXG5cdCAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxyXG5cdCAgfVxyXG5cdH0pKCl9XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMDIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuXHQgICAgdmFsdWU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHR2YXIgX3V1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcclxuXHRcclxuXHR2YXIgX3V1aWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXVpZCk7XHJcblx0XHJcblx0dmFyIF9VaVRhYkhlYWRlckl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMyk7XHJcblx0XHJcblx0dmFyIF9VaVRhYkhlYWRlckl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlUYWJIZWFkZXJJdGVtKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblx0XHJcblx0dmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblx0XHJcblx0dmFyIF9SZWNlaXZlc1RhcmdldGVkRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuXHRcclxuXHR2YXIgX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWNlaXZlc1RhcmdldGVkRXZlbnQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktdGFicycsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd0ZXh0JyB9LFxyXG5cdCAgICAgICAgYWN0aXZlVGFiOiBTdHJpbmcsXHJcblx0ICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2JhY2tncm91bmQtY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0ZXh0Q29sb3I6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ2JsYWNrJywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd0ZXh0LWNvbG9yLScgKyBjb2xvcjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGV4dENvbG9yQWN0aXZlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd0ZXh0LWNvbG9yLWFjdGl2ZS0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGluZGljYXRvckNvbG9yOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UoY29sb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvci0nICsgY29sb3I7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGZ1bGx3aWR0aDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByYWlzZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaGlkZVJpcHBsZUluazoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgYWN0aXZlVGFiRWxlbWVudDogbnVsbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHRcclxuXHRcclxuXHQgICAgY29tcHV0ZWQ6IHtcclxuXHQgICAgICAgIHN0eWxlQ2xhc3NlczogZnVuY3Rpb24gc3R5bGVDbGFzc2VzKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbGFzc2VzID0gWyd1aS10YWJzLXR5cGUtJyArIHRoaXMudHlwZV07XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMucmFpc2VkKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgncmFpc2VkJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmZ1bGx3aWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2Z1bGx3aWR0aCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpbmRpY2F0b3JMZWZ0OiBmdW5jdGlvbiBpbmRpY2F0b3JMZWZ0KCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRhYkVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGFiRWxlbWVudC5vZmZzZXRMZWZ0ICsgJ3B4JztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgaW5kaWNhdG9yUmlnaHQ6IGZ1bmN0aW9uIGluZGljYXRvclJpZ2h0KCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRhYkVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQub2Zmc2V0TGVmdDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5hY3RpdmVUYWJFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdGFiQ29udGFpbmVyV2lkdGggPSB0aGlzLiRlbHMudGFic0NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRhYkNvbnRhaW5lcldpZHRoIC0gKGxlZnQgKyB3aWR0aCkgKyAncHgnO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xyXG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHRcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRjaGlsZHJlbltpXS5pZCA9IHRoaXMuJGNoaWxkcmVuW2ldLmlkIHx8IF91dWlkMi5kZWZhdWx0LnNob3J0KCd1aS10YWItJyk7XHJcblx0ICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRoaXMuYWN0aXZlVGFiIHx8IHRoaXMuJGNoaWxkcmVuWzBdLmlkO1xyXG5cdFxyXG5cdCAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIGlmIChfdGhpcy4kZWxzLnRhYnNDb250YWluZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlVGFiRWxlbWVudCA9IF90aGlzLiRlbHMudGFic0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuYWN0aXZlJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLXRhYnM6OnNlbGVjdCc6IGZ1bmN0aW9uIHVpVGFic1NlbGVjdCh0YWJJZCwgaWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRUYXJnZXRzQ29tcG9uZW50KGlkKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciB0YWIgPSB0aGlzLmZpbmRUYWJCeUlkKHRhYklkKTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAodGFiKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRhYi4kZWwsIHRhYik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChlLCB0YWIpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmV3VGFiRWxlbWVudCA9IGUuY3VycmVudFRhcmdldCA/IGUuY3VycmVudFRhcmdldCA6IGU7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRhYi5kaXNhYmxlZCB8fCB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQgPT09IG5ld1RhYkVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYkVsZW1lbnQgPSBuZXdUYWJFbGVtZW50O1xyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiID0gdGFiLmlkO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdhY3RpdmUtdGFiLWNoYW5nZWQnLCB0YWIuaWQpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdFByZXY6IGZ1bmN0aW9uIHNlbGVjdFByZXYoY3VycmVudFRhYkluZGV4KSB7XHJcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRUYWJJbmRleCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHZhciBwcmV2VGFiID0gdGhpcy5maW5kVGFiKGN1cnJlbnRUYWJJbmRleCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zZWxlY3QocHJldlRhYi4kZWwsIHByZXZUYWIpO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiRWxlbWVudC5mb2N1cygpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHNlbGVjdE5leHQ6IGZ1bmN0aW9uIHNlbGVjdE5leHQoY3VycmVudFRhYkluZGV4KSB7XHJcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRUYWJJbmRleCA9PT0gdGhpcy4kcmVmcy50YWJFbGVtZW50cy5sZW5ndGggLSAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgdmFyIG5leHRUYWIgPSB0aGlzLmZpbmRUYWIoY3VycmVudFRhYkluZGV4LCB0cnVlKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNlbGVjdChuZXh0VGFiLiRlbCwgbmV4dFRhYik7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJFbGVtZW50LmZvY3VzKCk7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZmluZFRhYjogZnVuY3Rpb24gZmluZFRhYihjdXJyZW50VGFiSW5kZXgsIG5leHQpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGFiID0gdm9pZCAwO1xyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50VGFiSW5kZXggKyAxOyBpIDwgdGhpcy4kcmVmcy50YWJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW2ldLmRpc2FibGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFiID0gdGhpcy4kcmVmcy50YWJFbGVtZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gY3VycmVudFRhYkluZGV4IC0gMTsgX2kgPj0gMDsgX2ktLSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW19pXS5kaXNhYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYiA9IHRoaXMuJHJlZnMudGFiRWxlbWVudHNbX2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRhYiA9IHRhYiB8fCB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW2N1cnJlbnRUYWJJbmRleF07XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRhYjtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmaW5kVGFiQnlJZDogZnVuY3Rpb24gZmluZFRhYkJ5SWQoaWQpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGFiID0gbnVsbDtcclxuXHRcclxuXHQgICAgICAgICAgICB2YXIgbnVtT2ZUYWJzID0gdGhpcy4kcmVmcy50YWJFbGVtZW50cy5sZW5ndGg7XHJcblx0XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtT2ZUYWJzOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGlkID09PSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW2ldLmlkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YWIgPSB0aGlzLiRyZWZzLnRhYkVsZW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRhYjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgY29tcG9uZW50czoge1xyXG5cdCAgICAgICAgVWlUYWJIZWFkZXJJdGVtOiBfVWlUYWJIZWFkZXJJdGVtMi5kZWZhdWx0XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGRpcmVjdGl2ZXM6IHtcclxuXHQgICAgICAgIGRpc2FibGVkOiBfZGlzYWJsZWQyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX1JlY2VpdmVzVGFyZ2V0ZWRFdmVudDIuZGVmYXVsdF1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjAzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNClcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjA1KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVGFiSGVhZGVySXRlbS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNilcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRhYkhlYWRlckl0ZW0udnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfZGlzYWJsZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuXHRcclxuXHR2YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcclxuXHRcclxuXHR2YXIgX1Nob3dzUmlwcGxlSW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblx0XHJcblx0dmFyIF9TaG93c1JpcHBsZUluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaG93c1JpcHBsZUluayk7XHJcblx0XHJcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHRcclxuXHRleHBvcnRzLmRlZmF1bHQgPSB7XHJcblx0ICAgIG5hbWU6ICd1aS10YWItaGVhZGVyLWl0ZW0nLFxyXG5cdFxyXG5cdCAgICBwcm9wczoge1xyXG5cdCAgICAgICAgaWQ6IFN0cmluZyxcclxuXHQgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnIH0sXHJcblx0ICAgICAgICB0ZXh0OiBTdHJpbmcsXHJcblx0ICAgICAgICBpY29uOiBTdHJpbmcsXHJcblx0ICAgICAgICBhY3RpdmU6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZGlzYWJsZWQ6IHtcclxuXHQgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtaXhpbnM6IFtfU2hvd3NSaXBwbGVJbmsyLmRlZmF1bHRdLFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBkaXNhYmxlZDogX2Rpc2FibGVkMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjA2ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGxpXFxuICAgIGNsYXNzPVxcXCJ1aS10YWItaGVhZGVyLWl0ZW1cXFwiIHJvbGU9XFxcInRhYlxcXCJcXG4gICAgOmNsYXNzPVxcXCJbJ3R5cGUtJyArIHR5cGUsIHsgJ2FjdGl2ZSc6IGFjdGl2ZSwgJ2Rpc2FibGVkJzogZGlzYWJsZWQgfV1cXFwiXFxuXFxuICAgIDp0YWJpbmRleD1cXFwiYWN0aXZlID8gMCA6IC0xXFxcIiA6YXJpYS1jb250cm9scz1cXFwiaWRcXFwiIDphcmlhLXNlbGVjdGVkPVxcXCJhY3RpdmUgPyAndHJ1ZScgOiBudWxsXFxcIlxcbiAgICB2LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdi1lbDppdGVtXFxuPlxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktdGFiLWhlYWRlci1pdGVtLWljb25cXFwiIHYtaWY9XFxcInR5cGUgPT09ICdpY29uJyB8fCB0eXBlID09PSAnaWNvbi1hbmQtdGV4dCdcXFwiXFxuICAgID5cXG4gICAgICAgIDx1aS1pY29uIDppY29uPVxcXCJpY29uXFxcIj48L3VpLWljb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidWktdGFiLWhlYWRlci1pdGVtLXRleHRcXFwiIHYtdGV4dD1cXFwidGV4dFxcXCJcXG4gICAgICAgIHYtaWY9XFxcInR5cGUgPT09ICd0ZXh0JyB8fCB0eXBlID09PSAnaWNvbi1hbmQtdGV4dCdcXFwiXFxuICAgID48L2Rpdj5cXG5cXG4gICAgPHVpLXJpcHBsZS1pbmsgOnRyaWdnZXI9XFxcIiRlbHMuaXRlbVxcXCIgdi1pZj1cXFwiIWhpZGVSaXBwbGVJbmsgJiYgIWRpc2FibGVkXFxcIj48L3VpLXJpcHBsZS1pbms+XFxuPC9saT5cXG5cIjtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInVpLXRhYnNcXFwiIDpjbGFzcz1cXFwic3R5bGVDbGFzc2VzXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWktdGFicy1oZWFkZXJcXFwiIDpjbGFzcz1cXFwiW2JhY2tncm91bmRDb2xvcl1cXFwiPlxcbiAgICAgICAgPHVsXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRhYnMtaGVhZGVyLWl0ZW1zXFxcIiA6Y2xhc3M9XFxcIlt0ZXh0Q29sb3IsIHRleHRDb2xvckFjdGl2ZV1cXFwiIHJvbGU9XFxcInRhYmxpc3RcXFwiXFxuICAgICAgICAgICAgdi1lbDp0YWJzLWNvbnRhaW5lclxcbiAgICAgICAgPlxcbiAgICAgICAgICAgIDx1aS10YWItaGVhZGVyLWl0ZW1cXG4gICAgICAgICAgICAgICAgOnR5cGU9XFxcInR5cGVcXFwiIDppZD1cXFwidGFiLmlkXFxcIiA6aWNvbj1cXFwidGFiLmljb25cXFwiIDp0ZXh0PVxcXCJ0YWIuaGVhZGVyXFxcIlxcbiAgICAgICAgICAgICAgICA6YWN0aXZlPVxcXCJhY3RpdmVUYWIgPT09IHRhYi5pZFxcXCIgOmRpc2FibGVkPVxcXCJ0YWIuZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIDpoaWRlLXJpcHBsZS1pbms9XFxcImhpZGVSaXBwbGVJbmtcXFwiXFxuXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwic2VsZWN0KCRldmVudCwgdGFiKVxcXCIgQGtleWRvd24ubGVmdD1cXFwic2VsZWN0UHJldihpbmRleClcXFwiXFxuICAgICAgICAgICAgICAgIEBrZXlkb3duLnJpZ2h0PVxcXCJzZWxlY3ROZXh0KCRpbmRleClcXFwiXFxuXFxuICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIHRhYikgaW4gJGNoaWxkcmVuXFxcIiB2LXJlZjp0YWItZWxlbWVudHNcXG4gICAgICAgICAgICA+PC91aS10YWItaGVhZGVyLWl0ZW0+XFxuICAgICAgICA8L3VsPlxcblxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS10YWJzLWFjdGl2ZS10YWItaW5kaWNhdG9yXFxcIiA6Y2xhc3M9XFxcIltpbmRpY2F0b3JDb2xvcl1cXFwiXFxuICAgICAgICAgICAgOnN0eWxlPVxcXCJ7ICdsZWZ0JzogaW5kaWNhdG9yTGVmdCwgJ3JpZ2h0JzogaW5kaWNhdG9yUmlnaHQgfVxcXCJcXG4gICAgICAgID48L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRhYnMtYm9keVxcXCI+XFxuICAgICAgICA8c2xvdD48L3Nsb3Q+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjA4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOSlcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwKVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVGV4dGJveC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMSlcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRleHRib3gudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb24pO1xyXG5cdFxyXG5cdHZhciBfYXV0b2ZvY3VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XHJcblx0XHJcblx0dmFyIF9hdXRvZm9jdXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXV0b2ZvY3VzKTtcclxuXHRcclxuXHR2YXIgX0hhc1RleHRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xyXG5cdFxyXG5cdHZhciBfSGFzVGV4dElucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hhc1RleHRJbnB1dCk7XHJcblx0XHJcblx0dmFyIF9WYWxpZGF0ZXNJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xyXG5cdFxyXG5cdHZhciBfVmFsaWRhdGVzSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdGVzSW5wdXQpO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktdGV4dGJveCcsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICd0ZXh0J1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG11bHRpTGluZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICByb3dzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IDJcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBtYXhMZW5ndGg6IE51bWJlcixcclxuXHQgICAgICAgIHRyaW1WYWx1ZToge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHZhbGlkYXRlT25CbHVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGF1dG9jb21wbGV0ZTogU3RyaW5nLFxyXG5cdCAgICAgICAgYXV0b2ZvY3VzOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1pbjogTnVtYmVyLFxyXG5cdCAgICAgICAgbWF4OiBOdW1iZXIsXHJcblx0ICAgICAgICBzdGVwOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdhbnknLFxyXG5cdCAgICAgICAgICAgIGNvZXJjZTogU3RyaW5nXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIHdhdGNoOiB7XHJcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaWdub3JlVmFsdWVDaGFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZGlydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZU9uQmx1cikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpZ25vcmVWYWx1ZUNoYW5nZTogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0XHJcblx0XHJcblx0ICAgIGNvbXB1dGVkOiB7XHJcblx0ICAgICAgICBzaG93SWNvbjogZnVuY3Rpb24gc2hvd0ljb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pY29uKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBtaW5WYWx1ZTogZnVuY3Rpb24gbWluVmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1pbiB8fCB0aGlzLm1pbiA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taW47XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIG1heFZhbHVlOiBmdW5jdGlvbiBtYXhWYWx1ZSgpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF4IHx8IHRoaXMubWF4ID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3RlcFZhbHVlOiBmdW5jdGlvbiBzdGVwVmFsdWUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcDtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGV2ZW50czoge1xyXG5cdCAgICAgICAgJ3VpLWlucHV0OjpyZXNldCc6IGZ1bmN0aW9uIHVpSW5wdXRSZXNldChpZCkge1xyXG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0c0NvbXBvbmVudChpZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLmlnbm9yZVZhbHVlQ2hhbmdlID0gdHJ1ZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvciA9ICcnO1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmluaXRpYWxWYWx1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblx0XHJcblx0ICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICBfdGhpcy5pZ25vcmVWYWx1ZUNoYW5nZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBtZXRob2RzOiB7XHJcblx0ICAgICAgICBmb2N1c3NlZDogZnVuY3Rpb24gZm9jdXNzZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdmb2N1c3NlZCcpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJsdXJyZWQ6IGZ1bmN0aW9uIGJsdXJyZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZGlydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdibHVycmVkJyk7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGNoYW5nZWQ6IGZ1bmN0aW9uIGNoYW5nZWQoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NoYW5nZWQnKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgna2V5ZG93bicsIGUpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGtleWRvd25FbnRlcjogZnVuY3Rpb24ga2V5ZG93bkVudGVyKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgna2V5ZG93bi1lbnRlcicsIGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBmaWx0ZXJzOiB7XHJcblx0ICAgICAgICB0cmltOiB7XHJcblx0ICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdudW1iZXInICYmIHRoaXMudHJpbVZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpSWNvbjogX1VpSWNvbjIuZGVmYXVsdFxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBkaXJlY3RpdmVzOiB7XHJcblx0ICAgICAgICBhdXRvZm9jdXM6IF9hdXRvZm9jdXMyLmRlZmF1bHRcclxuXHQgICAgfSxcclxuXHRcclxuXHQgICAgbWl4aW5zOiBbX0hhc1RleHRJbnB1dDIuZGVmYXVsdCwgX1ZhbGlkYXRlc0lucHV0Mi5kZWZhdWx0XVxyXG5cdH07XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMTEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2XFxuICAgIGNsYXNzPVxcXCJ1aS10ZXh0Ym94XFxcIlxcbiAgICA6Y2xhc3M9XFxcIntcXG4gICAgICAgICdkaXNhYmxlZCc6IGRpc2FibGVkLCAnaW52YWxpZCc6ICF2YWxpZCwgJ2RpcnR5JzogZGlydHksICdhY3RpdmUnOiBhY3RpdmUsXFxuICAgICAgICAnaGFzLWxhYmVsJzogIWhpZGVMYWJlbCwgJ2lzLW11bHRpLWxpbmUnOiBtdWx0aUxpbmUsICdpY29uLXJpZ2h0JzogaWNvblJpZ2h0LFxcbiAgICAgICAgJ2hhcy1jb3VudGVyJzogbWF4TGVuZ3RoXFxuICAgIH1cXFwiXFxuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWljb24td3JhcHBlclxcXCIgdi1pZj1cXFwic2hvd0ljb25cXFwiPlxcbiAgICAgICAgPHVpLWljb24gOmljb249XFxcImljb25cXFwiIGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWljb25cXFwiPjwvdWktaWNvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInVpLXRleHRib3gtY29udGVudFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInVpLXRleHRib3gtbGFiZWxcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRleHRib3gtbGFiZWwtdGV4dFxcXCIgdi10ZXh0PVxcXCJsYWJlbFxcXCIgdi1pZj1cXFwiIWhpZGVMYWJlbFxcXCI+PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWlucHV0XFxcIiA6dHlwZT1cXFwidHlwZVxcXCIgOnBsYWNlaG9sZGVyPVxcXCJwbGFjZWhvbGRlclxcXCIgOm5hbWU9XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgIDppZD1cXFwiaWRcXFwiIDpudW1iZXI9XFxcInR5cGUgPT09ICdudW1iZXInID8gdHJ1ZSA6IG51bGxcXFwiIDptaW49XFxcIm1pblZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgICA6bWF4PVxcXCJtYXhWYWx1ZVxcXCIgOnN0ZXA9XFxcInN0ZXBWYWx1ZVxcXCJcXG4gICAgICAgICAgICAgICAgOmF1dG9jb21wbGV0ZT1cXFwiYXV0b2NvbXBsZXRlID8gYXV0b2NvbXBsZXRlIDogbnVsbFxcXCJcXG5cXG4gICAgICAgICAgICAgICAgQGZvY3VzPVxcXCJmb2N1c3NlZFxcXCIgQGJsdXI9XFxcImJsdXJyZWRcXFwiIEBjaGFuZ2U9XFxcImNoYW5nZWRcXFwiIEBrZXlkb3duPVxcXCJrZXlkb3duXFxcIlxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi5lbnRlcj1cXFwia2V5ZG93bkVudGVyXFxcIiA6ZGVib3VuY2U9XFxcImRlYm91bmNlXFxcIlxcblxcbiAgICAgICAgICAgICAgICB2LW1vZGVsPVxcXCJ2YWx1ZSB8IHRyaW1cXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB2LWlmPVxcXCIhbXVsdGlMaW5lXFxcIlxcbiAgICAgICAgICAgICAgICB2LWF1dG9mb2N1cz1cXFwiYXV0b2ZvY3VzXFxcIlxcbiAgICAgICAgICAgID5cXG5cXG4gICAgICAgICAgICA8dGV4dGFyZWFcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRleHRib3gtdGV4dGFyZWFcXFwiIDpwbGFjZWhvbGRlcj1cXFwicGxhY2Vob2xkZXJcXFwiIDpuYW1lPVxcXCJuYW1lXFxcIiA6aWQ9XFxcImlkXFxcIlxcbiAgICAgICAgICAgICAgICA6cm93cz1cXFwicm93c1xcXCJcXG5cXG4gICAgICAgICAgICAgICAgQGZvY3VzPVxcXCJmb2N1c3NlZFxcXCIgQGJsdXI9XFxcImJsdXJyZWRcXFwiIEBjaGFuZ2U9XFxcImNoYW5nZWRcXFwiIEBrZXlkb3duPVxcXCJrZXlkb3duXFxcIlxcbiAgICAgICAgICAgICAgICBAa2V5ZG93bi5lbnRlcj1cXFwia2V5ZG93bkVudGVyXFxcIiA6ZGVib3VuY2U9XFxcImRlYm91bmNlXFxcIlxcblxcbiAgICAgICAgICAgICAgICB2LW1vZGVsPVxcXCJ2YWx1ZSB8IHRyaW1cXFwiIHYtZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB2LWVsc2VcXG4gICAgICAgICAgICA+PC90ZXh0YXJlYT5cXG4gICAgICAgIDwvbGFiZWw+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWZlZWRiYWNrXFxcIiB2LWlmPVxcXCJzaG93RmVlZGJhY2sgfHwgbWF4TGVuZ3RoXFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWVycm9yLXRleHRcXFwiIHRyYW5zaXRpb249XFxcInVpLXRleHRib3gtZmVlZGJhY2stdG9nZ2xlXFxcIlxcbiAgICAgICAgICAgICAgICB2LXRleHQ9XFxcInZhbGlkYXRpb25FcnJvclxcXCIgdi1zaG93PVxcXCIhaGlkZVZhbGlkYXRpb25FcnJvcnMgJiYgIXZhbGlkXFxcIlxcbiAgICAgICAgICAgID48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWhlbHAtdGV4dFxcXCIgdHJhbnNpdGlvbj1cXFwidWktdGV4dGJveC1mZWVkYmFjay10b2dnbGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtdGV4dD1cXFwiaGVscFRleHRcXFwiIHYtZWxzZVxcbiAgICAgICAgICAgID48L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS10ZXh0Ym94LWNvdW50ZXJcXFwiIHYtdGV4dD1cXFwidmFsdWUubGVuZ3RoICsgJy8nICsgbWF4TGVuZ3RoXFxcIlxcbiAgICAgICAgICAgICAgICB2LWlmPVxcXCJtYXhMZW5ndGhcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjEyICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHR2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMylcclxuXHRfX3Z1ZV9zY3JpcHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjE0KVxyXG5cdGlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxyXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXHJcblx0ICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XHJcblx0ICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXFVpVG9vbGJhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxyXG5cdF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNSlcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XHJcblx0aWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxyXG5cdGlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XHJcblx0KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xyXG5cdH1cclxuXHRpZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxyXG5cdCAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcclxuXHQgIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXHJcblx0ICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cclxuXHQgIHZhciBpZCA9IFwiQzpcXFxcY29kZVxcXFxwYWNrYWdlc1xcXFxrZWVuLXVpXFxcXHNyY1xcXFxVaVRvb2xiYXIudnVlXCJcclxuXHQgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XHJcblx0ICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXHJcblx0ICB9XHJcblx0fSkoKX1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIxNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG5cdCAgICB2YWx1ZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBfVWlQcm9ncmVzc0xpbmVhciA9IF9fd2VicGFja19yZXF1aXJlX18oMTM3KTtcclxuXHRcclxuXHR2YXIgX1VpUHJvZ3Jlc3NMaW5lYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVWlQcm9ncmVzc0xpbmVhcik7XHJcblx0XHJcblx0dmFyIF9VaUljb25CdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHRcclxuXHR2YXIgX1VpSWNvbkJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9VaUljb25CdXR0b24pO1xyXG5cdFxyXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblx0XHJcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG5cdCAgICBuYW1lOiAndWktdG9vbGJhcicsXHJcblx0XHJcblx0ICAgIHByb3BzOiB7XHJcblx0ICAgICAgICB0eXBlOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JywgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3VpLXRvb2xiYXItJyArIHR5cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRleHRDb2xvcjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnYmxhY2snLCBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZShjb2xvcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQtY29sb3ItJyArIGNvbG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0aXRsZTogU3RyaW5nLFxyXG5cdCAgICAgICAgYnJhbmQ6IFN0cmluZyxcclxuXHQgICAgICAgIHNob3dCcmFuZDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzaG93QnJhbmREaXZpZGVyOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBudWxsXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbmF2SWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiAnbWVudSdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBoaWRlTmF2SWNvbjoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBmbGF0OiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHByZWxvYWRlclRvcDoge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcblx0ICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuXHQgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdFxyXG5cdCAgICBjb21wdXRlZDoge1xyXG5cdCAgICAgICAgc3R5bGVDbGFzc2VzOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbdGhpcy50eXBlLCB0aGlzLnRleHRDb2xvcl07XHJcblx0XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmZsYXQpIHtcclxuXHQgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd1aS10b29sYmFyLXJhaXNlZCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBpY29uQ29sb3I6IGZ1bmN0aW9uIGljb25Db2xvcigpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy50ZXh0Q29sb3IgPT09ICd0ZXh0LWNvbG9yLWJsYWNrJykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2JsYWNrJztcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuICd3aGl0ZSc7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcHJlbG9hZGVyQ29sb3I6IGZ1bmN0aW9uIHByZWxvYWRlckNvbG9yKCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnRleHRDb2xvciA9PT0gJ3RleHQtY29sb3ItYmxhY2snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAncHJpbWFyeSc7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdFxyXG5cdCAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGJyYW5kRGl2aWRlclZpc2libGU6IGZ1bmN0aW9uIGJyYW5kRGl2aWRlclZpc2libGUoKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0JyYW5kRGl2aWRlciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93QnJhbmREaXZpZGVyO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuc2hvd0JyYW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIG1ldGhvZHM6IHtcclxuXHQgICAgICAgIG5hdkljb25DbGljazogZnVuY3Rpb24gbmF2SWNvbkNsaWNrKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCduYXYtaWNvbi1jbGlja2VkJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblx0XHJcblx0ICAgIGNvbXBvbmVudHM6IHtcclxuXHQgICAgICAgIFVpUHJvZ3Jlc3NMaW5lYXI6IF9VaVByb2dyZXNzTGluZWFyMi5kZWZhdWx0LFxyXG5cdCAgICAgICAgVWlJY29uQnV0dG9uOiBfVWlJY29uQnV0dG9uMi5kZWZhdWx0XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjE1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidWktdG9vbGJhclxcXCIgOmNsYXNzPVxcXCJzdHlsZUNsYXNzZXNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLWxlZnRcXFwiPlxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInVpLXRvb2xiYXItbmF2LWljb25cXFwiIHR5cGU9XFxcImNsZWFyXFxcIiA6Y29sb3I9XFxcImljb25Db2xvclxcXCIgOmljb249XFxcIm5hdkljb25cXFwiXFxuICAgICAgICAgICAgQGNsaWNrPVxcXCJuYXZJY29uQ2xpY2tcXFwiIHYtaWY9XFxcIiFoaWRlTmF2SWNvblxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdG9vbGJhci1icmFuZFxcXCIgdi1pZj1cXFwic2hvd0JyYW5kXFxcIj5cXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVxcXCJicmFuZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRvb2xiYXItYnJhbmQtdGV4dFxcXCIgdi10ZXh0PVxcXCJicmFuZFxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9zbG90PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLWNlbnRlclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLWRpdmlkZXJcXFwiIHYtaWY9XFxcImJyYW5kRGl2aWRlclZpc2libGVcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgPHNsb3Q+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdG9vbGJhci10aXRsZVxcXCIgdi10ZXh0PVxcXCJ0aXRsZVxcXCI+PC9kaXY+XFxuICAgICAgICA8L3Nsb3Q+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10b29sYmFyLXJpZ2h0XFxcIj5cXG4gICAgICAgIDxzbG90IG5hbWU9XFxcImFjdGlvbnNcXFwiPjwvc2xvdD5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDx1aS1wcm9ncmVzcy1saW5lYXJcXG4gICAgICAgIDpzaG93PVxcXCJsb2FkaW5nXFxcIiBjbGFzcz1cXFwidWktdG9vbGJhci1wcmVsb2FkZXJcXFwiIDpjbGFzcz1cXFwieyAncG9zaXRpb24tdG9wJyA6IHByZWxvYWRlclRvcCB9XFxcIlxcbiAgICAgICAgOmNvbG9yPVxcXCJwcmVsb2FkZXJDb2xvclxcXCJcXG4gICAgPjwvdWktcHJvZ3Jlc3MtbGluZWFyPlxcbjwvZGl2PlxcblwiO1xyXG5cclxuLyoqKi8gfVxyXG4vKioqKioqLyBdKVxyXG59KTtcclxuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWVuLXVpLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2tlZW4tdWkvZGlzdC9rZWVuLXVpLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3M/LXVybCEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXEFwcC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BcHAudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtN2NhMWIxYmIvQXBwLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9BcHAudnVlXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3MtYXBwXCI+XHJcbiAgICAgICAgPHVpLXRhYnNcclxuICAgICAgICAgICAgY2xhc3M9XCJtYWluLXRhYi1jb250YWluZXJcIiBiYWNrZ3JvdW5kLWNvbG9yPVwiZGFya1wiIHRleHQtY29sb3I9XCJsaWdodFwiXHJcbiAgICAgICAgICAgIGluZGljYXRvci1jb2xvcj1cInRyYW5zcGFyZW50XCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDx1aS10YWIgaGVhZGVyPVwiTWFwXCI+XHJcbiAgICAgICAgICAgICAgICA8bWFwLXZpZXc+PC9tYXAtdmlldz5cclxuICAgICAgICAgICAgPC91aS10YWI+XHJcblxyXG4gICAgICAgICAgICA8dWktdGFiIGhlYWRlcj1cIlBhcmFtc1wiPlxyXG4gICAgICAgICAgICAgICAgPHBhcmFtcy12aWV3PjwvcGFyYW1zLXZpZXc+XHJcbiAgICAgICAgICAgIDwvdWktdGFiPlxyXG5cclxuICAgICAgICAgICAgPHVpLXRhYiBoZWFkZXI9XCJTZXR0aW5nc1wiPlxyXG4gICAgICAgICAgICAgICAgPHNldHRpbmdzLXZpZXc+PC9zZXR0aW5ncy12aWV3PlxyXG4gICAgICAgICAgICA8L3VpLXRhYj5cclxuICAgICAgICA8L3VpLXRhYnM+XHJcblxyXG4gICAgICAgIDxnY3MtaW5kaWNhdG9ycz48L2djcy1pbmRpY2F0b3JzPlxyXG5cclxuICAgICAgICA8dWktc25hY2tiYXItY29udGFpbmVyIHBvc2l0aW9uPVwibGVmdFwiPjwvdWktc25hY2tiYXItY29udGFpbmVyPlxyXG5cclxuICAgICAgICA8Z2NzLWVkaXQtbWlzc2lvbi1tb2RhbCA6c2hvdy5zeW5jPVwic2hvd0VkaXRNaXNzaW9uTW9kYWxcIj48L2djcy1lZGl0LW1pc3Npb24tbW9kYWw+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8c29ja2V0LWlvLW1hbmFnZXI+PC9zb2NrZXQtaW8tbWFuYWdlcj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBNYXBWaWV3IGZyb20gJ3ZpZXdzL01hcFZpZXcudnVlJztcclxuaW1wb3J0IFBhcmFtc1ZpZXcgZnJvbSAndmlld3MvUGFyYW1zVmlldy52dWUnO1xyXG5pbXBvcnQgU2V0dGluZ3NWaWV3IGZyb20gJ3ZpZXdzL1NldHRpbmdzVmlldy52dWUnO1xyXG5pbXBvcnQgR2NzSW5kaWNhdG9ycyBmcm9tICdjb21wb25lbnRzL0djc0luZGljYXRvcnMudnVlJztcclxuaW1wb3J0IFNvY2tldElvTWFuYWdlciBmcm9tICdjb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWUnO1xyXG5pbXBvcnQgR2NzRWRpdE1pc3Npb25Nb2RhbCBmcm9tICdjb21wb25lbnRzL21pc3Npb24vR2NzRWRpdE1pc3Npb25Nb2RhbC52dWUnO1xyXG5cclxuaW1wb3J0IENvbnRyb2xsZXJNYW5hZ2VyIGZyb20gJ21vZHVsZXMvY29udHJvbGxlci1tYW5hZ2VyLmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2hvd0VkaXRNaXNzaW9uTW9kYWw6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgbmV3IENvbnRyb2xsZXJNYW5hZ2VyKHRoaXMuY29udHJvbGxlckV2ZW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICAgJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJyhtZXNzYWdlLCBzbmFja2Jhcikge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNuYWNrYmFyKG1lc3NhZ2UsIHNuYWNrYmFyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnYXBwOjpzaG93LWVkaXQtbWlzc2lvbi1tb2RhbCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0VkaXRNaXNzaW9uTW9kYWwgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OnBhbi11cCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpwYW4tdXAnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tZG93bicoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnbWFwOjpwYW4tZG93bicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OnBhbi1sZWZ0JygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6OnBhbi1sZWZ0Jyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6cGFuLXJpZ2h0JygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6OnBhbi1yaWdodCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OnBhbi1jZW50ZXInKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6cGFuLWNlbnRlcicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6Onpvb20taW4nKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDo6em9vbS1pbicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6Onpvb20tb3V0JygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6Onpvb20tb3V0Jyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6Y2hhbmdlLXR5cGUnKG5ld1R5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6OmNoYW5nZS10eXBlJywgbmV3VHlwZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDpjbGljaycoZSkge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ21hcDpjbGljaycsIGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6ZGJsY2xpY2snKGUpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6ZGJsY2xpY2snLCBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOnJpZ2h0Y2xpY2snKGUpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdtYXA6cmlnaHRjbGljaycsIGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmdldF9wYXJhbWV0ZXJzJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjbGllbnQ6OmdldF9wYXJhbWV0ZXJzJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c2V0X3BhcmFtZXRlcnMnKHBhcmFtcykge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2NsaWVudDo6c2V0X3BhcmFtZXRlcnMnLCBwYXJhbXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmdldF9zZXR0aW5ncycoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjpnZXRfc2V0dGluZ3MnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpzZXRfc2V0dGluZ3MnKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjpzZXRfc2V0dGluZ3MnLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c2V0X21pc3Npb25zJyhtaXNzaW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2NsaWVudDo6c2V0X21pc3Npb25zJywgbWlzc2lvbnMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmdldF9taXNzaW9ucycoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjpnZXRfbWlzc2lvbnMnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpzZXRfbWlzc2lvbicobWlzc2lvbikge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2NsaWVudDo6c2V0X21pc3Npb24nLCBtaXNzaW9uKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpnZXRfbWlzc2lvbicoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjpnZXRfbWlzc2lvbicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmFybScoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50Ojphcm0nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpkaXNhcm0nKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2NsaWVudDo6ZGlzYXJtJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c3RhcnRfbWlzc2lvbicoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjpzdGFydF9taXNzaW9uJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c3RvcF9taXNzaW9uJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjbGllbnQ6OnN0b3BfbWlzc2lvbicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OnJlc3VtZV9taXNzaW9uJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjbGllbnQ6OnJlc3VtZV9taXNzaW9uJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6a2lsbCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjpraWxsJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6dW5raWxsJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjbGllbnQ6OnVua2lsbCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6Om1hbnVhbCcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2xpZW50OjptYW51YWwnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjphdXRvJygpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjbGllbnQ6OmF1dG8nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnc2VydmVyOjpzZXRfcGFyYW1ldGVyc19hY2snKCl7XHJcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2VydmVyOjpzZXRfcGFyYW1ldGVyc19hY2snKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnc2VydmVyOjpzZXRfc2V0dGluZ3NfYWNrJygpe1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3NlcnZlcjo6c2V0X3NldHRpbmdzX2FjaycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdzZXJ2ZXI6OnNldF9taXNzaW9uX2FjaycoKXtcclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdzZXJ2ZXI6OnNldF9taXNzaW9uX2FjaycpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGNvbnRyb2xsZXJFdmVudChldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZXZlbnQsIGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2NsaWVudDo6Y29udHJvbGxlcl9ldmVudCcsIGRhdGEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNyZWF0ZVNuYWNrYmFyKG1lc3NhZ2UsIHNuYWNrYmFyKSB7XHJcbiAgICAgICAgICAgIHNuYWNrYmFyID0gc25hY2tiYXIgfHwge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd1aS1zbmFja2Jhcjo6Y3JlYXRlJywgc25hY2tiYXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY29tcG9uZW50czoge1xyXG4gICAgICAgIE1hcFZpZXcsXHJcbiAgICAgICAgUGFyYW1zVmlldyxcclxuICAgICAgICBTZXR0aW5nc1ZpZXcsXHJcbiAgICAgICAgR2NzSW5kaWNhdG9ycyxcclxuICAgICAgICBTb2NrZXRJb01hbmFnZXIsXHJcbiAgICAgICAgR2NzRWRpdE1pc3Npb25Nb2RhbFxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvbWFpbic7XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEFwcC52dWU/Yzg1YjhlMGVcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcz8tdXJsIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NYXBWaWV3LnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL01hcFZpZXcudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXHZpZXdzXFxcXE1hcFZpZXcudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vTWFwVmlldy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0xMDY4ODdmYS9NYXBWaWV3LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL3ZpZXdzL01hcFZpZXcudnVlXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aWV3cy9NYXBWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwidmlldyBtYXAtdmlld1wiPlxyXG4gICAgICAgIDxnY3MtbWFwPjwvZ2NzLW1hcD5cclxuICAgICAgICA8Z2NzLW1hcC1jb250cm9scz48L2djcy1tYXAtY29udHJvbHM+XHJcbiAgICAgICAgPGdjcy1tYXAtc2lkZWJhciA6c2hvdy1zaWRlYmFyPVwic2hvd1NpZGViYXJcIj48L2djcy1tYXAtc2lkZWJhcj5cclxuXHJcbiAgICAgICAgPGdjcy1zaWRlYmFyLWNvbnRyb2xzXHJcbiAgICAgICAgICAgIDpzaG93LXNpZGViYXI9XCJzaG93U2lkZWJhclwiIEB0b2dnbGUtc2lkZWJhcj1cInRvZ2dsZVNpZGViYXJcIlxyXG4gICAgICAgID48L2djcy1zaWRlYmFyLWNvbnRyb2xzPlxyXG5cclxuICAgICAgICA8Z2NzLWNvbW1hbmRzPjwvZ2NzLWNvbW1hbmRzPlxyXG5cclxuICAgICAgICA8Z2NzLXdhbXYgdi1pZj1cIndhbXYubG9hZGVkXCJcclxuICAgICAgICAgICAgOmxhdD1cIndhbXYucG9zaXRpb24ubGF0XCIgOmxuZz1cIndhbXYucG9zaXRpb24ubG5nXCJcclxuICAgICAgICAgICAgOnJvdGF0aW9uPVwid2Ftdi5oZWFkaW5nXCJcclxuICAgICAgICA+PC9nY3Mtd2Ftdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEdjc01hcCBmcm9tICdtYXAvR2NzTWFwLnZ1ZSc7XHJcbmltcG9ydCBHY3NNYXBDb250cm9scyBmcm9tICdtYXAvR2NzTWFwQ29udHJvbHMudnVlJztcclxuaW1wb3J0IEdjc01hcFNpZGViYXIgZnJvbSAnbWFwL0djc01hcFNpZGViYXIudnVlJztcclxuaW1wb3J0IEdjc0NvbW1hbmRzIGZyb20gJ21hcC9HY3NDb21tYW5kcy52dWUnO1xyXG5pbXBvcnQgR2NzU2lkZWJhckNvbnRyb2xzIGZyb20gJ21hcC9HY3NTaWRlYmFyQ29udHJvbHMudnVlJztcclxuaW1wb3J0IEdjc1dhbXYgZnJvbSAnbWFya2Vycy9HY3NXYW12LnZ1ZSc7XHJcblxyXG5pbXBvcnQgeyBnZXRXYW12IH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgZ2V0dGVyczoge1xyXG4gICAgICAgICAgICB3YW12OiBnZXRXYW12XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNob3dTaWRlYmFyOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHRvZ2dsZVNpZGViYXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1NpZGViYXIgPSAhdGhpcy5zaG93U2lkZWJhcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBHY3NNYXAsXHJcbiAgICAgICAgR2NzV2FtdixcclxuICAgICAgICBHY3NNYXBDb250cm9scyxcclxuICAgICAgICBHY3NNYXBTaWRlYmFyLFxyXG4gICAgICAgIEdjc1NpZGViYXJDb250cm9scyxcclxuICAgICAgICBHY3NDb21tYW5kc1xyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4udmlldy5tYXAtdmlldyB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogTWFwVmlldy52dWU/MWFiNDU0MGJcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcz8tdXJsIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNYXAudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWFwLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtYXBcXFxcR2NzTWFwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01hcC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0xODI4MWMyNS9HY3NNYXAudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLW1hcFwiIGlkPVwibWFwXCIgOmNsYXNzPVwieyAnZ2NzLW1hcC1lZGl0LW1vZGUnOiBtYXBFZGl0aW5nIH1cIj48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBsb2FkR29vZ2xlTWFwc0FQSSBmcm9tICdsb2FkLWdvb2dsZS1tYXBzLWFwaSc7XHJcblxyXG5pbXBvcnQgeyBzZXRNYXAsIHNldE1hcEVsLCBzZXRNYXBMb2FkZWQgfSBmcm9tICdzdG9yZS9hY3Rpb25zJztcclxuaW1wb3J0IHsgZ2V0V2FtdiwgZ2V0U2V0dGluZ3MsIGdldFNldHRpbmdzTGFzdFVwZGF0ZVRpbWUsIGdldE1hcCwgZ2V0TWFwRWwsIGdldE1hcExvYWRlZCwgZ2V0TWFwRWRpdGluZyB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgbWFwOiBnZXRNYXAsXHJcbiAgICAgICAgICAgIG1hcEVsOiBnZXRNYXBFbCxcclxuICAgICAgICAgICAgbWFwTG9hZGVkOiBnZXRNYXBMb2FkZWQsXHJcbiAgICAgICAgICAgIG1hcEVkaXRpbmc6IGdldE1hcEVkaXRpbmcsXHJcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXYsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiBnZXRTZXR0aW5ncyxcclxuICAgICAgICAgICAgc2V0dGluZ3NMYXN0VXBkYXRlVGltZTogZ2V0U2V0dGluZ3NMYXN0VXBkYXRlVGltZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgc2V0TWFwLFxyXG4gICAgICAgICAgICBzZXRNYXBFbCxcclxuICAgICAgICAgICAgc2V0TWFwTG9hZGVkXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIG1hcEVkaXRpbmcoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5tYXBMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFZGl0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRPcHRpb25zKHsgZHJhZ2dhYmxlQ3Vyc29yOiAnY3Jvc3NoYWlyJyB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldE9wdGlvbnMoeyBkcmFnZ2FibGVDdXJzb3I6ICdtb3ZlJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldHRpbmdzTGFzdFVwZGF0ZVRpbWUoKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRNYXBFbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwJykpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIFNlYXJjaEtleTpcclxuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnNldHRpbmdzKXtcclxuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnRpdGxlID09PSAnTWFwJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc2V0dGluZyBvZiBzZWN0aW9uLnNldHRpbmdzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmcudGl0bGUgPT09ICdrZXknKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHNldHRpbmcudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBTZWFyY2hLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBmaW5kIEdvb2dsZSBNYXBzIGtleScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9hZEdvb2dsZU1hcHNBUEkoe2tleToga2V5LCB2OiAzfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbih0aGlzLmluaXRpYWxpemVNYXApXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGxvYWQgR29vZ2xlIE1hcHMgQVBJJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICAnbWFwOjpwYW4tdXAnKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAucGFuQnkoMCwgLTEgKiAodGhpcy5tYXBFbC5jbGllbnRIZWlnaHQgLyA0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tZG93bicoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcExvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5wYW5CeSgwLCB0aGlzLm1hcEVsLmNsaWVudEhlaWdodCAvIDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6cGFuLWxlZnQnKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAucGFuQnkoLTEgKiAodGhpcy5tYXBFbC5jbGllbnRXaWR0aCAvIDQpLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6OnBhbi1yaWdodCcoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcExvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5wYW5CeSh0aGlzLm1hcEVsLmNsaWVudFdpZHRoIC8gNCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnbWFwOjpwYW4tY2VudGVyJygpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkICYmIHRoaXMud2Ftdi5sb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAucGFuVG8odGhpcy53YW12LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdtYXA6Onpvb20taW4nKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQgJiYgdGhpcy53YW12LmxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRab29tKHRoaXMubWFwLmdldFpvb20oKSArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6em9vbS1vdXQnKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQgJiYgdGhpcy53YW12LmxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRab29tKHRoaXMubWFwLmdldFpvb20oKSAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDo6Y2hhbmdlLXR5cGUnKG5ld1R5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkICYmIHRoaXMud2Ftdi5sb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0TWFwVHlwZUlkKGdvb2dsZS5tYXBzLk1hcFR5cGVJZFtuZXdUeXBlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBpbml0aWFsaXplTWFwKCkge1xyXG4gICAgICAgICAgICBsZXQgbGF0ID0gbnVsbCwgbG5nID0gbnVsbCwgem9vbSA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb24gb2YgdGhpcy5zZXR0aW5ncyl7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbi50aXRsZSA9PT0gJ01hcCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNldHRpbmcgb2Ygc2VjdGlvbi5zZXR0aW5ncyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLnRpdGxlID09PSAnbGF0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXQgPSBzZXR0aW5nLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcudGl0bGUgPT09ICdsbmcnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuZyA9IHNldHRpbmcudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZy50aXRsZSA9PT0gJ3pvb20nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gPSBzZXR0aW5nLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGF0ID09PSBudWxsIHx8IGxuZyA9PT0gbnVsbCB8fCB6b29tID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZmluZCBsbmcvbG5nL3pvb20gc2V0dGluZycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAodGhpcy5tYXBFbCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IHBhcnNlRmxvYXQobGF0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBwYXJzZUZsb2F0KGxuZylcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHBhcnNlRmxvYXQoem9vbSksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwVHlwZUlkOiBnb29nbGUubWFwcy5NYXBUeXBlSWQuU0FURUxMSVRFLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZURvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aWx0OiAwXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudHMobWFwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1hcExvYWRlZCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldHVwRXZlbnRzKG1hcCkge1xyXG4gICAgICAgICAgICBtYXAuYWRkTGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtYXA6Y2xpY2snLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBtYXAuYWRkTGlzdGVuZXIoJ2RibGNsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtYXA6ZGJsY2xpY2snLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBtYXAuYWRkTGlzdGVuZXIoJ3JpZ2h0Y2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21hcDpyaWdodGNsaWNrJywgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1tYXAge1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB6LWluZGV4OiAxO1xyXG5cclxuICAgICYuZ2NzLW1hcC1lZGl0LW1vZGUge1xyXG4gICAgICAgIGN1cnNvcjogY3Jvc3NoYWlyO1xyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc01hcC52dWU/NzY0YWRiOGNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgdmFyIGNsaWVudCA9IF9yZWYuY2xpZW50O1xuICB2YXIga2V5ID0gX3JlZi5rZXk7XG4gIHZhciBsYW5ndWFnZSA9IF9yZWYubGFuZ3VhZ2U7XG4gIHZhciBfcmVmJGxpYnJhcmllcyA9IF9yZWYubGlicmFyaWVzO1xuICB2YXIgbGlicmFyaWVzID0gX3JlZiRsaWJyYXJpZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3JlZiRsaWJyYXJpZXM7XG4gIHZhciBfcmVmJHRpbWVvdXQgPSBfcmVmLnRpbWVvdXQ7XG4gIHZhciB0aW1lb3V0ID0gX3JlZiR0aW1lb3V0ID09PSB1bmRlZmluZWQgPyAxMDAwMCA6IF9yZWYkdGltZW91dDtcbiAgdmFyIHYgPSBfcmVmLnY7XG5cbiAgdmFyIGNhbGxiYWNrTmFtZSA9ICdfX2dvb2dsZU1hcHNBcGlPbkxvYWRDYWxsYmFjayc7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgIC8vIEV4aXQgaWYgbm90IHJ1bm5pbmcgaW5zaWRlIGEgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDYW4gb25seSBsb2FkIHRoZSBHb29nbGUgTWFwcyBBUEkgaW4gdGhlIGJyb3dzZXInKSk7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSB0aGUgYHNjcmlwdGAgdGFnIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHBhZ2UuXG4gICAgdmFyIHNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB2YXIgcGFyYW1zID0gWydjYWxsYmFjaz0nICsgY2FsbGJhY2tOYW1lXTtcbiAgICBpZiAoY2xpZW50KSBwYXJhbXMucHVzaCgnY2xpZW50PScgKyBjbGllbnQpO1xuICAgIGlmIChrZXkpIHBhcmFtcy5wdXNoKCdrZXk9JyArIGtleSk7XG4gICAgaWYgKGxhbmd1YWdlKSBwYXJhbXMucHVzaCgnbGFuZ3VhZ2U9JyArIGxhbmd1YWdlKTtcbiAgICBsaWJyYXJpZXMgPSBbXS5jb25jYXQobGlicmFyaWVzKTsgLy8gRW5zdXJlIHRoYXQgYGxpYnJhcmllc2AgaXMgYW4gYXJyYXlcbiAgICBpZiAobGlicmFyaWVzLmxlbmd0aCkgcGFyYW1zLnB1c2goJ2xpYnJhcmllcz0nICsgbGlicmFyaWVzLmpvaW4oJywnKSk7XG4gICAgaWYgKHYpIHBhcmFtcy5wdXNoKCd2PScgKyB2KTtcbiAgICBzY3JpcHRFbGVtZW50LnNyYyA9ICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/JyArIHBhcmFtcy5qb2luKCcmJyk7XG5cbiAgICAvLyBUaW1lb3V0IGlmIG5lY2Vzc2FyeS5cbiAgICB2YXIgdGltZW91dElkID0gbnVsbDtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKCkge307IC8vIFNldCB0aGUgb24gbG9hZCBjYWxsYmFjayB0byBhIG5vLW9wLlxuICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCB0aGUgR29vZ2xlIE1hcHMgQVBJJykpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgLy8gSG9vayB1cCB0aGUgb24gbG9hZCBjYWxsYmFjay5cbiAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHdpbmRvdy5nb29nbGUubWFwcyk7XG4gICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrTmFtZV07XG4gICAgfTtcblxuICAgIC8vIEluc2VydCB0aGUgYHNjcmlwdGAgdGFnLlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0RWxlbWVudCk7XG4gIH0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2FkLWdvb2dsZS1tYXBzLWFwaS9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IGFzc2lnbiBmcm9tICdkZWVwLWFzc2lnbic7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBHb29nbGUgTWFwcyBpbnN0YW5jZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hcCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtYXApIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfTUFQJywgbWFwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgZWxlbWVudCB0aGUgbWFwIGlzIHJlbmRlcmVkIGludG9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXBFbCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBtYXBFbCkge1xyXG4gICAgZGlzcGF0Y2goJ1NFVF9NQVBfRUwnLCBtYXBFbCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1hcCBsb2FkZWQgZmxhZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hcExvYWRlZCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBsb2FkZWQpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfTUFQX0xPQURFRCcsIGxvYWRlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHdheXBvaW50cyBhcmUgdmlzaWJsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFdheXBvaW50c1Zpc2libGUoeyBkaXNwYXRjaCwgc3RhdGUgfSwgdmlzaWJsZSkge1xyXG4gICAgZGlzcGF0Y2goJ1NFVF9XQVlQT0lOVFNfVklTSUJMRScsIHZpc2libGUpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBXYW1WXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0V2Ftdih7IGRpc3BhdGNoLCBzdGF0ZSB9LCB3YW12KSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX1dBTVYnLCB3YW12KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgV2FtViBhcm1lZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFdhbXZBcm1lZCh7IGRpc3BhdGNoLCBzdGF0ZSB9LCBhcm1lZCkge1xyXG4gICAgZGlzcGF0Y2goJ1NFVF9XQU1WX0FSTUVEJywgYXJtZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBXYW1WIG1vdmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFdhbXZNb2RlKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIG1vZGUpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfV0FNVl9NT0RFJywgbW9kZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHNldHRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0U2V0dGluZ3MoeyBkaXNwYXRjaCwgc3RhdGUgfSwgc2V0dGluZ3MpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfU0VUVElOR1MnLCBzZXR0aW5ncyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1pc3Npb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0TWlzc2lvbnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgbWlzc2lvbnMpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfTUlTU0lPTlMnLCBtaXNzaW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGN1cnJlbnQgbWlzc2lvbiBpbmRleFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldEN1cnJlbnRNaXNzaW9uSW5kZXgoeyBkaXNwYXRjaCwgc3RhdGUgfSwgaW5kZXgpIHtcclxuICAgIGRpc3BhdGNoKCdTRVRfQ1VSUkVOVF9NSVNTSU9OX0lOREVYJywgaW5kZXgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBjdXJyZW50IG1pc3Npb24gdGl0bGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXJyZW50TWlzc2lvblRpdGxlKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIHRpdGxlKSB7XHJcbiAgICBkaXNwYXRjaCgnU0VUX0NVUlJFTlRfTUlTU0lPTl9USVRMRScsIHRpdGxlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgcGFyYW1ldGVyc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBhcmFtZXRlcnMoeyBkaXNwYXRjaCwgc3RhdGUgfSwgcGFyYW1ldGVycykge1xyXG4gICAgZGlzcGF0Y2goJ1NFVF9QQVJBTUVURVJTJywgcGFyYW1ldGVycyk7XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvc3RvcmUvYWN0aW9ucy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iaiA9IHJlcXVpcmUoJ2lzLW9iaicpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdTb3VyY2VzIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25LZXkodG8sIGZyb20sIGtleSkge1xuXHR2YXIgdmFsID0gZnJvbVtrZXldO1xuXG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSkge1xuXHRcdGlmICh0b1trZXldID09PSB1bmRlZmluZWQgfHwgdG9ba2V5XSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0ICgnICsga2V5ICsgJyknKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkgfHwgIWlzT2JqKHZhbCkpIHtcblx0XHR0b1trZXldID0gdmFsO1xuXHR9IGVsc2Uge1xuXHRcdHRvW2tleV0gPSBhc3NpZ24oT2JqZWN0KHRvW2tleV0pLCBmcm9tW2tleV0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbih0bywgZnJvbSkge1xuXHRpZiAodG8gPT09IGZyb20pIHtcblx0XHRyZXR1cm4gdG87XG5cdH1cblxuXHRmcm9tID0gT2JqZWN0KGZyb20pO1xuXG5cdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0YXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdGFzc2lnbktleSh0bywgZnJvbSwgc3ltYm9sc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0KSB7XG5cdHRhcmdldCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRhc3NpZ24odGFyZ2V0LCBhcmd1bWVudHNbc10pO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kZWVwLWFzc2lnbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHZhciB0eXBlID0gdHlwZW9mIHg7XG5cdHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pcy1vYmovaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGZ1bmN0aW9uIGdldE1hcChzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1hcDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcEVsKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWFwRWw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBMb2FkZWQoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tYXBMb2FkZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXYXlQb2ludHNWaXNpYmxlKHN0YXRlKXtcclxuICAgIHJldHVybiBzdGF0ZS53YXlwb2ludHNWaXNpYmxlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwRWRpdGluZyhzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1hcExvYWRlZCAmJiBzdGF0ZS53YW12Lm1vZGUgIT0gJ2F1dG8nICYmIHN0YXRlLndheXBvaW50c1Zpc2libGU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXYW12KHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUud2FtdjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNldHRpbmdzKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUuc2V0dGluZ3M7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXR0aW5nc0xhc3RVcGRhdGVUaW1lKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUuc2V0dGluZ3NMYXN0VXBkYXRlVGltZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pc3Npb25zKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWlzc2lvbnM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNaXNzaW9uc0xhc3RVcGRhdGVUaW1lKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUubWlzc2lvbnNMYXN0VXBkYXRlVGltZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5jdXJyZW50TWlzc2lvbkluZGV4O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudE1pc3Npb24oc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5taXNzaW9uc1tzdGF0ZS5jdXJyZW50TWlzc2lvbkluZGV4XTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5wYXJhbWV0ZXJzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyc0xhc3RVcGRhdGVUaW1lKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUucGFyYW1ldGVyc0xhc3RVcGRhdGVUaW1lO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3N0b3JlL2dldHRlcnMuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLW1hcFxcXCIgaWQ9XFxcIm1hcFxcXCIgOmNsYXNzPVxcXCJ7ICdnY3MtbWFwLWVkaXQtbW9kZSc6IG1hcEVkaXRpbmcgfVxcXCI+PC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcz8tdXJsIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNYXBDb250cm9scy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NNYXBDb250cm9scy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWFwXFxcXEdjc01hcENvbnRyb2xzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01hcENvbnRyb2xzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTQ3NWFlMjBhL0djc01hcENvbnRyb2xzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBDb250cm9scy52dWVcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwQ29udHJvbHMudnVlXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3MtbWFwLWNvbnRyb2xzXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInBhbi1jb250cm9sc1wiPlxyXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgdXBcIiBpY29uPVwia2V5Ym9hcmRfYXJyb3dfdXBcIiBAY2xpY2s9XCJwYW4oJ3VwJylcIlxyXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJwYW4tY29udHJvbCByaWdodFwiIGljb249XCJrZXlib2FyZF9hcnJvd19yaWdodFwiIEBjbGljaz1cInBhbigncmlnaHQnKVwiXHJcbiAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG5cclxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInBhbi1jb250cm9sIGRvd25cIiBpY29uPVwia2V5Ym9hcmRfYXJyb3dfZG93blwiIEBjbGljaz1cInBhbignZG93bicpXCJcclxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgIGNsYXNzPVwicGFuLWNvbnRyb2wgbGVmdFwiIGljb249XCJrZXlib2FyZF9hcnJvd19sZWZ0XCIgQGNsaWNrPVwicGFuKCdsZWZ0JylcIlxyXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJwYW4tY29udHJvbCBjZW50ZXJcIiBpY29uPVwibXlfbG9jYXRpb25cIiBAY2xpY2s9XCJwYW4oJ2NlbnRlcicpXCJcclxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLWNvbnRyb2xzXCI+XHJcbiAgICAgICAgICAgIDx1aS1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ6b29tLWNvbnRyb2wgaW5cIiBpY29uPVwiYWRkXCIgQGNsaWNrPVwiem9vbSgnaW4nKVwiXHJcbiAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG5cclxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInpvb20tY29udHJvbCBvdXRcIiBpY29uPVwicmVtb3ZlXCIgQGNsaWNrPVwiem9vbSgnb3V0JylcIlxyXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInR5cGUtY29udHJvbFwiPlxyXG4gICAgICAgICAgICA8dWktYnV0dG9uXHJcbiAgICAgICAgICAgICAgICA6bWVudS1vcHRpb25zPVwibWFwVHlwZXNNZW51XCIgbmFtZT1cIm1hcF90eXBlc1wiIDp0ZXh0PVwibWFwVHlwZVwiXHJcbiAgICAgICAgICAgICAgICBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XCJjaGFuZ2VNYXBUeXBlXCIgaGFzLWRyb3Bkb3duLW1lbnUgcmFpc2VkXHJcbiAgICAgICAgICAgICAgICBkcm9wZG93bi1wb3NpdGlvbj1cInRvcCByaWdodFwiIDpzaG93LWRyb3Bkb3duLWljb249XCJmYWxzZVwiXHJcbiAgICAgICAgICAgID48L3VpLWJ1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXBUeXBlOiAnU2F0ZWxsaXRlJyxcclxuICAgICAgICAgICAgbWFwVHlwZXNNZW51OiBbXHJcbiAgICAgICAgICAgICAgICB7ICd2YWx1ZSc6ICdST0FETUFQJywgICB0ZXh0OiAnUm9hZCcgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgeyAndmFsdWUnOiAnVEVSUkFJTicsICAgdGV4dDogJ1RlcnJhaW4nICAgfSxcclxuICAgICAgICAgICAgICAgIHsgJ3ZhbHVlJzogJ1NBVEVMTElURScsIHRleHQ6ICdTYXRlbGxpdGUnIH0sXHJcbiAgICAgICAgICAgICAgICB7ICd2YWx1ZSc6ICdIWUJSSUQnLCAgICB0ZXh0OiAnSHlicmlkJyAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgcGFuKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbWFwOjpwYW4tJyArIGRpcmVjdGlvbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgem9vbSh0eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdtYXA6Onpvb20tJyArIHR5cGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNoYW5nZU1hcFR5cGUoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXBUeXBlID0gc2VsZWN0ZWQudGV4dDtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21hcDo6Y2hhbmdlLXR5cGUnLCBzZWxlY3RlZC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLW1hcC1jb250cm9scyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBib3R0b206IDI0cHg7XHJcbiAgICByaWdodDogMTJweDtcclxuICAgIHotaW5kZXg6IDE7XHJcblxyXG4gICAgLnBhbi1jb250cm9scyB7XHJcbiAgICAgICAgd2lkdGg6IDEwMHB4O1xyXG4gICAgICAgIGhlaWdodDogMTAwcHg7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIC5wYW4tY29udHJvbCB7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIHdpZHRoOiAzMnB4O1xyXG4gICAgICAgIGhlaWdodDogMzJweDtcclxuICAgICAgICBwYWRkaW5nOiAwO1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XHJcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggNXB4IDAgYWxwaGEoYmxhY2ssIDAuMiksIDAgMnB4IDEwcHggMCBhbHBoYShibGFjaywgMC4xNik7XHJcbiAgICAgICAgLXdlYmtpdC1tYXNrLWltYWdlOiBub25lO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlIWltcG9ydGFudDtcclxuXHJcbiAgICAgICAgJi51cCB7XHJcbiAgICAgICAgICAgIHRvcDogMDtcclxuICAgICAgICAgICAgbGVmdDogMzRweDtcclxuICAgICAgICAgICAgcmlnaHQ6IGF1dG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAmLmRvd24ge1xyXG4gICAgICAgICAgICBib3R0b206IDA7XHJcbiAgICAgICAgICAgIGxlZnQ6IDM0cHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAmLmxlZnQge1xyXG4gICAgICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgICAgICB0b3A6IDM0cHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAmLnJpZ2h0IHtcclxuICAgICAgICAgICAgcmlnaHQ6IDA7XHJcbiAgICAgICAgICAgIHRvcDogMzRweDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYuY2VudGVyIHtcclxuICAgICAgICAgICAgdG9wOiAzNHB4O1xyXG4gICAgICAgICAgICBsZWZ0OiAzNHB4O1xyXG5cclxuICAgICAgICAgICAgLnVpLWljb24ge1xyXG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC56b29tLWNvbnRyb2xzIHtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDhweDtcclxuICAgICAgICBib3gtc2hhZG93OiAwIDJweCA1cHggMCBhbHBoYShibGFjaywgMC4yKSwgMCAycHggMTBweCAwIGFscGhhKGJsYWNrLCAwLjE2KTtcclxuXHJcbiAgICAgICAgLnpvb20tY29udHJvbCB7XHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XHJcbiAgICAgICAgICAgIHdpZHRoOiA1MHB4O1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDI4cHg7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlIWltcG9ydGFudFxyXG5cclxuICAgICAgICAgICAgJi5pbiB7XHJcbiAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjQ0NDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC50eXBlLWNvbnRyb2wge1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDhweDtcclxuXHJcbiAgICAgICAgLnVpLWJ1dHRvbiB7XHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XHJcbiAgICAgICAgICAgIHdpZHRoOiAxMDBweDtcclxuICAgICAgICAgICAgaGVpZ2h0OiAzMnB4O1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzTWFwQ29udHJvbHMudnVlP2E4Y2U2MjUwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1tYXAtY29udHJvbHNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW4tY29udHJvbHNcXFwiPlxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInBhbi1jb250cm9sIHVwXFxcIiBpY29uPVxcXCJrZXlib2FyZF9hcnJvd191cFxcXCIgQGNsaWNrPVxcXCJwYW4oJ3VwJylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJwYW4tY29udHJvbCByaWdodFxcXCIgaWNvbj1cXFwia2V5Ym9hcmRfYXJyb3dfcmlnaHRcXFwiIEBjbGljaz1cXFwicGFuKCdyaWdodCcpXFxcIlxcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICBjbGFzcz1cXFwicGFuLWNvbnRyb2wgZG93blxcXCIgaWNvbj1cXFwia2V5Ym9hcmRfYXJyb3dfZG93blxcXCIgQGNsaWNrPVxcXCJwYW4oJ2Rvd24nKVxcXCJcXG4gICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInBhbi1jb250cm9sIGxlZnRcXFwiIGljb249XFxcImtleWJvYXJkX2Fycm93X2xlZnRcXFwiIEBjbGljaz1cXFwicGFuKCdsZWZ0JylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJwYW4tY29udHJvbCBjZW50ZXJcXFwiIGljb249XFxcIm15X2xvY2F0aW9uXFxcIiBAY2xpY2s9XFxcInBhbignY2VudGVyJylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInpvb20tY29udHJvbHNcXFwiPlxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcInpvb20tY29udHJvbCBpblxcXCIgaWNvbj1cXFwiYWRkXFxcIiBAY2xpY2s9XFxcInpvb20oJ2luJylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgIDx1aS1pY29uLWJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ6b29tLWNvbnRyb2wgb3V0XFxcIiBpY29uPVxcXCJyZW1vdmVcXFwiIEBjbGljaz1cXFwiem9vbSgnb3V0JylcXFwiXFxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInR5cGUtY29udHJvbFxcXCI+XFxuICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgOm1lbnUtb3B0aW9ucz1cXFwibWFwVHlwZXNNZW51XFxcIiBuYW1lPVxcXCJtYXBfdHlwZXNcXFwiIDp0ZXh0PVxcXCJtYXBUeXBlXFxcIlxcbiAgICAgICAgICAgIEBtZW51LW9wdGlvbi1zZWxlY3RlZD1cXFwiY2hhbmdlTWFwVHlwZVxcXCIgaGFzLWRyb3Bkb3duLW1lbnUgcmFpc2VkXFxuICAgICAgICAgICAgZHJvcGRvd24tcG9zaXRpb249XFxcInRvcCByaWdodFxcXCIgOnNob3ctZHJvcGRvd24taWNvbj1cXFwiZmFsc2VcXFwiXFxuICAgICAgICA+PC91aS1idXR0b24+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFwL0djc01hcENvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcz8tdXJsIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9HY3NNYXBTaWRlYmFyLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0djc01hcFNpZGViYXIudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcFxcXFxHY3NNYXBTaWRlYmFyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01hcFNpZGViYXIudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtN2ZjY2Y0YjIvR2NzTWFwU2lkZWJhci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwU2lkZWJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzTWFwU2lkZWJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImdjcy1tYXAtc2lkZWJhclwiIHYtc2hvdz1cInNob3dTaWRlYmFyXCIgdHJhbnNpdGlvbj1cInNpZGViYXItY29sbGFwc2VcIj5cclxuICAgICAgICA8Z2NzLW1pc3Npb25zPjwvZ2NzLW1pc3Npb25zPlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgR2NzTWlzc2lvbnMgZnJvbSAnbWlzc2lvbi9HY3NNaXNzaW9ucy52dWUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBzaG93U2lkZWJhcjoge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY29tcG9uZW50czoge1xyXG4gICAgICAgIEdjc01pc3Npb25zXHJcbiAgICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3MtbWFwLXNpZGViYXIge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgd2lkdGg6IDM2MHB4O1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG5cclxuICAgIHRvcDogMDtcclxuICAgIGxlZnQ6IDA7XHJcbiAgICB6LWluZGV4OiAxO1xyXG5cclxuICAgIG92ZXJmbG93LXk6IGF1dG87XHJcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XHJcblxyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcbiAgICBib3gtc2hhZG93OiAwIDAgNHB4IGFscGhhKGJsYWNrLCAwLjM1KSwgMCAycHggM3B4IGFscGhhKGJsYWNrLCAwLjIpO1xyXG59XHJcblxyXG4uc2lkZWJhci1jb2xsYXBzZS10cmFuc2l0aW9uIHtcclxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XHJcbn1cclxuXHJcbi5zaWRlYmFyLWNvbGxhcHNlLWVudGVyLFxyXG4uc2lkZWJhci1jb2xsYXBzZS1sZWF2ZSB7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTM2MHB4KTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNYXBTaWRlYmFyLnZ1ZT83NzQ3YTM0YVxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01pc3Npb25zLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0djc01pc3Npb25zLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtaXNzaW9uXFxcXEdjc01pc3Npb25zLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01pc3Npb25zLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTAwOTc2N2M0L0djc01pc3Npb25zLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbnMudnVlXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlcj8tdXJsIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9ucy52dWVcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImdjcy1taXNzaW9uc1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaWRlYmFyLXBhZ2VcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1pc3Npb25zLWxpc3RcIiB2LWlmPVwiY3VycmVudFZpZXcgPT09ICdsaXN0aW5nJ1wiPlxyXG4gICAgICAgICAgICAgICAgPHVpLXRvb2xiYXIgdGl0bGU9XCJNaXNzaW9uc1wiIGhpZGUtbmF2LWljb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzbG90PVwiYWN0aW9uc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJhZGRcIiB0b29sdGlwPVwiQWRkIG1pc3Npb25cIiBAY2xpY2s9XCJhZGRNaXNzaW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJmaWxlX2Rvd25sb2FkXCIgdG9vbHRpcD1cIkRvd25sb2FkIG1pc3Npb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwiZG93bmxvYWRNaXNzaW9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjbGVhclwiIGljb249XCJtb3JlX3ZlcnRcIiBoYXMtZHJvcGRvd24tbWVudVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24tcG9zaXRpb249XCJib3R0b20gcmlnaHRcIiA6bWVudS1vcHRpb25zPVwib3ZlcmZsb3dNZW51XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtZW51LW9wdGlvbi1zZWxlY3RlZD1cIm1lbnVPcHRpb25TZWxlY3RlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC91aS10b29sYmFyPlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzaWRlYmFyLXBhZ2UtY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJibGFuay1zdGF0ZVwiIHYtaWY9XCIhbWlzc2lvbnMubGVuZ3RoXCI+Tm8gbWlzc2lvbnM8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGdjcy1taXNzaW9uLXJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LWZvcj1cIihpbmRleCwgbWlzc2lvbikgaW4gbWlzc2lvbnNcIiA6aW5kZXg9XCJpbmRleFwiIDptaXNzaW9uPVwibWlzc2lvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInNlbGVjdE1pc3Npb24oaW5kZXgpXCJcclxuICAgICAgICAgICAgICAgICAgICA+PC9nY3MtbWlzc2lvbi1yb3c+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8Y29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICB2LWVsc2UgOmlzPVwiY3VycmVudFZpZXdcIiA6bWlzc2lvbj1cImN1cnJlbnRNaXNzaW9uXCIgQGdvLWJhY2s9XCJzaG93TGlzdGluZ1ZpZXdcIlxyXG4gICAgICAgICAgICA+PC9jb21wb25lbnQ+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDwhLS0gaGlkZGVuIGlucHV0IGVsZW1lbnQgdXNlZCBmb3Igc2VsZWN0aW5nIGEgZmlsZSB0byBpbXBvcnQgZnJvbSAtLT5cclxuICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGlkPVwiaW1wb3J0X21pc3Npb25zX2lucHV0XCIgQGNoYW5nZT1cImltcG9ydE1pc3Npb25cIj5cclxuICAgIDwhLS0gaGlkZGVuIGxpbmsgdXNlZCBmb3IgcHJvbXB0aW5nIGEgZG93bmxvYWQgLS0+XHJcbiAgICA8YSBpZD1cImV4cG9ydF9taXNzaW9uc19saW5rXCI+PC9hPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEdjc01pc3Npb24gZnJvbSAnbWlzc2lvbi9HY3NNaXNzaW9uLnZ1ZSc7XHJcbmltcG9ydCBHY3NNaXNzaW9uUm93IGZyb20gJ21pc3Npb24vR2NzTWlzc2lvblJvdy52dWUnO1xyXG5cclxuaW1wb3J0IHsgc2V0TWlzc2lvbnMsIHNldEN1cnJlbnRNaXNzaW9uSW5kZXggfSBmcm9tICdzdG9yZS9hY3Rpb25zJztcclxuaW1wb3J0IHsgZ2V0V2FtdiwgZ2V0TWlzc2lvbnMsIGdldEN1cnJlbnRNaXNzaW9uSW5kZXgsIGdldEN1cnJlbnRNaXNzaW9uIH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgZ2V0dGVyczoge1xyXG4gICAgICAgICAgICB3YW12OiAgICAgICAgICAgICAgICBnZXRXYW12LFxyXG4gICAgICAgICAgICBtaXNzaW9uczogICAgICAgICAgICBnZXRNaXNzaW9ucyxcclxuICAgICAgICAgICAgY3VycmVudE1pc3Npb25JbmRleDogZ2V0Q3VycmVudE1pc3Npb25JbmRleCxcclxuICAgICAgICAgICAgY3VycmVudE1pc3Npb246ICAgICAgZ2V0Q3VycmVudE1pc3Npb25cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIHNldE1pc3Npb25zLFxyXG4gICAgICAgICAgICBzZXRDdXJyZW50TWlzc2lvbkluZGV4XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3OiAnbGlzdGluZycsXHJcbiAgICAgICAgICAgIG92ZXJmbG93TWVudTogW1xyXG4gICAgICAgICAgICAgICAgeyBpZDogJ3NhdmUnLCAgIHRleHQ6ICdTYXZlIHRvIHNlcnZlcicgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHsgaWQ6ICdsb2FkJywgICB0ZXh0OiAnTG9hZCBmcm9tIHNlcnZlcicgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnc2VwMScsICAgdGV4dDogJycsICAgICAgICAgICAgICAgIHR5cGU6ICdkaXZpZGVyJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2V4cG9ydCcsIHRleHQ6ICdFeHBvcnQgdG8gZmlsZScgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHsgaWQ6ICdpbXBvcnQnLCB0ZXh0OiAnSW1wb3J0IGZyb20gZmlsZScgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnc2VwMicsICAgdGV4dDogJycsICAgICAgICAgICAgICAgIHR5cGU6ICdkaXZpZGVyJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBpZDogJ2NsZWFyJywgIHRleHQ6ICdDbGVhciBhbGwnICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHNlbGVjdE1pc3Npb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlzc2lvbkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICdnY3MtbWlzc2lvbic7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2hvd0xpc3RpbmdWaWV3KCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ2xpc3RpbmcnO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaXNzaW9uSW5kZXgoLTEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZE1pc3Npb24oKXtcclxuICAgICAgICAgICAgdGhpcy5taXNzaW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnTWlzc2lvbiAnICsgKHRoaXMubWlzc2lvbnMubGVuZ3RoICsgMSksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IHtsYXQ6IHRoaXMud2Ftdi5wb3NpdGlvbi5sYXQsIGxuZzogdGhpcy53YW12LnBvc2l0aW9uLmxuZ30sXHJcbiAgICAgICAgICAgICAgICB3YXlwb2ludHM6IFtdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRvd25sb2FkTWlzc2lvbigpIHtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWVudDo6Z2V0X21pc3Npb24nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZW51T3B0aW9uU2VsZWN0ZWQob3B0aW9uKXtcclxuICAgICAgICAgICAgc3dpdGNoIChvcHRpb24uaWQpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2F2ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWVudDo6c2V0X21pc3Npb25zJywgdGhpcy5taXNzaW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb2FkJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpZW50OjpnZXRfbWlzc2lvbnMnKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBmaWxlIHNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbXBvcnRfbWlzc2lvbnNfaW5wdXQnKS5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGF0YSBVUklcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJpID0gJ2RhdGE6YXBwbGljYXRpb24vanNvbiwnO1xyXG4gICAgICAgICAgICAgICAgICAgIHVyaSArPSBKU09OLnN0cmluZ2lmeSh0aGlzLm1pc3Npb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB1cmkgPSBlbmNvZGVVUkkodXJpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbGluayB0byB1c2UgZm9yIGRvd25sb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhwb3J0X21pc3Npb25zX2xpbmsnKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay5kb3dubG9hZCA9ICdtaXNzaW9ucy5qc29uJztcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGRvd25sb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgbGluay5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2xlYXInOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnMoW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaW1wb3J0TWlzc2lvbigpe1xyXG4gICAgICAgICAgICBsZXQgZmlsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1wb3J0X21pc3Npb25zX2lucHV0JykuZmlsZXM7XHJcbiAgICAgICAgICAgIC8vIEdldCBmaWxlIGNvbnRlbnRzXHJcbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNwZWNpZnkgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGZpbGUgaGFzIGJlZW4gcmVhZFxyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRzID0gZS50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdNaXNzaW9ucyA9IEpTT04ucGFyc2UoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNNaXNzaW9uTGlzdChuZXdNaXNzaW9ucykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgY29udGVudCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWxpZCBtaXNzaW9uIGxpc3QnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2lvbnMobmV3TWlzc2lvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIGNvbnRlbnQgaXMgbm90IHZhbGlkIEpTT046ICcgKyBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmaWxlIHJlYWRcclxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNNaXNzaW9uTGlzdChkYXRhKXtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pc3Npb24gPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtaXNzaW9uICE9ICdvYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG1pc3Npb24udGl0bGUgIT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbWlzc2lvbi5vcmlnaW4gIT0gJ29iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbWlzc2lvbi5vcmlnaW4ubGF0ICE9ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG1pc3Npb24ub3JpZ2luLmxuZyAhPSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KG1pc3Npb24ud2F5cG9pbnRzKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW9uLndheXBvaW50cy5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdwID0gbWlzc2lvbi53YXlwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cCAhPSAnb2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhd3AuaGFzT3duUHJvcGVydHkoJ3RpdGxlJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdwLnRpdGxlICE9ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF3cC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3cC50eXBlICE9ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF3cC5oYXNPd25Qcm9wZXJ0eSgncG9zaXRpb24nKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd3AucG9zaXRpb24gIT0gJ29iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXdwLnBvc2l0aW9uLmhhc093blByb3BlcnR5KCdsYXQnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd3AucG9zaXRpb24ubGF0ICE9ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF3cC5wb3NpdGlvbi5oYXNPd25Qcm9wZXJ0eSgnbG5nJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdwLnBvc2l0aW9uLmxuZyAhPSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICAnZGVsZXRlLW1pc3Npb24nKGluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy5taXNzaW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdkZWxldGUtd2F5cG9pbnQnKGluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlzc2lvbi53YXlwb2ludHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBHY3NNaXNzaW9uLFxyXG4gICAgICAgIEdjc01pc3Npb25Sb3dcclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1taXNzaW9ucyxcclxuLm1pc3Npb25zLWxpc3Qge1xyXG4gICAgaGVpZ2h0OiAxMDAlXHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG59XHJcblxyXG4jaW1wb3J0X21pc3Npb25zX2lucHV0LFxyXG4jZXhwb3J0X21pc3Npb25zX2xpbmsge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNaXNzaW9ucy52dWU/NjMwNjE2MjZcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1FVEEgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgc2V0RGVzYyAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24oaXQpe1xuICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9fSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01pc3Npb24udnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWlzc2lvbi52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWlzc2lvblxcXFxHY3NNaXNzaW9uLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01pc3Npb24udnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYjVlZWVjYjYvR2NzTWlzc2lvbi52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb24udnVlXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXI/LXVybCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3MtbWlzc2lvblwiPlxyXG4gICAgICAgIDx1aS10b29sYmFyIDp0aXRsZT1cIm1pc3Npb24udGl0bGVcIiBoaWRlLW5hdi1pY29uIHNob3ctYnJhbmQgOnNob3ctYnJhbmQtZGl2aWRlcj1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgIDxkaXYgc2xvdD1cImJyYW5kXCI+XHJcbiAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJnb0JhY2tcIiB0eXBlPVwiY2xlYXJcIiBpY29uPVwiYXJyb3dfYmFja1wiIHRvb2x0aXA9XCJCYWNrIHRvIE1pc3Npb25zXCJcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLXBvc2l0aW9uPVwiYm90dG9tIGxlZnRcIlxyXG4gICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBzbG90PVwiYWN0aW9uc1wiPlxyXG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNsZWFyXCIgaWNvbj1cImZpbGVfdXBsb2FkXCIgdG9vbHRpcD1cIlVwbG9hZCBtaXNzaW9uXCIgQGNsaWNrPVwidXBsb2FkTWlzc2lvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiIXdheXBvaW50c1Zpc2libGVcIlxyXG4gICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNsZWFyXCIgOmljb249XCJ3YXlwb2ludHNWaXNpYmxlID8gJ3Zpc2liaWxpdHknIDogJ3Zpc2liaWxpdHlfb2ZmJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwidG9nZ2xlV2F5cG9pbnRWaXNpYmlsaXR5XCJcclxuICAgICAgICAgICAgICAgICAgICA6dG9vbHRpcD1cIndheXBvaW50c1Zpc2libGUgPyAnSGlkZSB3YXlwb2ludHMnIDogJ1Nob3cgd2F5cG9pbnRzJ1wiXHJcbiAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2xlYXJcIiBpY29uPVwibW9yZV92ZXJ0XCIgaGFzLWRyb3Bkb3duLW1lbnUgZHJvcGRvd24tcG9zaXRpb249XCJib3R0b20gcmlnaHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIDptZW51LW9wdGlvbnM9XCJvdmVyZmxvd01lbnVcIiBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XCJvdmVyZmxvd01lbnVPcHRpb25TZWxlY3RlZFwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC91aS10b29sYmFyPlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwic2lkZWJhci1wYWdlLWNvbnRlbnRcIiB2LWVsOnBhZ2UtY29udGVudD5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBvcmlnaW4tcm93XCI+XHJcbiAgICAgICAgICAgICAgICA8dWktdGV4dGJveFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiY29sdW1uIG9uZS1oYWxmXCIgbGFiZWw9XCJPcmlnaW4gTGF0aXR1ZGVcIiBuYW1lPVwibGF0aXR1ZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIDp2YWx1ZS5zeW5jPVwibWlzc2lvbi5vcmlnaW4ubGF0XCIgdHlwZT1cIm51bWJlclwiIDpzdGVwPVwiMC4wMDAwMVwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxyXG4gICAgICAgICAgICAgICAgPHVpLXRleHRib3hcclxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbHVtbiBvbmUtaGFsZlwiIGxhYmVsPVwiT3JpZ2luIExvbmdpdHVkZVwiIG5hbWU9XCJsb25naXR1ZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIDp2YWx1ZS5zeW5jPVwibWlzc2lvbi5vcmlnaW4ubG5nXCIgdHlwZT1cIm51bWJlclwiIDpzdGVwPVwiMC4wMDAwMVwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxnY3Mtb3JpZ2luXHJcbiAgICAgICAgICAgICAgICA6bGF0LnN5bmM9XCJtaXNzaW9uLm9yaWdpbi5sYXRcIiA6bG5nLnN5bmM9XCJtaXNzaW9uLm9yaWdpbi5sbmdcIlxyXG4gICAgICAgICAgICAgICAgOnNjYWxlPVwiNVwiIDpkcmFnZ2FibGU9XCJtYXBFZGl0aW5nXCJcclxuICAgICAgICAgICAgPjwvZ2NzLW9yaWdpbj5cclxuXHJcbiAgICAgICAgICAgIDxwXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cIm5vLXdheXBvaW50c1wiIHYtaWY9XCIhbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXCJcclxuICAgICAgICAgICAgPk5vIHdheXBvaW50cyBmb3IgdGhpcyBtaXNzaW9uLiBDbGljayB0aGUgbWFwIHRvIGFkZCBhIHdheXBvaW50LjwvcD5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgdi1lbHNlPlxyXG4gICAgICAgICAgICAgICAgPGdjcy13YXlwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKGluZGV4LCB3YXlwb2ludCkgaW4gbWlzc2lvbi53YXlwb2ludHNcIiA6aW5kZXg9XCJpbmRleFwiIDppZD1cIid3YXlwb2ludC0nICsgaW5kZXhcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpsYWJlbD1cInRvTGV0dGVyKGluZGV4ICsgMSlcIiA6dGl0bGUuc3luYz1cIndheXBvaW50LnRpdGxlXCIgOndheXBvaW50LXR5cGU9XCJ3YXlwb2ludC50eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICA6bGF0LnN5bmM9XCJ3YXlwb2ludC5wb3NpdGlvbi5sYXRcIiA6bG5nLnN5bmM9XCJ3YXlwb2ludC5wb3NpdGlvbi5sbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpyb3RhdGlvbj1cIndheXBvaW50LnJvdGF0aW9uXCIgOnNjYWxlPVwiMTBcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpkcmFnZ2FibGU9XCJtYXBFZGl0aW5nXCIgOnZpc2libGU9XCJ3YXlwb2ludHNWaXNpYmxlXCJcclxuICAgICAgICAgICAgICAgICAgICBAZGVsZXRlPVwiZGVsZXRlV2F5cG9pbnQoaW5kZXgpXCJcclxuICAgICAgICAgICAgICAgID48L2djcy13YXlwb2ludD5cclxuXHJcbiAgICAgICAgICAgICAgICA8IS0tXHJcbiAgICAgICAgICAgICAgICAgICAgaXQgc2VlbXMsIHdoZW4gd2F5cG9pbnQucG9zaXRpb24gaXMgdXNlZCwgaW5zdGVhZCBvZiB3YXlwb2ludC5wb3NpdGlvbi5sYXQvbG5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5naW5nIHRoZSB3YXlwb2ludC5wb3NpdGlvbi5sYXQvbG5nIGVsc2V3aGVyZSB3b24ndCB0cmlnZ2VyIHVwZGF0ZXMgaGVyZVxyXG4gICAgICAgICAgICAgICAgLS0+XHJcbiAgICAgICAgICAgICAgICA8Z2NzLXdheXBvaW50LWxpbmtcclxuICAgICAgICAgICAgICAgICAgICB2LWZvcj1cIihpbmRleCwgd2F5cG9pbnQpIGluIG1pc3Npb24ud2F5cG9pbnRzXCIgOmluZGV4PVwiaW5kZXhcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpzdGFydC1sYXQ9XCJ3YXlwb2ludC5wb3NpdGlvbi5sYXRcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpzdGFydC1sbmc9XCJ3YXlwb2ludC5wb3NpdGlvbi5sbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgIDplbmQtbGF0PVwibWlzc2lvbi53YXlwb2ludHNbKGluZGV4KzEpICUgbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXS5wb3NpdGlvbi5sYXQ7XCJcclxuICAgICAgICAgICAgICAgICAgICA6ZW5kLWxuZz1cIm1pc3Npb24ud2F5cG9pbnRzWyhpbmRleCsxKSAlIG1pc3Npb24ud2F5cG9pbnRzLmxlbmd0aF0ucG9zaXRpb24ubG5nO1wiXHJcbiAgICAgICAgICAgICAgICAgICAgOnZpc2libGU9XCJ3YXlwb2ludHNWaXNpYmxlXCJcclxuICAgICAgICAgICAgICAgID48L2djcy13YXlwb2ludC1saW5rPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IEdjc1dheXBvaW50IGZyb20gJ21hcmtlcnMvR2NzV2F5cG9pbnQudnVlJztcclxuaW1wb3J0IEdjc1dheXBvaW50TGluayBmcm9tICdtYXJrZXJzL0djc1dheXBvaW50TGluay52dWUnO1xyXG5pbXBvcnQgR2NzT3JpZ2luIGZyb20gJ21hcmtlcnMvR2NzT3JpZ2luLnZ1ZSc7XHJcblxyXG5pbXBvcnQgZWxlbWVudCBmcm9tICd1dGlsL2VsZW1lbnQtc2Nyb2xsJztcclxuaW1wb3J0IG51bWJlclRvTGV0dGVyIGZyb20gJ3V0aWwvbnVtYmVyLXRvLWxldHRlcic7XHJcblxyXG5pbXBvcnQgeyBnZXRNYXBFZGl0aW5nLCBnZXRNaXNzaW9ucywgZ2V0Q3VycmVudE1pc3Npb25JbmRleCwgZ2V0V2F5UG9pbnRzVmlzaWJsZSB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5pbXBvcnQgeyBzZXRXYXlwb2ludHNWaXNpYmxlIH0gZnJvbSAnc3RvcmUvYWN0aW9ucyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgZ2V0dGVyczoge1xyXG4gICAgICAgICAgICBtYXBFZGl0aW5nOiAgICAgICAgICBnZXRNYXBFZGl0aW5nLFxyXG4gICAgICAgICAgICBtaXNzaW9uczogICAgICAgICAgICBnZXRNaXNzaW9ucyxcclxuICAgICAgICAgICAgY3VycmVudE1pc3Npb25JbmRleDogZ2V0Q3VycmVudE1pc3Npb25JbmRleCxcclxuICAgICAgICAgICAgd2F5cG9pbnRzVmlzaWJsZTogICAgZ2V0V2F5UG9pbnRzVmlzaWJsZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgc2V0V2F5cG9pbnRzVmlzaWJsZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBtaXNzaW9uOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dNZW51OiBbXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnZWRpdCcsIHRleHQ6ICdFZGl0IG1pc3Npb24nIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnY2xlYXJfYWxsJywgdGV4dDogJ0NsZWFyIGFsbCB3YXlwb2ludHMnIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgb3JpZ2luVmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGxhc3RTZXRNaXNzaW9uQWNrVGltZTogbnVsbCxcclxuICAgICAgICAgICAgVElNRU9VVDogMTAwMFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgIHRoaXMuc2V0V2F5cG9pbnRzVmlzaWJsZSh0cnVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnNldFdheXBvaW50c1Zpc2libGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgZ29CYWNrKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZ28tYmFjaycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvTGV0dGVyKG51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyVG9MZXR0ZXIobnVtYmVyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b2dnbGVXYXlwb2ludFZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V2F5cG9pbnRzVmlzaWJsZSghdGhpcy53YXlwb2ludHNWaXNpYmxlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZWxldGVXYXlwb2ludChpbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb24ud2F5cG9pbnRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xlYXJXYXlwb2ludHMoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy53YXlwb2ludHNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubWlzc2lvbi53YXlwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zZXRXYXlwb2ludHNWaXNpYmxlKHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwbG9hZE1pc3Npb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1pc3Npb24ub3JpZ2luLmxhdCA8ICAtOTAgfHwgdGhpcy5taXNzaW9uLm9yaWdpbi5sYXQgPiAgOTAgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMubWlzc2lvbi5vcmlnaW4ubG5nIDwgLTE4MCB8fCB0aGlzLm1pc3Npb24ub3JpZ2luLmxuZyA+IDE4MCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpjcmVhdGUtc25hY2tiYXInLCAnTWlzc2lvbiBvcmlnaW4gaXMgb3V0IG9mIHJhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWVudDo6c2V0X21pc3Npb24nLCB0aGlzLm1pc3Npb25zW3RoaXMuY3VycmVudE1pc3Npb25JbmRleF0pO1xyXG4gICAgICAgICAgICAvLyBTaG93IG1lc3NhZ2Ugb24gdGltZW91dFxyXG4gICAgICAgICAgICBsZXQgcmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RTZXRNaXNzaW9uQWNrVGltZSA8IHJlcXVlc3RUaW1lKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpjcmVhdGUtc25hY2tiYXInLCAnTWlzc2lvbiBub3QgdXBsb2FkZWQgd2l0aGluIHRpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcy5USU1FT1VUKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvdmVyZmxvd01lbnVPcHRpb25TZWxlY3RlZChvcHRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbi5pZCA9PT0gJ2VkaXQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpzaG93LWVkaXQtbWlzc2lvbi1tb2RhbCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5pZCA9PT0gJ2NsZWFyX2FsbCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYXlwb2ludHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICAgJ21hcDpjbGljaycoZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWFwRWRpdGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgbGF0ID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxhdCgpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgICAgIGxldCBsbmcgPSBOdW1iZXIoIHBhcnNlRmxvYXQoZS5sYXRMbmcubG5nKCkpLnRvRml4ZWQoNykgKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBuZXdXYXlwb2ludCA9IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnJyxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdnb190b19wb2ludCcsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhdCxcclxuICAgICAgICAgICAgICAgICAgICBsbmdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWlzc2lvbi53YXlwb2ludHMucHVzaChuZXdXYXlwb2ludCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTY3JvbGwgdG8gYm90dG9tXHJcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9FbmQodGhpcy4kZWxzLnBhZ2VDb250ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDpkYmxjbGljaycoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTWFwIGRvdWJsZSBjbGlja2VkJywgZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ21hcDpyaWdodGNsaWNrJyhlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNYXAgcmlnaHQtY2xpY2tlZCcsIGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICd3YXlwb2ludExpbms6Y2xpY2snKGluZGV4LCBsYXQsIGxuZyl7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5tYXBFZGl0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSW5zZXJ0IG5ldyB3YXlwb2ludFxyXG4gICAgICAgICAgICBsZXQgbmV3V2F5cG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJycsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ29fdG9fcG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBsYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbG5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMubWlzc2lvbi53YXlwb2ludHMuc3BsaWNlKGluZGV4KzEsIDAsIG5ld1dheXBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0aGUgbmV3bHkgaW5zZXJ0ZWQgd2F5cG9pbnRcclxuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyhcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcjd2F5cG9pbnQtJyArIChpbmRleCArIDEpKSwgdGhpcy4kZWxzLnBhZ2VDb250ZW50LCA1NlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ3NlcnZlcjo6c2V0X21pc3Npb25fYWNrJygpe1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RTZXRNaXNzaW9uQWNrVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgR2NzV2F5cG9pbnQsXHJcbiAgICAgICAgR2NzV2F5cG9pbnRMaW5rLFxyXG4gICAgICAgIEdjc09yaWdpblxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLW1pc3Npb24ge1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG5cclxuICAgIC5yb3cge1xyXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDRweDtcclxuXHJcbiAgICAgICAgJjpsYXN0LWNoaWxkIHtcclxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLm9yaWdpbi1yb3cge1xyXG4gICAgICAgIHBhZGRpbmc6IDE2cHg7XHJcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLnVpLXRvb2xiYXItYnJhbmQge1xyXG4gICAgICAgIG1pbi13aWR0aDogMDtcclxuICAgIH1cclxuXHJcbiAgICAubm8td2F5cG9pbnRzIHtcclxuICAgICAgICBmb250LXNpemU6IDAuOWVtO1xyXG4gICAgICAgIGNvbG9yOiAjNzc3O1xyXG4gICAgICAgIHBhZGRpbmc6IDE2cHg7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc01pc3Npb24udnVlPzBjZmIwNDgwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3M/LXVybCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzV2F5cG9pbnQudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzV2F5cG9pbnQudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcmtlcnNcXFxcR2NzV2F5cG9pbnQudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzV2F5cG9pbnQudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtMDBlMjNlYTUvR2NzV2F5cG9pbnQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlcj8tdXJsIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3Mtd2F5cG9pbnRcIiA6Y2xhc3M9XCJ7ICdoaWdobGlnaHRlZCc6IChkcmFnZ2luZyB8fCBoaWdobGlnaHRlZCkgfVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJudW1iZXJcIj5cclxuICAgICAgICAgICAgPGRpdiB2LXRleHQ9XCJpbmRleCArIDFcIj48L2Rpdj5cclxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICB0eXBlPVwiY2xlYXJcIiBpY29uPVwiZGVsZXRlXCIgdG9vbHRpcD1cIkRlbGV0ZVwiIEBjbGljaz1cImRlbGV0ZVdheXBvaW50XCJcclxuICAgICAgICAgICAgICAgIGNsYXNzPSdkZWxldGUtYnV0dG9uJ1xyXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgPHVpLXRleHRib3hcclxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbHVtblwiIGxhYmVsPVwiVGl0bGVcIiBuYW1lPVwidGl0bGVcIiA6dmFsdWUuc3luYz1cInRpdGxlXCJcclxuICAgICAgICAgICAgICAgID48L3VpLXRleHRib3g+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgPHVpLXRleHRib3hcclxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbHVtbiBvbmUtaGFsZlwiIGxhYmVsPVwiTGF0aXR1ZGVcIiBuYW1lPVwibGF0aXR1ZGVcIiA6dmFsdWUuc3luYz1cImxhdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiIDpzdGVwPVwiMC4wMDAwMVwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxyXG5cclxuICAgICAgICAgICAgICAgIDx1aS10ZXh0Ym94XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4gb25lLWhhbGZcIiBsYWJlbD1cIkxvbmdpdHVkZVwiIG5hbWU9XCJsb25naXR1ZGVcIiA6dmFsdWUuc3luYz1cImxuZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiIDpzdGVwPVwiMC4wMDAwMVwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDx1aS1zZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbHVtbiBvbmUtaGFsZlwiIGxhYmVsPVwiVHlwZVwiIG5hbWU9XCJ0eXBlXCIgOnZhbHVlLnN5bmM9XCJ3YXlwb2ludFR5cGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIDpvcHRpb25zPVwiW3sgdGV4dDogJ0dvIFRvIFBvaW50JywgdmFsdWU6ICdnb190b19wb2ludCcgfV1cIiA6ZGVmYXVsdD1cIndheXBvaW50VHlwZVwiXHJcbiAgICAgICAgICAgICAgICA+PC91aS1zZWxlY3Q+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgaXNNYXJrZXIgZnJvbSAnbWl4aW5zL2lzLW1hcmtlcic7XHJcbmltcG9ydCBlbGVtZW50IGZyb20gJ3V0aWwvZWxlbWVudC1zY3JvbGwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpbmRleDogTnVtYmVyLFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgY29lcmNlOiBTdHJpbmdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2F5cG9pbnRUeXBlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGF0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlclxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG5nOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlclxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZmlsbENvbG9yOiB7bm9ybWFsOiAneWVsbG93JywgaG92ZXI6ICdsaW1lJ31cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICBjbGljaygpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyh0aGlzLiRlbCwgdGhpcy4kZWwucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LCA1Nik7XHJcbiAgICAgICAgICAgICAgICAvLyA1NnB4IG1hcmdpbiBmb3IgVWlUb29sYmFyXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmlnaHRjbGljaygpIHtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RlbGV0ZScpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRyYWcoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxhdCA9IE51bWJlciggcGFyc2VGbG9hdChlLmxhdExuZy5sYXQoKSkudG9GaXhlZCg3KSApO1xyXG4gICAgICAgICAgICB0aGlzLmxuZyA9IE51bWJlciggcGFyc2VGbG9hdChlLmxhdExuZy5sbmcoKSkudG9GaXhlZCg3KSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1vdXNlb3ZlcigpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRJY29uKHRoaXMuZ2V0SWNvbih0aGlzLmZpbGxDb2xvci5ob3ZlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbW91c2VvdXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyICYmICF0aGlzLmRyYWdnaW5nKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldEljb24odGhpcy5nZXRJY29uKHRoaXMuZmlsbENvbG9yLm5vcm1hbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZHJhZ3N0YXJ0KCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkcmFnZW5kKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgZ2V0SWNvbihmaWxsQ29sb3IgPSB0aGlzLmZpbGxDb2xvci5ub3JtYWwsIHNjYWxlID0gdGhpcy5zY2FsZSwgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBnb29nbGUubWFwcy5TeW1ib2xQYXRoLkNJUkNMRSxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlbGV0ZVdheXBvaW50KCl7XHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkZWxldGUtd2F5cG9pbnQnLCB0aGlzLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1peGluczogW1xyXG4gICAgICAgIGlzTWFya2VyXHJcbiAgICBdXHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9fdmFyaWFibGVzJztcclxuXHJcbi5nY3Mtd2F5cG9pbnQge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIHBhZGRpbmc6IDhweCAxMnB4O1xyXG4gICAgcGFkZGluZy10b3A6IDEycHg7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcclxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xcyBlYXNlO1xyXG5cclxuICAgICY6bm90KDpmaXJzdC1jaGlsZCkge1xyXG4gICAgICAgIHBhZGRpbmctdG9wOiAxOHB4O1xyXG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjREREO1xyXG4gICAgfVxyXG5cclxuICAgICYuaGlnaGxpZ2h0ZWQge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkY5QzQ7XHJcbiAgICB9XHJcblxyXG4gICAgLm51bWJlciB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgICAgIG1hcmdpbi1yaWdodDogMTZweDtcclxuICAgICAgICBsaW5lLWhlaWdodDogMTtcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgICBtaW4td2lkdGg6IDI0cHg7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLmNvbnRlbnQge1xyXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcclxuICAgIH1cclxuXHJcbiAgICAuZGVsZXRlLWJ1dHRvbiB7XHJcbiAgICAgICAgY29sb3I6ICRkYXJrLXNlY29uZGFyeTtcclxuICAgICAgICBoZWlnaHQ6IDMycHg7XHJcbiAgICAgICAgd2lkdGg6IDMycHg7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogMTZweDtcclxuXHJcbiAgICAgICAgLnVpLWljb24ge1xyXG4gICAgICAgICAgICBmb250LXNpemU6IDIwcHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAmOmhvdmVyIHtcclxuICAgICAgICAgICAgY29sb3I6ICRkYXJrLXByaW1hcnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc1dheXBvaW50LnZ1ZT9lZTc5Mjg2MlxuICoqLyIsImltcG9ydCB7IGdldE1hcCwgZ2V0TWFwRWwsIGdldE1hcExvYWRlZCB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgbWFwOiBnZXRNYXAsXHJcbiAgICAgICAgICAgIG1hcEVsOiBnZXRNYXBFbCxcclxuICAgICAgICAgICAgbWFwTG9hZGVkOiBnZXRNYXBMb2FkZWRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgdGl0bGU6IFN0cmluZyxcclxuICAgICAgICBsYXQ6IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG5nOiAge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3RhdGlvbjoge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgZGVmYXVsdDogNlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaWJsZToge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmFnZ2FibGU6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWFya2VyOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBwb3NpdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxhdDogdGhpcy5sYXQsXHJcbiAgICAgICAgICAgICAgICBsbmc6IHRoaXMubG5nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZWFkeSgpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTWFya2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubWFya2VyLnNldE1hcChudWxsKTtcclxuICAgICAgICB0aGlzLm1hcmtlciA9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIHdhdGNoOiB7XHJcbiAgICAgICAgbWFwTG9hZGVkKG5ld1ZhbCwgb2xkVmFsKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkVmFsICYmIG5ld1ZhbCAmJiAhdGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZU1hcmtlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbWFwKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldE1hcCh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0aXRsZSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRUaXRsZSh0aGlzLnRpdGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGxhYmVsKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldExhYmVsKHRoaXMubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB2aXNpYmxlKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldFZpc2libGUodGhpcy52aXNpYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRyYWdnYWJsZSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlci5zZXREcmFnZ2FibGUodGhpcy5kcmFnZ2FibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcm90YXRpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWNvbigpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNjYWxlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUljb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBpbml0aWFsaXplTWFya2VyKCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBpY29uOiB0aGlzLmdldEljb24oKSxcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdGhpcy5kcmFnZ2FibGUsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICBtYXA6IHRoaXMubWFwXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLnNldFRpdGxlKHRoaXMudGl0bGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0TGFiZWwodGhpcy5sYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdpbml0aWFsaXplZCcsIHRoaXMubWFya2VyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudHMoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cGRhdGVJY29uKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLm1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0SWNvbih0aGlzLmdldEljb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXR1cEV2ZW50cygpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbGljaycsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdkYmxjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZGJsY2xpY2snLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcigncmlnaHRjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgncmlnaHRjbGljaycsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ21vdXNlb3ZlcicsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdtb3VzZW91dCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnbW91c2VvdXQnLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkcmFnc3RhcnQnLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignZHJhZycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnZHJhZycsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFya2VyLmFkZExpc3RlbmVyKCdkcmFnZW5kJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdkcmFnZW5kJywgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuYWRkTGlzdGVuZXIoJ3Bvc2l0aW9uX2NoYW5nZWQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Bvc2l0aW9uX2NoYW5nZWQnLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9taXhpbnMvaXMtbWFya2VyLmpzXG4gKiovIiwiZXhwb3J0IGZ1bmN0aW9uIGluVmlldyhlbGVtZW50LCBjb250YWluZXIpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG5cclxuICAgIGxldCB0b3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuICAgIGxldCBwYXJlbnRUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xyXG4gICAgbGV0IGJvdHRvbSA9IHRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgbGV0IHBhcmVudEJvdHRvbSA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIHRvcCA+PSBwYXJlbnRUb3AgJiYgYm90dG9tIDw9IHBhcmVudEJvdHRvbTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIGNvbnRhaW5lciwgbWFyZ2luVG9wID0gMCkge1xyXG4gICAgaWYgKCFlbGVtZW50IHx8IGluVmlldyhlbGVtZW50LCBjb250YWluZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIC0gbWFyZ2luVG9wO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9TdGFydChlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9FbmQoZWxlbWVudCkge1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxIZWlnaHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGluVmlldyxcclxuICAgIHNjcm9sbEludG9WaWV3LFxyXG4gICAgc2Nyb2xsVG9TdGFydCxcclxuICAgIHNjcm9sbFRvRW5kXHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3V0aWwvZWxlbWVudC1zY3JvbGwuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLXdheXBvaW50XFxcIiA6Y2xhc3M9XFxcInsgJ2hpZ2hsaWdodGVkJzogKGRyYWdnaW5nIHx8IGhpZ2hsaWdodGVkKSB9XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibnVtYmVyXFxcIj5cXG4gICAgICAgIDxkaXYgdi10ZXh0PVxcXCJpbmRleCArIDFcXFwiPjwvZGl2PlxcbiAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIGljb249XFxcImRlbGV0ZVxcXCIgdG9vbHRpcD1cXFwiRGVsZXRlXFxcIiBAY2xpY2s9XFxcImRlbGV0ZVdheXBvaW50XFxcIlxcbiAgICAgICAgICAgIGNsYXNzPSdkZWxldGUtYnV0dG9uJ1xcbiAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPHVpLXRleHRib3hcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNvbHVtblxcXCIgbGFiZWw9XFxcIlRpdGxlXFxcIiBuYW1lPVxcXCJ0aXRsZVxcXCIgOnZhbHVlLnN5bmM9XFxcInRpdGxlXFxcIlxcbiAgICAgICAgICAgID48L3VpLXRleHRib3g+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPHVpLXRleHRib3hcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNvbHVtbiBvbmUtaGFsZlxcXCIgbGFiZWw9XFxcIkxhdGl0dWRlXFxcIiBuYW1lPVxcXCJsYXRpdHVkZVxcXCIgOnZhbHVlLnN5bmM9XFxcImxhdFxcXCJcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwibnVtYmVyXFxcIiA6c3RlcD1cXFwiMC4wMDAwMVxcXCJcXG4gICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxcblxcbiAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2x1bW4gb25lLWhhbGZcXFwiIGxhYmVsPVxcXCJMb25naXR1ZGVcXFwiIG5hbWU9XFxcImxvbmdpdHVkZVxcXCIgOnZhbHVlLnN5bmM9XFxcImxuZ1xcXCJcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwibnVtYmVyXFxcIiA6c3RlcD1cXFwiMC4wMDAwMVxcXCJcXG4gICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDx1aS1zZWxlY3RcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImNvbHVtbiBvbmUtaGFsZlxcXCIgbGFiZWw9XFxcIlR5cGVcXFwiIG5hbWU9XFxcInR5cGVcXFwiIDp2YWx1ZS5zeW5jPVxcXCJ3YXlwb2ludFR5cGVcXFwiXFxuICAgICAgICAgICAgICAgIDpvcHRpb25zPVxcXCJbeyB0ZXh0OiAnR28gVG8gUG9pbnQnLCB2YWx1ZTogJ2dvX3RvX3BvaW50JyB9XVxcXCIgOmRlZmF1bHQ9XFxcIndheXBvaW50VHlwZVxcXCJcXG4gICAgICAgICAgICA+PC91aS1zZWxlY3Q+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3M/LXVybCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzV2F5cG9pbnRMaW5rLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0djc1dheXBvaW50TGluay52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWFya2Vyc1xcXFxHY3NXYXlwb2ludExpbmsudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzV2F5cG9pbnRMaW5rLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWI4NTgxMTgyL0djc1dheXBvaW50TGluay52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50TGluay52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlcj8tdXJsIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYXlwb2ludExpbmsudnVlXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZ2NzLXdheXBvaW50LWxpbmtcIj48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IGdldE1hcCwgZ2V0TWFwTG9hZGVkIH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgZ2V0dGVyczoge1xyXG4gICAgICAgICAgICBtYXA6IGdldE1hcCxcclxuICAgICAgICAgICAgbWFwTG9hZGVkOiBnZXRNYXBMb2FkZWRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5kZXg6IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0YXJ0TGF0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdGFydExuZzoge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW5kTGF0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbmRMbmc6IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHZpc2libGU6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW5rOiBudWxsLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjoge25vcm1hbDogJ2JsYWNrJywgaG92ZXI6ICdncmVlbid9XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxpbmsoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5saW5rLnNldE1hcChudWxsKTtcclxuICAgICAgICB0aGlzLmxpbmsgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIG1hcExvYWRlZChuZXdWYWwsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICBpZiAoIW9sZFZhbCAmJiBuZXdWYWwgJiYgIXRoaXMubGluaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGluaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbWFwKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0TWFwKHRoaXMubWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0YXJ0TGF0KCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmspe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmdldFBhdGgoKS5zZXRBdCgwLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHRoaXMuc3RhcnRMYXQsIHRoaXMuc3RhcnRMbmcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0YXJ0TG5nKCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmspe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmdldFBhdGgoKS5zZXRBdCgwLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHRoaXMuc3RhcnRMYXQsIHRoaXMuc3RhcnRMbmcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVuZExhdCgpe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluay5nZXRQYXRoKCkuc2V0QXQoMSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh0aGlzLmVuZExhdCwgdGhpcy5lbmRMbmcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVuZExuZygpe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluay5nZXRQYXRoKCkuc2V0QXQoMSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh0aGlzLmVuZExhdCwgdGhpcy5lbmRMbmcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHZpc2libGUoKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGluayl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0VmlzaWJsZSh0aGlzLnZpc2libGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZUxpbmsoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluayA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge2xhdDogdGhpcy5zdGFydExhdCwgbG5nOiB0aGlzLnN0YXJ0TG5nfSxcclxuICAgICAgICAgICAgICAgICAgICB7bGF0OiB0aGlzLmVuZExhdCwgbG5nOiB0aGlzLmVuZExuZ31cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5zdHJva2VDb2xvci5ub3JtYWwsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiA1LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgbWFwOiB0aGlzLm1hcFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5saW5rLmFkZExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF0ID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxhdCgpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnd2F5cG9pbnRMaW5rOmNsaWNrJywgdGhpcy5pbmRleCwgbGF0LCBsbmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5saW5rLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0T3B0aW9ucyh7c3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3IuaG92ZXJ9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubGluay5hZGRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0T3B0aW9ucyh7c3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3Iubm9ybWFsfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy13YXlwb2ludC1saW5rIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzV2F5cG9pbnRMaW5rLnZ1ZT8xYjIzZDY0M1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3Mtd2F5cG9pbnQtbGlua1xcXCI+PC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dheXBvaW50TGluay52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc09yaWdpbi52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NPcmlnaW4udnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcmtlcnNcXFxcR2NzT3JpZ2luLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc09yaWdpbi52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi02ZjJiMDM2Yy9HY3NPcmlnaW4udnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NPcmlnaW4udnVlXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXI/LXVybCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzT3JpZ2luLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImdjcy1vcmlnaW5cIj48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBpc01hcmtlciBmcm9tICdtaXhpbnMvaXMtbWFya2VyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbGF0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlclxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG5nOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE51bWJlclxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICAgZHJhZyhlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGF0ID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxhdCgpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgICAgIHRoaXMubG5nID0gTnVtYmVyKCBwYXJzZUZsb2F0KGUubGF0TG5nLmxuZygpKS50b0ZpeGVkKDcpICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgZ2V0SWNvbihzY2FsZSA9IHRoaXMuc2NhbGUsIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogZ29vZ2xlLm1hcHMuU3ltYm9sUGF0aC5DSVJDTEUsXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdvcmFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgbWl4aW5zOiBbXHJcbiAgICAgICAgaXNNYXJrZXJcclxuICAgIF1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1vcmlnaW4ge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NPcmlnaW4udnVlP2JlNDBlZWVjXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1vcmlnaW5cXFwiPjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NPcmlnaW4udnVlXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgIGlmIChudW1iZXIgPiA1Mikge1xyXG4gICAgICAgIHJldHVybiAnMCc7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFscGhhYmV0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCcnKTtcclxuXHJcbiAgICByZXR1cm4gYWxwaGFiZXRbbnVtYmVyIC0gMV07XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdXRpbC9udW1iZXItdG8tbGV0dGVyLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1taXNzaW9uXFxcIj5cXG4gICAgPHVpLXRvb2xiYXIgOnRpdGxlPVxcXCJtaXNzaW9uLnRpdGxlXFxcIiBoaWRlLW5hdi1pY29uIHNob3ctYnJhbmQgOnNob3ctYnJhbmQtZGl2aWRlcj1cXFwiZmFsc2VcXFwiPlxcbiAgICAgICAgPGRpdiBzbG90PVxcXCJicmFuZFxcXCI+XFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwiZ29CYWNrXFxcIiB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiYXJyb3dfYmFja1xcXCIgdG9vbHRpcD1cXFwiQmFjayB0byBNaXNzaW9uc1xcXCJcXG4gICAgICAgICAgICAgICAgdG9vbHRpcC1wb3NpdGlvbj1cXFwiYm90dG9tIGxlZnRcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgc2xvdD1cXFwiYWN0aW9uc1xcXCI+XFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNsZWFyXFxcIiBpY29uPVxcXCJmaWxlX3VwbG9hZFxcXCIgdG9vbHRpcD1cXFwiVXBsb2FkIG1pc3Npb25cXFwiIEBjbGljaz1cXFwidXBsb2FkTWlzc2lvblxcXCJcXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVxcXCIhd2F5cG9pbnRzVmlzaWJsZVxcXCJcXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIDppY29uPVxcXCJ3YXlwb2ludHNWaXNpYmxlID8gJ3Zpc2liaWxpdHknIDogJ3Zpc2liaWxpdHlfb2ZmJ1xcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJ0b2dnbGVXYXlwb2ludFZpc2liaWxpdHlcXFwiXFxuICAgICAgICAgICAgICAgIDp0b29sdGlwPVxcXCJ3YXlwb2ludHNWaXNpYmxlID8gJ0hpZGUgd2F5cG9pbnRzJyA6ICdTaG93IHdheXBvaW50cydcXFwiXFxuICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNsZWFyXFxcIiBpY29uPVxcXCJtb3JlX3ZlcnRcXFwiIGhhcy1kcm9wZG93bi1tZW51IGRyb3Bkb3duLXBvc2l0aW9uPVxcXCJib3R0b20gcmlnaHRcXFwiXFxuICAgICAgICAgICAgICAgIDptZW51LW9wdGlvbnM9XFxcIm92ZXJmbG93TWVudVxcXCIgQG1lbnUtb3B0aW9uLXNlbGVjdGVkPVxcXCJvdmVyZmxvd01lbnVPcHRpb25TZWxlY3RlZFxcXCJcXG4gICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L3VpLXRvb2xiYXI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItcGFnZS1jb250ZW50XFxcIiB2LWVsOnBhZ2UtY29udGVudD5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBvcmlnaW4tcm93XFxcIj5cXG4gICAgICAgICAgICA8dWktdGV4dGJveFxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwiY29sdW1uIG9uZS1oYWxmXFxcIiBsYWJlbD1cXFwiT3JpZ2luIExhdGl0dWRlXFxcIiBuYW1lPVxcXCJsYXRpdHVkZVxcXCJcXG4gICAgICAgICAgICAgICAgOnZhbHVlLnN5bmM9XFxcIm1pc3Npb24ub3JpZ2luLmxhdFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiA6c3RlcD1cXFwiMC4wMDAwMVxcXCJcXG4gICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxcbiAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2x1bW4gb25lLWhhbGZcXFwiIGxhYmVsPVxcXCJPcmlnaW4gTG9uZ2l0dWRlXFxcIiBuYW1lPVxcXCJsb25naXR1ZGVcXFwiXFxuICAgICAgICAgICAgICAgIDp2YWx1ZS5zeW5jPVxcXCJtaXNzaW9uLm9yaWdpbi5sbmdcXFwiIHR5cGU9XFxcIm51bWJlclxcXCIgOnN0ZXA9XFxcIjAuMDAwMDFcXFwiXFxuICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGdjcy1vcmlnaW5cXG4gICAgICAgICAgICA6bGF0LnN5bmM9XFxcIm1pc3Npb24ub3JpZ2luLmxhdFxcXCIgOmxuZy5zeW5jPVxcXCJtaXNzaW9uLm9yaWdpbi5sbmdcXFwiXFxuICAgICAgICAgICAgOnNjYWxlPVxcXCI1XFxcIiA6ZHJhZ2dhYmxlPVxcXCJtYXBFZGl0aW5nXFxcIlxcbiAgICAgICAgPjwvZ2NzLW9yaWdpbj5cXG5cXG4gICAgICAgIDxwXFxuICAgICAgICAgICAgY2xhc3M9XFxcIm5vLXdheXBvaW50c1xcXCIgdi1pZj1cXFwiIW1pc3Npb24ud2F5cG9pbnRzLmxlbmd0aFxcXCJcXG4gICAgICAgID5ObyB3YXlwb2ludHMgZm9yIHRoaXMgbWlzc2lvbi4gQ2xpY2sgdGhlIG1hcCB0byBhZGQgYSB3YXlwb2ludC48L3A+XFxuXFxuICAgICAgICA8ZGl2IHYtZWxzZT5cXG4gICAgICAgICAgICA8Z2NzLXdheXBvaW50XFxuICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIHdheXBvaW50KSBpbiBtaXNzaW9uLndheXBvaW50c1xcXCIgOmluZGV4PVxcXCJpbmRleFxcXCIgOmlkPVxcXCInd2F5cG9pbnQtJyArIGluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICA6bGFiZWw9XFxcInRvTGV0dGVyKGluZGV4ICsgMSlcXFwiIDp0aXRsZS5zeW5jPVxcXCJ3YXlwb2ludC50aXRsZVxcXCIgOndheXBvaW50LXR5cGU9XFxcIndheXBvaW50LnR5cGVcXFwiXFxuICAgICAgICAgICAgICAgIDpsYXQuc3luYz1cXFwid2F5cG9pbnQucG9zaXRpb24ubGF0XFxcIiA6bG5nLnN5bmM9XFxcIndheXBvaW50LnBvc2l0aW9uLmxuZ1xcXCJcXG4gICAgICAgICAgICAgICAgOnJvdGF0aW9uPVxcXCJ3YXlwb2ludC5yb3RhdGlvblxcXCIgOnNjYWxlPVxcXCIxMFxcXCJcXG4gICAgICAgICAgICAgICAgOmRyYWdnYWJsZT1cXFwibWFwRWRpdGluZ1xcXCIgOnZpc2libGU9XFxcIndheXBvaW50c1Zpc2libGVcXFwiXFxuICAgICAgICAgICAgICAgIEBkZWxldGU9XFxcImRlbGV0ZVdheXBvaW50KGluZGV4KVxcXCJcXG4gICAgICAgICAgICA+PC9nY3Mtd2F5cG9pbnQ+XFxuXFxuICAgICAgICAgICAgPCEtLVxcbiAgICAgICAgICAgICAgICBpdCBzZWVtcywgd2hlbiB3YXlwb2ludC5wb3NpdGlvbiBpcyB1c2VkLCBpbnN0ZWFkIG9mIHdheXBvaW50LnBvc2l0aW9uLmxhdC9sbmcsXFxuICAgICAgICAgICAgICAgIGNoYW5naW5nIHRoZSB3YXlwb2ludC5wb3NpdGlvbi5sYXQvbG5nIGVsc2V3aGVyZSB3b24ndCB0cmlnZ2VyIHVwZGF0ZXMgaGVyZVxcbiAgICAgICAgICAgIC0tPlxcbiAgICAgICAgICAgIDxnY3Mtd2F5cG9pbnQtbGlua1xcbiAgICAgICAgICAgICAgICB2LWZvcj1cXFwiKGluZGV4LCB3YXlwb2ludCkgaW4gbWlzc2lvbi53YXlwb2ludHNcXFwiIDppbmRleD1cXFwiaW5kZXhcXFwiXFxuICAgICAgICAgICAgICAgIDpzdGFydC1sYXQ9XFxcIndheXBvaW50LnBvc2l0aW9uLmxhdFxcXCJcXG4gICAgICAgICAgICAgICAgOnN0YXJ0LWxuZz1cXFwid2F5cG9pbnQucG9zaXRpb24ubG5nXFxcIlxcbiAgICAgICAgICAgICAgICA6ZW5kLWxhdD1cXFwibWlzc2lvbi53YXlwb2ludHNbKGluZGV4KzEpICUgbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXS5wb3NpdGlvbi5sYXQ7XFxcIlxcbiAgICAgICAgICAgICAgICA6ZW5kLWxuZz1cXFwibWlzc2lvbi53YXlwb2ludHNbKGluZGV4KzEpICUgbWlzc2lvbi53YXlwb2ludHMubGVuZ3RoXS5wb3NpdGlvbi5sbmc7XFxcIlxcbiAgICAgICAgICAgICAgICA6dmlzaWJsZT1cXFwid2F5cG9pbnRzVmlzaWJsZVxcXCJcXG4gICAgICAgICAgICA+PC9nY3Mtd2F5cG9pbnQtbGluaz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbi52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc01pc3Npb25Sb3cudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzTWlzc2lvblJvdy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWlzc2lvblxcXFxHY3NNaXNzaW9uUm93LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc01pc3Npb25Sb3cudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtZmUwNThkYjYvR2NzTWlzc2lvblJvdy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9taXNzaW9uL0djc01pc3Npb25Sb3cudnVlXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXI/LXVybCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvblJvdy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3MtbWlzc2lvbi1yb3dcIj5cclxuICAgICAgICA8dWktaWNvbi1idXR0b25cclxuICAgICAgICAgICAgdHlwZT1cImNsZWFyXCIgaWNvbj1cImRlbGV0ZVwiIGNsYXNzPVwiZGVsZXRlLWJ1dHRvblwiIHRvb2x0aXA9XCJEZWxldGVcIiBAY2xpY2s9XCJkZWxldGVNaXNzaW9uXCJcclxuICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgPGgzIGNsYXNzPVwibWlzc2lvbi1oZWFkZXJcIiB2LXRleHQ9XCJtaXNzaW9uLnRpdGxlXCI+PC9oMz5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm1pc3Npb24tc3VtbWFyeVwiPlxyXG4gICAgICAgICAgICA8cCBjbGFzcz1cImRlc2NyaXB0aW9uXCIgdi1pZj1cIm1pc3Npb24uZGVzY3JpcHRpb25cIiB2LXRleHQ9XCJtaXNzaW9uLmRlc2NyaXB0aW9uXCI+PC9wPlxyXG5cclxuICAgICAgICAgICAgPHAgY2xhc3M9XCJ3YXlwb2ludHNcIiB2LWlmPVwiIW1pc3Npb24uZGVzY3JpcHRpb24gJiYgaGFzV2F5cG9pbnRzXCI+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj5Gcm9tOiAoe3sgZmlyc3RXYXlwb2ludC5wb3NpdGlvbi5sYXQgfX0sIHt7IGZpcnN0V2F5cG9pbnQucG9zaXRpb24ubG5nIH19KTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxzcGFuPlRvOiAoe3sgbGFzdFdheXBvaW50LnBvc2l0aW9uLmxhdCB9fSwge3sgbGFzdFdheXBvaW50LnBvc2l0aW9uLmxuZyB9fSk8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwIGNsYXNzPVwibm8td2F5cG9pbnRzXCIgdi1pZj1cIiFtaXNzaW9uLmRlc2NyaXB0aW9uICYmICFoYXNXYXlwb2ludHNcIj5ObyB3YXlwb2ludHM8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbWlzc2lvbjoge1xyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmRleDoge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIGhhc1dheXBvaW50cygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlzc2lvbi53YXlwb2ludHMgJiYgdGhpcy5taXNzaW9uLndheXBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlyc3RXYXlwb2ludCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlzc2lvbi53YXlwb2ludHNbMF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbGFzdFdheXBvaW50KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taXNzaW9uLndheXBvaW50c1t0aGlzLm1pc3Npb24ud2F5cG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGRlbGV0ZU1pc3Npb24oKXtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2RlbGV0ZS1taXNzaW9uJywgdGhpcy5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLW1pc3Npb24tcm93IHtcclxuICAgIHBhZGRpbmc6IDEycHg7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0VFRTtcclxuXHJcbiAgICAmOmhvdmVyLFxyXG4gICAgJjpmb2N1cyB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0VFRTtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogNDhweDtcclxuXHJcbiAgICAgICAgLm1pc3Npb24taGVhZGVyIHtcclxuICAgICAgICAgICAgY29sb3I6ICRwcmltYXJ5LWRhcmtlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC5kZWxldGUtYnV0dG9uIHtcclxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5taXNzaW9uLWhlYWRlciB7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XHJcbiAgICAgICAgZm9udC1zaXplOiAxLjFlbTtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBAZXh0ZW5kcyAkdHJ1bmNhdGUtdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICAubWlzc2lvbi1zdW1tYXJ5IHtcclxuICAgICAgICBwYWRkaW5nLXRvcDogOHB4O1xyXG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XHJcbiAgICAgICAgZm9udC1zaXplOiAwLjllbTtcclxuICAgICAgICBsaW5lLWhlaWdodDogMTtcclxuICAgICAgICBjb2xvcjogIzc3NztcclxuXHJcbiAgICAgICAgcCB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogMDtcclxuICAgICAgICAgICAgcGFkZGluZzogMDtcclxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMztcclxuICAgICAgICAgICAgQGV4dGVuZHMgJHRydW5jYXRlLXRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5uby13YXlwb2ludHMge1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgIGNvbG9yOiAjQUFBO1xyXG4gICAgfVxyXG5cclxuICAgIC5kZWxldGUtYnV0dG9uIHtcclxuICAgICAgICByaWdodDogNnB4O1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICAgIGNvbG9yOiAkZGFyay1zZWNvbmRhcnk7XHJcblxyXG4gICAgICAgICY6aG92ZXIge1xyXG4gICAgICAgICAgICBjb2xvcjogJGRhcmstcHJpbWFyeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC51aS1pY29uIHtcclxuICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NNaXNzaW9uUm93LnZ1ZT9jNGUyYThiNFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3MtbWlzc2lvbi1yb3dcXFwiPlxcbiAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgIHR5cGU9XFxcImNsZWFyXFxcIiBpY29uPVxcXCJkZWxldGVcXFwiIGNsYXNzPVxcXCJkZWxldGUtYnV0dG9uXFxcIiB0b29sdGlwPVxcXCJEZWxldGVcXFwiIEBjbGljaz1cXFwiZGVsZXRlTWlzc2lvblxcXCJcXG4gICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgIDxoMyBjbGFzcz1cXFwibWlzc2lvbi1oZWFkZXJcXFwiIHYtdGV4dD1cXFwibWlzc2lvbi50aXRsZVxcXCI+PC9oMz5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwibWlzc2lvbi1zdW1tYXJ5XFxcIj5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJkZXNjcmlwdGlvblxcXCIgdi1pZj1cXFwibWlzc2lvbi5kZXNjcmlwdGlvblxcXCIgdi10ZXh0PVxcXCJtaXNzaW9uLmRlc2NyaXB0aW9uXFxcIj48L3A+XFxuXFxuICAgICAgICA8cCBjbGFzcz1cXFwid2F5cG9pbnRzXFxcIiB2LWlmPVxcXCIhbWlzc2lvbi5kZXNjcmlwdGlvbiAmJiBoYXNXYXlwb2ludHNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPkZyb206ICh7eyBmaXJzdFdheXBvaW50LnBvc2l0aW9uLmxhdCB9fSwge3sgZmlyc3RXYXlwb2ludC5wb3NpdGlvbi5sbmcgfX0pPC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuPlRvOiAoe3sgbGFzdFdheXBvaW50LnBvc2l0aW9uLmxhdCB9fSwge3sgbGFzdFdheXBvaW50LnBvc2l0aW9uLmxuZyB9fSk8L3NwYW4+XFxuICAgICAgICA8L3A+XFxuXFxuICAgICAgICA8cCBjbGFzcz1cXFwibm8td2F5cG9pbnRzXFxcIiB2LWlmPVxcXCIhbWlzc2lvbi5kZXNjcmlwdGlvbiAmJiAhaGFzV2F5cG9pbnRzXFxcIj5ObyB3YXlwb2ludHM8L3A+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWlzc2lvbi9HY3NNaXNzaW9uUm93LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1taXNzaW9uc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItcGFnZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtaXNzaW9ucy1saXN0XFxcIiB2LWlmPVxcXCJjdXJyZW50VmlldyA9PT0gJ2xpc3RpbmcnXFxcIj5cXG4gICAgICAgICAgICA8dWktdG9vbGJhciB0aXRsZT1cXFwiTWlzc2lvbnNcXFwiIGhpZGUtbmF2LWljb24+XFxuICAgICAgICAgICAgICAgIDxkaXYgc2xvdD1cXFwiYWN0aW9uc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiYWRkXFxcIiB0b29sdGlwPVxcXCJBZGQgbWlzc2lvblxcXCIgQGNsaWNrPVxcXCJhZGRNaXNzaW9uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgPjwvdWktaWNvbi1idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8dWktaWNvbi1idXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJjbGVhclxcXCIgaWNvbj1cXFwiZmlsZV9kb3dubG9hZFxcXCIgdG9vbHRpcD1cXFwiRG93bmxvYWQgbWlzc2lvblxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XFxcImRvd25sb2FkTWlzc2lvblxcXCJcXG4gICAgICAgICAgICAgICAgICAgID48L3VpLWljb24tYnV0dG9uPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPHVpLWljb24tYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwiY2xlYXJcXFwiIGljb249XFxcIm1vcmVfdmVydFxcXCIgaGFzLWRyb3Bkb3duLW1lbnVcXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi1wb3NpdGlvbj1cXFwiYm90dG9tIHJpZ2h0XFxcIiA6bWVudS1vcHRpb25zPVxcXCJvdmVyZmxvd01lbnVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgQG1lbnUtb3B0aW9uLXNlbGVjdGVkPVxcXCJtZW51T3B0aW9uU2VsZWN0ZWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICA+PC91aS1pY29uLWJ1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC91aS10b29sYmFyPlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItcGFnZS1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmxhbmstc3RhdGVcXFwiIHYtaWY9XFxcIiFtaXNzaW9ucy5sZW5ndGhcXFwiPk5vIG1pc3Npb25zPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDxnY3MtbWlzc2lvbi1yb3dcXG4gICAgICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIoaW5kZXgsIG1pc3Npb24pIGluIG1pc3Npb25zXFxcIiA6aW5kZXg9XFxcImluZGV4XFxcIiA6bWlzc2lvbj1cXFwibWlzc2lvblxcXCJcXG4gICAgICAgICAgICAgICAgICAgIEBjbGljaz1cXFwic2VsZWN0TWlzc2lvbihpbmRleClcXFwiXFxuICAgICAgICAgICAgICAgID48L2djcy1taXNzaW9uLXJvdz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGNvbXBvbmVudFxcbiAgICAgICAgICAgIHYtZWxzZSA6aXM9XFxcImN1cnJlbnRWaWV3XFxcIiA6bWlzc2lvbj1cXFwiY3VycmVudE1pc3Npb25cXFwiIEBnby1iYWNrPVxcXCJzaG93TGlzdGluZ1ZpZXdcXFwiXFxuICAgICAgICA+PC9jb21wb25lbnQ+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcbjwhLS0gaGlkZGVuIGlucHV0IGVsZW1lbnQgdXNlZCBmb3Igc2VsZWN0aW5nIGEgZmlsZSB0byBpbXBvcnQgZnJvbSAtLT5cXG48aW5wdXQgdHlwZT1cXFwiZmlsZVxcXCIgaWQ9XFxcImltcG9ydF9taXNzaW9uc19pbnB1dFxcXCIgQGNoYW5nZT1cXFwiaW1wb3J0TWlzc2lvblxcXCI+XFxuPCEtLSBoaWRkZW4gbGluayB1c2VkIGZvciBwcm9tcHRpbmcgYSBkb3dubG9hZCAtLT5cXG48YSBpZD1cXFwiZXhwb3J0X21pc3Npb25zX2xpbmtcXFwiPjwvYT5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzTWlzc2lvbnMudnVlXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiZ2NzLW1hcC1zaWRlYmFyXFxcIiB2LXNob3c9XFxcInNob3dTaWRlYmFyXFxcIiB0cmFuc2l0aW9uPVxcXCJzaWRlYmFyLWNvbGxhcHNlXFxcIj5cXG4gICAgPGdjcy1taXNzaW9ucz48L2djcy1taXNzaW9ucz5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NNYXBTaWRlYmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3M/LXVybCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzQ29tbWFuZHMudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vR2NzQ29tbWFuZHMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcFxcXFxHY3NDb21tYW5kcy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HY3NDb21tYW5kcy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi00YzJiMWQ4Zi9HY3NDb21tYW5kcy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzQ29tbWFuZHMudnVlXG4gKiogbW9kdWxlIGlkID0gMTMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXI/LXVybCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJnY3MtY29tbWFuZHNcIj5cclxuICAgICAgICA8dWktYnV0dG9uIHYtaWY9XCJ3YW12Lm1vZGUgPT09ICdwYXVzZWQnXCJcclxuICAgICAgICAgICAgQGNsaWNrPVwic3RhcnRNaXNzaW9uXCJcclxuICAgICAgICA+UmVzdGFydDwvdWktYnV0dG9uPlxyXG5cclxuICAgICAgICA8dWktYnV0dG9uIHYtaWY9XCJ3YW12Lm1vZGUgIT09ICdtYW51YWwnXCJcclxuICAgICAgICAgICAgQGNsaWNrPVwidG9nZ2xlTWlzc2lvblwiIDp0ZXh0PVwic3RhcnRCdXR0b25UZXh0XCJcclxuICAgICAgICAgICAgOmRpc2FibGVkPVwid2Ftdi5tb2RlID09PSAna2lsbGVkJ1wiXHJcbiAgICAgICAgPjwvdWktYnV0dG9uPlxyXG5cclxuICAgICAgICA8dWktYnV0dG9uIHYtaWY9XCJ3YW12Lm1vZGUgIT09ICdtYW51YWwnXCJcclxuICAgICAgICAgICAgY29sb3I9XCJkYW5nZXJcIiA6dGV4dD1cIndhbXYubW9kZSA9PT0gJ2tpbGxlZCcgPyAnVW5raWxsJyA6ICdLaWxsJ1wiXHJcbiAgICAgICAgICAgIEBjbGljaz1cInRvZ2dsZUtpbGxcIlxyXG4gICAgICAgID48L3VpLWJ1dHRvbj5cclxuXHJcbiAgICAgICAgPHVpLWJ1dHRvblxyXG4gICAgICAgICAgICA6dGV4dD1cIm1vZGVCdXR0b25UZXh0XCJcclxuICAgICAgICAgICAgaGFzLWRyb3Bkb3duLW1lbnUgZHJvcGRvd24tcG9zaXRpb249XCJib3R0b20gcmlnaHRcIiA6bWVudS1vcHRpb25zPVwib3ZlcmZsb3dNZW51XCJcclxuICAgICAgICAgICAgQG1lbnUtb3B0aW9uLXNlbGVjdGVkPVwibWVudU9wdGlvblNlbGVjdGVkXCJcclxuICAgICAgICA+PC91aS1idXR0b24+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJhcm1lZC10b2dnbGVcIiB2LWlmPVwid2Ftdi5sb2FkZWRcIj5cclxuICAgICAgICAgICAgPHVpLXN3aXRjaFxyXG4gICAgICAgICAgICAgICAgOnZhbHVlLnN5bmM9XCJpc0FybWVkXCIgOmxhYmVsPVwiaXNBcm1lZCA/ICdBcm1lZCcgOiAnRGlzYXJtZWQnXCIgbGFiZWwtbGVmdFxyXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVwid2Ftdi5tb2RlID09PSAnYXV0bydcIlxyXG4gICAgICAgICAgICA+PC91aS1zd2l0Y2g+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IGdldFdhbXYgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHZ1ZXg6IHtcclxuICAgICAgICBnZXR0ZXJzOiB7XHJcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXZcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRhdGEoKXtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvdmVyZmxvd01lbnU6IFtcclxuICAgICAgICAgICAgICAgIHsgaWQ6ICdhdXRvJywgICB0ZXh0OiAnQXV0bycgIH0sXHJcbiAgICAgICAgICAgICAgICB7IGlkOiAnbWFudWFsJywgdGV4dDogJ01hbnVhbCd9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHRvZ2dsZU1pc3Npb25GYWlsdXJlVGltZXI6IG51bGwsXHJcbiAgICAgICAgICAgIFRJTUVPVVQ6IDEwMDBcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIG1vZGVCdXR0b25UZXh0KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53YW12Lm1vZGUgPT09ICdtYW51YWwnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01vZGU6IE0nO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb2RlOiBBJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0YXJ0QnV0dG9uVGV4dCgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLndhbXYubW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaWRsZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdraWxsZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnU3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncGF1c2VkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1Jlc3VtZSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRvJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1BhdXNlJztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gVE9ETzogdWktc3dpdGNoIGRvZXNuJ3QgcmVwcmVzZW50IHN0YXRlIHdoZW4gc2V0KCkgZmFpbHNcclxuICAgICAgICBpc0FybWVkOiB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndhbXYuYXJtZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXQoYXJtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJtKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpZW50Ojphcm0nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWVudDo6ZGlzYXJtJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICB0b2dnbGVNaXNzaW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53YW12Lm1vZGUgPT09ICdpZGxlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE1pc3Npb24oKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLndhbXYubW9kZSA9PT0gJ3BhdXNlZCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbGllbnQ6OnJlc3VtZV9taXNzaW9uJyk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b2dnbGVNaXNzaW9uRmFpbHVyZVRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlTWlzc2lvbkZhaWx1cmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLndhbXYubW9kZSAhPT0gJ2F1dG8nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJywgJ1Jlc3VtaW5nIHNlZW1zIHRvIGhhdmUgZmFpbGVkIChQb3NzaWJsZSByZWFzb25zOiBub3QgYXJtZWQsIG5vIGJhdHRlcnksIC4uLiknKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLlRJTUVPVVQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2Ftdi5tb2RlID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbGllbnQ6OnN0b3BfbWlzc2lvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3RhcnRNaXNzaW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjbGllbnQ6OnN0YXJ0X21pc3Npb24nKTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG9nZ2xlTWlzc2lvbkZhaWx1cmVUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlTWlzc2lvbkZhaWx1cmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud2Ftdi5tb2RlICE9PSAnYXV0bycpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdhcHA6OmNyZWF0ZS1zbmFja2JhcicsICdTdGFydGluZyBzZWVtcyB0byBoYXZlIGZhaWxlZCAoUG9zc2libGUgcmVhc29uczogbm8gdXBsb2FkZWQgbWlzc2lvbiwgbm90IGFybWVkLCAuLi4pJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMuVElNRU9VVCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9nZ2xlS2lsbCgpIHtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2godGhpcy53YW12Lm1vZGUgPT09ICdraWxsZWQnID8gJ2NsaWVudDo6dW5raWxsJyA6ICdjbGllbnQ6OmtpbGwnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZW51T3B0aW9uU2VsZWN0ZWQob3B0aW9uKXtcclxuICAgICAgICAgICAgc3dpdGNoIChvcHRpb24uaWQpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYXV0byc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2Ftdi5tb2RlICE9PSAnbWFudWFsJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdhcHA6OmNyZWF0ZS1zbmFja2JhcicsICdBbHJlYWR5IGluIGF1dG9tYXRpYyBtb2RlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWVudDo6YXV0bycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWFudWFsJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53YW12Lm1vZGUgPT09ICdtYW51YWwnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJywgJ0FscmVhZHkgaW4gbWFudWFsIG1vZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpZW50OjptYW51YWwnKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1jb21tYW5kcyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICByaWdodDogMTJweDtcclxuICAgIHRvcDogMTZweDtcclxuICAgIHotaW5kZXg6IDE7XHJcblxyXG4gICAgcGFkZGluZzogOHB4O1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIG1pbi13aWR0aDogMTIwcHg7XHJcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgLy8gYWxwaGEod2hpdGUsIDAuOSk7XHJcbiAgICBib3gtc2hhZG93OiAwIDJweCA1cHggMCBhbHBoYShibGFjaywgMC4yKSwgMCAycHggMTBweCAwIGFscGhhKGJsYWNrLCAwLjE2KTtcclxuXHJcbiAgICAuYXJtZWQtdG9nZ2xlIHtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIHdpZHRoOiAxMThweDtcclxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xyXG4gICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI0RERDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IDhweDtcclxuICAgICAgICBtYXJnaW4tbGVmdDogNHB4O1xyXG5cclxuICAgICAgICAudWktc3dpdGNoLWxhYmVsLXRleHQge1xyXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLnVpLWJ1dHRvbiB7XHJcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xyXG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC51aS1idXR0b24tZHJvcGRvd24taWNvbiB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgICAgIG1hcmdpbi10b3A6IC0ycHg7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzQ29tbWFuZHMudnVlPzE4MDczOWIyXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImdjcy1jb21tYW5kc1xcXCI+XFxuICAgIDx1aS1idXR0b24gdi1pZj1cXFwid2Ftdi5tb2RlID09PSAncGF1c2VkJ1xcXCJcXG4gICAgICAgIEBjbGljaz1cXFwic3RhcnRNaXNzaW9uXFxcIlxcbiAgICA+UmVzdGFydDwvdWktYnV0dG9uPlxcblxcbiAgICA8dWktYnV0dG9uIHYtaWY9XFxcIndhbXYubW9kZSAhPT0gJ21hbnVhbCdcXFwiXFxuICAgICAgICBAY2xpY2s9XFxcInRvZ2dsZU1pc3Npb25cXFwiIDp0ZXh0PVxcXCJzdGFydEJ1dHRvblRleHRcXFwiXFxuICAgICAgICA6ZGlzYWJsZWQ9XFxcIndhbXYubW9kZSA9PT0gJ2tpbGxlZCdcXFwiXFxuICAgID48L3VpLWJ1dHRvbj5cXG5cXG4gICAgPHVpLWJ1dHRvbiB2LWlmPVxcXCJ3YW12Lm1vZGUgIT09ICdtYW51YWwnXFxcIlxcbiAgICAgICAgY29sb3I9XFxcImRhbmdlclxcXCIgOnRleHQ9XFxcIndhbXYubW9kZSA9PT0gJ2tpbGxlZCcgPyAnVW5raWxsJyA6ICdLaWxsJ1xcXCJcXG4gICAgICAgIEBjbGljaz1cXFwidG9nZ2xlS2lsbFxcXCJcXG4gICAgPjwvdWktYnV0dG9uPlxcblxcbiAgICA8dWktYnV0dG9uXFxuICAgICAgICA6dGV4dD1cXFwibW9kZUJ1dHRvblRleHRcXFwiXFxuICAgICAgICBoYXMtZHJvcGRvd24tbWVudSBkcm9wZG93bi1wb3NpdGlvbj1cXFwiYm90dG9tIHJpZ2h0XFxcIiA6bWVudS1vcHRpb25zPVxcXCJvdmVyZmxvd01lbnVcXFwiXFxuICAgICAgICBAbWVudS1vcHRpb24tc2VsZWN0ZWQ9XFxcIm1lbnVPcHRpb25TZWxlY3RlZFxcXCJcXG4gICAgPjwvdWktYnV0dG9uPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhcm1lZC10b2dnbGVcXFwiIHYtaWY9XFxcIndhbXYubG9hZGVkXFxcIj5cXG4gICAgICAgIDx1aS1zd2l0Y2hcXG4gICAgICAgICAgICA6dmFsdWUuc3luYz1cXFwiaXNBcm1lZFxcXCIgOmxhYmVsPVxcXCJpc0FybWVkID8gJ0FybWVkJyA6ICdEaXNhcm1lZCdcXFwiIGxhYmVsLWxlZnRcXG4gICAgICAgICAgICA6ZGlzYWJsZWQ9XFxcIndhbXYubW9kZSA9PT0gJ2F1dG8nXFxcIlxcbiAgICAgICAgPjwvdWktc3dpdGNoPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21hcC9HY3NDb21tYW5kcy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0djc1NpZGViYXJDb250cm9scy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NTaWRlYmFyQ29udHJvbHMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1hcFxcXFxHY3NTaWRlYmFyQ29udHJvbHMudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWFhMTgxNzBhL0djc1NpZGViYXJDb250cm9scy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdlxyXG4gICAgICAgIGNsYXNzPVwiZ2NzLXNpZGViYXItY29udHJvbHNcIlxyXG4gICAgICAgIDpzdHlsZT1cInsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgnICsgKHNob3dTaWRlYmFyID8gJzM3NnB4JyA6ICcxNnB4JyArICcpJykgfVwiXHJcbiAgICA+XHJcbiAgICAgICAgPHVpLWJ1dHRvblxyXG4gICAgICAgICAgICA6Y29sb3I9XCJzaG93U2lkZWJhciA/ICdwcmltYXJ5JyA6ICdkZWZhdWx0J1wiIEBjbGljaz1cInRvZ2dsZVNpZGViYXJcIlxyXG4gICAgICAgID5NaXNzaW9uczwvdWktYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgR2NzQ29tbWFuZHMgZnJvbSAnbWFwL0djc0NvbW1hbmRzLnZ1ZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIHNob3dTaWRlYmFyOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgdG9nZ2xlU2lkZWJhcigpIHtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3RvZ2dsZS1zaWRlYmFyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgR2NzQ29tbWFuZHNcclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1zaWRlYmFyLWNvbnRyb2xzIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6IDE2cHg7XHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgei1pbmRleDogMTtcclxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTZweCk7XHJcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgYm94LXNoYWRvdzogMCAycHggNXB4IDAgYWxwaGEoYmxhY2ssIDAuMiksIDAgMnB4IDEwcHggMCBhbHBoYShibGFjaywgMC4xNik7XHJcblxyXG4gICAgLnVpLWJ1dHRvbiB7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcclxuICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjQ0NDO1xyXG4gICAgICAgIGhlaWdodDogMzJweDtcclxuXHJcbiAgICAgICAgLnVpLWJ1dHRvbi1kcm9wZG93bi1pY29uIHtcclxuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAtMnB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJi5jb2xvci1kZWZhdWx0Om5vdCguZHJvcGRvd24tb3Blbikge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJi5jb2xvci1wcmltYXJ5IHtcclxuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJjpsYXN0LWNoaWxkIHtcclxuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NTaWRlYmFyQ29udHJvbHMudnVlPzE1NTViNTc4XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXZcXG4gICAgY2xhc3M9XFxcImdjcy1zaWRlYmFyLWNvbnRyb2xzXFxcIlxcbiAgICA6c3R5bGU9XFxcInsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgnICsgKHNob3dTaWRlYmFyID8gJzM3NnB4JyA6ICcxNnB4JyArICcpJykgfVxcXCJcXG4+XFxuICAgIDx1aS1idXR0b25cXG4gICAgICAgIDpjb2xvcj1cXFwic2hvd1NpZGViYXIgPyAncHJpbWFyeScgOiAnZGVmYXVsdCdcXFwiIEBjbGljaz1cXFwidG9nZ2xlU2lkZWJhclxcXCJcXG4gICAgPk1pc3Npb25zPC91aS1idXR0b24+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXAvR2NzU2lkZWJhckNvbnRyb2xzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3M/LXVybCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzV2Ftdi52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NXYW12LnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtYXJrZXJzXFxcXEdjc1dhbXYudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzV2Ftdi52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1iNWJhYjRkMi9HY3NXYW12LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21hcmtlcnMvR2NzV2Ftdi52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlcj8tdXJsIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWFya2Vycy9HY3NXYW12LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImdjcy13YW12XCI+PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgaXNNYXJrZXIgZnJvbSAnbWl4aW5zL2lzLW1hcmtlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICBjbGljayhlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYW12IGNsaWNrZWQnLCBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpbml0aWFsaXplZCgpIHtcclxuICAgICAgICAgICAgd2luZG93LndhbXYgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGdldEljb24oc2NhbGUgPSB0aGlzLnNjYWxlLCByb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IGdvb2dsZS5tYXBzLlN5bWJvbFBhdGguRk9SV0FSRF9DTE9TRURfQVJST1csXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdyZWQnLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtaXhpbnM6IFtcclxuICAgICAgICBpc01hcmtlclxyXG4gICAgXVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4uZ2NzLXdhbXYge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBHY3NXYW12LnZ1ZT8zZDYwOTBhNFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3Mtd2FtdlxcXCI+PC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tYXJrZXJzL0djc1dhbXYudnVlXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidmlldyBtYXAtdmlld1xcXCI+XFxuICAgIDxnY3MtbWFwPjwvZ2NzLW1hcD5cXG4gICAgPGdjcy1tYXAtY29udHJvbHM+PC9nY3MtbWFwLWNvbnRyb2xzPlxcbiAgICA8Z2NzLW1hcC1zaWRlYmFyIDpzaG93LXNpZGViYXI9XFxcInNob3dTaWRlYmFyXFxcIj48L2djcy1tYXAtc2lkZWJhcj5cXG5cXG4gICAgPGdjcy1zaWRlYmFyLWNvbnRyb2xzXFxuICAgICAgICA6c2hvdy1zaWRlYmFyPVxcXCJzaG93U2lkZWJhclxcXCIgQHRvZ2dsZS1zaWRlYmFyPVxcXCJ0b2dnbGVTaWRlYmFyXFxcIlxcbiAgICA+PC9nY3Mtc2lkZWJhci1jb250cm9scz5cXG5cXG4gICAgPGdjcy1jb21tYW5kcz48L2djcy1jb21tYW5kcz5cXG5cXG4gICAgPGdjcy13YW12IHYtaWY9XFxcIndhbXYubG9hZGVkXFxcIlxcbiAgICAgICAgOmxhdD1cXFwid2Ftdi5wb3NpdGlvbi5sYXRcXFwiIDpsbmc9XFxcIndhbXYucG9zaXRpb24ubG5nXFxcIlxcbiAgICAgICAgOnJvdGF0aW9uPVxcXCJ3YW12LmhlYWRpbmdcXFwiXFxuICAgID48L2djcy13YW12PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvTWFwVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BhcmFtc1ZpZXcudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vUGFyYW1zVmlldy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcdmlld3NcXFxcUGFyYW1zVmlldy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9QYXJhbXNWaWV3LnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTA0ZTg3YjRlL1BhcmFtc1ZpZXcudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlcj8tdXJsIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJ2aWV3IHBhcmFtcy12aWV3XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2VcIj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzPVwicGFnZS1oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj5QYXJhbXM8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLWJ1dHRvbnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dWktYnV0dG9uIGNvbG9yPVwicHJpbWFyeVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInNhdmVQYXJhbXNcIlxyXG4gICAgICAgICAgICAgICAgICAgID5TYXZlPC91aS1idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVpLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJyZXNldFBhcmFtc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgPlJlc2V0PC91aS1idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9oMT5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLXNpZGViYXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2lkZWJhci1tZW51XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwiI1wiIGNsYXNzPVwic2lkZWJhci1tZW51LWl0ZW1cIiB2LWZvcj1cIihpbmRleCwgc2VjdGlvbikgaW4gcGFyYW1ldGVyc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJzZWxlY3RTZWN0aW9uKGluZGV4KVwiIDpjbGFzcz1cInsgJ3NlbGVjdGVkJzogaW5kZXggPT09IGN1cnJlbnRTZWN0aW9uSW5kZXggfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID57eyBzZWN0aW9uLnRpdGxlIH19PC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtbWFpblwiIHYtaWY9XCJwYXJhbWV0ZXJzLmxlbmd0aCA+IDBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dWktY29sbGFwc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi1mb3I9XCJzZWN0aW9uIGluIGN1cnJlbnRTZWN0aW9uLnN1YlNlY3Rpb25zXCIgOmhlYWRlcj1cInNlY3Rpb24udGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhcmFtXCIgdi1mb3I9XCJwYXJhbSBpbiBzZWN0aW9uLnBhcmFtc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVpLXRleHRib3hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bGFiZWw9XCJwYXJhbS50aXRsZVwiIDpuYW1lPVwicGFyYW0udGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp2YWx1ZS5zeW5jPVwicGFyYW0udmFsdWVcIiA6dmFsaWQuc3luYz1cInBhcmFtLnZhbGlkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAY2hhbmdlZD1cInBhcmFtQ2hhbmdlZChjdXJyZW50U2VjdGlvbi50aXRsZSwgc2VjdGlvbi50aXRsZSwgcGFyYW0udGl0bGUsIHBhcmFtLnR5cGUsIHBhcmFtLnZhbHVlLCBwYXJhbS52YWxpZClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp2YWxpZGF0aW9uLXJ1bGVzPVwiZ2V0VmFsaWRhdGlvblJ1bGUocGFyYW0udHlwZSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC91aS1jb2xsYXBzaWJsZT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgZ2V0UGFyYW1ldGVycywgZ2V0UGFyYW1ldGVyc0xhc3RVcGRhdGVUaW1lIH0gZnJvbSAnc3RvcmUvZ2V0dGVycyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB2dWV4OiB7XHJcbiAgICAgICAgZ2V0dGVyczoge1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBnZXRQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzTGFzdFVwZGF0ZVRpbWU6IGdldFBhcmFtZXRlcnNMYXN0VXBkYXRlVGltZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjdXJyZW50U2VjdGlvbkluZGV4OiAwLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUGFyYW1zOiB7fSxcclxuICAgICAgICAgICAgbGFzdFNldFBhcmFtZXRlcnNBY2tUaW1lOiBudWxsLFxyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUnVsZXM6IHtcclxuICAgICAgICAgICAgICAgIHZlYzM6IFsncmVnZXg6L14oLT9cXFxcZCpcXFxcLj9cXFxcZCssKXsyfSgtP1xcXFxkKlxcXFwuP1xcXFxkKykkLyddLFxyXG4gICAgICAgICAgICAgICAgZG91YmxlOiBbJ3JlZ2V4Oi9eKC0/XFxcXGQqXFxcXC4/XFxcXGQrKSQvJ10sXHJcbiAgICAgICAgICAgICAgICBtYXQzOiBbJ3JlZ2V4Oi9eKC0/XFxcXGQqXFxcXC4/XFxcXGQrLCl7OH0oLT9cXFxcZCpcXFxcLj9cXFxcZCspJC8nXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBUSU1FT1VUOiAxMDAwXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBjdXJyZW50U2VjdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyc1t0aGlzLmN1cnJlbnRTZWN0aW9uSW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHNlbGVjdFNlY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VjdGlvbkluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNBcnJheSh4KXtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCk7IC8vIFZ1ZSBkb2Vzbid0IGxpa2UgaXQgaWYgSSB1c2UgdGhpcyBkaXJlY3RseVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBhcmFtQ2hhbmdlZChzZWN0aW9uLCBzdWJzZWN0aW9uLCB0aXRsZSwgdHlwZSwgdmFsdWUsIHZhbGlkKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlZFBhcmFtcy5oYXNPd25Qcm9wZXJ0eShzZWN0aW9uKSl7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VkUGFyYW1zW3NlY3Rpb25dLmhhc093blByb3BlcnR5KHN1YnNlY3Rpb24pKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRQYXJhbXNbc2VjdGlvbl1bc3Vic2VjdGlvbl1bdGl0bGVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUsIHZhbGlkOiB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZFBhcmFtc1tzZWN0aW9uXVtzdWJzZWN0aW9uXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXToge3R5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSwgdmFsaWQ6IHZhbGlkfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRQYXJhbXNbc2VjdGlvbl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgW3N1YnNlY3Rpb25dOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZV06IHt0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUsIHZhbGlkOiB2YWxpZH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2F2ZVBhcmFtcygpe1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzZWN0aW9uTmFtZSBpbiB0aGlzLmNoYW5nZWRQYXJhbXMpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3Rpb24gPSB0aGlzLmNoYW5nZWRQYXJhbXNbc2VjdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3Vic2VjdGlvbk5hbWUgaW4gc2VjdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YnNlY3Rpb24gPSBzZWN0aW9uW3N1YnNlY3Rpb25OYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXJhbU5hbWUgaW4gc3Vic2VjdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbSA9IHN1YnNlY3Rpb25bcGFyYW1OYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS52YWxpZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpjcmVhdGUtc25hY2tiYXInLCAnQSBwYXJhbWV0ZXIgdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uOiAgICBzZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNlY3Rpb246IHN1YnNlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICAgICAgcGFyYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgcGFyYW0udHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAgICAgIHBhcmFtLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpZW50OjpzZXRfcGFyYW1ldGVycycsIGRhdGEpO1xyXG4gICAgICAgICAgICAvLyBTaG93IG1lc3NhZ2Ugb24gdGltZW91dFxyXG4gICAgICAgICAgICBsZXQgcmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RTZXRQYXJhbWV0ZXJzQWNrVGltZSA8IHJlcXVlc3RUaW1lKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpjcmVhdGUtc25hY2tiYXInLCAnUGFyYW1ldGVycyBub3Qgc2V0IHdpdGhpbiB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMuVElNRU9VVCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVzZXRQYXJhbXMoKXtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NsaWVudDo6Z2V0X3BhcmFtZXRlcnMnKTtcclxuICAgICAgICAgICAgbGV0IHJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzTGFzdFVwZGF0ZVRpbWUgPCByZXF1ZXN0VGltZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJywgJ1BhcmFtZXRlcnMgbm90IHJlY2VpdmVkIHdpdGhpbiB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMuVElNRU9VVCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0VmFsaWRhdGlvblJ1bGUodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJ1bGVzW3R5cGVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgICdzZXJ2ZXI6OnNldF9wYXJhbWV0ZXJzX2FjaycoKXtcclxuICAgICAgICAgICAgdGhpcy5sYXN0U2V0UGFyYW1ldGVyc0Fja1RpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLnZpZXcucGFyYW1zLXZpZXcge1xyXG4gICAgcGFkZGluZzogMjRweDtcclxuXHJcbiAgICAucGFnZS1oZWFkZXIge1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTZweDtcclxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG5cclxuICAgICAgICAuYWN0aW9uLWJ1dHRvbnMge1xyXG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogYXV0bztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLnBhZ2UtY29udGVudCB7XHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBwYWRkaW5nOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC5wYWdlLXNpZGViYXIge1xyXG4gICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNFRUU7XHJcbiAgICAgICAgd2lkdGg6IDIxNnB4O1xyXG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC5wYWdlLW1haW4ge1xyXG4gICAgICAgIHBhZGRpbmc6IDE2cHg7XHJcbiAgICAgICAgZmxleC1ncm93OiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC5zaWRlYmFyLW1lbnUge1xyXG4gICAgICAgIHBhZGRpbmctdG9wOiAxNnB4O1xyXG4gICAgfVxyXG5cclxuICAgIC5zaWRlYmFyLW1lbnUtaXRlbSB7XHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgcGFkZGluZzogOHB4O1xyXG4gICAgICAgIHBhZGRpbmctbGVmdDogMjRweDtcclxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICAgICAgY29sb3I6ICRkYXJrLXByaW1hcnk7XHJcblxyXG4gICAgICAgICYuc2VsZWN0ZWQge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUVFO1xyXG4gICAgICAgICAgICBjb2xvcjogJHByaW1hcnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFBhcmFtc1ZpZXcudnVlPzEwZWEyYzIwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidmlldyBwYXJhbXMtdmlld1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhZ2VcXFwiPlxcbiAgICAgICAgPGgxIGNsYXNzPVxcXCJwYWdlLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRpdGxlXFxcIj5QYXJhbXM8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYWN0aW9uLWJ1dHRvbnNcXFwiPlxcbiAgICAgICAgICAgICAgICA8dWktYnV0dG9uIGNvbG9yPVxcXCJwcmltYXJ5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJzYXZlUGFyYW1zXFxcIlxcbiAgICAgICAgICAgICAgICA+U2F2ZTwvdWktYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XFxcInJlc2V0UGFyYW1zXFxcIlxcbiAgICAgICAgICAgICAgICA+UmVzZXQ8L3VpLWJ1dHRvbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvaDE+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2Utc2lkZWJhclxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNpZGViYXItbWVudVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzaWRlYmFyLW1lbnUtaXRlbVxcXCIgdi1mb3I9XFxcIihpbmRleCwgc2VjdGlvbikgaW4gcGFyYW1ldGVyc1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XFxcInNlbGVjdFNlY3Rpb24oaW5kZXgpXFxcIiA6Y2xhc3M9XFxcInsgJ3NlbGVjdGVkJzogaW5kZXggPT09IGN1cnJlbnRTZWN0aW9uSW5kZXggfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgID57eyBzZWN0aW9uLnRpdGxlIH19PC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLW1haW5cXFwiIHYtaWY9XFxcInBhcmFtZXRlcnMubGVuZ3RoID4gMFxcXCI+XFxuICAgICAgICAgICAgICAgIDx1aS1jb2xsYXBzaWJsZVxcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XFxcInNlY3Rpb24gaW4gY3VycmVudFNlY3Rpb24uc3ViU2VjdGlvbnNcXFwiIDpoZWFkZXI9XFxcInNlY3Rpb24udGl0bGVcXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhcmFtXFxcIiB2LWZvcj1cXFwicGFyYW0gaW4gc2VjdGlvbi5wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpsYWJlbD1cXFwicGFyYW0udGl0bGVcXFwiIDpuYW1lPVxcXCJwYXJhbS50aXRsZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOnZhbHVlLnN5bmM9XFxcInBhcmFtLnZhbHVlXFxcIiA6dmFsaWQuc3luYz1cXFwicGFyYW0udmFsaWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBjaGFuZ2VkPVxcXCJwYXJhbUNoYW5nZWQoY3VycmVudFNlY3Rpb24udGl0bGUsIHNlY3Rpb24udGl0bGUsIHBhcmFtLnRpdGxlLCBwYXJhbS50eXBlLCBwYXJhbS52YWx1ZSwgcGFyYW0udmFsaWQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dmFsaWRhdGlvbi1ydWxlcz1cXFwiZ2V0VmFsaWRhdGlvblJ1bGUocGFyYW0udHlwZSlcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L3VpLWNvbGxhcHNpYmxlPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvUGFyYW1zVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzPy11cmwhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhc3R5bHVzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1NldHRpbmdzVmlldy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TZXR0aW5nc1ZpZXcudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXHZpZXdzXFxcXFNldHRpbmdzVmlldy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TZXR0aW5nc1ZpZXcudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYTZlOTFiMTQvU2V0dGluZ3NWaWV3LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL3ZpZXdzL1NldHRpbmdzVmlldy52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlcj8tdXJsIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vc3R5bHVzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cInZpZXcgc2V0dGluZ3Mtdmlld1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlXCI+XHJcbiAgICAgICAgICAgIDxoMSBjbGFzcz1cInBhZ2UtaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1idXR0b25zXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVpLWJ1dHRvbiBjb2xvcj1cInByaW1hcnlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJzYXZlU2V0dGluZ3NcIlxyXG4gICAgICAgICAgICAgICAgICAgID5TYXZlPC91aS1idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVpLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJyZXNldFNldHRpbmdzXCJcclxuICAgICAgICAgICAgICAgICAgICA+UmVzZXQ8L3VpLWJ1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2gxPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1jb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1tYWluXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVpLWNvbGxhcHNpYmxlIHYtZm9yPVwic2VjdGlvbiBpbiBzZXR0aW5nc1wiIDpoZWFkZXI9XCJzZWN0aW9uLnRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZXR0aW5nXCIgdi1mb3I9XCJzZXR0aW5nIGluIHNlY3Rpb24uc2V0dGluZ3NcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1aS10ZXh0Ym94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmxhYmVsPVwic2V0dGluZy50aXRsZVwiIDpuYW1lPVwic2V0dGluZy50aXRsZVwiIDp2YWx1ZS5zeW5jPVwic2V0dGluZy52YWx1ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNoYW5nZWQ9XCJzZXR0aW5nQ2hhbmdlZChzZWN0aW9uLnRpdGxlLCBzZXR0aW5nLnRpdGxlLCBzZXR0aW5nLnZhbHVlKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC91aS10ZXh0Ym94PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L3VpLWNvbGxhcHNpYmxlPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBnZXRTZXR0aW5ncywgZ2V0U2V0dGluZ3NMYXN0VXBkYXRlVGltZSB9IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgc2V0dGluZ3M6IGdldFNldHRpbmdzLFxyXG4gICAgICAgICAgICBzZXR0aW5nc0xhc3RVcGRhdGVUaW1lOiBnZXRTZXR0aW5nc0xhc3RVcGRhdGVUaW1lXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYW5nZWRTZXR0aW5nczoge30sXHJcbiAgICAgICAgICAgIGxhc3RTZXRTZXR0aW5nc0Fja1RpbWU6IG51bGwsXHJcbiAgICAgICAgICAgIFRJTUVPVVQ6IDEwMDBcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgc2V0dGluZ0NoYW5nZWQoc2VjdGlvbiwgcGFyYW0sIHZhbHVlKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlZFNldHRpbmdzLmhhc093blByb3BlcnR5KHNlY3Rpb24pKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZFNldHRpbmdzW3NlY3Rpb25dW3BhcmFtXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkU2V0dGluZ3Nbc2VjdGlvbl0gPSB7W3BhcmFtXTogdmFsdWV9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2F2ZVNldHRpbmdzKCl7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb24gaW4gdGhpcy5jaGFuZ2VkU2V0dGluZ3Mpe1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2V0dGluZyBpbiB0aGlzLmNoYW5nZWRTZXR0aW5nc1tzZWN0aW9uXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbjogc2VjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICAgc2V0dGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICAgdGhpcy5jaGFuZ2VkU2V0dGluZ3Nbc2VjdGlvbl1bc2V0dGluZ11cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpZW50OjpzZXRfc2V0dGluZ3MnLCBkYXRhKTtcclxuICAgICAgICAgICAgLy8gU2hvdyBtZXNzYWdlIG9uIHRpbWVvdXRcclxuICAgICAgICAgICAgbGV0IHJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0U2V0U2V0dGluZ3NBY2tUaW1lIDwgcmVxdWVzdFRpbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdhcHA6OmNyZWF0ZS1zbmFja2JhcicsICdTZXR0aW5ncyBub3Qgc2V0IHdpdGhpbiB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMuVElNRU9VVCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVzZXRTZXR0aW5ncygpe1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnY2xpZW50OjpnZXRfc2V0dGluZ3MnKTtcclxuICAgICAgICAgICAgbGV0IHJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nc0xhc3RVcGRhdGVUaW1lIDwgcmVxdWVzdFRpbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdhcHA6OmNyZWF0ZS1zbmFja2JhcicsICdTZXR0aW5ncyBub3QgcmVjZWl2ZWQgd2l0aGluIHRpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcy5USU1FT1VUKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgICdzZXJ2ZXI6OnNldF9zZXR0aW5nc19hY2snKCl7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFNldFNldHRpbmdzQWNrVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic3R5bHVzXCI+XHJcbkBpbXBvcnQgJ35zdHlsZXMvX3ZhcmlhYmxlcyc7XHJcblxyXG4udmlldy5zZXR0aW5ncy12aWV3IHtcclxuICAgIHBhZGRpbmc6IDI0cHg7XHJcblxyXG4gICAgLnBhZ2UtaGVhZGVyIHtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XHJcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuXHJcbiAgICAgICAgLmFjdGlvbi1idXR0b25zIHtcclxuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IGF1dG87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFNldHRpbmdzVmlldy52dWU/NzU4OWFkZTRcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwidmlldyBzZXR0aW5ncy12aWV3XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFnZVxcXCI+XFxuICAgICAgICA8aDEgY2xhc3M9XFxcInBhZ2UtaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICBTZXR0aW5nc1xcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFjdGlvbi1idXR0b25zXFxcIj5cXG4gICAgICAgICAgICAgICAgPHVpLWJ1dHRvbiBjb2xvcj1cXFwicHJpbWFyeVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIEBjbGljaz1cXFwic2F2ZVNldHRpbmdzXFxcIlxcbiAgICAgICAgICAgICAgICA+U2F2ZTwvdWktYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8dWktYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICBAY2xpY2s9XFxcInJlc2V0U2V0dGluZ3NcXFwiXFxuICAgICAgICAgICAgICAgID5SZXNldDwvdWktYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9oMT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2UtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFnZS1tYWluXFxcIj5cXG4gICAgICAgICAgICAgICAgPHVpLWNvbGxhcHNpYmxlIHYtZm9yPVxcXCJzZWN0aW9uIGluIHNldHRpbmdzXFxcIiA6aGVhZGVyPVxcXCJzZWN0aW9uLnRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNldHRpbmdcXFwiIHYtZm9yPVxcXCJzZXR0aW5nIGluIHNlY3Rpb24uc2V0dGluZ3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx1aS10ZXh0Ym94XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpsYWJlbD1cXFwic2V0dGluZy50aXRsZVxcXCIgOm5hbWU9XFxcInNldHRpbmcudGl0bGVcXFwiIDp2YWx1ZS5zeW5jPVxcXCJzZXR0aW5nLnZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAY2hhbmdlZD1cXFwic2V0dGluZ0NoYW5nZWQoc2VjdGlvbi50aXRsZSwgc2V0dGluZy50aXRsZSwgc2V0dGluZy52YWx1ZSlcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvdWktdGV4dGJveD5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L3VpLWNvbGxhcHNpYmxlPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlld3MvU2V0dGluZ3NWaWV3LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3M/LXVybCEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFzdHlsdXMhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vR2NzSW5kaWNhdG9ycy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NJbmRpY2F0b3JzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxHY3NJbmRpY2F0b3JzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0djc0luZGljYXRvcnMudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNmNiMGM3ZWEvR2NzSW5kaWNhdG9ycy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyPy11cmwhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9zdHlsdXMtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9HY3NJbmRpY2F0b3JzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlPlxyXG4gICAgPHVsIGNsYXNzPVwiZ2NzLWluZGljYXRvcnNcIiB2LWlmPVwid2Ftdi5sb2FkZWRcIj5cclxuICAgICAgICA8bGkgY2xhc3M9XCJpbmRpY2F0b3IgaGVhZGluZ1wiPlxyXG4gICAgICAgICAgICA8dWktaWNvblxyXG4gICAgICAgICAgICAgICAgaWNvbj1cIm5hdmlnYXRpb25cIiA6c3R5bGU9XCJ7IHRyYW5zZm9ybTogJ3JvdGF0ZVooJyArIHdhbXYuaGVhZGluZyArICdkZWcpJyB9XCJcclxuICAgICAgICAgICAgPjwvdWktaWNvbj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiIHYtaHRtbD1cImhlYWRpbmdcIj48L3NwYW4+XHJcbiAgICAgICAgPC9saT5cclxuXHJcbiAgICAgICAgPGxpIGNsYXNzPVwiaW5kaWNhdG9yIHNwZWVkXCI+XHJcbiAgICAgICAgICAgIDx1aS1pY29uIGljb249XCJuZXR3b3JrX2NoZWNrXCI+PC91aS1pY29uPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZhbHVlXCIgdi10ZXh0PVwic3BlZWRcIj48L3NwYW4+XHJcbiAgICAgICAgPC9saT5cclxuXHJcbiAgICAgICAgPGxpIGNsYXNzPVwiaW5kaWNhdG9yIGJhdHRlcnlcIj5cclxuICAgICAgICAgICAgPHVpLWljb24gaWNvbj1cImJhdHRlcnlfZnVsbFwiPjwvdWktaWNvbj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiIHYtdGV4dD1cImJhdHRlcnlcIj48L3NwYW4+XHJcbiAgICAgICAgPC9saT5cclxuXHJcbiAgICAgICAgPGxpIGNsYXNzPVwiaW5kaWNhdG9yIHNpZ25hbFwiPlxyXG4gICAgICAgICAgICA8dWktaWNvbiBpY29uPVwid2lmaVwiPjwvdWktaWNvbj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiIHYtdGV4dD1cInNpZ25hbFwiPjwvc3Bhbj5cclxuICAgICAgICA8L2xpPlxyXG4gICAgPC91bD5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IGdldFdhbXYgfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHZ1ZXg6IHtcclxuICAgICAgICBnZXR0ZXJzOiB7XHJcbiAgICAgICAgICAgIHdhbXY6IGdldFdhbXZcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgaGVhZGluZygpIHtcclxuICAgICAgICAgICAgbGV0IGRlZyA9IE1hdGgucm91bmQodGhpcy53YW12LmhlYWRpbmcpOyAvLyAwIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgIHJldHVybiBkZWcgKyAnJmRlZzsgJyArIHRoaXMuZGVncmVlVG9Ub0NhcmRpbmFsKHRoaXMud2Ftdi5oZWFkaW5nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzcGVlZCgpIHtcclxuICAgICAgICAgICAgbGV0IHNwZCA9IE1hdGgucm91bmQodGhpcy53YW12LnNwZWVkKjEwMCkvMTAwOyAvLyAyIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgIHJldHVybiBzcGQgKyAnIEsnO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJhdHRlcnkoKSB7XHJcbiAgICAgICAgICAgIGxldCBwZXJjID0gTWF0aC5yb3VuZCh0aGlzLndhbXYuYmF0dGVyeSoxMDApLzEwMDsgLy8gMiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICByZXR1cm4gcGVyYyArICclJztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaWduYWwoKSB7XHJcbiAgICAgICAgICAgIGxldCBwZXJjID0gTWF0aC5yb3VuZCh0aGlzLndhbXYuc2lnbmFsKjEwMCkvMTAwOyAvLyAyIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgIHJldHVybiBwZXJjICsgJyUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGRlZ3JlZVRvVG9DYXJkaW5hbChkZWdyZWUpIHtcclxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDIyLjUgfHwgZGVncmVlID49IDMzNy41KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ04nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgNjcuNSAmJiBkZWdyZWUgPj0gMjIuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdORSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAxMTIuNSAmJiBkZWdyZWUgPj0gNjcuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdFJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDE1Ny41ICYmIGRlZ3JlZSA+PSAxMTIuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdTRSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAyMDIuNSAmJiBkZWdyZWUgPj0gMTU3LjUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnUyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAyNDcuNSAmJiBkZWdyZWUgPj0gMjAyLjUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnU1cnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMjkyLjUgJiYgZGVncmVlID49IDI0Ny41KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1cnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMzM3LjUgJiYgZGVncmVlID49IDI5Mi41KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05XJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxyXG5AaW1wb3J0ICd+c3R5bGVzL192YXJpYWJsZXMnO1xyXG5cclxuLmdjcy1pbmRpY2F0b3JzIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHJpZ2h0OiAxNnB4O1xyXG4gICAgdG9wOiAxMnB4O1xyXG4gICAgaGVpZ2h0OiAyNHB4O1xyXG4gICAgcGFkZGluZzogMDtcclxuICAgIG1hcmdpbjogMDtcclxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XHJcblxyXG4gICAgLmluZGljYXRvciB7XHJcbiAgICAgICAgY29sb3I6IGFscGhhKHdoaXRlLCAwLjgpO1xyXG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcclxuXHJcbiAgICAgICAgJjpsYXN0LWNoaWxkIHtcclxuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xyXG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAwO1xyXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAuaGVhZGluZyAudWktaWNvbiB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAmLmJhdHRlcnksXHJcbiAgICAgICAgJi5zaWduYWwge1xyXG4gICAgICAgICAgICB3aWR0aDogODhweDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICYuaGVhZGluZyB7XHJcbiAgICAgICAgICAgIHdpZHRoOiA5NnB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJi5zcGVlZCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiA4OHB4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAudWktaWNvbiB7XHJcbiAgICAgICAgY29sb3I6IGFscGhhKHdoaXRlLCAwLjUpO1xyXG4gICAgfVxyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEdjc0luZGljYXRvcnMudnVlPzcxZDliY2IxXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjx1bCBjbGFzcz1cXFwiZ2NzLWluZGljYXRvcnNcXFwiIHYtaWY9XFxcIndhbXYubG9hZGVkXFxcIj5cXG4gICAgPGxpIGNsYXNzPVxcXCJpbmRpY2F0b3IgaGVhZGluZ1xcXCI+XFxuICAgICAgICA8dWktaWNvblxcbiAgICAgICAgICAgIGljb249XFxcIm5hdmlnYXRpb25cXFwiIDpzdHlsZT1cXFwieyB0cmFuc2Zvcm06ICdyb3RhdGVaKCcgKyB3YW12LmhlYWRpbmcgKyAnZGVnKScgfVxcXCJcXG4gICAgICAgID48L3VpLWljb24+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidmFsdWVcXFwiIHYtaHRtbD1cXFwiaGVhZGluZ1xcXCI+PC9zcGFuPlxcbiAgICA8L2xpPlxcblxcbiAgICA8bGkgY2xhc3M9XFxcImluZGljYXRvciBzcGVlZFxcXCI+XFxuICAgICAgICA8dWktaWNvbiBpY29uPVxcXCJuZXR3b3JrX2NoZWNrXFxcIj48L3VpLWljb24+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidmFsdWVcXFwiIHYtdGV4dD1cXFwic3BlZWRcXFwiPjwvc3Bhbj5cXG4gICAgPC9saT5cXG5cXG4gICAgPGxpIGNsYXNzPVxcXCJpbmRpY2F0b3IgYmF0dGVyeVxcXCI+XFxuICAgICAgICA8dWktaWNvbiBpY29uPVxcXCJiYXR0ZXJ5X2Z1bGxcXFwiPjwvdWktaWNvbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2YWx1ZVxcXCIgdi10ZXh0PVxcXCJiYXR0ZXJ5XFxcIj48L3NwYW4+XFxuICAgIDwvbGk+XFxuXFxuICAgIDxsaSBjbGFzcz1cXFwiaW5kaWNhdG9yIHNpZ25hbFxcXCI+XFxuICAgICAgICA8dWktaWNvbiBpY29uPVxcXCJ3aWZpXFxcIj48L3VpLWljb24+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidmFsdWVcXFwiIHYtdGV4dD1cXFwic2lnbmFsXFxcIj48L3NwYW4+XFxuICAgIDwvbGk+XFxuPC91bD5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0djc0luZGljYXRvcnMudnVlXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcz8tdXJsIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIXN0eWx1cyEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9Tb2NrZXRJb01hbmFnZXIudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vU29ja2V0SW9NYW5hZ2VyLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxTb2NrZXRJb01hbmFnZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU29ja2V0SW9NYW5hZ2VyLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTJiZTdmZjc4L1NvY2tldElvTWFuYWdlci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9Tb2NrZXRJb01hbmFnZXIudnVlXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXI/LXVybCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L3N0eWx1cy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1NvY2tldElvTWFuYWdlci52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXY+PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4vLyBUaGlzIGNvbXBvbmVudCBtYW5hZ2VzIGNvbW11bmljYXRpb24gd2l0aCB0aGUgc2VydmVyIHZpYSBhIHNvY2tldFxyXG4vLyBJdCBhbGxvd3MgZm9yIG90aGVyIGNvbXBvbmVudHMgdG8gaW5pdGlhdGUgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcclxuLy8gVGhlc2UgYXJlIHRoZSByZXF1ZXN0cyB0aGF0IGNhbiBiZSBpbml0aWF0ZWQ6XHJcbiAgICAvLyBTdGF0dXMsIGdldF9wYXJhbWV0ZXJzLCBzZXRfcGFyYW1ldGVycywgZ2V0X3NldHRpbmdzLCBzZXRfc2V0dGluZ3MsXHJcbiAgICAvLyBTZXRfbWlzc2lvbnMsIGdldF9taXNzaW9ucywgc2V0X21pc3Npb24sIGdldF9taXNzaW9uLFxyXG4gICAgLy8gQXJtLCBkaXNhcm0sIHN0YXJ0X21pc3Npb24sIHN0b3BfbWlzc2lvbiwgcmVzdW1lX21pc3Npb24sIGtpbGwsIHVua2lsbCxcclxuLy8gQSBjb21wb25lbnQgaW5pdGlhdGVzIGEgcmVxdWVzdCByMSBieSBkaXNwYXRjaGluZyBhbiBldmVudCBjbGllbnQ6OnIxXHJcbiAgICAvLyBUaGUgZXZlbnQgZ29lcyB1cCB0byBBcHAudnVlLCB0aGVuIGRvd24gdG8gdGhpcyBjb21wb25lbnRcclxuICAgIC8vIFRoaXMgY29tcG9uZW50IHNlbmRzIGEgY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcclxuXHJcbmltcG9ydCBzb2NrZXRfaW9fY2xpZW50IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xyXG5pbXBvcnQgcHJvdG9idWYgZnJvbSAncHJvdG9idWZqcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gICAgZ2V0TWlzc2lvbnMsIGdldE1pc3Npb25zTGFzdFVwZGF0ZVRpbWUsXHJcbiAgICBnZXRQYXJhbWV0ZXJzLCBnZXRQYXJhbWV0ZXJzTGFzdFVwZGF0ZVRpbWUsXHJcbiAgICBnZXRTZXR0aW5ncywgZ2V0U2V0dGluZ3NMYXN0VXBkYXRlVGltZVxyXG59IGZyb20gJ3N0b3JlL2dldHRlcnMnO1xyXG5pbXBvcnQgeyBzZXRXYW12LCBzZXRQYXJhbWV0ZXJzLCBzZXRTZXR0aW5ncywgc2V0TWlzc2lvbnMgfSBmcm9tICdzdG9yZS9hY3Rpb25zJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHZ1ZXg6IHtcclxuICAgICAgICBnZXR0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1pc3Npb25zOiAgICAgICAgICAgICAgICAgZ2V0TWlzc2lvbnMsXHJcbiAgICAgICAgICAgIG1pc3Npb25zTGFzdFVwZGF0ZVRpbWU6ICAgZ2V0TWlzc2lvbnNMYXN0VXBkYXRlVGltZSxcclxuICAgICAgICAgICAgcGFyYW1ldGVyczogICAgICAgICAgICAgICBnZXRQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzTGFzdFVwZGF0ZVRpbWU6IGdldFBhcmFtZXRlcnNMYXN0VXBkYXRlVGltZSxcclxuICAgICAgICAgICAgc2V0dGluZ3M6ICAgICAgICAgICAgICAgICBnZXRTZXR0aW5ncyxcclxuICAgICAgICAgICAgc2V0dGluZ3NMYXN0VXBkYXRlVGltZTogICBnZXRTZXR0aW5nc0xhc3RVcGRhdGVUaW1lXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIHNldFdhbXYsXHJcbiAgICAgICAgICAgIHNldFBhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgIHNldFNldHRpbmdzLFxyXG4gICAgICAgICAgICBzZXRNaXNzaW9uc1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBUSU1FT1VUOiAxMDAwLFxyXG4gICAgICAgICAgICBzb2NrZXQ6IG51bGwsXHJcbiAgICAgICAgICAgIHByb3RvQnVpbGRlcjogbnVsbCxcclxuICAgICAgICAgICAgcHJvdG9Qa2c6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICByZWFkeSgpIHtcclxuICAgICAgICAvLyBMb2FkIC5wcm90byBmaWxlc1xyXG4gICAgICAgIHRoaXMucHJvdG9CdWlsZGVyID0gcHJvdG9idWYubmV3QnVpbGRlcigpO1xyXG4gICAgICAgIHByb3RvYnVmLmxvYWRQcm90b0ZpbGUoJ2Fzc2V0cy9wcm90by9UZXN0LnByb3RvJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb3RvUGtnID0gdGhpcy5wcm90b0J1aWxkZXIuYnVpbGQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0U29ja2V0KCk7XHJcbiAgICAgICAgfSwgdGhpcy5wcm90b0J1aWxkZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaW5pdFNvY2tldCgpe1xyXG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldF9pb19jbGllbnQoJ2xvY2FsaG9zdDozMDAwJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgdGhpcy5oYW5kbGVDb25uZWN0aW9uRXN0YWJsaXNoZWQpO1xyXG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkaXNjb25uZWN0ZWQgZnJvbSBzZXJ2ZXInKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdTdGF0dXMnLCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0YXR1cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdHZXRQYXJhbWV0ZXJzUmVzcG9uc2UnLCB0aGlzLmhhbmRsZUdldFBhcmFtZXRlcnNSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdHZXRTZXR0aW5nc1Jlc3BvbnNlJywgICB0aGlzLmhhbmRsZUdldFNldHRpbmdzUmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbignR2V0TWlzc2lvbnNSZXNwb25zZScsICAgdGhpcy5oYW5kbGVHZXRNaXNzaW9uc1Jlc3BvbnNlKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ0dldE1pc3Npb25SZXNwb25zZScsICAgIHRoaXMuaGFuZGxlR2V0TWlzc2lvblJlc3BvbnNlKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ1NldFBhcmFtZXRlcnNBY2snLCAgICAgIHRoaXMuaGFuZGxlU2V0UGFyYW1ldGVyc0Fjayk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdTZXRTZXR0aW5nc0FjaycsICAgICAgICB0aGlzLmhhbmRsZVNldFNldHRpbmdzQWNrKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ1NldE1pc3Npb25BY2snLCAgICAgICAgIHRoaXMuaGFuZGxlU2V0TWlzc2lvbkFjayk7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdTZXRNaXNzaW9uc0FjaycsICAgICAgICB0aGlzLmhhbmRsZVNldE1pc3Npb25zQWNrKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ0F0dGVudGlvbicsICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXR0ZW50aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbmRNc2cobXNnVHlwZSwgZGF0YSl7XHJcbiAgICAgICAgICAgIGxldCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBsZXQgbXNnO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1zZ1R5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29udHJvbGxlcl9ldmVudCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnQ29udHJvbGxlckFjdGlvbicsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ2V0X3BhcmFtZXRlcnMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRQYXJhbWV0ZXJzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5ldyB0aGlzLnByb3RvUGtnLkdldFBhcmFtZXRlcnModGltZXN0YW1wKSkudG9CdWZmZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzZXRfcGFyYW1ldGVycyc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2RhdGEnIHNob3VsZCBoYXZlIHRoaXMgZm9ybTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3tzZWN0aW9uOiBzMSwgc3Vic2VjdGlvbjogczIsIHRpdGxlOiB0MSwgdmFsdWU6IHYxfSwgLi4uXVxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyB0aGlzLnByb3RvUGtnLlNldFBhcmFtZXRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBhcmFtIG9mIGRhdGEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuYWRkKCdwYXJhbWV0ZXJzJywgbmV3IHRoaXMucHJvdG9Qa2cuUGFyYW1ldGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uc2VjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnN1YnNlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS50aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1UeXBlKHBhcmFtLnR5cGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ1NldFBhcmFtZXRlcnMnLCBtc2cudG9CdWZmZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdnZXRfc2V0dGluZ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRTZXR0aW5ncycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChuZXcgdGhpcy5wcm90b1BrZy5HZXRTZXR0aW5ncyh0aW1lc3RhbXApKS50b0J1ZmZlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NldF9zZXR0aW5ncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2RhdGEnIHNob3VsZCBoYXZlIHRoaXMgZm9ybTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3tzZWN0aW9uOiBzMSwgdGl0bGU6IHQxLCB2YWx1ZTogdjF9LCAuLi5dXHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRoaXMucHJvdG9Qa2cuU2V0U2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNldHRpbmcgb2YgZGF0YSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5hZGQoJ3NldHRpbmdzJywgbmV3IHRoaXMucHJvdG9Qa2cuU2V0dGluZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcuc2VjdGlvbiwgc2V0dGluZy50aXRsZSwgc2V0dGluZy52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnU2V0U2V0dGluZ3MnLCBtc2cudG9CdWZmZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdnZXRfbWlzc2lvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1pc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV3IHRoaXMucHJvdG9Qa2cuR2V0TWlzc2lvbih0aW1lc3RhbXApKS50b0J1ZmZlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NldF9taXNzaW9uJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgZWxlbWVudHMgb2YgJ21pc3Npb25zJyBpbiBzdG9yZS5qcyBmb3IgZXhwZWN0ZWQgJ2RhdGEnIGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyB0aGlzLnByb3RvUGtnLlNldE1pc3Npb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IHRoaXMucHJvdG9Qa2cuTWlzc2lvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBtc2cubWlzc2lvbi50aXRsZSA9IGRhdGEudGl0bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnLm1pc3Npb24ub3JpZ2luTGF0aXR1ZGUgPSBkYXRhLm9yaWdpbi5sYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnLm1pc3Npb24ub3JpZ2luTG9uZ2l0dWRlID0gZGF0YS5vcmlnaW4ubG5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHdheXBvaW50IG9mIGRhdGEud2F5cG9pbnRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLm1pc3Npb24uYWRkKCd3YXlwb2ludHMnLCBuZXcgdGhpcy5wcm90b1BrZy5NaXNzaW9uLldheXBvaW50KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F5cG9pbnQudGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndheXBvaW50VHlwZSh3YXlwb2ludC50eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdheXBvaW50LnBvc2l0aW9uLmxhdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdheXBvaW50LnBvc2l0aW9uLmxuZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnU2V0TWlzc2lvbicsIG1zZy50b0J1ZmZlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2dldF9taXNzaW9ucyc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1pc3Npb25zJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5ldyB0aGlzLnByb3RvUGtnLkdldE1pc3Npb25zKHRpbWVzdGFtcCkpLnRvQnVmZmVyKClcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2V0X21pc3Npb25zJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgJ21pc3Npb25zJyBpbiBzdG9yZS5qcyBmb3IgZXhwZWN0ZWQgJ2RhdGEnIGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyB0aGlzLnByb3RvUGtnLlNldE1pc3Npb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBtaXNzaW9uIG9mIGRhdGEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG5ldyB0aGlzLnByb3RvUGtnLk1pc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS50aXRsZSA9IG1pc3Npb24udGl0bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ub3JpZ2luTGF0aXR1ZGUgPSBtaXNzaW9uLm9yaWdpbi5sYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ub3JpZ2luTG9uZ2l0dWRlID0gbWlzc2lvbi5vcmlnaW4ubG5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB3YXlwb2ludCBvZiBtaXNzaW9uLndheXBvaW50cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmFkZCgnd2F5cG9pbnRzJywgbmV3IHRoaXMucHJvdG9Qa2cuTWlzc2lvbi5XYXlwb2ludChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXlwb2ludC50aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndheXBvaW50VHlwZSh3YXlwb2ludC50eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXlwb2ludC5wb3NpdGlvbi5sYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F5cG9pbnQucG9zaXRpb24ubG5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuYWRkKCdtaXNzaW9ucycsIG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdTZXRNaXNzaW9ucycsIG1zZy50b0J1ZmZlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2FybSc6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRoaXMucHJvdG9Qa2cuQ29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvUGtnLkNvbW1hbmQuVHlwZS5BUk1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ0NvbW1hbmQnLCBtc2cudG9CdWZmZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNhcm0nOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyB0aGlzLnByb3RvUGtnLkNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90b1BrZy5Db21tYW5kLlR5cGUuRElTQVJNXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdDb21tYW5kJywgbXNnLnRvQnVmZmVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnRfbWlzc2lvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRoaXMucHJvdG9Qa2cuQ29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvUGtnLkNvbW1hbmQuVHlwZS5TVEFSVFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnQ29tbWFuZCcsIG1zZy50b0J1ZmZlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0b3BfbWlzc2lvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRoaXMucHJvdG9Qa2cuQ29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvUGtnLkNvbW1hbmQuVHlwZS5TVE9QXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdDb21tYW5kJywgbXNnLnRvQnVmZmVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVzdW1lX21pc3Npb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyB0aGlzLnByb3RvUGtnLkNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90b1BrZy5Db21tYW5kLlR5cGUuUkVTVU1FXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdDb21tYW5kJywgbXNnLnRvQnVmZmVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAna2lsbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRoaXMucHJvdG9Qa2cuQ29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvUGtnLkNvbW1hbmQuVHlwZS5LSUxMXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdDb21tYW5kJywgbXNnLnRvQnVmZmVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndW5raWxsJzpcclxuICAgICAgICAgICAgICAgICAgICBtc2cgPSBuZXcgdGhpcy5wcm90b1BrZy5Db21tYW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG9Qa2cuQ29tbWFuZC5UeXBlLlVOS0lMTFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnQ29tbWFuZCcsIG1zZy50b0J1ZmZlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21hbnVhbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRoaXMucHJvdG9Qa2cuQ29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvUGtnLkNvbW1hbmQuVHlwZS5NQU5VQUxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ0NvbW1hbmQnLCBtc2cudG9CdWZmZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRvJzpcclxuICAgICAgICAgICAgICAgICAgICBtc2cgPSBuZXcgdGhpcy5wcm90b1BrZy5Db21tYW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG9Qa2cuQ29tbWFuZC5UeXBlLkFVVE9NQVRJQ1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnQ29tbWFuZCcsIG1zZy50b0J1ZmZlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkVzdGFibGlzaGVkKCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQgdG8gc2VydmVyJyk7XHJcbiAgICAgICAgICAgIC8vIEdldCBwYXJhbWV0ZXJzIG9uY2UgYXQgc3RhcnR1cFxyXG4gICAgICAgICAgICB0aGlzLnNlbmRNc2coJ2dldF9wYXJhbWV0ZXJzJywgbnVsbCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc0xhc3RVcGRhdGVUaW1lID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BhcmFtZXRlcnMgbGlzdCBmYWlsZWQgdG8gbG9hZCdcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzLlRJTUVPVVQpO1xyXG4gICAgICAgICAgICAvLyBHZXQgc2V0dGluZ3Mgb25jZSBhdCBzdGFydHVwXHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnZ2V0X3NldHRpbmdzJywgbnVsbCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3NMYXN0VXBkYXRlVGltZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcHA6OmNyZWF0ZS1zbmFja2JhcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZXR0aW5ncyBsaXN0IGZhaWxlZCB0byBsb2FkJ1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMuVElNRU9VVCk7XHJcbiAgICAgICAgICAgIC8vIExvYWQgbWlzc2lvbnMgb25jZSBhdCBzdGFydHVwXHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnZ2V0X21pc3Npb25zJywgbnVsbCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlzc2lvbnNMYXN0VXBkYXRlVGltZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcHA6OmNyZWF0ZS1zbmFja2JhcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdNaXNzaW9uIGxpc3QgZmFpbGVkIHRvIGxvYWQnXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcy5USU1FT1VUKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhbmRsZVN0YXR1cyhkYXRhKXtcclxuICAgICAgICAgICAgLy8gRGVjb2RlIG1lc3NhZ2VcclxuICAgICAgICAgICAgbGV0IG1zZztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG1zZyA9IHRoaXMucHJvdG9Qa2cuU3RhdHVzLmRlY29kZShkYXRhKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGRlY29kZSBTdGF0dXMgbWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3YW12XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V2Ftdih7XHJcbiAgICAgICAgICAgICAgICBsb2FkZWQ6ICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7bGF0OiBtc2cubGF0aXR1ZGUsIGxuZzogbXNnLmxvbmdpdHVkZX0sXHJcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiAgbXNnLmhlYWRpbmcsXHJcbiAgICAgICAgICAgICAgICBzcGVlZDogICAgbXNnLnNwZWVkLFxyXG4gICAgICAgICAgICAgICAgYmF0dGVyeTogIG1zZy5iYXR0ZXJ5LFxyXG4gICAgICAgICAgICAgICAgYXJtZWQ6ICAgIG1zZy5hcm1lZCxcclxuICAgICAgICAgICAgICAgIG1vZGU6ICAgICB0aGlzLm1vZGVTdHJpbmcobXNnLm1vZGUpLFxyXG4gICAgICAgICAgICAgICAgc2lnbmFsOiAgIG1zZy5zaWduYWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVHZXRQYXJhbWV0ZXJzUmVzcG9uc2UoZGF0YSl7XHJcbiAgICAgICAgICAgIC8vIERlY29kZSBtZXNzYWdlXHJcbiAgICAgICAgICAgIGxldCBwYXJhbXNNc2c7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXNNc2cgPSB0aGlzLnByb3RvUGtnLkdldFBhcmFtZXRlcnNSZXNwb25zZS5kZWNvZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkZWNvZGUgR2V0UGFyYW1ldGVyc1Jlc3BvbnNlIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJlY2VpdmVkIHBhcmFtZXRlcnMgaW50byBhbiBpbnRlcm1lZGlhdGUgc3RydWN0dXJlXHJcbiAgICAgICAgICAgICAgICAvLyB7c2VjdGlvbjE6IHtzdWJzZWN0aW9uMToge3BhcmFtMToge3R5cGU6IHQyLCB2YWx1ZTogdjF9fSwgLi4ufSwgLi4ufVxyXG4gICAgICAgICAgICBsZXQgdGVtcFBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHBhcmFtc01zZy5wYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgICAgIGlmIChwLnNlY3Rpb24gaW4gdGVtcFBhcmFtcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViU2VjdGlvbiBpbiB0ZW1wUGFyYW1zW3Auc2VjdGlvbl0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50aXRsZSBpbiB0ZW1wUGFyYW1zW3Auc2VjdGlvbl1bcC5zdWJTZWN0aW9uXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV2FybmluZzogcmVjZWl2ZWQgZHVwbGljYXRlIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFBhcmFtc1twLnNlY3Rpb25dW3Auc3ViU2VjdGlvbl1bcC50aXRsZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5wYXJhbVR5cGVTdHJpbmcocC50eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBQYXJhbXNbcC5zZWN0aW9uXVtwLnN1YlNlY3Rpb25dID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3AudGl0bGVdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5wYXJhbVR5cGVTdHJpbmcocC50eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFBhcmFtc1twLnNlY3Rpb25dID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbcC5zdWJTZWN0aW9uXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3AudGl0bGVdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5wYXJhbVR5cGVTdHJpbmcocC50eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGludGVybWVkaWF0ZSBzdHJ1Y3R1cmUgaW50byBvbmUgdGhhdCBpcyBjb252ZW5pZW50IGZvciBkaXNwbGF5XHJcbiAgICAgICAgICAgIGxldCBuZXdQYXJhbXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvbk5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVtcFBhcmFtcykpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3Rpb24gPSB0ZW1wUGFyYW1zW3NlY3Rpb25OYW1lXTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdTZWN0aW9uID0ge3RpdGxlOiBzZWN0aW9uTmFtZSwgc3ViU2VjdGlvbnM6IFtdfTtcclxuICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKG5ld1NlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViU2VjdGlvbk5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2VjdGlvbikpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJTZWN0aW9uID0gc2VjdGlvbltzdWJTZWN0aW9uTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1N1YlNlY3Rpb24gPSB7dGl0bGU6IHN1YlNlY3Rpb25OYW1lLCBwYXJhbXM6IFtdfTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTZWN0aW9uLnN1YlNlY3Rpb25zLnB1c2gobmV3U3ViU2VjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcGFyYW1OYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN1YlNlY3Rpb24pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmFtID0gc3ViU2VjdGlvbltwYXJhbU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdWJTZWN0aW9uLnBhcmFtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJhbU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcmFtLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNldCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVycyhuZXdQYXJhbXMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyYW1ldGVycyBsb2FkZWQuJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVHZXRTZXR0aW5nc1Jlc3BvbnNlKGRhdGEpe1xyXG4gICAgICAgICAgICAvLyBEZWNvZGUgbWVzc2FnZVxyXG4gICAgICAgICAgICBsZXQgc2V0dGluZ3NNc2c7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc01zZyA9IHRoaXMucHJvdG9Qa2cuR2V0U2V0dGluZ3NSZXNwb25zZS5kZWNvZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkZWNvZGUgR2V0U2V0dGluZ3NSZXNwb25zZSBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29udmVydCByZWNlaXZlZCBzZXR0aW5ncyBpbnRvIGFuIGludGVybWVkaWF0ZSBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgICAgIC8vIHtzZWN0aW9uMToge3NldHRpbmcxOiB2YWx1ZTF9LCAuLi59XHJcbiAgICAgICAgICAgIGxldCB0ZW1wU2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiBzZXR0aW5nc01zZy5zZXR0aW5ncyl7XHJcbiAgICAgICAgICAgICAgICBpZiAocy5zZWN0aW9uIGluIHRlbXBTZXR0aW5ncyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMudGl0bGUgaW4gdGVtcFNldHRpbmdzW3Muc2VjdGlvbl0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV2FybmluZzogcmVjZWl2ZWQgZHVwbGljYXRlIHNldHRpbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU2V0dGluZ3Nbcy5zZWN0aW9uXVtzLnRpdGxlXSA9IHMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wU2V0dGluZ3Nbcy5zZWN0aW9uXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3MudGl0bGVdOiBzLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGludGVybWVkaWF0ZSBzdHJ1Y3R1cmUgaW50byBvbmUgdGhhdCBpcyBjb252ZW5pZW50IGZvciBkaXNwbGF5XHJcbiAgICAgICAgICAgIGxldCBuZXdTZXR0aW5ncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzZWN0aW9uTmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZW1wU2V0dGluZ3MpKXtcclxuICAgICAgICAgICAgICAgIGxldCBzZWN0aW9uID0gdGVtcFNldHRpbmdzW3NlY3Rpb25OYW1lXTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdTZWN0aW9uID0ge3RpdGxlOiBzZWN0aW9uTmFtZSwgc2V0dGluZ3M6IFtdfTtcclxuICAgICAgICAgICAgICAgIG5ld1NldHRpbmdzLnB1c2gobmV3U2VjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZXR0aW5nTmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWN0aW9uKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VjdGlvbi5zZXR0aW5ncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNldHRpbmdOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VjdGlvbltzZXR0aW5nTmFtZV1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTZXQgc2V0dGluZ3NcclxuICAgICAgICAgICAgdGhpcy5zZXRTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5ncyBsb2FkZWQuJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVHZXRNaXNzaW9uc1Jlc3BvbnNlKGRhdGEpe1xyXG4gICAgICAgICAgICAvLyBEZWNvZGUgbWVzc2FnZVxyXG4gICAgICAgICAgICBsZXQgbWlzc2lvbnNNc2c7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBtaXNzaW9uc01zZyA9IHRoaXMucHJvdG9Qa2cuR2V0TWlzc2lvbnNSZXNwb25zZS5kZWNvZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkZWNvZGUgR2V0TWlzc2lvbnNSZXNwb25zZSBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29udmVydCByZWNlaXZlZCBtaXNzaW9ucyBpbnRvIGEgY2VydGFpbiBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgbGV0IG5ld01pc3Npb25zID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IG1pc3Npb24gb2YgbWlzc2lvbnNNc2cubWlzc2lvbnMpe1xyXG4gICAgICAgICAgICAgICAgbmV3TWlzc2lvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1pc3Npb24udGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogbWlzc2lvbi5vcmlnaW5MYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBtaXNzaW9uLm9yaWdpbkxvbmdpdHVkZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2F5cG9pbnRzOiBtaXNzaW9uLndheXBvaW50cy5tYXAoKHdwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogd3AudGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLndheXBvaW50VHlwZVN0cmluZyh3cC50eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiB3cC5sYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsbmc6IHdwLmxvbmdpdHVkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTZXQgbWlzc2lvbnNcclxuICAgICAgICAgICAgdGhpcy5zZXRNaXNzaW9ucyhuZXdNaXNzaW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW9ucyBsb2FkZWQuJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVHZXRNaXNzaW9uUmVzcG9uc2UoZGF0YSl7XHJcbiAgICAgICAgICAgIC8vIERlY29kZSBtZXNzYWdlXHJcbiAgICAgICAgICAgIGxldCBtaXNzaW9uTXNnO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbWlzc2lvbk1zZyA9IHRoaXMucHJvdG9Qa2cuR2V0TWlzc2lvblJlc3BvbnNlLmRlY29kZShkYXRhKS5taXNzaW9uO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gZGVjb2RlIEdldE1pc3Npb25SZXNwb25zZSBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29udmVydCByZWNlaXZlZCBtaXNzaW9uIGludG8gYSBjZXJ0YWluIHN0cnVjdHVyZSwgYW5kIGFwcGVuZCBpdCB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICB0aGlzLm1pc3Npb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IG1pc3Npb25Nc2cudGl0bGUsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IHtcclxuICAgICAgICAgICAgICAgICAgICBsYXQ6IG1pc3Npb25Nc2cub3JpZ2luTGF0aXR1ZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbG5nOiBtaXNzaW9uTXNnLm9yaWdpbkxvbmdpdHVkZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHdheXBvaW50czogbWlzc2lvbk1zZy53YXlwb2ludHMubWFwKCh3cCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB3cC50aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy53YXlwb2ludFR5cGVTdHJpbmcod3AudHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IHdwLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiB3cC5sb25naXR1ZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3Npb24gZG93bmxvYWRlZC4nKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhbmRsZVNldFBhcmFtZXRlcnNBY2soZGF0YSl7XHJcbiAgICAgICAgICAgIC8vIERlY29kZSBtZXNzYWdlXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvUGtnLlNldFBhcmFtZXRlcnNBY2suZGVjb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gZGVjb2RlIFNldFBhcmFtZXRlcnNBY2sgbWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdGlmeVxyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpjcmVhdGUtc25hY2tiYXInLCAnUGFyYW1ldGVycyBzZXQgb24gdmVoaWNsZScpO1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2VydmVyOjpzZXRfcGFyYW1ldGVyc19hY2snKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhbmRsZVNldFNldHRpbmdzQWNrKGRhdGEpe1xyXG4gICAgICAgICAgICAvLyBEZWNvZGUgbWVzc2FnZVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b1BrZy5TZXRTZXR0aW5nc0Fjay5kZWNvZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkZWNvZGUgU2V0U2V0dGluZ3NBY2sgbWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdGlmeVxyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnYXBwOjpjcmVhdGUtc25hY2tiYXInLCAnU2V0dGluZ3Mgc2V0IG9uIHNlcnZlcicpO1xyXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2VydmVyOjpzZXRfc2V0dGluZ3NfYWNrJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVTZXRNaXNzaW9uQWNrKGRhdGEpe1xyXG4gICAgICAgICAgICAvLyBEZWNvZGUgbWVzc2FnZVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b1BrZy5TZXRNaXNzaW9uQWNrLmRlY29kZShkYXRhKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGRlY29kZSBTZXRNaXNzaW9uQWNrIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOb3RpZnlcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJywgJ01pc3Npb24gc2V0IG9uIHZlaGljbGUnKTtcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3NlcnZlcjo6c2V0X21pc3Npb25fYWNrJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVTZXRNaXNzaW9uc0FjayhkYXRhKXtcclxuICAgICAgICAgICAgLy8gRGVjb2RlIG1lc3NhZ2VcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9Qa2cuU2V0TWlzc2lvbnNBY2suZGVjb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gZGVjb2RlIFNldE1pc3Npb25zQWNrIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOb3RpZnlcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJywgJ01pc3Npb24gbGlzdCBzZXQgb24gc2VydmVyJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYW5kbGVBdHRlbnRpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIC8vIERlY29kZSBtZXNzYWdlXHJcbiAgICAgICAgICAgIGxldCBhdHRlbnRpb25Nc2c7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhdHRlbnRpb25Nc2cgPSB0aGlzLnByb3RvUGtnLkF0dGVudGlvbi5kZWNvZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkZWNvZGUgQXR0ZW50aW9uIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG1lc3NhZ2VcclxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2FwcDo6Y3JlYXRlLXNuYWNrYmFyJywgYXR0ZW50aW9uTXNnLm1zZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBVc2VkIGZvciBjb252ZXJzaW9uIGZyb20gcHJvdG9jb2wgYnVmZmVyIHZhbHVlcyB0by9mcm9tIHN0cmluZ3MgdXNlZCBieSBjb21wb25lbnRzXHJcbiAgICAgICAgbW9kZVN0cmluZyhtb2RlKXtcclxuICAgICAgICAgICAgc3dpdGNoIChtb2RlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wcm90b1BrZy5TdGF0dXMuTW9kZS5TVE9QUEVEOiByZXR1cm4gJ2lkbGUnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLnByb3RvUGtnLlN0YXR1cy5Nb2RlLkFVVE86ICAgIHJldHVybiAnYXV0byc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMucHJvdG9Qa2cuU3RhdHVzLk1vZGUuUEFVU0VEOiAgcmV0dXJuICdwYXVzZWQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLnByb3RvUGtnLlN0YXR1cy5Nb2RlLktJTExFRDogIHJldHVybiAna2lsbGVkJztcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wcm90b1BrZy5TdGF0dXMuTW9kZS5NQU5VQUw6ICByZXR1cm4gJ21hbnVhbCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZSB0eXBlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmFtVHlwZVN0cmluZyh0eXBlKXtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wcm90b1BrZy5QYXJhbWV0ZXIuVHlwZS5ET1VCTEU6IHJldHVybiAnZG91YmxlJztcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wcm90b1BrZy5QYXJhbWV0ZXIuVHlwZS5WRUMzOiAgIHJldHVybiAndmVjMyc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMucHJvdG9Qa2cuUGFyYW1ldGVyLlR5cGUuTUFUMzogICByZXR1cm4gJ21hdDMnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciB0eXBlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmFtVHlwZShzdHIpe1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0cil7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gdGhpcy5wcm90b1BrZy5QYXJhbWV0ZXIuVHlwZS5ET1VCTEU7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd2ZWMzJzogICByZXR1cm4gdGhpcy5wcm90b1BrZy5QYXJhbWV0ZXIuVHlwZS5WRUMzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWF0Myc6ICAgcmV0dXJuIHRoaXMucHJvdG9Qa2cuUGFyYW1ldGVyLlR5cGUuTUFUMztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgdHlwZSBzdHJpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2F5cG9pbnRUeXBlU3RyaW5nKHR5cGUpe1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLnByb3RvUGtnLk1pc3Npb24uV2F5cG9pbnQuVHlwZS5HT19UT19QT0lOVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2dvX3RvX3BvaW50JztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdheXBvaW50IHR5cGUgc3RyaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHdheXBvaW50VHlwZShzdHIpe1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0cil7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdnb190b19wb2ludCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9Qa2cuTWlzc2lvbi5XYXlwb2ludC5UeXBlLkdPX1RPX1BPSU5UO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgd2F5cG9pbnQgdHlwZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICAnY2xpZW50OjpnZXRfcGFyYW1ldGVycycoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnZ2V0X3BhcmFtZXRlcnMnLCBudWxsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpzZXRfcGFyYW1ldGVycycocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnc2V0X3BhcmFtZXRlcnMnLCBwYXJhbXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmdldF9zZXR0aW5ncycoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnZ2V0X3NldHRpbmdzJywgbnVsbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c2V0X3NldHRpbmdzJyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNc2coJ3NldF9zZXR0aW5ncycsIHNldHRpbmdzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpzZXRfbWlzc2lvbnMnKG1pc3Npb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnc2V0X21pc3Npb25zJywgbWlzc2lvbnMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmdldF9taXNzaW9ucycoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnZ2V0X21pc3Npb25zJywgbnVsbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c2V0X21pc3Npb24nKG1pc3Npb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdzZXRfbWlzc2lvbicsIG1pc3Npb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmdldF9taXNzaW9uJygpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdnZXRfbWlzc2lvbicsIG51bGwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmFybScoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygnYXJtJywgbnVsbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6ZGlzYXJtJygpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdkaXNhcm0nLCBudWxsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpzdGFydF9taXNzaW9uJygpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdzdGFydF9taXNzaW9uJywgbnVsbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6c3RvcF9taXNzaW9uJygpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdzdG9wX21pc3Npb24nLCBudWxsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpyZXN1bWVfbWlzc2lvbicoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1zZygncmVzdW1lX21pc3Npb24nLCBudWxsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjpraWxsJygpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdraWxsJywgbnVsbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJ2NsaWVudDo6dW5raWxsJygpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCd1bmtpbGwnLCBudWxsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAnY2xpZW50OjptYW51YWwnKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNc2coJ21hbnVhbCcsIG51bGwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgICdjbGllbnQ6OmF1dG8nKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNc2coJ2F1dG8nLCBudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICdjbGllbnQ6OmNvbnRyb2xsZXJfZXZlbnQnKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTXNnKCdjb250cm9sbGVyX2V2ZW50JyxkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzdHlsdXNcIj5cclxuQGltcG9ydCAnfnN0eWxlcy9tYWluJztcclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogU29ja2V0SW9NYW5hZ2VyLnZ1ZT81Y2EzMjg4ZVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiAkT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktbmFtZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsKHVyaSwgbG9jKXtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICB2YXIgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wYXJzZXVyaS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZGVidWcvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kZWJ1Zy9kZWJ1Zy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbi8qKlxuICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbnNwID0gZmFsc2U7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICBzdHIgKz0gb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuICAgIHN0ciArPSAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT0gb2JqLm5zcCkge1xuICAgIG5zcCA9IHRydWU7XG4gICAgc3RyICs9IG9iai5uc3A7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgaWYgKG5zcCkge1xuICAgICAgc3RyICs9ICcsJztcbiAgICAgIG5zcCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgaWYgKG5zcCkgc3RyICs9ICcsJztcbiAgICBzdHIgKz0ganNvbi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICB9XG5cbiAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBwID0ge307XG4gIHZhciBpID0gMDtcblxuICAvLyBsb29rIHVwIHR5cGVcbiAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB0cnkge1xuICAgICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcidcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2pzb24zL2xpYi9qc29uMy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihmbil7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbihkYXRhKXtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbigpe1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGU7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24obnNwKXtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9ICByZXF1aXJlKCcuL2xpYi8nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZWpzb24gPSByZXF1aXJlKCdwYXJzZWpzb24nKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe31cblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG4gICAgKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG4gICAgICAgbG9jYXRpb24ucG9ydCA6XG4gICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogdGhpcy5wYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IHRoaXMucG9saWN5UG9ydCxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgcGZ4OiB0aGlzLnBmeCxcbiAgICBrZXk6IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiB0aGlzLmNlcnQsXG4gICAgY2E6IHRoaXMuY2EsXG4gICAgY2lwaGVyczogdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVyc1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCl7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uKHBhY2tldCl7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSlcbiAgICAsIGZhaWxlZCA9IGZhbHNlXG4gICAgLCBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCl7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09IG1zZy50eXBlICYmICdwcm9iZScgPT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCl7XG4gICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlKCl7XG4gICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSh0byl7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy9SZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAoKXtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcblxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIGNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2goZSkgeyB9XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKlxuICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG4gKlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9jb3JzLmpzXG4gKi9cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2hhcy1jb3JzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG9wdHMpe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbihkYXRhLCBmbil7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oZnJvbUVycm9yKXtcbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5zcGxpdCgnOycpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciB1aThBcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG4gIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanNcbiAqKiBtb2R1bGUgaWQgPSAxODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuICB2YXIgcGVuZGluZyA9IDA7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UoKXtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGlmKG51bWJlclRvb0xvbmcpIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbmdpbmUuaW8tcGFyc2VyL34vaGFzLWJpbmFyeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLXBhcnNlci9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKGNoYXJzKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcbiAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG4gICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FmdGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMC4wJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91dGY4L3V0ZjguanNcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmxvYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcGFyc2Vxcy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG4gICwgbGVuZ3RoID0gNjRcbiAgLCBtYXAgPSB7fVxuICAsIHNlZWQgPSAwXG4gICwgaSA9IDBcbiAgLCBwcmV2O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgZG8ge1xuICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArJy4nKyBlbmNvZGUoc2VlZCsrKTtcbn1cblxuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG4vL1xueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3llYXN0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogQ2FsbGJhY2tzIGNvdW50LlxuICovXG5cbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJyxlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xudmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cblxuICB0aGlzLndzID0gQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2J1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIUJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy90aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHdzIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2luZGV4b2YvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3BhcnNlanNvbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbihjb21wcmVzcyl7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90by1hcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvbXBvbmVudC1iaW5kL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gICAgICBpZiAob2JqLnRvSlNPTiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9oYXMtYmluYXJ5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWNrbzIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBwcm90b2J1Zi5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXCJieXRlYnVmZmVyXCJdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKSwgdHJ1ZSk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJQcm90b0J1ZlwiXSA9IGZhY3RvcnkoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJ5dGVCdWZmZXJcIl0pO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oQnl0ZUJ1ZmZlciwgaXNDb21tb25KUykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgUHJvdG9CdWYgbmFtZXNwYWNlLlxyXG4gICAgICogQGV4cG9ydHMgUHJvdG9CdWZcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgdmFyIFByb3RvQnVmID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IWZ1bmN0aW9uKG5ldzogQnl0ZUJ1ZmZlciwgLi4uWypdKX1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuQnl0ZUJ1ZmZlciA9IEJ5dGVCdWZmZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzogTG9uZywgLi4uWypdKX1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuTG9uZyA9IEJ5dGVCdWZmZXIuTG9uZyB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdG9CdWYuanMgdmVyc2lvbi5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuVkVSU0lPTiA9IFwiNS4wLjFcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpcmUgdHlwZXMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYXJpbnQgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRml4ZWQgNjQgYml0cyB3aXJlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0ID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExlbmd0aCBkZWxpbWl0ZWQgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSA9IDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBncm91cCB3aXJlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUCA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmQgZ3JvdXAgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQID0gNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpeGVkIDMyIGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMiA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYWNrYWJsZSB3aXJlIHR5cGVzLlxyXG4gICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTID0gW1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0LFxyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHlwZXMuXHJcbiAgICAgKiBAZGljdFxyXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZyx7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyLCBkZWZhdWx0VmFsdWU6ICp9Pn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5UWVBFUyA9IHtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHByb3RvYnVmIHNwZWMuXHJcbiAgICAgICAgXCJpbnQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiaW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidWludDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJ1aW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ludDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzaW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImludDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInVpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwidWludDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5VWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzaW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInNpbnQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJib29sXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJib29sXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkb3VibGVcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImRvdWJsZVwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdHJpbmdcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0sXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJieXRlc1wiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwgLy8gb3ZlcnJpZGRlbiBpbiB0aGUgY29kZSwgbXVzdCBiZSBhIHVuaXF1ZSBpbnN0YW5jZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMixcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQzMlwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmaXhlZDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAgUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuVVpFUk8gOiB1bmRlZmluZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ZpeGVkNjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInNmaXhlZDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZsb2F0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJlbnVtXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJlbnVtXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1lc3NhZ2VcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ3JvdXBcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVAsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZCBtYXAga2V5IHR5cGVzLlxyXG4gICAgICogQHR5cGUgeyFBcnJheS48IU9iamVjdC48c3RyaW5nLHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXIsIGRlZmF1bHRWYWx1ZTogKn0+Pn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5NQVBfS0VZX1RZUEVTID0gW1xyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXVxyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gZmllbGQgaWQuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLklEX01JTiA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIGZpZWxkIGlkLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5JRF9NQVggPSAweDFGRkZGRkZGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgZmllbGQgbmFtZXMgd2lsbCBiZSBjb252ZXJ0ZWQgZnJvbSB1bmRlcnNjb3JlIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UuIERlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgKiAgTXVzdCBiZSBzZXQgcHJpb3IgdG8gcGFyc2luZy5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsIG1lc3NhZ2VzIGFyZSBwb3B1bGF0ZWQgd2l0aCAoc2V0WCwgc2V0X3gpIGFjY2Vzc29ycyBmb3IgZWFjaCBmaWVsZC4gVGhpcyBjYW4gYmUgZGlzYWJsZWQgYnlcclxuICAgICAqICBzZXR0aW5nIHRoaXMgdG8gYGZhbHNlYCBwcmlvciB0byBidWlsZGluZyBtZXNzYWdlcy5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wb3B1bGF0ZUFjY2Vzc29ycyA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlcyBhcmUgcG9wdWxhdGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMgaWYgYSBmaWVsZCBpcyBub3QgcHJlc2VudCBvbiB0aGUgd2lyZS4gVG8gZGlzYWJsZVxyXG4gICAgICogIHRoaXMgYmVoYXZpb3IsIHNldCB0aGlzIHNldHRpbmcgdG8gYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wb3B1bGF0ZURlZmF1bHRzID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuVXRpbFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5VdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdG9CdWYgdXRpbGl0aWVzLlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5VdGlsXG4gICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciBVdGlsID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaWYgcnVubmluZyBpbiBub2RlIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBVdGlsLklTX05PREUgPSAhIShcbiAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzKycnID09PSAnW29iamVjdCBwcm9jZXNzXScgJiYgIXByb2Nlc3NbJ2Jyb3dzZXInXVxuICAgICAgICApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH1cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVXRpbC5YSFIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE5vIGRlcGVuZGVuY2llcyBwbGVhc2UsIHJlZjogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy94bWxodHRwLmh0bWxcbiAgICAgICAgICAgIHZhciBYTUxIdHRwRmFjdG9yaWVzID0gW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCl9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKX0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/WE1MSHR0cFJlcXVlc3R9ICovXG4gICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDtpPFhNTEh0dHBGYWN0b3JpZXMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIHRyeSB7IHhociA9IFhNTEh0dHBGYWN0b3JpZXNbaV0oKTsgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXhocilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGEgcmVzb3VyY2UuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFJlc291cmNlIHBhdGhcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbig/c3RyaW5nKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUgcmVzb3VyY2UncyBjb250ZW50cy4gSWYgb21pdHRlZCB0aGUgcmVzb3VyY2Ugd2lsbFxuICAgICAgICAgKiAgIGJlIGZldGNoZWQgc3luY2hyb25vdXNseS4gSWYgdGhlIHJlcXVlc3QgZmFpbGVkLCBjb250ZW50cyB3aWxsIGJlIG51bGwuXG4gICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd8dW5kZWZpbmVkfSBSZXNvdXJjZSBjb250ZW50cyBpZiBjYWxsYmFjayBpcyBvbWl0dGVkIChudWxsIGlmIHRoZSByZXF1ZXN0IGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBVdGlsLmZldGNoID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICBpZiAoVXRpbC5JU19OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIitkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gVXRpbC5YSFIoKTtcbiAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgY2FsbGJhY2sgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdVc2VyLUFnZW50JywgJ1hNTEhUVFAvMS4wJyk7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIub3ZlcnJpZGVNaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9IDQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvKiByZW1vdGUgKi8geGhyLnN0YXR1cyA9PSAyMDAgfHwgLyogbG9jYWwgKi8gKHhoci5zdGF0dXMgPT0gMCAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvKiByZW1vdGUgKi8geGhyLnN0YXR1cyA9PSAyMDAgfHwgLyogbG9jYWwgKi8gKHhoci5zdGF0dXMgPT0gMCAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gY2FtZWwgY2FzZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBVdGlsLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL18oW2EtekEtWl0pL2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBVdGlsO1xuICAgIH0pKCk7XG5cclxuICAgIC8qKlxyXG4gICAgICogTGFuZ3VhZ2UgZXhwcmVzc2lvbnMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCFSZWdFeHA+fVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5MYW5nID0ge1xyXG5cclxuICAgICAgICAvLyBDaGFyYWN0ZXJzIGFsd2F5cyBlbmRpbmcgYSBzdGF0ZW1lbnRcclxuICAgICAgICBERUxJTTogL1tcXHNcXHtcXH09OzpcXFtcXF0sJ1wiXFwoXFwpPD5dL2csXHJcblxyXG4gICAgICAgIC8vIEZpZWxkIHJ1bGVzXHJcbiAgICAgICAgUlVMRTogL14oPzpyZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZHxtYXApJC8sXHJcblxyXG4gICAgICAgIC8vIEZpZWxkIHR5cGVzXHJcbiAgICAgICAgVFlQRTogL14oPzpkb3VibGV8ZmxvYXR8aW50MzJ8dWludDMyfHNpbnQzMnxpbnQ2NHx1aW50NjR8c2ludDY0fGZpeGVkMzJ8c2ZpeGVkMzJ8Zml4ZWQ2NHxzZml4ZWQ2NHxib29sfHN0cmluZ3xieXRlcykkLyxcclxuXHJcbiAgICAgICAgLy8gTmFtZXNcclxuICAgICAgICBOQU1FOiAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLyxcclxuXHJcbiAgICAgICAgLy8gVHlwZSBkZWZpbml0aW9uc1xyXG4gICAgICAgIFRZUEVERUY6IC9eW2EtekEtWl1bYS16QS1aXzAtOV0qJC8sXHJcblxyXG4gICAgICAgIC8vIFR5cGUgcmVmZXJlbmNlc1xyXG4gICAgICAgIFRZUEVSRUY6IC9eKD86XFwuP1thLXpBLVpfXVthLXpBLVpfMC05XSopKyQvLFxyXG5cclxuICAgICAgICAvLyBGdWxseSBxdWFsaWZpZWQgdHlwZSByZWZlcmVuY2VzXHJcbiAgICAgICAgRlFUWVBFUkVGOiAvXig/OlxcLlthLXpBLVpdW2EtekEtWl8wLTldKikrJC8sXHJcblxyXG4gICAgICAgIC8vIEFsbCBudW1iZXJzXHJcbiAgICAgICAgTlVNQkVSOiAvXi0/KD86WzEtOV1bMC05XSp8MHwwW3hYXVswLTlhLWZBLUZdK3wwWzAtN10rfChbMC05XSooXFwuWzAtOV0qKT8oW0VlXVsrLV0/WzAtOV0rKT8pfGluZnxuYW4pJC8sXHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9ERUM6IC9eKD86WzEtOV1bMC05XSp8MCkkLyxcclxuXHJcbiAgICAgICAgLy8gSGV4YWRlY2ltYWwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9IRVg6IC9eMFt4WF1bMC05YS1mQS1GXSskLyxcclxuXHJcbiAgICAgICAgLy8gT2N0YWwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9PQ1Q6IC9eMFswLTddKyQvLFxyXG5cclxuICAgICAgICAvLyBGbG9hdGluZyBwb2ludCBudW1iZXJzXHJcbiAgICAgICAgTlVNQkVSX0ZMVDogL14oWzAtOV0qKFxcLlswLTldKik/KFtFZV1bKy1dP1swLTldKyk/fGluZnxuYW4pJC8sXHJcblxyXG4gICAgICAgIC8vIEJvb2xlYW5zXHJcbiAgICAgICAgQk9PTDogL14oPzp0cnVlfGZhbHNlKSQvaSxcclxuXHJcbiAgICAgICAgLy8gSWQgbnVtYmVyc1xyXG4gICAgICAgIElEOiAvXig/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddKykkLyxcclxuXHJcbiAgICAgICAgLy8gTmVnYXRpdmUgaWQgbnVtYmVycyAoZW51bSB2YWx1ZXMpXHJcbiAgICAgICAgTkVHSUQ6IC9eXFwtPyg/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddKykkLyxcclxuXHJcbiAgICAgICAgLy8gV2hpdGVzcGFjZXNcclxuICAgICAgICBXSElURVNQQUNFOiAvXFxzLyxcclxuXHJcbiAgICAgICAgLy8gQWxsIHN0cmluZ3NcclxuICAgICAgICBTVFJJTkc6IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpfCg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nLFxyXG5cclxuICAgICAgICAvLyBEb3VibGUgcXVvdGVkIHN0cmluZ3NcclxuICAgICAgICBTVFJJTkdfRFE6IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpL2csXHJcblxyXG4gICAgICAgIC8vIFNpbmdsZSBxdW90ZWQgc3RyaW5nc1xyXG4gICAgICAgIFNUUklOR19TUTogLyg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLkRvdFByb3RvID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBMYW5nKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFV0aWxpdGllcyB0byBwYXJzZSAucHJvdG8gZmlsZXMuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuRG90UHJvdG9cclxuICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIERvdFByb3RvID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVG9rZW5pemVyLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxyXG4gICAgICAgICAqIEBjbGFzcyBwcm90b3R5cGUgdG9rZW5pemVyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIFByb3RvIHRvIHRva2VuaXplXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU291cmNlIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHByb3RvK1wiXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3VycmVudCBpbmRleC5cclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3VycmVudCBsaW5lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUgPSAxO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRva2VuIHN0YWNrLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3BlbmluZyBjaGFyYWN0ZXIgb2YgdGhlIGN1cnJlbnQgc3RyaW5nIHJlYWQsIGlmIGFueS5cclxuICAgICAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJpbmdPcGVuID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuRG90UHJvdG8uVG9rZW5pemVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUb2tlbml6ZXJQcm90b3R5cGUgPSBUb2tlbml6ZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHN0cmluZyBiZWdpbm5pbmcgYXQgdGhlIGN1cnJlbnQgaW5kZXguXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLl9yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciByZSA9IHRoaXMuX3N0cmluZ09wZW4gPT09ICdcIidcclxuICAgICAgICAgICAgICAgID8gTGFuZy5TVFJJTkdfRFFcclxuICAgICAgICAgICAgICAgIDogTGFuZy5TVFJJTkdfU1E7XHJcbiAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IHRoaXMuaW5kZXggLSAxOyAvLyBJbmNsdWRlIHRoZSBvcGVuIHF1b3RlXHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWModGhpcy5zb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bnRlcm1pbmF0ZWQgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gcmUubGFzdEluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5fc3RyaW5nT3Blbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0cmluZ09wZW4gPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgYnkgb25lLlxyXG4gICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFRva2VuIG9yIGBudWxsYCBvbiBFT0ZcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMuc291cmNlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RyaW5nT3BlbiAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVwZWF0LFxyXG4gICAgICAgICAgICAgICAgcHJldixcclxuICAgICAgICAgICAgICAgIG5leHQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIHdoaXRlIHNwYWNlc1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKExhbmcuV0hJVEVTUEFDRS50ZXN0KG5leHQgPSB0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLmluZGV4ID09PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSA9PT0gJy8nKSB7IC8vIExpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuc291cmNlLmNoYXJBdCgrK3RoaXMuaW5kZXgpICE9PSAnXFxuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09IHRoaXMuc291cmNlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChuZXh0ID0gdGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpKSA9PT0gJyonKSB7IC8qIEJsb2NrICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK3RoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiAhPT0gJyonIHx8IG5leHQgIT09ICcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcvJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAocmVwZWF0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIG5leHQgdG9rZW5cclxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgIExhbmcuREVMSU0ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGRlbGltID0gTGFuZy5ERUxJTS50ZXN0KHRoaXMuc291cmNlLmNoYXJBdChlbmQrKykpO1xyXG4gICAgICAgICAgICBpZiAoIWRlbGltKVxyXG4gICAgICAgICAgICAgICAgd2hpbGUoZW5kIDwgdGhpcy5zb3VyY2UubGVuZ3RoICYmICFMYW5nLkRFTElNLnRlc3QodGhpcy5zb3VyY2UuY2hhckF0KGVuZCkpKVxyXG4gICAgICAgICAgICAgICAgICAgICsrZW5kO1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnNvdXJjZS5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCA9IGVuZCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1wiJyB8fCB0b2tlbiA9PT0gXCInXCIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmdPcGVuID0gdG9rZW47XHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXHJcbiAgICAgICAgICogQHJldHVybiB7P3N0cmluZ30gVG9rZW4gb3IgYG51bGxgIG9uIEVPRlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2tlbml6ZXJQcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1swXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTa2lwcyBhIHNwZWNpZmljIHRva2VuIGFuZCB0aHJvd3MgaWYgaXQgZGlmZmVycy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGFjdHVhbCB0b2tlbiBkaWZmZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbihleHBlY3RlZCkge1xyXG4gICAgICAgICAgICB2YXIgYWN0dWFsID0gdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsICdcIithY3R1YWwrXCInLCAnXCIrZXhwZWN0ZWQrXCInIGV4cGVjdGVkXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9taXRzIGFuIG9wdGlvbmFsIHRva2VuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCBvcHRpb25hbCB0b2tlblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHRva2VuIGV4aXN0c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5vbWl0ID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBleHBlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIlRva2VuaXplcihpbmRleC9sZW5ndGgpXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlRva2VuaXplciAoXCIrdGhpcy5pbmRleCtcIi9cIit0aGlzLnNvdXJjZS5sZW5ndGgrXCIgYXQgbGluZSBcIit0aGlzLmxpbmUrXCIpXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBEb3RQcm90by5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUGFyc2VyLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxyXG4gICAgICAgICAqIEBjbGFzcyBwcm90b3R5cGUgcGFyc2VyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2VcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUGFyc2VyID0gZnVuY3Rpb24oc291cmNlKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVG9rZW5pemVyLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50biA9IG5ldyBUb2tlbml6ZXIoc291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHBhcnNpbmcgcHJvdG8zIG9yIG5vdC5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnByb3RvMyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFBhcnNlclByb3RvdHlwZSA9IFBhcnNlci5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyB0aGUgc291cmNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3BMZXZlbCA9IHtcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIltST09UXVwiLCAvLyB0ZW1wb3JhcnlcclxuICAgICAgICAgICAgICAgIFwicGFja2FnZVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwiZW51bXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImltcG9ydHNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge30sXHJcbiAgICAgICAgICAgICAgICBcInNlcnZpY2VzXCI6IFtdXHJcbiAgICAgICAgICAgICAgICAvLyBcInN5bnRheFwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgaGVhZCA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3ZWFrO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRva2VuID0gdGhpcy50bi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkIHx8IHRvcExldmVsW1wicGFja2FnZVwiXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVuZXhwZWN0ZWQgJ3BhY2thZ2UnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBwYWNrYWdlIG5hbWU6IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsW1wicGFja2FnZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkICdpbXBvcnQnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJwdWJsaWNcIiB8fCAod2VhayA9IHRva2VuID09PSBcIndlYWtcIikpIC8vIHRva2VuIGlnbm9yZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5fcmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2VhaykgLy8gaW1wb3J0IGlnbm9yZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFtcImltcG9ydHNcIl0ucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3ludGF4JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVuZXhwZWN0ZWQgJ3N5bnRheCdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b3BMZXZlbFtcInN5bnRheFwiXSA9IHRoaXMuX3JlYWRTdHJpbmcoKSkgPT09IFwicHJvdG8zXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90bzMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZSh0b3BMZXZlbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW51bSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0odG9wTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbih0b3BMZXZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VydmljZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2UodG9wTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVuZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV4dGVuZCh0b3BMZXZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5leHBlY3RlZCAnXCIgKyB0b2tlbiArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IFwiUGFyc2UgZXJyb3IgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiICsgZS5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWxldGUgdG9wTGV2ZWxbXCJuYW1lXCJdO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9wTGV2ZWw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIHRoZSBzcGVjaWZpZWQgc291cmNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHNvdXJjZSkucGFyc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyAtLS0tLSBDb252ZXJzaW9uIC0tLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIG51bWVyaWNhbCBzdHJpbmcgdG8gYW4gaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbWF5QmVOZWdhdGl2ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWtJZCh2YWx1ZSwgbWF5QmVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICB2YXIgaWQgPSAtMSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAxO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApID09ICctJykge1xyXG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSX0RFQy50ZXN0KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQodmFsdWUpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9IRVgudGVzdCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygyKSwgMTYpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9PQ1QudGVzdCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgOCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBpZCB2YWx1ZTogXCIgKyAoc2lnbiA8IDAgPyAnLScgOiAnJykgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlkID0gKHNpZ24qaWQpfDA7IC8vIEZvcmNlIHRvIDMyYml0XHJcbiAgICAgICAgICAgIGlmICghbWF5QmVOZWdhdGl2ZSAmJiBpZCA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgaWQgdmFsdWU6IFwiICsgKHNpZ24gPCAwID8gJy0nIDogJycpICsgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIG51bWVyaWNhbCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWtOdW1iZXIodmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gMTtcclxuICAgICAgICAgICAgaWYgKHZhbC5jaGFyQXQoMCkgPT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUl9ERUMudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWwsIDEwKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfSEVYLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsLnN1YnN0cmluZygyKSwgMTYpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9PQ1QudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEpLCA4KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID09PSAnaW5mJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gJ25hbicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9GTFQudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBudW1iZXIgdmFsdWU6IFwiICsgKHNpZ24gPCAwID8gJy0nIDogJycpICsgdmFsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLS0tIFJlYWRpbmcgLS0tLS0tXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgc3RyaW5nLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3JlYWRTdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gXCJcIixcclxuICAgICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgZGVsaW07XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGRlbGltID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsaW0gIT09IFwiJ1wiICYmIGRlbGltICE9PSAnXCInKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBzdHJpbmcgZGVsaW1pdGVyOiBcIitkZWxpbSk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChkZWxpbSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICB9IHdoaWxlICh0b2tlbiA9PT0gJ1wiJyB8fCB0b2tlbiA9PT0gJ1wiJyk7IC8vIG11bHRpIGxpbmU/XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG1heUJlVHlwZVJlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ8Ym9vbGVhbnxzdHJpbmd9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3JlYWRWYWx1ZSA9IGZ1bmN0aW9uKG1heUJlVHlwZVJlZikge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICdcIicgfHwgdG9rZW4gPT09IFwiJ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBta051bWJlcih0b2tlbik7XHJcbiAgICAgICAgICAgIGlmIChMYW5nLkJPT0wudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRva2VuLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJyk7XHJcbiAgICAgICAgICAgIGlmIChtYXlCZVR5cGVSZWYgJiYgTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdmFsdWU6IFwiK3Rva2VuKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gUGFyc2luZyBjb25zdHJ1Y3RzIC0tLS0tXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIG5hbWVzcGFjZSBvcHRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0xpc3RcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VPcHRpb24gPSBmdW5jdGlvbihwYXJlbnQsIGlzTGlzdCkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLm5leHQoKSxcclxuICAgICAgICAgICAgICAgIGN1c3RvbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICcoJykge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gYWxsb3cgb3B0aW9ucyBvZiB0aGUgZm9ybSBnb29nbGUucHJvdG9idWYuKiBzaW5jZSB0aGV5IHdpbGwganVzdCBnZXQgaWdub3JlZCBhbnl3YXlzXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoIS9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdCh0b2tlbikpIC8vIEZJWE1FOiBXaHkgc2hvdWxkIHRoYXQgbm90IGJlIGEgdmFsaWQgdHlwZXJlZj9cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb3B0aW9uIG5hbWU6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbSkgeyAvLyAobXlfbWV0aG9kX29wdGlvbikuZm9vLCAobXlfbWV0aG9kX29wdGlvbiksIHNvbWVfbWV0aG9kX29wdGlvbiwgKGZvby5teV9vcHRpb24pLmJhclxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKCcpJyk7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gJygnK25hbWUrJyknO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgIGlmIChMYW5nLkZRVFlQRVJFRi50ZXN0KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKCc9Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc0xpc3QpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYW4gb3B0aW9uIG9uIHRoZSBzcGVjaWZpZWQgb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj59IG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufSB2YWx1ZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldE9wdGlvbihvcHRpb25zLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbbmFtZV0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zW25hbWVdKSlcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gWyBvcHRpb25zW25hbWVdIF07XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYW4gb3B0aW9uIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuICE9PSAneycpIHsgLy8gUGxhaW4gdmFsdWVcclxuICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnRbXCJvcHRpb25zXCJdLCBuYW1lLCB0aGlzLl9yZWFkVmFsdWUodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBBZ2dyZWdhdGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb3B0aW9uIG5hbWU6IFwiICsgbmFtZSArIFwiLlwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRuLm9taXQoXCI6XCIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24ocGFyZW50W1wib3B0aW9uc1wiXSwgbmFtZSArIFwiLlwiICsgdG9rZW4sIHRoaXMuX3JlYWRWYWx1ZSh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgc2VydmljZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlU2VydmljZSA9IGZ1bmN0aW9uKHBhcmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgc2VydmljZSBuYW1lIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XHJcbiAgICAgICAgICAgIHZhciBzdmMgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogbmFtZSxcclxuICAgICAgICAgICAgICAgIFwicnBjXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKHN2Yyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJ3JwYycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlUlBDKHN2Yyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHNlcnZpY2UgdG9rZW46IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBwYXJlbnRbXCJzZXJ2aWNlc1wiXS5wdXNoKHN2Yyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgUlBDIHNlcnZpY2UgZGVmaW5pdGlvbiBvZiB0aGUgZm9ybSBbJ3JwYycsIG5hbWUsIChyZXF1ZXN0KSwgJ3JldHVybnMnLCAocmVzcG9uc2UpXS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHN2YyBTZXJ2aWNlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VTZXJ2aWNlUlBDID0gZnVuY3Rpb24oc3ZjKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gXCJycGNcIixcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHJwYyBzZXJ2aWNlIG1ldGhvZCBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSB7XHJcbiAgICAgICAgICAgICAgICBcInJlcXVlc3RcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgIFwicmVzcG9uc2VcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgIFwicmVxdWVzdF9zdHJlYW1cIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInJlc3BvbnNlX3N0cmVhbVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIoXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gXCJzdHJlYW1cIikge1xyXG4gICAgICAgICAgICAgIG1ldGhvZFtcInJlcXVlc3Rfc3RyZWFtXCJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHJwYyBzZXJ2aWNlIHJlcXVlc3QgdHlwZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICBtZXRob2RbXCJyZXF1ZXN0XCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIilcIik7XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbi50b0xvd2VyQ2FzZSgpICE9PSBcInJldHVybnNcIilcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBycGMgc2VydmljZSByZXF1ZXN0IHR5cGUgZGVsaW1pdGVyOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIihcIik7XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbi50b0xvd2VyQ2FzZSgpID09PSBcInN0cmVhbVwiKSB7XHJcbiAgICAgICAgICAgICAgbWV0aG9kW1wicmVzcG9uc2Vfc3RyZWFtXCJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1ldGhvZFtcInJlc3BvbnNlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIilcIik7XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ3snKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ29wdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcnBjIHNlcnZpY2UgdG9rZW46IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN2Y1t0eXBlXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICBzdmNbdHlwZV0gPSB7fTtcclxuICAgICAgICAgICAgc3ZjW3R5cGVdW25hbWVdID0gbWV0aG9kO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIG1lc3NhZ2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudCBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdD19IGZsZCBGaWVsZCBkZWZpbml0aW9uIGlmIHRoaXMgaXMgYSBncm91cFxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbihwYXJlbnQsIGZsZCkge1xyXG4gICAgICAgICAgICB2YXIgaXNHcm91cCA9ICEhZmxkLFxyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgdmFyIG1zZyA9IHtcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJmaWVsZHNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImVudW1zXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fSxcclxuICAgICAgICAgICAgICAgIFwic2VydmljZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcIm9uZW9mc1wiOiB7fVxyXG4gICAgICAgICAgICAgICAgLy8gXCJleHRlbnNpb25zXCI6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBcIisoaXNHcm91cCA/IFwiZ3JvdXBcIiA6IFwibWVzc2FnZVwiKStcIiBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIG1zZ1tcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIj1cIik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IG1rSWQodGhpcy50bi5uZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgbXNnW1wiaXNHcm91cFwiXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnWycgJiYgZmxkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMoZmxkKTtcclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSAhPT0gJ30nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGFuZy5SVUxFLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKG1zZywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwib25lb2ZcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VPbmVPZihtc2cpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZW51bVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRW51bShtc2cpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwibWVzc2FnZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZShtc2cpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24obXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcInNlcnZpY2VcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2UobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImV4dGVuc2lvbnNcIilcclxuICAgICAgICAgICAgICAgICAgICBtc2dbXCJleHRlbnNpb25zXCJdID0gdGhpcy5fcGFyc2VFeHRlbnNpb25SYW5nZXMoKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcInJlc2VydmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VJZ25vcmVkKCk7IC8vIFRPRE9cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImV4dGVuZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRXh0ZW5kKG1zZyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdG8zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZmllbGQgcnVsZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKG1zZywgXCJvcHRpb25hbFwiLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSB0b2tlbjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudG4ub21pdChcIjtcIik7XHJcbiAgICAgICAgICAgIHBhcmVudFtcIm1lc3NhZ2VzXCJdLnB1c2gobXNnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYW4gaWdub3JlZCBzdGF0ZW1lbnQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlSWdub3JlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50bi5wZWVrKCkgIT09ICc7JylcclxuICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIG1lc3NhZ2UgZmllbGQuXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgRmllbGQgcnVsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSBGaWVsZCB0eXBlIGlmIGFscmVhZHkga25vd24gKG5ldmVyIGtub3duIGZvciBtYXBzKVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBGaWVsZCBkZXNjcmlwdG9yXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlTWVzc2FnZUZpZWxkID0gZnVuY3Rpb24obXNnLCBydWxlLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5SVUxFLnRlc3QocnVsZSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZCBydWxlOiBcIitydWxlKTtcclxuICAgICAgICAgICAgdmFyIGZsZCA9IHtcclxuICAgICAgICAgICAgICAgIFwicnVsZVwiOiBydWxlLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fSxcclxuICAgICAgICAgICAgICAgIFwiaWRcIjogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdG9rZW47XHJcbiAgICAgICAgICAgIGlmIChydWxlID09PSBcIm1hcFwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoJzwnKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRva2VuKSAmJiAhTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIHR5cGU6IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgZmxkW1wia2V5dHlwZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKCcsJyk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEUudGVzdCh0b2tlbikgJiYgIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZDogXCIgKyB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJ0eXBlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoJz4nKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZCBuYW1lOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIj1cIik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IG1rSWQodGhpcy50bi5uZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1snKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKGZsZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHR5cGUgIT09ICd1bmRlZmluZWQnID8gdHlwZSA6IHRoaXMudG4ubmV4dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImdyb3VwXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJBIFtsZWdhY3ldIGdyb3VwIHNpbXBseSBjb21iaW5lcyBhIG5lc3RlZCBtZXNzYWdlIHR5cGUgYW5kIGEgZmllbGQgaW50byBhIHNpbmdsZSBkZWNsYXJhdGlvbi4gSW4geW91clxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUsIHlvdSBjYW4gdHJlYXQgdGhpcyBtZXNzYWdlIGp1c3QgYXMgaWYgaXQgaGFkIGEgUmVzdWx0IHR5cGUgZmllbGQgY2FsbGVkIHJlc3VsdCAodGhlIGxhdHRlciBuYW1lIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIHRvIGxvd2VyLWNhc2Ugc28gdGhhdCBpdCBkb2VzIG5vdCBjb25mbGljdCB3aXRoIHRoZSBmb3JtZXIpLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdycCA9IHRoaXMuX3BhcnNlTWVzc2FnZShtc2csIGZsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvXltBLVpdLy50ZXN0KGdycFtcIm5hbWVcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignaWxsZWdhbCBncm91cCBuYW1lOiAnK2dycFtcIm5hbWVcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcInR5cGVcIl0gPSBncnBbXCJuYW1lXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSBncnBbXCJuYW1lXCJdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHR5cGUpICYmICFMYW5nLlRZUEVSRUYudGVzdCh0eXBlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG1lc3NhZ2UgZmllbGQgdHlwZTogXCIgKyB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJ0eXBlXCJdID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZCBuYW1lOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IG1rSWQodGhpcy50bi5uZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIltcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMoZmxkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtc2dbXCJmaWVsZHNcIl0ucHVzaChmbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmxkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIG1lc3NhZ2Ugb25lb2YuXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlTWVzc2FnZU9uZU9mID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBvbmVvZiBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW4sXHJcbiAgICAgICAgICAgICAgICBmbGQ7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSAhPT0gXCJ9XCIpIHtcclxuICAgICAgICAgICAgICAgIGZsZCA9IHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKG1zZywgXCJvcHRpb25hbFwiLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJvbmVvZlwiXSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChmbGRbXCJpZFwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgbXNnW1wib25lb2ZzXCJdW25hbWVdID0gZmllbGRzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIHNldCBvZiBmaWVsZCBvcHRpb24gZGVmaW5pdGlvbnMuXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBmbGQgRmllbGQgZGVmaW5pdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZUZpZWxkT3B0aW9ucyA9IGZ1bmN0aW9uKGZsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJbXCIpO1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4sXHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLnBlZWsoKSkgIT09ICddJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oZmxkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGFuIGVudW0uXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlRW51bSA9IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgICAgICB2YXIgZW5tID0ge1xyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInZhbHVlc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICBlbm1bXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGVubSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG5hbWU6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiB0b2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBta0lkKHRoaXMudG4ubmV4dCgpLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwiW1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkT3B0aW9ucyh7IFwib3B0aW9uc1wiOiB7fSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVubVtcInZhbHVlc1wiXS5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgbXNnW1wiZW51bXNcIl0ucHVzaChlbm0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBleHRlbnNpb24gLyByZXNlcnZlZCByYW5nZXMuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFBcnJheS48IUFycmF5LjxudW1iZXI+Pn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VFeHRlbnNpb25SYW5nZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4sXHJcbiAgICAgICAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBQcm90b0J1Zi5JRF9NSU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1heFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBQcm90b0J1Zi5JRF9NQVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWtOdW1iZXIodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRuLnBlZWsoKSAhPT0gXCJ0b1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMudG4ub21pdChcIixcIikpO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhbiBleHRlbmQgYmxvY2suXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnQgUGFyZW50IG9iamVjdFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZUV4dGVuZCA9IGZ1bmN0aW9uKHBhcmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZXh0ZW5kIHJlZmVyZW5jZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB2YXIgZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgXCJyZWZcIjogdG9rZW4sXHJcbiAgICAgICAgICAgICAgICBcImZpZWxkc1wiOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChMYW5nLlJVTEUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQoZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdG8zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZmllbGQgcnVsZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKGV4dCwgXCJvcHRpb25hbFwiLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZXh0ZW5kIHRva2VuOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIC0tLS0tIEdlbmVyYWwgLS0tLS1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBhcnNlci5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJQYXJzZXIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBEb3RQcm90by5QYXJzZXIgPSBQYXJzZXI7XHJcblxyXG4gICAgICAgIHJldHVybiBEb3RQcm90bztcclxuXHJcbiAgICB9KShQcm90b0J1ZiwgUHJvdG9CdWYuTGFuZyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5SZWZsZWN0ID0gKGZ1bmN0aW9uKFByb3RvQnVmKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZXMuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdFxyXG4gICAgICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUmVmbGVjdCA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgUmVmbGVjdCBiYXNlIGNsYXNzLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0gez9Qcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT2JqZWN0IG5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHBhcmVudCwgbmFtZSkge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkZXIgcmVmZXJlbmNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLkJ1aWxkZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICogQHR5cGUgez9Qcm90b0J1Zi5SZWZsZWN0LlR9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9iamVjdCBuYW1lIGluIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZVxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5ULnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUUHJvdG90eXBlID0gVC5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZ1bGx5IHF1YWxpZmllZCBuYW1lIGFzIG9mIFwiLlBBVEguVE8uVEhJU1wiXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRQcm90b3R5cGUuZnFuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcztcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChwdHIgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBwdHIubmFtZStcIi5cIituYW1lO1xyXG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFJlZmxlY3Qgb2JqZWN0IChpdHMgZnVsbHkgcXVhbGlmaWVkIG5hbWUpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVDbGFzcyBTZXQgdG8gdHJ1ZSB0byBpbmNsdWRlIHRoZSBjbGFzcyBuYW1lLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oaW5jbHVkZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaW5jbHVkZUNsYXNzID8gdGhpcy5jbGFzc05hbWUgKyBcIiBcIiA6IFwiXCIpICsgdGhpcy5mcW4oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZHMgdGhpcyB0eXBlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGlzIHR5cGUgY2Fubm90IGJlIGJ1aWx0IGRpcmVjdGx5XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcy50b1N0cmluZyh0cnVlKStcIiBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LlQgPSBUO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0gez9Qcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcGFyZW50IE5hbWVzcGFjZSBwYXJlbnRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE5hbWVzcGFjZSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBzeW50YXggVGhlIHN5bnRheCBsZXZlbCBvZiB0aGlzIGRlZmluaXRpb24gKGUuZy4sIHByb3RvMylcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTmFtZXNwYWNlID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lLCBvcHRpb25zLCBzeW50YXgpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHBhcmVudCwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTmFtZXNwYWNlXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hpbGRyZW4gaW5zaWRlIHRoZSBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPFByb3RvQnVmLlJlZmxlY3QuVD59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3B0aW9ucy5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgKj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN5bnRheCBsZXZlbCAoZS5nLiwgcHJvdG8yIG9yIHByb3RvMykuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshc3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXggfHwgXCJwcm90bzJcIjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE5hbWVzcGFjZVByb3RvdHlwZSA9IE5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXNwYWNlJ3MgY2hpbGRyZW4uXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlQ9fSB0eXBlIEZpbHRlciB0eXBlIChyZXR1cm5zIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUgb25seSkuIERlZmF1bHRzIHRvIG51bGwgKGFsbCBjaGlsZHJlbikuXHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPFByb3RvQnVmLlJlZmxlY3QuVD59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgbnVsbDtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8azsgKytpKVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiB0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuVH0gY2hpbGQgQ2hpbGRcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNoaWxkIGNhbm5vdCBiZSBhZGRlZCAoZHVwbGljYXRlKVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXI7XHJcbiAgICAgICAgICAgIGlmIChvdGhlciA9IHRoaXMuZ2V0Q2hpbGQoY2hpbGQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZXZlcnQgY2FtZWxjYXNlIHRyYW5zZm9ybWF0aW9uIG9uIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBvdGhlci5uYW1lICE9PSBvdGhlci5vcmlnaW5hbE5hbWUgJiYgdGhpcy5nZXRDaGlsZChvdGhlci5vcmlnaW5hbE5hbWUpID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLm5hbWUgPSBvdGhlci5vcmlnaW5hbE5hbWU7IC8vIFJldmVydCBwcmV2aW91cyBmaXJzdCAoZWZmZWN0aXZlbHkga2VlcHMgYm90aCBvcmlnaW5hbHMpXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UuRmllbGQgJiYgY2hpbGQubmFtZSAhPT0gY2hpbGQub3JpZ2luYWxOYW1lICYmIHRoaXMuZ2V0Q2hpbGQoY2hpbGQub3JpZ2luYWxOYW1lKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5uYW1lID0gY2hpbGQub3JpZ2luYWxOYW1lO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRHVwbGljYXRlIG5hbWUgaW4gbmFtZXNwYWNlIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIGNoaWxkIGJ5IGl0cyBuYW1lIG9yIGlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9ySWQgQ2hpbGQgbmFtZSBvciBpZFxyXG4gICAgICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5SZWZsZWN0LlR9IFRoZSBjaGlsZCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbihuYW1lT3JJZCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdHlwZW9mIG5hbWVPcklkID09PSAnbnVtYmVyJyA/ICdpZCcgOiAnbmFtZSc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtrZXldID09PSBuYW1lT3JJZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzb2x2ZXMgYSByZWZsZWN0IG9iamVjdCBpbnNpZGUgb2YgdGhpcyBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjxzdHJpbmc+fSBxbiBRdWFsaWZpZWQgbmFtZSB0byByZXNvbHZlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gZXhjbHVkZU5vbk5hbWVzcGFjZSBFeGNsdWRlcyBub24tbmFtZXNwYWNlIHR5cGVzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBUaGUgcmVzb2x2ZWQgdHlwZSBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHFuLCBleGNsdWRlTm9uTmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gdHlwZW9mIHFuID09PSAnc3RyaW5nJyA/IHFuLnNwbGl0KFwiLlwiKSA6IHFuLFxyXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBpZiAocGFydFtpXSA9PT0gXCJcIikgeyAvLyBGdWxseSBxdWFsaWZpZWQgbmFtZSwgZS5nLiBcIi5NeS5NZXNzYWdlJ1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5wYXJlbnQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gcHRyLmdldENoaWxkKHBhcnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFJlZmxlY3QuVCkgfHwgKGV4Y2x1ZGVOb25OYW1lc3BhY2UgJiYgIShjaGlsZCBpbnN0YW5jZW9mIFJlZmxlY3QuTmFtZXNwYWNlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IGNoaWxkOyBpKys7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgcGFydC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHB0ciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBGb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gRWxzZSBzZWFyY2ggdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZXNvbHZlKHFuLCBleGNsdWRlTm9uTmFtZXNwYWNlKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9IG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHRyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHNob3J0ZXN0IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgaWYgYW55LCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlR9IHQgUmVmbGVjdGlvbiB0eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNob3J0ZXN0IHF1YWxpZmllZCBuYW1lIG9yLCBpZiB0aGVyZSBpcyBub25lLCB0aGUgZnFuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5xbiA9IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBbXSwgcHRyID0gdDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgcGFydC51bnNoaWZ0KHB0ci5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHB0ciAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGxlbj0xOyBsZW4gPD0gcGFydC5sZW5ndGg7IGxlbisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcW4gPSBwYXJ0LnNsaWNlKHBhcnQubGVuZ3RoLWxlbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gdGhpcy5yZXNvbHZlKHFuLCB0IGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxbi5qb2luKFwiLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdC5mcW4oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZHMgdGhlIG5hbWVzcGFjZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZyxGdW5jdGlvbnxPYmplY3Q+fSBSdW50aW1lIG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgIHZhciBucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9Y2hpbGRyZW4ubGVuZ3RoLCBjaGlsZDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBOYW1lc3BhY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgbnNbY2hpbGQubmFtZV0gPSBjaGlsZC5idWlsZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IHRoaXMuYnVpbGRPcHQoKSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5zO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUuYnVpbGRPcHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG9wdCA9IHt9LFxyXG4gICAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1rZXlzLmxlbmd0aDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0aW9uc1trZXlzW2ldXTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IE9wdGlvbnMgYXJlIG5vdCByZXNvbHZlZCwgeWV0LlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKHZhbCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIG9wdFtrZXldID0gdmFsLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0W2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9wdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgb3B0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBSZXR1cm5zIHRoZSBvcHRpb24gdmFsdWUgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2UgYWxsIG9wdGlvbnMgYXJlIHJldHVybmVkLlxyXG4gICAgICAgICAqIEByZXR1cm4geyp8T2JqZWN0LjxzdHJpbmcsKj59bnVsbH0gT3B0aW9uIHZhbHVlIG9yIE5VTEwgaWYgdGhlcmUgaXMgbm8gc3VjaCBvcHRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnNbbmFtZV0gIT09ICd1bmRlZmluZWQnID8gdGhpcy5vcHRpb25zW25hbWVdIDogbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5OYW1lc3BhY2UgPSBOYW1lc3BhY2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRWxlbWVudCBpbXBsZW1lbnRhdGlvbiB0aGF0IGNoZWNrcyBhbmQgY29udmVydHMgdmFsdWVzIGZvciBhXHJcbiAgICAgICAgICogcGFydGljdWxhciBmaWVsZCB0eXBlLCBhcyBhcHByb3ByaWF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFuIEVsZW1lbnQgcmVwcmVzZW50cyBhIHNpbmdsZSB2YWx1ZTogZWl0aGVyIHRoZSB2YWx1ZSBvZiBhIHNpbmd1bGFyIGZpZWxkLFxyXG4gICAgICAgICAqIG9yIGEgdmFsdWUgY29udGFpbmVkIGluIG9uZSBlbnRyeSBvZiBhIHJlcGVhdGVkIGZpZWxkIG9yIG1hcCBmaWVsZC4gVGhpc1xyXG4gICAgICAgICAqIGNsYXNzIGRvZXMgbm90IGltcGxlbWVudCB0aGVzZSBoaWdoZXItbGV2ZWwgY29uY2VwdHM7IGl0IG9ubHkgZW5jYXBzdWxhdGVzXHJcbiAgICAgICAgICogdGhlIGxvdy1sZXZlbCB0eXBlY2hlY2tpbmcgYW5kIGNvbnZlcnNpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnRcclxuICAgICAgICAgKiBAcGFyYW0ge3tuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fSB0eXBlIFJlc29sdmVkIGRhdGEgdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9IHJlc29sdmVkVHlwZSBSZXNvbHZlZCB0eXBlLCBpZiByZWxldmFudFxyXG4gICAgICAgICAqIChlLmcuIHN1Ym1lc3NhZ2UgZmllbGQpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYXBLZXkgSXMgdGhpcyBlbGVtZW50IGEgTWFwIGtleT8gVGhlIHZhbHVlIHdpbGwgYmVcclxuICAgICAgICAgKiBjb252ZXJ0ZWQgdG8gc3RyaW5nIGZvcm0gaWYgc28uXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bnRheCBTeW50YXggbGV2ZWwgb2YgZGVmaW5pbmcgbWVzc2FnZSB0eXBlLCBlLmcuLFxyXG4gICAgICAgICAqIHByb3RvMiBvciBwcm90bzMuXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCByZXNvbHZlZFR5cGUsIGlzTWFwS2V5LCBzeW50YXgpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IHR5cGUsIGFzIGEgc3RyaW5nIChlLmcuLCBpbnQzMikuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHt7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCB0eXBlIHJlZmVyZW5jZSB0byBzdWJtZXNzYWdlIG9yIGVudW0gZGVmaW5pdGlvbiwgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IHJlc29sdmVkVHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGlzIGEgbWFwIGtleS5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmlzTWFwS2V5ID0gaXNNYXBLZXk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIG9mIGRlZmluaW5nIG1lc3NhZ2UgdHlwZSwgZS5nLiwgcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTWFwS2V5ICYmIFByb3RvQnVmLk1BUF9LRVlfVFlQRVMuaW5kZXhPZih0eXBlKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbWFwIGtleSB0eXBlOiBcIiArIHR5cGUubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyBhIChuZXcpIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fSBGaWVsZCB0eXBlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9IERlZmF1bHQgdmFsdWVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0RlZmF1bHQodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFByb3RvQnVmLlRZUEVTW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUuZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZGVmYXVsdCB2YWx1ZSBmb3IgdHlwZSBcIit0eXBlLm5hbWUrXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBmaWVsZCBpbiBwcm90bzMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX0gdGhlIGZpZWxkIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnQuZGVmYXVsdEZpZWxkVmFsdWUgPSBta0RlZmF1bHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ha2VzIGEgTG9uZyBmcm9tIGEgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHt7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fHN0cmluZ3xudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHJldXNlIGl0IGZyb20gTG9uZy1saWtlIG9iamVjdHMgb3IgdG8gc2lnbmVkIGZvclxyXG4gICAgICAgICAqICBzdHJpbmdzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIExvbmdcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0xvbmcodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubG93ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUuaGlnaCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnVuc2lnbmVkID09PSAnYm9vbGVhbidcclxuICAgICAgICAgICAgICAgICYmIHZhbHVlLmxvdyA9PT0gdmFsdWUubG93ICYmIHZhbHVlLmhpZ2ggPT09IHZhbHVlLmhpZ2gpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkxvbmcodmFsdWUubG93LCB2YWx1ZS5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICd1bmRlZmluZWQnID8gdmFsdWUudW5zaWduZWQgOiB1bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UsIDEwKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCB8fCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGNvbnZlcnRpYmxlIHRvIExvbmdcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBzZXQgZm9yIGFuIGVsZW1lbnQgb2YgdGhpcyB0eXBlIChzaW5ndWxhclxyXG4gICAgICAgICAqIGZpZWxkIG9yIG9uZSBlbGVtZW50IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwKS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gVmVyaWZpZWQsIG1heWJlIGFkanVzdGVkLCB2YWx1ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHZlcmlmaWVkIGZvciB0aGlzIGVsZW1lbnQgc2xvdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3NlbGYudG9TdHJpbmcodHJ1ZSkrXCIgb2YgdHlwZSBcIitzZWxmLnR5cGUubmFtZStcIjogXCIrdmFsK1wiIChcIittc2crXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgIU5hTjogdmFsdWUgPT09IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYW4gaW50ZWdlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiA0Mjk0OTY3Mjk1ID8gdmFsdWUgfCAwIDogdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5zaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAodmFsdWUgPT09IHZhbHVlICYmIHZhbHVlICUgMSAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZXMgTG9uZy5qc1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWtMb25nKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgbnVtYmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiK3ZhbHVlOyAvLyBDb252ZXJ0IFN0cmluZyBvYmplY3QgdG8gc3RyaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcih2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci53cmFwKHZhbHVlLCBcImJhc2U2NFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnJlc29sdmVkVHlwZS5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXS5uYW1lID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzW2ldLmlkID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXS5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSAncHJvdG8zJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm90bzM6IGp1c3QgbWFrZSBzdXJlIGl0J3MgYW4gaW50ZWdlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDQyOTQ5NjcyOTUgfHwgdmFsdWUgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGluIHJhbmdlIGZvciB1aW50MzJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvMiByZXF1aXJlcyBlbnVtIHZhbHVlcyB0byBiZSB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh2YWx1ZSwgXCJub3QgYSB2YWxpZCBlbnVtIHZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5yZXNvbHZlZFR5cGUuY2xhenopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlzbWF0Y2hlZCB0eXBlOiBDb252ZXJ0IHRvIG9iamVjdCAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy9pc3N1ZXMvMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIGxldCdzIHRyeSB0byBjb25zdHJ1Y3Qgb25lIGZyb20gYSBrZXktdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5yZXNvbHZlZFR5cGUuY2xhenopKHZhbHVlKTsgLy8gTWF5IHRocm93IGZvciBhIGh1bmRyZWQgb2YgcmVhc29uc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmRlZmluZWQgdHlwZSBcIit0aGlzLnR5cGUrXCIpXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVsZW1lbnQgb24gdGhlIHdpcmUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIEZpZWxkIG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNhbGN1bGF0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS5jYWxjdWxhdGVMZW5ndGggPSBmdW5jdGlvbihpZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gMDsgLy8gTm90aGluZyB0byBlbmNvZGVcclxuICAgICAgICAgICAgLy8gVGFnIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlblxyXG4gICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSkgOiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NChCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlbWFpbmluZygpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUucmVtYWluaW5nKCkpICsgdmFsdWUucmVtYWluaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5yZXNvbHZlZFR5cGUuY2FsY3VsYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucmVzb2x2ZWRUeXBlLmNhbGN1bGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gKyBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKChpZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLiBEb2VzIG5vdCBlbmNvZGUgdGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgRmllbGQgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgZW5jb2RlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLmVuY29kZVZhbHVlID0gZnVuY3Rpb24oaWQsIHZhbHVlLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gYnVmZmVyOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgeW91IHVzZSBpbnQzMiBvciBpbnQ2NCBhcyB0aGUgdHlwZSBmb3IgYSBuZWdhdGl2ZSBudW1iZXIsIHRoZSByZXN1bHRpbmcgdmFyaW50IGlzIGFsd2F5cyB0ZW4gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb25nIOKAkyBpdCBpcywgZWZmZWN0aXZlbHksIHRyZWF0ZWQgbGlrZSBhIHZlcnkgbGFyZ2UgdW5zaWduZWQgaW50ZWdlci5cIiAoc2VlICMxMjIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzJaaWdaYWcodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgYXMtaXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQ2NFppZ1phZyh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCBzaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJvb2xcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnID8gMCA6ICEhdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IGZsb2F0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVlN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZW1haW5pbmcoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUucmVtYWluaW5nKCkrXCIgYnl0ZXMgcmVtYWluaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2T2Zmc2V0ID0gdmFsdWUub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJiKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihiYi5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoYmIuZmxpcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgZ3JvdXBcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKGlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGUgb25lIGVsZW1lbnQgdmFsdWUgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFRoZSBmaWVsZCB3aXJlIHR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIGZpZWxkIG51bWJlclxyXG4gICAgICAgICAqIEByZXR1cm4geyp9IERlY29kZWQgdmFsdWVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCB3aXJlVHlwZSwgaWQpIHtcclxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlICE9IHRoaXMudHlwZS53aXJlVHlwZSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB3aXJlIHR5cGUgZm9yIGVsZW1lbnRcIik7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSA+Pj4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzJaaWdaYWcoKSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgMzJiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQzMigpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRJbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKS50b1Vuc2lnbmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgc2lnbmVkIHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0WmlnWmFnKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgNjRiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIDY0Yml0IHNpZ25lZFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlICh2YXJpbnQpXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIEJ1aWxkZXIuTWVzc2FnZSNzZXQgd2lsbCBhbHJlYWR5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEZsb2F0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVlN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgbnVtYmVyIG9mIGJ5dGVzIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIituQnl0ZXMrXCIgcmVxdWlyZWQgYnV0IGdvdCBvbmx5IFwiK2J1ZmZlci5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuY2xvbmUoKTsgLy8gT2Zmc2V0IGFscmVhZHkgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubGltaXQgPSB2YWx1ZS5vZmZzZXQrbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCBuQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCAtMSwgaWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgZGVjb2RlIHR5cGVcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIHRoZSBjYW5vbmljYWwgZWxlbWVudCB0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTGVnYWwgb25seSB3aGVuIGlzTWFwS2V5IGlzIHRydWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS52YWx1ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFwS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInZhbHVlRnJvbVN0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShwYXJzZUludChzdHIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTG9uZy1iYXNlZCBmaWVsZHMgc3VwcG9ydCBjb252ZXJzaW9ucyBmcm9tIHN0cmluZyBhbHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5VmFsdWUoc3RyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT09IFwidHJ1ZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShzdHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoc3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgdmFsdWUgZnJvbSB0aGUgY2Fub25pY2FsIGVsZW1lbnQgdHlwZSB0byBhIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHNob3VsZCBiZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZUZyb21TdHJpbmcodmFsdWVUb1N0cmluZyh2YWwpKWAgcmV0dXJuc1xyXG4gICAgICAgICAqIGEgdmFsdWUgZXF1aXZhbGVudCB0byBgdmVyaWZ5VmFsdWUodmFsKWAgZm9yIGV2ZXJ5IGxlZ2FsIHZhbHVlIG9mIGB2YWxgXHJcbiAgICAgICAgICogYWNjb3JkaW5nIHRvIHRoaXMgZWxlbWVudCB0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBtYXkgYmUgdXNlZCB3aGVuIHRoZSBlbGVtZW50IG11c3QgYmUgc3RvcmVkIG9yIHVzZWQgYXMgYSBzdHJpbmcsXHJcbiAgICAgICAgICogZS5nLiwgYXMgYSBtYXAga2V5IG9uIGFuIE9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIExlZ2FsIG9ubHkgd2hlbiBpc01hcEtleSBpcyB0cnVlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyBmb3JtIG9mIHRoZSB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYXBLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidmFsdWVUb1N0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoXCJiaW5hcnlcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FbGVtZW50ID0gRWxlbWVudDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcGFyZW50IFBhcmVudCBtZXNzYWdlIG9yIG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE1lc3NhZ2Ugb3B0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzR3JvdXAgYHRydWVgIGlmIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXBcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIG9mIHRoaXMgZGVmaW5pdGlvbiAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1lc3NhZ2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIGlzR3JvdXAsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTWVzc2FnZVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dGVuc2lvbnMgcmFuZ2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUnVudGltZSBtZXNzYWdlIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzpQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UpfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXp6ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXAgb3Igbm90LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pc0dyb3VwID0gISFpc0dyb3VwO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjYWNoZWQgY29sbGVjdGlvbnMgYXJlIHVzZWQgdG8gZWZmaWNpZW50bHkgaXRlcmF0ZSBvdmVyIG9yIGxvb2sgdXAgZmllbGRzIHdoZW4gZGVjb2RpbmcuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FjaGVkIGZpZWxkcy5cclxuICAgICAgICAgICAgICogQHR5cGUgez9BcnJheS48IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhY2hlZCBmaWVsZHMgYnkgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0LjxudW1iZXIsIVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0LjxzdHJpbmcsIVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeU5hbWUgPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1lc3NhZ2VQcm90b3R5cGUgPSBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gTWVzc2FnZSBjbGFzc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6ejtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcnVudGltZSBNZXNzYWdlIGNsYXNzIGluIGl0cyBvd24gc2NvcGVcclxuICAgICAgICAgICAgdmFyIGNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvbmVvZnMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQGNsYXNzIEJhcmVib25lIG9mIGFsbCBydW50aW1lIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj58c3RyaW5nfSB2YWx1ZXMgUHJlc2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IHZhcl9hcmdzXHJcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFyX2FyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHZpcnR1YWwgb25lb2YgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1vbmVvZnMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvbmVvZnNbaV0ubmFtZV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBmaWVsZHMgYW5kIHNldCBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wLCBrPWZpZWxkcy5sZW5ndGg7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5yZXBlYXRlZCA/IFtdIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZC5tYXAgPyBuZXcgUHJvdG9CdWYuTWFwKGZpZWxkKSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZpZWxkLnJlcXVpcmVkIHx8IFQuc3ludGF4ID09PSAncHJvdG8zJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYSB2YWx1ZXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHZhbHVlcyAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IF9hbm90aGVyXyBNZXNzYWdlICovICh0eXBlb2YgdmFsdWVzLmVuY29kZSAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZXMgaW5zdGFuY2VvZiBNZXNzYWdlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgcmVwZWF0ZWQgZmllbGQgKi8gIUFycmF5LmlzQXJyYXkodmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgTWFwICovICEodmFsdWVzIGluc3RhbmNlb2YgUHJvdG9CdWYuTWFwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgQnl0ZUJ1ZmZlciAqLyAhQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFuIEFycmF5QnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBMb25nICovICEoUHJvdG9CdWYuTG9uZyAmJiB2YWx1ZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5Mb25nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYXJndW1lbnRzLCBpbiBkZWNsYXJhdGlvbiBvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTAsIGs9YXJndW1lbnRzLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUgPSBhcmd1bWVudHNbaV0pICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkc1tpXS5uYW1lLCB2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlUHJvdG90eXBlID0gTWVzc2FnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBhZGRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpOyAvLyBNYXkgdGhyb3cgaWYgaXQncyBhbiBlbnVtIG9yIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5yZXBlYXRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIHJlcGVhdGVkIGZpZWxkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YWx1ZSB0byBhIHJlcGVhdGVkIGZpZWxkLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2FkZH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGFkZFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS4kYWRkID0gTWVzc2FnZVByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgZmllbGQncyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8IU9iamVjdC48c3RyaW5nLCo+fSBrZXlPck9iaiBTdHJpbmcga2V5IG9yIHBsYWluIG9iamVjdCBob2xkaW5nIG11bHRpcGxlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoKnxib29sZWFuKT19IHZhbHVlIFZhbHVlIHRvIHNldCBpZiBrZXkgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBvbWl0dGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgZm9yIGFuIGFjdHVhbCBmaWVsZCAvIHByb3BlciB2YWx1ZSB0eXBlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5T3JPYmosIHZhbHVlLCBub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlPck9iaiAmJiB0eXBlb2Yga2V5T3JPYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQXNzZXJ0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlrZXkgaW4ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5T3JPYmouaGFzT3duUHJvcGVydHkoaWtleSkgJiYgdHlwZW9mICh2YWx1ZSA9IGtleU9yT2JqW2lrZXldKSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGlrZXksIHZhbHVlLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULl9maWVsZHNCeU5hbWVba2V5T3JPYmpdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5T3JPYmorXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXlPck9iaitcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gKHZhbHVlID0gZmllbGQudmVyaWZ5VmFsdWUodmFsdWUpKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5T3JPYmpdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdOyAvLyBWaXJ0dWFsIGZpZWxkIHJlZmVyZW5jZXMgY3VycmVudGx5IHNldCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudEZpZWxkXSA9IG51bGw7IC8vIENsZWFyIGN1cnJlbnRseSBzZXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQub25lb2YubmFtZV0gPSBmaWVsZC5uYW1lOyAvLyBQb2ludCB2aXJ0dWFsIGZpZWxkIGF0IHRoaXMgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvKiB2YWx1ZSA9PT0gbnVsbCAmJiAqL2N1cnJlbnRGaWVsZCA9PT0ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdID0gbnVsbDsgLy8gQ2xlYXIgdmlydHVhbCBmaWVsZCAoY3VycmVudCBmaWVsZCBleHBsaWNpdGx5IGNsZWFyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIGZvciBbQGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJHNldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whT2JqZWN0LjxzdHJpbmcsKj59IGtleU9yT2JqIFN0cmluZyBrZXkgb3IgcGxhaW4gb2JqZWN0IGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geygqfGJvb2xlYW4pPX0gdmFsdWUgVmFsdWUgdG8gc2V0IGlmIGtleSBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLiRzZXQgPSBNZXNzYWdlUHJvdG90eXBlLnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IGZvciBhbiBhY3R1YWwgZmllbGQsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWVcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuJGdldCA9IE1lc3NhZ2VQcm90b3R5cGUuZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHNldHRlcnMgZm9yIGV4dGVuc2lvbiBmaWVsZHMgYXMgdGhlc2UgYXJlIG5hbWVkIGJ5IHRoZWlyIGZxblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChULmJ1aWxkZXIub3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQvZ2V0W1NvbWVWYWx1ZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhfW2EtekEtWl0pL2csIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnXycsJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lID0gTmFtZS5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpICsgTmFtZS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldF9bc29tZV92YWx1ZV0gRklYTUU6IERvIHdlIHJlYWxseSBuZWVkIHRoZXNlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9cIittYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgZmllbGQncyB1bmJvdW5kIHNldHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gbm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCBmaWVsZCdzIHVuYm91bmQgZ2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwic2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJzZXRcIitOYW1lXSA9IHNldHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVC5nZXRDaGlsZChcInNldF9cIituYW1lKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBhbm90aGVyIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgdGhlIHZhbHVlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wic2V0X1wiK25hbWVdID0gc2V0dGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwiZ2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wiZ2V0XCIrTmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFQuZ2V0Q2hpbGQoXCJnZXRfXCIrbmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0X1tzb21lX2ZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJnZXRfXCIrbmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KShmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW4tL2RlY29kaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRlbmNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9WZXJpZnkgV2hldGhlciB0byBub3QgdmVyaWZ5IGZpZWxkIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IUJ5dGVCdWZmZXJ9IEVuY29kZWQgbWVzc2FnZSBhcyBhIEJ5dGVCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vVmVyaWZ5ID0gYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFQuZW5jb2RlKHRoaXMsIGJ1ZmZlci5MRSgpLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOZXcgPyBidWZmZXIuZmxpcCgpIDogYnVmZmVyKS5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgdGhlIHNwZWNpZmllZCBkYXRhIHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gZGF0YSBEYXRhIHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShkYXRhKS5lbmNvZGUoYnVmZmVyLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBULmNhbGN1bGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYyA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBlbmMsIG5vVmVyaWZ5KS5mbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoZW5jLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGFuIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlQUIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0FycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9BcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9BcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEFycmF5QnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBNZXNzYWdlUHJvdG90eXBlLmVuY29kZUFCO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQsIG5vdCBydW5uaW5nIHVuZGVyIG5vZGUuanMgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZVxyXG4gICAgICAgICAgICAgICAgICogIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZU5CID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIG5vZGUgQnVmZmVyLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CfS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0J1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBub2RlIEJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlTkI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0Jhc2U2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CYXNlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgYmFzZTY0IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0Jhc2U2NCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlNjQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgICogIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVIZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9IZXhcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0hleCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlSGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3Qgb3IgZmllbGQgdmFsdWUgdG8gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0IHRvIGNsb25lXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpbmFyeUFzQmFzZTY0IFdoZXRoZXIgdG8gaW5jbHVkZSBiaW5hcnkgZGF0YSBhcyBiYXNlNjQgc3RyaW5ncyBvciBhcyBhIGJ1ZmZlciBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9uZ3NBc1N0cmluZ3MgV2hldGhlciB0byBlbmNvZGUgbG9uZ3MgYXMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UPX0gcmVzb2x2ZWRUeXBlIFRoZSByZXNvbHZlZCBmaWVsZCB0eXBlIGlmIGEgZmllbGRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBDbG9uZWQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xvbmVSYXcob2JqLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIHJlc29sdmVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBlbnVtIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFR5cGUgJiYgcmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFByb3RvQnVmLlJlZmxlY3QuRW51bS5nZXROYW1lKHJlc29sdmVkVHlwZS5vYmplY3QsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzLXRocm91Z2ggc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG51bGwuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBCeXRlQnVmZmVycyB0byByYXcgYnVmZmVyIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeUFzQmFzZTY0ID8gb2JqLnRvQmFzZTY0KCkgOiBvYmoudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IExvbmdzIHRvIHByb3BlciBvYmplY3RzIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZy5pc0xvbmcob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdzQXNTdHJpbmdzID8gb2JqLnRvU3RyaW5nKCkgOiBQcm90b0J1Zi5Mb25nLmZyb21WYWx1ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2tdID0gY2xvbmVSYXcodiwgYmluYXJ5QXNCYXNlNjQsIGxvbmdzQXNTdHJpbmdzLCByZXNvbHZlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbWFwcyB0byBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXQgPSBvYmouZW50cmllcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gaXQubmV4dCgpOyAhZS5kb25lOyBlID0gaXQubmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbb2JqLmtleUVsZW0udmFsdWVUb1N0cmluZyhlLnZhbHVlWzBdKV0gPSBjbG9uZVJhdyhlLnZhbHVlWzFdLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIG9iai52YWx1ZUVsZW0ucmVzb2x2ZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYSBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9iai4kdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICYmIChmaWVsZCA9IHR5cGUuZ2V0Q2hpbGQoaSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gY2xvbmVSYXcob2JqW2ldLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIGZpZWxkLnJlc29sdmVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBjbG9uZVJhdyhvYmpbaV0sIGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlJ3MgcmF3IHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBiaW5hcnlBc0Jhc2U2NCBXaGV0aGVyIHRvIGluY2x1ZGUgYmluYXJ5IGRhdGEgYXMgYmFzZTY0IHN0cmluZ3MgaW5zdGVhZCBvZiBCdWZmZXJzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvbmdzQXNTdHJpbmdzIFdoZXRoZXIgdG8gZW5jb2RlIGxvbmdzIGFzIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUmF3IHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVJhdyh0aGlzLCAhIWJpbmFyeUFzQmFzZTY0LCAhIWxvbmdzQXNTdHJpbmdzLCB0aGlzLiR0eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIGEgbWVzc2FnZSB0byBKU09OLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVKU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVJhdyh0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJpbmFyeS1hcy1iYXNlNjQgKi8gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsb25ncy1hcy1zdHJpbmdzICovIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHRoZSByZW1haW5pZyBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbihidWZmZXIsIGxlbmd0aCwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmMgPSBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSA/IGJ1ZmZlciA6IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIHZhcmludDMyIGxlbmd0aC1kZWxpbWl0ZWQgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jIEVuY29kaW5nIGlmIGJ1ZmZlciBpcyBhIHN0cmluZzogaGV4LCB1dGY4IChub3QgcmVjb21tZW5kZWQpLCBkZWZhdWx0cyB0byBiYXNlNjRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlIG9yIGBudWxsYCBpZiBub3QgZW5vdWdoIGJ5dGVzIGFyZSBhdmFpbGFibGUgeWV0XHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbihidWZmZXIsIGVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSA/IGJ1ZmZlciA6IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZiA9IGJ1ZmZlci5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgPSBvZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gVC5kZWNvZGUoYnVmZmVyLnNsaWNlKGJ1ZmZlci5vZmZzZXQsIGJ1ZmZlci5vZmZzZXQgKyBsZW4pLkxFKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVjb2RlcyB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZTY0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2UuZGVjb2RlKHN0ciwgXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVjb2RlcyB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGVIZXggPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5kZWNvZGUoc3RyLCBcImhleFwiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVKU09OXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlXHJcbiAgICAgICAgICAgICAgICAgKiBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZUpTT04gPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2UoSlNPTi5wYXJzZShzdHIpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXRpbGl0eVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIE1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9TdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCIuRnVsbHkuUXVhbGlmaWVkLk1lc3NhZ2VOYW1lXCJcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBULnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2Ugb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS4kb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnNTOyAvLyBjYyBuZWVkcyB0aGlzXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNZXNzYWdlIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICRvcHRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLiR0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlUztcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciAkdHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlLCAnJG9wdGlvbnMnLCB7IFwidmFsdWVcIjogVC5idWlsZE9wdCgpIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlUHJvdG90eXBlLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBNZXNzYWdlW1wiJG9wdGlvbnNcIl0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UsIFwiJHR5cGVcIiwgeyBcInZhbHVlXCI6IFQgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VQcm90b3R5cGUsIFwiJHR5cGVcIiwgeyBcInZhbHVlXCI6IFQgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2U7XHJcblxyXG4gICAgICAgICAgICB9KShQcm90b0J1ZiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdGF0aWMgZW51bXMgYW5kIHByb3RvdHlwZWQgc3ViLW1lc3NhZ2VzIC8gY2FjaGVkIGNvbGxlY3Rpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5TmFtZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9dGhpcy5jaGlsZHJlbi5sZW5ndGgsIGNoaWxkOyBpPGs7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRW51bSB8fCBjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UgfHwgY2hpbGQgaW5zdGFuY2VvZiBTZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXp6Lmhhc093blByb3BlcnR5KGNoaWxkLm5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcmVmbGVjdCBjaGlsZCBvZiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitjaGlsZC50b1N0cmluZyh0cnVlKStcIiBjYW5ub3Qgb3ZlcnJpZGUgc3RhdGljIHByb3BlcnR5ICdcIitjaGlsZC5uYW1lK1wiJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGF6eltjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZClcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5idWlsZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkcy5wdXNoKGNoaWxkKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkW2NoaWxkLmlkXSA9IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5TmFtZVtjaGlsZC5uYW1lXSA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UuT25lT2YpICYmICEoY2hpbGQgaW5zdGFuY2VvZiBFeHRlbnNpb24pKSAvLyBOb3QgYnVpbHRcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcmVmbGVjdCBjaGlsZCBvZiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLmNoaWxkcmVuW2ldLnRvU3RyaW5nKHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhenogPSBjbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIGEgcnVudGltZSBtZXNzYWdlJ3MgY29udGVudHMgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZSB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIHdyaXRlIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9WZXJpZnkgV2hldGhlciB0byBub3QgdmVyaWZ5IGZpZWxkIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAqIEByZXR1cm4ge0J5dGVCdWZmZXJ9IFRoZSBCeXRlQnVmZmVyIGZvciBjaGFpbmluZ1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3Npbmcgb3IgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgZm9yIGFub3RoZXIgcmVhc29uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24obWVzc2FnZSwgYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRNaXNzaW5nID0gbnVsbCxcclxuICAgICAgICAgICAgICAgIGZpZWxkO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9dGhpcy5fZmllbGRzLmxlbmd0aCwgdmFsOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9maWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBtZXNzYWdlW2ZpZWxkLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcXVpcmVkICYmIHZhbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZE1pc3NpbmcgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTWlzc2luZyA9IGZpZWxkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZW5jb2RlKG5vVmVyaWZ5ID8gdmFsIDogZmllbGQudmVyaWZ5VmFsdWUodmFsKSwgYnVmZmVyLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmllbGRNaXNzaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXCJNaXNzaW5nIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBmaWVsZCBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrZmllbGRNaXNzaW5nKTtcclxuICAgICAgICAgICAgICAgIGVycltcImVuY29kZWRcIl0gPSBidWZmZXI7IC8vIFN0aWxsIGV4cG9zZSB3aGF0IHdlIGdvdFxyXG4gICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgYSBydW50aW1lIG1lc3NhZ2UncyBieXRlIGxlbmd0aC5cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZyBvciB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY2FsY3VsYXRlZCBmb3IgYW5vdGhlciByZWFzb25cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG49MCwgaT0wLCBrPXRoaXMuX2ZpZWxkcy5sZW5ndGgsIGZpZWxkLCB2YWw7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZCA9IHRoaXMuX2ZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2VbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVxdWlyZWQgJiYgdmFsID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBmaWVsZCBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrZmllbGQpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gZmllbGQuY2FsY3VsYXRlKHZhbCwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2tpcHMgYWxsIGRhdGEgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIGdyb3VwIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkSWQgRXhwZWN0ZWQgR1JPVVBFTkQgaWRcclxuICAgICAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSBidWYgQnl0ZUJ1ZmZlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgYSB2YWx1ZSBhcyBiZWVuIHNraXBwZWQsIGBmYWxzZWAgaWYgdGhlIGVuZCBoYXMgYmVlbiByZWFjaGVkXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0IHdhc24ndCBwb3NzaWJsZSB0byBmaW5kIHRoZSBlbmQgb2YgdGhlIGdyb3VwIChidWZmZXIgb3ZlcnJ1biBvciBlbmQgdGFnIG1pc21hdGNoKVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHNraXBUaWxsR3JvdXBFbmQoZXhwZWN0ZWRJZCwgYnVmKSB7XHJcbiAgICAgICAgICAgIHZhciB0YWcgPSBidWYucmVhZFZhcmludDMyKCksIC8vIFRocm93cyBvbiBPT0JcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdGFnICYgMHgwNyxcclxuICAgICAgICAgICAgICAgIGlkID0gdGFnID4+PiAzO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgIGRvIHRhZyA9IGJ1Zi5yZWFkVWludDgoKTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHRhZyAmIDB4ODApID09PSAweDgwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLm9mZnNldCArPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTTpcclxuICAgICAgICAgICAgICAgICAgICB0YWcgPSBidWYucmVhZFZhcmludDMyKCk7IC8vIHJlYWRzIHRoZSB2YXJpbnRcclxuICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IHRhZzsgICAgICAgIC8vIHNraXBzIG4gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSBleHBlY3RlZElkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgR1JPVVBFTkQgYWZ0ZXIgdW5rbm93biBncm91cDogXCIraWQrXCIgKFwiK2V4cGVjdGVkSWQrXCIgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMjpcclxuICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgaW4gdW5rbm93biBncm91cCBcIitleHBlY3RlZElkK1wiOiBcIit3aXJlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGFuIGVuY29kZWQgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGxlbmd0aCBNZXNzYWdlIGxlbmd0aC4gRGVmYXVsdHMgdG8gZGVjb2RlIGFsbCByZW1haW5pbmcgZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGV4cGVjdGVkR3JvdXBFbmRJZCBFeHBlY3RlZCBHUk9VUEVORCBpZCBpZiB0aGlzIGlzIGEgbGVnYWN5IGdyb3VwXHJcbiAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihidWZmZXIsIGxlbmd0aCwgZXhwZWN0ZWRHcm91cEVuZElkKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gbGVuZ3RoIDogLTE7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgKHRoaXMuY2xhenopKCksXHJcbiAgICAgICAgICAgICAgICB0YWcsIHdpcmVUeXBlLCBpZCwgZmllbGQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgc3RhcnQrbGVuZ3RoIHx8IChsZW5ndGggPT09IC0xICYmIGJ1ZmZlci5yZW1haW5pbmcoKSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0YWcgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gZXhwZWN0ZWRHcm91cEVuZElkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZ3JvdXAgZW5kIGluZGljYXRvciBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIraWQrXCIgKFwiKyhleHBlY3RlZEdyb3VwRW5kSWQgPyBleHBlY3RlZEdyb3VwRW5kSWQrXCIgZXhwZWN0ZWRcIiA6IFwibm90IGEgZ3JvdXBcIikrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgPSB0aGlzLl9maWVsZHNCeUlkW2lkXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIm1lc3NhZ2VzIGNyZWF0ZWQgYnkgeW91ciBuZXcgY29kZSBjYW4gYmUgcGFyc2VkIGJ5IHlvdXIgb2xkIGNvZGU6IG9sZCBiaW5hcmllcyBzaW1wbHkgaWdub3JlIHRoZSBuZXcgZmllbGQgd2hlbiBwYXJzaW5nLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1ZmZlcikpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIHVua25vd24gZmllbGQgXCIraWQrXCIgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIiNkZWNvZGU6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIWZpZWxkLm9wdGlvbnNbXCJwYWNrZWRcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0ucHVzaChmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcikpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5dmFsID0gZmllbGQuZGVjb2RlKHdpcmVUeXBlLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXS5zZXQoa2V5dmFsWzBdLCBrZXl2YWxbMV0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSBtc2dbZmllbGQub25lb2YubmFtZV07IC8vIFZpcnR1YWwgZmllbGQgcmVmZXJlbmNlcyBjdXJyZW50bHkgc2V0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2N1cnJlbnRGaWVsZF0gPSBudWxsOyAvLyBDbGVhciBjdXJyZW50bHkgc2V0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5vbmVvZi5uYW1lXSA9IGZpZWxkLm5hbWU7IC8vIFBvaW50IHZpcnR1YWwgZmllbGQgYXQgdGhpcyBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudCBhbmQgc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25hbCBmaWVsZHMgdGhhdCBhcmUgbm90XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9maWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnW2ZpZWxkLm5hbWVdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSBcInByb3RvM1wiKSB7IC8vIFByb3RvMyBzZXRzIGRlZmF1bHQgdmFsdWVzIGJ5IHNwZWNpZmljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiICsgdGhpcy50b1N0cmluZyh0cnVlKSArIFwiOiBcIiArIGZpZWxkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJbXCJkZWNvZGVkXCJdID0gbXNnOyAvLyBTdGlsbCBleHBvc2Ugd2hhdCB3ZSBnb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFByb3RvQnVmLnBvcHVsYXRlRGVmYXVsdHMgJiYgZmllbGQuZGVmYXVsdFZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZSA9IE1lc3NhZ2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBGaWVsZC5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IGtleXR5cGUgS2V5IGRhdGEgdHlwZSwgaWYgYW55LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERhdGEgdHlwZSwgZS5nLiBpbnQzMlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZj19IG9uZW9mIEVuY2xvc2luZyBPbmVPZlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEZpZWxkID0gZnVuY3Rpb24oYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwga2V5dHlwZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMsIG9uZW9mLCBzeW50YXgpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIG1lc3NhZ2UsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2UuRmllbGRcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcXVpcmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVkID0gcnVsZSA9PT0gXCJyZXF1aXJlZFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgcmVwZWF0ZWQgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09PSBcInJlcGVhdGVkXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCBtYXAgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gcnVsZSA9PT0gXCJtYXBcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIGtleSB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWZcclxuICAgICAgICAgICAgICogdHlwZSBpZiByZXNvbHZlZC4gVmFsaWQgb25seSBpZiB0aGlzLm1hcCA9PT0gdHJ1ZSwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn18bnVsbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlUeXBlID0ga2V5dHlwZSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgdHlwZS4gVHlwZSByZWZlcmVuY2Ugc3RyaW5nIGlmIHVucmVzb2x2ZWQsIHByb3RvYnVmIHR5cGUgaWZcclxuICAgICAgICAgICAgICogcmVzb2x2ZWQuIEluIGEgbWFwIGZpZWxkLCB0aGlzIGlzIHRoZSB2YWx1ZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHR5cGUgcmVmZXJlbmNlIGluc2lkZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVHxudWxsfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIG1lc3NhZ2UgZmllbGQgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqIEBkaWN0XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmYXVsdCB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNsb3NpbmcgT25lT2YuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9uZW9mID0gb25lb2YgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCAncHJvdG8yJztcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcmlnaW5hbCBmaWVsZCBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsTmFtZSA9IHRoaXMubmFtZTsgLy8gVXNlZCB0byByZXZlcnQgY2FtZWxjYXNlIHRyYW5zZm9ybWF0aW9uIG9uIG5hbWluZyBjb2xsaXNpb25zXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCBpbXBsZW1lbnRhdGlvbi4gQ3JlYXRlZCBpbiBidWlsZCgpIGFmdGVyIHR5cGVzIGFyZSByZXNvbHZlZC5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLkVsZW1lbnR9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2V5IGVsZW1lbnQgaW1wbGVtZW50YXRpb24sIGZvciBtYXAgZmllbGRzLiBDcmVhdGVkIGluIGJ1aWxkKCkgYWZ0ZXJcclxuICAgICAgICAgICAgICogdHlwZXMgYXJlIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuRWxlbWVudH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkZXIub3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gJiYgISh0aGlzIGluc3RhbmNlb2YgTWVzc2FnZS5FeHRlbnNpb25GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBQcm90b0J1Zi5VdGlsLnRvQ2FtZWxDYXNlKHRoaXMubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRmllbGRQcm90b3R5cGUgPSBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBmaWVsZC5cclxuICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbmV3IEVsZW1lbnQodGhpcy50eXBlLCB0aGlzLnJlc29sdmVkVHlwZSwgZmFsc2UsIHRoaXMuc3ludGF4KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50ID0gbmV3IEVsZW1lbnQodGhpcy5rZXlUeXBlLCB1bmRlZmluZWQsIHRydWUsIHRoaXMuc3ludGF4KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluIHByb3RvMywgZmllbGRzIGRvIG5vdCBoYXZlIGZpZWxkIHByZXNlbmNlLCBhbmQgZXZlcnkgZmllbGQgaXMgc2V0IHRvXHJcbiAgICAgICAgICAgIC8vIGl0cyB0eXBlJ3MgZGVmYXVsdCB2YWx1ZSAoXCJcIiwgMCwgMC4wLCBvciBmYWxzZSkuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCA9PT0gJ3Byb3RvMycgJiYgIXRoaXMucmVwZWF0ZWQgJiYgIXRoaXMubWFwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlKHRoaXMudHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRlZmF1bHQgdmFsdWVzIGFyZSBwcmVzZW50IHdoZW4gZXhwbGljaXRseSBzcGVjaWZpZWRcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9uc1snZGVmYXVsdCddICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh0aGlzLm9wdGlvbnNbJ2RlZmF1bHQnXSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgc2V0IGZvciB0aGlzIGZpZWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBza2lwUmVwZWF0ZWQgV2hldGhlciB0byBza2lwIHRoZSByZXBlYXRlZCB2YWx1ZSBjaGVjayBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZlcmlmaWVkLCBtYXliZSBhZGp1c3RlZCwgdmFsdWVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXQgZm9yIHRoaXMgZmllbGRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUudmVyaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgIHNraXBSZXBlYXRlZCA9IHNraXBSZXBlYXRlZCB8fCBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3NlbGYudG9TdHJpbmcodHJ1ZSkrXCIgb2YgdHlwZSBcIitzZWxmLnR5cGUubmFtZStcIjogXCIrdmFsK1wiIChcIittc2crXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgeyAvLyBOVUxMIHZhbHVlcyBmb3Igb3B0aW9uYWwgZmllbGRzXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlZClcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJyZXF1aXJlZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCA9PT0gJ3Byb3RvMycgJiYgdGhpcy50eXBlICE9PSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicHJvdG8zIGZpZWxkIHdpdGhvdXQgZmllbGQgcHJlc2VuY2UgY2Fubm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQgJiYgIXNraXBSZXBlYXRlZCkgeyAvLyBSZXBlYXRlZCB2YWx1ZXMgYXMgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuZWxlbWVudC52ZXJpZnlWYWx1ZSh2YWx1ZVtpXSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXAgJiYgIXNraXBSZXBlYXRlZCkgeyAvLyBNYXAgdmFsdWVzIGFzIG9iamVjdHNcclxuICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgUHJvdG9CdWYuTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBhbHJlYWR5IGEgTWFwLCBhdHRlbXB0IHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgUHJvdG9CdWYuTWFwIG9yIHJhdyBvYmplY3QgZm9yIG1hcCBmaWVsZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5NYXAodGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWxsIG5vbi1yZXBlYXRlZCBmaWVsZHMgZXhwZWN0IG5vIGFycmF5XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXBlYXRlZCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vIGFycmF5IGV4cGVjdGVkXCIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC52ZXJpZnlWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaWVsZCB3aWxsIGhhdmUgYSBwcmVzZW5jZSBvbiB0aGUgd2lyZSBnaXZlbiBpdHNcclxuICAgICAgICAgKiB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZlcmlmaWVkIGZpZWxkIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGZpZWxkIHdpbGwgYmUgcHJlc2VudCBvbiB0aGUgd2lyZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmhhc1dpcmVQcmVzZW5jZSA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCAhPT0gJ3Byb3RvMycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9PSBudWxsKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25lb2YgJiYgbWVzc2FnZVt0aGlzLm9uZW9mLm5hbWVdID09PSB0aGlzLm5hbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxvdyAhPT0gMCB8fCB2YWx1ZS5oaWdoICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMC4wO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZW1haW5pbmcoKSA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgZmllbGQgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWZXJpZmllZCBmaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZVxyXG4gICAgICAgICAqIEByZXR1cm4ge0J5dGVCdWZmZXJ9IFRoZSBCeXRlQnVmZmVyIGZvciBjaGFpbmluZ1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGVuY29kZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGJ1ZmZlciwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLnR5cGUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFVucmVzb2x2ZWQgdHlwZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjsgLy8gT3B0aW9uYWwgb21pdHRlZFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIk9ubHkgcmVwZWF0ZWQgZmllbGRzIG9mIHByaW1pdGl2ZSBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LCBvciA2NC1iaXQgd2lyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgJ3BhY2tlZCcuXCJcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW1wicGFja2VkXCJdICYmIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUud2lyZVR5cGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJBbGwgb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBmaWVsZCBhcmUgcGFja2VkIGludG8gYSBzaW5nbGUga2V5LXZhbHVlIHBhaXIgd2l0aCB3aXJlIHR5cGUgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobGVuZ3RoLWRlbGltaXRlZCkuIEVhY2ggZWxlbWVudCBpcyBlbmNvZGVkIHRoZSBzYW1lIHdheSBpdCB3b3VsZCBiZSBub3JtYWxseSwgZXhjZXB0IHdpdGhvdXQgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWcgcHJlY2VkaW5nIGl0LlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuZW5zdXJlQ2FwYWNpdHkoYnVmZmVyLm9mZnNldCArPSAxKTsgLy8gV2UgZG8gbm90IGtub3cgdGhlIGxlbmd0aCB5ZXQsIHNvIGxldCdzIGFzc3VtZSBhIHZhcmludCBvZiBsZW5ndGggMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBidWZmZXIub2Zmc2V0OyAvLyBSZW1lbWJlciB3aGVyZSB0aGUgY29udGVudHMgYmVnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWVbaV0sIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIub2Zmc2V0LXN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaW50TGVuID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihsZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaW50TGVuID4gMSkgeyAvLyBXZSBuZWVkIHRvIG1vdmUgdGhlIGNvbnRlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBidWZmZXIuc2xpY2Uoc3RhcnQsIGJ1ZmZlci5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gdmFyaW50TGVuLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihsZW4sIHN0YXJ0LXZhcmludExlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB5b3VyIG1lc3NhZ2UgZGVmaW5pdGlvbiBoYXMgcmVwZWF0ZWQgZWxlbWVudHMgKHdpdGhvdXQgdGhlIFtwYWNrZWQ9dHJ1ZV0gb3B0aW9uKSwgdGhlIGVuY29kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBoYXMgemVybyBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aXRoIHRoZSBzYW1lIHRhZyBudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSh0aGlzLmlkLCB2YWx1ZVtpXSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgb3V0IGVhY2ggbWFwIGVudHJ5IGFzIGEgc3VibWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwga2V5LCBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgc3VibWVzc2FnZSAoa2V5LCB2YWwpIHBhaXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoMSA8PCAzKSB8IHRoaXMua2V5VHlwZS53aXJlVHlwZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCgxLCBrZXkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgoMiwgdmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Ym1lc3NhZ2Ugd2l0aCB3aXJlIHR5cGUgb2YgbGVuZ3RoLWRlbGltaXRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSBvdXQgdGhlIGtleSBhbmQgdmFsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigoMSA8PCAzKSB8IHRoaXMua2V5VHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2V5RWxlbWVudC5lbmNvZGVWYWx1ZSgxLCBrZXksIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCgyIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmVuY29kZVZhbHVlKDIsIHZhbCwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzV2lyZVByZXNlbmNlKHZhbHVlLCBtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSh0aGlzLmlkLCB2YWx1ZSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKFwiK2UrXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgZmllbGQncyB2YWx1ZSBvbiB0aGUgbmV0d29yayBsZXZlbC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLnR5cGUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFVucmVzb2x2ZWQgdHlwZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIE9wdGlvbmFsIG9taXR0ZWRcclxuICAgICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbmk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pICs9IHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgodGhpcy5pZCwgdmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IG5pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCh0aGlzLmlkLCB2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggbWFwIGVudHJ5IGJlY29tZXMgYSBzdWJtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24odmFsLCBrZXksIG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdWJtZXNzYWdlIChrZXksIHZhbCkgcGFpci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCgxIDw8IDMpIHwgdGhpcy5rZXlUeXBlLndpcmVUeXBlKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDEsIGtleSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoMiA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCgyLCB2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1dpcmVQcmVzZW5jZSh2YWx1ZSwgbWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKHRoaXMuaWQsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKFwiK2UrXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZSB0aGUgZmllbGQgdmFsdWUgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgTGVhZGluZyB3aXJlIHR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFJlcGVhdGVkIFdoZXRoZXIgdG8gc2tpcCB0aGUgcmVwZWF0ZWQgY2hlY2sgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgKiBAcmV0dXJuIHsqfSBEZWNvZGVkIHZhbHVlOiBhcnJheSBmb3IgcGFja2VkIHJlcGVhdGVkIGZpZWxkcywgW2tleSwgdmFsdWVdIGZvclxyXG4gICAgICAgICAqICAgICAgICAgICAgIG1hcCBmaWVsZHMsIG9yIGFuIGluZGl2aWR1YWwgdmFsdWUgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24od2lyZVR5cGUsIGJ1ZmZlciwgc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgbkJ5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gV2UgZXhwZWN0IHdpcmVUeXBlIHRvIG1hdGNoIHRoZSB1bmRlcmx5aW5nIHR5cGUncyB3aXJlVHlwZSB1bmxlc3Mgd2Ugc2VlXHJcbiAgICAgICAgICAgIC8vIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLCBvciB1bmxlc3MgdGhpcyBpcyBhIG1hcCBmaWVsZC5cclxuICAgICAgICAgICAgdmFyIHdpcmVUeXBlT0sgPVxyXG4gICAgICAgICAgICAgICAgKCF0aGlzLm1hcCAmJiB3aXJlVHlwZSA9PSB0aGlzLnR5cGUud2lyZVR5cGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIXNraXBSZXBlYXRlZCAmJiB0aGlzLnJlcGVhdGVkICYmIHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJlxyXG4gICAgICAgICAgICAgICAgIHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKSB8fFxyXG4gICAgICAgICAgICAgICAgKHRoaXMubWFwICYmIHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgaWYgKCF3aXJlVHlwZU9LKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBmb3IgZmllbGQgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrd2lyZVR5cGUrXCIgKFwiK3RoaXMudHlwZS53aXJlVHlwZStcIiBleHBlY3RlZClcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgcGFja2VkIHJlcGVhdGVkIGZpZWxkcy5cclxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNICYmIHRoaXMucmVwZWF0ZWQgJiYgdGhpcy5vcHRpb25zW1wicGFja2VkXCJdICYmIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUud2lyZVR5cGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5vZmZzZXQgKyBuQnl0ZXM7IC8vIExpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmRlY29kZSh0aGlzLnR5cGUud2lyZVR5cGUsIGJ1ZmZlciwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHZhbHVlIG90aGVyd2lzZS4uLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbWFwcy5cclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIG9uZSAoa2V5LCB2YWx1ZSkgc3VibWVzc2FnZSwgYW5kIHJldHVybiBba2V5LCB2YWx1ZV1cclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlKHRoaXMua2V5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEVsZW1lbnQuZGVmYXVsdEZpZWxkVmFsdWUodGhpcy50eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBuQnl0ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG51bWJlciBvZiBieXRlcyBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrbkJ5dGVzK1wiIHJlcXVpcmVkIGJ1dCBnb3Qgb25seSBcIitidWZmZXIucmVtYWluaW5nKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBhIHN1Yi1idWZmZXIgb2YgdGhpcyBrZXkvdmFsdWUgc3VibWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdmFyIG1zZ2J1ZiA9IGJ1ZmZlci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgbXNnYnVmLmxpbWl0ID0gbXNnYnVmLm9mZnNldCArIG5CeXRlcztcclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbkJ5dGVzO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChtc2didWYucmVtYWluaW5nKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG1zZ2J1Zi5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdGFnID4+PiAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmtleUVsZW1lbnQuZGVjb2RlKG1zZ2J1Ziwgd2lyZVR5cGUsIGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbGVtZW50LmRlY29kZShtc2didWYsIHdpcmVUeXBlLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIHRhZyBpbiBtYXAgZmllbGQga2V5L3ZhbHVlIHN1Ym1lc3NhZ2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzaW5ndWxhciBhbmQgbm9uLXBhY2tlZCByZXBlYXRlZCBmaWVsZCB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZGVjb2RlKGJ1ZmZlciwgd2lyZVR5cGUsIHRoaXMuaWQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlLkZpZWxkID0gRmllbGQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBFeHRlbnNpb25GaWVsZC5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGRcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBEYXRhIHR5cGUsIGUuZy4gaW50MzJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBmaWVsZCBpZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEV4dGVuc2lvbkZpZWxkID0gZnVuY3Rpb24oYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgRmllbGQuY2FsbCh0aGlzLCBidWlsZGVyLCBtZXNzYWdlLCBydWxlLCAvKiBrZXl0eXBlID0gKi8gbnVsbCwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dGVuc2lvbiByZWZlcmVuY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb259XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZHMgRmllbGRcclxuICAgICAgICBFeHRlbnNpb25GaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpZWxkLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkID0gRXh0ZW5zaW9uRmllbGQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBPbmVPZi5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuT25lT2ZcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT25lT2YgbmFtZVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBPbmVPZiA9IGZ1bmN0aW9uKGJ1aWxkZXIsIG1lc3NhZ2UsIG5hbWUpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIG1lc3NhZ2UsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuY2xvc2VkIGZpZWxkcy5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRzID0gW107XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0Lk1lc3NhZ2UuT25lT2YgPSBPbmVPZjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRW51bVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgUmVmbGVjdCBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFbnVtIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBFbnVtIG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIChlLmcuLCBwcm90bzMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRW51bSA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHBhcmVudCwgbmFtZSwgb3B0aW9ucywgc3ludGF4KSB7XHJcbiAgICAgICAgICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIGJ1aWxkZXIsIHBhcmVudCwgbmFtZSwgb3B0aW9ucywgc3ludGF4KTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJFbnVtXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUnVudGltZSBlbnVtIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj58bnVsbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHN0cmluZyBuYW1lIG9mIGFuIGVudW0gdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5FbnVtfSBlbm0gUnVudGltZSBlbnVtXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEVudW0gdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7P3N0cmluZ30gTmFtZSBvciBgbnVsbGAgaWYgbm90IHByZXNlbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW51bS5nZXROYW1lID0gZnVuY3Rpb24oZW5tLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVubSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwga2V5OyBpPGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBpZiAoZW5tW2tleSA9IGtleXNbaV1dID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFbnVtUHJvdG90eXBlID0gRW51bS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZHMgdGhpcyBlbnVtIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW51bVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqZWN0ICYmICFyZWJ1aWxkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgZW5tID0gbmV3IFByb3RvQnVmLkJ1aWxkZXIuRW51bSgpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5nZXRDaGlsZHJlbihFbnVtLlZhbHVlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXZhbHVlcy5sZW5ndGg7IGk8azsgKytpKVxyXG4gICAgICAgICAgICAgICAgZW5tW3ZhbHVlc1tpXVsnbmFtZSddXSA9IHZhbHVlc1tpXVsnaWQnXTtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbm0sICckb3B0aW9ucycsIHtcclxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHRoaXMuYnVpbGRPcHQoKSxcclxuICAgICAgICAgICAgICAgICAgICBcImVudW1lcmFibGVcIjogZmFsc2VcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QgPSBlbm07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LkVudW0gPSBFbnVtO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEVudW0gVmFsdWUuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuRW51bX0gZW5tIEVudW0gcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVmFsdWUgPSBmdW5jdGlvbihidWlsZGVyLCBlbm0sIG5hbWUsIGlkKSB7XHJcbiAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBidWlsZGVyLCBlbm0sIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIkVudW0uVmFsdWVcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVbmlxdWUgZW51bSB2YWx1ZSBpZC5cclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgIFZhbHVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuRW51bS5WYWx1ZSA9IFZhbHVlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBleHRlbnNpb24gKGZpZWxkKS5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkV4dGVuc2lvblxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT2JqZWN0IG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGR9IGZpZWxkIEV4dGVuc2lvbiBmaWVsZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFeHRlbnNpb24gPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIGZpZWxkKSB7XHJcbiAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dGVuZGVkIG1lc3NhZ2UgZmllbGQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gRXh0ZW5kcyBUXHJcbiAgICAgICAgRXh0ZW5zaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb25cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FeHRlbnNpb24gPSBFeHRlbnNpb247XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VydmljZS5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IHJvb3QgUm9vdFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTZXJ2aWNlID0gZnVuY3Rpb24oYnVpbGRlciwgcm9vdCwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCByb290LCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbHQgcnVudGltZSBzZXJ2aWNlIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzpQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UpfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGF6eiA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU2VydmljZVByb3RvdHlwZSA9IFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBzZXJ2aWNlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LCB3aGljaCBpcyBhIGZ1bGx5IGZ1bmN0aW9uYWwgY2xhc3MuXHJcbiAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2VcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWJ1aWxkIFdoZXRoZXIgdG8gcmVidWlsZCBvciBub3RcclxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gU2VydmljZSBjbGFzc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2VydmljZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6ejtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcnVudGltZSBTZXJ2aWNlIGNsYXNzIGluIGl0cyBvd24gc2NvcGVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhenogPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcnVudGltZSBTZXJ2aWNlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLCBmdW5jdGlvbihFcnJvciwgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlPSkpPX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb24gcmVjZWl2aW5nIHRoZSBtZXRob2QgbmFtZSBhbmQgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAqIEBjbGFzcyBCYXJlYm9uZSBvZiBhbGwgcnVudGltZSBzZXJ2aWNlcy5cclxuICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzZXJ2aWNlIGNhbm5vdCBiZSBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBTZXJ2aWNlID0gZnVuY3Rpb24ocnBjSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2aWNlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSNycGNJbXBsXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUgeyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX1cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbCB8fCBmdW5jdGlvbihuYW1lLCBtc2csIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hhdCBhIHVzZXIgaGFzIHRvIGltcGxlbWVudDogQSBmdW5jdGlvbiByZWNlaXZpbmcgdGhlIG1ldGhvZCBuYW1lLCB0aGUgYWN0dWFsIG1lc3NhZ2UgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCAodHlwZSBjaGVja2VkKSBhbmQgdGhlIGNhbGxiYWNrIHRoYXQncyBlaXRoZXIgcHJvdmlkZWQgd2l0aCB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IG9yIG51bGwgYW5kIHRoZSBhY3R1YWwgcmVzcG9uc2UgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjay5iaW5kKHRoaXMsIEVycm9yKFwiTm90IGltcGxlbWVudGVkLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL1Byb3RvQnVmLmpzL3dpa2kvU2VydmljZXNcIikpLCAwKTsgLy8gTXVzdCBiZSBhc3luYyFcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIFNlcnZpY2VQcm90b3R5cGUgPSBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBc3luY2hyb25vdXNseSBwZXJmb3JtcyBhbiBSUEMgY2FsbCB1c2luZyB0aGUgZ2l2ZW4gUlBDIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLltNZXRob2RdXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKHN0cmluZywgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLCBmdW5jdGlvbihFcnJvciwgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlPSkpfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHJlcSBSZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfEJ5dGVCdWZmZXJ8QnVmZmVyfHN0cmluZyk9KX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nXHJcbiAgICAgICAgICAgICAgICAgKiAgdGhlIGVycm9yIGlmIGFueSBhbmQgdGhlIHJlc3BvbnNlIGVpdGhlciBhcyBhIHByZS1wYXJzZWQgbWVzc2FnZSBvciBhcyBpdHMgcmF3IGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGluc3RhbmNlJ3MgUlBDIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlI1tNZXRob2RdXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSByZXEgUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxCeXRlQnVmZmVyfEJ1ZmZlcnxzdHJpbmcpPSl9IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZ1xyXG4gICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xyXG4gICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcnBjID0gVC5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxycGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2aWNlI01ldGhvZChtZXNzYWdlLCBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2VydmljZVByb3RvdHlwZVttZXRob2QubmFtZV0gPSBmdW5jdGlvbihyZXEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGdpdmVuIGFzIGEgYnVmZmVyLCBkZWNvZGUgdGhlIHJlcXVlc3QuIFdpbGwgdGhyb3cgYSBUeXBlRXJyb3IgaWYgbm90IGEgdmFsaWQgYnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6ei5kZWNvZGUoQnl0ZUJ1ZmZlci53cmFwKHJlcSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxID09PSBudWxsIHx8IHR5cGVvZiByZXEgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgYXJndW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlcSBpbnN0YW5jZW9mIG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlLmNsYXp6KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gbmV3IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlLmNsYXp6KHJlcSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG1ldGhvZC5mcW4oKSwgcmVxLCBmdW5jdGlvbihlcnIsIHJlcykgeyAvLyBBc3N1bWVzIHRoYXQgdGhpcyBpcyBwcm9wZXJseSBhc3luY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvYWxlc2NlIHRvIGVtcHR5IHN0cmluZyB3aGVuIHNlcnZpY2UgcmVzcG9uc2UgaGFzIGVtcHR5IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IHJlcyA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZS5jbGF6ei5kZWNvZGUocmVzKTsgfSBjYXRjaCAobm90QUJ1ZmZlcikge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY2xhenopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIklsbGVnYWwgcmVzcG9uc2UgdHlwZSByZWNlaXZlZCBpbiBzZXJ2aWNlIG1ldGhvZCBcIisgVC5uYW1lK1wiI1wiK21ldGhvZC5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBlcnIpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcnZpY2UuTWV0aG9kKHJwY0ltcGwsIG1lc3NhZ2UsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlW21ldGhvZC5uYW1lXSA9IGZ1bmN0aW9uKHJwY0ltcGwsIHJlcSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZXJ2aWNlKHJwY0ltcGwpW21ldGhvZC5uYW1lXShyZXEsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVttZXRob2QubmFtZV0sIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IG1ldGhvZC5idWlsZE9wdCgpIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VQcm90b3R5cGVbbWV0aG9kLm5hbWVdLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBTZXJ2aWNlW21ldGhvZC5uYW1lXVtcIiRvcHRpb25zXCJdIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKHJwY1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllc1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2VydmljZSBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLiRvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciAkb3B0aW9uc1M7IC8vIGNjIG5lZWRzIHRoaXNcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNlcnZpY2Ugb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSMkb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZsZWN0aW9uIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuJHR5cGVcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJHR5cGVTO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlIyR0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFQuYnVpbGRPcHQoKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVByb3RvdHlwZSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVtcIiRvcHRpb25zXCJdIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLCBcIiR0eXBlXCIsIHsgXCJ2YWx1ZVwiOiBUIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlUHJvdG90eXBlLCBcIiR0eXBlXCIsIHsgXCJ2YWx1ZVwiOiBUIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBTZXJ2aWNlO1xyXG5cclxuICAgICAgICAgICAgfSkoUHJvdG9CdWYsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2VcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5TZXJ2aWNlID0gU2VydmljZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzdHJhY3Qgc2VydmljZSBtZXRob2QuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9IHN2YyBTZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1ldGhvZCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHN2YywgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgc3ZjLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlLk1ldGhvZFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgKj59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1ldGhvZFByb3RvdHlwZSA9IE1ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBtZXRob2QncyAnJG9wdGlvbnMnIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBuYW1lIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QjYnVpbGRPcHRcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXRob2RQcm90b3R5cGUuYnVpbGRPcHQgPSBOYW1lc3BhY2VQcm90b3R5cGUuYnVpbGRPcHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuU2VydmljZS5NZXRob2QgPSBNZXRob2Q7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJQQyBzZXJ2aWNlIG1ldGhvZC5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX0gc3ZjIFNlcnZpY2VcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWVzdF9zdHJlYW0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3BvbnNlX3N0cmVhbSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSUENNZXRob2QgPSBmdW5jdGlvbihidWlsZGVyLCBzdmMsIG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCByZXF1ZXN0X3N0cmVhbSwgcmVzcG9uc2Vfc3RyZWFtLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIE1ldGhvZC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHN2YywgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZS5SUENNZXRob2RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXF1ZXN0IG1lc3NhZ2UgbmFtZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TmFtZSA9IHJlcXVlc3Q7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzcG9uc2UgbWVzc2FnZSBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlTmFtZSA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTdHJlYW0gPSByZXF1ZXN0X3N0cmVhbTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZV9zdHJlYW07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgcmVxdWVzdCBtZXNzYWdlIHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgcmVzcG9uc2UgbWVzc2FnZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIE1ldGhvZFxyXG4gICAgICAgIFJQQ01ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1ldGhvZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kID0gUlBDTWV0aG9kO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVmbGVjdDtcclxuXHJcbiAgICB9KShQcm90b0J1Zik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5CdWlsZGVyID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBMYW5nLCBSZWZsZWN0KSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnVpbGRlci5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5CdWlsZGVyXHJcbiAgICAgICAgICogQGNsYXNzIFByb3ZpZGVzIHRoZSBmdW5jdGlvbmFsaXR5IHRvIGJ1aWxkIHByb3RvY29sIG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQnVpbGRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5ucyA9IG5ldyBSZWZsZWN0Lk5hbWVzcGFjZSh0aGlzLCBudWxsLCBcIlwiKTsgLy8gR2xvYmFsIG5hbWVzcGFjZVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hbWVzcGFjZSBwb2ludGVyLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMubnM7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBidWlsZGluZyByZXN1bHQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8T2JqZWN0PnxudWxsfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWxlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEltcG9ydCByb290IG92ZXJyaWRlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQnVpbGRlclByb3RvdHlwZSA9IEJ1aWxkZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAvLyAtLS0tLSBEZWZpbml0aW9uIHRlc3RzIC0tLS0tXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYSBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuaXNNZXNzYWdlID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIHJlcXVpcmUgYSBzdHJpbmcgbmFtZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBkbyBub3QgY29udGFpbiB2YWx1ZXMgKGVudW0pIG9yIHJwYyBtZXRob2RzIChzZXJ2aWNlKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlZltcInJwY1wiXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYSBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuaXNNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgLy8gTWVzc2FnZSBmaWVsZHMgcmVxdWlyZSBhIHN0cmluZyBydWxlLCBuYW1lIGFuZCB0eXBlIGFuZCBhbiBpZFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInJ1bGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1widHlwZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcImlkXCJdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhbiBlbnVtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuaXNFbnVtID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIEVudW1zIHJlcXVpcmUgYSBzdHJpbmcgbmFtZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBFbnVtcyByZXF1aXJlIGF0IGxlYXN0IG9uZSB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUFycmF5LmlzQXJyYXkoZGVmW1widmFsdWVzXCJdKSB8fCBkZWZbXCJ2YWx1ZXNcIl0ubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgc2VydmljZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzU2VydmljZSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBTZXJ2aWNlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWUgYW5kIGFuIHJwYyBvYmplY3RcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wicnBjXCJdICE9PSAnb2JqZWN0JyB8fCAhZGVmW1wicnBjXCJdKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGFuIGV4dGVuZGVkIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzRXh0ZW5kID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgcnF1aXJlIGEgc3RyaW5nIHJlZlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInJlZlwiXSAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIC0tLS0tIEJ1aWxkaW5nIC0tLS0tXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgcG9pbnRlciB0byB0aGUgcm9vdCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLm5zO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIGEgbmFtZXNwYWNlIG9uIHRvcCBvZiB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBwbGFjZXMgdGhlIHBvaW50ZXIgb24gaXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24obmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5UWVBFUkVGLnRlc3QobmFtZXNwYWNlKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBuYW1lc3BhY2U6IFwiK25hbWVzcGFjZSk7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZS5zcGxpdChcIi5cIikuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSB0aGlzLnB0ci5nZXRDaGlsZChwYXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChucyA9PT0gbnVsbCkgLy8gS2VlcCBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG5zID0gbmV3IFJlZmxlY3QuTmFtZXNwYWNlKHRoaXMsIHRoaXMucHRyLCBwYXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IG5zO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgc3BlY2lmaWVkIGRlZmluaXRpb25zIGF0IHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPCFPYmplY3Q+fSBkZWZzIE1lc3NhZ2VzLCBlbnVtcyBvciBzZXJ2aWNlcyB0byBjcmVhdGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBtZXNzYWdlIGRlZmluaXRpb24gaXMgaW52YWxpZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRlZnMpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWZzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWZzKSlcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBbZGVmc107XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgZGVmcyA9IGRlZnMuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSXQncyBxdWl0ZSBoYXJkIHRvIGtlZXAgdHJhY2sgb2Ygc2NvcGVzIGFuZCBtZW1vcnkgaGVyZSwgc28gbGV0J3MgZG8gdGhpcyBpdGVyYXRpdmVseS5cclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW2RlZnNdO1xyXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZGVmcyA9IHN0YWNrLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWZzKSkgLy8gU3RhY2sgYWx3YXlzIGNvbnRhaW5zIGVudGlyZSBuYW1lc3BhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgYSB2YWxpZCBuYW1lc3BhY2U6IFwiK0pTT04uc3RyaW5naWZ5KGRlZnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVmcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGRlZnMuc2hpZnQoKTsgLy8gTmFtZXNwYWNlcyBhbHdheXMgY29udGFpbiBhbiBhcnJheSBvZiBtZXNzYWdlcywgZW51bXMgYW5kIHNlcnZpY2VzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCdWlsZGVyLmlzTWVzc2FnZShkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBuZXcgUmVmbGVjdC5NZXNzYWdlKHRoaXMsIHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdLCBkZWZbXCJpc0dyb3VwXCJdLCBkZWZbXCJzeW50YXhcIl0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIE9uZU9mc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lb2ZzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJvbmVvZnNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZbXCJvbmVvZnNcIl0pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChvbmVvZnNbbmFtZV0gPSBuZXcgUmVmbGVjdC5NZXNzYWdlLk9uZU9mKHRoaXMsIG9iaiwgbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJmaWVsZHNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJmaWVsZHNcIl0uZm9yRWFjaChmdW5jdGlvbihmbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmdldENoaWxkKGZsZFtcImlkXCJdfDApICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBvciBpbnZhbGlkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGRbXCJvcHRpb25zXCJdICYmIHR5cGVvZiBmbGRbXCJvcHRpb25zXCJdICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGZpZWxkIG9wdGlvbnMgaW4gXCIrb2JqLm5hbWUrXCIjXCIrZmxkW1wibmFtZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uZW9mID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsZFtcIm9uZW9mXCJdID09PSAnc3RyaW5nJyAmJiAhKG9uZW9mID0gb25lb2ZzW2ZsZFtcIm9uZW9mXCJdXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBvbmVvZiBpbiBcIitvYmoubmFtZStcIiNcIitmbGRbXCJuYW1lXCJdK1wiOiBcIitmbGRbXCJvbmVvZlwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxkID0gbmV3IFJlZmxlY3QuTWVzc2FnZS5GaWVsZCh0aGlzLCBvYmosIGZsZFtcInJ1bGVcIl0sIGZsZFtcImtleXR5cGVcIl0sIGZsZFtcInR5cGVcIl0sIGZsZFtcIm5hbWVcIl0sIGZsZFtcImlkXCJdLCBmbGRbXCJvcHRpb25zXCJdLCBvbmVvZiwgZGVmW1wic3ludGF4XCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lb2YpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mLmZpZWxkcy5wdXNoKGZsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKGZsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggY2hpbGRyZW4gdG8gc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Yk9iaiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZW51bXNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJlbnVtc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGVubSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKGVubSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcIm1lc3NhZ2VzXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wibWVzc2FnZXNcIl0uZm9yRWFjaChmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJzZXJ2aWNlc1wiXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcInNlcnZpY2VzXCJdLmZvckVhY2goZnVuY3Rpb24oc3ZjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2goc3ZjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGV4dGVuc2lvbiByYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImV4dGVuc2lvbnNcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZXh0ZW5zaW9uc1wiXVswXSA9PT0gJ251bWJlcicpIC8vIHByZSA1LjAuMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zID0gWyBkZWZbXCJleHRlbnNpb25zXCJdIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnMgPSBkZWZbXCJleHRlbnNpb25zXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgb24gdG9wIG9mIGN1cnJlbnQgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJPYmoubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChkZWZzKTsgLy8gUHVzaCB0aGUgY3VycmVudCBsZXZlbCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzID0gc3ViT2JqOyAvLyBDb250aW51ZSBwcm9jZXNzaW5nIHN1YiBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gb2JqOyAvLyBBbmQgbW92ZSB0aGUgcG9pbnRlciB0byB0aGlzIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc0VudW0oZGVmKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IFJlZmxlY3QuRW51bSh0aGlzLCB0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSwgZGVmW1wic3ludGF4XCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1widmFsdWVzXCJdLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuRW51bS5WYWx1ZSh0aGlzLCBvYmosIHZhbFtcIm5hbWVcIl0sIHZhbFtcImlkXCJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNTZXJ2aWNlKGRlZikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LlNlcnZpY2UodGhpcywgdGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZbXCJycGNcIl0pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG10ZCA9IGRlZltcInJwY1wiXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCh0aGlzLCBvYmosIG5hbWUsIG10ZFtcInJlcXVlc3RcIl0sIG10ZFtcInJlc3BvbnNlXCJdLCAhIW10ZFtcInJlcXVlc3Rfc3RyZWFtXCJdLCAhIW10ZFtcInJlc3BvbnNlX3N0cmVhbVwiXSwgbXRkW1wib3B0aW9uc1wiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzRXh0ZW5kKGRlZikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMucHRyLnJlc29sdmUoZGVmW1wicmVmXCJdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wiZmllbGRzXCJdLmZvckVhY2goZnVuY3Rpb24oZmxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5nZXRDaGlsZChmbGRbJ2lkJ118MCkgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGV4dGVuZGVkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpZWxkIGlkIGlzIGFsbG93ZWQgdG8gYmUgZXh0ZW5kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGRbXCJpZFwiXSA+PSByYW5nZVswXSAmJiBmbGRbXCJpZFwiXSA8PSByYW5nZVsxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGV4dGVuZGVkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10rXCIgKG5vdCB3aXRoaW4gdmFsaWQgcmFuZ2VzKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBleHRlbnNpb24gZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmbGRbXCJuYW1lXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2NvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gUHJvdG9CdWYuVXRpbC50b0NhbWVsQ2FzZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgIzE2MTogRXh0ZW5zaW9ucyB1c2UgdGhlaXIgZnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgdGhlaXIgcnVudGltZSBrZXkgYW5kLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gbmV3IFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCh0aGlzLCBvYmosIGZsZFtcInJ1bGVcIl0sIGZsZFtcInR5cGVcIl0sIHRoaXMucHRyLmZxbigpKycuJytuYW1lLCBmbGRbXCJpZFwiXSwgZmxkW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYXJlIGFkZGVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBuYW1lc3BhY2UgYXMgYW4gZXh0ZW5zaW9uIHdoaWNoIGlzIHVzZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZWlyIHR5cGUgbGF0ZXIgb24gKHRoZSBleHRlbnNpb24gYWx3YXlzIGtlZXBzIHRoZSBvcmlnaW5hbCBuYW1lIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBuYW1pbmcgY29sbGlzaW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gbmV3IFJlZmxlY3QuRXh0ZW5zaW9uKHRoaXMsIHRoaXMucHRyLCBmbGRbXCJuYW1lXCJdLCBmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZXh0ZW5zaW9uID0gZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghL1xcLj9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdChkZWZbXCJyZWZcIl0pKSAvLyBTaWxlbnRseSBza2lwIGludGVybmFsIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZXh0ZW5kZWQgbWVzc2FnZSBcIitkZWZbXCJyZWZcIl0rXCIgaXMgbm90IGRlZmluZWRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vdCBhIHZhbGlkIGRlZmluaXRpb246IFwiK0pTT04uc3RyaW5naWZ5KGRlZikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBCcmVhayBnb2VzIGhlcmVcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLnB0ci5wYXJlbnQ7IC8vIE5hbWVzcGFjZSBkb25lLCBjb250aW51ZSBhdCBwYXJlbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7IC8vIFJlcXVpcmUgcmUtcmVzb2x2ZVxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7IC8vIFJlcXVpcmUgcmUtYnVpbGRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGFnYXRlcyBzeW50YXggdG8gYWxsIGNoaWxkcmVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcHJvcGFnYXRlU3ludGF4KHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50WydtZXNzYWdlcyddKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRbJ21lc3NhZ2VzJ10uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW1wic3ludGF4XCJdID0gcGFyZW50W1wic3ludGF4XCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVN5bnRheChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyZW50WydlbnVtcyddKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRbJ2VudW1zJ10uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW1wic3ludGF4XCJdID0gcGFyZW50W1wic3ludGF4XCJdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcG9ydHMgYW5vdGhlciBkZWZpbml0aW9uIGludG8gdGhpcyBidWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gUGFyc2VkIGltcG9ydFxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIEltcG9ydGVkIGZpbGUgbmFtZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBvciBmaWxlIGNhbm5vdCBiZSBpbXBvcnRlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlW1wiaW1wb3J0XCJdID0gZnVuY3Rpb24oanNvbiwgZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGRlbGltID0gJy8nO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHNraXAgZHVwbGljYXRlIGltcG9ydHNcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUoXCJwYXRoXCIpWydyZXNvbHZlJ10oZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbZmlsZW5hbWVdID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gT2JqZWN0IHdpdGggcm9vdCwgZmlsZS5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IGZpbGVuYW1lLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuVXRpbC5JU19OT0RFKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSByZXF1aXJlKFwicGF0aFwiKVsncmVzb2x2ZSddKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuaW5kZXhPZihcIlxcXFxcIikgPj0gMCB8fCBmaWxlbmFtZS5maWxlLmluZGV4T2YoXCJcXFxcXCIpID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSAnXFxcXCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm5hbWUgPSByb290ICsgZGVsaW0gKyBmaWxlbmFtZS5maWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbZm5hbWVdID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzW2ZuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEltcG9ydCBpbXBvcnRzXHJcblxyXG4gICAgICAgICAgICBpZiAoanNvblsnaW1wb3J0cyddICYmIGpzb25bJ2ltcG9ydHMnXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0Um9vdCxcclxuICAgICAgICAgICAgICAgICAgICByZXNldFJvb3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JykgeyAvLyBJZiBhbiBpbXBvcnQgcm9vdCBpcyBzcGVjaWZpZWQsIG92ZXJyaWRlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IGZpbGVuYW1lW1wicm9vdFwiXTsgcmVzZXRSb290ID0gdHJ1ZTsgLy8gLi4uIGFuZCByZXNldCBhZnRlcndhcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IHRoaXMuaW1wb3J0Um9vdDtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lW1wiZmlsZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0Um9vdC5pbmRleE9mKFwiXFxcXFwiKSA+PSAwIHx8IGZpbGVuYW1lLmluZGV4T2YoXCJcXFxcXCIpID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbXBvcnRSb290KSAvLyBJZiBpbXBvcnQgcm9vdCBpcyBvdmVycmlkZGVuLCB1c2UgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IHRoaXMuaW1wb3J0Um9vdDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gT3RoZXJ3aXNlIGNvbXB1dGUgZnJvbSBmaWxlbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIi9cIikgPj0gMCkgeyAvLyBVbml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gZmlsZW5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvKiAvZmlsZS5wcm90byAqLyBpbXBvcnRSb290ID09PSBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBcIi9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKSB7IC8vIFdpbmRvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBmaWxlbmFtZS5yZXBsYWNlKC9cXFxcW15cXFxcXSokLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9ICdcXFxcJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gXCIuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxqc29uWydpbXBvcnRzJ10ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb25bJ2ltcG9ydHMnXVtpXSA9PT0gJ3N0cmluZycpIHsgLy8gSW1wb3J0IGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRSb290KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJjYW5ub3QgZGV0ZXJtaW5lIGltcG9ydCByb290XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0RmlsZW5hbWUgPSBqc29uWydpbXBvcnRzJ11baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRGaWxlbmFtZSA9PT0gXCJnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90b1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIE5vdCBuZWVkZWQgYW5kIHRoZXJlZm9yZSBub3QgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRGaWxlbmFtZSA9IGltcG9ydFJvb3QgKyBkZWxpbSArIGltcG9ydEZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlc1tpbXBvcnRGaWxlbmFtZV0gPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQWxyZWFkeSBpbXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLnByb3RvJC9pLnRlc3QoaW1wb3J0RmlsZW5hbWUpICYmICFQcm90b0J1Zi5Eb3RQcm90bykgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpZ2h0IGJ1aWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRGaWxlbmFtZSA9IGltcG9ydEZpbGVuYW1lLnJlcGxhY2UoL1xcLnByb3RvJC8sIFwiLmpzb25cIik7IC8vIGFsd2F5cyBsb2FkIHRoZSBKU09OIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaChpbXBvcnRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50cyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZmFpbGVkIHRvIGltcG9ydCAnXCIraW1wb3J0RmlsZW5hbWUrXCInIGluICdcIitmaWxlbmFtZStcIic6IGZpbGUgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLmpzb24kL2kudGVzdChpbXBvcnRGaWxlbmFtZSkpIC8vIEFsd2F5cyBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShKU09OLnBhcnNlKGNvbnRlbnRzK1wiXCIpLCBpbXBvcnRGaWxlbmFtZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKFByb3RvQnVmLkRvdFByb3RvLlBhcnNlci5wYXJzZShjb250ZW50cyksIGltcG9ydEZpbGVuYW1lKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIEltcG9ydCBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1xcLihcXHcrKSQvLnRlc3QoZmlsZW5hbWUpKSAvLyBXaXRoIGV4dGVuc2lvbjogQXBwZW5kIF9pbXBvcnROIHRvIHRoZSBuYW1lIHBvcnRpb24gdG8gbWFrZSBpdCB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldLCBmaWxlbmFtZS5yZXBsYWNlKC9eKC4rKVxcLihcXHcrKSQvLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7IHJldHVybiAkMStcIl9pbXBvcnRcIitpK1wiLlwiKyQyOyB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgLy8gV2l0aG91dCBleHRlbnNpb246IEFwcGVuZCBfaW1wb3J0TiB0byBtYWtlIGl0IHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShqc29uWydpbXBvcnRzJ11baV0sIGZpbGVuYW1lK1wiX2ltcG9ydFwiK2kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0Um9vdCkgLy8gUmVzZXQgaW1wb3J0IHJvb3Qgb3ZlcnJpZGUgd2hlbiBhbGwgaW1wb3J0cyBhcmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEltcG9ydCBzdHJ1Y3R1cmVzXHJcblxyXG4gICAgICAgICAgICBpZiAoanNvblsncGFja2FnZSddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZpbmUoanNvblsncGFja2FnZSddKTtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ3N5bnRheCddKVxyXG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlU3ludGF4KGpzb24pO1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMucHRyO1xyXG4gICAgICAgICAgICBpZiAoanNvblsnb3B0aW9ucyddKVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoanNvblsnb3B0aW9ucyddKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2Uub3B0aW9uc1trZXldID0ganNvblsnb3B0aW9ucyddW2tleV07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ21lc3NhZ2VzJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydtZXNzYWdlcyddKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gYmFzZTtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ2VudW1zJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydlbnVtcyddKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gYmFzZTtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ3NlcnZpY2VzJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydzZXJ2aWNlcyddKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gYmFzZTtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ2V4dGVuZHMnXSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGpzb25bJ2V4dGVuZHMnXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc29sdmVzIGFsbCBuYW1lc3BhY2Ugb2JqZWN0cy5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSB0eXBlIGNhbm5vdCBiZSByZXNvbHZlZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbGwgcmVmbGVjdGVkIG9iamVjdHNcclxuICAgICAgICAgICAgdmFyIHJlcztcclxuICAgICAgICAgICAgaWYgKHRoaXMucHRyID09IG51bGwgfHwgdHlwZW9mIHRoaXMucHRyLnR5cGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIERvbmUgKGFscmVhZHkgcmVzb2x2ZWQpXHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkgeyAvLyBSZXNvbHZlIGNoaWxkcmVuXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQpIHsgLy8gUmVzb2x2ZSB0eXBlXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEUudGVzdCh0aGlzLnB0ci50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodGhpcy5wdHIudHlwZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkID8gdGhpcy5wdHIuZXh0ZW5zaW9uLnBhcmVudCA6IHRoaXMucHRyLnBhcmVudCkucmVzb2x2ZSh0aGlzLnB0ci50eXBlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bnJlc29sdmFibGUgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkVHlwZSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUmVmbGVjdC5FbnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ci5zeW50YXggPT09ICdwcm90bzMnICYmIHJlcy5zeW50YXggIT09ICdwcm90bzMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwcm90bzMgbWVzc2FnZSBjYW5ub3QgcmVmZXJlbmNlIHByb3RvMiBlbnVtXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSByZXMuaXNHcm91cCA/IFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl0gOiBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IFByb3RvQnVmLlRZUEVTW3RoaXMucHRyLnR5cGVdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBtYXAgZmllbGQsIGFsc28gcmVzb2x2ZSB0aGUga2V5IHR5cGUuIFRoZSBrZXkgdHlwZSBjYW4gYmUgb25seSBhIG51bWVyaWMsIHN0cmluZywgb3IgYm9vbCB0eXBlXHJcbiAgICAgICAgICAgICAgICAvLyAoaS5lLiwgbm8gZW51bXMgb3IgbWVzc2FnZXMpLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlc29sdmUgYWdhaW5zdCB0aGUgY3VycmVudCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIubWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEUudGVzdCh0aGlzLnB0ci5rZXlUeXBlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGtleSB0eXBlIGZvciBtYXAgZmllbGQgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLmtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmtleVR5cGUgPSBQcm90b0J1Zi5UWVBFU1t0aGlzLnB0ci5rZXlUeXBlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlcXVlc3ROYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVxdWVzdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkUmVxdWVzdFR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wdHIucGFyZW50LnJlc29sdmUodGhpcy5wdHIucmVzcG9uc2VOYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVzcG9uc2VOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHJlcztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBTaG91bGQgbm90IGhhcHBlbiBhcyBub3RoaW5nIGVsc2UgaXMgaW1wbGVtZW50ZWRcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgc2VydmljZSB0eXBlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mKSAmJiAvLyBOb3QgYnVpbHRcclxuICAgICAgICAgICAgICAgICEodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LkV4dGVuc2lvbikgJiYgLy8gTm90IGJ1aWx0XHJcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlKSAvLyBCdWlsdCBpbiBlbnVtXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBvYmplY3QgaW4gbmFtZXNwYWNlOiBcIit0eXBlb2YodGhpcy5wdHIpK1wiOiBcIit0aGlzLnB0cik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgcHJvdG9jb2wuIFRoaXMgd2lsbCBmaXJzdCB0cnkgdG8gcmVzb2x2ZSBhbGwgZGVmaW5pdGlvbnMgYW5kLCBpZiB0aGlzIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsXHJcbiAgICAgICAgICogcmV0dXJuIHRoZSBidWlsdCBwYWNrYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xBcnJheS48c3RyaW5nPik9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXwhT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVBbGwoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsOyAvLyBSZXF1aXJlIHJlLWJ1aWxkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdCA9PT0gbnVsbCkgLy8gKFJlLSlCdWlsZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLm5zLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIGlmICghcGF0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgPyBwYXRoLnNwbGl0KFwiLlwiKSA6IHBhdGgsXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJlc3VsdDsgLy8gQnVpbGQgbmFtZXNwYWNlIHBvaW50ZXIgKG5vIGhhc0NoaWxkIGV0Yy4pXHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxwYXJ0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKHB0cltwYXJ0W2ldXSlcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHJbcGFydFtpXV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHRyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNpbWlsYXIgdG8ge0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIjYnVpbGR9LCBidXQgbG9va3MgdXAgdGhlIGludGVybmFsIHJlZmxlY3Rpb24gZGVzY3JpcHRvci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHBhdGggU3BlY2lmaWVzIHdoYXQgdG8gcmV0dXJuLiBJZiBvbWl0dGVkLCB0aGUgZW50aXJlIG5hbWVzcGFjZSB3aWlsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4Y2x1ZGVOb25OYW1lc3BhY2UgRXhjbHVkZXMgbm9uLW5hbWVzcGFjZSB0eXBlcyBsaWtlIGZpZWxkcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHs/UHJvdG9CdWYuUmVmbGVjdC5UfSBSZWZsZWN0aW9uIGRlc2NyaXB0b3Igb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24ocGF0aCwgZXhjbHVkZU5vbk5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aCA/IHRoaXMubnMucmVzb2x2ZShwYXRoLCBleGNsdWRlTm9uTmFtZXNwYWNlKSA6IHRoaXMubnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIkJ1aWxkZXJcIlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkJ1aWxkZXJcIjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyAtLS0tLSBCYXNlIGNsYXNzZXMgLS0tLS1cclxuICAgICAgICAvLyBFeGlzdCBmb3IgdGhlIHNvbGUgcHVycG9zZSBvZiBiZWluZyBhYmxlIHRvIFwiLi4uIGluc3RhbmNlb2YgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXCIgZXRjLlxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5NZXNzYWdlID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIuRW51bVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuRW51bSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLlNlcnZpY2UgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgICAgICByZXR1cm4gQnVpbGRlcjtcclxuXHJcbiAgICB9KShQcm90b0J1ZiwgUHJvdG9CdWYuTGFuZywgUHJvdG9CdWYuUmVmbGVjdCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuTWFwXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLk1hcCA9IChmdW5jdGlvbihQcm90b0J1ZiwgUmVmbGVjdCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1hcC4gQSBNYXAgaXMgYSBjb250YWluZXIgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCBtYXBcclxuICAgICAgICAgKiBmaWVsZHMgb24gbWVzc2FnZSBvYmplY3RzLiBJdCBjbG9zZWx5IGZvbGxvd3MgdGhlIEVTNiBNYXAgQVBJOyBob3dldmVyLFxyXG4gICAgICAgICAqIGl0IGlzIGRpc3RpbmN0IGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGVwZW5kIG9uIGV4dGVybmFsIHBvbHlmaWxscyBvclxyXG4gICAgICAgICAqIG9uIEVTNiBpdHNlbGYuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5NYXBcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LkZpZWxkfSBmaWVsZCBNYXAgZmllbGRcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gY29udGVudHMgSW5pdGlhbCBjb250ZW50c1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBNYXAgPSBmdW5jdGlvbihmaWVsZCwgY29udGVudHMpIHtcclxuICAgICAgICAgICAgaWYgKCFmaWVsZC5tYXApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImZpZWxkIGlzIG5vdCBhIG1hcFwiKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZmllbGQgY29ycmVzcG9uZGluZyB0byB0aGlzIG1hcC5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5SZWZsZWN0LkZpZWxkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVsZW1lbnQgaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byBrZXkgdHlwZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmtleUVsZW0gPSBuZXcgUmVmbGVjdC5FbGVtZW50KGZpZWxkLmtleVR5cGUsIG51bGwsIHRydWUsIGZpZWxkLnN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCBpbnN0YW5jZSBjb3JyZXNwb25kaW5nIHRvIHZhbHVlIHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FbGVtZW50fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy52YWx1ZUVsZW0gPSBuZXcgUmVmbGVjdC5FbGVtZW50KGZpZWxkLnR5cGUsIGZpZWxkLnJlc29sdmVkVHlwZSwgZmFsc2UsIGZpZWxkLnN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW50ZXJuYWwgbWFwOiBzdG9yZXMgbWFwcGluZyBvZiAoc3RyaW5nIGZvcm0gb2Yga2V5KSAtPiAoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgICAgICogcGFpci5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogV2UgcHJvdmlkZSBtYXAgc2VtYW50aWNzIGZvciBhcmJpdHJhcnkga2V5IHR5cGVzLCBidXQgd2UgYnVpbGQgb24gdG9wXHJcbiAgICAgICAgICAgICAqIG9mIGFuIE9iamVjdCwgd2hpY2ggaGFzIG9ubHkgc3RyaW5nIGtleXMuIEluIG9yZGVyIHRvIGF2b2lkIHRoZSBuZWVkXHJcbiAgICAgICAgICAgICAqIHRvIGNvbnZlcnQgYSBzdHJpbmcga2V5IGJhY2sgdG8gaXRzIG5hdGl2ZSB0eXBlIGluIG1hbnkgc2l0dWF0aW9ucyxcclxuICAgICAgICAgICAgICogd2Ugc3RvcmUgdGhlIG5hdGl2ZSBrZXkgdmFsdWUgYWxvbmdzaWRlIHRoZSB2YWx1ZS4gVGh1cywgd2Ugb25seSBuZWVkXHJcbiAgICAgICAgICAgICAqIGEgb25lLXdheSBtYXBwaW5nIGZyb20gYSBrZXkgdHlwZSB0byBpdHMgc3RyaW5nIGZvcm0gdGhhdCBndWFyYW50ZWVzXHJcbiAgICAgICAgICAgICAqIHVuaXF1ZW5lc3MgYW5kIGVxdWFsaXR5IChpLmUuLCBzdHIoSzEpID09PSBzdHIoSzIpIGlmIGFuZCBvbmx5IGlmIEsxXHJcbiAgICAgICAgICAgICAqID09PSBLMikuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywge2tleTogKiwgdmFsdWU6ICp9Pn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0ge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBtYXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1hcCkubGVuZ3RoOyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRmlsbCBpbml0aWFsIGNvbnRlbnRzIGZyb20gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICBpZiAoY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5RWxlbS52YWx1ZUZyb21TdHJpbmcoa2V5c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWVFbGVtLnZlcmlmeVZhbHVlKGNvbnRlbnRzW2tleXNbaV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcFt0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyhrZXkpXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBrZXksIHZhbHVlOiB2YWwgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIZWxwZXI6IHJldHVybiBhbiBpdGVyYXRvciBvdmVyIGFuIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIgdGhlIGFycmF5XHJcbiAgICAgICAgICogQHJldHVybnMgeyFPYmplY3R9IGFuIGl0ZXJhdG9yXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gYXJyYXlJdGVyYXRvcihhcnIpIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgYXJyLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBhcnJbaWR4KytdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIG1hcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAgPSB7fTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGVzIGEgcGFydGljdWxhciBrZXkgZnJvbSB0aGUgbWFwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIGFueSBlbnRyeSB3aXRoIHRoaXMga2V5IHdhcyBkZWxldGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyh0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KSk7XHJcbiAgICAgICAgICAgIHZhciBoYWRLZXkgPSBrZXlWYWx1ZSBpbiB0aGlzLm1hcDtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWFwW2tleVZhbHVlXTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhZEtleTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgW2tleSwgdmFsdWVdIHBhaXJzIGluIHRoZSBtYXAuXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGl0ZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHN0cktleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeTsgaSA8IHN0cktleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goWyhlbnRyeT10aGlzLm1hcFtzdHJLZXlzW2ldXSkua2V5LCBlbnRyeS52YWx1ZV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlJdGVyYXRvcihlbnRyaWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIga2V5cyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpdGVyYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cktleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2godGhpcy5tYXBbc3RyS2V5c1tpXV0ua2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5SXRlcmF0b3Ioa2V5cyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHZhbHVlcyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBUaGUgaXRlcmF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHN0cktleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyS2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMubWFwW3N0cktleXNbaV1dLnZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5SXRlcmF0b3IodmFsdWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdGVyYXRlcyBvdmVyIGVudHJpZXMgaW4gdGhlIG1hcCwgY2FsbGluZyBhIGZ1bmN0aW9uIG9uIGVhY2guXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiosICosICosICopfSBjYiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggdmFsdWUsIGtleSwgYW5kIG1hcCBhcmd1bWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSB0aGlzQXJnIFRoZSBgdGhpc2AgdmFsdWUgZm9yIHRoZSBjYWxsYmFja1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2IsIHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgdmFyIHN0cktleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeTsgaSA8IHN0cktleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIChlbnRyeT10aGlzLm1hcFtzdHJLZXlzW2ldXSkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyBhIGtleSBpbiB0aGUgbWFwIHRvIHRoZSBnaXZlbiB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLk1hcH0gVGhlIG1hcCBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMua2V5RWxlbS52ZXJpZnlWYWx1ZShrZXkpO1xyXG4gICAgICAgICAgICB2YXIgdmFsVmFsdWUgPSB0aGlzLnZhbHVlRWxlbS52ZXJpZnlWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwW3RoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKGtleVZhbHVlKV0gPVxyXG4gICAgICAgICAgICAgICAgeyBrZXk6IGtleVZhbHVlLCB2YWx1ZTogdmFsVmFsdWUgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBhIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Knx1bmRlZmluZWR9IFRoZSB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYga2V5IG5vdCBwcmVzZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyh0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KSk7XHJcbiAgICAgICAgICAgIGlmICghKGtleVZhbHVlIGluIHRoaXMubWFwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXlWYWx1ZV0udmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBrZXkgaXMgcHJlc2VudCBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBrZXkgaXMgcHJlc2VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGtleVZhbHVlIGluIHRoaXMubWFwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfSkoUHJvdG9CdWYsIFByb3RvQnVmLlJlZmxlY3QpO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLnByb3RvIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byAucHJvdG8gZmlsZSBjb250ZW50c1xyXG4gICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLmxvYWRQcm90byA9IGZ1bmN0aW9uKHByb3RvLCBidWlsZGVyLCBmaWxlbmFtZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVpbGRlciA9PT0gJ3N0cmluZycgfHwgKGJ1aWxkZXIgJiYgdHlwZW9mIGJ1aWxkZXJbXCJmaWxlXCJdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYnVpbGRlcltcInJvb3RcIl0gPT09ICdzdHJpbmcnKSlcclxuICAgICAgICAgICAgZmlsZW5hbWUgPSBidWlsZGVyLFxyXG4gICAgICAgICAgICBidWlsZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBQcm90b0J1Zi5sb2FkSnNvbihQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIucGFyc2UocHJvdG8pLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSAucHJvdG8gc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBQcm90b0J1Zi5sb2FkUHJvdG99LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gLnByb3RvIGZpbGUgY29udGVudHNcclxuICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nKT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgVGhlIGNvcnJlc3BvbmRpbmcgZmlsZSBuYW1lIGlmIGtub3duLiBNdXN0IGJlIHNwZWNpZmllZCBmb3IgaW1wb3J0cy5cclxuICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXIgdG8gY3JlYXRlIG5ldyBtZXNzYWdlc1xyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYucHJvdG9Gcm9tU3RyaW5nID0gUHJvdG9CdWYubG9hZFByb3RvOyAvLyBMZWdhY3lcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLnByb3RvIGZpbGUgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9fSBmaWxlbmFtZSBQYXRoIHRvIHByb3RvIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcclxuICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgIVByb3RvQnVmLkJ1aWxkZXI9KT19IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGBudWxsYCBhcyB0aGUgZmlyc3QgYW5kXHJcbiAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXHJcbiAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlcj19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybiB7P1Byb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXHJcbiAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLmxvYWRQcm90b0ZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2ssIGJ1aWxkZXIpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgYnVpbGRlciA9IGNhbGxiYWNrLFxyXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGlmIChjYWxsYmFjaylcclxuICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJyA/IGZpbGVuYW1lIDogZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSwgZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGZpbGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgUHJvdG9CdWYubG9hZFByb3RvKGNvbnRlbnRzLCBidWlsZGVyLCBmaWxlbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcgPyBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdIDogZmlsZW5hbWUpO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50cyA9PT0gbnVsbCA/IG51bGwgOiBQcm90b0J1Zi5sb2FkUHJvdG8oY29udGVudHMsIGJ1aWxkZXIsIGZpbGVuYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBwcm90byBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wcm90b0Zyb21GaWxlID0gUHJvdG9CdWYubG9hZFByb3RvRmlsZTsgLy8gTGVnYWN5XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBlbXB0eSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgQnVpbGRlciBvcHRpb25zLCBkZWZhdWx0cyB0byBnbG9iYWwgb3B0aW9ucyBzZXQgb24gUHJvdG9CdWZcclxuICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLm5ld0J1aWxkZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIG9wdGlvbnNbJ2NvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSddID0gUHJvdG9CdWYuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIG9wdGlvbnNbJ3BvcHVsYXRlQWNjZXNzb3JzJ10gPSBQcm90b0J1Zi5wb3B1bGF0ZUFjY2Vzc29ycztcclxuICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkJ1aWxkZXIob3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSAuanNvbiBkZWZpbml0aW9uIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHshKnxzdHJpbmd9IGpzb24gSlNPTiBkZWZpbml0aW9uXHJcbiAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgVGhlIGNvcnJlc3BvbmRpbmcgZmlsZSBuYW1lIGlmIGtub3duLiBNdXN0IGJlIHNwZWNpZmllZCBmb3IgaW1wb3J0cy5cclxuICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXIgdG8gY3JlYXRlIG5ldyBtZXNzYWdlc1xyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYubG9hZEpzb24gPSBmdW5jdGlvbihqc29uLCBidWlsZGVyLCBmaWxlbmFtZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVpbGRlciA9PT0gJ3N0cmluZycgfHwgKGJ1aWxkZXIgJiYgdHlwZW9mIGJ1aWxkZXJbXCJmaWxlXCJdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYnVpbGRlcltcInJvb3RcIl0gPT09ICdzdHJpbmcnKSlcclxuICAgICAgICAgICAgZmlsZW5hbWUgPSBidWlsZGVyLFxyXG4gICAgICAgICAgICBidWlsZGVyID0gbnVsbDtcclxuICAgICAgICBpZiAoIWJ1aWxkZXIgfHwgdHlwZW9mIGJ1aWxkZXIgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICBidWlsZGVyID0gUHJvdG9CdWYubmV3QnVpbGRlcigpO1xyXG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgICAgIGJ1aWxkZXJbXCJpbXBvcnRcIl0oanNvbiwgZmlsZW5hbWUpO1xyXG4gICAgICAgIGJ1aWxkZXIucmVzb2x2ZUFsbCgpO1xyXG4gICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLmpzb24gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfCF7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9fSBmaWxlbmFtZSBQYXRoIHRvIGpzb24gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxyXG4gICAgICogIGFuIG92ZXJyaWRkZW4gJ3Jvb3QnIHBhdGggZm9yIGFsbCBpbXBvcnRlZCBmaWxlcy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcclxuICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcclxuICAgICAqICBmaWxlIHdpbGwgYmUgcmVhZCBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcclxuICAgICAqICAgcmVxdWVzdCBoYXMgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYubG9hZEpzb25GaWxlID0gZnVuY3Rpb24oZmlsZW5hbWUsIGNhbGxiYWNrLCBidWlsZGVyKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIGJ1aWxkZXIgPSBjYWxsYmFjayxcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICBpZiAoY2FsbGJhY2spXHJcbiAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBmaWxlXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRKc29uKEpTT04ucGFyc2UoY29udGVudHMpLCBidWlsZGVyLCBmaWxlbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcgPyBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdIDogZmlsZW5hbWUpO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50cyA9PT0gbnVsbCA/IG51bGwgOiBQcm90b0J1Zi5sb2FkSnNvbihKU09OLnBhcnNlKGNvbnRlbnRzKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHJvdG9CdWY7XHJcbn0pO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wcm90b2J1ZmpzL2Rpc3QvcHJvdG9idWYuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG4gQ29weXJpZ2h0IDIwMTMtMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBieXRlYnVmZmVyLmpzIChjKSAyMDE1IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIEJhY2tpbmcgYnVmZmVyOiBBcnJheUJ1ZmZlciwgQWNjZXNzb3I6IFVpbnQ4QXJyYXlcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2J5dGVidWZmZXIuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXCJsb25nXCJdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pXHJcbiAgICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBMb25nOyB0cnkgeyBMb25nID0gcmVxdWlyZShcImxvbmdcIik7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KExvbmcpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJCeXRlQnVmZmVyXCJdID0gZmFjdG9yeShnbG9iYWxbXCJkY29kZUlPXCJdW1wiTG9uZ1wiXSk7XHJcblxyXG59KSh0aGlzLCBmdW5jdGlvbihMb25nKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBjbGFzcyBUaGUgc3dpc3MgYXJteSBrbmlmZSBmb3IgYmluYXJ5IGRhdGEgaW4gSmF2YVNjcmlwdC5cclxuICAgICAqIEBleHBvcnRzIEJ5dGVCdWZmZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBjYXBhY2l0eSBJbml0aWFsIGNhcGFjaXR5LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgdmFyIEJ5dGVCdWZmZXIgPSBmdW5jdGlvbihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBjYXBhY2l0eSA9IEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWTtcclxuICAgICAgICBpZiAodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU47XHJcbiAgICAgICAgaWYgKHR5cGVvZiBub0Fzc2VydCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUO1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgY2FwYWNpdHkgPSBjYXBhY2l0eSB8IDA7XHJcbiAgICAgICAgICAgIGlmIChjYXBhY2l0eSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eVwiKTtcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gISFsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gISFub0Fzc2VydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhY2tpbmcgQXJyYXlCdWZmZXIuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheUJ1ZmZlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBjYXBhY2l0eSA9PT0gMCA/IEVNUFRZX0JVRkZFUiA6IG5ldyBBcnJheUJ1ZmZlcihjYXBhY2l0eSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVpbnQ4QXJyYXkgdXRpbGl6ZWQgdG8gbWFuaXB1bGF0ZSB0aGUgYmFja2luZyBidWZmZXIuIEJlY29tZXMgYG51bGxgIGlmIHRoZSBiYWNraW5nIGJ1ZmZlciBoYXMgYSBjYXBhY2l0eSBvZiBgMGAuXHJcbiAgICAgICAgICogQHR5cGUgez9VaW50OEFycmF5fVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpZXcgPSBjYXBhY2l0eSA9PT0gMCA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic29sdXRlIHJlYWQvd3JpdGUgb2Zmc2V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNmbGlwXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2NsZWFyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXJrZWQgb2Zmc2V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI3Jlc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSAtMTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzb2x1dGUgbGltaXQgb2YgdGhlIGNvbnRhaW5lZCBkYXRhLiBTZXQgdG8gdGhlIGJhY2tpbmcgYnVmZmVyJ3MgY2FwYWNpdHkgdXBvbiBhbGxvY2F0aW9uLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNmbGlwXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2NsZWFyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW1pdCA9IGNhcGFjaXR5O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW4uXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm9Bc3NlcnQgPSBub0Fzc2VydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeXRlQnVmZmVyIHZlcnNpb24uXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuVkVSU0lPTiA9IFwiNS4wLjFcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpdHRsZSBlbmRpYW4gY29uc3RhbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGl0cyBib29sZWFuIHZhbHVlLiBFdmFsdWF0ZXMgdG8gYHRydWVgLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJpZyBlbmRpYW4gY29uc3RhbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGl0cyBib29sZWFuIHZhbHVlLiBFdmFsdWF0ZXMgdG8gYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuQklHX0VORElBTiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBpbml0aWFsIGNhcGFjaXR5IG9mIGAxNmAuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFkgPSAxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgZW5kaWFuZXNzIG9mIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW4uXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTiA9IEJ5dGVCdWZmZXIuQklHX0VORElBTjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgbm8gYXNzZXJ0aW9ucyBmbGFnIG9mIGBmYWxzZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBMb25nYCBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQtYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS4gTWF5IGJlIGBudWxsYCBpZiBMb25nLmpzIGhhcyBub3QgYmVlbiBsb2FkZWRcclxuICAgICAqICBhbmQgaW50NjQgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLlxyXG4gICAgICogQHR5cGUgez9Mb25nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2xvbmcuanNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5Mb25nID0gTG9uZyB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIEJ5dGVCdWZmZXIucHJvdG90eXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEJ5dGVCdWZmZXJQcm90b3R5cGUgPSBCeXRlQnVmZmVyLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCeXRlQnVmZmVyIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLl9faXNCeXRlQnVmZmVyX187XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVCdWZmZXJQcm90b3R5cGUsIFwiX19pc0J5dGVCdWZmZXJfX1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaGVscGVyc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFBcnJheUJ1ZmZlcn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRU1QVFlfQlVGRkVSID0gbmV3IEFycmF5QnVmZmVyKDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaW5nLmZyb21DaGFyQ29kZSByZWZlcmVuY2UgZm9yIGNvbXBpbGUtdGltZSByZW5hbWluZy5cclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbiguLi5udW1iZXIpOnN0cmluZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzb3VyY2UgZnVuY3Rpb24gZm9yIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nIHRvIHJlYWQgZnJvbVxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKCk6bnVtYmVyfG51bGx9IFNvdXJjZSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlXHJcbiAgICAgKiAgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBhcmd1bWVudCBpcyBpbnZhbGlkXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RyaW5nU291cmNlKHMpIHtcclxuICAgICAgICB2YXIgaT0wOyByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpIDwgcy5sZW5ndGggPyBzLmNoYXJDb2RlQXQoaSsrKSA6IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBkZXN0aW5hdGlvbiBmdW5jdGlvbiBmb3IgYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyPSk6dW5kZWZpbmVkfHN0cmluZ30gRGVzdGluYXRpb24gZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGNoYXIgY29kZS5cclxuICAgICAqICBSZXR1cm5zIHRoZSBmaW5hbCBzdHJpbmcgd2hlbiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMuXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RyaW5nRGVzdGluYXRpb24oKSB7XHJcbiAgICAgICAgdmFyIGNzID0gW10sIHBzID0gW107IHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHMuam9pbignJykrc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY3MpO1xyXG4gICAgICAgICAgICBpZiAoY3MubGVuZ3RoICsgYXJndW1lbnRzLmxlbmd0aCA+IDEwMjQpXHJcbiAgICAgICAgICAgICAgICBwcy5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNzKSksXHJcbiAgICAgICAgICAgICAgICAgICAgY3MubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY3MsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFjY2Vzc29yIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IGBCdWZmZXJgIHVuZGVyIG5vZGUuanMsIGBVaW50OEFycmF5YCByZXNwZWN0aXZlbHkgYERhdGFWaWV3YCBpbiB0aGUgYnJvd3NlciAoY2xhc3NlcylcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5hY2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIGEgbmV3IEJ5dGVCdWZmZXIgYmFja2VkIGJ5IGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGNhcGFjaXR5IEluaXRpYWwgY2FwYWNpdHkuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFl9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmFsbG9jYXRlID0gZnVuY3Rpb24oY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyBtdWx0aXBsZSBCeXRlQnVmZmVycyBpbnRvIG9uZS5cclxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nPn0gYnVmZmVycyBCdWZmZXJzIHRvIGNvbmNhdGVuYXRlXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8Ym9vbGVhbik9fSBlbmNvZGluZyBTdHJpbmcgZW5jb2RpbmcgaWYgYGJ1ZmZlcnNgIGNvbnRhaW5zIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLFxyXG4gICAgICogIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIgZm9yIHRoZSByZXN1bHRpbmcgQnl0ZUJ1ZmZlci4gRGVmYXVsdHNcclxuICAgICAqICB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMgZm9yIHRoZSByZXN1bHRpbmcgQnl0ZUJ1ZmZlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ29uY2F0ZW5hdGVkIEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbihidWZmZXJzLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBrPWJ1ZmZlcnMubGVuZ3RoLCBsZW5ndGg7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyc1tpXSkpXHJcbiAgICAgICAgICAgICAgICBidWZmZXJzW2ldID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcnNbaV0sIGVuY29kaW5nKTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYnVmZmVyc1tpXS5saW1pdCAtIGJ1ZmZlcnNbaV0ub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkgY2FwYWNpdHkgKz0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FwYWNpdHkgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCksXHJcbiAgICAgICAgICAgIGJpO1xyXG4gICAgICAgIGk9MDsgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBiaSA9IGJ1ZmZlcnNbaSsrXTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYmkubGltaXQgLSBiaS5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gMCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGJiLnZpZXcuc2V0KGJpLnZpZXcuc3ViYXJyYXkoYmkub2Zmc2V0LCBiaS5saW1pdCksIGJiLm9mZnNldCk7XHJcbiAgICAgICAgICAgIGJiLm9mZnNldCArPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJiLmxpbWl0ID0gYmIub2Zmc2V0O1xyXG4gICAgICAgIGJiLm9mZnNldCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0geyp9IGJiIEJ5dGVCdWZmZXIgdG8gdGVzdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBpdCBpcyBhIEJ5dGVCdWZmZXIsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyID0gZnVuY3Rpb24oYmIpIHtcclxuICAgICAgICByZXR1cm4gKGJiICYmIGJiW1wiX19pc0J5dGVCdWZmZXJfX1wiXSkgPT09IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBiYWNraW5nIGJ1ZmZlciB0eXBlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgQnVmZmVyYCB1bmRlciBub2RlLmpzLCBgQXJyYXlCdWZmZXJgIGluIHRoZSBicm93c2VyIChjbGFzc2VzKVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLnR5cGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcyBhIGJ1ZmZlciBvciBhIHN0cmluZy4gU2V0cyB0aGUgYWxsb2NhdGVkIEJ5dGVCdWZmZXIncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IHRvIGAwYCBhbmQgaXRzXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIHRoZSBsZW5ndGggb2YgdGhlIHdyYXBwZWQgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ3whQXJyYXkuPG51bWJlcj59IGJ1ZmZlciBBbnl0aGluZyB0aGF0IGNhbiBiZSB3cmFwcGVkXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8Ym9vbGVhbik9fSBlbmNvZGluZyBTdHJpbmcgZW5jb2RpbmcgaWYgYGJ1ZmZlcmAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvXHJcbiAgICAgKiAgXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEEgQnl0ZUJ1ZmZlciB3cmFwcGluZyBgYnVmZmVyYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLndyYXAgPSBmdW5jdGlvbihidWZmZXIsIGVuY29kaW5nLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IGVuY29kaW5nO1xyXG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CYXNlNjQoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImhleFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21IZXgoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tVVRGOChidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tRGVidWcoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCB8fCB0eXBlb2YgYnVmZmVyICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7XHJcbiAgICAgICAgdmFyIGJiO1xyXG4gICAgICAgIGlmIChCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcihidWZmZXIpKSB7XHJcbiAgICAgICAgICAgIGJiID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbG9uZS5jYWxsKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gYmI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IC8vIEV4dHJhY3QgQXJyYXlCdWZmZXIgZnJvbSBVaW50OEFycmF5XHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkgeyAvLyBBdm9pZCByZWZlcmVuY2VzIHRvIG1vcmUgdGhhbiBvbmUgRU1QVFlfQlVGRkVSXHJcbiAgICAgICAgICAgICAgICBiYi5idWZmZXIgPSBidWZmZXIuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gYnVmZmVyLmJ5dGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBiYi52aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7IC8vIFJldXNlIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJiLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYmIudmlldyA9IGJ1ZmZlci5ieXRlTGVuZ3RoID4gMCA/IG5ldyBVaW50OEFycmF5KGJ1ZmZlcikgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYnVmZmVyKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7IC8vIENyZWF0ZSBmcm9tIG9jdGV0c1xyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKGJ1ZmZlci5sZW5ndGgsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxidWZmZXIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBiYi52aWV3W2ldID0gYnVmZmVyW2ldO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTsgLy8gT3RoZXJ3aXNlIGZhaWxcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHRoZSBhcnJheSBhcyBhIGJpdHNldC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8Ym9vbGVhbj59IHZhbHVlIEFycmF5IG9mIGJvb2xlYW5zIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgbGVuZ3RoYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQml0U2V0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgQml0U2V0OiBOb3QgYW4gYXJyYXlcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgYml0cyA9IHZhbHVlLmxlbmd0aCxcclxuICAgICAgICAgIGJ5dGVzID0gKGJpdHMgPj4gMyksXHJcbiAgICAgICAgICBiaXQgPSAwLFxyXG4gICAgICAgICAgaztcclxuXHJcbiAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoYml0cyxvZmZzZXQpO1xyXG5cclxuICAgICAgd2hpbGUoYnl0ZXMtLSkge1xyXG4gICAgICAgIGsgPSAoISF2YWx1ZVtiaXQrK10gJiAxKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAxKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAyKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAzKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA0KSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA1KSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA2KSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA3KTtcclxuICAgICAgICB0aGlzLndyaXRlQnl0ZShrLG9mZnNldCsrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoYml0IDwgYml0cykge1xyXG4gICAgICAgIHZhciBtID0gMDsgayA9IDA7XHJcbiAgICAgICAgd2hpbGUoYml0IDwgYml0cykgayA9IGsgfCAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgKG0rKykpO1xyXG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGssb2Zmc2V0KyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIEJpdFNldCBhcyBhbiBhcnJheSBvZiBib29sZWFucy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQml0U2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcblxyXG4gICAgICB2YXIgcmV0ID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KSxcclxuICAgICAgICAgIGJpdHMgPSByZXQudmFsdWUsXHJcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxyXG4gICAgICAgICAgYml0ID0gMCxcclxuICAgICAgICAgIHZhbHVlID0gW10sXHJcbiAgICAgICAgICBrO1xyXG5cclxuICAgICAgb2Zmc2V0ICs9IHJldC5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZShieXRlcy0tKSB7XHJcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDAxKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwMik7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDQpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDA4KTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgxMCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MjApO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDQwKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHg4MCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGJpdCA8IGJpdHMpIHtcclxuICAgICAgICB2YXIgbSA9IDA7XHJcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xyXG4gICAgICAgIHdoaWxlKGJpdCA8IGJpdHMpIHZhbHVlW2JpdCsrXSA9ICEhKChrID4+IChtKyspKSAmIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYGxlbmd0aGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIGxlbmd0aCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiK2xlbmd0aCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2xpY2UgPSB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHBheWxvYWQgb2YgYnl0ZXMuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjYXBwZW5kfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nfSBzb3VyY2UgRGF0YSB0byB3cml0ZS4gSWYgYHNvdXJjZWAgaXMgYSBCeXRlQnVmZmVyLCBpdHMgb2Zmc2V0c1xyXG4gICAgICogIHdpbGwgYmUgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJ5dGVzID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5hcHBlbmQ7XHJcblxyXG4gICAgLy8gdHlwZXMvaW50cy9pbnQ4XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB2YXIgY2FwYWNpdHkwID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTAgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTAgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMTtcbiAgICAgICAgdGhpcy52aWV3W29mZnNldF0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50OH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCeXRlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlld1tvZmZzZXRdO1xyXG4gICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMHg4MCkgdmFsdWUgPSAtKDB4RkYgLSB2YWx1ZSArIDEpOyAvLyBDYXN0IHRvIHNpZ25lZFxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRCeXRlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ODtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDggPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlld1tvZmZzZXRdO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50OCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ4O1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50MTZcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgdmFyIGNhcGFjaXR5MiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkyICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkyIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDI7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlICYgMHhGRjAwKSA+Pj4gODtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAmIDB4MDBGRjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSAgID0gKHZhbHVlICYgMHhGRjAwKSA+Pj4gODtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICB2YWx1ZSAmIDB4MDBGRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDE2fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVTaG9ydCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAyID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMitcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXSA8PCA4O1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZhbHVlICYgMHg4MDAwKSA9PT0gMHg4MDAwKSB2YWx1ZSA9IC0oMHhGRkZGIC0gdmFsdWUgKyAxKTsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTaG9ydCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHZhciBjYXBhY2l0eTMgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkzKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MyA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldF0gICA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDE2ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAyID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMitcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXSA8PCA4O1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50MTYgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MTY7XHJcblxyXG4gICAgLy8gdHlwZXMvaW50cy9pbnQzMlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5NCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTQpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk0ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk0IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDMyfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgfD0gMDsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQzMn0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5NSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTUpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk1ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk1IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDMyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDMyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDMyO1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50NjRcclxuXHJcbiAgICBpZiAoTG9uZykge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIExvbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICB2YXIgY2FwYWNpdHk2ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTYpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NiA6IG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgICAgIHZhciBsbyA9IHZhbHVlLmxvdyxcclxuICAgICAgICAgICAgICAgIGhpID0gdmFsdWUuaGlnaDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQ2NH0uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUxvbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50NjQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA4ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG8gPSAwLFxyXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgTG9uZyhsbywgaGksIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDY0fS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZExvbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ2NDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5NyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk3KVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTcgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTcgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgICAgICB2YXIgbG8gPSB2YWx1ZS5sb3csXHJcbiAgICAgICAgICAgICAgICBoaSA9IHZhbHVlLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50NjR9LlxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDY0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvID0gMCxcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IExvbmcobG8sIGhpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDY0fS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQ2NCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ2NDtcclxuXHJcbiAgICB9IC8vIExvbmdcclxuXHJcblxyXG4gICAgLy8gdHlwZXMvZmxvYXRzL2Zsb2F0MzJcclxuXHJcbiAgICAvKlxyXG4gICAgIGllZWU3NTQgLSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcclxuXHJcbiAgICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcblxyXG4gICAgIENvcHlyaWdodCAoYykgRmVyb3NzIEFib3VraGFkaWplaFxyXG5cclxuICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAgICAgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gICAgIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICAgICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAgICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAgICAgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICAgICBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gICAgIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICAgICBUSEUgU09GVFdBUkUuXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gSUVFRTc1NCBmbG9hdCBmcm9tIGEgYnl0ZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7IUFycmF5fSBidWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1MZW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaWVlZTc1NF9yZWFkKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcclxuICAgICAgICB2YXIgZSwgbSxcclxuICAgICAgICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcclxuICAgICAgICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcclxuICAgICAgICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXHJcbiAgICAgICAgICAgIG5CaXRzID0gLTcsXHJcbiAgICAgICAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcclxuICAgICAgICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXHJcbiAgICAgICAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XHJcblxyXG4gICAgICAgIGkgKz0gZDtcclxuXHJcbiAgICAgICAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XHJcbiAgICAgICAgcyA+Pj0gKC1uQml0cyk7XHJcbiAgICAgICAgbkJpdHMgKz0gZUxlbjtcclxuICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxyXG5cclxuICAgICAgICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcclxuICAgICAgICBlID4+PSAoLW5CaXRzKTtcclxuICAgICAgICBuQml0cyArPSBtTGVuO1xyXG4gICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XHJcblxyXG4gICAgICAgIGlmIChlID09PSAwKSB7XHJcbiAgICAgICAgICAgIGUgPSAxIC0gZUJpYXM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xyXG4gICAgICAgICAgICBlID0gZSAtIGVCaWFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBJRUVFNzU0IGZsb2F0IHRvIGEgYnl0ZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7IUFycmF5fSBidWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xFXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbUxlblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlc1xyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGllZWU3NTRfd3JpdGUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcclxuICAgICAgICB2YXIgZSwgbSwgYyxcclxuICAgICAgICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcclxuICAgICAgICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcclxuICAgICAgICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXHJcbiAgICAgICAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcclxuICAgICAgICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxyXG4gICAgICAgICAgICBkID0gaXNMRSA/IDEgOiAtMSxcclxuICAgICAgICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcclxuICAgICAgICAgICAgZSA9IGVNYXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBlLS07XHJcbiAgICAgICAgICAgICAgICBjICo9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBlKys7XHJcbiAgICAgICAgICAgICAgICBjIC89IDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xyXG4gICAgICAgICAgICAgICAgbSA9IDA7XHJcbiAgICAgICAgICAgICAgICBlID0gZU1heDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xyXG4gICAgICAgICAgICAgICAgZSA9IGUgKyBlQmlhcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxyXG5cclxuICAgICAgICBlID0gKGUgPDwgbUxlbikgfCBtO1xyXG4gICAgICAgIGVMZW4gKz0gbUxlbjtcclxuICAgICAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XHJcblxyXG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB2YXIgY2FwYWNpdHk4ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5OClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTggKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTggOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNDtcbiAgICAgICAgaWVlZTc1NF93cml0ZSh0aGlzLnZpZXcsIHZhbHVlLCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCAyMywgNCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUZsb2F0MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gaWVlZTc1NF9yZWFkKHRoaXMudmlldywgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgMjMsIDQpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEZsb2F0MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQzMjtcclxuXHJcbiAgICAvLyB0eXBlcy9mbG9hdHMvZmxvYXQ2NFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgNjRiaXQgZmxvYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYSBudW1iZXIpXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIHZhciBjYXBhY2l0eTkgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk5KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5OSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5OSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICBpZWVlNzU0X3dyaXRlKHRoaXMudmlldywgdmFsdWUsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlRmxvYXQ2NH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRG91YmxlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0NjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDY0Yml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gaWVlZTc1NF9yZWFkKHRoaXMudmlldywgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgNTIsIDgpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgNjRiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEZsb2F0NjR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZERvdWJsZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0NjQ7XHJcblxyXG5cclxuICAgIC8vIHR5cGVzL3ZhcmludHMvdmFyaW50MzJcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDMyX0JZVEVTID0gNTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyByZXF1aXJlZC4gQ2FwcGVkIHRvIHtAbGluayBCeXRlQnVmZmVyLk1BWF9WQVJJTlQzMl9CWVRFU31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL2lvL2NvZGVkX3N0cmVhbS5jY1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDA7XHJcbiAgICAgICAgICAgICBpZiAodmFsdWUgPCAxIDw8IDcgKSByZXR1cm4gMTtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDEgPDwgMTQpIHJldHVybiAyO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMSA8PCAyMSkgcmV0dXJuIDM7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDI4KSByZXR1cm4gNDtcclxuICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFppZ3phZyBlbmNvZGVzIGEgc2lnbmVkIDMyYml0IGludGVnZXIgc28gdGhhdCBpdCBjYW4gYmUgZWZmZWN0aXZlbHkgdXNlZCB3aXRoIHZhcmludCBlbmNvZGluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFNpZ25lZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCB6aWd6YWcgZW5jb2RlZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlMzIgPSBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKG4gfD0gMCkgPDwgMSkgXiAobiA+PiAzMSkpID4+PiAwOyAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIHppZ3phZyBlbmNvZGVkIHNpZ25lZCAzMmJpdCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVW5zaWduZWQgemlnemFnIGVuY29kZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMiA9IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICByZXR1cm4gKChuID4+PiAxKSBeIC0obiAmIDEpKSB8IDA7IC8vIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaXplID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgIHZhciBjYXBhY2l0eTEwID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTAgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gc2l6ZTtcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSAweDgwKSB7XHJcbiAgICAgICAgICAgIGIgPSAodmFsdWUgJiAweDdmKSB8IDB4ODA7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB6aWctemFnIGVuY29kZWQgKHNpZ25lZCkgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQzMlppZ1phZyA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVZhcmludDMyKEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlMzIodmFsdWUpLCBvZmZzZXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcnwhe3ZhbHVlOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHZhbHVlIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHZhbHVlIHJlYWRcclxuICAgICAqICBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludC4gSGFzIGEgcHJvcGVydHkgYHRydW5jYXRlZCA9IHRydWVgIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSBhdmFpbGFibGVcclxuICAgICAqICB0byBmdWxseSBkZWNvZGUgdGhlIHZhcmludC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYyA9IDAsXHJcbiAgICAgICAgICAgIHZhbHVlID0gMCA+Pj4gMCxcclxuICAgICAgICAgICAgYjtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCAmJiBvZmZzZXQgPiB0aGlzLmxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXCJUcnVuY2F0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICBlcnJbJ3RydW5jYXRlZCddID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTtcclxuICAgICAgICAgICAgaWYgKGMgPCA1KVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgfD0gKGIgJiAweDdmKSA8PCAoNypjKTtcclxuICAgICAgICAgICAgKytjO1xyXG4gICAgICAgIH0gd2hpbGUgKChiICYgMHg4MCkgIT09IDApO1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUsXHJcbiAgICAgICAgICAgIFwibGVuZ3RoXCI6IGNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIChzaWduZWQpIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8IXt2YWx1ZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkXHJcbiAgICAgKiAgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50MzJaaWdaYWcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHZhbFtcInZhbHVlXCJdID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMih2YWxbXCJ2YWx1ZVwiXSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB2YWwgPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTMyKHZhbCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdHlwZXMvdmFyaW50cy92YXJpbnQ2NFxyXG5cclxuICAgIGlmIChMb25nKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UNjRfQllURVMgPSAxMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQuIENhcHBlZCB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UNjRfQllURVN9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcclxuICAgICAgICAgICAgdmFyIHBhcnQwID0gdmFsdWUudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDIgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCkgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0MiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFydDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0MCA8IDEgPDwgMTQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MCA8IDEgPDwgNyA/IDEgOiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQwIDwgMSA8PCAyMSA/IDMgOiA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDEgPCAxIDw8IDE0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDEgPCAxIDw8IDcgPyA1IDogNjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MSA8IDEgPDwgMjEgPyA3IDogODtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDIgPCAxIDw8IDcgPyA5IDogMTA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWmlnemFnIGVuY29kZXMgYSBzaWduZWQgNjRiaXQgaW50ZWdlciBzbyB0aGF0IGl0IGNhbiBiZSBlZmZlY3RpdmVseSB1c2VkIHdpdGggdmFyaW50IGVuY29kaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBTaWduZWQgbG9uZ1xyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgemlnemFnIGVuY29kZWQgbG9uZ1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2hpZnRMZWZ0KDEpLnhvcih2YWx1ZS5zaGlmdFJpZ2h0KDYzKSkudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSB6aWd6YWcgZW5jb2RlZCBzaWduZWQgNjRiaXQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcn0gdmFsdWUgVW5zaWduZWQgemlnemFnIGVuY29kZWQgbG9uZyBvciBKYXZhU2NyaXB0IG51bWJlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS51bnNpZ25lZCAhPT0gZmFsc2UpIHZhbHVlID0gdmFsdWUudG9TaWduZWQoKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgxKS54b3IodmFsdWUuYW5kKExvbmcuT05FKS50b1NpZ25lZCgpLm5lZ2F0ZSgpKS50b1NpZ25lZCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfExvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgcGFydDAgPSB2YWx1ZS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDEgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKSA+Pj4gMDtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICB2YXIgY2FwYWNpdHkxMSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTEgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IHNpemU7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHRoaXMudmlld1tvZmZzZXQrOV0gPSAocGFydDIgPj4+ICA3KSAmIDB4MDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkgOiB0aGlzLnZpZXdbb2Zmc2V0KzhdID0gc2l6ZSAhPT0gOSA/IChwYXJ0MiAgICAgICApIHwgMHg4MCA6IChwYXJ0MiAgICAgICApICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgOCA6IHRoaXMudmlld1tvZmZzZXQrN10gPSBzaXplICE9PSA4ID8gKHBhcnQxID4+PiAyMSkgfCAweDgwIDogKHBhcnQxID4+PiAyMSkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3IDogdGhpcy52aWV3W29mZnNldCs2XSA9IHNpemUgIT09IDcgPyAocGFydDEgPj4+IDE0KSB8IDB4ODAgOiAocGFydDEgPj4+IDE0KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDYgOiB0aGlzLnZpZXdbb2Zmc2V0KzVdID0gc2l6ZSAhPT0gNiA/IChwYXJ0MSA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gIDcpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNSA6IHRoaXMudmlld1tvZmZzZXQrNF0gPSBzaXplICE9PSA1ID8gKHBhcnQxICAgICAgICkgfCAweDgwIDogKHBhcnQxICAgICAgICkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IDogdGhpcy52aWV3W29mZnNldCszXSA9IHNpemUgIT09IDQgPyAocGFydDAgPj4+IDIxKSB8IDB4ODAgOiAocGFydDAgPj4+IDIxKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMgOiB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gc2l6ZSAhPT0gMyA/IChwYXJ0MCA+Pj4gMTQpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gMTQpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMiA6IHRoaXMudmlld1tvZmZzZXQrMV0gPSBzaXplICE9PSAyID8gKHBhcnQwID4+PiAgNykgfCAweDgwIDogKHBhcnQwID4+PiAgNykgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIDogdGhpcy52aWV3W29mZnNldCAgXSA9IHNpemUgIT09IDEgPyAocGFydDAgICAgICAgKSB8IDB4ODAgOiAocGFydDAgICAgICAgKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzaXplO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIHppZy16YWcgZW5jb2RlZCA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQ2NFppZ1phZyA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVWYXJpbnQ2NChCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0KHZhbHVlKSwgb2Zmc2V0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLiBSZXF1aXJlcyBMb25nLmpzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ3whe3ZhbHVlOiBMb25nLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkIGFuZFxyXG4gICAgICAgICAqICB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgICAgIHBhcnQwID0gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQyID0gMCxcclxuICAgICAgICAgICAgICAgIGIgID0gMDtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwICA9IChiICYgMHg3RikgICAgICA7IGlmICggYiAmIDB4ODAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgMTQ7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgMjE7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxICA9IChiICYgMHg3RikgICAgICA7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgMTQ7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgMjE7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQyICA9IChiICYgMHg3RikgICAgICA7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQyIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCdWZmZXIgb3ZlcnJ1blwiKTsgfX19fX19fX19fVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBMb25nLmZyb21CaXRzKHBhcnQwIHwgKHBhcnQxIDw8IDI4KSwgKHBhcnQxID4+PiA0KSB8IChwYXJ0MikgPDwgMjQsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldC1zdGFydFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLiBSZXF1aXJlcyBMb25nLmpzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ3whe3ZhbHVlOiBMb25nLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkIGFuZFxyXG4gICAgICAgICAqICB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQ2NFppZ1phZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50NjQob2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWxbJ3ZhbHVlJ10gaW5zdGFuY2VvZiBMb25nKVxyXG4gICAgICAgICAgICAgICAgdmFsW1widmFsdWVcIl0gPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTY0KHZhbFtcInZhbHVlXCJdKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdmFsID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCh2YWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSAvLyBMb25nXHJcblxyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvY3N0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgTlVMTC10ZXJtaW5hdGVkIFVURjggZW5jb2RlZCBzdHJpbmcuIEZvciB0aGlzIHRvIHdvcmsgdGhlIHNwZWNpZmllZCBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnkgTlVMTFxyXG4gICAgICogIGNoYXJhY3RlcnMgaXRzZWxmLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIGNvbnRhaW5lZCBpbiBgc3RyYCArIDEgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQ1N0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBrID0gc3RyLmxlbmd0aDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgZm9yIChpPTA7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBOVUxMLWNoYXJhY3RlcnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVURjggc3RyaW5ncyBkbyBub3QgY29udGFpbiB6ZXJvIGJ5dGVzIGluIGJldHdlZW4gZXhjZXB0IGZvciB0aGUgemVybyBjaGFyYWN0ZXIsIHNvOlxyXG4gICAgICAgIGsgPSB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVsxXTtcclxuICAgICAgICBvZmZzZXQgKz0gaysxO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTIgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEyIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGsrMTtcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgTlVMTC10ZXJtaW5hdGVkIFVURjggZW5jb2RlZCBzdHJpbmcuIEZvciB0aGlzIHRvIHdvcmsgdGhlIHN0cmluZyByZWFkIG11c3Qgbm90IGNvbnRhaW4gYW55IE5VTEwgY2hhcmFjdGVyc1xyXG4gICAgICogIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRDU3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICB0ZW1wO1xyXG4gICAgICAgIC8vIFVURjggc3RyaW5ncyBkbyBub3QgY29udGFpbiB6ZXJvIGJ5dGVzIGluIGJldHdlZW4gZXhjZXB0IGZvciB0aGUgemVybyBjaGFyYWN0ZXIgaXRzZWxmLCBzbzpcclxuICAgICAgICB2YXIgc2QsIGIgPSAtMTtcclxuICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiIDwgXCIrdGhpcy5saW1pdCk7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IG51bGwgOiBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpLCB0cnVlKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBzZCgpLFxyXG4gICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvaXN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIGs7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xyXG4gICAgICAgIG9mZnNldCArPSA0K2s7XG4gICAgICAgIHZhciBjYXBhY2l0eTEzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTMpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTMgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNCtrO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoayA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoayA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoayA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgayAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoayA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoayA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoayA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgayAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gc3RhcnQgKyA0ICsgaylcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrKG9mZnNldCs0K2spKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBsZW5ndGggYXMgdWludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZWFkVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSVN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMucmVhZFVURjhTdHJpbmcobGVuLCBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMsIG9mZnNldCArPSA0KTtcclxuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcclxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gdHlwZXMvc3RyaW5ncy91dGY4c3RyaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyaWNzIHJlcHJlc2VudGluZyBudW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzLiBFdmFsdWF0ZXMgdG8gYGNgLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlMgPSAnYyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyaWNzIHJlcHJlc2VudGluZyBudW1iZXIgb2YgYnl0ZXMuIEV2YWx1YXRlcyB0byBgYmAuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUyA9ICdiJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrO1xyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IGs7XG4gICAgICAgIHZhciBjYXBhY2l0eTE0ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTQpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTQgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gaztcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVURjhTdHJpbmd9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU3RyaW5nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzIG9mIGEgc3RyaW5nLiBKYXZhU2NyaXB0IGl0c2VsZiB1c2VzIFVURi0xNiwgc28gdGhhdCBhIHN0cmluZydzXHJcbiAgICAgKiAgYGxlbmd0aGAgcHJvcGVydHkgZG9lcyBub3QgcmVmbGVjdCBpdHMgYWN0dWFsIFVURjggc2l6ZSBpZiBpdCBjb250YWlucyBjb2RlIHBvaW50cyBsYXJnZXIgdGhhbiAweEZGRkYuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGNoYXJhY3RlcnNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Q2hhcnMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICByZXR1cm4gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgb2YgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGJ5dGVzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhbGN1bGF0ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIFVURjggYnl0ZXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVTdHJpbmcgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIHRvIHJlYWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG1ldHJpY3MgTWV0cmljcyBzcGVjaWZ5aW5nIHdoYXQgYGxlbmd0aGAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSU30uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVVRGOFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgbWV0cmljcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBtZXRyaWNzO1xyXG4gICAgICAgICAgICBtZXRyaWNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAndW5kZWZpbmVkJykgbWV0cmljcyA9IEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUztcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2xlbmd0aCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgbGVuZ3RoIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgc2Q7XHJcbiAgICAgICAgaWYgKG1ldHJpY3MgPT09IEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUykgeyAvLyBUaGUgc2FtZSBmb3Igbm9kZSBhbmQgdGhlIGJyb3dzZXJcclxuICAgICAgICAgICAgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpO1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjgoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbmd0aCAmJiBvZmZzZXQgPCB0aGlzLmxpbWl0ID8gdGhpcy52aWV3W29mZnNldCsrXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgICsraTsgdXRmeC5VVEY4dG9VVEYxNihjcCwgc2QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGkgIT09IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIraStcIiA9PSBcIitsZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IHNkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1ldHJpY3MgPT09IEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrbGVuZ3RoK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGsgPSBvZmZzZXQgKyBsZW5ndGg7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0IDwgayA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGspXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIitrKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJzogc2QoKSxcclxuICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0cmljczogXCIrbWV0cmljcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVVRGOFN0cmluZ30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGNoYXJhY3RlcnMgb3IgYnl0ZXMgdG8gcmVhZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBtZXRyaWNzIE1ldHJpY3Mgc3BlY2lmeWluZyB3aGF0IGBuYCBpcyBtZWFudCB0byBjb3VudC4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTdHJpbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nO1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdnN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHZhcmludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3dyaXRlVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgaywgbDtcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdGhpcy5ub0Fzc2VydClbMV07XHJcbiAgICAgICAgbCA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoayk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IGwraztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE1ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBsK2s7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoaywgb2Zmc2V0KTtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gc3RhcnQraytsKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIisob2Zmc2V0K2srbCkpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMucmVhZFVURjhTdHJpbmcobGVuWyd2YWx1ZSddLCBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMsIG9mZnNldCArPSBsZW5bJ2xlbmd0aCddKTtcclxuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcclxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBzb21lIGRhdGEgdG8gdGhpcyBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWhpbmQgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGFwcGVuZGVkXHJcbiAgICAgKiAgZGF0YSdzIGxlbmd0aC5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gYXBwZW5kLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXRzXHJcbiAgICAgKiAgd2lsbCBiZSBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gZW5jb2RpbmcgRW5jb2RpbmcgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBhcHBlbmQgYXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIEEgcmVsYXRpdmUgYDwwMSAwMj4wMy5hcHBlbmQoPDA0IDA1PilgIHdpbGwgcmVzdWx0IGluIGA8MDEgMDIgMDQgMDU+LCAwNCAwNXxgXHJcbiAgICAgKiBAZXhhbXBsZSBBbiBhYnNvbHV0ZSBgPDAxIDAyPjAzLmFwcGVuZCgwNCAwNT4sIDEpYCB3aWxsIHJlc3VsdCBpbiBgPDAxIDA0PjA1LCAwNCAwNXxgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBCeXRlQnVmZmVyLndyYXAoc291cmNlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBhcHBlbmRcclxuICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICB2YXIgY2FwYWNpdHkxNiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTE2KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTE2IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGxlbmd0aDtcbiAgICAgICAgdGhpcy52aWV3LnNldChzb3VyY2Uudmlldy5zdWJhcnJheShzb3VyY2Uub2Zmc2V0LCBzb3VyY2UubGltaXQpLCBvZmZzZXQpO1xyXG4gICAgICAgIHNvdXJjZS5vZmZzZXQgKz0gbGVuZ3RoO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYXQgYW5kIGFmdGVyIHRoZVxyXG4gICAgICAgIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGxlbmd0aCBvZiB0aGlzIEJ5dGVCdWZmZXIncyBkYXRhLlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gYXBwZW5kIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjYXBwZW5kXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHRhcmdldC5hcHBlbmQodGhpcywgb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGFzc2VydGlvbnMgb2YgYXJndW1lbnQgdHlwZXMgYW5kIG9mZnNldHMuIEFzc2VydGlvbnMgYXJlIGVuYWJsZWQgYnkgZGVmYXVsdCBidXQgeW91IGNhbiBvcHQgdG9cclxuICAgICAqICBkaXNhYmxlIHRoZW0gaWYgeW91ciBjb2RlIGFscmVhZHkgbWFrZXMgc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzc2VydCBgdHJ1ZWAgdG8gZW5hYmxlIGFzc2VydGlvbnMsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbihhc3NlcnQpIHtcclxuICAgICAgICB0aGlzLm5vQXNzZXJ0ID0gIWFzc2VydDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjYXBhY2l0eSBvZiB0aGlzIEJ5dGVCdWZmZXIncyBiYWNraW5nIGJ1ZmZlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IENhcGFjaXR5IG9mIHRoZSBiYWNraW5nIGJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNhcGFjaXR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhpcyBCeXRlQnVmZmVyJ3Mgb2Zmc2V0cyBieSBzZXR0aW5nIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gdG8gYDBgIGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gdGhlXHJcbiAgICAgKiAgYmFja2luZyBidWZmZXIncyBjYXBhY2l0eS4gRGlzY2FyZHMge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGlzIEJ5dGVCdWZmZXIsIHByZXNldCB3aXRoIHRoaXMgQnl0ZUJ1ZmZlcidzIHZhbHVlcyBmb3Ige0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSxcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb3B5IFdoZXRoZXIgdG8gY29weSB0aGUgYmFja2luZyBidWZmZXIgb3IgdG8gcmV0dXJuIGFub3RoZXIgdmlldyBvbiB0aGUgc2FtZSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDbG9uZWQgaW5zdGFuY2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGNvcHkpIHtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgaWYgKGNvcHkpIHtcclxuICAgICAgICAgICAgYmIuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBiYi52aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmIuYnVmZmVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYi5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICAgICAgYmIudmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gdGhpcy5tYXJrZWRPZmZzZXQ7XHJcbiAgICAgICAgYmIubGltaXQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYWN0cyB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgYmFja2VkIGJ5IGEge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfSBvZiBpdHMgY29udGVudHMnIGxlbmd0aC4gQ29udGVudHMgYXJlIHRoZSBieXRlc1xyXG4gICAgICogIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBXaWxsIHNldCBgb2Zmc2V0ID0gMGAgYW5kIGBsaW1pdCA9IGNhcGFjaXR5YCBhbmRcclxuICAgICAqICBhZGFwdCB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9IHRvIHRoZSBzYW1lIHJlbGF0aXZlIHBvc2l0aW9uIGlmIHNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIHN0YXJ0IGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gMCAmJiBlbmQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBBbHJlYWR5IGNvbXBhY3RlZFxyXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBiZWdpbjtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5saW1pdCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XHJcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgIHZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShiZWdpbiwgZW5kKSk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsZW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gQmVnaW4gb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDb3B5XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwLCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gZW5kIC0gYmVnaW4sXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLm5vQXNzZXJ0KTtcclxuICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gY2FwYWNpdHk7XHJcbiAgICAgICAgaWYgKGJiLm1hcmtlZE9mZnNldCA+PSAwKSBiYi5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5jb3B5VG8oYmIsIDAsIGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gdGFyZ2V0T2Zmc2V0IE9mZnNldCB0byBjb3B5IHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2UgdGhlIHRhcmdldCdzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cclxuICAgICAqICBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VPZmZzZXQgT2Zmc2V0IHRvIHN0YXJ0IGNvcHlpbmcgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlXHJcbiAgICAgKiAgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VMaW1pdCBPZmZzZXQgdG8gZW5kIGNvcHlpbmcgZnJvbSwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldE9mZnNldCwgc291cmNlT2Zmc2V0LCBzb3VyY2VMaW1pdCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSxcclxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmU7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdGFyZ2V0OiBOb3QgYSBCeXRlQnVmZmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRPZmZzZXQgPSAodGFyZ2V0UmVsYXRpdmUgPSB0eXBlb2YgdGFyZ2V0T2Zmc2V0ID09PSAndW5kZWZpbmVkJykgPyB0YXJnZXQub2Zmc2V0IDogdGFyZ2V0T2Zmc2V0IHwgMDtcclxuICAgICAgICBzb3VyY2VPZmZzZXQgPSAocmVsYXRpdmUgPSB0eXBlb2Ygc291cmNlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykgPyB0aGlzLm9mZnNldCA6IHNvdXJjZU9mZnNldCB8IDA7XHJcbiAgICAgICAgc291cmNlTGltaXQgPSB0eXBlb2Ygc291cmNlTGltaXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5saW1pdCA6IHNvdXJjZUxpbWl0IHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldCA8IDAgfHwgdGFyZ2V0T2Zmc2V0ID4gdGFyZ2V0LmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQgcmFuZ2U6IDAgPD0gXCIrdGFyZ2V0T2Zmc2V0K1wiIDw9IFwiK3RhcmdldC5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHNvdXJjZU9mZnNldCA8IDAgfHwgc291cmNlTGltaXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzb3VyY2UgcmFuZ2U6IDAgPD0gXCIrc291cmNlT2Zmc2V0K1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gc291cmNlTGltaXQgLSBzb3VyY2VPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDsgLy8gTm90aGluZyB0byBjb3B5XHJcblxyXG4gICAgICAgIHRhcmdldC5lbnN1cmVDYXBhY2l0eSh0YXJnZXRPZmZzZXQgKyBsZW4pO1xyXG5cclxuICAgICAgICB0YXJnZXQudmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KHNvdXJjZU9mZnNldCwgc291cmNlTGltaXQpLCB0YXJnZXRPZmZzZXQpO1xyXG5cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICBpZiAodGFyZ2V0UmVsYXRpdmUpIHRhcmdldC5vZmZzZXQgKz0gbGVuO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBzdXJlIHRoYXQgdGhpcyBCeXRlQnVmZmVyIGlzIGJhY2tlZCBieSBhIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn0gb2YgYXQgbGVhc3QgdGhlIHNwZWNpZmllZCBjYXBhY2l0eS4gSWYgdGhlXHJcbiAgICAgKiAgY3VycmVudCBjYXBhY2l0eSBpcyBleGNlZWRlZCwgaXQgd2lsbCBiZSBkb3VibGVkLiBJZiBkb3VibGUgdGhlIGN1cnJlbnQgY2FwYWNpdHkgaXMgbGVzcyB0aGFuIHRoZSByZXF1aXJlZCBjYXBhY2l0eSxcclxuICAgICAqICB0aGUgcmVxdWlyZWQgY2FwYWNpdHkgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHkgUmVxdWlyZWQgY2FwYWNpdHlcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBjYXBhY2l0eSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKChjdXJyZW50ICo9IDIpID4gY2FwYWNpdHkgPyBjdXJyZW50IDogY2FwYWNpdHkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJ3cml0ZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIEJ5dGUgdmFsdWUgdG8gZmlsbCB3aXRoLiBJZiBnaXZlbiBhcyBhIHN0cmluZywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyB1c2VkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBFbmQgb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIGBzb21lQnl0ZUJ1ZmZlci5jbGVhcigpLmZpbGwoMClgIGZpbGxzIHRoZSBlbnRpcmUgYmFja2luZyBidWZmZXIgd2l0aCB6ZXJvZXNcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID49IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gZmlsbFxyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkgdGhpcy52aWV3W2JlZ2luKytdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCA9IGJlZ2luO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoaXMgQnl0ZUJ1ZmZlciByZWFkeSBmb3IgYSBuZXcgc2VxdWVuY2Ugb2Ygd3JpdGUgb3IgcmVsYXRpdmUgcmVhZCBvcGVyYXRpb25zLiBTZXRzIGBsaW1pdCA9IG9mZnNldGAgYW5kXHJcbiAgICAgKiAgYG9mZnNldCA9IDBgLiBNYWtlIHN1cmUgYWx3YXlzIHRvIGZsaXAgYSBCeXRlQnVmZmVyIHdoZW4gYWxsIHJlbGF0aXZlIHJlYWQgb3Igd3JpdGUgb3BlcmF0aW9ucyBhcmUgY29tcGxldGUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1hcmtzIGFuIG9mZnNldCBvbiB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgdXNlZCBsYXRlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBtYXJrLiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3Jlc2V0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIG9mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5vZmZzZXQgOiBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJ5dGUgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBgdHJ1ZWAgZm9yIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgYGZhbHNlYCBmb3IgYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGl0dGxlRW5kaWFuOiBOb3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzICh0bykgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHVzZXMgYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuTEUgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gISFsaXR0bGVFbmRpYW4gOiB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzICh0bykgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYmlnRW5kaWFuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHVzZXMgbGl0dGxlIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuQkUgPSBmdW5jdGlvbihiaWdFbmRpYW4pIHtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBiaWdFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gIWJpZ0VuZGlhbiA6IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUHJlcGVuZHMgc29tZSBkYXRhIHRvIHRoaXMgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZVxyXG4gICAgICogIHByZXBlbmRlZCBkYXRhJ3MgbGVuZ3RoLiBJZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBgb2Zmc2V0YCwgdGhlIGJhY2tpbmcgYnVmZmVyXHJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfHN0cmluZ3whQXJyYXlCdWZmZXJ9IHNvdXJjZSBEYXRhIHRvIHByZXBlbmQuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldCB3aWxsIGJlXHJcbiAgICAgKiAgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcHJlcGVuZCBhdC4gV2lsbCB1c2UgYW5kIGRlY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHByZXBlbmRlZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBBIHJlbGF0aXZlIGAwMDwwMSAwMiAwMz4ucHJlcGVuZCg8MDQgMDU+KWAgcmVzdWx0cyBpbiBgPDA0IDA1IDAxIDAyIDAzPiwgMDQgMDV8YFxyXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDAwPDAxIDAyIDAzPi5wcmVwZW5kKDwwNCAwNT4sIDIpYCByZXN1bHRzIGluIGAwNDwwNSAwMiAwMz4sIDA0IDA1fGBcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBCeXRlQnVmZmVyLndyYXAoc291cmNlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbiA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBwcmVwZW5kXHJcbiAgICAgICAgdmFyIGRpZmYgPSBsZW4gLSBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7IC8vIE5vdCBlbm91Z2ggc3BhY2UgYmVmb3JlIG9mZnNldCwgc28gcmVzaXplICsgbW92ZVxyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggKyBkaWZmKTtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkob2Zmc2V0LCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSwgbGVuKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB0aGlzLm1hcmtlZE9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLmxpbWl0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheVZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlldy5zZXQoc291cmNlLnZpZXcuc3ViYXJyYXkoc291cmNlLm9mZnNldCwgc291cmNlLmxpbWl0KSwgb2Zmc2V0IC0gbGVuKTtcclxuXHJcbiAgICAgICAgc291cmNlLm9mZnNldCA9IHNvdXJjZS5saW1pdDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpXHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWZvcmUgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlXHJcbiAgICAgKiAgcHJlcGVuZGVkIGRhdGEncyBsZW5ndGguIElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGBvZmZzZXRgLCB0aGUgYmFja2luZyBidWZmZXJcclxuICAgICAqICB3aWxsIGJlIHJlc2l6ZWQgYW5kIGl0cyBjb250ZW50cyBtb3ZlZCBhY2NvcmRpbmdseS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IHRhcmdldCBUYXJnZXQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBwcmVwZW5kZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3ByZXBlbmRcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHRhcmdldC5wcmVwZW5kKHRoaXMsIG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmludHMgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk9fSBvdXQgT3V0cHV0IGZ1bmN0aW9uIHRvIGNhbGwsIGRlZmF1bHRzIHRvIGNvbnNvbGUubG9nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJpbnREZWJ1ZyA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0ICE9PSAnZnVuY3Rpb24nKSBvdXQgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xyXG4gICAgICAgIG91dChcclxuICAgICAgICAgICAgdGhpcy50b1N0cmluZygpK1wiXFxuXCIrXHJcbiAgICAgICAgICAgIFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiK1xyXG4gICAgICAgICAgICB0aGlzLnRvRGVidWcoLyogY29sdW1ucyAqLyB0cnVlKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyByZWFkYWJsZSBieXRlcy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LCBzbyB0aGlzIHJldHVybnMgYGxpbWl0IC0gb2Zmc2V0YC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJlbWFpbmluZyByZWFkYWJsZSBieXRlcy4gTWF5IGJlIG5lZ2F0aXZlIGlmIGBvZmZzZXQgPiBsaW1pdGAuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVtYWluaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQgLSB0aGlzLm9mZnNldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGlzIEJ5dGVCdWZmZXIncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LiBJZiBhbiBvZmZzZXQgaGFzIGJlZW4gbWFya2VkIHRocm91Z2gge0BsaW5rIEJ5dGVCdWZmZXIjbWFya31cclxuICAgICAqICBiZWZvcmUsIGBvZmZzZXRgIHdpbGwgYmUgc2V0IHRvIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0sIHdoaWNoIHdpbGwgdGhlbiBiZSBkaXNjYXJkZWQuIElmIG5vIG9mZnNldCBoYXMgYmVlblxyXG4gICAgICogIG1hcmtlZCwgc2V0cyBgb2Zmc2V0ID0gMGAuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMubWFya2VkT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBiZSBiYWNrZWQgYnkgYSBidWZmZXIgb2YgYXQgbGVhc3QgdGhlIGdpdmVuIGNhcGFjaXR5LiBXaWxsIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSB0aGF0XHJcbiAgICAgKiAgbGFyZ2Ugb3IgbGFyZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IENhcGFjaXR5IHJlcXVpcmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYGNhcGFjaXR5YCBpcyBub3QgYSBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBjYXBhY2l0eSA8IDBgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXBhY2l0eSAhPT0gJ251bWJlcicgfHwgY2FwYWNpdHkgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IFwiK2NhcGFjaXR5K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBjYXBhY2l0eSB8PSAwO1xuICAgICAgICAgICAgaWYgKGNhcGFjaXR5IDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2NhcGFjaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPCBjYXBhY2l0eSkge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZlcnNlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIHN0YXJ0IGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byByZXZlcnNlXHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCh0aGlzLnZpZXcuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgdGhlIG5leHQgYGxlbmd0aGAgYnl0ZXMuIFRoaXMgd2lsbCBqdXN0IGFkdmFuY2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuIE1heSBhbHNvIGJlIG5lZ2F0aXZlIHRvIG1vdmUgdGhlIG9mZnNldCBiYWNrLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrbGVuZ3RoK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBsZW5ndGggfD0gMDtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIGxlbmd0aDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogMCA8PSBcIit0aGlzLm9mZnNldCtcIiArIFwiK2xlbmd0aCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2xpY2VzIHRoaXMgQnl0ZUJ1ZmZlciBieSBjcmVhdGluZyBhIGNsb25lZCBpbnN0YW5jZSB3aXRoIGBvZmZzZXQgPSBiZWdpbmAgYW5kIGBsaW1pdCA9IGVuZGAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIEJlZ2luIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ2xvbmUgb2YgdGhpcyBCeXRlQnVmZmVyIHdpdGggc2xpY2luZyBhcHBsaWVkLCBiYWNrZWQgYnkgdGhlIHNhbWUge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmIgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gYmVnaW47XHJcbiAgICAgICAgYmIubGltaXQgPSBlbmQ7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGJhY2tpbmcgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlblxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlQ29weSBJZiBgdHJ1ZWAgcmV0dXJucyBhIGNvcHksIG90aGVyd2lzZSByZXR1cm5zIGEgdmlldyByZWZlcmVuY2luZyB0aGUgc2FtZSBtZW1vcnkgaWZcclxuICAgICAqICBwb3NzaWJsZS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFBcnJheUJ1ZmZlcn0gQ29udGVudHMgYXMgYW4gQXJyYXlCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKGZvcmNlQ29weSkge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCxcclxuICAgICAgICAgICAgbGltaXQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgbGltaXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGltaXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgbGltaXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gbGltaXQgfHwgbGltaXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK29mZnNldCtcIiA8PSBcIitsaW1pdCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5PVEU6IEl0J3Mgbm90IHBvc3NpYmxlIHRvIGhhdmUgYW5vdGhlciBBcnJheUJ1ZmZlciByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5IGFzIHRoZSBiYWNraW5nIGJ1ZmZlci4gVGhpcyBpc1xyXG4gICAgICAgIC8vIHBvc3NpYmxlIHdpdGggVWludDhBcnJheSNzdWJhcnJheSBvbmx5LCBidXQgd2UgaGF2ZSB0byByZXR1cm4gYW4gQXJyYXlCdWZmZXIgYnkgY29udHJhY3QuIFNvOlxyXG4gICAgICAgIGlmICghZm9yY2VDb3B5ICYmIG9mZnNldCA9PT0gMCAmJiBsaW1pdCA9PT0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxpbWl0KVxyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGltaXQgLSBvZmZzZXQpO1xyXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKS5zdWJhcnJheShvZmZzZXQsIGxpbWl0KSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmF3IGJ1ZmZlciBjb21wYWN0ZWQgdG8gY29udGFpbiB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3RvQnVmZmVyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VDb3B5IElmIGB0cnVlYCByZXR1cm5zIGEgY29weSwgb3RoZXJ3aXNlIHJldHVybnMgYSB2aWV3IHJlZmVyZW5jaW5nIHRoZSBzYW1lIG1lbW9yeS5cclxuICAgICAqICBEZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5QnVmZmVyfSBDb250ZW50cyBhcyBhbiBBcnJheUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jb2RpbmcgT3V0cHV0IGVuY29kaW5nLiBSZXR1cm5zIGFuIGluZm9ybWF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiBvbWl0dGVkIGJ1dCBhbHNvIGFsbG93c1xyXG4gICAgICogIGRpcmVjdCBjb252ZXJzaW9uIHRvIFwidXRmOFwiLCBcImhleFwiLCBcImJhc2U2NFwiIGFuZCBcImJpbmFyeVwiIGVuY29kaW5nLiBcImRlYnVnXCIgcmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiB3aXRoXHJcbiAgICAgKiAgaGlnaGxpZ2h0ZWQgb2Zmc2V0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGBlbmNvZGluZ2AgaXMgaW52YWxpZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgcmV0dXJuIFwiQnl0ZUJ1ZmZlckFCKG9mZnNldD1cIit0aGlzLm9mZnNldCtcIixtYXJrZWRPZmZzZXQ9XCIrdGhpcy5tYXJrZWRPZmZzZXQrXCIsbGltaXQ9XCIrdGhpcy5saW1pdCtcIixjYXBhY2l0eT1cIit0aGlzLmNhcGFjaXR5KCkrXCIpXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCIsXHJcbiAgICAgICAgICAgIGJlZ2luID0gZW5jb2RpbmcsXHJcbiAgICAgICAgICAgIGVuZCA9IGJlZ2luO1xyXG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVVRGOChiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CYXNlNjQoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0JpbmFyeShiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RlYnVnKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5zXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbHVtbnMoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK2VuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGx4aXYtZW1iZWRkYWJsZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogbHhpdi1lbWJlZGRhYmxlIChjKSAyMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAgICAgKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2x4aXYgZm9yIGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgdmFyIGx4aXYgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbHhpdiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKiBAZXhwb3J0cyBseGl2XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGx4aXYgPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhcmFjdGVyIGNvZGVzIGZvciBvdXRwdXQuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYW91dCA9IFtcclxuICAgICAgICAgICAgNjUsIDY2LCA2NywgNjgsIDY5LCA3MCwgNzEsIDcyLCA3MywgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsXHJcbiAgICAgICAgICAgIDgxLCA4MiwgODMsIDg0LCA4NSwgODYsIDg3LCA4OCwgODksIDkwLCA5NywgOTgsIDk5LCAxMDAsIDEwMSwgMTAyLFxyXG4gICAgICAgICAgICAxMDMsIDEwNCwgMTA1LCAxMDYsIDEwNywgMTA4LCAxMDksIDExMCwgMTExLCAxMTIsIDExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsXHJcbiAgICAgICAgICAgIDExOSwgMTIwLCAxMjEsIDEyMiwgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDQzLCA0N1xyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYXJhY3RlciBjb2RlcyBmb3IgaW5wdXQuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBrPWFvdXQubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgYWluW2FvdXRbaV1dID0gaTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBieXRlcyB0byBiYXNlNjQgY2hhciBjb2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZlxyXG4gICAgICAgICAqICB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggZW5jb2RlZCBjaGFyXHJcbiAgICAgICAgICogIGNvZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi5lbmNvZGUgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYiwgdDtcclxuICAgICAgICAgICAgd2hpbGUgKChiID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkc3QoYW91dFsoYj4+MikmMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiJjB4Myk8PDQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGIgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0IHw9IChiPj40KSYweGY7XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbKHR8KChiPj40KSYweGYpKSYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IChiJjB4Zik8PDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiID0gc3JjKCkpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFsodHwoKGI+PjYpJjB4MykpJjB4M2ZdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbYiYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFt0JjB4M2ZdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KDYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W3QmMHgzZl0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCg2MSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KDYxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYmFzZTY0IGNoYXIgY29kZXMgdG8gYnl0ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQnl0ZXMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBpbnZhbGlkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi5kZWNvZGUgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYywgdDEsIHQyO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKGMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBjaGFyYWN0ZXIgY29kZTogXCIrYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0MSA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDEgPT09ICd1bmRlZmluZWQnKSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdDIgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MiA9PT0gJ3VuZGVmaW5lZCcpIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCh0MTw8Mik+Pj4wfCh0MiYweDMwKT4+NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQxID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSA2MSkgYnJlYWs7IGVsc2UgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KCgodDImMHhmKTw8NCk+Pj4wfCh0MSYweDNjKT4+Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQyID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gNjEpIGJyZWFrOyBlbHNlIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3QoKCh0MSYweDMpPDw2KT4+PjB8dDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBzdHJpbmcgaXMgdmFsaWQgYmFzZTY0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRlc3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHZhbGlkLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx4aXYudGVzdCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gbHhpdjtcclxuICAgIH0oKTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvYmFzZTY0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gYmVnaW4gYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBiZWdpbmAgb3IgYGVuZGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQmFzZTY0ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBiZWdpbiA9IGJlZ2luIHwgMDsgZW5kID0gZW5kIHwgMDtcclxuICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGVuZCA+IHRoaXMuY2FwYWNpdHkgfHwgYmVnaW4gPiBlbmQpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO1xyXG4gICAgICAgIHZhciBzZDsgbHhpdi5lbmNvZGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZWdpbiA8IGVuZCA/IHRoaXMudmlld1tiZWdpbisrXSA6IG51bGw7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCkpO1xyXG4gICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tQmFzZTY0ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcInN0clwiKTtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihzdHIubGVuZ3RoLzQqMywgbGl0dGxlRW5kaWFuKSxcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgbHhpdi5kZWNvZGUoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgYmIudmlld1tpKytdID0gYjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYi5saW1pdCA9IGk7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgYSBiaW5hcnkgc3RyaW5nIHRvIGJhc2U2NCBsaWtlIGB3aW5kb3cuYnRvYWAgZG9lcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQmluYXJ5IHN0cmluZ1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuYnRvYVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmJ0b2EgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KHN0cikudG9CYXNlNjQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGJpbmFyeSBsaWtlIGB3aW5kb3cuYXRvYmAgZG9lcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiNjQgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCaW5hcnkgc3RyaW5nXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuYXRvYlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmF0b2IgPSBmdW5jdGlvbihiNjQpIHtcclxuICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmFzZTY0KGI2NCkudG9CaW5hcnkoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2JpbmFyeVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcsIHRoYXQgaXMgdXNpbmcgb25seSBjaGFyYWN0ZXJzIDB4MDAtMHhGRiBhcyBieXRlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmluYXJ5IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0ID4gbGltaXRgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CaW5hcnkgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGJlZ2luIHw9IDA7IGVuZCB8PSAwO1xyXG4gICAgICAgIGlmIChiZWdpbiA8IDAgfHwgZW5kID4gdGhpcy5jYXBhY2l0eSgpIHx8IGJlZ2luID4gZW5kKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiYmVnaW4sIGVuZFwiKTtcclxuICAgICAgICBpZiAoYmVnaW4gPT09IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gW10sXHJcbiAgICAgICAgICAgIHBhcnRzID0gW107XHJcbiAgICAgICAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIGNoYXJzLnB1c2godGhpcy52aWV3W2JlZ2luKytdKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA+PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2hhcnMpKSxcclxuICAgICAgICAgICAgICAgIGNoYXJzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKSArIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaGFycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZywgdGhhdCBpcyB1c2luZyBvbmx5IGNoYXJhY3RlcnMgMHgwMC0weEZGIGFzIGJ5dGVzLCB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21CaW5hcnkgPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO1xyXG4gICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgayA9IHN0ci5sZW5ndGgsXHJcbiAgICAgICAgICAgIGNoYXJDb2RlLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKGssIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPiAweGZmKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcImlsbGVnYWwgY2hhciBjb2RlOiBcIitjaGFyQ29kZSk7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGNoYXJDb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5saW1pdCA9IGs7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvZGVidWdcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nIHdpdGggbWFya2VkIG9mZnNldHMuIE9mZnNldCBzeW1ib2xzIGFyZTpcclxuICAgICAqICogYDxgIDogb2Zmc2V0LFxyXG4gICAgICogKiBgJ2AgOiBtYXJrZWRPZmZzZXQsXHJcbiAgICAgKiAqIGA+YCA6IGxpbWl0LFxyXG4gICAgICogKiBgfGAgOiBvZmZzZXQgYW5kIGxpbWl0LFxyXG4gICAgICogKiBgW2AgOiBvZmZzZXQgYW5kIG1hcmtlZE9mZnNldCxcclxuICAgICAqICogYF1gIDogbWFya2VkT2Zmc2V0IGFuZCBsaW1pdCxcclxuICAgICAqICogYCFgIDogb2Zmc2V0LCBtYXJrZWRPZmZzZXQgYW5kIGxpbWl0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb2x1bW5zIElmIGB0cnVlYCByZXR1cm5zIHR3byBjb2x1bW5zIGhleCArIGFzY2lpLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCFBcnJheS48c3RyaW5nPn0gRGVidWcgc3RyaW5nIG9yIGFycmF5IG9mIGxpbmVzIGlmIGBhc0FycmF5ID0gdHJ1ZWBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIGA+MDAnMDEgMDI8MDNgIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgbGltaXQ9MCwgbWFya2VkT2Zmc2V0PTEsIG9mZnNldD0zYFxyXG4gICAgICogQGV4YW1wbGUgYDAwWzAxIDAyIDAzPmAgY29udGFpbnMgZm91ciBieXRlcyB3aXRoIGBvZmZzZXQ9bWFya2VkT2Zmc2V0PTEsIGxpbWl0PTRgXHJcbiAgICAgKiBAZXhhbXBsZSBgMDB8MDEgMDIgMDNgIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgb2Zmc2V0PWxpbWl0PTEsIG1hcmtlZE9mZnNldD0tMWBcclxuICAgICAqIEBleGFtcGxlIGB8YCBjb250YWlucyB6ZXJvIGJ5dGVzIHdpdGggYG9mZnNldD1saW1pdD0wLCBtYXJrZWRPZmZzZXQ9LTFgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9EZWJ1ZyA9IGZ1bmN0aW9uKGNvbHVtbnMpIHtcclxuICAgICAgICB2YXIgaSA9IC0xLFxyXG4gICAgICAgICAgICBrID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgYixcclxuICAgICAgICAgICAgaGV4ID0gXCJcIixcclxuICAgICAgICAgICAgYXNjID0gXCJcIixcclxuICAgICAgICAgICAgb3V0ID0gXCJcIjtcclxuICAgICAgICB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IHRoaXMudmlld1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChiIDwgMHgxMCkgaGV4ICs9IFwiMFwiK2IudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGhleCArPSBiLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgYXNjICs9IGIgPiAzMiAmJiBiIDwgMTI3ID8gU3RyaW5nLmZyb21DaGFyQ29kZShiKSA6ICcuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgaSAlIDE2ID09PSAwICYmIGkgIT09IGspIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDMqMTYrMykgaGV4ICs9IFwiIFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBoZXgrYXNjK1wiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gYXNjID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5vZmZzZXQgJiYgaSA9PT0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiIVwiIDogXCJ8XCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IHRoaXMub2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IGkgPT09IHRoaXMubWFya2VkT2Zmc2V0ID8gXCJbXCIgOiBcIjxcIjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiXVwiIDogXCI+XCI7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiJ1wiIDogKGNvbHVtbnMgfHwgKGkgIT09IDAgJiYgaSAhPT0gaykgPyBcIiBcIiA6IFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sdW1ucyAmJiBoZXggIT09IFwiIFwiKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMyoxNiszKVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiIFwiO1xyXG4gICAgICAgICAgICBvdXQgKz0gaGV4ICsgYXNjICsgXCJcXG5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMgPyBvdXQgOiBoZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHN0cmluZyB3aXRoIG1hcmtlZCBvZmZzZXRzIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgRGVidWcgc3RyaW5nIHRvIGRlY29kZSAobm90IGJlIGdlbmVyYXRlZCB3aXRoIGBjb2x1bW5zID0gdHJ1ZWApXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN0b0RlYnVnXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbURlYnVnID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgdmFyIGsgPSBzdHIubGVuZ3RoLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKCgoaysxKS8zKXwwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICB2YXIgaSA9IDAsIGogPSAwLCBjaCwgYixcclxuICAgICAgICAgICAgcnMgPSBmYWxzZSwgLy8gUmVxdWlyZSBzeW1ib2wgbmV4dFxyXG4gICAgICAgICAgICBobyA9IGZhbHNlLCBobSA9IGZhbHNlLCBobCA9IGZhbHNlLCAvLyBBbHJlYWR5IGhhcyBvZmZzZXQgKGhvKSwgbWFya2VkT2Zmc2V0IChobSksIGxpbWl0IChobCk/XHJcbiAgICAgICAgICAgIGZhaWwgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY2ggPSBzdHIuY2hhckF0KGkrKykpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtIHx8IGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaG0gPSBobCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLm1hcmtlZE9mZnNldCA9IGJiLmxpbWl0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnfCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG8gfHwgaGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSBobCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLmxpbWl0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG8gfHwgaG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSBobSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLm1hcmtlZE9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnXSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGwgfHwgaG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGwgPSBobSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYmIubWFya2VkT2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCInXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5tYXJrZWRPZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiID0gcGFyc2VJbnQoY2grc3RyLmNoYXJBdChpKyspLCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYikgfHwgYiA8IDAgfHwgYiA+IDI1NSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIudmlld1tqKytdID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZhaWwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogSW52YWxpZCBzeW1ib2wgYXQgXCIraSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKCFobyB8fCAhaGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTWlzc2luZyBvZmZzZXQgb3IgbGltaXRcIik7XHJcbiAgICAgICAgICAgIGlmIChqPGJiLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIGRlYnVnIGVuY29kZWQgc3RyaW5nIChpcyBpdCBoZXg/KSBcIitqK1wiIDwgXCIrayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2hleFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgYmVnaW4gPSB0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5vZmZzZXQgOiBiZWdpbjtcclxuICAgICAgICBlbmQgPSB0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJyA/IHRoaXMubGltaXQgOiBlbmQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheShlbmQgLSBiZWdpbiksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbYmVnaW4rK107XHJcbiAgICAgICAgICAgIGlmIChiIDwgMHgxMClcclxuICAgICAgICAgICAgICAgIG91dC5wdXNoKFwiMFwiLCBiLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgICAgIGVsc2Ugb3V0LnB1c2goYi50b1N0cmluZygxNikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tSGV4ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgIT09IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTGVuZ3RoIG5vdCBhIG11bHRpcGxlIG9mIDJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrID0gc3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigoayAvIDIpIHwgMCwgbGl0dGxlRW5kaWFuKSxcclxuICAgICAgICAgICAgYjtcclxuICAgICAgICBmb3IgKHZhciBpPTAsIGo9MDsgaTxrOyBpKz0yKSB7XHJcbiAgICAgICAgICAgIGIgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkrMiksIDE2KTtcclxuICAgICAgICAgICAgaWYgKCFub0Fzc2VydClcclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoYikgfHwgYiA8IDAgfHwgYiA+IDI1NSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgbm9uLWhleCBjaGFyYWN0ZXJzXCIpO1xyXG4gICAgICAgICAgICBiYi52aWV3W2orK10gPSBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB1dGZ4LWVtYmVkZGFibGVcclxuXHJcbiAgICAvKipcclxuICAgICAqIHV0ZngtZW1iZWRkYWJsZSAoYykgMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gICAgICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy91dGZ4IGZvciBkZXRhaWxzXHJcbiAgICAgKi9cclxuICAgIHZhciB1dGZ4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHV0ZnggbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHV0ZnggPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWF4aW11bSB2YWxpZCBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5NQVhfQ09ERVBPSU5UID0gMHgxMEZGRkY7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgVVRGOCBjb2RlIHBvaW50cyB0byBVVEY4IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKSB8IG51bWJlcn0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSwgZWl0aGVyIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnRcclxuICAgICAgICAgKiAgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0IG9yIGEgc2luZ2xlIG51bWVyaWMgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQnl0ZXMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIGNwID0gc3JjLFxyXG4gICAgICAgICAgICAgICAgc3JjID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3AgPCAweDgwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChjcCYweDdGKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNwIDwgMHg4MDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4MUYpfDB4QzApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjcCA8IDB4MTAwMDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjEyKSYweDBGKXwweEUwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+NikmMHgzRil8MHg4MCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+MTgpJjB4MDcpfDB4RjApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgzRil8MHg4MCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4M0YpfDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIFVURjggYnl0ZXMgdG8gVVRGOCBjb2RlIHBvaW50cy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZVxyXG4gICAgICAgICAqICBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDb2RlIHBvaW50cyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGRlY29kZWQgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIHN0YXJ0aW5nIGJ5dGUgaXMgaW52YWxpZCBpbiBVVEY4XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXN0IHNlcXVlbmNlIGlzIHRydW5jYXRlZC4gSGFzIGFuIGFycmF5IHByb3BlcnR5IGBieXRlc2AgaG9sZGluZyB0aGVcclxuICAgICAgICAgKiAgcmVtYWluaW5nIGJ5dGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZGVjb2RlVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkLCBmYWlsID0gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuc2xpY2UoMCwgYi5pbmRleE9mKG51bGwpKTtcclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihiLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIlRydW5jYXRlZEVycm9yXCI7XHJcbiAgICAgICAgICAgICAgICBlcnJbJ2J5dGVzJ10gPSBiO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoKGEgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYSYweDgwKSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoYSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEUwKSA9PT0gMHhDMClcclxuICAgICAgICAgICAgICAgICAgICAoKGIgPSBzcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGJdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChhJjB4MUYpPDw2KSB8IChiJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChhJjB4RjApID09PSAweEUwKVxyXG4gICAgICAgICAgICAgICAgICAgICgoYj1zcmMoKSkgPT09IG51bGwgfHwgKGM9c3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiLCBjXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoYSYweDBGKTw8MTIpIHwgKChiJjB4M0YpPDw2KSB8IChjJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChhJjB4RjgpID09PSAweEYwKVxyXG4gICAgICAgICAgICAgICAgICAgICgoYj1zcmMoKSkgPT09IG51bGwgfHwgKGM9c3JjKCkpID09PSBudWxsIHx8IChkPXNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYiwgYyAsZF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGEmMHgwNyk8PDE4KSB8ICgoYiYweDNGKTw8MTIpIHwgKChjJjB4M0YpPDw2KSB8IChkJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RhcnRpbmcgYnl0ZTogXCIrYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBVVEYxNiBjaGFyYWN0ZXJzIHRvIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ29kZSBwb2ludHMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBjb252ZXJ0ZWQgY29kZVxyXG4gICAgICAgICAqICBwb2ludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LlVURjE2dG9VVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGMxLCBjMiA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMxID0gYzIgIT09IG51bGwgPyBjMiA6IHNyYygpKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGlmIChjMSA+PSAweEQ4MDAgJiYgYzEgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjMiA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYzIgPj0gMHhEQzAwICYmIGMyIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0KChjMS0weEQ4MDApKjB4NDAwK2MyLTB4REMwMCsweDEwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyID0gbnVsbDsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkc3QoYzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gbnVsbCkgZHN0KGMyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBVVEY4IGNvZGUgcG9pbnRzIHRvIFVURjE2IGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpIHwgbnVtYmVyfSBzcmMgQ29kZSBwb2ludHMgc291cmNlLCBlaXRoZXIgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludFxyXG4gICAgICAgICAqICByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvZGUgcG9pbnRzIGxlZnQgb3IgYSBzaW5nbGUgbnVtZXJpYyBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIGNvZGUgcG9pbnQgaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5VVEY4dG9VVEYxNiA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIGNwID0gc3JjLCBzcmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgICAgIHdoaWxlIChjcCAhPT0gbnVsbCB8fCAoY3AgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjcCA8PSAweEZGRkYpXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGNwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjcCAtPSAweDEwMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3A+PjEwKSsweEQ4MDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AlMHg0MDApKzB4REMwMCk7XHJcbiAgICAgICAgICAgICAgICBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhbmQgZW5jb2RlcyBVVEYxNiBjaGFyYWN0ZXJzIHRvIFVURjggYnl0ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHkgYG51bGxgXHJcbiAgICAgICAgICogIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQnl0ZXMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdXRmeC5VVEYxNnRvVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICB1dGZ4LmVuY29kZVVURjgoY3AsIGRzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYW5kIGNvbnZlcnRzIFVURjggYnl0ZXMgdG8gVVRGMTYgY2hhcmFjdGVycy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZVxyXG4gICAgICAgICAqICBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIHN0YXJ0aW5nIGJ5dGUgaXMgaW52YWxpZCBpbiBVVEY4XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXN0IHNlcXVlbmNlIGlzIHRydW5jYXRlZC4gSGFzIGFuIGFycmF5IHByb3BlcnR5IGBieXRlc2AgaG9sZGluZyB0aGUgcmVtYWluaW5nIGJ5dGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjgoc3JjLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgdXRmeC5VVEY4dG9VVEYxNihjcCwgZHN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gVVRGOCBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcCBVVEY4IGNvZGUgcG9pbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlQ29kZVBvaW50ID0gZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIChjcCA8IDB4ODApID8gMSA6IChjcCA8IDB4ODAwKSA/IDIgOiAoY3AgPCAweDEwMDAwKSA/IDMgOiA0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpfSBzcmMgQ29kZSBwb2ludHMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnQgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlVVRGOCA9IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICAgICAgICB2YXIgY3AsIGw9MDtcclxuICAgICAgICAgICAgd2hpbGUgKChjcCA9IHNyYygpKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGwgKz0gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XHJcbiAgICAgICAgICAgIHJldHVybiBsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGNvZGUgcG9pbnRzIHJlc3BlY3RpdmVseSBVVEY4IGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIFVURjE2IGNoYXIgY29kZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IFRoZSBudW1iZXIgb2YgVVRGOCBjb2RlIHBvaW50cyBhdCBpbmRleCAwIGFuZCB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWQgYXQgaW5kZXggMS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4ID0gZnVuY3Rpb24oc3JjKSB7XHJcbiAgICAgICAgICAgIHZhciBuPTAsIGw9MDtcclxuICAgICAgICAgICAgdXRmeC5VVEYxNnRvVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICArK247IGwgKz0gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gW24sbF07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHV0Zng7XHJcbiAgICB9KCk7XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL3V0ZjhcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gYW4gVVRGOCBlbmNvZGVkXHJcbiAgICAgKiAgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0ID4gbGltaXRgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9VVEY4ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2Q7IHRyeSB7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVnaW4gPCBlbmQgPyB0aGlzLnZpZXdbYmVnaW4rK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoYmVnaW4gIT09IGVuZClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYmVnaW4rXCIgIT0gXCIrZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbVVURjggPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRydWUpWzFdLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSxcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gaTtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBCeXRlQnVmZmVyO1xyXG59KTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYnl0ZWJ1ZmZlci9kaXN0L2J5dGVidWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBsb25nLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9sb25nLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG4gICAgLyogQ29tbW9uSlMgKi8gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeSgpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiTG9uZ1wiXSA9IGZhY3RvcnkoKTtcclxuXHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAgICAgKiBAZXhwb3J0cyBMb25nXHJcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbiAgICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4gICAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbiAgICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbiAgICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4gICAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbiAgICAvL1xyXG4gICAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4gICAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbiAgICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuICAgIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuICAgIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuICAgIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIC8vXHJcbiAgICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuICAgIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gICAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwpIHtcclxuICAgICAgICBpZiAodmFsIC8qIGlzIGNvbXBhdGlibGUgKi8gaW5zdGFuY2VvZiBMb25nKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCk7XHJcbiAgICAgICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHZhbC51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4gICAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25lZCBvbmUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuT05FID0gT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgICAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgICAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAgICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICAgICAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICAgICAgcmVzID0gWkVSTztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24obGUpIHtcclxuICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICBsbyAgICAgICAgICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgIGhpICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAyNCkgJiAweGZmXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgICBoaSAgICAgICAgICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAyNCkgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgIGxvICAgICAgICAgJiAweGZmXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTG9uZztcclxufSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvbmcvZGlzdC9sb25nLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGZzIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDIyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBwYXRoIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXY+PC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9Tb2NrZXRJb01hbmFnZXIudnVlXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HY3NFZGl0TWlzc2lvbk1vZGFsLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtaXNzaW9uXFxcXEdjc0VkaXRNaXNzaW9uTW9kYWwudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR2NzRWRpdE1pc3Npb25Nb2RhbC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0zZmUxZWU2Mi9HY3NFZGl0TWlzc2lvbk1vZGFsLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzRWRpdE1pc3Npb25Nb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAyMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZT5cclxuICAgIDx1aS1tb2RhbCA6c2hvdy5zeW5jPVwic2hvd1wiIGNsYXNzPVwiZ2NzLWVkaXQtbWlzc2lvbi1tb2RhbFwiIGhlYWRlcj1cIkVkaXQgbWlzc2lvblwiIEBvcGVuZWQ9XCJvcGVuZWRcIj5cclxuICAgICAgICA8dWktdGV4dGJveFxyXG4gICAgICAgICAgICBsYWJlbD1cIk1pc3Npb24gdGl0bGVcIiBuYW1lPVwibWlzc2lvbl90aXRsZVwiIDp2YWx1ZS5zeW5jPVwibWlzc2lvblRpdGxlXCJcclxuICAgICAgICAgICAgdmFsaWRhdGlvbi1ydWxlcz1cInJlcXVpcmVkXCIgdi1lbDppbnB1dFxyXG4gICAgICAgID48L3VpLXRleHRib3g+XHJcblxyXG4gICAgICAgIDxkaXYgc2xvdD1cImZvb3RlclwiPlxyXG4gICAgICAgICAgICA8dWktYnV0dG9uIGNvbG9yPVwicHJpbWFyeVwiIEBjbGljaz1cInNhdmVcIj5TYXZlPC91aS1idXR0b24+XHJcbiAgICAgICAgICAgIDx1aS1idXR0b24gQGNsaWNrPVwic2hvdyA9IGZhbHNlXCI+Q2FuY2VsPC91aS1idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L3VpLW1vZGFsPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgZ2V0TWlzc2lvbnMsIGdldEN1cnJlbnRNaXNzaW9uSW5kZXggfSBmcm9tICdzdG9yZS9nZXR0ZXJzJztcclxuaW1wb3J0IHsgc2V0Q3VycmVudE1pc3Npb25UaXRsZSB9IGZyb20gJ3N0b3JlL2FjdGlvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdnVleDoge1xyXG4gICAgICAgIGdldHRlcnM6IHtcclxuICAgICAgICAgICAgbWlzc2lvbnM6IGdldE1pc3Npb25zLFxyXG4gICAgICAgICAgICBjdXJyZW50TWlzc2lvbkluZGV4OiBnZXRDdXJyZW50TWlzc2lvbkluZGV4XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWN0aW9uczoge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50TWlzc2lvblRpdGxlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIHNob3c6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHR3b1dheTogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaXNzaW9uVGl0bGU6ICcnXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBtaXNzaW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWlzc2lvbkluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taXNzaW9uc1t0aGlzLmN1cnJlbnRNaXNzaW9uSW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIG9wZW5lZCgpIHtcclxuICAgICAgICAgICAgdGhpcy5taXNzaW9uVGl0bGUgPSB0aGlzLm1pc3Npb24udGl0bGUgfHwgJyc7XHJcbiAgICAgICAgICAgIHRoaXMuJGVscy5pbnB1dC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2F2ZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlzc2lvblRpdGxlKHRoaXMubWlzc2lvblRpdGxlKTtcclxuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogR2NzRWRpdE1pc3Npb25Nb2RhbC52dWU/NTc2MGU2ZDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPHVpLW1vZGFsIDpzaG93LnN5bmM9XFxcInNob3dcXFwiIGNsYXNzPVxcXCJnY3MtZWRpdC1taXNzaW9uLW1vZGFsXFxcIiBoZWFkZXI9XFxcIkVkaXQgbWlzc2lvblxcXCIgQG9wZW5lZD1cXFwib3BlbmVkXFxcIj5cXG4gICAgPHVpLXRleHRib3hcXG4gICAgICAgIGxhYmVsPVxcXCJNaXNzaW9uIHRpdGxlXFxcIiBuYW1lPVxcXCJtaXNzaW9uX3RpdGxlXFxcIiA6dmFsdWUuc3luYz1cXFwibWlzc2lvblRpdGxlXFxcIlxcbiAgICAgICAgdmFsaWRhdGlvbi1ydWxlcz1cXFwicmVxdWlyZWRcXFwiIHYtZWw6aW5wdXRcXG4gICAgPjwvdWktdGV4dGJveD5cXG5cXG4gICAgPGRpdiBzbG90PVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgPHVpLWJ1dHRvbiBjb2xvcj1cXFwicHJpbWFyeVxcXCIgQGNsaWNrPVxcXCJzYXZlXFxcIj5TYXZlPC91aS1idXR0b24+XFxuICAgICAgICA8dWktYnV0dG9uIEBjbGljaz1cXFwic2hvdyA9IGZhbHNlXFxcIj5DYW5jZWw8L3VpLWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC91aS1tb2RhbD5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21pc3Npb24vR2NzRWRpdE1pc3Npb25Nb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAyMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBDb250cm9sbGVyIGZyb20gJ2NvbnRyb2xsZXIuanMnO1xyXG5pbXBvcnQgQ29udHJvbGxlckxheW91dHMgZnJvbSAnY29udHJvbGxlci5qcy9kaXN0L0NvbnRyb2xsZXIubGF5b3V0cy5qcyc7XHJcblxyXG5Db250cm9sbGVyLmxheW91dHMucmVnaXN0ZXIoQ29udHJvbGxlckxheW91dHMpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJvbGxlck1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmdhbWVwYWRzID0ge307XHJcbiAgICAgICAgdGhpcy5Db250cm9sbGVyID0gQ29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdGhpcy5icm9hZGNhc3QgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lcGFkRXZlbnRzID0gW1xyXG4gICAgICAgICAgICAnZ2MuYnV0dG9uLnByZXNzJyxcclxuICAgICAgICAgICAgJ2djLmJ1dHRvbi5ob2xkJyxcclxuICAgICAgICAgICAgJ2djLmJ1dHRvbi5yZWxlYXNlJyxcclxuICAgICAgICAgICAgJ2djLmFuYWxvZy5zdGFydCcsXHJcbiAgICAgICAgICAgICdnYy5hbmFsb2cuaG9sZCcsXHJcbiAgICAgICAgICAgICdnYy5hbmFsb2cuY2hhbmdlJyxcclxuICAgICAgICAgICAgJ2djLmFuYWxvZy5lbmQnXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29udHJvbGxlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0aWFsaXplQ29udHJvbGxlcnMoKSB7XHJcbiAgICAgICAgQ29udHJvbGxlci5zZWFyY2goKTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2djLmNvbnRyb2xsZXIuZm91bmQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3QoJ2djLmNvbnRyb2xsZXIuZm91bmQnLCBldmVudC5kZXRhaWwpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWVwYWRzW2V2ZW50LmRldGFpbC5jb250cm9sbGVyLmlkXSA9IGV2ZW50LmRldGFpbC5jb250cm9sbGVyO1xyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2djLmNvbnRyb2xsZXIubG9zdCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdCgnZ2MuY29udHJvbGxlci5sb3N0JywgZXZlbnQuZGV0YWlsKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2FtZXBhZHNbZXZlbnQuZGV0YWlsLmlkXTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZXBhZEV2ZW50cy5tYXAoKGV2ZW50bmFtZSkgPT4ge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudG5hbWUsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3QoZXZlbnRuYW1lLCBldmVudC5kZXRhaWwpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9jb250cm9sbGVyLW1hbmFnZXIuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMjI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2NvbnRyb2xsZXIuanMnLCBmYWN0b3J5KSA6XHJcbiAgICAoZ2xvYmFsLkNvbnRyb2xsZXIgPSBmYWN0b3J5KCkpO1xyXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xyXG5cclxuLyohIENvbnRyb2xsZXIuanMgLSB2MS4wLjAgLSAyMDE2LTA4LTMwICovXHJcbmZ1bmN0aW9uIENvbnRyb2xsZXIoSFRNTGdhbWVwYWQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGlmIChIVE1MZ2FtZXBhZC5jb25zdHJ1Y3Rvci5uYW1lICE9PSBcIkdhbWVwYWRcIikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBpZCA9IEhUTUxnYW1lcGFkLmlkO1xyXG4gICAgdmFyIGluZGV4ID0gSFRNTGdhbWVwYWQuaW5kZXg7XHJcbiAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgIHZhciBSQUYgPSBudWxsO1xyXG4gICAgdmFyIGxhc3RVcGRhdGVkID0gMDtcclxuICAgIHZhciBhbmFsb2dNYXAgPSB7fTtcclxuICAgIHZhciBldmVudFF1ZXVlID0ge307XHJcbiAgICB2YXIgbGF5b3V0SW5mbyA9IHt9O1xyXG4gICAgdmFyIGNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICB2YXIgc3RhdGUgPSB7fTtcclxuICAgIHZhciB1bmtub3duTGF5b3V0ID0gdHJ1ZTtcclxuICAgIHZhciBzZXR0aW5ncyA9IGFyZ3VtZW50c1sxXSB8fCBmYWxzZTtcclxuICAgIHZhciBnYW1lcGFkID0gSFRNTGdhbWVwYWQ7XHJcbiAgICB2YXIgX2Rpc2Nvbm5lY3RDb250cm9sbGVyID0gZGlzY29ubmVjdENvbnRyb2xsZXIuYmluZCh0aGlzKTtcclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgaWYgKCFjb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKFJBRik7XHJcbiAgICAgICAgICAgIFJBRiA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tJbnB1dHMuY2FsbCh0aGlzKTtcclxuICAgICAgICBSQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZUNvbnRyb2xsZXIuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGVja0lucHV0cygpIHtcclxuICAgICAgICBnYW1lcGFkID0gdGhpcy5jb25zdHJ1Y3Rvci5nYW1lcGFkc1tpbmRleF07XHJcbiAgICAgICAgbGFzdFVwZGF0ZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBsb29wVGhyb3VnaEJ1dHRvbnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoXCJMRUZUX0FOQUxPR19TVElDS19IT1JcIiBpbiBhbmFsb2dNYXAgJiYgXCJMRUZUX0FOQUxPR19TVElDS19WRVJUXCIgaW4gYW5hbG9nTWFwKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NBbmFsb2dTdGljay5jYWxsKHRoaXMsIFwiTEVGVF9BTkFMT0dfU1RJQ0tcIiwge1xyXG4gICAgICAgICAgICAgICAgeDogZ2V0Tm9ybWFsaXplZEFuYWxvZ0lucHV0KGdhbWVwYWQuYXhlc1thbmFsb2dNYXAuTEVGVF9BTkFMT0dfU1RJQ0tfSE9SXSksXHJcbiAgICAgICAgICAgICAgICB5OiBnZXROb3JtYWxpemVkQW5hbG9nSW5wdXQoZ2FtZXBhZC5heGVzW2FuYWxvZ01hcC5MRUZUX0FOQUxPR19TVElDS19WRVJUXSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcIlJJR0hUX0FOQUxPR19TVElDS19IT1JcIiBpbiBhbmFsb2dNYXAgJiYgXCJSSUdIVF9BTkFMT0dfU1RJQ0tfVkVSVFwiIGluIGFuYWxvZ01hcCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzQW5hbG9nU3RpY2suY2FsbCh0aGlzLCBcIlJJR0hUX0FOQUxPR19TVElDS1wiLCB7XHJcbiAgICAgICAgICAgICAgICB4OiBnZXROb3JtYWxpemVkQW5hbG9nSW5wdXQoZ2FtZXBhZC5heGVzW2FuYWxvZ01hcC5SSUdIVF9BTkFMT0dfU1RJQ0tfSE9SXSksXHJcbiAgICAgICAgICAgICAgICB5OiBnZXROb3JtYWxpemVkQW5hbG9nSW5wdXQoZ2FtZXBhZC5heGVzW2FuYWxvZ01hcC5SSUdIVF9BTkFMT0dfU1RJQ0tfVkVSVF0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MudXNlQW5hbG9nQXNEcGFkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQW5hbG9nQXNEcGFkLmNhbGwodGhpcywgXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NBbmFsb2dBc0RwYWQuY2FsbCh0aGlzLCBcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiYm90aFwiOlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0FuYWxvZ0FzRHBhZC5jYWxsKHRoaXMsIFwibGVmdFwiKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NBbmFsb2dBc0RwYWQuY2FsbCh0aGlzLCBcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGlucHV0IGluIGV2ZW50UXVldWUpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRRdWV1ZVtpbnB1dF07XHJcbiAgICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQoZXZlbnQubmFtZSwgZXZlbnQuZGV0YWlsLCBldmVudC5pbmZvKTtcclxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50UXVldWVbaW5wdXRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldHVwQ29udHJvbGxlcigpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gbmV3IEdDX1NldHRpbmdzKCk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGluaXRTZXR0aW5ncy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGF5b3V0ID0gaW5pdENvbnRyb2xsZXJNYXBwaW5nLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaW5pdFByZXZpb3VzSW5wdXRzLmNhbGwodGhpcywgbGF5b3V0KTtcclxuICAgICAgICBpZiAobGF5b3V0LmluaXQgJiYgdHlwZW9mIGxheW91dC5pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgbGF5b3V0LmluaXQoZ2FtZXBhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmNvbnRyb2xsZXJDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRkaXNjb25uZWN0ZWRcIiwgX2Rpc2Nvbm5lY3RDb250cm9sbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUNvbnRyb2xsZXIuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluaXRDb250cm9sbGVyTWFwcGluZygpIHtcclxuICAgICAgICB2YXIgbGF5b3V0ID0ge307XHJcbiAgICAgICAgaWYgKGdhbWVwYWQubWFwcGluZyA9PT0gXCJzdGFuZGFyZFwiKSB7XHJcbiAgICAgICAgICAgIHVua25vd25MYXlvdXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGF5b3V0ID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXlvdXRzLmdldChcInN0YW5kYXJkXCIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25zdHJ1Y3Rvci5sYXlvdXRzLmhhcyh0aGlzLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHVua25vd25MYXlvdXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGF5b3V0ID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXlvdXRzLmdldCh0aGlzLm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihHQ19FcnJvcnMuTUFQKTtcclxuICAgICAgICAgICAgbGF5b3V0ID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXlvdXRzLmdldChcIl91bmtub3duXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRMYXlvdXRJbmZvKGxheW91dCk7XHJcbiAgICAgICAgaWYgKHVua25vd25MYXlvdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxheW91dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XHJcbiAgICAgICAgaWYgKGJyb3dzZXIgJiYgYnJvd3NlciBpbiBsYXlvdXQpIHtcclxuICAgICAgICAgICAgbGF5b3V0ID0gbGF5b3V0W2Jyb3dzZXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGxheW91dC5heGVzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkxFRlRfQU5BTE9HX1NUSUNLX0hPUlwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkxFRlRfQU5BTE9HX1NUSUNLX1ZFUlRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJSSUdIVF9BTkFMT0dfU1RJQ0tfSE9SXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiUklHSFRfQU5BTE9HX1NUSUNLX1ZFUlRcIjpcclxuICAgICAgICAgICAgICAgICAgICBhbmFsb2dNYXBbbmFtZV0gPSBsYXlvdXQuYXhlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsYXlvdXQubWlzYyA9IHtcclxuICAgICAgICAgICAgTF9EUEFEX1VQOiAwLFxyXG4gICAgICAgICAgICBMX0RQQURfRE9XTjogMSxcclxuICAgICAgICAgICAgTF9EUEFEX0xFRlQ6IDIsXHJcbiAgICAgICAgICAgIExfRFBBRF9SSUdIVDogMyxcclxuICAgICAgICAgICAgUl9EUEFEX1VQOiA0LFxyXG4gICAgICAgICAgICBSX0RQQURfRE9XTjogNSxcclxuICAgICAgICAgICAgUl9EUEFEX0xFRlQ6IDYsXHJcbiAgICAgICAgICAgIFJfRFBBRF9SSUdIVDogN1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGxheW91dDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluaXRQcmV2aW91c0lucHV0cyhsYXlvdXQpIHtcclxuICAgICAgICB2YXIgYnV0dG9uTmFtZXMgPSBbXTtcclxuICAgICAgICB2YXIgYXhpc05hbWVzID0gW107XHJcbiAgICAgICAgbGFzdFVwZGF0ZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBzdGF0ZS5idXR0b25zID0ge307XHJcbiAgICAgICAgc3RhdGUuYXhlcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLm1pc2MgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBncm91cCBpbiBzdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgbWFwID0gbGF5b3V0W2dyb3VwXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGV4ID0gbWFwW25hbWVdLmluZGV4IHx8IG1hcFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbWFwW25hbWVdLnR5cGUgfHwgZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG1hcFtuYW1lXS5kYXRhIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoX3R5cGVvZihtYXBbbmFtZV0pID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRNaW46IG1hcFtuYW1lXS5pbnB1dE1pbiB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0TWF4OiBtYXBbbmFtZV0uaW5wdXRNYXggfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1hcFtuYW1lXS5tZXRob2QgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVDb252ZXJzaW9uOiBtYXBbbmFtZV0uaWdub3JlQ29udmVyc2lvbiB8fCB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYXhlc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuZW5kc1dpdGgoXCJfSE9SXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC00KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuZW5kc1dpdGgoXCJfVkVSVFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW3R5cGVdW25hbWVdID0gbmV3IEFuYWxvZ1N0aWNrKG5hbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBbZ3JvdXAsIGlucHV0SW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNOYW1lcy5wdXNoKGlucHV0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJ1dHRvbnNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkLmJ1dHRvbnNbaW5wdXRJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVbdHlwZV1bbmFtZV0gPSBuZXcgQnV0dG9uKG5hbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcDogW2dyb3VwLCBpbnB1dEluZGV4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbk5hbWVzLnB1c2goaW5wdXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibWlzY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVbdHlwZV1bbmFtZV0gPSBuZXcgQnV0dG9uKG5hbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBbZ3JvdXAsIGlucHV0SW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXlvdXQub3B0aW9ucyAmJiBsYXlvdXQub3B0aW9ucy5hbGxvd3NFeHRyYXMpIHtcclxuICAgICAgICAgICAgc2V0dXBFeHRyYUJ1dHRvbnMuY2FsbCh0aGlzLCBidXR0b25OYW1lcywgXCJidXR0b25zXCIpO1xyXG4gICAgICAgICAgICBzZXR1cEV4dHJhQnV0dG9ucy5jYWxsKHRoaXMsIGF4aXNOYW1lcywgXCJheGVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluaXRTZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzLnVwZGF0ZShzZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0Q29udHJvbGxlcihldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC5nYW1lcGFkLmluZGV4ID09PSB0aGlzLmluZGV4KSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnVud2F0Y2guY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uc3RydWN0b3IuY29udHJvbGxlcnNbdGhpcy5pbmRleF07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmNvbnRyb2xsZXJDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsIF9kaXNjb25uZWN0Q29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLmNvbnN0cnVjdG9yLmV2ZW50cy5nZXROYW1lKFwiY29udHJvbGxlclwiLCBcImRpc2Nvbm5lY3RcIiksIHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICAgICAgICAgIH0sIFwiQ29udHJvbGxlciBhdCBpbmRleCBcIiArIHRoaXMuaW5kZXggKyBcIiBkaXNjb25uZWN0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldHVwRXh0cmFCdXR0b25zKGxpc3QsIHR5cGUpIHtcclxuICAgICAgICB2YXIgcHJlZml4ID0gdHlwZSA9PT0gXCJidXR0b25zXCIgPyBcIkJVVFRPTlwiIDogXCJBWElTXCI7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIF9pbmRleCBpbiBnYW1lcGFkW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0LmluZGV4T2YocGFyc2VJbnQoX2luZGV4KSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFwiTUlTQ1wiICsgcHJlZml4ICsgXCJfXCIgKyBpO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYnV0dG9uc1tuYW1lXSA9IG5ldyBCdXR0b24obmFtZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcDogW3R5cGUsIF9pbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0TGF5b3V0SW5mbyhsYXlvdXQpIHtcclxuICAgICAgICBsYXlvdXRJbmZvLm5hbWUgPSBsYXlvdXQubmFtZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGF5b3V0SW5mby5kZXNjcmlwdGlvbiA9IGxheW91dC5kZXNjcmlwdGlvbiB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGF5b3V0SW5mby51bmtub3duTGF5b3V0ID0gdW5rbm93bkxheW91dCB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yICh2YXIgX2luZGV4MiBpbiBsYXlvdXRJbmZvKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvW19pbmRleDJdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBsYXlvdXRJbmZvW19pbmRleDJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxvb3BUaHJvdWdoQnV0dG9ucygpIHtcclxuICAgICAgICB2YXIgaW5wdXRzID0gc3RhdGUuYnV0dG9ucztcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGlucHV0cykge1xyXG4gICAgICAgICAgICB2YXIgX2luZGV4MyA9IGlucHV0c1tuYW1lXS5nZXRHYW1lcGFkSW5kZXgoKTtcclxuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBpbnB1dHNbbmFtZV0uZ2V0R2FtZXBhZFNlY3Rpb24oKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3R5cGVvZihnYW1lcGFkW3NlY3Rpb25dW19pbmRleDNdKSA9PT0gXCJvYmplY3RcIiA/IGdhbWVwYWRbc2VjdGlvbl1bX2luZGV4M10udmFsdWUgOiBnYW1lcGFkW3NlY3Rpb25dW19pbmRleDNdO1xyXG4gICAgICAgICAgICBwcm9jZXNzQnV0dG9uLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCdXR0b24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnB1dE5hbWUgPSBuYW1lLnN0YXJ0c1dpdGgoXCJMX1wiKSB8fCBuYW1lLnN0YXJ0c1dpdGgoXCJSX1wiKSA/IG5hbWUuc3Vic3RyaW5nKDIpIDogbmFtZTtcclxuICAgICAgICB2YXIgYnV0dG9uID0gc3RhdGUuYnV0dG9uc1tuYW1lXSB8fCBzdGF0ZS5heGVzW25hbWVdIHx8IHN0YXRlLm1pc2NbbmFtZV07XHJcbiAgICAgICAgaWYgKGV2ZW50UXVldWVbaW5wdXROYW1lXSAmJiBldmVudFF1ZXVlW2lucHV0TmFtZV0ubmFtZSA9PT0gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZ2V0TmFtZShcImJ1dHRvblwiLCBcImR1cmluZ1wiKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYnV0dG9uLmdldE9wdGlvbihcIm1ldGhvZFwiKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gYnV0dG9uLmdldE9wdGlvbihcIm1ldGhvZFwiKS5jYWxsKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2FtZXBhZHNbdGhpcy5pbmRleF0sIGJ1dHRvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gYnV0dG9uLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5oYXNVcGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFidXR0b24uZ2V0T3B0aW9uKFwiaWdub3JlQ29udmVyc2lvblwiKSAmJiBidXR0b24uaGFzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICB2YXIgbWluID0gYnV0dG9uLmdldE9wdGlvbihcImlucHV0TWluXCIpIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBidXR0b24uZ2V0T3B0aW9uKFwiaW5wdXRNYXhcIikgfHwgMTtcclxuICAgICAgICAgICAgdmFsdWUgPSBnZXRMaW5lYXJDb252ZXJzaW9uKHZhbHVlLCBtaW4sIG1heCwgMCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmVzc2VkID0gdmFsdWUgPiAwO1xyXG4gICAgICAgIHZhciBwcmV2aW91c2x5UHJlc3NlZCA9IGJ1dHRvbi52YWx1ZSA+IDA7XHJcbiAgICAgICAgaWYgKCFwcmVzc2VkICYmICFwcmV2aW91c2x5UHJlc3NlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1dHRvbi51cGRhdGUodmFsdWUpO1xyXG4gICAgICAgIHZhciBjb3B5ID0gYnV0dG9uLmNvcHkoKTtcclxuICAgICAgICBjb3B5Lm5hbWUgPSBpbnB1dE5hbWU7XHJcbiAgICAgICAgaWYgKHByZXNzZWQgJiYgIXByZXZpb3VzbHlQcmVzc2VkKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlRXZlbnQoaW5wdXROYW1lLCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50cy5nZXROYW1lKFwiYnV0dG9uXCIsIFwic3RhcnRcIiksIGNvcHkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJlc3NlZCAmJiBwcmV2aW91c2x5UHJlc3NlZCkge1xyXG4gICAgICAgICAgICBxdWV1ZUV2ZW50KGlucHV0TmFtZSwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZ2V0TmFtZShcImJ1dHRvblwiLCBcImR1cmluZ1wiKSwgY29weSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghcHJlc3NlZCAmJiBwcmV2aW91c2x5UHJlc3NlZCkge1xyXG4gICAgICAgICAgICBxdWV1ZUV2ZW50KGlucHV0TmFtZSwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZ2V0TmFtZShcImJ1dHRvblwiLCBcImVuZFwiKSwgY29weSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FuYWxvZ1N0aWNrKG5hbWUsIGlucHV0KSB7XHJcbiAgICAgICAgaWYgKGlucHV0LnggPT09IHVuZGVmaW5lZCB8fCBpbnB1dC55ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRRdWV1ZVtuYW1lXSAmJiBldmVudFF1ZXVlW25hbWVdLm5hbWUgPT09IHRoaXMuY29uc3RydWN0b3IuZXZlbnRzLmdldE5hbWUoXCJhbmFsb2dcIiwgXCJkdXJpbmdcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYW5hbG9nU3RpY2sgPSBzdGF0ZS5heGVzW25hbWVdIHx8IHN0YXRlLmJ1dHRvbnNbbmFtZV0gfHwgc3RhdGUubWlzY1tuYW1lXTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gY2FsY3VsYXRlQW5hbG9nVmFsdWVzLmNhbGwodGhpcywgaW5wdXQpO1xyXG4gICAgICAgIHZhciBwcmVzc2VkID0gaXNBbmFsb2dTdGlja1ByZXNzZWQodmFsdWVzKTtcclxuICAgICAgICB2YXIgcHJldmlvdXNseVByZXNzZWQgPSBpc0FuYWxvZ1N0aWNrUHJlc3NlZChhbmFsb2dTdGljay5wb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzVmFsdWVzID0ge1xyXG4gICAgICAgICAgICB4OiBhbmFsb2dTdGljay5wb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBhbmFsb2dTdGljay5wb3NpdGlvbi55XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIXByZXNzZWQgJiYgIXByZXZpb3VzbHlQcmVzc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYW5hbG9nU3RpY2sudXBkYXRlKHZhbHVlcyk7XHJcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBhbmFsb2dTdGljay5wb3NpdGlvbi54ICE9PSBwcmV2aW91c1ZhbHVlcy54IHx8IGFuYWxvZ1N0aWNrLnBvc2l0aW9uLnkgIT09IHByZXZpb3VzVmFsdWVzLnk7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBhbmFsb2dTdGljay5jb3B5KCk7XHJcbiAgICAgICAgaWYgKHByZXNzZWQgJiYgIXByZXZpb3VzbHlQcmVzc2VkKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlRXZlbnQobmFtZSArIFwic3RhcnRcIiwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZ2V0TmFtZShcImFuYWxvZ1wiLCBcInN0YXJ0XCIpLCBjb3B5KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByZXNzZWQgJiYgcHJldmlvdXNseVByZXNzZWQpIHtcclxuICAgICAgICAgICAgcXVldWVFdmVudChuYW1lICsgXCJkdXJpbmdcIiwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZ2V0TmFtZShcImFuYWxvZ1wiLCBcImR1cmluZ1wiKSwgY29weSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghcHJlc3NlZCAmJiBwcmV2aW91c2x5UHJlc3NlZCkge1xyXG4gICAgICAgICAgICBxdWV1ZUV2ZW50KG5hbWUgKyBcImVuZFwiLCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50cy5nZXROYW1lKFwiYW5hbG9nXCIsIFwiZW5kXCIpLCBjb3B5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgcXVldWVFdmVudChuYW1lICsgXCJjaGFuZ2VcIiwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZ2V0TmFtZShcImFuYWxvZ1wiLCBcImNoYW5nZVwiKSwgY29weSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FuYWxvZ0FzRHBhZChzdGljaykge1xyXG4gICAgICAgIHZhciBwcmVmaXggPSBzdGljayA9PT0gXCJsZWZ0XCIgPyBcIkxfXCIgOiBcIlJfXCI7XHJcbiAgICAgICAgdmFyIGFuYWxvZ1N0aWNrID0gc3RpY2sgPT09IFwibGVmdFwiID8gXCJMRUZUX0FOQUxPR19TVElDS1wiIDogXCJSSUdIVF9BTkFMT0dfU1RJQ0tcIjtcclxuICAgICAgICB2YXIgbmFtZXMgPSBbXCJEUEFEX1VQXCIsIFwiRFBBRF9ET1dOXCIsIFwiRFBBRF9MRUZUXCIsIFwiRFBBRF9SSUdIVFwiXTtcclxuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XHJcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBuYW1lc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3N0ZXAudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0QXhpcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJBeGlzID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBpc1Bhc3RUaHJlc2hvbGQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEUEFEX1VQXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0QXhpcyA9IHN0YXRlLmF4ZXNbYW5hbG9nU3RpY2tdLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQXhpcyA9IHN0YXRlLmF4ZXNbYW5hbG9nU3RpY2tdLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFzdFRocmVzaG9sZCA9IGlucHV0QXhpcyA8PSB0aGlzLnNldHRpbmdzLmFuYWxvZ1N0aWNrRHBhZFRocmVzaG9sZCAqIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRQQURfRE9XTlwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEF4aXMgPSBzdGF0ZS5heGVzW2FuYWxvZ1N0aWNrXS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckF4aXMgPSBzdGF0ZS5heGVzW2FuYWxvZ1N0aWNrXS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Bhc3RUaHJlc2hvbGQgPSBpbnB1dEF4aXMgPj0gdGhpcy5zZXR0aW5ncy5hbmFsb2dTdGlja0RwYWRUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRFBBRF9MRUZUXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0QXhpcyA9IHN0YXRlLmF4ZXNbYW5hbG9nU3RpY2tdLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQXhpcyA9IHN0YXRlLmF4ZXNbYW5hbG9nU3RpY2tdLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFzdFRocmVzaG9sZCA9IGlucHV0QXhpcyA8PSB0aGlzLnNldHRpbmdzLmFuYWxvZ1N0aWNrRHBhZFRocmVzaG9sZCAqIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRQQURfUklHSFRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRBeGlzID0gc3RhdGUuYXhlc1thbmFsb2dTdGlja10ucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJBeGlzID0gc3RhdGUuYXhlc1thbmFsb2dTdGlja10ucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXN0VGhyZXNob2xkID0gaW5wdXRBeGlzID49IHRoaXMuc2V0dGluZ3MuYW5hbG9nU3RpY2tEcGFkVGhyZXNob2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlzUGFzdFRocmVzaG9sZCAmJiBNYXRoLmFicyhpbnB1dEF4aXMpID4gTWF0aC5hYnMob3RoZXJBeGlzKSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0J1dHRvbi5jYWxsKHRoaXMsIHByZWZpeCArIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlQW5hbG9nVmFsdWVzKHZhbHVlcykge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZXMueCAhPT0gMCkge1xyXG4gICAgICAgICAgICBvdXRwdXQueCA9IGdldExpbmVhckNvbnZlcnNpb24oTWF0aC5hYnModmFsdWVzLngpLCB0aGlzLnNldHRpbmdzLmFuYWxvZ1N0aWNrRGVhZHpvbmUubWluLCB0aGlzLnNldHRpbmdzLmFuYWxvZ1N0aWNrRGVhZHpvbmUubWF4LCAwLCAxKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlcy54IDwgMCAmJiBvdXRwdXQueCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnggKj0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlcy55ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC55ID0gZ2V0TGluZWFyQ29udmVyc2lvbihNYXRoLmFicyh2YWx1ZXMueSksIHRoaXMuc2V0dGluZ3MuYW5hbG9nU3RpY2tEZWFkem9uZS5taW4sIHRoaXMuc2V0dGluZ3MuYW5hbG9nU3RpY2tEZWFkem9uZS5tYXgsIDAsIDEpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWVzLnkgPCAwICYmIG91dHB1dC55ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQueSAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5tYXBBbmFsb2dUb1NoYXBlID09PSBcInNxdWFyZVwiID8gZ2V0Q29vcmRzTWFwcGVkVG9TcXVhcmUob3V0cHV0KSA6IG91dHB1dDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkZXRhaWwsIGluZm8pIHtcclxuICAgICAgICBkZXRhaWwgPSBkZXRhaWwgfHwge307XHJcbiAgICAgICAgaW5mbyA9IGluZm8gfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChpbmZvKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhpbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xyXG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcclxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcclxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb29yZHNNYXBwZWRUb1NxdWFyZShjb29yZHMpIHtcclxuICAgICAgICBpZiAoY29vcmRzLnggPT09IDAgfHwgY29vcmRzLnkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IGNvb3Jkcy54LFxyXG4gICAgICAgICAgICAgICAgeTogY29vcmRzLnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYWJzID0ge1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5hYnMoY29vcmRzLngpLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5hYnMoY29vcmRzLnkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBvbGRMZW5ndGggPSBNYXRoLmh5cG90KGFicy54LCBhYnMueSk7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSAxO1xyXG4gICAgICAgICAgICBpZiAoYWJzLnggPiBhYnMueSkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gb2xkTGVuZ3RoICogKDEgLyBhYnMueCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBvbGRMZW5ndGggKiAoMSAvIGFicy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3VmFscyA9IGdldFNob3J0ZW5lZExpbmVEaXN0YW5jZShhYnMsIGdldExpbmVhckNvbnZlcnNpb24ob2xkTGVuZ3RoLCAwLCAxLCAwLCBtYXgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IGNvb3Jkcy54ID4gMCA/IG5ld1ZhbHMueCA6IC1uZXdWYWxzLngsXHJcbiAgICAgICAgICAgICAgICB5OiBjb29yZHMueSA+IDAgPyBuZXdWYWxzLnkgOiAtbmV3VmFscy55XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0TGluZWFyQ29udmVyc2lvbih2YWx1ZSwgb2xkTWluLCBvbGRNYXgsIG5ld01pbiwgbmV3TWF4KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSAtIG9sZE1pbikgKiAobmV3TWF4IC0gbmV3TWluKSAvIChvbGRNYXggLSBvbGRNaW4pICsgbmV3TWluO1xyXG4gICAgICAgIGlmIChuZXdNYXggPCBuZXdNaW4pIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA8IG5ld01heCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3TWF4O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA+IG5ld01pbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3TWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA+IG5ld01heCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3TWF4O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA8IG5ld01pbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3TWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXROb3JtYWxpemVkQW5hbG9nSW5wdXQoaW5wdXQpIHtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgLjEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldExpbmVhckNvbnZlcnNpb24oaW5wdXQsIC0uOSwgMSwgLTEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFNob3J0ZW5lZExpbmVEaXN0YW5jZSh2YWx1ZXMsIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIGh5cG90ZW51c2UgPSBNYXRoLmh5cG90KHZhbHVlcy54LCB2YWx1ZXMueSk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hY29zKHZhbHVlcy55IC8gaHlwb3RlbnVzZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2UsXHJcbiAgICAgICAgICAgIHk6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzQW5hbG9nU3RpY2tQcmVzc2VkKHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZXMueCkgPiAwIHx8IE1hdGguYWJzKHZhbHVlcy55KSA+IDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBxdWV1ZUV2ZW50KGlucHV0LCBldmVudE5hbWUsIGRldGFpbCwgaW5mbykge1xyXG4gICAgICAgIGV2ZW50UXVldWVbaW5wdXRdID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXHJcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsIHx8IHt9LFxyXG4gICAgICAgICAgICBpbmZvOiBpbmZvIHx8IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRCcm93c2VyKCkge1xyXG4gICAgICAgIGlmIChcImNocm9tZVwiIGluIHdpbmRvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJDaHJvbWVcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKFwib3BlcmFcIiBpbiB3aW5kb3cgJiYge30udG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmEpID09PSBcIltvYmplY3QgT3BlcmFdXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiT3BlcmFcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKFwiTW96QXBwZWFyYW5jZVwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJNb3ppbGxhXCI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcIldlYmtpdEFwcGVhcmFuY2VcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiV2Via2l0XCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLndhdGNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghUkFGKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xsZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy51bndhdGNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChSQUYpIHtcclxuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKFJBRik7XHJcbiAgICAgICAgICAgIFJBRiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IENvbnRyb2xsZXIubGF5b3V0cy5yZWdleFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleCA9IF9zdGVwMi52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZC5tYXRjaChyZWdleClbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3RlZFRpbWVzdGFtcFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lc3RhbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXlvdXRJbmZvXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxheW91dEluZm87XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgYW5hbG9nU3RpY2tzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGJ1dHRvbiBpbiBzdGF0ZS5idXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25zW2J1dHRvbl0gPSBzdGF0ZS5idXR0b25zW2J1dHRvbl0uY29weSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGF4aXMgaW4gc3RhdGUuYXhlcykge1xyXG4gICAgICAgICAgICAgICAgYW5hbG9nU3RpY2tzW2F4aXNdID0gc3RhdGUuYXhlc1theGlzXS5jb3B5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IGJ1dHRvbnMsXHJcbiAgICAgICAgICAgICAgICBhbmFsb2dTdGlja3M6IGFuYWxvZ1N0aWNrc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gQnV0dG9uKG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICBhcmdzID0gYXJncyB8fCB7fTtcclxuICAgICAgICB2YXIgbWFwID0gYXJncy5tYXAgfHwgW107XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0gYXJncy5zZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICB2YXIgZGF0YSA9IGFyZ3MuZGF0YSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XHJcbiAgICAgICAgc2V0UHJlc3NlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHNldFRpbWUuY2FsbCh0aGlzKTtcclxuICAgICAgICBmdW5jdGlvbiBzZXRQcmVzc2VkKCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0aGlzLnZhbHVlID4gKHNldHRpbmdzLmJ1dHRvblRocmVzaG9sZCB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0VGltZSgpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lID0gbGFzdFVwZGF0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0R2FtZXBhZFNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBbMF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldEdhbWVwYWRJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcFsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uc1tvcHRpb25dO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBzZXRQcmVzc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHNldFRpbWUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCF1cGRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29weSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbcHJvcGVydHldICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXdEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzVXBkYXRlZFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGhhc1VwZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBoYXNVcGRhdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBBbmFsb2dTdGljayhuYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XHJcbiAgICAgICAgdmFyIG1hcCA9IGFyZ3MubWFwIHx8IFtdO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IGFyZ3Muc2V0dGluZ3MgfHwge307XHJcbiAgICAgICAgdmFyIGRhdGEgPSBhcmdzLmRhdGEgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVySW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBnZXRQb3NpdGlvbi5jYWxsKHRoaXMsIHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldEFuZ2xlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgc2V0VGltZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldEFuZ2xlKCkge1xyXG4gICAgICAgICAgICB2YXIgcmFkaWFucyA9IGNvb3JkaW5hdGVzVG9SYWRpYW5zKHRoaXMucG9zaXRpb24ueCwgLXRoaXMucG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgIHZhciBkZWdyZWVzID0gcmFkaWFuc1RvRGVncmVlcyhyYWRpYW5zKTtcclxuICAgICAgICAgICAgdGhpcy5hbmdsZSA9IHtcclxuICAgICAgICAgICAgICAgIHJhZGlhbnM6IGdldFNob3J0ZW5lZE51bWJlcihyYWRpYW5zLCAzKSxcclxuICAgICAgICAgICAgICAgIGRlZ3JlZXM6IGdldFNob3J0ZW5lZE51bWJlcihkZWdyZWVzLCAzKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzZXRUaW1lKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWUgPSBsYXN0VXBkYXRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24odmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiByb3VuZFBvc2l0aW9uKHZhbHVlcy54KSxcclxuICAgICAgICAgICAgICAgIHk6IHJvdW5kUG9zaXRpb24odmFsdWVzLnkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNvb3JkaW5hdGVzVG9SYWRpYW5zKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmFkaWFucyA9IE1hdGguYXRhbjIoeSwgeCk7XHJcbiAgICAgICAgICAgIGlmIChyYWRpYW5zIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmFkaWFucyArPSAyICogTWF0aC5QSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMocmFkaWFucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJvdW5kUG9zaXRpb24obnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobnVtYmVyKSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IobnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IC0yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBNYXRoLmZyb3VuZChudW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFNob3J0ZW5lZE51bWJlcihudW1iZXIsIHBsYWNlcykge1xyXG4gICAgICAgICAgICB2YXIgbXVsdCA9IE1hdGgucG93KDEwLCBwbGFjZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBtdWx0KSAvIG11bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocmFkaWFucykge1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4ocmFkaWFucykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0R2FtZXBhZFNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBbMF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldEdhbWVwYWRJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcFsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uc1tvcHRpb25dO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBnZXRQb3NpdGlvbi5jYWxsKHRoaXMsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHNldEFuZ2xlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHNldFRpbWUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCF1cGRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29weSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbcHJvcGVydHldICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXdEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzVXBkYXRlZFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGhhc1VwZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBoYXNVcGRhdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wb3N0U2V0dXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IHRoaXMsXHJcbiAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHVua25vd25MYXlvdXQpIHtcclxuICAgICAgICAgICAgZGF0YS51bmtub3duTGF5b3V0ID0gdW5rbm93bkxheW91dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLmNvbnN0cnVjdG9yLmV2ZW50cy5nZXROYW1lKFwiY29udHJvbGxlclwiLCBcImNvbm5lY3RcIiksIGRhdGEsIFwiR2FtZXBhZCBjb25uZWN0ZWQgYXQgaW5kZXggXCIgKyBpbmRleCArIFwiLlwiKTtcclxuICAgIH07XHJcbiAgICBzZXR1cENvbnRyb2xsZXIuY2FsbCh0aGlzKTtcclxufVxyXG5cclxuQ29udHJvbGxlci5zZWFyY2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHRpbWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmludGVydmFsIHx8IDUwMDtcclxuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5saW1pdCB8fCB1bmRlZmluZWQ7XHJcbiAgICBpZiAoIUNvbnRyb2xsZXIuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMudW5zdXBwb3J0ZWRDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudW5zdXBwb3J0ZWRDYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY29udHJvbGxlckNvdW50ID49IGxpbWl0KSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gdGhpcy5nYW1lcGFkcykge1xyXG4gICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lcGFkc1tpbmRleF0gIT09IG51bGwgJiYgdGhpcy5nYW1lcGFkc1tpbmRleF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldENvbnRyb2xsZXIoaW5kZXgpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9sbGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgXCJzZXR0aW5nc1wiIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IG9wdGlvbnMuc2V0dGluZ3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2luZGV4XSA9IG5ldyBDb250cm9sbGVyKHRoaXMuZ2FtZXBhZHNbaW5kZXhdLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2luZGV4XS5fcG9zdFNldHVwLmNhbGwodGhpcy5jb250cm9sbGVyc1tpbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpLCB0aW1lcik7XHJcbn07XHJcblxyXG5Db250cm9sbGVyLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXgpO1xyXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihpbmRleCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oaW5kZXggKyBcIiBtdXN0IGJlIGEgbnVtYmVyXCIpO1xyXG4gICAgfSBlbHNlIGlmIChpbmRleCAlIDEgIT09IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oaW5kZXggKyBcIiBtdXN0IGJlIGFuIGludFwiKTtcclxuICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGluZGV4ICsgXCIgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzICYmIHRoaXMuY29udHJvbGxlcnNbaW5kZXhdO1xyXG59O1xyXG5cclxuQ29udHJvbGxlci53YXRjaEFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGluZGV4IGluIENvbnRyb2xsZXIuY29udHJvbGxlcnMpIHtcclxuICAgICAgICBDb250cm9sbGVyLmdldENvbnRyb2xsZXIoaW5kZXgpLndhdGNoKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Db250cm9sbGVyLnVud2F0Y2hBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBpbmRleCBpbiBDb250cm9sbGVyLmNvbnRyb2xsZXJzKSB7XHJcbiAgICAgICAgQ29udHJvbGxlci5nZXRDb250cm9sbGVyKGluZGV4KS51bndhdGNoKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbGxlciwgXCJjb250cm9sbGVyQ291bnRcIiwge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbGxlcnMpLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xsZXIsIFwic3VwcG9ydGVkXCIsIHtcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWVwYWRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkdBTUVQQURcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghKFwiZGVmaW5lUHJvcGVydHlcIiBpbiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkRFRklORVBST1BFUlRZXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihHQ19FcnJvcnNbZXJyb3JdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbGxlciwgXCJnYW1lcGFkc1wiLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgICB2YXIgZ2FtZXBhZHMgPSBudWxsO1xyXG4gICAgICAgIGlmIChcImdldEdhbWVwYWRzXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgICAgICAgIGdhbWVwYWRzID0gbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcIndlYmtpdEdhbWVwYWRzXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgICAgICAgIGdhbWVwYWRzID0gbmF2aWdhdG9yLndlYmtpdEdhbWVwYWRzKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcIm1vekdhbWVwYWRzXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgICAgICAgIGdhbWVwYWRzID0gbmF2aWdhdG9yLm1vekdhbWVwYWRzKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcImdhbWVwYWRzXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgICAgICAgIGdhbWVwYWRzID0gbmF2aWdhdG9yLmdhbWVwYWRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnYW1lcGFkcztcclxuICAgIH0sXHJcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG59KTtcclxuXHJcbk1hdGguaHlwb3QgPSBNYXRoLmh5cG90IHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB5ID0gMDtcclxuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XHJcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XHJcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGFyZ3VtZW50c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgYXJnID0gX3N0ZXAzLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFyZyA9PT0gSW5maW5pdHkgfHwgYXJnID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5ICs9IGFyZyAqIGFyZztcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xyXG4gICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xyXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xyXG59O1xyXG5cclxuT2JqZWN0LmFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XHJcbiAgICB9XHJcbiAgICB0YXJnZXQgPSBPYmplY3QodGFyZ2V0KTtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XHJcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxudmFyIEdDX0Vycm9ycyA9IHtcclxuICAgIGdldCBHQU1FUEFEKCkge1xyXG4gICAgICAgIHJldHVybiBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBHYW1lcGFkIEFQSS5cIjtcclxuICAgIH0sXHJcbiAgICBnZXQgREVGSU5FUFJPUEVSVFkoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvZXJ0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpLlwiO1xyXG4gICAgfSxcclxuICAgIGdldCBNQVAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdObyBtYXRjaGluZyBtYXAgZm91bmQuIFVzaW5nIFwiU3RhbmRhcmRcIi4nO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIEdDX0V2ZW50cyA9IGZ1bmN0aW9uIEdDX0V2ZW50cygpIHtcclxuICAgIHZhciBwcmUgPSBcImdjXCI7XHJcbiAgICB0aGlzLmdldE5hbWUgPSBmdW5jdGlvbiAoYmFzZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBbcHJlLCB0aGlzW2Jhc2UudG9VcHBlckNhc2UoKV0uYmFzZSwgdGhpc1tiYXNlLnRvVXBwZXJDYXNlKCldLmFjdGlvbnNbYWN0aW9uXV07XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuam9pbihcIi5cIik7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdDX0V2ZW50cy5wcm90b3R5cGUsIFwiQ09OVFJPTExFUlwiLCB7XHJcbiAgICB2YWx1ZToge1xyXG4gICAgICAgIGJhc2U6IFwiY29udHJvbGxlclwiLFxyXG4gICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgY29ubmVjdDogXCJmb3VuZFwiLFxyXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBcImxvc3RcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR0NfRXZlbnRzLnByb3RvdHlwZSwgXCJCVVRUT05cIiwge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgICBiYXNlOiBcImJ1dHRvblwiLFxyXG4gICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgc3RhcnQ6IFwicHJlc3NcIixcclxuICAgICAgICAgICAgZHVyaW5nOiBcImhvbGRcIixcclxuICAgICAgICAgICAgZW5kOiBcInJlbGVhc2VcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR0NfRXZlbnRzLnByb3RvdHlwZSwgXCJBTkFMT0dcIiwge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgICBiYXNlOiBcImFuYWxvZ1wiLFxyXG4gICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcclxuICAgICAgICAgICAgZHVyaW5nOiBcImhvbGRcIixcclxuICAgICAgICAgICAgY2hhbmdlOiBcImNoYW5nZVwiLFxyXG4gICAgICAgICAgICBlbmQ6IFwiZW5kXCJcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuQ29udHJvbGxlci5ldmVudHMgPSBuZXcgR0NfRXZlbnRzKCk7XHJcblxyXG52YXIgR0NfTGF5b3V0cyA9IHtcclxuICAgIGxpc3Q6IHtcclxuICAgICAgICBfdW5rbm93bjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcIlVua25vd24gTGF5b3V0XCIsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkEgZmFsbGJhY2sgZm9yIHdoZW4gbm8gYXBwcm9wcmlhdGUgbGF5b3V0cyBhcmUgZm91bmQuXCIsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGFsbG93c0V4dHJhczogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihtYXApIHtcclxuICAgICAgICB2YXIgbGF5b3V0cyA9IENvbnRyb2xsZXIubGF5b3V0cztcclxuICAgICAgICB2YXIgaWQgPSBtYXAubWF0Y2g7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRzLnJlZ2V4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IHRoaXMucmVnZXhbaV07XHJcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGlkKSkge1xyXG4gICAgICAgICAgICAgICAgaWQgPSBpZC5tYXRjaChyZWdleClbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGF5b3V0cy5saXN0W2lkLnRvTG93ZXJDYXNlKCldID0gbWFwO1xyXG4gICAgfSxcclxuICAgIGhhczogZnVuY3Rpb24gaGFzKG5hbWUpIHtcclxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBuYW1lIGluIENvbnRyb2xsZXIubGF5b3V0cy5saXN0O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcclxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBDb250cm9sbGVyLmxheW91dHMubGlzdFtuYW1lXTtcclxuICAgIH0sXHJcbiAgICBnZXQgcmVnZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsvKC4qKVxcKC4qXFwpLywgL1thLXpBLVowLTldezMsNH0tW2EtekEtWjAtOV17Myw0fS0oLiopL107XHJcbiAgICB9XHJcbn07XHJcblxyXG5Db250cm9sbGVyLmxheW91dHMgPSBHQ19MYXlvdXRzO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdGFuZGFyZCA9IHtcclxuICAgICAgICBtYXRjaDogXCJTdGFuZGFyZFwiLFxyXG4gICAgICAgIG5hbWU6IFwiU3RhbmRhcmRcIixcclxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgVzNDIHN0YW5kYXJkIGdhbWVwYWQgbGF5b3V0LlwiLFxyXG4gICAgICAgIGJ1dHRvbnM6IHtcclxuICAgICAgICAgICAgRkFDRV8xOiAwLFxyXG4gICAgICAgICAgICBGQUNFXzI6IDEsXHJcbiAgICAgICAgICAgIEZBQ0VfMzogMixcclxuICAgICAgICAgICAgRkFDRV80OiAzLFxyXG4gICAgICAgICAgICBMRUZUX1NIT1VMREVSOiA0LFxyXG4gICAgICAgICAgICBSSUdIVF9TSE9VTERFUjogNSxcclxuICAgICAgICAgICAgTEVGVF9TSE9VTERFUl9CT1RUT006IDYsXHJcbiAgICAgICAgICAgIFJJR0hUX1NIT1VMREVSX0JPVFRPTTogNyxcclxuICAgICAgICAgICAgU0VMRUNUOiA4LFxyXG4gICAgICAgICAgICBTVEFSVDogOSxcclxuICAgICAgICAgICAgTEVGVF9BTkFMT0dfQlVUVE9OOiAxMCxcclxuICAgICAgICAgICAgUklHSFRfQU5BTE9HX0JVVFRPTjogMTEsXHJcbiAgICAgICAgICAgIERQQURfVVA6IDEyLFxyXG4gICAgICAgICAgICBEUEFEX0RPV046IDEzLFxyXG4gICAgICAgICAgICBEUEFEX0xFRlQ6IDE0LFxyXG4gICAgICAgICAgICBEUEFEX1JJR0hUOiAxNSxcclxuICAgICAgICAgICAgSE9NRTogMTZcclxuICAgICAgICB9LFxyXG4gICAgICAgIGF4ZXM6IHtcclxuICAgICAgICAgICAgTEVGVF9BTkFMT0dfU1RJQ0tfSE9SOiAwLFxyXG4gICAgICAgICAgICBMRUZUX0FOQUxPR19TVElDS19WRVJUOiAxLFxyXG4gICAgICAgICAgICBSSUdIVF9BTkFMT0dfU1RJQ0tfSE9SOiAyLFxyXG4gICAgICAgICAgICBSSUdIVF9BTkFMT0dfU1RJQ0tfVkVSVDogM1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBhbGxvd3NFeHRyYXM6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udHJvbGxlci5sYXlvdXRzLnJlZ2lzdGVyKHN0YW5kYXJkKTtcclxufSkoKTtcclxuXHJcbnZhciBHQ19TZXR0aW5nID0gZnVuY3Rpb24gR0NfU2V0dGluZyhuYW1lLCBkZWZhdWx0VmFsdWUsIHNldHRlckZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB0aGlzLnNldHRlckZ1bmN0aW9uID0gc2V0dGVyRnVuY3Rpb247XHJcbn07XHJcblxyXG52YXIgR0NfU2V0dGluZ3MgPSBmdW5jdGlvbiBHQ19TZXR0aW5ncyhpc0dsb2JhbFNldHRpbmdMaXN0KSB7XHJcbiAgICB2YXIgZ2xvYmFsU2V0dGluZ3MgPSBpc0dsb2JhbFNldHRpbmdMaXN0ID8gZmFsc2UgOiBDb250cm9sbGVyLmdsb2JhbFNldHRpbmdzO1xyXG4gICAgdmFyIGxvY2FsU2V0dGluZ3MgPSB7fTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdsb2JhbFwiLCB7XHJcbiAgICAgICAgdmFsdWU6ICEhaXNHbG9iYWxTZXR0aW5nTGlzdCxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHNldHRpbmcpIHtcclxuICAgICAgICBpZiAoIWlzR2xvYmFsU2V0dGluZ0xpc3QpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiWW91IGNhbiBvbmx5IHJlZ2lzdGVyIHNldHRpbmdzIGdsb2JhbGx5OlxcbkNvbnRyb2xsZXIuZ2xvYmFsU2V0dGluZ3MucmVnaXN0ZXIoKVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3R5cGVvZihzZXR0aW5nLmRlZmF1bHRWYWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgc2V0dGluZy52YWx1ZSA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmcuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXR0aW5nLnZhbHVlID0gc2V0dGluZy5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc2V0dGluZy5uYW1lLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdsb2JhbCAmJiBzZXR0aW5nLm5hbWUgaW4gbG9jYWxTZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNldHRpbmdzW3NldHRpbmcubmFtZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5nLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IFwiZGVmYXVsdFwiICYmIHRoaXMuZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mKHNldHRpbmcuZGVmYXVsdFZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZy52YWx1ZSA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmcuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcudmFsdWUgPSBzZXR0aW5nLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbFNldHRpbmdzW3NldHRpbmcubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJkZWZhdWx0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3R5cGVvZihzZXR0aW5nLmRlZmF1bHRWYWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTZXR0aW5nc1tzZXR0aW5nLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2V0dGluZ3Nbc2V0dGluZy5uYW1lXSA9IHNldHRpbmcuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gc2V0dGluZy5zZXR0ZXJGdW5jdGlvbih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdsb2JhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgbmV3VmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihuZXdWYWx1ZSkpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZXR0aW5nLnZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIG5ld1ZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobmV3VmFsdWUpKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obG9jYWxTZXR0aW5nc1tzZXR0aW5nLm5hbWVdLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2V0dGluZ3Nbc2V0dGluZy5uYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuR0NfU2V0dGluZ3MucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgb3V0cHV0ID0ge307XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpICYmIHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIG91dHB1dFtuYW1lXSA9IHRoaXNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbkdDX1NldHRpbmdzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdHlwZW9mIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlW25hbWVdICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkdDX1NldHRpbmdzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBpZiAoX3R5cGVvZihhcmd1bWVudHNbMF0pID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVNdWx0aXBsZS5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dDX1NldHRpbmdzLnVwZGF0ZShzZXR0aW5ncykgZXhwZWN0cyBcInNldHRpbmdzXCIgdG8gYmUgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIiAmJiBhcmd1bWVudHNbMF0gaW4gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpc1thcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdHQ19TZXR0aW5ncy51cGRhdGUoc2V0dGluZ05hbWUsIHZhbHVlKSBleHBlY3RzIFwic2V0dGluZ25hbWVcIiB0byBiZSB0aGUgbmFtZSBvZiBhIHNldHRpbmcuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignR0NfU2V0dGluZ3MudXBkYXRlKCkgZXhwZWN0cyBlaXRoZXIgMSBvciAyIGFyZ3VtZW50czpcXG51cGRhdGUoc2V0dGluZ3MpIC0gd2hlcmUgXCJzZXR0aW5nc1wiIGlzIGFuIG9iamVjdCBrZXkvdmFsdWUgcGFpcnNcXG51cGRhdGUoc2V0dGluZ05hbWUsIHZhbHVlKSAtIHdoZXJlIFwic2V0dGluZ05hbWVcIiBpcyB0aGUgc2V0dGluZyB5b3Ugd2FudCB0byBjaGFuZ2UgYW5kIFwidmFsdWVcIiBpcyB3aGF0IHlvdSB3YW50IHRvIGNoYW5nZSBpdCB0by4nKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVNdWx0aXBsZShsaXN0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBsaXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBsaXN0W25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzdWNjZXNzO1xyXG59O1xyXG5cclxuQ29udHJvbGxlci5nbG9iYWxTZXR0aW5ncyA9IG5ldyBHQ19TZXR0aW5ncyh0cnVlKTtcclxuXHJcbkNvbnRyb2xsZXIuZ2xvYmFsU2V0dGluZ3MucmVnaXN0ZXIobmV3IEdDX1NldHRpbmcoXCJhbmFsb2dTdGlja0RlYWR6b25lXCIsIHtcclxuICAgIG1pbjogMCxcclxuICAgIG1heDogMVxyXG59LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSAhPT0gXCJvYmplY3RcIiB8fCAhKFwibWluXCIgaW4gdmFsdWUgfHwgXCJtYXhcIiBpbiB2YWx1ZSkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgZWl0aGVyL2JvdGggXCJtaW5cIiBhbmQgXCJtYXhcIiB2YWx1ZXMnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBvdXRwdXQgPSB7fTtcclxuICAgIGlmIChcIm1pblwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5taW4gPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubWluID49IDAgJiYgdmFsdWUubWluIDw9IDEpIHtcclxuICAgICAgICBvdXRwdXQubWluID0gdmFsdWUubWluO1xyXG4gICAgfVxyXG4gICAgaWYgKFwibWF4XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm1heCA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5tYXggPj0gMCAmJiB2YWx1ZS5tYXggPD0gMSkge1xyXG4gICAgICAgIG91dHB1dC5tYXggPSB2YWx1ZS5tYXg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59KSk7XHJcblxyXG5Db250cm9sbGVyLmdsb2JhbFNldHRpbmdzLnJlZ2lzdGVyKG5ldyBHQ19TZXR0aW5nKFwiYW5hbG9nU3RpY2tEcGFkVGhyZXNob2xkXCIsIC43LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJhbmdyeVwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSkpO1xyXG5cclxuQ29udHJvbGxlci5nbG9iYWxTZXR0aW5ncy5yZWdpc3RlcihuZXcgR0NfU2V0dGluZyhcImJ1dHRvblRocmVzaG9sZFwiLCAuOTUsIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcImFuZ3J5XCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59KSk7XHJcblxyXG5Db250cm9sbGVyLmdsb2JhbFNldHRpbmdzLnJlZ2lzdGVyKG5ldyBHQ19TZXR0aW5nKFwibWFwQW5hbG9nVG9TaGFwZVwiLCBcIm5vbmVcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibm9uZVwiO1xyXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJzcXVhcmVcIikge1xyXG4gICAgICAgIHJldHVybiBcInNxdWFyZVwiO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSkpO1xyXG5cclxuQ29udHJvbGxlci5nbG9iYWxTZXR0aW5ncy5yZWdpc3RlcihuZXcgR0NfU2V0dGluZyhcInVzZUFuYWxvZ0FzRHBhZFwiLCBcIm5vbmVcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgcG9zc2libGUgPSBbXCJub25lXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90aFwiLCBmYWxzZV07XHJcbiAgICBpZiAocG9zc2libGUuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdOb3QgYSB2YWxpZCBvcHRpb24gZm9yIFwidXNlQW5hbG9nQXNEcGFkXCIuJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn0pKTtcclxuXHJcbnJldHVybiBDb250cm9sbGVyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29udHJvbGxlci5qcy9kaXN0L0NvbnRyb2xsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2NvbnRyb2xsZXIubGF5b3V0cy5qcycsIGZhY3RvcnkpIDpcclxuICAgIChnbG9iYWwuQ29udHJvbGxlckxheW91dHMgPSBmYWN0b3J5KCkpO1xyXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qISBDb250cm9sbGVyLmxheW91dHMuanMgLSB2MS4wLjAgLSAyMDE2LTA4LTMwICovXHJcblxyXG52YXIgeGJveE9uZU9TWCA9IHtcclxuICAgIG1hdGNoOiBcIlhib3ggT25lIFdpcmVkIENvbnRyb2xsZXJcIixcclxuICAgIG5hbWU6IFwiWGJveCBPbmUgKFhib3ggMzYwIENvbnRyb2xsZXIgRHJpdmVyKVwiLFxyXG4gICAgZGVzY3JpcHRpb246IFwiQSBzdGFuZGFyZCBYYm94IE9uZSBnYW1lcGFkIG9uIE1hYyBPUyBYIHVzaW5nIHRoZSBkcml2ZXIgXCIgKyBcIlhib3ggMzYwIENvbnRyb2xsZXIgRHJpdmVyIChodHRwczovL2dpdGh1Yi5jb20vMzYwQ29udHJvbGxlci8zNjBDb250cm9sbGVyLykuXCIsXHJcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlJlcG9ydGluZyBvZiBidXR0b25zLkhPTUUgaXMgYnVnZ3kgYW5kIHVucmVsaWFibGUuXCIpO1xyXG4gICAgfSxcclxuICAgIGJ1dHRvbnM6IHtcclxuICAgICAgICBGQUNFXzE6IDAsXHJcbiAgICAgICAgRkFDRV8yOiAxLFxyXG4gICAgICAgIEZBQ0VfMzogMixcclxuICAgICAgICBGQUNFXzQ6IDMsXHJcbiAgICAgICAgTEVGVF9TSE9VTERFUjogNCxcclxuICAgICAgICBSSUdIVF9TSE9VTERFUjogNSxcclxuICAgICAgICBMRUZUX0FOQUxPR19CVVRUT046IDYsXHJcbiAgICAgICAgUklHSFRfQU5BTE9HX0JVVFRPTjogNyxcclxuICAgICAgICBTVEFSVDogOCxcclxuICAgICAgICBTRUxFQ1Q6IDksXHJcbiAgICAgICAgRFBBRF9VUDogMTEsXHJcbiAgICAgICAgRFBBRF9ET1dOOiAxMixcclxuICAgICAgICBEUEFEX0xFRlQ6IDEzLFxyXG4gICAgICAgIERQQURfUklHSFQ6IDE0XHJcbiAgICB9LFxyXG4gICAgYXhlczoge1xyXG4gICAgICAgIExFRlRfQU5BTE9HX1NUSUNLX0hPUjogMCxcclxuICAgICAgICBMRUZUX0FOQUxPR19TVElDS19WRVJUOiAxLFxyXG4gICAgICAgIExFRlRfU0hPVUxERVJfQk9UVE9NOiB7XHJcbiAgICAgICAgICAgIGluZGV4OiAyLFxyXG4gICAgICAgICAgICBpbnB1dE1pbjogLTEsXHJcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uc1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBSSUdIVF9BTkFMT0dfU1RJQ0tfSE9SOiAzLFxyXG4gICAgICAgIFJJR0hUX0FOQUxPR19TVElDS19WRVJUOiA0LFxyXG4gICAgICAgIFJJR0hUX1NIT1VMREVSX0JPVFRPTToge1xyXG4gICAgICAgICAgICBpbmRleDogNSxcclxuICAgICAgICAgICAgaW5wdXRNaW46IC0xLFxyXG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvbnNcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSE9NRToge1xyXG4gICAgICAgICAgICBpbmRleDogOSxcclxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25zXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBwcmVzc2VkOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtZXRob2Q6IGhvbWVCdXR0b24sXHJcbiAgICAgICAgICAgIGlnbm9yZUNvbnZlcnNpb246IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbnZhciBtb3ppbGxhVmFyaWFudCA9IHtcclxuICAgIGJ1dHRvbnM6IHtcclxuICAgICAgICBGQUNFXzE6IDMsXHJcbiAgICAgICAgRkFDRV8yOiA0LFxyXG4gICAgICAgIEZBQ0VfMzogNSxcclxuICAgICAgICBGQUNFXzQ6IDYsXHJcbiAgICAgICAgTEVGVF9TSE9VTERFUjogMTEsXHJcbiAgICAgICAgUklHSFRfU0hPVUxERVI6IDEyLFxyXG4gICAgICAgIExFRlRfQU5BTE9HX0JVVFRPTjogMTMsXHJcbiAgICAgICAgUklHSFRfQU5BTE9HX0JVVFRPTjogMTQsXHJcbiAgICAgICAgU1RBUlQ6IDIsXHJcbiAgICAgICAgU0VMRUNUOiAxLFxyXG4gICAgICAgIERQQURfVVA6IDcsXHJcbiAgICAgICAgRFBBRF9ET1dOOiA4LFxyXG4gICAgICAgIERQQURfTEVGVDogOSxcclxuICAgICAgICBEUEFEX1JJR0hUOiAxMCxcclxuICAgICAgICBIT01FOiAxNVxyXG4gICAgfSxcclxuICAgIGF4ZXM6IHtcclxuICAgICAgICBMRUZUX0FOQUxPR19TVElDS19IT1I6IDAsXHJcbiAgICAgICAgTEVGVF9BTkFMT0dfU1RJQ0tfVkVSVDogMSxcclxuICAgICAgICBMRUZUX1NIT1VMREVSX0JPVFRPTToge1xyXG4gICAgICAgICAgICBpbmRleDogMixcclxuICAgICAgICAgICAgaW5wdXRNaW46IC0xLFxyXG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvbnNcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgUklHSFRfQU5BTE9HX1NUSUNLX0hPUjogMyxcclxuICAgICAgICBSSUdIVF9BTkFMT0dfU1RJQ0tfVkVSVDogNCxcclxuICAgICAgICBSSUdIVF9TSE9VTERFUl9CT1RUT006IHtcclxuICAgICAgICAgICAgaW5kZXg6IDUsXHJcbiAgICAgICAgICAgIGlucHV0TWluOiAtMSxcclxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25zXCJcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbnhib3hPbmVPU1guTW96aWxsYSA9IG1vemlsbGFWYXJpYW50O1xyXG5cclxuZnVuY3Rpb24gaG9tZUJ1dHRvbihnYW1lcGFkLCBidXR0b24pIHtcclxuICAgIGlmICghZ2FtZXBhZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB2YWx1ZSA9IGdhbWVwYWQuYXhlc1s5XTtcclxuICAgIHZhciBwcmV2aW91cyA9IGJ1dHRvbi5kYXRhO1xyXG4gICAgaWYgKHByZXZpb3VzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBidXR0b24uZGF0YSA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBwcmVzc2VkOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09IHByZXZpb3VzLnZhbHVlKSB7XHJcbiAgICAgICAgYnV0dG9uLmRhdGEgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBidXR0b24uZGF0YS52YWx1ZSxcclxuICAgICAgICAgICAgcHJlc3NlZDogYnV0dG9uLmRhdGEucHJlc3NlZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzLnByZXNzZWQgPyAxIDogMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzLnByZXNzZWQpIHtcclxuICAgICAgICAgICAgYnV0dG9uLmRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBwcmVzc2VkOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidXR0b24uZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIHByZXNzZWQ6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5yZXR1cm4geGJveE9uZU9TWDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvbnRyb2xsZXIuanMvZGlzdC9Db250cm9sbGVyLmxheW91dHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJnY3MtYXBwXFxcIj5cXG4gICAgPHVpLXRhYnNcXG4gICAgICAgIGNsYXNzPVxcXCJtYWluLXRhYi1jb250YWluZXJcXFwiIGJhY2tncm91bmQtY29sb3I9XFxcImRhcmtcXFwiIHRleHQtY29sb3I9XFxcImxpZ2h0XFxcIlxcbiAgICAgICAgaW5kaWNhdG9yLWNvbG9yPVxcXCJ0cmFuc3BhcmVudFxcXCJcXG4gICAgPlxcbiAgICAgICAgPHVpLXRhYiBoZWFkZXI9XFxcIk1hcFxcXCI+XFxuICAgICAgICAgICAgPG1hcC12aWV3PjwvbWFwLXZpZXc+XFxuICAgICAgICA8L3VpLXRhYj5cXG5cXG4gICAgICAgIDx1aS10YWIgaGVhZGVyPVxcXCJQYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxwYXJhbXMtdmlldz48L3BhcmFtcy12aWV3PlxcbiAgICAgICAgPC91aS10YWI+XFxuXFxuICAgICAgICA8dWktdGFiIGhlYWRlcj1cXFwiU2V0dGluZ3NcXFwiPlxcbiAgICAgICAgICAgIDxzZXR0aW5ncy12aWV3Pjwvc2V0dGluZ3Mtdmlldz5cXG4gICAgICAgIDwvdWktdGFiPlxcbiAgICA8L3VpLXRhYnM+XFxuXFxuICAgIDxnY3MtaW5kaWNhdG9ycz48L2djcy1pbmRpY2F0b3JzPlxcblxcbiAgICA8dWktc25hY2tiYXItY29udGFpbmVyIHBvc2l0aW9uPVxcXCJsZWZ0XFxcIj48L3VpLXNuYWNrYmFyLWNvbnRhaW5lcj5cXG5cXG4gICAgPGdjcy1lZGl0LW1pc3Npb24tbW9kYWwgOnNob3cuc3luYz1cXFwic2hvd0VkaXRNaXNzaW9uTW9kYWxcXFwiPjwvZ2NzLWVkaXQtbWlzc2lvbi1tb2RhbD5cXG48L2Rpdj5cXG5cXG48c29ja2V0LWlvLW1hbmFnZXI+PC9zb2NrZXQtaW8tbWFuYWdlcj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnO1xyXG5cclxuVnVlLnVzZShWdWV4KTtcclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgIG1hcDogbnVsbCxcclxuICAgIG1hcEVsOiBudWxsLFxyXG4gICAgbWFwTG9hZGVkOiBmYWxzZSxcclxuICAgIHdheXBvaW50c1Zpc2libGU6IHRydWUsXHJcbiAgICB3YW12OiB7XHJcbiAgICAgICAgbG9hZGVkOiBmYWxzZSxcclxuICAgICAgICBwb3NpdGlvbjoge2xhdDogLTMyLjg4ODMzMzgsIGxuZzogMTUxLjcwNzUyNzl9LFxyXG4gICAgICAgIGhlYWRpbmc6ICAwLFxyXG4gICAgICAgIHNwZWVkOiAgICAwLFxyXG4gICAgICAgIGJhdHRlcnk6ICAxMDAsXHJcbiAgICAgICAgYXJtZWQ6ICAgIGZhbHNlLFxyXG4gICAgICAgIG1vZGU6ICAgICAnbWFudWFsJyxcclxuICAgICAgICBzaWduYWw6ICAgMTAwXHJcbiAgICB9LFxyXG4gICAgc2V0dGluZ3M6IFtdLCAvLyBbe3RpdGxlOiB0MSwgc2V0dGluZ3M6IFt7dGl0bGU6IHQyLCB2YWx1ZTogdjF9LCAuLi5dfSwgLi4uXVxyXG4gICAgc2V0dGluZ3NMYXN0VXBkYXRlVGltZTogbnVsbCxcclxuICAgIG1pc3Npb25zOiBbXSxcclxuICAgICAgICAvL1t7XHJcbiAgICAgICAgLy8gICAgdGl0bGU6IHQxLFxyXG4gICAgICAgIC8vICAgIG9yaWdpbjoge2xhdDogbGF0MSwgbG5nOiBsbmcxfSxcclxuICAgICAgICAvLyAgICB3YXlwb2ludHM6IFtcclxuICAgICAgICAvLyAgICAgICAge3RpdGxlOiB0MiwgdHlwZTogdDMsIHBvc2l0aW9uOiB7bGF0OiBsYXQxLCBsbmc6IGxuZzF9fSwgLi4uXVxyXG4gICAgICAgIC8vfSwgLi4uXVxyXG4gICAgbWlzc2lvbnNMYXN0VXBkYXRlVGltZTogbnVsbCxcclxuICAgIGN1cnJlbnRNaXNzaW9uSW5kZXg6IC0xLFxyXG4gICAgcGFyYW1ldGVyczogW10sXHJcbiAgICAgICAgLy9be1xyXG4gICAgICAgIC8vICAgIHRpdGxlOiB0MSxcclxuICAgICAgICAvLyAgICBzdWJTZWN0aW9uczogW3tcclxuICAgICAgICAvLyAgICAgICAgdGl0bGU6IHQyLFxyXG4gICAgICAgIC8vICAgICAgICBwYXJhbXM6IFt7dGl0bGU6IHQzLCB0eXBlOiB0NCwgdmFsdWU6IHYxLCB2YWxpZDogdjJ9LCAuLi5dXHJcbiAgICAgICAgLy8gICAgfSwgLi4uXVxyXG4gICAgICAgIC8vfSwgLi4uXVxyXG4gICAgcGFyYW1ldGVyc0xhc3RVcGRhdGVUaW1lOiBudWxsXHJcbn07XHJcblxyXG5jb25zdCBtdXRhdGlvbnMgPSB7XHJcbiAgICBTRVRfTUFQKHN0YXRlLCBtYXApIHtcclxuICAgICAgICBzdGF0ZS5tYXAgPSBtYXA7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFVF9NQVBfRUwoc3RhdGUsIG1hcEVsKSB7XHJcbiAgICAgICAgc3RhdGUubWFwRWwgPSBtYXBFbDtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX01BUF9MT0FERUQoc3RhdGUsIGxvYWRlZCkge1xyXG4gICAgICAgIHN0YXRlLm1hcExvYWRlZCA9IGxvYWRlZDtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX1dBWVBPSU5UU19WSVNJQkxFKHN0YXRlLCB2aXNpYmxlKSB7XHJcbiAgICAgICAgc3RhdGUud2F5cG9pbnRzVmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9LFxyXG5cclxuICAgIFVQREFURV9XQU1WX1BPU0lUSU9OKHN0YXRlLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHN0YXRlLndhbXYucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX1dBTVYoc3RhdGUsIHdhbXYpIHtcclxuICAgICAgICBzdGF0ZS53YW12ID0gd2FtdjtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX1dBTVZfQVJNRUQoc3RhdGUsIGFybWVkKSB7XHJcbiAgICAgICAgc3RhdGUud2Ftdi5hcm1lZCA9IGFybWVkO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfV0FNVl9NT0RFKHN0YXRlLCBtb2RlKSB7XHJcbiAgICAgICAgc3RhdGUud2Ftdi5tb2RlID0gbW9kZTtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX1NFVFRJTkdTKHN0YXRlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIHN0YXRlLnNldHRpbmdzTGFzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHN0YXRlLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICB9LFxyXG5cclxuICAgIFNFVF9NSVNTSU9OUyhzdGF0ZSwgbWlzc2lvbnMpIHtcclxuICAgICAgICBzdGF0ZS5taXNzaW9uc0xhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBzdGF0ZS5taXNzaW9ucyA9IG1pc3Npb25zO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfQ1VSUkVOVF9NSVNTSU9OX0lOREVYKHN0YXRlLCBpbmRleCkge1xyXG4gICAgICAgIHN0YXRlLmN1cnJlbnRNaXNzaW9uSW5kZXggPSBpbmRleDtcclxuICAgIH0sXHJcblxyXG4gICAgU0VUX0NVUlJFTlRfTUlTU0lPTl9USVRMRShzdGF0ZSwgdGl0bGUpIHtcclxuICAgICAgICBzdGF0ZS5taXNzaW9uc1tzdGF0ZS5jdXJyZW50TWlzc2lvbkluZGV4XS50aXRsZSA9IHRpdGxlO1xyXG4gICAgfSxcclxuXHJcbiAgICBTRVRfUEFSQU1FVEVSUyhzdGF0ZSwgcGFyYW1ldGVycykge1xyXG4gICAgICAgIHN0YXRlLnBhcmFtZXRlcnNMYXN0VXBkYXRlVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgc3RhdGUucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgVnVleC5TdG9yZSh7XHJcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlLFxyXG4gICAgbXV0YXRpb25zXHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zdG9yZS9zdG9yZS5qc1xuICoqLyIsIi8qIVxuICogVnVleCB2MS4wLjAtcmNcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbC5WdWV4ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9O1xuXG4gIHZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYXJyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKGFycikge1xuICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBvYmopIHtcbiAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IHByZXZba2V5XTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgLy8gYWxsb3cgbXVsdGlwbGUgbXV0YXRpb24gb2JqZWN0cyB0byBjb250YWluIGR1cGxpY2F0ZVxuICAgICAgICAgIC8vIGhhbmRsZXJzIGZvciB0aGUgc2FtZSBtdXRhdGlvbiB0eXBlXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICBwcmV2W2tleV0gPSBleGlzdGluZy5jb25jYXQob2JqW2tleV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2W2tleV0gPSBbZXhpc3RpbmddLmNvbmNhdChvYmpba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBPYmplY3Qgb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb2JqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3RhdGUgc3ViIHRyZWUgYnkgZ2l2ZW4ga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gbmVzdGVkS2V5c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBnZXROZXN0ZWRTdGF0ZShzdGF0ZSwgbmVzdGVkS2V5cykge1xuICAgIHJldHVybiBuZXN0ZWRLZXlzLnJlZHVjZShmdW5jdGlvbiAoc3RhdGUsIGtleSkge1xuICAgICAgcmV0dXJuIHN0YXRlW2tleV07XG4gICAgfSwgc3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhY2tzIHRvIGdldCBhY2Nlc3MgdG8gVnVlIGludGVybmFscy5cbiAgICogTWF5YmUgd2Ugc2hvdWxkIGV4cG9zZSB0aGVzZS4uLlxuICAgKi9cblxuICB2YXIgV2F0Y2hlciA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gZ2V0V2F0Y2hlcih2bSkge1xuICAgIGlmICghV2F0Y2hlcikge1xuICAgICAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG4gICAgICB2YXIgdW53YXRjaCA9IHZtLiR3YXRjaChub29wLCBub29wKTtcbiAgICAgIFdhdGNoZXIgPSB2bS5fd2F0Y2hlcnNbMF0uY29uc3RydWN0b3I7XG4gICAgICB1bndhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiBXYXRjaGVyO1xuICB9XG5cbiAgdmFyIERlcCA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gZ2V0RGVwKHZtKSB7XG4gICAgaWYgKCFEZXApIHtcbiAgICAgIERlcCA9IHZtLl9kYXRhLl9fb2JfXy5kZXAuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBEZXA7XG4gIH1cblxuICB2YXIgaG9vayA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4gIGZ1bmN0aW9uIGRldnRvb2xQbHVnaW4oc3RvcmUpIHtcbiAgICBpZiAoIWhvb2spIHJldHVybjtcblxuICAgIGhvb2suZW1pdCgndnVleDppbml0Jywgc3RvcmUpO1xuXG4gICAgaG9vay5vbigndnVleDp0cmF2ZWwtdG8tc3RhdGUnLCBmdW5jdGlvbiAodGFyZ2V0U3RhdGUpIHtcbiAgICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gICAgfSk7XG5cbiAgICBzdG9yZS5vbignbXV0YXRpb24nLCBmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgICBob29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGUgKFZ1ZSkge1xuICAgIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gICAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgICAgdmFyIHVzZXNJbml0ID0gVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTE7XG4gICAgICBWdWUubWl4aW4odXNlc0luaXQgPyB7IGluaXQ6IHZ1ZXhJbml0IH0gOiB7IGJlZm9yZUNyZWF0ZTogdnVleEluaXQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIHZhciBfaW5pdCA9IFZ1ZS5wcm90b3R5cGUuX2luaXQ7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdCA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdCkgOiB2dWV4SW5pdDtcbiAgICAgICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2dWV4SW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAgIHZhciBzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgICB2YXIgdnVleCA9IG9wdGlvbnMudnVleDtcbiAgICAgIC8vIHN0b3JlIGluamVjdGlvblxuXG4gICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgdGhpcy4kc3RvcmUgPSBzdG9yZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgICAgfVxuICAgICAgLy8gdnVleCBvcHRpb24gaGFuZGxpbmdcbiAgICAgIGlmICh2dWV4KSB7XG4gICAgICAgIGlmICghdGhpcy4kc3RvcmUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBzdG9yZSBub3QgaW5qZWN0ZWQuIG1ha2Ugc3VyZSB0byAnICsgJ3Byb3ZpZGUgdGhlIHN0b3JlIG9wdGlvbiBpbiB5b3VyIHJvb3QgY29tcG9uZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHZ1ZXguc3RhdGU7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdnVleC5hY3Rpb25zO1xuICAgICAgICB2YXIgZ2V0dGVycyA9IHZ1ZXguZ2V0dGVycztcbiAgICAgICAgLy8gaGFuZGxlIGRlcHJlY2F0ZWQgc3RhdGUgb3B0aW9uXG5cbiAgICAgICAgaWYgKHN0YXRlICYmICFnZXR0ZXJzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gdnVleC5zdGF0ZSBvcHRpb24gd2lsbCBiZWVuIGRlcHJlY2F0ZWQgaW4gMS4wLiAnICsgJ1VzZSB2dWV4LmdldHRlcnMgaW5zdGVhZC4nKTtcbiAgICAgICAgICBnZXR0ZXJzID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0dGVyc1xuICAgICAgICBpZiAoZ2V0dGVycykge1xuICAgICAgICAgIG9wdGlvbnMuY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkIHx8IHt9O1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBnZXR0ZXJzKSB7XG4gICAgICAgICAgICBkZWZpbmVWdWV4R2V0dGVyKHRoaXMsIGtleSwgZ2V0dGVyc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWN0aW9uc1xuICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMubWV0aG9kcyA9IG9wdGlvbnMubWV0aG9kcyB8fCB7fTtcbiAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kc1tfa2V5XSA9IG1ha2VCb3VuZEFjdGlvbih0aGlzLiRzdG9yZSwgYWN0aW9uc1tfa2V5XSwgX2tleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIGZvciBhbGwgZ2V0dGVyIHByb3BlcnRpZXMuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXR0ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Z1ZXggZ2V0dGVyIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seS4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBWdWV4IGdldHRlciBvbiBhbiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRlZmluZVZ1ZXhHZXR0ZXIodm0sIGtleSwgZ2V0dGVyKSB7XG4gICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBHZXR0ZXIgYm91bmQgdG8ga2V5IFxcJ3Z1ZXguZ2V0dGVycy4nICsga2V5ICsgJ1xcJyBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBtYWtlQ29tcHV0ZWRHZXR0ZXIodm0uJHN0b3JlLCBnZXR0ZXIpLFxuICAgICAgICAgIHNldDogc2V0dGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBjb21wdXRlZCBnZXR0ZXIsIHVzaW5nIHRoZSBzYW1lIGNhY2hpbmcgbWVjaGFuaXNtIG9mIGNvbXB1dGVkXG4gICAgICogcHJvcGVydGllcy4gSW4gYWRkaXRpb24sIGl0IGlzIGNhY2hlZCBvbiB0aGUgcmF3IGdldHRlciBmdW5jdGlvbiB1c2luZ1xuICAgICAqIHRoZSBzdG9yZSdzIHVuaXF1ZSBjYWNoZSBpZC4gVGhpcyBtYWtlcyB0aGUgc2FtZSBnZXR0ZXIgc2hhcmVkXG4gICAgICogYWNyb3NzIGFsbCBjb21wb25lbnRzIHVzZSB0aGUgc2FtZSB1bmRlcmx5aW5nIHdhdGNoZXIsIGFuZCBtYWtlc1xuICAgICAqIHRoZSBnZXR0ZXIgZXZhbHVhdGVkIG9ubHkgb25jZSBkdXJpbmcgZXZlcnkgZmx1c2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0b3JlfSBzdG9yZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyKHN0b3JlLCBnZXR0ZXIpIHtcbiAgICAgIHZhciBpZCA9IHN0b3JlLl9nZXR0ZXJDYWNoZUlkO1xuXG4gICAgICAvLyBjYWNoZWRcbiAgICAgIGlmIChnZXR0ZXJbaWRdKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXJbaWRdO1xuICAgICAgfVxuICAgICAgdmFyIHZtID0gc3RvcmUuX3ZtO1xuICAgICAgdmFyIFdhdGNoZXIgPSBnZXRXYXRjaGVyKHZtKTtcbiAgICAgIHZhciBEZXAgPSBnZXREZXAodm0pO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZnVuY3Rpb24gKHZtKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXIodm0uc3RhdGUpO1xuICAgICAgfSwgbnVsbCwgeyBsYXp5OiB0cnVlIH0pO1xuICAgICAgdmFyIGNvbXB1dGVkR2V0dGVyID0gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgIH07XG4gICAgICBnZXR0ZXJbaWRdID0gY29tcHV0ZWRHZXR0ZXI7XG4gICAgICByZXR1cm4gY29tcHV0ZWRHZXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGJvdW5kLXRvLXN0b3JlIHZlcnNpb24gb2YgYSByYXcgYWN0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdG9yZX0gc3RvcmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBtYWtlQm91bmRBY3Rpb24oc3RvcmUsIGFjdGlvbiwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBBY3Rpb24gYm91bmQgdG8ga2V5IFxcJ3Z1ZXguYWN0aW9ucy4nICsga2V5ICsgJ1xcJyBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB2dWV4Qm91bmRBY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsLmFwcGx5KGFjdGlvbiwgW3RoaXMsIHN0b3JlXS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb24gbWVyZ2luZ1xuICAgIHZhciBtZXJnZSA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLmNvbXB1dGVkO1xuICAgIFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLnZ1ZXggPSBmdW5jdGlvbiAodG9WYWwsIGZyb21WYWwpIHtcbiAgICAgIGlmICghdG9WYWwpIHJldHVybiBmcm9tVmFsO1xuICAgICAgaWYgKCFmcm9tVmFsKSByZXR1cm4gdG9WYWw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXR0ZXJzOiBtZXJnZSh0b1ZhbC5nZXR0ZXJzLCBmcm9tVmFsLmdldHRlcnMpLFxuICAgICAgICBzdGF0ZTogbWVyZ2UodG9WYWwuc3RhdGUsIGZyb21WYWwuc3RhdGUpLFxuICAgICAgICBhY3Rpb25zOiBtZXJnZSh0b1ZhbC5hY3Rpb25zLCBmcm9tVmFsLmFjdGlvbnMpXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgVnVlID0gdm9pZCAwO1xuICB2YXIgdWlkID0gMDtcblxuICB2YXIgU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICAtIHtPYmplY3R9IHN0YXRlXG4gICAgICogICAgICAgIC0ge09iamVjdH0gYWN0aW9uc1xuICAgICAqICAgICAgICAtIHtPYmplY3R9IG11dGF0aW9uc1xuICAgICAqICAgICAgICAtIHtBcnJheX0gcGx1Z2luc1xuICAgICAqICAgICAgICAtIHtCb29sZWFufSBzdHJpY3RcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFN0b3JlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIF9yZWYkc3RhdGUgPSBfcmVmLnN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gX3JlZiRzdGF0ZSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJHN0YXRlO1xuICAgICAgdmFyIF9yZWYkbXV0YXRpb25zID0gX3JlZi5tdXRhdGlvbnM7XG4gICAgICB2YXIgbXV0YXRpb25zID0gX3JlZiRtdXRhdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRtdXRhdGlvbnM7XG4gICAgICB2YXIgX3JlZiRtb2R1bGVzID0gX3JlZi5tb2R1bGVzO1xuICAgICAgdmFyIG1vZHVsZXMgPSBfcmVmJG1vZHVsZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRtb2R1bGVzO1xuICAgICAgdmFyIF9yZWYkcGx1Z2lucyA9IF9yZWYucGx1Z2lucztcbiAgICAgIHZhciBwbHVnaW5zID0gX3JlZiRwbHVnaW5zID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYkcGx1Z2lucztcbiAgICAgIHZhciBfcmVmJHN0cmljdCA9IF9yZWYuc3RyaWN0O1xuICAgICAgdmFyIHN0cmljdCA9IF9yZWYkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkc3RyaWN0O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmUpO1xuXG4gICAgICB0aGlzLl9nZXR0ZXJDYWNoZUlkID0gJ3Z1ZXhfc3RvcmVfJyArIHVpZCsrO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Jvb3RNdXRhdGlvbnMgPSB0aGlzLl9tdXRhdGlvbnMgPSBtdXRhdGlvbnM7XG4gICAgICB0aGlzLl9tb2R1bGVzID0gbW9kdWxlcztcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAvLyBiaW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgICAgIHZhciBkaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2g7XG4gICAgICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaC5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgICAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gICAgICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgICAgIGlmICghVnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIG11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLicpO1xuICAgICAgfVxuICAgICAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICAgICAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fdm0gPSBuZXcgVnVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuICAgICAgdGhpcy5fc2V0dXBNb2R1bGVTdGF0ZShzdGF0ZSwgbW9kdWxlcyk7XG4gICAgICB0aGlzLl9zZXR1cE1vZHVsZU11dGF0aW9ucyhtb2R1bGVzKTtcbiAgICAgIC8vIGFkZCBleHRyYSB3YXJuaW5ncyBpbiBzdHJpY3QgbW9kZVxuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aGlzLl9zZXR1cE11dGF0aW9uQ2hlY2soKTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBsdWdpbnNcbiAgICAgIGRldnRvb2xQbHVnaW4odGhpcyk7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luKF90aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRlciBmb3IgdGhlIGVudGlyZSBzdGF0ZSB0cmVlLlxuICAgICAqIFJlYWQgb25seS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cblxuICAgIGNyZWF0ZUNsYXNzKFN0b3JlLCBbe1xuICAgICAga2V5OiAncmVwbGFjZVN0YXRlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2Ugcm9vdCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICAgICAqL1xuXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdm0uc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwYXRjaCBhbiBhY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzcGF0Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoKHR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHBheWxvYWRbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgLy8gY29tcGF0aWJpbGl0eSBmb3Igb2JqZWN0IGFjdGlvbnMsIGUuZy4gRlNBXG4gICAgICAgIGlmICgodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHR5cGUpKSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHBheWxvYWQgPSB0eXBlO1xuICAgICAgICAgIGlmICh0eXBlLnNpbGVudCkgc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0eXBlID0gdHlwZS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcHBseSB0aGUgbXV0YXRpb25cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlci5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgIGlzT2JqZWN0U3R5bGVEaXNwYXRjaCA/IGgoc3RhdGUsIHBheWxvYWQpIDogaC5hcHBseSh1bmRlZmluZWQsIFtzdGF0ZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHBheWxvYWQpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNPYmplY3RTdHlsZURpc3BhdGNoID8gaGFuZGxlcihzdGF0ZSwgcGF5bG9hZCkgOiBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgW3N0YXRlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocGF5bG9hZCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gaXNPYmplY3RTdHlsZURpc3BhdGNoID8gcGF5bG9hZCA6IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdtdXRhdGlvbicsIG11dGF0aW9uLCBzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW3Z1ZXhdIFVua25vd24gbXV0YXRpb246ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdhdGNoIHN0YXRlIGNoYW5nZXMgb24gdGhlIHN0b3JlLlxuICAgICAgICogU2FtZSBBUEkgYXMgVnVlJ3MgJHdhdGNoLCBleGNlcHQgd2hlbiB3YXRjaGluZyBhIGZ1bmN0aW9uLFxuICAgICAgICogdGhlIGZ1bmN0aW9uIGdldHMgdGhlIHN0YXRlIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd2F0Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhdGNoKGZuLCBjYiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVnVleCBzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92bS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmbihfdGhpczIuc3RhdGUpO1xuICAgICAgICB9LCBjYiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSG90IHVwZGF0ZSBtdXRhdGlvbnMgJiBtb2R1bGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiAgICAgICAgLSB7T2JqZWN0fSBbbXV0YXRpb25zXVxuICAgICAgICogICAgICAgIC0ge09iamVjdH0gW21vZHVsZXNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hvdFVwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaG90VXBkYXRlKCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB2YXIgbXV0YXRpb25zID0gX3JlZjIubXV0YXRpb25zO1xuICAgICAgICB2YXIgbW9kdWxlcyA9IF9yZWYyLm1vZHVsZXM7XG5cbiAgICAgICAgdGhpcy5fcm9vdE11dGF0aW9ucyA9IHRoaXMuX211dGF0aW9ucyA9IG11dGF0aW9ucyB8fCB0aGlzLl9yb290TXV0YXRpb25zO1xuICAgICAgICB0aGlzLl9zZXR1cE1vZHVsZU11dGF0aW9ucyhtb2R1bGVzIHx8IHRoaXMuX21vZHVsZXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGFjaCBzdWIgc3RhdGUgdHJlZSBvZiBlYWNoIG1vZHVsZSB0byB0aGUgcm9vdCB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldHVwTW9kdWxlU3RhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZHVsZVN0YXRlKHN0YXRlLCBtb2R1bGVzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QobW9kdWxlcykpIHJldHVybjtcblxuICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1trZXldO1xuXG4gICAgICAgICAgLy8gc2V0IHRoaXMgbW9kdWxlJ3Mgc3RhdGVcbiAgICAgICAgICBWdWUuc2V0KHN0YXRlLCBrZXksIG1vZHVsZS5zdGF0ZSB8fCB7fSk7XG5cbiAgICAgICAgICAvLyByZXRyaWV2ZSBuZXN0ZWQgbW9kdWxlc1xuICAgICAgICAgIF90aGlzMy5fc2V0dXBNb2R1bGVTdGF0ZShzdGF0ZVtrZXldLCBtb2R1bGUubW9kdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJpbmQgbXV0YXRpb25zIGZvciBlYWNoIG1vZHVsZSB0byBpdHMgc3ViIHRyZWUgYW5kXG4gICAgICAgKiBtZXJnZSB0aGVtIGFsbCBpbnRvIG9uZSBmaW5hbCBtdXRhdGlvbnMgbWFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVkTW9kdWxlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNb2R1bGVNdXRhdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZHVsZU11dGF0aW9ucyh1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IHRoaXMuX21vZHVsZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBtb2R1bGVzW2tleV0gPSB1cGRhdGVkTW9kdWxlc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVwZGF0ZWRNdXRhdGlvbnMgPSB0aGlzLl9jcmVhdGVNb2R1bGVNdXRhdGlvbnMobW9kdWxlcywgW10pO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSBtZXJnZU9iamVjdHMoW3RoaXMuX3Jvb3RNdXRhdGlvbnNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh1cGRhdGVkTXV0YXRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhlbHBlciBtZXRob2QgZm9yIF9zZXR1cE1vZHVsZU11dGF0aW9ucy5cbiAgICAgICAqIFRoZSBtZXRob2QgcmV0cmlldmUgbmVzdGVkIHN1YiBtb2R1bGVzIGFuZFxuICAgICAgICogYmluZCBlYWNoIG11dGF0aW9ucyB0byBpdHMgc3ViIHRyZWUgcmVjdXJzaXZlbHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gbmVzdGVkS2V5c1xuICAgICAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZU1vZHVsZU11dGF0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZU1vZHVsZU11dGF0aW9ucyhtb2R1bGVzLCBuZXN0ZWRLZXlzKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QobW9kdWxlcykpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobW9kdWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1trZXldO1xuICAgICAgICAgIHZhciBuZXdOZXN0ZWRLZXlzID0gbmVzdGVkS2V5cy5jb25jYXQoa2V5KTtcblxuICAgICAgICAgIC8vIHJldHJpZXZlIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgdmFyIG5lc3RlZE11dGF0aW9ucyA9IF90aGlzNC5fY3JlYXRlTW9kdWxlTXV0YXRpb25zKG1vZHVsZS5tb2R1bGVzLCBuZXdOZXN0ZWRLZXlzKTtcblxuICAgICAgICAgIGlmICghbW9kdWxlIHx8ICFtb2R1bGUubXV0YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKG5lc3RlZE11dGF0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYmluZCBtdXRhdGlvbnMgdG8gc3ViIHN0YXRlIHRyZWVcbiAgICAgICAgICB2YXIgbXV0YXRpb25zID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMobW9kdWxlLm11dGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gbW9kdWxlLm11dGF0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIG11dGF0aW9uc1tuYW1lXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHVuZGVmaW5lZCwgW2dldE5lc3RlZFN0YXRlKHN0YXRlLCBuZXdOZXN0ZWRLZXlzKV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBtZXJnZSBtdXRhdGlvbnMgb2YgdGhpcyBtb2R1bGUgYW5kIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhbbXV0YXRpb25zXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkobmVzdGVkTXV0YXRpb25zKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBtdXRhdGlvbiBjaGVjazogaWYgdGhlIHZ1ZXggaW5zdGFuY2UncyBzdGF0ZSBpcyBtdXRhdGVkXG4gICAgICAgKiBvdXRzaWRlIG9mIGEgbXV0YXRpb24gaGFuZGxlciwgd2UgdGhyb3cgZW4gZXJyb3IuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgICAqIGVuZm9yY2VzIGFsbCBtdXRhdGlvbnMgdG8gdGhlIHN0YXRlIHRvIGJlIHRyYWNrYWJsZSBhbmQgaG90LXJlbG9hZGJsZS5cbiAgICAgICAqIEhvd2V2ZXIsIHRoaXMgY29tZXMgYXQgYSBydW4gdGltZSBjb3N0IHNpbmNlIHdlIGFyZSBkb2luZyBhIGRlZXBcbiAgICAgICAqIHdhdGNoIG9uIHRoZSBlbnRpcmUgc3RhdGUgdHJlZSwgc28gaXQgaXMgb25seSBlbmFsYmVkIHdpdGggdGhlXG4gICAgICAgKiBzdHJpY3Qgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNdXRhdGlvbkNoZWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBNdXRhdGlvbkNoZWNrKCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB2YXIgV2F0Y2hlciA9IGdldFdhdGNoZXIodGhpcy5fdm0pO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICAgICAgbmV3IFdhdGNoZXIodGhpcy5fdm0sICdzdGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNS5fZGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIERvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0YXRlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdm0uc3RhdGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1t2dWV4XSBVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS4nKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFN0b3JlO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gaW5zdGFsbChfVnVlKSB7XG4gICAgaWYgKFZ1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFZ1ZSA9IF9WdWVcbiAgICAvLyByZXVzZSBWdWUncyBldmVudCBzeXN0ZW1cbiAgICA7WydvbicsICdvZmYnLCAnb25jZScsICdlbWl0J10uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgU3RvcmUucHJvdG90eXBlW2VdID0gU3RvcmUucHJvdG90eXBlWyckJyArIGVdID0gVnVlLnByb3RvdHlwZVsnJCcgKyBlXTtcbiAgICB9KTtcbiAgICBvdmVycmlkZShWdWUpO1xuICB9XG5cbiAgLy8gYXV0byBpbnN0YWxsIGluIGRpc3QgbW9kZVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICAgIGluc3RhbGwod2luZG93LlZ1ZSk7XG4gIH1cblxuICB2YXIgaW5kZXggPSB7XG4gICAgU3RvcmU6IFN0b3JlLFxuICAgIGluc3RhbGw6IGluc3RhbGxcbiAgfTtcblxuICByZXR1cm4gaW5kZXg7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWV4L2Rpc3QvdnVleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==